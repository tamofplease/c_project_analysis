# 1 "project/radare2/libr/asm/d/xtensa.c"


#include <ctype.h>
#include <stdio.h>
#include <string.h>

struct kv { const char *name; const char *value; };
static struct kv kvs[] = {
  {"rsr","read special register"},
  {"ipf","instruction cache prefetch"},
  {"ufloat.s","convert unsigned fixed to single"},
  {"call4","call PC-relative, rotate window by 4"},
  {"add.n","narrow add"},
  {"bbsi","branch if bit set immediate"},
  {"call0","non-windowed call"},
  {"beqz.n","narrow branch if equal zero"},
  {"floor.s","floor single to fixed"},
  {"add","add"},
  {"break.n","narrow breakpoint"},
  {"call8","call PC-relative, rotate window by 8"},
  {"mulsh","multiply signed high"},
  {"ssa8l","set shift amount for LE byte shift"},
  {"lsiu","load single immediate with update"},
  {"bnez.n","narrow branch if not equal zero"},
  {"maxu","maximum value unsigned"},
  {"ball","branch if all bits set"},
  {"simcall","simulator call"},
  {"diwb","data cache index write back"},
  {"diwbi","data cache index write back invalidate"},
  {"rsync","register read synchronize"},
  {"add.s","add single"},
  {"dhu","data cache hit unlock"},
  {"s16i","store 16-bit"},
  {"extui","extract unsigned immediate"},
  {"dii","data cache index invalidate"},
  {"movsp","move to stack pointer"},
  {"ssa8b","set shift amount for BE byte shift"},
  {"retw.n","narrow windowed return"},
  {"ssl","set shift amount for left shift"},
  {"srli","shift right logical immediate"},
  {"moveqz","move if equal to zero"},
  {"ldinc","load with autoincrement"},
  {"un.s","compare single unordered"},
  {"ssi","store single immediate"},
  {"dpfro","data cache prefetch for read once"},
  {"bltui","branch if less than unsigned immediate"},
  {"rfr","move FR to AR"},
  {"ssr","set shift amount for right shift"},
  {"rdtlb1","read data TLB entry translation"},
  {"bltz","branch if less than zero"},
  {"rdtlb0","read data TLB entry virtual"},
  {"bbc","branch if bit clear"},
  {"ssx","store single indexed"},
  {"bltu","branch if less than unsigned"},
  {"excw","exception wait"},
  {"clamps","signed clamp"},
  {"j","unconditional jump"},
  {"diu","data cache index unlock"},
  {"movgez","move if greater than or equal to zero"},
  {"rfe","return from exception"},
  {"rur","read user register"},
  {"ssiu","store single immediate with update"},
  {"wer","write external register"},
  {"rfi","return from high-priority interrupt"},
  {"bbci","branch if bit clear immediate"},
  {"loopgtz","loop if greater than zero"},
  {"s8i","store 8-bit"},
  {"blti","branch if less than immediate"},
  {"iii","instruction cache index invalidate"},
  {"bbs","branch if bit set"},
  {"sll","shift left logical"},
  {"or","bitwise logical or"},
  {"mull","multiply low"},
  {"iiu","instruction cache index unlock"},
  {"neg","negate"},
  {"mov.s","move single"},
  {"max","maximum value"},
  {"bbci.l","branch if bit clear immediate LE"},
  {"mov.n","narrow move"},
  {"bgei","branch if greater than or equal immediate"},
  {"rfde","return from double exception"},
  {"rfdd","return from debug and dispatch"},
  {"wsr","write special register"},
  {"ssai","set shift amount immediate"},
  {"iitlb","invalidate instruction TLB entry"},
  {"bgeu","branch if greater than or equal unsigned"},
  {"rfme","return from memory error"},
  {"abs","absolute value"},
  {"rfdo","return from debug operation"},
  {"movt.s","move single if true"},
  {"xsr","exchange special register"},
  {"sdct","store data cache tag"},
  {"sra","shift right arithmetic"},
  {"ihi","instruction cache hit invalidate"},
  {"orb","boolean or"},
  {"src","shift right combined"},
  {"srl","shift right logical"},
  {"bgez","branch if greater than or equal to zero"},
  {"ihu","instruction cache hit unlock"},
  {"blt","branch if less than"},
  {"remu","remainder unsigned"},
  {"idtlb","invalidate data TLB entry"},
  {"rems","remainder signed"},
  {"abs.s","absolute value single"},
  {"min","minimum value"},
  {"extw","external wait"},
  {"rfwo","return from window overflow"},
  {"ule.s","compare single unord or less than or equal"},
  {"andb","boolean and"},
  {"s32ri","store 32-bit release"},
  {"beqz","branch if equal to zero"},
  {"sub","subtract"},
  {"rfwu","return from window underflow"},
  {"bany","branch if any bit set"},
  {"slli","shift left logical immediate"},
  {"addmi","add immediate with shift by 8"},
  {"sub.s","subtract single"},
  {"lsx","load single indexed"},
  {"subx8","subtract with shift by 3"},
  {"mov","move"},
  {"l32ai","load 32-bit acquire"},
  {"beqi","branch if equal immediate"},
  {"l16si","load 16-bit signed"},
  {"waiti","wait for interrupt"},
  {"rsil","read and set interrupt level"},
  {"subx2","subtract with shift by 1"},
  {"loop","loop"},
  {"subx4","subtract with shift by 2"},
  {"wur","write user register"},
  {"s32e","store 32-bit for window exceptions"},
  {"lsi","load single immediate"},
  {"minu","minimum value unsigned"},
  {"wdtlb","write data TLB entry"},
  {"bnall","branch if not-all bits set"},
  {"pitlb","probe instruction TLB"},
  {"isync","instruction fetch synchronize"},
  {"beq","branch if equal"},
  {"dpfw","data cache prefetch for write"},
  {"addx8","add with shift by 3"},
  {"ult.s","compare single unordered or less than"},
  {"l32i.n","narrow load 32-bit"},
  {"jx","unconditional jump register"},
  {"s32i","store 32-bit"},
  {"bgeui","i branch if greater than or equal unsigned immediate"},
  {"addx4","add with shift by 2"},
  {"dpfr","data cache prefetch for read"},
  {"addx2","add with shift by 1"},
  {"orbc","boolean or with complement"},
  {"rfue","return from user-mode exception"},
  {"srai","shift right arithmetic immediate"},
  {"lsxu","load single indexed with update"},
  {"bf","branch if false"},
  {"sict","store instruction cache tag"},
  {"xorb","boolean exclusive or"},
  {"dhwbi","data cache hit writeback invalidate"},
  {"bne","branch if not equal"},
  {"sicw","store instruction cache word"},
  {"licw","load instruction cache word"},
  {"addi.n","narrow add immediate"},
  {"dpfl","data cache prefetch and lock"},
  {"lict","load instruction cache tag"},
  {"madd.s","multiply and add single"},
  {"mul.s","multiply single"},
  {"ssxu","store single indexed with update"},
  {"nop.n","narrow no-operation"},
  {"wfr","move AR to FR"},
  {"xor","bitwise logical exclusive or"},
  {"bt","branch if true"},
  {"l8ui","load 8-bit unsigned"},
  {"movf.s","move single if false"},
  {"ceil.s","ceiling single to fixed"},
  {"neg.s","negate single"},
  {"olt.s","compare single ordered and less than"},
  {"loopnez","loop if not-equal zero"},
  {"bnei","branch if not equal immediate"},
  {"l16ui","load 16-bit unsigned"},
  {"oeq.s","compare single equal"},
  {"bbsi.l","branch if bit set immediate LE"},
  {"nsau","normalization shift amount unsigned"},
  {"l32i","load 32-bit"},
  {"addi","add immediate"},
  {"andbc","boolean and with complement"},
  {"movt","move if true"},
  {"muluh","multiply unsigned high"},
  {"movnez","move if not-equal to zero"},
  {"break","breakpoint"},
  {"and","bitwise logical and"},
  {"movnez.s","move single if not equal to zero"},
  {"witlb","write instruction TLB entry"},
  {"ueq.s","compare single unordered or equal"},
  {"l32e","load 32-bit for window exceptions"},
  {"bnez","branch if not-equal to zero"},
  {"nop","no-operation"},
  {"trunc.s","truncate single to fixed"},
  {"all4","all 4 booleans true"},
  {"movgez.s","move single if greater than or equal to zero"},
  {"movf","move if false"},
  {"rotw","rotate window"},
  {"movi","move immediate"},
  {"ritlb0","read instruction TLB entry virtual"},
  {"ret.n","narrow non-windowed return"},
  {"ritlb1","read instruction TLB entry translation"},
  {"dsync","load/store synchronize"},
  {"utrunc.s","truncate single to fixed unsigned"},
  {"l32r","load 32-bit PC-relative"},
  {"movi.n","narrow move immediate"},
  {"movltz","move if less than zero"},
  {"dhwb","data cache hit writeback"},
  {"bnone","branch if no bit set"},
  {"s32c1i","store 32-bit compare conditional"},
  {"all8","all 8 booleans true"},
  {"sext","sign extend"},
  {"dpfwo","data cache prefetch for write once"},
  {"callx12","call register, rotate window by 12"},
  {"float.s","convert fixed to single"},
  {"j.l","unconditional jump long"},
  {"lddec","load with autodecrement"},
  {"ole.s","compare single ordered and less than or equal"},
  {"entry","subroutine entry"},
  {"mul16u","multiply 16-bit unsigned"},
  {"mul16s","multiply 16-bit signed"},
  {"moveqz.s","move single if equal to zero"},
  {"bge","branch if greater than or equal"},
  {"msub.s","multiply and subtract single"},
  {"retw","windowed return"},
  {"ill.n","narrow illegal instruction"},
  {"movltz.s","move single if less than zero"},
  {"s32i.n","narrow store 32-bit"},
  {"rer","read external register"},
  {"ill","illegal instruction"},
  {"memw","memory wait"},
  {"pdtlb","probe data tlb"},
  {"ret","non-windowed return"},
  {"syscall","system call"},
  {"round.s","round single to fixed"},
  {"ldct","load data cache tag"},
  {"call12","call PC-relative, rotate window by 12"},
  {"callx8","call register, rotate window by 8"},
  {"nsa","normalization shift amount"},
  {"any4","any 4 booleans true"},
  {"callx4","call register, rotate window by 4"},
  {"any8","any 8 booleans true"},
  {"callx0","non-windowed call register"},
  {"esync","execute synchronize"},
  {"ipfl","instruction cache prefetch and lock"},
  {"dhi","data cache hit invalidate"},
  {"quou","quotient unsigned"},
  {"quos","quotient signed"},
  {NULL, NULL}
};


typedef int (*GperfForeachCallback)(void *user, const char *k, const char *v);
int gperf_xtensa_foreach(GperfForeachCallback cb, void *user) {
  int i = 0; while (kvs[i].name) {
  cb (user, kvs[i].name, kvs[i].value);
  i++;}
  return 0;
}
const char *gperf_xtensa_get(const char *s) {
  int i = 0; while (kvs[i].name) {
  if (!strcmp (s, kvs[i].name)) return kvs[i].value;
  i++;}
  return NULL;
}
#define sdb_hash_c_xtensa(x,y) gperf_xtensa_hash(x)
const unsigned int gperf_xtensa_hash(const char *s) {
  int sum = strlen (s);
  while (*s) { sum += *s; s++; }
  return sum;
}
struct {const char *name;void *get;void *hash;void *foreach;} gperf_xtensa = {
  .name = "xtensa",
  .get = &gperf_xtensa_get,
  .hash = &gperf_xtensa_hash,
  .foreach = &gperf_xtensa_foreach
};

#if MAIN
int main () {
 const char *s = ((char*(*)(char*))gperf_xtensa.get)("foo");
 printf ("%s\n", s);
}
#endif
