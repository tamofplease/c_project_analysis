# 1 "project/radare2/libr/asm/d/mips.c"


#include <ctype.h>
#include <stdio.h>
#include <string.h>

struct kv { const char *name; const char *value; };
static struct kv kvs[] = {
  {"c.cond.fmt","floating point compare"},
  {"lhu","lhu $t,C($s), loads the halfword stored from: MEM[$s+C] and the following byte."},
  {"dinsu","doubleword insert bit field upper"},
  {"trunc.l.fmt","floating point truncate to long fixed point"},
  {"bgezal","branch on greater than or equal to zero and link"},
  {"add","adds two registers, trap on overflow"},
  {"dext","doubleword extract bit field"},
  {"bc1t","branch on fp true"},
  {"floor.l.fmt","floating point floor convert to long fixed point"},
  {"daddiu","doubleword add immediate unsigned"},
  {"teq","trap if equal"},
  {"cvt.d.fmt","floating point convert to double floating point"},
  {"round.l.fmt","floating point round to long fixed point"},
  {"dinsm","doubleword insert bit field middle"},
  {"dmult","doubleword multiply"},
  {"cvt.s.pl","floating point convert pair lower to single floating point"},
  {"bc1f","branch on fp false"},
  {"nmsub.fmt","floating point negative multiply subtract"},
  {"movf.fmt","floating point move conditional on floating point false"},
  {"divu","divides two registers and puts the 32-bit integer result in LO and the remainder in HI."},
  {"dmtc2","doubleword move to coprocessor 2"},
  {"dmtc1","doubleword move to floating point"},
  {"tgeu","trap if greater or equal unsigned"},
  {"dmtc0","doubleword move to coprocessor 0"},
  {"cvt.s.pu","floating point convert pair upper to single floating point"},
  {"sqrt.fmt","floating point square root"},
  {"bgtz","branch on greater than zero"},
  {"mult","int HI, int LO = (64-bit) $s * $t, trap on overflow"},
  {"round.w.fmt","floating point round to word fixed point"},
  {"mthi","move to hi register"},
  {"b","unconditional branch"},
  {"dmfc1","doubleword move from floating point"},
  {"bltz","branch on less than zero"},
  {"movt.fmt","floating point move conditional on floating point true"},
  {"dmfc0","doubleword move from coprocessor 0"},
  {"recip.fmt","reciprocal approximation"},
  {"dmfc2","doubleword move from coprocessor 2"},
  {"bltzall","branch on less than zero and link likely"},
  {"swxc1","store word indexed from floating point"},
  {"lui","loads a 16-bit immediate operand into the upper 16-bits of the register specified."},
  {"deret","debug exception return"},
  {"tgei","trap if greater or equal immediate"},
  {"j","unconditionally jumps to the instruction at the specified address"},
  {"div","divides two registers and puts the 32-bit integer result in LO and the remainder in HI."},
  {"slt","tests if one register is less than another."},
  {"srlv","srlv $d,$t,$s, shifts $s number of bits to the right - zeros are shifted in"},
  {"tgeiu","trap if greater or equal immediate unsigned"},
  {"seb","sign-extend byte"},
  {"sll","sll $d,$t,shamt, shifts shamt number of bits to the left (multiply but 2^n)"},
  {"or","bitwise or"},
  {"sdbbp","software debug breakpoint"},
  {"cvt.w.fmt","floating point convert to word fixed point"},
  {"wsbh","word swap bytes within halfwords"},
  {"eret","exception return"},
  {"cvt.ps.s","floating point convert pair to paired single"},
  {"ldl","load doubleword left"},
  {"seh","sign-extend halfword"},
  {"dsbh","doubleword swap bytes within halfwords"},
  {"mflo","moves a value from LO to a register"},
  {"ext","extract bit field"},
  {"msub","multiply and subtract word to hi,lo"},
  {"sdr","store doubleword right"},
  {"dsrl32","doubleword shift right logical plus 32"},
  {"suxc1","store doubleword indexed unaligned from floating point"},
  {"pref","prefetch"},
  {"bc2tl","branch on cop2 true likely"},
  {"ori","bitwise or, leftmost 16 bits are padded with 0s"},
  {"daddi","doubleword add immediate"},
  {"mfhc1","move word from high half of floating point register"},
  {"mtc2","move word to coprocessor 2"},
  {"mtc1","move word to floating point"},
  {"mtc0","move to coprocessor 0"},
  {"mfhc2","move word from high half of coprocessor 2 register"},
  {"dsrlv","doubleword shift right logical variable"},
  {"sra","sda $d,$t,shamt, shifts shamt number of bits - the sign bit is shifted in"},
  {"dsll","doubleword shift left logical"},
  {"srl","srl $d,$t,shamt, shifts shamt number of bits to the right - zeros are shifted in."},
  {"bgez","branch on greater than or equal to zero"},
  {"sllv","sllv $d,$t,$s, shifts $s number of bits to the left"},
  {"neg.fmt","floating point negate"},
  {"daddu","doubleword add unsigned"},
  {"rdpgpr","read gpr from previous shadow set"},
  {"ddivu","doubleword divide unsigned"},
  {"pll.ps","pair lower lower"},
  {"abs.fmt","floating point absolute value"},
  {"ldr","load doubleword right"},
  {"sdi","store doubleword"},
  {"lwc1","load word to floating point"},
  {"trunc.w.fmt","floating point truncate to word fixed point"},
  {"tltiu","trap if less than immediate unsigned"},
  {"sdl","store doubleword left"},
  {"lwc2","load word to coprocessor 2"},
  {"lld","load linked doubleword"},
  {"bc1fl","branch on fp false likely"},
  {"li","load immediate (pseudoinstruction)"},
  {"bgezall","branch on greater than or equal to zero and link likely"},
  {"lh","lh $t,C($s), loads the halfword stored from: MEM[$s+C] and the following byte, sign is extended to width of register."},
  {"bgezl","branch on greater than or equal to zero likely"},
  {"ll","load linked word"},
  {"andi","bitwise and, leftmost 16 bits are padded with 0s"},
  {"dextm","doubleword extract bit field middle"},
  {"dsubu","doubleword subtract unsigned"},
  {"bltzal","branch on less than zero and link"},
  {"lb","lb $t,C($s), loads the byte stored from: MEM[$s+C], sign is extended to width of register"},
  {"sub","subtracts two registers, trap on overflow"},
  {"ld","load doubleword"},
  {"dmultu","doubleword multiply unsigned"},
  {"jr.hb","jump register with hazard barrier"},
  {"dsub","doubleword subtract"},
  {"dsra","doubleword shift right arithmetic"},
  {"puu.ps","pair upper upper"},
  {"bc2fl","branch on cop2 false likely"},
  {"mul","multiply word to gpr"},
  {"tlbwi","write indexed tlb entry"},
  {"floor.w.fmt","floating point floor convert to word fixed point"},
  {"sw","sw $t,C($s), stores a word into: MEM[$s+C] and the following 3 bytes."},
  {"cop2","coprocessor operation to coprocessor 2"},
  {"dsrl","doubleword shift right logical"},
  {"add.fmt","floating point add"},
  {"lw","lw $t,C($s), loads the word stored from: MEM[$s+C] and the following 3 bytes."},
  {"dextu","doubleword extract bit field upper"},
  {"slti","tests if one register is less than a constant."},
  {"beql","branch on equal likely"},
  {"ehb","execution hazard barrier"},
  {"mthc2","move word to high half of coprocessor 2 register"},
  {"mthc1","move word to high half of floating point register"},
  {"mfc1","move word from floating point"},
  {"mfc0","move from coprocessor 0"},
  {"sdc1","store doubleword from floating point"},
  {"sb","sb $t,C($s), stores the least-significant 8-bit of a register (a byte) into: MEM[$s+C]."},
  {"sc","store a word to memory."},
  {"mfc2","move word from coprocessor 2"},
  {"dins","doubleword insert bit field"},
  {"sdc2","store doubleword from coprocessor 2"},
  {"jalr","jump and link register"},
  {"tlbwr","write random tlb entry"},
  {"di","disable interrupts"},
  {"cvt.s.fmt","floating point convert to single floating point"},
  {"beq","beq $s,$t,C, goes to the instruction at the specified address if two registers are equal."},
  {"div.fmt","floating point divide"},
  {"sdxc1","store doubleword indexed from floating point"},
  {"sh","sh $t,C($s), stores the least-significant 16-bit of a register (a halfword) into: MEM[$s+C]."},
  {"sltu","tests if one register is less than an unsigned constant."},
  {"ctc1","move control word to floating point"},
  {"blezl","branch on less than or equal to zero likely"},
  {"ctc2","move control word to coprocessor 2"},
  {"jr","jumps to the address contained in the specified register"},
  {"subu","subtracts two registers"},
  {"blez","branch if the register is less than or equal to zero."},
  {"drotr32","doubleword rotate right plus 32"},
  {"movn.fmt","floating point move conditional on not zero"},
  {"sub.fmt","floating point subtract"},
  {"mtcZ","moves a 4 byte value from a general purpose register to a Coprocessor Z Control register. Sign extension."},
  {"plu.ps","pair lower upper"},
  {"dsllv","doubleword shift left logical variable"},
  {"multu","int HI, int LO = (64-bit) $s * $t"},
  {"srav","srav $d,$t,$s, shifts $s number of bits - the sign bit is shifted in"},
  {"bne","branch on not equal"},
  {"cvt.l.fmt","floating point convert to long fixed point"},
  {"jal","used to call a subroutine, $31 holds the return address; returning from a subroutine is done by: jr $31. Return address is PC + 8, not PC + 4 due to the use of a branch delay slot which forces the instruction after the jump to be executed"},
  {"madd","multiply and add word to hi,lo"},
  {"xori","bitwise xor with a constant"},
  {"ei","enable interrupts"},
  {"ceil.l.fmt","fixed point ceiling convert to long fixed point"},
  {"xor","bitwise xor"},
  {"mov.fmt","floating point move"},
  {"bnel","branch on not equal likely"},
  {"alnv.ps","floating point align variable"},
  {"tlbr","read indexed tlb entry"},
  {"msubu","multiply and subtract word to hi,lo"},
  {"tlbp","probe tlb for matching entry"},
  {"swl","store word left"},
  {"ins","insert bit field"},
  {"lbu","load byte unsigned"},
  {"nmadd.fmt","floating point negative multiply add"},
  {"addi","add sign-extended constants (or copy one register to another: addi $1, $2, 0), trap on overflow"},
  {"swr","store word right"},
  {"tne","trap if not equal"},
  {"movt","move conditional on floating point true"},
  {"mfhi","moves a value from HI to a register"},
  {"addu","adds two registers"},
  {"break","breakpoint"},
  {"and","bitwise and"},
  {"ldc2","load doubleword to coprocessor 2"},
  {"prefx","prefetch indexed"},
  {"tnei","trap if not equal immediate"},
  {"movz","conditional move."},
  {"mtlo","move to lo register"},
  {"ldc1","load doubleword to floating point"},
  {"luxc1","load doubleword indexed unaligned to floating point"},
  {"nop","no operation"},
  {"bgtzl","branch on greater than zero likely"},
  {"nor","bitwise nor"},
  {"clo","count leading ones in word"},
  {"move","moves a register value into another register (pseudoinstruction)."},
  {"rsqrt.fmt","reciprocal square root approximation"},
  {"bneq","goes to the instruction at the specified address if two registers are not equal."},
  {"sync","synchronize shared memory"},
  {"movf","move conditional on floating point false"},
  {"wrpgpr","write to gpr in previous shadow set"},
  {"synci","synchronize caches to make instruction writes effective"},
  {"rotr","rotate word right"},
  {"clz","count leading zeros in word"},
  {"bc1tl","branch on fp true likely"},
  {"tlti","trap if less than immediate"},
  {"movn","conditional move."},
  {"cfc2","move control word from coprocessor 2"},
  {"cfc1","move control word from floating point"},
  {"movz.fmt","floating point move conditional on zero"},
  {"rdhwr","read hardware register"},
  {"teqi","trap if equal immediate"},
  {"mul.fmt","floating point multiply"},
  {"mfcZ","moves a 4 byte value from Coprocessor Z Control register to a general purpose register. Sign extension."},
  {"lwxc1","load word indexed to floating point"},
  {"cache","perform cache operation."},
  {"drotr","doubleword rotate right"},
  {"dclo","count leading ones in doubleword"},
  {"tlt","trap if less than"},
  {"scd","store conditional doubleword"},
  {"drotrv","doubleword rotate right variable"},
  {"swc2","store word from coprocessor 2"},
  {"tltu","trap if less than unsigned"},
  {"rotrv","rotate word right variable"},
  {"swc1","store word from floating point"},
  {"ssnop","superscalar no operation"},
  {"jraddiusp","increment stackpointer and jump to ra register"},
  {"dsrav","doubleword shift right arithmetic variable"},
  {"syscall","system call"},
  {"tge","trap if greater or equal"},
  {"ldxc1","load doubleword indexed to floating point"},
  {"jalr.hb","jump and link register with hazard barrier"},
  {"dclz","count leading zeros in doubleword"},
  {"lwu","load word unsigned"},
  {"lwr","load word right"},
  {"msub.fmt","floating point multiply subtract"},
  {"madd.fmt","floating point multiply add"},
  {"dshd","doubleword swap halfwords within doublewords"},
  {"bltzl","branch on less than zero likely"},
  {"bc2t","branch on cop2 true"},
  {"bal","branch and link"},
  {"pul.ps","pair upper lower"},
  {"lwl","load word left"},
  {"ddiv","doubleword divide"},
  {"dsll32","doubleword shift left logical plus 32"},
  {"dsra32","doubleword shift right arithmetic plus 32"},
  {"dadd","doubleword add"},
  {"addiu","add sign-extended constants (or copy one register to another: addi $1, $2, 0)"},
  {"maddu","multiply and add unsigned word to hi,lo"},
  {"ceil.w.fmt","floating point ceiling convert to word fixed point"},
  {"bc2f","branch on cop2 false"},
  {"sltiu","set on less than immediate unsigned"},
  {"wait","enter standby mode"},
  {NULL, NULL}
};


typedef int (*GperfForeachCallback)(void *user, const char *k, const char *v);
int gperf_mips_foreach(GperfForeachCallback cb, void *user) {
  int i = 0; while (kvs[i].name) {
  cb (user, kvs[i].name, kvs[i].value);
  i++;}
  return 0;
}
const char *gperf_mips_get(const char *s) {
  int i = 0; while (kvs[i].name) {
  if (!strcmp (s, kvs[i].name)) return kvs[i].value;
  i++;}
  return NULL;
}
#define sdb_hash_c_mips(x,y) gperf_mips_hash(x)
const unsigned int gperf_mips_hash(const char *s) {
  int sum = strlen (s);
  while (*s) { sum += *s; s++; }
  return sum;
}
struct {const char *name;void *get;void *hash;void *foreach;} gperf_mips = {
  .name = "mips",
  .get = &gperf_mips_get,
  .hash = &gperf_mips_hash,
  .foreach = &gperf_mips_foreach
};

#if MAIN
int main () {
 const char *s = ((char*(*)(char*))gperf_mips.get)("foo");
 printf ("%s\n", s);
}
#endif
