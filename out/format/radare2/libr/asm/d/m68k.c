# 1 "project/radare2/libr/asm/d/m68k.c"


#include <ctype.h>
#include <stdio.h>
#include <string.h>

struct kv { const char *name; const char *value; };
static struct kv kvs[] = {
  {"subq","subtract quick"},
  {"eori","logical exclusive-or immediate"},
  {"rol","rotate left"},
  {"fsmove","move floating-point register double precision"},
  {"pflusha","flush entry(ies) in the atcs"},
  {"movep","move peripheral"},
  {"cmp","compare"},
  {"moveq","move quick"},
  {"or","logical inclusive-or"},
  {"moves","move address space"},
  {"fgetman","floating-point get mantissa"},
  {"pvalid","validate a pointer"},
  {"andi","logical and immediate"},
  {"trapcc","trap conditionally"},
  {"subx","subtract with extend"},
  {"link","link and allocate"},
  {"fmovem","move multiple floating-point registers"},
  {"ftanh","hyperbolic tangent"},
  {"fetox","floating-point ex"},
  {"and","logical and"},
  {"fmovecr","move constant rom"},
  {"fsglmul","single-precision multiply"},
  {"fsneg","floating-point negate single precision"},
  {"unpk","unpack bcd"},
  {"movea","move address"},
  {"fsabs","floating-point absolute value single precision"},
  {"chk2","check register against upper and lower bounds"},
  {"movec","move control register"},
  {"divu","unsigned divide"},
  {"fsinh","hyperbolic sine"},
  {"extb","sign extend"},
  {"pscc","set on pmmu condition"},
  {"movem","move multiple registers"},
  {"roxl","rotate with extend left"},
  {"divs","signed divide"},
  {"pload*","load an entry into the atc"},
  {"pflush","flush entry(ies) in the atcs"},
  {"fsincos","simultaneous sine and cosine"},
  {"fssub","floating-point subtract single precision"},
  {"ori","logical inclusive-or immediate"},
  {"callm","call module"},
  {"roxr","rotate with extend right"},
  {"pack","pack bcd"},
  {"cinv","invalidate cache entries"},
  {"reset","reset external devices"},
  {"neg","negate"},
  {"clr","clear"},
  {"fintrz","floating-point integer part, round-to-zero"},
  {"fdsqrt","floating-point square root double precision"},
  {"cmp2","compare register against upper and lower bounds"},
  {"ftentox","floating-point 10x"},
  {"jsr","jump to subroutine"},
  {"facos","floating-point arc cosine"},
  {"adda","add address"},
  {"fadd","floating-point add"},
  {"frem","ieee remainder"},
  {"cprestore","coprocessor restore function"},
  {"cpgen","coprocessor general function"},
  {"flog10","floating-point log10"},
  {"add","add"},
  {"addi","add immediate"},
  {"flogn","floating-point loge"},
  {"tas","test operand and set"},
  {"jmp","jump"},
  {"addq","add quick"},
  {"fcos","floating-point cosine"},
  {"illegal","take illegal instruction trap"},
  {"cas2","compare and swap dual operands"},
  {"trapv","trap on overflow"},
  {"addx","add with extend"},
  {"not","logical complement"},
  {"cptracpcc","trap on coprocessor condition"},
  {"nop","no operation"},
  {"bfffo","bit field find first one"},
  {"fatan","floating-point arc tangent"},
  {"bfclr","test bit field and clear"},
  {"fdbcc","floating-point decrement and branch"},
  {"pflush*","invalidate entries in the atc"},
  {"fatanh","floating-point hyperbolic arc tangent"},
  {"fddiv","floating-point divide double precision"},
  {"fdmul","floating-point multiply double precision"},
  {"fetoxm","floating-point ex -1"},
  {"fdneg","floating-point negate double precision"},
  {"fsgldiv","single-precision divide"},
  {"pflusha*","invalidate all entries in the atc"},
  {"lea","load effective address"},
  {"nbcd","negate decimal with extend"},
  {"fsmul","floating-point multiply single precision"},
  {"psave","pmmu save function"},
  {"negx","negate with extend"},
  {"abcd","add decimal with extend"},
  {"pdbcc","test, decrement, and branch on pmmu condition"},
  {"rte","return from exception"},
  {"rtd","return and deallocate"},
  {"bchg","test bit and change"},
  {"fsqrt","floating-point square root"},
  {"fscale","floating-point scale exponent"},
  {"trap","trap"},
  {"fscc","floating-point set according to condition"},
  {"muls","signed multiply"},
  {"rtm","return from module"},
  {"pmove","move pmmu register"},
  {"ftwotox","floating-point 2x"},
  {"swap","swap register words"},
  {"mulu","unsigned multiply"},
  {"rts","return from subroutine"},
  {"fbcc","floating-point branch"},
  {"rtr","return and restore"},
  {"fcmp","floating-point compare"},
  {"cas","compare and swap operands"},
  {"cmpi","compare immediate"},
  {"bfexts","signed bit field extract"},
  {"lpstop","low-power stop"},
  {"cptrapcc","trap on coprocessor condition"},
  {"bfextu","unsigned bit field extract"},
  {"bgnd","enter background mode"},
  {"tblsn","signed table lookup with interpolate"},
  {"cmpm","compare memory to memory"},
  {"bset","test bit and set"},
  {"fcosh","floating-point hyperbolic cosine"},
  {"fsave","save floating-point internal state"},
  {"cmpa","compare address"},
  {"move","move"},
  {"sub","subtract"},
  {"fnop","floating-point no operation"},
  {"prestore","pmmu restore function"},
  {"cpsave","coprocessor save function"},
  {"asr","arithmetic shift  right"},
  {"scc","set conditionally"},
  {"bcc","branch conditionally"},
  {"chk","check register against bound"},
  {"ptrapcc","trap on pmmu condition"},
  {"ftan","tangent"},
  {"ftrapcc","floating-point trap on condition"},
  {"divsl","signed divide"},
  {"bra","branch"},
  {"fasin","floating-point arc sine"},
  {"asl","arithmetic shift left"},
  {"ftst","floating-point test"},
  {"cpbcc","branch on coprocessor condition"},
  {"cpscc","set on coprocessor condition"},
  {"tblun","unsigned table lookup with interpolate"},
  {"fgetexp","floating-point get exponent"},
  {"btst","test bit"},
  {"lsr","logical shift right"},
  {"tblu","unsigned table lookup with interpolate"},
  {"unlk","unlink"},
  {"dbcc","test condition, decrement and branch"},
  {"tbls","unsigned table lookup with interpolate"},
  {"bsr","branch to subroutine"},
  {"bfchg","test bit field and change"},
  {"fsin","sine"},
  {"lsl","logical shift left"},
  {"fdfabs","floating-point absolute value double precision"},
  {"fdsub","floating-point subtract double precision"},
  {"fmove","move floating-point register"},
  {"fsdiv","floating-point divide simple precision"},
  {"ptest","test a logical address"},
  {"ext","sign extend"},
  {"fint","floating-point integer part"},
  {"fdabs","floating-point absolute value double precision"},
  {"bftst","test bit field"},
  {"fmod","floating-point modulo remainder"},
  {"stop","stop"},
  {"fmul","floating-point multiply"},
  {"move16","16-byte block move"},
  {"fsfabs","floating-point absolute value single precision"},
  {"exg","exchange registers"},
  {"fneg","floating-point negate"},
  {"fdiv","floating-point divide"},
  {"tst","test operand"},
  {"fsadd","floating-point add single"},
  {"pload","load an entry into the atc"},
  {"bkpt","breakpoint"},
  {"eor","logical exclusive-or"},
  {"flognp","floating-point loge (x + 1)"},
  {"fabs","floating-point absolute value"},
  {"bfset","test bit field and set"},
  {"fssqrt","floating-point square root single precision"},
  {"cpush","push then invalidate cache entries"},
  {"divul","unsigned divide"},
  {"frestore","restore floating-point internal state"},
  {"suba","subtract address"},
  {"bfins","bit field insert"},
  {"bclr","test bit and clear"},
  {"pea","push effective address"},
  {"pflushs","flush entry(ies) in the atcs"},
  {"pflushr","flush entry(ies) in the atcs and rpt entries"},
  {"ror","rotate right"},
  {"subi","subtract immediate"},
  {"sbcd","subtract decimal with extend"},
  {"cpdbcc","test coprocessor condition decrement and branch"},
  {"fdadd","floating-point add double precision"},
  {"fdmove","move floating-point register single"},
  {"fsub","floating-point subtract"},
  {"pbcc","branch on pmmu condition"},
  {"flog2","floating-point log2"},
  {NULL, NULL}
};


typedef int (*GperfForeachCallback)(void *user, const char *k, const char *v);
int gperf_m68k_foreach(GperfForeachCallback cb, void *user) {
  int i = 0; while (kvs[i].name) {
  cb (user, kvs[i].name, kvs[i].value);
  i++;}
  return 0;
}
const char *gperf_m68k_get(const char *s) {
  int i = 0; while (kvs[i].name) {
  if (!strcmp (s, kvs[i].name)) return kvs[i].value;
  i++;}
  return NULL;
}
#define sdb_hash_c_m68k(x,y) gperf_m68k_hash(x)
const unsigned int gperf_m68k_hash(const char *s) {
  int sum = strlen (s);
  while (*s) { sum += *s; s++; }
  return sum;
}
struct {const char *name;void *get;void *hash;void *foreach;} gperf_m68k = {
  .name = "m68k",
  .get = &gperf_m68k_get,
  .hash = &gperf_m68k_hash,
  .foreach = &gperf_m68k_foreach
};

#if MAIN
int main () {
 const char *s = ((char*(*)(char*))gperf_m68k.get)("foo");
 printf ("%s\n", s);
}
#endif
