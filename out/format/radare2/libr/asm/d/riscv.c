# 1 "project/radare2/libr/asm/d/riscv.c"


#include <ctype.h>
#include <stdio.h>
#include <string.h>

struct kv { const char *name; const char *value; };
static struct kv kvs[] = {
  {"bne","branch if not equal"},
  {"c.addi4spn","add unsigned immediate*4 to stack pointer (compressed instruction)"},
  {"divuw","unsigned division of words (32 bits)"},
  {"or","bitwise OR"},
  {"c.ldsp","load double word (64 bits), SP relative (compressed instruction)"},
  {"fmv.x.s","move integer register to double"},
  {"fsqrt.s","floating-point square root, single precision"},
  {"lb","load byte"},
  {"subw","subtract word (32 bits)"},
  {"bge","branch if greater than"},
  {"ld","load double word (64 bits)"},
  {"andi","bitwise and with immediate"},
  {"fcvt.d.wu","convert to double from unsigned word (32 bits)"},
  {"amomaxu.w","atomic memory operation, unsigned integer maximum (32 bits)"},
  {"c.lui","load upper immediate (compressed instruction)"},
  {"fcvt.l.d","convert to long (64 bits) from double"},
  {"c.fsd","floating-point store, double precision (compressed instruction)"},
  {"auipc","add upper immediate to PC"},
  {"amoor.d","atomic memory operation, bitwise OR (64 bits)"},
  {"c.andi","bitwirse AND with immediate (compressed instruction)"},
  {"and","bitwise and"},
  {"amominu.w","atomic memory operation, unsigned integer minimum (32 bits)"},
  {"mrts","machine redirect trap to supervisor"},
  {"lr.w","load reserved (32 bits)"},
  {"c.jr","jump, register relative (compressed instruction)"},
  {"eret","environment return"},
  {"fmax.s","floating-point maximum, single precision"},
  {"fnmsub.d","floating-point negated multiply-subtract, double precision"},
  {"c.sdsp","store double word (64 bits), SP relative (compressed instruction)"},
  {"c.fld","floating-point load, double precision (compressed instruction)"},
  {"c.srai","shift right arithmetically by immediate (compressed instruction)"},
  {"divw","signed division of words (32 bits)"},
  {"lr","load reserved"},
  {"bgt","branch if greater than"},
  {"divu","unsigned division"},
  {"flt.s","floating-point \""},
  {"lw","load word (32 bits)"},
  {"lr.d","load reserved (64 bits)"},
  {"ori","bitwise OR with immediate"},
  {"c.addw","add 32-bit words (compressed instruction)"},
  {"fcvt.l.s","convert to long (64 bits) from single"},
  {"srlw","shift right logically (32 bits)"},
  {"fnmsub.s","floating-point negated multiply-subtract, single precision"},
  {"c.sw","store word (32 bits) (compressed instruction)"},
  {"amominu.d","atomic memory operation, unsigned integer minimum (64 bits)"},
  {"remw","remainder of division (32 bits)"},
  {"neg","two's complement"},
  {"remu","remainder of unsigned division"},
  {"fsgnjn.s","floating-point negated sign-injection, single precision"},
  {"c.flw","floating-point load, single precision (compressed instruction)"},
  {"flt.d","floating-point \""},
  {"csrrwi","atomic read/write CSR with immediate"},
  {"csrrw","atomic read/write CSR"},
  {"fmax.d","floating-point maximum, double precision"},
  {"j","jump"},
  {"csrrs","atomic read and set bit in CSR"},
  {"xori","exclusive or with immediate"},
  {"add","add"},
  {"c.sd","store double word (64 bits) (compressed instruction)"},
  {"addi","add immediate"},
  {"fcvt.s.lu","convert to single from unsigned long (64 bits)"},
  {"csrrc","atomic read and clear bit in CSR"},
  {"addw","add 32-bit words"},
  {"lwu","load word (32 bits) unsigned"},
  {"mv","copy"},
  {"fsgnjn.d","floating-point negated sign-injection, double precision"},
  {"fnmadd.d","floating-point negated multiply-add, double precision"},
  {"c.fsdsp","floating-point store, double precision, SP relative (compressed instruction)"},
  {"c.addi16sp","add signed immediate*16 to stack pointer (compressed instruction)"},
  {"slliw","shift left logically by immediate (32 bits)"},
  {"rdinstreth","read \""},
  {"not","one's complement"},
  {"amoswap.w","atomic memory operation, swap (32 bits)"},
  {"c.ebreak","environment breakpoint (compressed instruction)"},
  {"rdcycleh","read cycle counter, high half"},
  {"c.addiw","add immediate to 32-bit word (compressed instruction)"},
  {"nop","no operation"},
  {"fnmadd.s","floating-point negated multiply-add, single precision"},
  {"fmin.d","floating-point minimum, double precision"},
  {"fcvt.d.l","convert to double from long (64 bits)"},
  {"rdtime","read real-time clock"},
  {"c.swsp","store word (32 bits), SP relative (compressed instruction)"},
  {"amomin.d","atomic memory operation, signed integer minimum (64 bits)"},
  {"rdcycle","read cycle counter"},
  {"fcvt.d.w","convert to double from word (32 bits)"},
  {"amoswap.d","atomic memory operation, swap (64 bits)"},
  {"fdiv.s","floating-point division, single precision"},
  {"fcvt.wu.d","convert to unsigned word (32 bits) from double"},
  {"fcvt.d.s","convert to double from single"},
  {"fadd.d","floating-point add, double precision"},
  {"sc.w","store conditional (32 bits)"},
  {"srai","shift right arithmetically by immediate"},
  {"fsgnj.s","floating-point sign-injection, single precision"},
  {"amomin.w","atomic memory operation, signed integer minimum (32 bits)"},
  {"fmv.d.x","move double to integer register"},
  {"fmin.s","floating-point minimum, single precision"},
  {"sraw","shift right arithmetically (32 bits)"},
  {"fence.i","instruction cache fence"},
  {"fdiv.d","floating-point division, double precision"},
  {"jalr","jump and link (call); register-based"},
  {"sra","shift right arithmetically"},
  {"fcvt.wu.s","convert to unsigned word (32 bits) from single"},
  {"fcvt.w.s","convert to word (32 bits) from single"},
  {"c.xor","exclusive OR (compressed instruction)"},
  {"fsgnj.d","floating-point sign-injection, double precision"},
  {"srl","shift right logically"},
  {"feq.s","floating-point \""},
  {"jr","jump register"},
  {"negw","two's complement word"},
  {"mulw","multiply word (32 bits)"},
  {"sc.d","store conditional (64 bits)"},
  {"addiw","add immediate to 32-bit word"},
  {"c.srli","shift right logically by immediate (compressed instruction)"},
  {"fcvt.w.d","convert to word (32 bits) from double"},
  {"fadd.s","floating-point add, single precision"},
  {"ecall","environment call"},
  {"c.beqz","branch if equal to zero (compressed instruction)"},
  {"c.or","bitwise OR (compressed instruction)"},
  {"lbu","load byte, unsigned"},
  {"fsw","floating-point store word (single precision value)"},
  {"feq.d","floating-point \""},
  {"fle.d","floating-point \""},
  {"sfence.vm","supervisor-mode fence for virtual memory"},
  {"mulh","multiply, high half"},
  {"amoadd.d","atomic memory operation, add (64 bits)"},
  {"fmsub.d","floating-point multiply-subtract, double precision"},
  {"sw","store word (32 bits)"},
  {"c.subw","subtract words (32 bits) (compressed instruction)"},
  {"sub","subtract"},
  {"c.fldsp","floating-point load, double precision, SP relative (compressed instruction)"},
  {"c.fswsp","floating-point store, single precision, SP relative (compressed instruction)"},
  {"fclass.d","classify floating point number, double precision"},
  {"mul","multiply"},
  {"lui","load upper immediate"},
  {"bgeu","branch if greater than, unsigned"},
  {"div","signed division"},
  {"fcvt.s.w","convert to single from word (32 bits)"},
  {"fsd","floating-point store double"},
  {"fmv.s.x","move single to integer register"},
  {"ebreak","environment breakpoint"},
  {"fclass.s","classify floating point number, single precision"},
  {"c.sub","subtract (compressed instruction)"},
  {"amoadd.w","atomic memory operation, add (32 bits)"},
  {"sd","store double word (64 bits)"},
  {"seqz","set if equal to zero"},
  {"c.and","bitwise AND (compressed instruction)"},
  {"sb","store byte"},
  {"amoxor.d","atomic memory operation,"},
  {"sc","store conditional"},
  {"fle.s","floating-point \""},
  {"bgez","branch if greater than or equal to zero"},
  {"fmsub.s","floating-point multiply-subtract, single precision"},
  {"rdinstret","read \""},
  {"fcvt.s.d","convert to single from double"},
  {"fmadd.d","floating-point multiply-add, double precision"},
  {"sh","store half-word (16 bits)"},
  {"fcvt.s.l","convert to single from long (64 bits)"},
  {"fld","floating-point load double"},
  {"lhu","load half-word (16 bits), unsigned"},
  {"sgtz","set if greater than zero"},
  {"c.mv","move (compressed instruction)"},
  {"amoxor.w","atomic memory operation,"},
  {"fmadd.s","floating-point multiply-add, single precision"},
  {"csrrsi","atomic read and set immediate bit in CSR"},
  {"bltz","branch if less than zero"},
  {"slti","set if less than immediate"},
  {"flw","floating-point load word"},
  {"bltu","branch if less than, unsigned"},
  {"c.ld","load double word (64 bits) (compressed instruction)"},
  {"fsgnjx.d","floating-point XOR sign-injection, double precision"},
  {"sltiu","set if less than immediate, unsigned"},
  {"sllw","shift left logically (32 bits)"},
  {"blez","branch if less than or equal to zero"},
  {"sltz","set if less than zero"},
  {"rdtimeh","read real-time clock, high half"},
  {"fcvt.lu.s","convert to unsigned long (64 bits) from single"},
  {"fmul.s","floating-point multiply, single precision"},
  {"bgtu","branch if greater than, unsigned"},
  {"jal","jump and link (call)"},
  {"bleu","branch if less than or equal to, unsigned"},
  {"c.lwsp","load word (32 bits), SP relative (compressed instruction)"},
  {"rem","remainder of division"},
  {"c.li","load immediate (compressed instruction)"},
  {"c.bnez","branch if not equal to zero (compressed instruction)"},
  {"sltu","set if less than, unsigned"},
  {"amomax.w","atomic memory operation, signed integer maximum (32 bits)"},
  {"c.lw","load word (32 bits) (compressed instruction)"},
  {"ble","branch if less than or equal to"},
  {"fence","memory fence"},
  {"amoand.d","atomic memory operation, bitwise AND (64 bits)"},
  {"bgtz","branch if greater than zero"},
  {"c.flwsp","floating-point load, single precision, SP relative (compressed instruction)"},
  {"fsgnjx.s","floating-point XOR sign-injection, single precision"},
  {"mulhsu","multiply signed*unsigned, high half"},
  {"fmul.d","floating-point multiply, double precision"},
  {"mulhu","multiply unsigned, high half"},
  {"amomax.d","atomic memory operation, signed integer maximum (64 bits)"},
  {"sraiw","shift right arithmetically by immediate (32 bits)"},
  {"fcvt.lu.d","convert to unsigned long (64 bits) from double"},
  {"remuw","remainder of unsigned division (32 bits)"},
  {"hrts","hypervisor redirect trap to supervisor"},
  {"amoand.w","atomic memory operation, bitwise AND (32 bits)"},
  {"slli","shift left logically by immediate"},
  {"fsub.d","floating-point subtract, double precision"},
  {"blt","branch if less than"},
  {"beq","branch if equal"},
  {"c.jalr","jump and link, register relative (compressed instruction)"},
  {"csrrci","atomic read and clear immediate bit in CSR"},
  {"beqz","branch if equal to zero"},
  {"fcvt.s.wu","convert to single from unsigned word (32 bits)"},
  {"fsub.s","floating-point subtract, single precision"},
  {"snez","set if not equal to zero"},
  {"slt","set if less than"},
  {"fcvt.d.lu","convert to double from unsigned long (64 bits)"},
  {"c.j","jump (compressed instruction)"},
  {"mrth","machine redirect trap to hypervisor"},
  {"xor","exclusive or"},
  {"fmv.x.d","move integer register to double"},
  {"c.add","add (compressed instruction)"},
  {"c.slli","logical left shift by immediate (compressed instruction)"},
  {"c.jal","jump and link (compressed instruction)"},
  {"amomaxu.d","atomic memory operation, unsigned integer maximum (64 bits)"},
  {"sll","shift left logically"},
  {"fsqrt.d","floating-point square root, double precision"},
  {"li","load immediate"},
  {"lh","load half-word (16 bits)"},
  {"amoor.w","atomic memory operation, bitwise OR (32 bits)"},
  {"bnez","branch if not equal to zero"},
  {"c.fsw","floating-point store, single precision (compressed instruction)"},
  {"wfi","wait for interrupt"},
  {"srliw","shift right logically by immediate (32 bits)"},
  {"c.addi","add immediate  (compressed instruction)"},
  {"srli","shift right logically by immediate"},
  {NULL, NULL}
};


typedef int (*GperfForeachCallback)(void *user, const char *k, const char *v);
int gperf_riscv_foreach(GperfForeachCallback cb, void *user) {
  int i = 0; while (kvs[i].name) {
  cb (user, kvs[i].name, kvs[i].value);
  i++;}
  return 0;
}
const char *gperf_riscv_get(const char *s) {
  int i = 0; while (kvs[i].name) {
  if (!strcmp (s, kvs[i].name)) return kvs[i].value;
  i++;}
  return NULL;
}
#define sdb_hash_c_riscv(x,y) gperf_riscv_hash(x)
const unsigned int gperf_riscv_hash(const char *s) {
  int sum = strlen (s);
  while (*s) { sum += *s; s++; }
  return sum;
}
struct {const char *name;void *get;void *hash;void *foreach;} gperf_riscv = {
  .name = "riscv",
  .get = &gperf_riscv_get,
  .hash = &gperf_riscv_hash,
  .foreach = &gperf_riscv_foreach
};

#if MAIN
int main () {
 const char *s = ((char*(*)(char*))gperf_riscv.get)("foo");
 printf ("%s\n", s);
}
#endif
