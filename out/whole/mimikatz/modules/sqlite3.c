# 0 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 0 "<built-in>"
#define __STDC__ 1
# 0 "<built-in>"
#define __STDC_VERSION__ 201710L
# 0 "<built-in>"
#define __STDC_UTF_16__ 1
# 0 "<built-in>"
#define __STDC_UTF_32__ 1
# 0 "<built-in>"
#define __STDC_HOSTED__ 1
# 0 "<built-in>"
#define __GNUC__ 12
# 0 "<built-in>"
#define __GNUC_MINOR__ 2
# 0 "<built-in>"
#define __GNUC_PATCHLEVEL__ 0
# 0 "<built-in>"
#define __VERSION__ "12.2.0"
# 0 "<built-in>"
#define __ATOMIC_RELAXED 0
# 0 "<built-in>"
#define __ATOMIC_SEQ_CST 5
# 0 "<built-in>"
#define __ATOMIC_ACQUIRE 2
# 0 "<built-in>"
#define __ATOMIC_RELEASE 3
# 0 "<built-in>"
#define __ATOMIC_ACQ_REL 4
# 0 "<built-in>"
#define __ATOMIC_CONSUME 1
# 0 "<built-in>"
#define __pic__ 2
# 0 "<built-in>"
#define __PIC__ 2
# 0 "<built-in>"
#define __FINITE_MATH_ONLY__ 0
# 0 "<built-in>"
#define _LP64 1
# 0 "<built-in>"
#define __LP64__ 1
# 0 "<built-in>"
#define __SIZEOF_INT__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_SHORT__ 2
# 0 "<built-in>"
#define __SIZEOF_FLOAT__ 4
# 0 "<built-in>"
#define __SIZEOF_DOUBLE__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_DOUBLE__ 8
# 0 "<built-in>"
#define __SIZEOF_SIZE_T__ 8
# 0 "<built-in>"
#define __CHAR_BIT__ 8
# 0 "<built-in>"
#define __BIGGEST_ALIGNMENT__ 16
# 0 "<built-in>"
#define __ORDER_LITTLE_ENDIAN__ 1234
# 0 "<built-in>"
#define __ORDER_BIG_ENDIAN__ 4321
# 0 "<built-in>"
#define __ORDER_PDP_ENDIAN__ 3412
# 0 "<built-in>"
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __SIZEOF_POINTER__ 8
# 0 "<built-in>"
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
# 0 "<built-in>"
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
# 0 "<built-in>"
#define __SIZE_TYPE__ long unsigned int
# 0 "<built-in>"
#define __PTRDIFF_TYPE__ long int
# 0 "<built-in>"
#define __WCHAR_TYPE__ int
# 0 "<built-in>"
#define __WINT_TYPE__ int
# 0 "<built-in>"
#define __INTMAX_TYPE__ long int
# 0 "<built-in>"
#define __UINTMAX_TYPE__ long unsigned int
# 0 "<built-in>"
#define __CHAR16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __CHAR32_TYPE__ unsigned int
# 0 "<built-in>"
#define __SIG_ATOMIC_TYPE__ int
# 0 "<built-in>"
#define __INT8_TYPE__ signed char
# 0 "<built-in>"
#define __INT16_TYPE__ short int
# 0 "<built-in>"
#define __INT32_TYPE__ int
# 0 "<built-in>"
#define __INT64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_LEAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_LEAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_LEAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_LEAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_LEAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_LEAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_LEAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_LEAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_FAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_FAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_FAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_FAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_FAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_FAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INTPTR_TYPE__ long int
# 0 "<built-in>"
#define __UINTPTR_TYPE__ long unsigned int
# 0 "<built-in>"
#define __GXX_ABI_VERSION 1017
# 0 "<built-in>"
#define __SCHAR_MAX__ 0x7f
# 0 "<built-in>"
#define __SHRT_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __LONG_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __WCHAR_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
# 0 "<built-in>"
#define __WINT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WINT_MIN__ (-__WINT_MAX__ - 1)
# 0 "<built-in>"
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __SIZE_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __SCHAR_WIDTH__ 8
# 0 "<built-in>"
#define __SHRT_WIDTH__ 16
# 0 "<built-in>"
#define __INT_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_WIDTH__ 64
# 0 "<built-in>"
#define __LONG_LONG_WIDTH__ 64
# 0 "<built-in>"
#define __WCHAR_WIDTH__ 32
# 0 "<built-in>"
#define __WINT_WIDTH__ 32
# 0 "<built-in>"
#define __PTRDIFF_WIDTH__ 64
# 0 "<built-in>"
#define __SIZE_WIDTH__ 64
# 0 "<built-in>"
#define __INTMAX_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTMAX_C(c) c ## L
# 0 "<built-in>"
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __UINTMAX_C(c) c ## UL
# 0 "<built-in>"
#define __INTMAX_WIDTH__ 64
# 0 "<built-in>"
#define __SIG_ATOMIC_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
# 0 "<built-in>"
#define __SIG_ATOMIC_WIDTH__ 32
# 0 "<built-in>"
#define __INT8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __UINT8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INT_LEAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT8_C(c) c
# 0 "<built-in>"
#define __INT_LEAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_LEAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT16_C(c) c
# 0 "<built-in>"
#define __INT_LEAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_LEAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT32_C(c) c
# 0 "<built-in>"
#define __INT_LEAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT64_C(c) c ## LL
# 0 "<built-in>"
#define __INT_LEAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_LEAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT8_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT16_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT32_C(c) c ## U
# 0 "<built-in>"
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINT64_C(c) c ## ULL
# 0 "<built-in>"
#define __INT_FAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT_FAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_FAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_FAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_FAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT_FAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_FAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT_FAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT_FAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INTPTR_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTPTR_WIDTH__ 64
# 0 "<built-in>"
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __GCC_IEC_559 2
# 0 "<built-in>"
#define __GCC_IEC_559_COMPLEX 2
# 0 "<built-in>"
#define __FLT_EVAL_METHOD__ 0
# 0 "<built-in>"
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
# 0 "<built-in>"
#define __DEC_EVAL_METHOD__ 2
# 0 "<built-in>"
#define __FLT_RADIX__ 2
# 0 "<built-in>"
#define __FLT_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT_DIG__ 6
# 0 "<built-in>"
#define __FLT_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
# 0 "<built-in>"
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
# 0 "<built-in>"
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
# 0 "<built-in>"
#define __FLT_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMAF 1
# 0 "<built-in>"
#define __FLT_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __DBL_MANT_DIG__ 53
# 0 "<built-in>"
#define __DBL_DIG__ 15
# 0 "<built-in>"
#define __DBL_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __DBL_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __DBL_MAX_EXP__ 1024
# 0 "<built-in>"
#define __DBL_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __DBL_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_NORM_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
# 0 "<built-in>"
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
# 0 "<built-in>"
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
# 0 "<built-in>"
#define __DBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __DBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __DBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMA 1
# 0 "<built-in>"
#define __DBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __LDBL_MANT_DIG__ 53
# 0 "<built-in>"
#define __LDBL_DIG__ 15
# 0 "<built-in>"
#define __LDBL_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __LDBL_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __LDBL_MAX_EXP__ 1024
# 0 "<built-in>"
#define __LDBL_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __LDBL_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __LDBL_MAX__ 1.79769313486231570814527423731704357e+308L
# 0 "<built-in>"
#define __LDBL_NORM_MAX__ 1.79769313486231570814527423731704357e+308L
# 0 "<built-in>"
#define __LDBL_MIN__ 2.22507385850720138309023271733240406e-308L
# 0 "<built-in>"
#define __LDBL_EPSILON__ 2.22044604925031308084726333618164062e-16L
# 0 "<built-in>"
#define __LDBL_DENORM_MIN__ 4.94065645841246544176568792868221372e-324L
# 0 "<built-in>"
#define __LDBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __LDBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __LDBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMAL 1
# 0 "<built-in>"
#define __LDBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT16_MANT_DIG__ 11
# 0 "<built-in>"
#define __FLT16_DIG__ 3
# 0 "<built-in>"
#define __FLT16_MIN_EXP__ (-13)
# 0 "<built-in>"
#define __FLT16_MIN_10_EXP__ (-4)
# 0 "<built-in>"
#define __FLT16_MAX_EXP__ 16
# 0 "<built-in>"
#define __FLT16_MAX_10_EXP__ 4
# 0 "<built-in>"
#define __FLT16_DECIMAL_DIG__ 5
# 0 "<built-in>"
#define __FLT16_MAX__ 6.55040000000000000000000000000000000e+4F16
# 0 "<built-in>"
#define __FLT16_NORM_MAX__ 6.55040000000000000000000000000000000e+4F16
# 0 "<built-in>"
#define __FLT16_MIN__ 6.10351562500000000000000000000000000e-5F16
# 0 "<built-in>"
#define __FLT16_EPSILON__ 9.76562500000000000000000000000000000e-4F16
# 0 "<built-in>"
#define __FLT16_DENORM_MIN__ 5.96046447753906250000000000000000000e-8F16
# 0 "<built-in>"
#define __FLT16_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT16_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT16_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT16_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT32_DIG__ 6
# 0 "<built-in>"
#define __FLT32_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT32_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT32_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT32_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT32_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
# 0 "<built-in>"
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
# 0 "<built-in>"
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
# 0 "<built-in>"
#define __FLT32_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMAF32 1
# 0 "<built-in>"
#define __FLT32_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT64_DIG__ 15
# 0 "<built-in>"
#define __FLT64_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT64_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT64_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT64_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT64_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
# 0 "<built-in>"
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
# 0 "<built-in>"
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
# 0 "<built-in>"
#define __FLT64_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMAF64 1
# 0 "<built-in>"
#define __FLT64_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT128_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT128_DIG__ 33
# 0 "<built-in>"
#define __FLT128_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT128_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT128_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT128_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT128_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
# 0 "<built-in>"
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
# 0 "<built-in>"
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
# 0 "<built-in>"
#define __FLT128_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT128_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT128_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT128_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32X_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT32X_DIG__ 15
# 0 "<built-in>"
#define __FLT32X_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT32X_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT32X_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT32X_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT32X_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
# 0 "<built-in>"
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
# 0 "<built-in>"
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
# 0 "<built-in>"
#define __FLT32X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FP_FAST_FMAF32x 1
# 0 "<built-in>"
#define __FLT32X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64X_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT64X_DIG__ 33
# 0 "<built-in>"
#define __FLT64X_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT64X_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT64X_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT64X_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT64X_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT64X_MAX__ 1.18973149535723176508575932662800702e+4932F64x
# 0 "<built-in>"
#define __FLT64X_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F64x
# 0 "<built-in>"
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
# 0 "<built-in>"
#define __FLT64X_EPSILON__ 1.92592994438723585305597794258492732e-34F64x
# 0 "<built-in>"
#define __FLT64X_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F64x
# 0 "<built-in>"
#define __FLT64X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __REGISTER_PREFIX__ 
# 0 "<built-in>"
#define __USER_LABEL_PREFIX__ _
# 0 "<built-in>"
#define __GNUC_STDC_INLINE__ 1
# 0 "<built-in>"
#define __NO_INLINE__ 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_16 1
# 0 "<built-in>"
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_INT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
# 0 "<built-in>"
#define __GCC_DESTRUCTIVE_SIZE 256
# 0 "<built-in>"
#define __GCC_CONSTRUCTIVE_SIZE 64
# 0 "<built-in>"
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
# 0 "<built-in>"
#define __HAVE_SPECULATION_SAFE_VALUE 1
# 0 "<built-in>"
#define __PRAGMA_REDEFINE_EXTNAME 1
# 0 "<built-in>"
#define __SIZEOF_INT128__ 16
# 0 "<built-in>"
#define __SIZEOF_WCHAR_T__ 4
# 0 "<built-in>"
#define __SIZEOF_WINT_T__ 4
# 0 "<built-in>"
#define __SIZEOF_PTRDIFF_T__ 8
# 0 "<built-in>"
#define __aarch64__ 1
# 0 "<built-in>"
#define __ARM_64BIT_STATE 1
# 0 "<built-in>"
#define __ARM_ARCH_ISA_A64 1
# 0 "<built-in>"
#define __ARM_ALIGN_MAX_PWR 28
# 0 "<built-in>"
#define __ARM_ALIGN_MAX_STACK_PWR 16
# 0 "<built-in>"
#define __ARM_ARCH_8A 1
# 0 "<built-in>"
#define __ARM_ARCH_PROFILE 65
# 0 "<built-in>"
#define __ARM_FEATURE_CLZ 1
# 0 "<built-in>"
#define __ARM_FEATURE_IDIV 1
# 0 "<built-in>"
#define __ARM_FEATURE_UNALIGNED 1
# 0 "<built-in>"
#define __ARM_PCS_AAPCS64 1
# 0 "<built-in>"
#define __ARM_SIZEOF_WCHAR_T 4
# 0 "<built-in>"
#define __GCC_ASM_FLAG_OUTPUTS__ 1
# 0 "<built-in>"
#undef __ARM_FP_FAST
# 0 "<built-in>"
#define __ARM_ARCH 8
# 0 "<built-in>"
#define __ARM_SIZEOF_MINIMAL_ENUM 4
# 0 "<built-in>"
#undef __AARCH64EB__
# 0 "<built-in>"
#undef __ARM_BIG_ENDIAN
# 0 "<built-in>"
#define __AARCH64EL__ 1
# 0 "<built-in>"
#define __ARM_FEATURE_FMA 1
# 0 "<built-in>"
#define __ARM_FP 14
# 0 "<built-in>"
#define __ARM_FP16_FORMAT_IEEE 1
# 0 "<built-in>"
#define __ARM_FP16_ARGS 1
# 0 "<built-in>"
#undef __ARM_FEATURE_FP16_SCALAR_ARITHMETIC
# 0 "<built-in>"
#undef __ARM_FEATURE_FP16_VECTOR_ARITHMETIC
# 0 "<built-in>"
#define __ARM_FEATURE_NUMERIC_MAXMIN 1
# 0 "<built-in>"
#define __ARM_NEON 1
# 0 "<built-in>"
#undef __ARM_FEATURE_CRC32
# 0 "<built-in>"
#undef __ARM_FEATURE_DOTPROD
# 0 "<built-in>"
#undef __ARM_FEATURE_COMPLEX
# 0 "<built-in>"
#undef __ARM_FEATURE_JCVT
# 0 "<built-in>"
#undef __AARCH64_CMODEL_TINY__
# 0 "<built-in>"
#undef __AARCH64_CMODEL_SMALL__
# 0 "<built-in>"
#undef __AARCH64_CMODEL_LARGE__
# 0 "<built-in>"
#define __AARCH64_CMODEL_SMALL__ 1
# 0 "<built-in>"
#undef _ILP32
# 0 "<built-in>"
#undef __ILP32__
# 0 "<built-in>"
#undef __ARM_FEATURE_CRYPTO
# 0 "<built-in>"
#undef __ARM_FEATURE_QRDMX
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE_BITS
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE_VECTOR_OPERATORS
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE_MATMUL_INT8
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE_MATMUL_FP32
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE_MATMUL_FP64
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE2
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE2_AES
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE2_BITPERM
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE2_SHA3
# 0 "<built-in>"
#undef __ARM_FEATURE_SVE2_SM4
# 0 "<built-in>"
#undef __ARM_FEATURE_ATOMICS
# 0 "<built-in>"
#undef __ARM_FEATURE_AES
# 0 "<built-in>"
#undef __ARM_FEATURE_SHA2
# 0 "<built-in>"
#undef __ARM_FEATURE_SHA3
# 0 "<built-in>"
#undef __ARM_FEATURE_SHA512
# 0 "<built-in>"
#undef __ARM_FEATURE_SM3
# 0 "<built-in>"
#undef __ARM_FEATURE_SM4
# 0 "<built-in>"
#undef __ARM_FEATURE_FP16_FML
# 0 "<built-in>"
#undef __ARM_FEATURE_FRINT
# 0 "<built-in>"
#undef __ARM_FEATURE_TME
# 0 "<built-in>"
#undef __ARM_FEATURE_RNG
# 0 "<built-in>"
#undef __ARM_FEATURE_MEMORY_TAGGING
# 0 "<built-in>"
#undef __ARM_FEATURE_BTI_DEFAULT
# 0 "<built-in>"
#undef __ARM_FEATURE_PAC_DEFAULT
# 0 "<built-in>"
#undef __ARM_FEATURE_MATMUL_INT8
# 0 "<built-in>"
#undef __ARM_FEATURE_BF16_VECTOR_ARITHMETIC
# 0 "<built-in>"
#undef __ARM_FEATURE_BF16_SCALAR_ARITHMETIC
# 0 "<built-in>"
#undef __ARM_FEATURE_LS64
# 0 "<built-in>"
#undef __FLT_EVAL_METHOD__
# 0 "<built-in>"
#define __FLT_EVAL_METHOD__ 0
# 0 "<built-in>"
#undef __FLT_EVAL_METHOD_C99__
# 0 "<built-in>"
#define __FLT_EVAL_METHOD_C99__ 0
# 0 "<built-in>"
#define __LITTLE_ENDIAN__ 1
# 0 "<built-in>"
#define __arm64 1
# 0 "<built-in>"
#define __arm64__ 1
# 0 "<built-in>"
#define __MACH__ 1
# 0 "<built-in>"
#define __APPLE__ 1
# 0 "<built-in>"
#define __APPLE_CC__ 1
# 0 "<built-in>"
#define __CONSTANT_CFSTRINGS__ 1
# 0 "<built-in>"
#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 120000
# 0 "<built-in>"
#define __strong 
# 0 "<built-in>"
#define __weak 
# 0 "<command-line>"
#define __DYNAMIC__ 1
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 20 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_CORE 1
#define SQLITE_AMALGAMATION 1

#define SQLITE_PRIVATE static
# 55 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define CTIMEOPT_VAL_(opt) #opt
#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)




#define CTIMEOPT_VAL2_(opt1,opt2) #opt1 "," #opt2
#define CTIMEOPT_VAL2(opt) CTIMEOPT_VAL2_(opt)
# 72 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char * const sqlite3azCompileOpt[] = {
# 111 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  "COMPILER=gcc-" "12.2.0",
# 751 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  "THREADSAFE=1",
# 783 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};

static const char **sqlite3CompileOptions(int *pnOpt){
  *pnOpt = sizeof(sqlite3azCompileOpt) / sizeof(sqlite3azCompileOpt[0]);
  return (const char**)sqlite3azCompileOpt;
}
# 809 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITEINT_H 
# 843 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_TCLAPI 
# 869 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MSVC_H 
# 931 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OS_VXWORKS 0
#define HAVE_FCHOWN 1
#define HAVE_READLINK 1
#define HAVE_LSTAT 1
# 965 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define _LARGE_FILE 1

#define _FILE_OFFSET_BITS 64

#define _LARGEFILE_SOURCE 1
# 986 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define GCC_VERSION (__GNUC__*1000000+__GNUC_MINOR__*1000+__GNUC_PATCHLEVEL__)






#define MSVC_VERSION 0




#define _GNU_SOURCE 
# 1076 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE3_H 
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdarg.h" 1
# 20 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdarg.h"
#define _INC_STDARG 

# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h" 1
# 20 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTIMP 




#define _INC_CRTDEFS 



#define __STR2WSTR(str) L ##str
#define _STR2WSTR(str) __STR2WSTR(str)



#define __FILEW__ _STR2WSTR(__FILE__)



#define __FUNCTIONW__ _STR2WSTR(__FUNCTION__)
# 58 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_NOFORCE_MANIFEST 





#define _CRTEXP 


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h" 1

#define SPECSTRINGS_H 
# 30 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _SAL_VERSION_SAL2(_A) 






#define _SAL_VERSION_CHECK(_A) 



#define SAL_VERSION_CHECK(_A) _SAL_VERSION_CHECK(_A)
#define SAL_VERSION_SAL2(_A) _SAL_VERSION_SAL2(_A)
# 54 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _SAL_L_Source_(Name,args,annotes) _SA_annotes3(SAL_name, #Name, "", "2") _GrouP_(annotes _SAL_nop_impl_)






# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h" 1
# 14 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
       
# 146 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __ATTR_SAL 


#define _SAL_VERSION 20



#define __SAL_H_VERSION 180000000
# 192 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _USE_DECLSPECS_FOR_SAL 0


#define _USE_ATTRIBUTES_FOR_SAL 0
# 228 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _SAL1_Source_(Name,args,annotes) _SA_annotes3(SAL_name, #Name, "", "1") _Group_(annotes _SAL_nop_impl_)
#define _SAL1_1_Source_(Name,args,annotes) _SA_annotes3(SAL_name, #Name, "", "1.1") _Group_(annotes _SAL_nop_impl_)
#define _SAL1_2_Source_(Name,args,annotes) _SA_annotes3(SAL_name, #Name, "", "1.2") _Group_(annotes _SAL_nop_impl_)
#define _SAL2_Source_(Name,args,annotes) _SA_annotes3(SAL_name, #Name, "", "2") _Group_(annotes _SAL_nop_impl_)
# 250 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _At_(target,annos) _At_impl_(target, annos _SAL_nop_impl_)





#define _At_buffer_(target,iter,bound,annos) _At_buffer_impl_(target, iter, bound, annos _SAL_nop_impl_)



#define _When_(expr,annos) _When_impl_(expr, annos _SAL_nop_impl_)
#define _Group_(annos) _Group_impl_(annos _SAL_nop_impl_)
#define _GrouP_(annos) _GrouP_impl_(annos _SAL_nop_impl_)


#define _Success_(expr) _SAL2_Source_(_Success_, (expr), _Success_impl_(expr))



#define _Return_type_success_(expr) _SAL2_Source_(_Return_type_success_, (expr), _Success_impl_(expr))


#define _On_failure_(annos) _On_failure_impl_(annos _SAL_nop_impl_)



#define _Always_(annos) _Always_impl_(annos _SAL_nop_impl_)




#define _Use_decl_annotations_ _Use_decl_anno_impl_




#define _Notref_ _Notref_impl_


#define _Pre_defensive_ _SA_annotes0(SAL_pre_defensive)
#define _Post_defensive_ _SA_annotes0(SAL_post_defensive)

#define _In_defensive_(annotes) _Pre_defensive_ _Group_(annotes _SAL_nop_impl_)
#define _Out_defensive_(annotes) _Post_defensive_ _Group_(annotes _SAL_nop_impl_)
#define _Inout_defensive_(annotes) _Pre_defensive_ _Post_defensive_ _Group_(annotes _SAL_nop_impl_)






#define _Reserved_ _SAL2_Source_(_Reserved_, (), _Pre1_impl_(__null_impl))



#define _Const_ _SAL2_Source_(_Const_, (), _Pre1_impl_(__readaccess_impl_notref))
# 314 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _In_ _SAL2_Source_(_In_, (), _Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_ _Deref_pre1_impl_(__readaccess_impl_notref))
#define _In_opt_ _SAL2_Source_(_In_opt_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_ _Deref_pre_readonly_)



#define _In_z_ _SAL2_Source_(_In_z_, (), _In_ _Pre1_impl_(__zterm_impl))
#define _In_opt_z_ _SAL2_Source_(_In_opt_z_, (), _In_opt_ _Pre1_impl_(__zterm_impl))




#define _In_reads_(size) _SAL2_Source_(_In_reads_, (size), _Pre_count_(size) _Deref_pre_readonly_)
#define _In_reads_opt_(size) _SAL2_Source_(_In_reads_opt_, (size), _Pre_opt_count_(size) _Deref_pre_readonly_)
#define _In_reads_bytes_(size) _SAL2_Source_(_In_reads_bytes_, (size), _Pre_bytecount_(size) _Deref_pre_readonly_)
#define _In_reads_bytes_opt_(size) _SAL2_Source_(_In_reads_bytes_opt_, (size), _Pre_opt_bytecount_(size) _Deref_pre_readonly_)
#define _In_reads_z_(size) _SAL2_Source_(_In_reads_z_, (size), _In_reads_(size) _Pre_z_)
#define _In_reads_opt_z_(size) _SAL2_Source_(_In_reads_opt_z_, (size), _Pre_opt_count_(size) _Deref_pre_readonly_ _Pre_opt_z_)
#define _In_reads_or_z_(size) _SAL2_Source_(_In_reads_or_z_, (size), _In_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))
#define _In_reads_or_z_opt_(size) _SAL2_Source_(_In_reads_or_z_opt_, (size), _In_opt_ _When_(_String_length_(_Curr_) < (size), _Pre_z_) _When_(_String_length_(_Curr_) >= (size), _Pre1_impl_(__count_impl(size))))




#define _In_reads_to_ptr_(ptr) _SAL2_Source_(_In_reads_to_ptr_, (ptr), _Pre_ptrdiff_count_(ptr) _Deref_pre_readonly_)
#define _In_reads_to_ptr_opt_(ptr) _SAL2_Source_(_In_reads_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_)
#define _In_reads_to_ptr_z_(ptr) _SAL2_Source_(_In_reads_to_ptr_z_, (ptr), _In_reads_to_ptr_(ptr) _Pre_z_)
#define _In_reads_to_ptr_opt_z_(ptr) _SAL2_Source_(_In_reads_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_count_(ptr) _Deref_pre_readonly_ _Pre_opt_z_)
# 351 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Out_ _SAL2_Source_(_Out_, (), _Out_impl_)
#define _Out_opt_ _SAL2_Source_(_Out_opt_, (), _Out_opt_impl_)

#define _Out_writes_(size) _SAL2_Source_(_Out_writes_, (size), _Pre_cap_(size) _Post_valid_impl_)
#define _Out_writes_opt_(size) _SAL2_Source_(_Out_writes_opt_, (size), _Pre_opt_cap_(size) _Post_valid_impl_)
#define _Out_writes_bytes_(size) _SAL2_Source_(_Out_writes_bytes_, (size), _Pre_bytecap_(size) _Post_valid_impl_)
#define _Out_writes_bytes_opt_(size) _SAL2_Source_(_Out_writes_bytes_opt_, (size), _Pre_opt_bytecap_(size) _Post_valid_impl_)
#define _Out_writes_z_(size) _SAL2_Source_(_Out_writes_z_, (size), _Pre_cap_(size) _Post_valid_impl_ _Post_z_)
#define _Out_writes_opt_z_(size) _SAL2_Source_(_Out_writes_opt_z_, (size), _Pre_opt_cap_(size) _Post_valid_impl_ _Post_z_)

#define _Out_writes_to_(size,count) _SAL2_Source_(_Out_writes_to_, (size,count), _Pre_cap_(size) _Post_valid_impl_ _Post_count_(count))
#define _Out_writes_to_opt_(size,count) _SAL2_Source_(_Out_writes_to_opt_, (size,count), _Pre_opt_cap_(size) _Post_valid_impl_ _Post_count_(count))
#define _Out_writes_all_(size) _SAL2_Source_(_Out_writes_all_, (size), _Out_writes_to_(_Old_(size), _Old_(size)))
#define _Out_writes_all_opt_(size) _SAL2_Source_(_Out_writes_all_opt_, (size), _Out_writes_to_opt_(_Old_(size), _Old_(size)))

#define _Out_writes_bytes_to_(size,count) _SAL2_Source_(_Out_writes_bytes_to_, (size,count), _Pre_bytecap_(size) _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_writes_bytes_to_opt_(size,count) _SAL2_Source_(_Out_writes_bytes_to_opt_, (size,count), _Pre_opt_bytecap_(size) _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_writes_bytes_all_(size) _SAL2_Source_(_Out_writes_bytes_all_, (size), _Out_writes_bytes_to_(_Old_(size), _Old_(size)))
#define _Out_writes_bytes_all_opt_(size) _SAL2_Source_(_Out_writes_bytes_all_opt_, (size), _Out_writes_bytes_to_opt_(_Old_(size), _Old_(size)))

#define _Out_writes_to_ptr_(ptr) _SAL2_Source_(_Out_writes_to_ptr_, (ptr), _Pre_ptrdiff_cap_(ptr) _Post_valid_impl_)
#define _Out_writes_to_ptr_opt_(ptr) _SAL2_Source_(_Out_writes_to_ptr_opt_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_)
#define _Out_writes_to_ptr_z_(ptr) _SAL2_Source_(_Out_writes_to_ptr_z_, (ptr), _Pre_ptrdiff_cap_(ptr) _Post_valid_impl_ Post_z_)
#define _Out_writes_to_ptr_opt_z_(ptr) _SAL2_Source_(_Out_writes_to_ptr_opt_z_, (ptr), _Pre_opt_ptrdiff_cap_(ptr) _Post_valid_impl_ Post_z_)
# 384 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Inout_ _SAL2_Source_(_Inout_, (), _Prepost_valid_)
#define _Inout_opt_ _SAL2_Source_(_Inout_opt_, (), _Prepost_opt_valid_)



#define _Inout_z_ _SAL2_Source_(_Inout_z_, (), _Prepost_z_)
#define _Inout_opt_z_ _SAL2_Source_(_Inout_opt_z_, (), _Prepost_opt_z_)


#define _Inout_updates_(size) _SAL2_Source_(_Inout_updates_, (size), _Pre_cap_(size) _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_opt_(size) _SAL2_Source_(_Inout_updates_opt_, (size), _Pre_opt_cap_(size) _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_z_(size) _SAL2_Source_(_Inout_updates_z_, (size), _Pre_cap_(size) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))
#define _Inout_updates_opt_z_(size) _SAL2_Source_(_Inout_updates_opt_z_, (size), _Pre_opt_cap_(size) _Pre_valid_impl_ _Post_valid_impl_ _Pre1_impl_(__zterm_impl) _Post1_impl_(__zterm_impl))

#define _Inout_updates_to_(size,count) _SAL2_Source_(_Inout_updates_to_, (size,count), _Out_writes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))
#define _Inout_updates_to_opt_(size,count) _SAL2_Source_(_Inout_updates_to_opt_, (size,count), _Out_writes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__count_impl(size)))

#define _Inout_updates_all_(size) _SAL2_Source_(_Inout_updates_all_, (size), _Inout_updates_to_(_Old_(size), _Old_(size)))
#define _Inout_updates_all_opt_(size) _SAL2_Source_(_Inout_updates_all_opt_, (size), _Inout_updates_to_opt_(_Old_(size), _Old_(size)))


#define _Inout_updates_bytes_(size) _SAL2_Source_(_Inout_updates_bytes_, (size), _Pre_bytecap_(size) _Pre_valid_impl_ _Post_valid_impl_)
#define _Inout_updates_bytes_opt_(size) _SAL2_Source_(_Inout_updates_bytes_opt_, (size), _Pre_opt_bytecap_(size) _Pre_valid_impl_ _Post_valid_impl_)

#define _Inout_updates_bytes_to_(size,count) _SAL2_Source_(_Inout_updates_bytes_to_, (size,count), _Out_writes_bytes_to_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))
#define _Inout_updates_bytes_to_opt_(size,count) _SAL2_Source_(_Inout_updates_bytes_to_opt_, (size,count), _Out_writes_bytes_to_opt_(size,count) _Pre_valid_impl_ _Pre1_impl_(__bytecount_impl(size)))

#define _Inout_updates_bytes_all_(size) _SAL2_Source_(_Inout_updates_bytes_all_, (size), _Inout_updates_bytes_to_(_Old_(size), _Old_(size)))
#define _Inout_updates_bytes_all_opt_(size) _SAL2_Source_(_Inout_updates_bytes_all_opt_, (size), _Inout_updates_bytes_to_opt_(_Old_(size), _Old_(size)))
# 433 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Outptr_ _SAL2_Source_(_Outptr_, (), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(1)))
#define _Outptr_result_maybenull_ _SAL2_Source_(_Outptr_result_maybenull_, (), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))
#define _Outptr_opt_ _SAL2_Source_(_Outptr_opt_, (), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(1)))
#define _Outptr_opt_result_maybenull_ _SAL2_Source_(_Outptr_opt_result_maybenull_, (), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(1)))



#define _Outptr_result_z_ _SAL2_Source_(_Outptr_result_z_, (), _Out_impl_ _Deref_post_z_)
#define _Outptr_opt_result_z_ _SAL2_Source_(_Outptr_opt_result_z_, (), _Out_opt_impl_ _Deref_post_z_)
#define _Outptr_result_maybenull_z_ _SAL2_Source_(_Outptr_result_maybenull_z_, (), _Out_impl_ _Deref_post_opt_z_)
#define _Outptr_opt_result_maybenull_z_ _SAL2_Source_(_Outptr_opt_result_maybenull_z_, (), _Out_opt_impl_ _Deref_post_opt_z_)



#define _Outptr_result_nullonfailure_ _SAL2_Source_(_Outptr_result_nullonfailure_, (), _Outptr_ _On_failure_(_Deref_post_null_))
#define _Outptr_opt_result_nullonfailure_ _SAL2_Source_(_Outptr_opt_result_nullonfailure_, (), _Outptr_opt_ _On_failure_(_Deref_post_null_))






#define _COM_Outptr_ _SAL2_Source_(_COM_Outptr_, (), _Outptr_ _On_failure_(_Deref_post_null_))
#define _COM_Outptr_result_maybenull_ _SAL2_Source_(_COM_Outptr_result_maybenull_, (), _Outptr_result_maybenull_ _On_failure_(_Deref_post_null_))
#define _COM_Outptr_opt_ _SAL2_Source_(_COM_Outptr_opt_, (), _Outptr_opt_ _On_failure_(_Deref_post_null_))
#define _COM_Outptr_opt_result_maybenull_ _SAL2_Source_(_COM_Outptr_opt_result_maybenull_, (), _Outptr_opt_result_maybenull_ _On_failure_(_Deref_post_null_))



#define _Outptr_result_buffer_(size) _SAL2_Source_(_Outptr_result_buffer_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))
#define _Outptr_opt_result_buffer_(size) _SAL2_Source_(_Outptr_opt_result_buffer_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __cap_impl(size)))
#define _Outptr_result_buffer_to_(size,count) _SAL2_Source_(_Outptr_result_buffer_to_, (size, count), _Out_impl_ _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))
#define _Outptr_opt_result_buffer_to_(size,count) _SAL2_Source_(_Outptr_opt_result_buffer_to_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __cap_impl(size), __count_impl(count)))

#define _Outptr_result_buffer_all_(size) _SAL2_Source_(_Outptr_result_buffer_all_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))
#define _Outptr_opt_result_buffer_all_(size) _SAL2_Source_(_Outptr_opt_result_buffer_all_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __count_impl(size)))

#define _Outptr_result_buffer_maybenull_(size) _SAL2_Source_(_Outptr_result_buffer_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))
#define _Outptr_opt_result_buffer_maybenull_(size) _SAL2_Source_(_Outptr_opt_result_buffer_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __cap_impl(size)))
#define _Outptr_result_buffer_to_maybenull_(size,count) _SAL2_Source_(_Outptr_result_buffer_to_maybenull_, (size, count), _Out_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))
#define _Outptr_opt_result_buffer_to_maybenull_(size,count) _SAL2_Source_(_Outptr_opt_result_buffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __cap_impl(size), __count_impl(count)))

#define _Outptr_result_buffer_all_maybenull_(size) _SAL2_Source_(_Outptr_result_buffer_all_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))
#define _Outptr_opt_result_buffer_all_maybenull_(size) _SAL2_Source_(_Outptr_opt_result_buffer_all_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __count_impl(size)))

#define _Outptr_result_bytebuffer_(size) _SAL2_Source_(_Outptr_result_bytebuffer_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))
#define _Outptr_opt_result_bytebuffer_(size) _SAL2_Source_(_Outptr_opt_result_bytebuffer_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecap_impl(size)))
#define _Outptr_result_bytebuffer_to_(size,count) _SAL2_Source_(_Outptr_result_bytebuffer_to_, (size, count), _Out_impl_ _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))
#define _Outptr_opt_result_bytebuffer_to_(size,count) _SAL2_Source_(_Outptr_opt_result_bytebuffer_to_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__notnull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))

#define _Outptr_result_bytebuffer_all_(size) _SAL2_Source_(_Outptr_result_bytebuffer_all_, (size), _Out_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))
#define _Outptr_opt_result_bytebuffer_all_(size) _SAL2_Source_(_Outptr_opt_result_bytebuffer_all_, (size), _Out_opt_impl_ _Deref_post2_impl_(__notnull_impl_notref, __bytecount_impl(size)))

#define _Outptr_result_bytebuffer_maybenull_(size) _SAL2_Source_(_Outptr_result_bytebuffer_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))
#define _Outptr_opt_result_bytebuffer_maybenull_(size) _SAL2_Source_(_Outptr_opt_result_bytebuffer_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecap_impl(size)))
#define _Outptr_result_bytebuffer_to_maybenull_(size,count) _SAL2_Source_(_Outptr_result_bytebuffer_to_maybenull_, (size, count), _Out_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))
#define _Outptr_opt_result_bytebuffer_to_maybenull_(size,count) _SAL2_Source_(_Outptr_opt_result_bytebuffer_to_maybenull_, (size, count), _Out_opt_impl_ _Deref_post3_impl_(__maybenull_impl_notref, __bytecap_impl(size), __bytecount_impl(count)))

#define _Outptr_result_bytebuffer_all_maybenull_(size) _SAL2_Source_(_Outptr_result_bytebuffer_all_maybenull_, (size), _Out_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))
#define _Outptr_opt_result_bytebuffer_all_maybenull_(size) _SAL2_Source_(_Outptr_opt_result_bytebuffer_all_maybenull_, (size), _Out_opt_impl_ _Deref_post2_impl_(__maybenull_impl_notref, __bytecount_impl(size)))



#define _Outref_ _SAL2_Source_(_Outref_, (), _Out_impl_ _Post_notnull_)
#define _Outref_result_maybenull_ _SAL2_Source_(_Outref_result_maybenull_, (), _Pre2_impl_(__notnull_impl_notref, __cap_c_one_notref_impl) _Post_maybenull_ _Post_valid_impl_)

#define _Outref_result_buffer_(size) _SAL2_Source_(_Outref_result_buffer_, (size), _Outref_ _Post1_impl_(__cap_impl(size)))
#define _Outref_result_bytebuffer_(size) _SAL2_Source_(_Outref_result_bytebuffer_, (size), _Outref_ _Post1_impl_(__bytecap_impl(size)))
#define _Outref_result_buffer_to_(size,count) _SAL2_Source_(_Outref_result_buffer_to_, (size, count), _Outref_result_buffer_(size) _Post1_impl_(__count_impl(count)))
#define _Outref_result_bytebuffer_to_(size,count) _SAL2_Source_(_Outref_result_bytebuffer_to_, (size, count), _Outref_result_bytebuffer_(size) _Post1_impl_(__bytecount_impl(count)))
#define _Outref_result_buffer_all_(size) _SAL2_Source_(_Outref_result_buffer_all_, (size), _Outref_result_buffer_to_(size, _Old_(size)))
#define _Outref_result_bytebuffer_all_(size) _SAL2_Source_(_Outref_result_bytebuffer_all_, (size), _Outref_result_bytebuffer_to_(size, _Old_(size)))

#define _Outref_result_buffer_maybenull_(size) _SAL2_Source_(_Outref_result_buffer_maybenull_, (size), _Outref_result_maybenull_ _Post1_impl_(__cap_impl(size)))
#define _Outref_result_bytebuffer_maybenull_(size) _SAL2_Source_(_Outref_result_bytebuffer_maybenull_, (size), _Outref_result_maybenull_ _Post1_impl_(__bytecap_impl(size)))
#define _Outref_result_buffer_to_maybenull_(size,count) _SAL2_Source_(_Outref_result_buffer_to_maybenull_, (size, count), _Outref_result_buffer_maybenull_(size) _Post1_impl_(__count_impl(count)))
#define _Outref_result_bytebuffer_to_maybenull_(size,count) _SAL2_Source_(_Outref_result_bytebuffer_to_maybenull_, (size, count), _Outref_result_bytebuffer_maybenull_(size) _Post1_impl_(__bytecount_impl(count)))
#define _Outref_result_buffer_all_maybenull_(size) _SAL2_Source_(_Outref_result_buffer_all_maybenull_, (size), _Outref_result_buffer_to_maybenull_(size, _Old_(size)))
#define _Outref_result_bytebuffer_all_maybenull_(size) _SAL2_Source_(_Outref_result_bytebuffer_all_maybenull_, (size), _Outref_result_bytebuffer_to_maybenull_(size, _Old_(size)))



#define _Outref_result_nullonfailure_ _SAL2_Source_(_Outref_result_nullonfailure_, (), _Outref_ _On_failure_(_Post_null_))


#define _Result_nullonfailure_ _SAL2_Source_(_Result_nullonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Post_null_))
#define _Result_zeroonfailure_ _SAL2_Source_(_Result_zeroonfailure_, (), _On_failure_(_Notref_impl_ _Deref_impl_ _Out_range_(==, 0)))
# 530 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Ret_z_ _SAL2_Source_(_Ret_z_, (), _Ret2_impl_(__notnull_impl, __zterm_impl) _Ret_valid_impl_)
#define _Ret_maybenull_z_ _SAL2_Source_(_Ret_maybenull_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)


#define _Ret_notnull_ _SAL2_Source_(_Ret_notnull_, (), _Ret1_impl_(__notnull_impl))
#define _Ret_maybenull_ _SAL2_Source_(_Ret_maybenull_, (), _Ret1_impl_(__maybenull_impl))
#define _Ret_null_ _SAL2_Source_(_Ret_null_, (), _Ret1_impl_(__null_impl))



#define _Ret_valid_ _SAL2_Source_(_Ret_valid_, (), _Ret1_impl_(__notnull_impl_notref) _Ret_valid_impl_)


#define _Ret_writes_(size) _SAL2_Source_(_Ret_writes_, (size), _Ret2_impl_(__notnull_impl, __count_impl(size)) _Ret_valid_impl_)
#define _Ret_writes_z_(size) _SAL2_Source_(_Ret_writes_z_, (size), _Ret3_impl_(__notnull_impl, __count_impl(size), __zterm_impl) _Ret_valid_impl_)
#define _Ret_writes_bytes_(size) _SAL2_Source_(_Ret_writes_bytes_, (size), _Ret2_impl_(__notnull_impl, __bytecount_impl(size)) _Ret_valid_impl_)
#define _Ret_writes_maybenull_(size) _SAL2_Source_(_Ret_writes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__count_impl(size)) _Ret_valid_impl_)
#define _Ret_writes_maybenull_z_(size) _SAL2_Source_(_Ret_writes_maybenull_z_, (size), _Ret3_impl_(__maybenull_impl,__count_impl(size),__zterm_impl) _Ret_valid_impl_)
#define _Ret_writes_bytes_maybenull_(size) _SAL2_Source_(_Ret_writes_bytes_maybenull_, (size), _Ret2_impl_(__maybenull_impl,__bytecount_impl(size)) _Ret_valid_impl_)


#define _Ret_writes_to_(size,count) _SAL2_Source_(_Ret_writes_to_, (size,count), _Ret3_impl_(__notnull_impl, __cap_impl(size), __count_impl(count)) _Ret_valid_impl_)
#define _Ret_writes_bytes_to_(size,count) _SAL2_Source_(_Ret_writes_bytes_to_, (size,count), _Ret3_impl_(__notnull_impl, __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)
#define _Ret_writes_to_maybenull_(size,count) _SAL2_Source_(_Ret_writes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl, __cap_impl(size), __count_impl(count)) _Ret_valid_impl_)
#define _Ret_writes_bytes_to_maybenull_(size,count) _SAL2_Source_(_Ret_writes_bytes_to_maybenull_, (size,count), _Ret3_impl_(__maybenull_impl, __bytecap_impl(size), __bytecount_impl(count)) _Ret_valid_impl_)



#define _Points_to_data_ _SAL2_Source_(_Points_to_data_, (), _Pre_ _Points_to_data_impl_)
#define _Literal_ _SAL2_Source_(_Literal_, (), _Pre_ _Literal_impl_)
#define _Notliteral_ _SAL2_Source_(_Notliteral_, (), _Pre_ _Notliteral_impl_)


#define _Check_return_ _SAL2_Source_(_Check_return_, (), _Check_return_impl_)
#define _Must_inspect_result_ _SAL2_Source_(_Must_inspect_result_, (), _Must_inspect_impl_ _Check_return_impl_)


#define _Printf_format_string_ _SAL2_Source_(_Printf_format_string_, (), _Printf_format_string_impl_)
#define _Scanf_format_string_ _SAL2_Source_(_Scanf_format_string_, (), _Scanf_format_string_impl_)
#define _Scanf_s_format_string_ _SAL2_Source_(_Scanf_s_format_string_, (), _Scanf_s_format_string_impl_)

#define _Format_string_impl_(kind,where) _SA_annotes2(SAL_IsFormatString2, kind, where)
#define _Printf_format_string_params_(x) _SAL2_Source_(_Printf_format_string_params_, (x), _Format_string_impl_("printf", x))
#define _Scanf_format_string_params_(x) _SAL2_Source_(_Scanf_format_string_params_, (x), _Format_string_impl_("scanf", x))
#define _Scanf_s_format_string_params_(x) _SAL2_Source_(_Scanf_s_format_string_params_, (x), _Format_string_impl_("scanf_s", x))


#define _In_range_(lb,ub) _SAL2_Source_(_In_range_, (lb,ub), _In_range_impl_(lb,ub))
#define _Out_range_(lb,ub) _SAL2_Source_(_Out_range_, (lb,ub), _Out_range_impl_(lb,ub))
#define _Ret_range_(lb,ub) _SAL2_Source_(_Ret_range_, (lb,ub), _Ret_range_impl_(lb,ub))
#define _Deref_in_range_(lb,ub) _SAL2_Source_(_Deref_in_range_, (lb,ub), _Deref_in_range_impl_(lb,ub))
#define _Deref_out_range_(lb,ub) _SAL2_Source_(_Deref_out_range_, (lb,ub), _Deref_out_range_impl_(lb,ub))
#define _Deref_ret_range_(lb,ub) _SAL2_Source_(_Deref_ret_range_, (lb,ub), _Deref_ret_range_impl_(lb,ub))
#define _Pre_equal_to_(expr) _SAL2_Source_(_Pre_equal_to_, (expr), _In_range_(==, expr))
#define _Post_equal_to_(expr) _SAL2_Source_(_Post_equal_to_, (expr), _Out_range_(==, expr))



#define _Unchanged_(e) _SAL2_Source_(_Unchanged_, (e), _At_(e, _Post_equal_to_(_Old_(e)) _Const_))




#define _Pre_satisfies_(cond) _SAL2_Source_(_Pre_satisfies_, (cond), _Pre_satisfies_impl_(cond))
#define _Post_satisfies_(cond) _SAL2_Source_(_Post_satisfies_, (cond), _Post_satisfies_impl_(cond))


#define _Struct_size_bytes_(size) _SAL2_Source_(_Struct_size_bytes_, (size), _Writable_bytes_(size))

#define _Field_size_(size) _SAL2_Source_(_Field_size_, (size), _Notnull_ _Writable_elements_(size))
#define _Field_size_opt_(size) _SAL2_Source_(_Field_size_opt_, (size), _Maybenull_ _Writable_elements_(size))
#define _Field_size_part_(size,count) _SAL2_Source_(_Field_size_part_, (size, count), _Notnull_ _Writable_elements_(size) _Readable_elements_(count))
#define _Field_size_part_opt_(size,count) _SAL2_Source_(_Field_size_part_opt_, (size, count), _Maybenull_ _Writable_elements_(size) _Readable_elements_(count))
#define _Field_size_full_(size) _SAL2_Source_(_Field_size_full_, (size), _Field_size_part_(size, size))
#define _Field_size_full_opt_(size) _SAL2_Source_(_Field_size_full_opt_, (size), _Field_size_part_opt_(size, size))

#define _Field_size_bytes_(size) _SAL2_Source_(_Field_size_bytes_, (size), _Notnull_ _Writable_bytes_(size))
#define _Field_size_bytes_opt_(size) _SAL2_Source_(_Field_size_bytes_opt_, (size), _Maybenull_ _Writable_bytes_(size))
#define _Field_size_bytes_part_(size,count) _SAL2_Source_(_Field_size_bytes_part_, (size, count), _Notnull_ _Writable_bytes_(size) _Readable_bytes_(count))
#define _Field_size_bytes_part_opt_(size,count) _SAL2_Source_(_Field_size_bytes_part_opt_, (size, count), _Maybenull_ _Writable_bytes_(size) _Readable_bytes_(count))
#define _Field_size_bytes_full_(size) _SAL2_Source_(_Field_size_bytes_full_, (size), _Field_size_bytes_part_(size, size))
#define _Field_size_bytes_full_opt_(size) _SAL2_Source_(_Field_size_bytes_full_opt_, (size), _Field_size_bytes_part_opt_(size, size))

#define _Field_z_ _SAL2_Source_(_Field_z_, (), _Null_terminated_)

#define _Field_range_(min,max) _SAL2_Source_(_Field_range_, (min,max), _Field_range_impl_(min,max))
# 625 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Pre_ _Pre_impl_
#define _Post_ _Post_impl_





#define _Valid_ _Valid_impl_
#define _Notvalid_ _Notvalid_impl_
#define _Maybevalid_ _Maybevalid_impl_






#define _Readable_bytes_(size) _SAL2_Source_(_Readable_bytes_, (size), _Readable_bytes_impl_(size))
#define _Readable_elements_(size) _SAL2_Source_(_Readable_elements_, (size), _Readable_elements_impl_(size))
#define _Writable_bytes_(size) _SAL2_Source_(_Writable_bytes_, (size), _Writable_bytes_impl_(size))
#define _Writable_elements_(size) _SAL2_Source_(_Writable_elements_, (size), _Writable_elements_impl_(size))

#define _Null_terminated_ _SAL2_Source_(_Null_terminated_, (), _Null_terminated_impl_)
#define _NullNull_terminated_ _SAL2_Source_(_NullNull_terminated_, (), _NullNull_terminated_impl_)


#define _Pre_readable_size_(size) _SAL2_Source_(_Pre_readable_size_, (size), _Pre1_impl_(__count_impl(size)) _Pre_valid_impl_)
#define _Pre_writable_size_(size) _SAL2_Source_(_Pre_writable_size_, (size), _Pre1_impl_(__cap_impl(size)))
#define _Pre_readable_byte_size_(size) _SAL2_Source_(_Pre_readable_byte_size_, (size), _Pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)
#define _Pre_writable_byte_size_(size) _SAL2_Source_(_Pre_writable_byte_size_, (size), _Pre1_impl_(__bytecap_impl(size)))

#define _Post_readable_size_(size) _SAL2_Source_(_Post_readable_size_, (size), _Post1_impl_(__count_impl(size)) _Post_valid_impl_)
#define _Post_writable_size_(size) _SAL2_Source_(_Post_writable_size_, (size), _Post1_impl_(__cap_impl(size)))
#define _Post_readable_byte_size_(size) _SAL2_Source_(_Post_readable_byte_size_, (size), _Post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)
#define _Post_writable_byte_size_(size) _SAL2_Source_(_Post_writable_byte_size_, (size), _Post1_impl_(__bytecap_impl(size)))




#define _Null_ _SAL2_Source_(_Null_, (), _Null_impl_)
#define _Notnull_ _SAL2_Source_(_Notnull_, (), _Notnull_impl_)
#define _Maybenull_ _SAL2_Source_(_Maybenull_, (), _Maybenull_impl_)
# 674 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Pre_z_ _SAL2_Source_(_Pre_z_, (), _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)


#define _Pre_valid_ _SAL2_Source_(_Pre_valid_, (), _Pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_)
#define _Pre_opt_valid_ _SAL2_Source_(_Pre_opt_valid_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)

#define _Pre_invalid_ _SAL2_Source_(_Pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))


#define _Pre_unknown_ _SAL2_Source_(_Pre_unknown_, (), _Pre1_impl_(__maybevalid_impl))


#define _Pre_notnull_ _SAL2_Source_(_Pre_notnull_, (), _Pre1_impl_(__notnull_impl_notref))
#define _Pre_maybenull_ _SAL2_Source_(_Pre_maybenull_, (), _Pre1_impl_(__maybenull_impl_notref))
#define _Pre_null_ _SAL2_Source_(_Pre_null_, (), _Pre1_impl_(__null_impl_notref))
# 697 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Post_z_ _SAL2_Source_(_Post_z_, (), _Post1_impl_(__zterm_impl) _Post_valid_impl_)


#define _Post_valid_ _SAL2_Source_(_Post_valid_, (), _Post_valid_impl_)
#define _Post_invalid_ _SAL2_Source_(_Post_invalid_, (), _Deref_post1_impl_(__notvalid_impl))


#define _Post_ptr_invalid_ _SAL2_Source_(_Post_ptr_invalid_, (), _Post1_impl_(__notvalid_impl))


#define _Post_notnull_ _SAL2_Source_(_Post_notnull_, (), _Post1_impl_(__notnull_impl))


#define _Post_null_ _SAL2_Source_(_Post_null_, (), _Post1_impl_(__null_impl))

#define _Post_maybenull_ _SAL2_Source_(_Post_maybenull_, (), _Post1_impl_(__maybenull_impl))

#define _Prepost_z_ _SAL2_Source_(_Prepost_z_, (), _Pre_z_ _Post_z_)


#pragma region Input Buffer SAL 1 compatibility macros
# 816 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _In_count_(size) _SAL1_1_Source_(_In_count_, (size), _Pre_count_(size) _Deref_pre_readonly_)
#define _In_opt_count_(size) _SAL1_1_Source_(_In_opt_count_, (size), _Pre_opt_count_(size) _Deref_pre_readonly_)
#define _In_bytecount_(size) _SAL1_1_Source_(_In_bytecount_, (size), _Pre_bytecount_(size) _Deref_pre_readonly_)
#define _In_opt_bytecount_(size) _SAL1_1_Source_(_In_opt_bytecount_, (size), _Pre_opt_bytecount_(size) _Deref_pre_readonly_)


#define _In_count_c_(size) _SAL1_1_Source_(_In_count_c_, (size), _Pre_count_c_(size) _Deref_pre_readonly_)
#define _In_opt_count_c_(size) _SAL1_1_Source_(_In_opt_count_c_, (size), _Pre_opt_count_c_(size) _Deref_pre_readonly_)
#define _In_bytecount_c_(size) _SAL1_1_Source_(_In_bytecount_c_, (size), _Pre_bytecount_c_(size) _Deref_pre_readonly_)
#define _In_opt_bytecount_c_(size) _SAL1_1_Source_(_In_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)





#define _In_z_count_(size) _SAL1_1_Source_(_In_z_count_, (size), _Pre_z_ _Pre_count_(size) _Deref_pre_readonly_)
#define _In_opt_z_count_(size) _SAL1_1_Source_(_In_opt_z_count_, (size), _Pre_opt_z_ _Pre_opt_count_(size) _Deref_pre_readonly_)
#define _In_z_bytecount_(size) _SAL1_1_Source_(_In_z_bytecount_, (size), _Pre_z_ _Pre_bytecount_(size) _Deref_pre_readonly_)
#define _In_opt_z_bytecount_(size) _SAL1_1_Source_(_In_opt_z_bytecount_, (size), _Pre_opt_z_ _Pre_opt_bytecount_(size) _Deref_pre_readonly_)


#define _In_z_count_c_(size) _SAL1_1_Source_(_In_z_count_c_, (size), _Pre_z_ _Pre_count_c_(size) _Deref_pre_readonly_)
#define _In_opt_z_count_c_(size) _SAL1_1_Source_(_In_opt_z_count_c_, (size), _Pre_opt_z_ _Pre_opt_count_c_(size) _Deref_pre_readonly_)
#define _In_z_bytecount_c_(size) _SAL1_1_Source_(_In_z_bytecount_c_, (size), _Pre_z_ _Pre_bytecount_c_(size) _Deref_pre_readonly_)
#define _In_opt_z_bytecount_c_(size) _SAL1_1_Source_(_In_opt_z_bytecount_c_, (size), _Pre_opt_z_ _Pre_opt_bytecount_c_(size) _Deref_pre_readonly_)



#define _In_ptrdiff_count_(size) _SAL1_1_Source_(_In_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size) _Deref_pre_readonly_)
#define _In_opt_ptrdiff_count_(size) _SAL1_1_Source_(_In_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size) _Deref_pre_readonly_)



#define _In_count_x_(size) _SAL1_1_Source_(_In_count_x_, (size), _Pre_count_x_(size) _Deref_pre_readonly_)
#define _In_opt_count_x_(size) _SAL1_1_Source_(_In_opt_count_x_, (size), _Pre_opt_count_x_(size) _Deref_pre_readonly_)
#define _In_bytecount_x_(size) _SAL1_1_Source_(_In_bytecount_x_, (size), _Pre_bytecount_x_(size) _Deref_pre_readonly_)
#define _In_opt_bytecount_x_(size) _SAL1_1_Source_(_In_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Deref_pre_readonly_)





#define _Out_cap_(size) _SAL1_1_Source_(_Out_cap_, (size), _Pre_cap_(size) _Post_valid_impl_)
#define _Out_opt_cap_(size) _SAL1_1_Source_(_Out_opt_cap_, (size), _Pre_opt_cap_(size) _Post_valid_impl_)
#define _Out_bytecap_(size) _SAL1_1_Source_(_Out_bytecap_, (size), _Pre_bytecap_(size) _Post_valid_impl_)
#define _Out_opt_bytecap_(size) _SAL1_1_Source_(_Out_opt_bytecap_, (size), _Pre_opt_bytecap_(size) _Post_valid_impl_)


#define _Out_cap_c_(size) _SAL1_1_Source_(_Out_cap_c_, (size), _Pre_cap_c_(size) _Post_valid_impl_)
#define _Out_opt_cap_c_(size) _SAL1_1_Source_(_Out_opt_cap_c_, (size), _Pre_opt_cap_c_(size) _Post_valid_impl_)
#define _Out_bytecap_c_(size) _SAL1_1_Source_(_Out_bytecap_c_, (size), _Pre_bytecap_c_(size) _Post_valid_impl_)
#define _Out_opt_bytecap_c_(size) _SAL1_1_Source_(_Out_opt_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_)


#define _Out_cap_m_(mult,size) _SAL1_1_Source_(_Out_cap_m_, (mult,size), _Pre_cap_m_(mult,size) _Post_valid_impl_)
#define _Out_opt_cap_m_(mult,size) _SAL1_1_Source_(_Out_opt_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_)
#define _Out_z_cap_m_(mult,size) _SAL1_1_Source_(_Out_z_cap_m_, (mult,size), _Pre_cap_m_(mult,size) _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_m_(mult,size) _SAL1_1_Source_(_Out_opt_z_cap_m_, (mult,size), _Pre_opt_cap_m_(mult,size) _Post_valid_impl_ _Post_z_)



#define _Out_ptrdiff_cap_(size) _SAL1_1_Source_(_Out_ptrdiff_cap_, (size), _Pre_ptrdiff_cap_(size) _Post_valid_impl_)
#define _Out_opt_ptrdiff_cap_(size) _SAL1_1_Source_(_Out_opt_ptrdiff_cap_, (size), _Pre_opt_ptrdiff_cap_(size) _Post_valid_impl_)


#define _Out_cap_x_(size) _SAL1_1_Source_(_Out_cap_x_, (size), _Pre_cap_x_(size) _Post_valid_impl_)
#define _Out_opt_cap_x_(size) _SAL1_1_Source_(_Out_opt_cap_x_, (size), _Pre_opt_cap_x_(size) _Post_valid_impl_)
#define _Out_bytecap_x_(size) _SAL1_1_Source_(_Out_bytecap_x_, (size), _Pre_bytecap_x_(size) _Post_valid_impl_)
#define _Out_opt_bytecap_x_(size) _SAL1_1_Source_(_Out_opt_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_)




#define _Out_z_cap_(size) _SAL1_1_Source_(_Out_z_cap_, (size), _Pre_cap_(size) _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_(size) _SAL1_1_Source_(_Out_opt_z_cap_, (size), _Pre_opt_cap_(size) _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_(size) _SAL1_1_Source_(_Out_z_bytecap_, (size), _Pre_bytecap_(size) _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_(size) _SAL1_1_Source_(_Out_opt_z_bytecap_, (size), _Pre_opt_bytecap_(size) _Post_valid_impl_ _Post_z_)


#define _Out_z_cap_c_(size) _SAL1_1_Source_(_Out_z_cap_c_, (size), _Pre_cap_c_(size) _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_c_(size) _SAL1_1_Source_(_Out_opt_z_cap_c_, (size), _Pre_opt_cap_c_(size) _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_c_(size) _SAL1_1_Source_(_Out_z_bytecap_c_, (size), _Pre_bytecap_c_(size) _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_c_(size) _SAL1_1_Source_(_Out_opt_z_bytecap_c_, (size), _Pre_opt_bytecap_c_(size) _Post_valid_impl_ _Post_z_)


#define _Out_z_cap_x_(size) _SAL1_1_Source_(_Out_z_cap_x_, (size), _Pre_cap_x_(size) _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_cap_x_(size) _SAL1_1_Source_(_Out_opt_z_cap_x_, (size), _Pre_opt_cap_x_(size) _Post_valid_impl_ _Post_z_)
#define _Out_z_bytecap_x_(size) _SAL1_1_Source_(_Out_z_bytecap_x_, (size), _Pre_bytecap_x_(size) _Post_valid_impl_ _Post_z_)
#define _Out_opt_z_bytecap_x_(size) _SAL1_1_Source_(_Out_opt_z_bytecap_x_, (size), _Pre_opt_bytecap_x_(size) _Post_valid_impl_ _Post_z_)



#define _Out_cap_post_count_(cap,count) _SAL1_1_Source_(_Out_cap_post_count_, (cap,count), _Pre_cap_(cap) _Post_valid_impl_ _Post_count_(count))
#define _Out_opt_cap_post_count_(cap,count) _SAL1_1_Source_(_Out_opt_cap_post_count_, (cap,count), _Pre_opt_cap_(cap) _Post_valid_impl_ _Post_count_(count))
#define _Out_bytecap_post_bytecount_(cap,count) _SAL1_1_Source_(_Out_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap) _Post_valid_impl_ _Post_bytecount_(count))
#define _Out_opt_bytecap_post_bytecount_(cap,count) _SAL1_1_Source_(_Out_opt_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_bytecount_(count))



#define _Out_z_cap_post_count_(cap,count) _SAL1_1_Source_(_Out_z_cap_post_count_, (cap,count), _Pre_cap_(cap) _Post_valid_impl_ _Post_z_count_(count))
#define _Out_opt_z_cap_post_count_(cap,count) _SAL1_1_Source_(_Out_opt_z_cap_post_count_, (cap,count), _Pre_opt_cap_(cap) _Post_valid_impl_ _Post_z_count_(count))
#define _Out_z_bytecap_post_bytecount_(cap,count) _SAL1_1_Source_(_Out_z_bytecap_post_bytecount_, (cap,count), _Pre_bytecap_(cap) _Post_valid_impl_ _Post_z_bytecount_(count))
#define _Out_opt_z_bytecap_post_bytecount_(cap,count) _SAL1_1_Source_(_Out_opt_z_bytecap_post_bytecount_, (cap,count), _Pre_opt_bytecap_(cap) _Post_valid_impl_ _Post_z_bytecount_(count))


#define _Out_capcount_(capcount) _SAL1_1_Source_(_Out_capcount_, (capcount), _Pre_cap_(capcount) _Post_valid_impl_ _Post_count_(capcount))
#define _Out_opt_capcount_(capcount) _SAL1_1_Source_(_Out_opt_capcount_, (capcount), _Pre_opt_cap_(capcount) _Post_valid_impl_ _Post_count_(capcount))
#define _Out_bytecapcount_(capcount) _SAL1_1_Source_(_Out_bytecapcount_, (capcount), _Pre_bytecap_(capcount) _Post_valid_impl_ _Post_bytecount_(capcount))
#define _Out_opt_bytecapcount_(capcount) _SAL1_1_Source_(_Out_opt_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_bytecount_(capcount))

#define _Out_capcount_x_(capcount) _SAL1_1_Source_(_Out_capcount_x_, (capcount), _Pre_cap_x_(capcount) _Post_valid_impl_ _Post_count_x_(capcount))
#define _Out_opt_capcount_x_(capcount) _SAL1_1_Source_(_Out_opt_capcount_x_, (capcount), _Pre_opt_cap_x_(capcount) _Post_valid_impl_ _Post_count_x_(capcount))
#define _Out_bytecapcount_x_(capcount) _SAL1_1_Source_(_Out_bytecapcount_x_, (capcount), _Pre_bytecap_x_(capcount) _Post_valid_impl_ _Post_bytecount_x_(capcount))
#define _Out_opt_bytecapcount_x_(capcount) _SAL1_1_Source_(_Out_opt_bytecapcount_x_, (capcount), _Pre_opt_bytecap_x_(capcount) _Post_valid_impl_ _Post_bytecount_x_(capcount))


#define _Out_z_capcount_(capcount) _SAL1_1_Source_(_Out_z_capcount_, (capcount), _Pre_cap_(capcount) _Post_valid_impl_ _Post_z_count_(capcount))
#define _Out_opt_z_capcount_(capcount) _SAL1_1_Source_(_Out_opt_z_capcount_, (capcount), _Pre_opt_cap_(capcount) _Post_valid_impl_ _Post_z_count_(capcount))
#define _Out_z_bytecapcount_(capcount) _SAL1_1_Source_(_Out_z_bytecapcount_, (capcount), _Pre_bytecap_(capcount) _Post_valid_impl_ _Post_z_bytecount_(capcount))
#define _Out_opt_z_bytecapcount_(capcount) _SAL1_1_Source_(_Out_opt_z_bytecapcount_, (capcount), _Pre_opt_bytecap_(capcount) _Post_valid_impl_ _Post_z_bytecount_(capcount))




#define _Inout_count_(size) _SAL1_1_Source_(_Inout_count_, (size), _Prepost_count_(size))
#define _Inout_opt_count_(size) _SAL1_1_Source_(_Inout_opt_count_, (size), _Prepost_opt_count_(size))
#define _Inout_bytecount_(size) _SAL1_1_Source_(_Inout_bytecount_, (size), _Prepost_bytecount_(size))
#define _Inout_opt_bytecount_(size) _SAL1_1_Source_(_Inout_opt_bytecount_, (size), _Prepost_opt_bytecount_(size))

#define _Inout_count_c_(size) _SAL1_1_Source_(_Inout_count_c_, (size), _Prepost_count_c_(size))
#define _Inout_opt_count_c_(size) _SAL1_1_Source_(_Inout_opt_count_c_, (size), _Prepost_opt_count_c_(size))
#define _Inout_bytecount_c_(size) _SAL1_1_Source_(_Inout_bytecount_c_, (size), _Prepost_bytecount_c_(size))
#define _Inout_opt_bytecount_c_(size) _SAL1_1_Source_(_Inout_opt_bytecount_c_, (size), _Prepost_opt_bytecount_c_(size))



#define _Inout_z_count_(size) _SAL1_1_Source_(_Inout_z_count_, (size), _Prepost_z_ _Prepost_count_(size))
#define _Inout_opt_z_count_(size) _SAL1_1_Source_(_Inout_opt_z_count_, (size), _Prepost_z_ _Prepost_opt_count_(size))
#define _Inout_z_bytecount_(size) _SAL1_1_Source_(_Inout_z_bytecount_, (size), _Prepost_z_ _Prepost_bytecount_(size))
#define _Inout_opt_z_bytecount_(size) _SAL1_1_Source_(_Inout_opt_z_bytecount_, (size), _Prepost_z_ _Prepost_opt_bytecount_(size))

#define _Inout_z_count_c_(size) _SAL1_1_Source_(_Inout_z_count_c_, (size), _Prepost_z_ _Prepost_count_c_(size))
#define _Inout_opt_z_count_c_(size) _SAL1_1_Source_(_Inout_opt_z_count_c_, (size), _Prepost_z_ _Prepost_opt_count_c_(size))
#define _Inout_z_bytecount_c_(size) _SAL1_1_Source_(_Inout_z_bytecount_c_, (size), _Prepost_z_ _Prepost_bytecount_c_(size))
#define _Inout_opt_z_bytecount_c_(size) _SAL1_1_Source_(_Inout_opt_z_bytecount_c_, (size), _Prepost_z_ _Prepost_opt_bytecount_c_(size))

#define _Inout_ptrdiff_count_(size) _SAL1_1_Source_(_Inout_ptrdiff_count_, (size), _Pre_ptrdiff_count_(size))
#define _Inout_opt_ptrdiff_count_(size) _SAL1_1_Source_(_Inout_opt_ptrdiff_count_, (size), _Pre_opt_ptrdiff_count_(size))

#define _Inout_count_x_(size) _SAL1_1_Source_(_Inout_count_x_, (size), _Prepost_count_x_(size))
#define _Inout_opt_count_x_(size) _SAL1_1_Source_(_Inout_opt_count_x_, (size), _Prepost_opt_count_x_(size))
#define _Inout_bytecount_x_(size) _SAL1_1_Source_(_Inout_bytecount_x_, (size), _Prepost_bytecount_x_(size))
#define _Inout_opt_bytecount_x_(size) _SAL1_1_Source_(_Inout_opt_bytecount_x_, (size), _Prepost_opt_bytecount_x_(size))


#define _Inout_cap_(size) _SAL1_1_Source_(_Inout_cap_, (size), _Pre_valid_cap_(size) _Post_valid_)
#define _Inout_opt_cap_(size) _SAL1_1_Source_(_Inout_opt_cap_, (size), _Pre_opt_valid_cap_(size) _Post_valid_)
#define _Inout_bytecap_(size) _SAL1_1_Source_(_Inout_bytecap_, (size), _Pre_valid_bytecap_(size) _Post_valid_)
#define _Inout_opt_bytecap_(size) _SAL1_1_Source_(_Inout_opt_bytecap_, (size), _Pre_opt_valid_bytecap_(size) _Post_valid_)

#define _Inout_cap_c_(size) _SAL1_1_Source_(_Inout_cap_c_, (size), _Pre_valid_cap_c_(size) _Post_valid_)
#define _Inout_opt_cap_c_(size) _SAL1_1_Source_(_Inout_opt_cap_c_, (size), _Pre_opt_valid_cap_c_(size) _Post_valid_)
#define _Inout_bytecap_c_(size) _SAL1_1_Source_(_Inout_bytecap_c_, (size), _Pre_valid_bytecap_c_(size) _Post_valid_)
#define _Inout_opt_bytecap_c_(size) _SAL1_1_Source_(_Inout_opt_bytecap_c_, (size), _Pre_opt_valid_bytecap_c_(size) _Post_valid_)

#define _Inout_cap_x_(size) _SAL1_1_Source_(_Inout_cap_x_, (size), _Pre_valid_cap_x_(size) _Post_valid_)
#define _Inout_opt_cap_x_(size) _SAL1_1_Source_(_Inout_opt_cap_x_, (size), _Pre_opt_valid_cap_x_(size) _Post_valid_)
#define _Inout_bytecap_x_(size) _SAL1_1_Source_(_Inout_bytecap_x_, (size), _Pre_valid_bytecap_x_(size) _Post_valid_)
#define _Inout_opt_bytecap_x_(size) _SAL1_1_Source_(_Inout_opt_bytecap_x_, (size), _Pre_opt_valid_bytecap_x_(size) _Post_valid_)



#define _Inout_z_cap_(size) _SAL1_1_Source_(_Inout_z_cap_, (size), _Pre_z_cap_(size) _Post_z_)
#define _Inout_opt_z_cap_(size) _SAL1_1_Source_(_Inout_opt_z_cap_, (size), _Pre_opt_z_cap_(size) _Post_z_)
#define _Inout_z_bytecap_(size) _SAL1_1_Source_(_Inout_z_bytecap_, (size), _Pre_z_bytecap_(size) _Post_z_)
#define _Inout_opt_z_bytecap_(size) _SAL1_1_Source_(_Inout_opt_z_bytecap_, (size), _Pre_opt_z_bytecap_(size) _Post_z_)

#define _Inout_z_cap_c_(size) _SAL1_1_Source_(_Inout_z_cap_c_, (size), _Pre_z_cap_c_(size) _Post_z_)
#define _Inout_opt_z_cap_c_(size) _SAL1_1_Source_(_Inout_opt_z_cap_c_, (size), _Pre_opt_z_cap_c_(size) _Post_z_)
#define _Inout_z_bytecap_c_(size) _SAL1_1_Source_(_Inout_z_bytecap_c_, (size), _Pre_z_bytecap_c_(size) _Post_z_)
#define _Inout_opt_z_bytecap_c_(size) _SAL1_1_Source_(_Inout_opt_z_bytecap_c_, (size), _Pre_opt_z_bytecap_c_(size) _Post_z_)

#define _Inout_z_cap_x_(size) _SAL1_1_Source_(_Inout_z_cap_x_, (size), _Pre_z_cap_x_(size) _Post_z_)
#define _Inout_opt_z_cap_x_(size) _SAL1_1_Source_(_Inout_opt_z_cap_x_, (size), _Pre_opt_z_cap_x_(size) _Post_z_)
#define _Inout_z_bytecap_x_(size) _SAL1_1_Source_(_Inout_z_bytecap_x_, (size), _Pre_z_bytecap_x_(size) _Post_z_)
#define _Inout_opt_z_bytecap_x_(size) _SAL1_1_Source_(_Inout_opt_z_bytecap_x_, (size), _Pre_opt_z_bytecap_x_(size) _Post_z_)



#define _Ret_ _SAL1_1_Source_(_Ret_, (), _Ret_valid_)
#define _Ret_opt_ _SAL1_1_Source_(_Ret_opt_, (), _Ret_opt_valid_)


#define _In_bound_ _SAL1_1_Source_(_In_bound_, (), _In_bound_impl_)
#define _Out_bound_ _SAL1_1_Source_(_Out_bound_, (), _Out_bound_impl_)
#define _Ret_bound_ _SAL1_1_Source_(_Ret_bound_, (), _Ret_bound_impl_)
#define _Deref_in_bound_ _SAL1_1_Source_(_Deref_in_bound_, (), _Deref_in_bound_impl_)
#define _Deref_out_bound_ _SAL1_1_Source_(_Deref_out_bound_, (), _Deref_out_bound_impl_)
#define _Deref_inout_bound_ _SAL1_1_Source_(_Deref_inout_bound_, (), _Deref_in_bound_ _Deref_out_bound_)
#define _Deref_ret_bound_ _SAL1_1_Source_(_Deref_ret_bound_, (), _Deref_ret_bound_impl_)


#define _Deref_out_ _SAL1_1_Source_(_Deref_out_, (), _Out_ _Deref_post_valid_)
#define _Deref_out_opt_ _SAL1_1_Source_(_Deref_out_opt_, (), _Out_ _Deref_post_opt_valid_)
#define _Deref_opt_out_ _SAL1_1_Source_(_Deref_opt_out_, (), _Out_opt_ _Deref_post_valid_)
#define _Deref_opt_out_opt_ _SAL1_1_Source_(_Deref_opt_out_opt_, (), _Out_opt_ _Deref_post_opt_valid_)


#define _Deref_out_z_ _SAL1_1_Source_(_Deref_out_z_, (), _Out_ _Deref_post_z_)
#define _Deref_out_opt_z_ _SAL1_1_Source_(_Deref_out_opt_z_, (), _Out_ _Deref_post_opt_z_)
#define _Deref_opt_out_z_ _SAL1_1_Source_(_Deref_opt_out_z_, (), _Out_opt_ _Deref_post_z_)
#define _Deref_opt_out_opt_z_ _SAL1_1_Source_(_Deref_opt_out_opt_z_, (), _Out_opt_ _Deref_post_opt_z_)







#define _Deref_pre_z_ _SAL1_1_Source_(_Deref_pre_z_, (), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)
#define _Deref_pre_opt_z_ _SAL1_1_Source_(_Deref_pre_opt_z_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__zterm_impl) _Pre_valid_impl_)



#define _Deref_pre_cap_(size) _SAL1_1_Source_(_Deref_pre_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)))
#define _Deref_pre_opt_cap_(size) _SAL1_1_Source_(_Deref_pre_opt_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)))
#define _Deref_pre_bytecap_(size) _SAL1_1_Source_(_Deref_pre_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)))
#define _Deref_pre_opt_bytecap_(size) _SAL1_1_Source_(_Deref_pre_opt_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)))


#define _Deref_pre_cap_c_(size) _SAL1_1_Source_(_Deref_pre_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)))
#define _Deref_pre_opt_cap_c_(size) _SAL1_1_Source_(_Deref_pre_opt_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)))
#define _Deref_pre_bytecap_c_(size) _SAL1_1_Source_(_Deref_pre_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)))
#define _Deref_pre_opt_bytecap_c_(size) _SAL1_1_Source_(_Deref_pre_opt_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)))


#define _Deref_pre_cap_x_(size) _SAL1_1_Source_(_Deref_pre_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)))
#define _Deref_pre_opt_cap_x_(size) _SAL1_1_Source_(_Deref_pre_opt_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)))
#define _Deref_pre_bytecap_x_(size) _SAL1_1_Source_(_Deref_pre_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)))
#define _Deref_pre_opt_bytecap_x_(size) _SAL1_1_Source_(_Deref_pre_opt_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)))


#define _Deref_pre_z_cap_(size) _SAL1_1_Source_(_Deref_pre_z_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_(size) _SAL1_1_Source_(_Deref_pre_opt_z_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_(size) _SAL1_1_Source_(_Deref_pre_z_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_(size) _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_z_cap_c_(size) _SAL1_1_Source_(_Deref_pre_z_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_c_(size) _SAL1_1_Source_(_Deref_pre_opt_z_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_c_(size) _SAL1_1_Source_(_Deref_pre_z_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_c_(size) _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_z_cap_x_(size) _SAL1_1_Source_(_Deref_pre_z_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_cap_x_(size) _SAL1_1_Source_(_Deref_pre_opt_z_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_z_bytecap_x_(size) _SAL1_1_Source_(_Deref_pre_z_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_z_bytecap_x_(size) _SAL1_1_Source_(_Deref_pre_opt_z_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)


#define _Deref_pre_valid_cap_(size) _SAL1_1_Source_(_Deref_pre_valid_cap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_(size) _SAL1_1_Source_(_Deref_pre_opt_valid_cap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_(size) _SAL1_1_Source_(_Deref_pre_valid_bytecap_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_(size) _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_valid_cap_c_(size) _SAL1_1_Source_(_Deref_pre_valid_cap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_c_(size) _SAL1_1_Source_(_Deref_pre_opt_valid_cap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_c_(size) _SAL1_1_Source_(_Deref_pre_valid_bytecap_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_c_(size) _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Deref_pre_valid_cap_x_(size) _SAL1_1_Source_(_Deref_pre_valid_cap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_cap_x_(size) _SAL1_1_Source_(_Deref_pre_opt_valid_cap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_valid_bytecap_x_(size) _SAL1_1_Source_(_Deref_pre_valid_bytecap_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_bytecap_x_(size) _SAL1_1_Source_(_Deref_pre_opt_valid_bytecap_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)



#define _Deref_pre_count_(size) _SAL1_1_Source_(_Deref_pre_count_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__count_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_count_(size) _SAL1_1_Source_(_Deref_pre_opt_count_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_bytecount_(size) _SAL1_1_Source_(_Deref_pre_bytecount_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_(size) _SAL1_1_Source_(_Deref_pre_opt_bytecount_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)


#define _Deref_pre_count_c_(size) _SAL1_1_Source_(_Deref_pre_count_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_count_c_(size) _SAL1_1_Source_(_Deref_pre_opt_count_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_bytecount_c_(size) _SAL1_1_Source_(_Deref_pre_bytecount_c_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_c_(size) _SAL1_1_Source_(_Deref_pre_opt_bytecount_c_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)


#define _Deref_pre_count_x_(size) _SAL1_1_Source_(_Deref_pre_count_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_count_x_(size) _SAL1_1_Source_(_Deref_pre_opt_count_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_bytecount_x_(size) _SAL1_1_Source_(_Deref_pre_bytecount_x_, (size), _Deref_pre1_impl_(__notnull_impl_notref) _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)
#define _Deref_pre_opt_bytecount_x_(size) _SAL1_1_Source_(_Deref_pre_opt_bytecount_x_, (size), _Deref_pre1_impl_(__maybenull_impl_notref) _Deref_pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)


#define _Deref_pre_valid_ _SAL1_1_Source_(_Deref_pre_valid_, (), _Deref_pre1_impl_(__notnull_impl_notref) _Pre_valid_impl_)
#define _Deref_pre_opt_valid_ _SAL1_1_Source_(_Deref_pre_opt_valid_, (), _Deref_pre1_impl_(__maybenull_impl_notref) _Pre_valid_impl_)
#define _Deref_pre_invalid_ _SAL1_1_Source_(_Deref_pre_invalid_, (), _Deref_pre1_impl_(__notvalid_impl))

#define _Deref_pre_notnull_ _SAL1_1_Source_(_Deref_pre_notnull_, (), _Deref_pre1_impl_(__notnull_impl_notref))
#define _Deref_pre_maybenull_ _SAL1_1_Source_(_Deref_pre_maybenull_, (), _Deref_pre1_impl_(__maybenull_impl_notref))
#define _Deref_pre_null_ _SAL1_1_Source_(_Deref_pre_null_, (), _Deref_pre1_impl_(__null_impl_notref))


#define _Deref_pre_readonly_ _SAL1_1_Source_(_Deref_pre_readonly_, (), _Deref_pre1_impl_(__readaccess_impl_notref))
#define _Deref_pre_writeonly_ _SAL1_1_Source_(_Deref_pre_writeonly_, (), _Deref_pre1_impl_(__writeaccess_impl_notref))







#define _Deref_post_z_ _SAL1_1_Source_(_Deref_post_z_, (), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)
#define _Deref_post_opt_z_ _SAL1_1_Source_(_Deref_post_opt_z_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__zterm_impl) _Post_valid_impl_)



#define _Deref_post_cap_(size) _SAL1_1_Source_(_Deref_post_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))
#define _Deref_post_opt_cap_(size) _SAL1_1_Source_(_Deref_post_opt_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size)))
#define _Deref_post_bytecap_(size) _SAL1_1_Source_(_Deref_post_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))
#define _Deref_post_opt_bytecap_(size) _SAL1_1_Source_(_Deref_post_opt_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)))


#define _Deref_post_cap_c_(size) _SAL1_1_Source_(_Deref_post_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))
#define _Deref_post_opt_cap_c_(size) _SAL1_1_Source_(_Deref_post_opt_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)))
#define _Deref_post_bytecap_c_(size) _SAL1_1_Source_(_Deref_post_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))
#define _Deref_post_opt_bytecap_c_(size) _SAL1_1_Source_(_Deref_post_opt_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)))


#define _Deref_post_cap_x_(size) _SAL1_1_Source_(_Deref_post_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))
#define _Deref_post_opt_cap_x_(size) _SAL1_1_Source_(_Deref_post_opt_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)))
#define _Deref_post_bytecap_x_(size) _SAL1_1_Source_(_Deref_post_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))
#define _Deref_post_opt_bytecap_x_(size) _SAL1_1_Source_(_Deref_post_opt_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)))


#define _Deref_post_z_cap_(size) _SAL1_1_Source_(_Deref_post_z_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_cap_(size) _SAL1_1_Source_(_Deref_post_opt_z_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_impl(size)) _Post_valid_impl_)
#define _Deref_post_z_bytecap_(size) _SAL1_1_Source_(_Deref_post_z_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_(size) _SAL1_1_Source_(_Deref_post_opt_z_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_impl(size)) _Post_valid_impl_)

#define _Deref_post_z_cap_c_(size) _SAL1_1_Source_(_Deref_post_z_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_cap_c_(size) _SAL1_1_Source_(_Deref_post_opt_z_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_z_bytecap_c_(size) _SAL1_1_Source_(_Deref_post_z_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_c_(size) _SAL1_1_Source_(_Deref_post_opt_z_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Post_valid_impl_)

#define _Deref_post_z_cap_x_(size) _SAL1_1_Source_(_Deref_post_z_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_cap_x_(size) _SAL1_1_Source_(_Deref_post_opt_z_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__cap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_z_bytecap_x_(size) _SAL1_1_Source_(_Deref_post_z_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_z_bytecap_x_(size) _SAL1_1_Source_(_Deref_post_opt_z_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Post_valid_impl_)


#define _Deref_post_valid_cap_(size) _SAL1_1_Source_(_Deref_post_valid_cap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_(size) _SAL1_1_Source_(_Deref_post_opt_valid_cap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_impl(size)) _Post_valid_impl_)
#define _Deref_post_valid_bytecap_(size) _SAL1_1_Source_(_Deref_post_valid_bytecap_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_(size) _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_impl(size)) _Post_valid_impl_)

#define _Deref_post_valid_cap_c_(size) _SAL1_1_Source_(_Deref_post_valid_cap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_c_(size) _SAL1_1_Source_(_Deref_post_opt_valid_cap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_valid_bytecap_c_(size) _SAL1_1_Source_(_Deref_post_valid_bytecap_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_c_(size) _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_c_impl(size)) _Post_valid_impl_)

#define _Deref_post_valid_cap_x_(size) _SAL1_1_Source_(_Deref_post_valid_cap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_cap_x_(size) _SAL1_1_Source_(_Deref_post_opt_valid_cap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__cap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_valid_bytecap_x_(size) _SAL1_1_Source_(_Deref_post_valid_bytecap_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_valid_bytecap_x_(size) _SAL1_1_Source_(_Deref_post_opt_valid_bytecap_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecap_x_impl(size)) _Post_valid_impl_)



#define _Deref_post_count_(size) _SAL1_1_Source_(_Deref_post_count_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_count_(size) _SAL1_1_Source_(_Deref_post_opt_count_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_impl(size)) _Post_valid_impl_)
#define _Deref_post_bytecount_(size) _SAL1_1_Source_(_Deref_post_bytecount_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_bytecount_(size) _SAL1_1_Source_(_Deref_post_opt_bytecount_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)


#define _Deref_post_count_c_(size) _SAL1_1_Source_(_Deref_post_count_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_count_c_(size) _SAL1_1_Source_(_Deref_post_opt_count_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_bytecount_c_(size) _SAL1_1_Source_(_Deref_post_bytecount_c_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_bytecount_c_(size) _SAL1_1_Source_(_Deref_post_opt_bytecount_c_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)


#define _Deref_post_count_x_(size) _SAL1_1_Source_(_Deref_post_count_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__count_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_count_x_(size) _SAL1_1_Source_(_Deref_post_opt_count_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__count_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_bytecount_x_(size) _SAL1_1_Source_(_Deref_post_bytecount_x_, (size), _Deref_post1_impl_(__notnull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)
#define _Deref_post_opt_bytecount_x_(size) _SAL1_1_Source_(_Deref_post_opt_bytecount_x_, (size), _Deref_post1_impl_(__maybenull_impl_notref) _Deref_post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)


#define _Deref_post_valid_ _SAL1_1_Source_(_Deref_post_valid_, (), _Deref_post1_impl_(__notnull_impl_notref) _Post_valid_impl_)
#define _Deref_post_opt_valid_ _SAL1_1_Source_(_Deref_post_opt_valid_, (), _Deref_post1_impl_(__maybenull_impl_notref) _Post_valid_impl_)

#define _Deref_post_notnull_ _SAL1_1_Source_(_Deref_post_notnull_, (), _Deref_post1_impl_(__notnull_impl_notref))
#define _Deref_post_maybenull_ _SAL1_1_Source_(_Deref_post_maybenull_, (), _Deref_post1_impl_(__maybenull_impl_notref))
#define _Deref_post_null_ _SAL1_1_Source_(_Deref_post_null_, (), _Deref_post1_impl_(__null_impl_notref))





#define _Deref_ret_z_ _SAL1_1_Source_(_Deref_ret_z_, (), _Deref_ret1_impl_(__notnull_impl_notref) _Deref_ret1_impl_(__zterm_impl))
#define _Deref_ret_opt_z_ _SAL1_1_Source_(_Deref_ret_opt_z_, (), _Deref_ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__zterm_impl))




#define _Deref2_pre_readonly_ _SAL1_1_Source_(_Deref2_pre_readonly_, (), _Deref2_pre1_impl_(__readaccess_impl_notref))






#define _Ret_opt_valid_ _SAL1_1_Source_(_Ret_opt_valid_, (), _Ret1_impl_(__maybenull_impl_notref) _Ret_valid_impl_)
#define _Ret_opt_z_ _SAL1_1_Source_(_Ret_opt_z_, (), _Ret2_impl_(__maybenull_impl,__zterm_impl) _Ret_valid_impl_)



#define _Ret_cap_(size) _SAL1_1_Source_(_Ret_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_impl(size)))
#define _Ret_opt_cap_(size) _SAL1_1_Source_(_Ret_opt_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_impl(size)))
#define _Ret_bytecap_(size) _SAL1_1_Source_(_Ret_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))
#define _Ret_opt_bytecap_(size) _SAL1_1_Source_(_Ret_opt_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_impl(size)))


#define _Ret_cap_c_(size) _SAL1_1_Source_(_Ret_cap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))
#define _Ret_opt_cap_c_(size) _SAL1_1_Source_(_Ret_opt_cap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_c_impl(size)))
#define _Ret_bytecap_c_(size) _SAL1_1_Source_(_Ret_bytecap_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))
#define _Ret_opt_bytecap_c_(size) _SAL1_1_Source_(_Ret_opt_bytecap_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_c_impl(size)))


#define _Ret_cap_x_(size) _SAL1_1_Source_(_Ret_cap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))
#define _Ret_opt_cap_x_(size) _SAL1_1_Source_(_Ret_opt_cap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__cap_x_impl(size)))
#define _Ret_bytecap_x_(size) _SAL1_1_Source_(_Ret_bytecap_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))
#define _Ret_opt_bytecap_x_(size) _SAL1_1_Source_(_Ret_opt_bytecap_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecap_x_impl(size)))


#define _Ret_z_cap_(size) _SAL1_1_Source_(_Ret_z_cap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_cap_(size) _SAL1_1_Source_(_Ret_opt_z_cap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__cap_impl(size)) _Ret_valid_impl_)
#define _Ret_z_bytecap_(size) _SAL1_1_Source_(_Ret_z_bytecap_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_bytecap_(size) _SAL1_1_Source_(_Ret_opt_z_bytecap_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecap_impl(size)) _Ret_valid_impl_)



#define _Ret_count_(size) _SAL1_1_Source_(_Ret_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_count_(size) _SAL1_1_Source_(_Ret_opt_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_impl(size)) _Ret_valid_impl_)
#define _Ret_bytecount_(size) _SAL1_1_Source_(_Ret_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_(size) _SAL1_1_Source_(_Ret_opt_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_impl(size)) _Ret_valid_impl_)


#define _Ret_count_c_(size) _SAL1_1_Source_(_Ret_count_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_c_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_count_c_(size) _SAL1_1_Source_(_Ret_opt_count_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_c_impl(size)) _Ret_valid_impl_)
#define _Ret_bytecount_c_(size) _SAL1_1_Source_(_Ret_bytecount_c_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_c_(size) _SAL1_1_Source_(_Ret_opt_bytecount_c_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_c_impl(size)) _Ret_valid_impl_)


#define _Ret_count_x_(size) _SAL1_1_Source_(_Ret_count_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__count_x_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_count_x_(size) _SAL1_1_Source_(_Ret_opt_count_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__count_x_impl(size)) _Ret_valid_impl_)
#define _Ret_bytecount_x_(size) _SAL1_1_Source_(_Ret_bytecount_x_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_bytecount_x_(size) _SAL1_1_Source_(_Ret_opt_bytecount_x_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret1_impl_(__bytecount_x_impl(size)) _Ret_valid_impl_)


#define _Ret_z_count_(size) _SAL1_1_Source_(_Ret_z_count_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_count_(size) _SAL1_1_Source_(_Ret_opt_z_count_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__count_impl(size)) _Ret_valid_impl_)
#define _Ret_z_bytecount_(size) _SAL1_1_Source_(_Ret_z_bytecount_, (size), _Ret1_impl_(__notnull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)
#define _Ret_opt_z_bytecount_(size) _SAL1_1_Source_(_Ret_opt_z_bytecount_, (size), _Ret1_impl_(__maybenull_impl_notref) _Ret2_impl_(__zterm_impl,__bytecount_impl(size)) _Ret_valid_impl_)



#define _Pre_opt_z_ _SAL1_1_Source_(_Pre_opt_z_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__zterm_impl) _Pre_valid_impl_)


#define _Pre_readonly_ _SAL1_1_Source_(_Pre_readonly_, (), _Pre1_impl_(__readaccess_impl_notref))
#define _Pre_writeonly_ _SAL1_1_Source_(_Pre_writeonly_, (), _Pre1_impl_(__writeaccess_impl_notref))



#define _Pre_cap_(size) _SAL1_1_Source_(_Pre_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size)))
#define _Pre_opt_cap_(size) _SAL1_1_Source_(_Pre_opt_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size)))
#define _Pre_bytecap_(size) _SAL1_1_Source_(_Pre_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))
#define _Pre_opt_bytecap_(size) _SAL1_1_Source_(_Pre_opt_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size)))


#define _Pre_cap_c_(size) _SAL1_1_Source_(_Pre_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))
#define _Pre_opt_cap_c_(size) _SAL1_1_Source_(_Pre_opt_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size)))
#define _Pre_bytecap_c_(size) _SAL1_1_Source_(_Pre_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))
#define _Pre_opt_bytecap_c_(size) _SAL1_1_Source_(_Pre_opt_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)))
#define _Pre_cap_c_one_ _SAL1_1_Source_(_Pre_cap_c_one_, (), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))
#define _Pre_opt_cap_c_one_ _SAL1_1_Source_(_Pre_opt_cap_c_one_, (), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_one_notref_impl))


#define _Pre_cap_m_(mult,size) _SAL1_1_Source_(_Pre_cap_m_, (mult,size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))
#define _Pre_opt_cap_m_(mult,size) _SAL1_1_Source_(_Pre_opt_cap_m_, (mult,size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__mult_impl(mult,size)))



#define _Pre_cap_for_(param) _SAL1_1_Source_(_Pre_cap_for_, (param), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))
#define _Pre_opt_cap_for_(param) _SAL1_1_Source_(_Pre_opt_cap_for_, (param), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_for_impl(param)))


#define _Pre_cap_x_(size) _SAL1_1_Source_(_Pre_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))
#define _Pre_opt_cap_x_(size) _SAL1_1_Source_(_Pre_opt_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size)))
#define _Pre_bytecap_x_(size) _SAL1_1_Source_(_Pre_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))
#define _Pre_opt_bytecap_x_(size) _SAL1_1_Source_(_Pre_opt_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)))


#define _Pre_ptrdiff_cap_(ptr) _SAL1_1_Source_(_Pre_ptrdiff_cap_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))
#define _Pre_opt_ptrdiff_cap_(ptr) _SAL1_1_Source_(_Pre_opt_ptrdiff_cap_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(__ptrdiff(ptr))))


#define _Pre_z_cap_(size) _SAL1_1_Source_(_Pre_z_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_cap_(size) _SAL1_1_Source_(_Pre_opt_z_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_impl(size)) _Pre_valid_impl_)
#define _Pre_z_bytecap_(size) _SAL1_1_Source_(_Pre_z_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_(size) _SAL1_1_Source_(_Pre_opt_z_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_impl(size)) _Pre_valid_impl_)

#define _Pre_z_cap_c_(size) _SAL1_1_Source_(_Pre_z_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_cap_c_(size) _SAL1_1_Source_(_Pre_opt_z_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_z_bytecap_c_(size) _SAL1_1_Source_(_Pre_z_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_c_(size) _SAL1_1_Source_(_Pre_opt_z_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Pre_z_cap_x_(size) _SAL1_1_Source_(_Pre_z_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_cap_x_(size) _SAL1_1_Source_(_Pre_opt_z_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__cap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_z_bytecap_x_(size) _SAL1_1_Source_(_Pre_z_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_z_bytecap_x_(size) _SAL1_1_Source_(_Pre_opt_z_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre2_impl_(__zterm_impl,__bytecap_x_impl(size)) _Pre_valid_impl_)


#define _Pre_valid_cap_(size) _SAL1_1_Source_(_Pre_valid_cap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_cap_(size) _SAL1_1_Source_(_Pre_opt_valid_cap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_impl(size)) _Pre_valid_impl_)
#define _Pre_valid_bytecap_(size) _SAL1_1_Source_(_Pre_valid_bytecap_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_(size) _SAL1_1_Source_(_Pre_opt_valid_bytecap_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_impl(size)) _Pre_valid_impl_)

#define _Pre_valid_cap_c_(size) _SAL1_1_Source_(_Pre_valid_cap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_cap_c_(size) _SAL1_1_Source_(_Pre_opt_valid_cap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_valid_bytecap_c_(size) _SAL1_1_Source_(_Pre_valid_bytecap_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_c_(size) _SAL1_1_Source_(_Pre_opt_valid_bytecap_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_c_impl(size)) _Pre_valid_impl_)

#define _Pre_valid_cap_x_(size) _SAL1_1_Source_(_Pre_valid_cap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_cap_x_(size) _SAL1_1_Source_(_Pre_opt_valid_cap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__cap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_valid_bytecap_x_(size) _SAL1_1_Source_(_Pre_valid_bytecap_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_valid_bytecap_x_(size) _SAL1_1_Source_(_Pre_opt_valid_bytecap_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecap_x_impl(size)) _Pre_valid_impl_)



#define _Pre_count_(size) _SAL1_1_Source_(_Pre_count_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_count_(size) _SAL1_1_Source_(_Pre_opt_count_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_impl(size)) _Pre_valid_impl_)
#define _Pre_bytecount_(size) _SAL1_1_Source_(_Pre_bytecount_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_bytecount_(size) _SAL1_1_Source_(_Pre_opt_bytecount_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_impl(size)) _Pre_valid_impl_)


#define _Pre_count_c_(size) _SAL1_1_Source_(_Pre_count_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_count_c_(size) _SAL1_1_Source_(_Pre_opt_count_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_c_impl(size)) _Pre_valid_impl_)
#define _Pre_bytecount_c_(size) _SAL1_1_Source_(_Pre_bytecount_c_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_bytecount_c_(size) _SAL1_1_Source_(_Pre_opt_bytecount_c_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_c_impl(size)) _Pre_valid_impl_)


#define _Pre_count_x_(size) _SAL1_1_Source_(_Pre_count_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_count_x_(size) _SAL1_1_Source_(_Pre_opt_count_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(size)) _Pre_valid_impl_)
#define _Pre_bytecount_x_(size) _SAL1_1_Source_(_Pre_bytecount_x_, (size), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)
#define _Pre_opt_bytecount_x_(size) _SAL1_1_Source_(_Pre_opt_bytecount_x_, (size), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__bytecount_x_impl(size)) _Pre_valid_impl_)


#define _Pre_ptrdiff_count_(ptr) _SAL1_1_Source_(_Pre_ptrdiff_count_, (ptr), _Pre1_impl_(__notnull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)
#define _Pre_opt_ptrdiff_count_(ptr) _SAL1_1_Source_(_Pre_opt_ptrdiff_count_, (ptr), _Pre1_impl_(__maybenull_impl_notref) _Pre1_impl_(__count_x_impl(__ptrdiff(ptr))) _Pre_valid_impl_)




#define _Post_maybez_ _SAL_L_Source_(_Post_maybez_, (), _Post1_impl_(__maybezterm_impl))


#define _Post_cap_(size) _SAL1_1_Source_(_Post_cap_, (size), _Post1_impl_(__cap_impl(size)))
#define _Post_bytecap_(size) _SAL1_1_Source_(_Post_bytecap_, (size), _Post1_impl_(__bytecap_impl(size)))


#define _Post_count_(size) _SAL1_1_Source_(_Post_count_, (size), _Post1_impl_(__count_impl(size)) _Post_valid_impl_)
#define _Post_bytecount_(size) _SAL1_1_Source_(_Post_bytecount_, (size), _Post1_impl_(__bytecount_impl(size)) _Post_valid_impl_)
#define _Post_count_c_(size) _SAL1_1_Source_(_Post_count_c_, (size), _Post1_impl_(__count_c_impl(size)) _Post_valid_impl_)
#define _Post_bytecount_c_(size) _SAL1_1_Source_(_Post_bytecount_c_, (size), _Post1_impl_(__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Post_count_x_(size) _SAL1_1_Source_(_Post_count_x_, (size), _Post1_impl_(__count_x_impl(size)) _Post_valid_impl_)
#define _Post_bytecount_x_(size) _SAL1_1_Source_(_Post_bytecount_x_, (size), _Post1_impl_(__bytecount_x_impl(size)) _Post_valid_impl_)


#define _Post_z_count_(size) _SAL1_1_Source_(_Post_z_count_, (size), _Post2_impl_(__zterm_impl,__count_impl(size)) _Post_valid_impl_)
#define _Post_z_bytecount_(size) _SAL1_1_Source_(_Post_z_bytecount_, (size), _Post2_impl_(__zterm_impl,__bytecount_impl(size)) _Post_valid_impl_)
#define _Post_z_count_c_(size) _SAL1_1_Source_(_Post_z_count_c_, (size), _Post2_impl_(__zterm_impl,__count_c_impl(size)) _Post_valid_impl_)
#define _Post_z_bytecount_c_(size) _SAL1_1_Source_(_Post_z_bytecount_c_, (size), _Post2_impl_(__zterm_impl,__bytecount_c_impl(size)) _Post_valid_impl_)
#define _Post_z_count_x_(size) _SAL1_1_Source_(_Post_z_count_x_, (size), _Post2_impl_(__zterm_impl,__count_x_impl(size)) _Post_valid_impl_)
#define _Post_z_bytecount_x_(size) _SAL1_1_Source_(_Post_z_bytecount_x_, (size), _Post2_impl_(__zterm_impl,__bytecount_x_impl(size)) _Post_valid_impl_)






#define _Prepost_opt_z_ _SAL1_1_Source_(_Prepost_opt_z_, (), _Pre_opt_z_ _Post_z_)

#define _Prepost_count_(size) _SAL1_1_Source_(_Prepost_count_, (size), _Pre_count_(size) _Post_count_(size))
#define _Prepost_opt_count_(size) _SAL1_1_Source_(_Prepost_opt_count_, (size), _Pre_opt_count_(size) _Post_count_(size))
#define _Prepost_bytecount_(size) _SAL1_1_Source_(_Prepost_bytecount_, (size), _Pre_bytecount_(size) _Post_bytecount_(size))
#define _Prepost_opt_bytecount_(size) _SAL1_1_Source_(_Prepost_opt_bytecount_, (size), _Pre_opt_bytecount_(size) _Post_bytecount_(size))
#define _Prepost_count_c_(size) _SAL1_1_Source_(_Prepost_count_c_, (size), _Pre_count_c_(size) _Post_count_c_(size))
#define _Prepost_opt_count_c_(size) _SAL1_1_Source_(_Prepost_opt_count_c_, (size), _Pre_opt_count_c_(size) _Post_count_c_(size))
#define _Prepost_bytecount_c_(size) _SAL1_1_Source_(_Prepost_bytecount_c_, (size), _Pre_bytecount_c_(size) _Post_bytecount_c_(size))
#define _Prepost_opt_bytecount_c_(size) _SAL1_1_Source_(_Prepost_opt_bytecount_c_, (size), _Pre_opt_bytecount_c_(size) _Post_bytecount_c_(size))
#define _Prepost_count_x_(size) _SAL1_1_Source_(_Prepost_count_x_, (size), _Pre_count_x_(size) _Post_count_x_(size))
#define _Prepost_opt_count_x_(size) _SAL1_1_Source_(_Prepost_opt_count_x_, (size), _Pre_opt_count_x_(size) _Post_count_x_(size))
#define _Prepost_bytecount_x_(size) _SAL1_1_Source_(_Prepost_bytecount_x_, (size), _Pre_bytecount_x_(size) _Post_bytecount_x_(size))
#define _Prepost_opt_bytecount_x_(size) _SAL1_1_Source_(_Prepost_opt_bytecount_x_, (size), _Pre_opt_bytecount_x_(size) _Post_bytecount_x_(size))

#define _Prepost_valid_ _SAL1_1_Source_(_Prepost_valid_, (), _Pre_valid_ _Post_valid_)
#define _Prepost_opt_valid_ _SAL1_1_Source_(_Prepost_opt_valid_, (), _Pre_opt_valid_ _Post_valid_)







#define _Deref_prepost_z_ _SAL1_1_Source_(_Deref_prepost_z_, (), _Deref_pre_z_ _Deref_post_z_)
#define _Deref_prepost_opt_z_ _SAL1_1_Source_(_Deref_prepost_opt_z_, (), _Deref_pre_opt_z_ _Deref_post_opt_z_)

#define _Deref_prepost_cap_(size) _SAL1_1_Source_(_Deref_prepost_cap_, (size), _Deref_pre_cap_(size) _Deref_post_cap_(size))
#define _Deref_prepost_opt_cap_(size) _SAL1_1_Source_(_Deref_prepost_opt_cap_, (size), _Deref_pre_opt_cap_(size) _Deref_post_opt_cap_(size))
#define _Deref_prepost_bytecap_(size) _SAL1_1_Source_(_Deref_prepost_bytecap_, (size), _Deref_pre_bytecap_(size) _Deref_post_bytecap_(size))
#define _Deref_prepost_opt_bytecap_(size) _SAL1_1_Source_(_Deref_prepost_opt_bytecap_, (size), _Deref_pre_opt_bytecap_(size) _Deref_post_opt_bytecap_(size))

#define _Deref_prepost_cap_x_(size) _SAL1_1_Source_(_Deref_prepost_cap_x_, (size), _Deref_pre_cap_x_(size) _Deref_post_cap_x_(size))
#define _Deref_prepost_opt_cap_x_(size) _SAL1_1_Source_(_Deref_prepost_opt_cap_x_, (size), _Deref_pre_opt_cap_x_(size) _Deref_post_opt_cap_x_(size))
#define _Deref_prepost_bytecap_x_(size) _SAL1_1_Source_(_Deref_prepost_bytecap_x_, (size), _Deref_pre_bytecap_x_(size) _Deref_post_bytecap_x_(size))
#define _Deref_prepost_opt_bytecap_x_(size) _SAL1_1_Source_(_Deref_prepost_opt_bytecap_x_, (size), _Deref_pre_opt_bytecap_x_(size) _Deref_post_opt_bytecap_x_(size))

#define _Deref_prepost_z_cap_(size) _SAL1_1_Source_(_Deref_prepost_z_cap_, (size), _Deref_pre_z_cap_(size) _Deref_post_z_cap_(size))
#define _Deref_prepost_opt_z_cap_(size) _SAL1_1_Source_(_Deref_prepost_opt_z_cap_, (size), _Deref_pre_opt_z_cap_(size) _Deref_post_opt_z_cap_(size))
#define _Deref_prepost_z_bytecap_(size) _SAL1_1_Source_(_Deref_prepost_z_bytecap_, (size), _Deref_pre_z_bytecap_(size) _Deref_post_z_bytecap_(size))
#define _Deref_prepost_opt_z_bytecap_(size) _SAL1_1_Source_(_Deref_prepost_opt_z_bytecap_, (size), _Deref_pre_opt_z_bytecap_(size) _Deref_post_opt_z_bytecap_(size))

#define _Deref_prepost_valid_cap_(size) _SAL1_1_Source_(_Deref_prepost_valid_cap_, (size), _Deref_pre_valid_cap_(size) _Deref_post_valid_cap_(size))
#define _Deref_prepost_opt_valid_cap_(size) _SAL1_1_Source_(_Deref_prepost_opt_valid_cap_, (size), _Deref_pre_opt_valid_cap_(size) _Deref_post_opt_valid_cap_(size))
#define _Deref_prepost_valid_bytecap_(size) _SAL1_1_Source_(_Deref_prepost_valid_bytecap_, (size), _Deref_pre_valid_bytecap_(size) _Deref_post_valid_bytecap_(size))
#define _Deref_prepost_opt_valid_bytecap_(size) _SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_, (size), _Deref_pre_opt_valid_bytecap_(size) _Deref_post_opt_valid_bytecap_(size))

#define _Deref_prepost_valid_cap_x_(size) _SAL1_1_Source_(_Deref_prepost_valid_cap_x_, (size), _Deref_pre_valid_cap_x_(size) _Deref_post_valid_cap_x_(size))
#define _Deref_prepost_opt_valid_cap_x_(size) _SAL1_1_Source_(_Deref_prepost_opt_valid_cap_x_, (size), _Deref_pre_opt_valid_cap_x_(size) _Deref_post_opt_valid_cap_x_(size))
#define _Deref_prepost_valid_bytecap_x_(size) _SAL1_1_Source_(_Deref_prepost_valid_bytecap_x_, (size), _Deref_pre_valid_bytecap_x_(size) _Deref_post_valid_bytecap_x_(size))
#define _Deref_prepost_opt_valid_bytecap_x_(size) _SAL1_1_Source_(_Deref_prepost_opt_valid_bytecap_x_, (size), _Deref_pre_opt_valid_bytecap_x_(size) _Deref_post_opt_valid_bytecap_x_(size))

#define _Deref_prepost_count_(size) _SAL1_1_Source_(_Deref_prepost_count_, (size), _Deref_pre_count_(size) _Deref_post_count_(size))
#define _Deref_prepost_opt_count_(size) _SAL1_1_Source_(_Deref_prepost_opt_count_, (size), _Deref_pre_opt_count_(size) _Deref_post_opt_count_(size))
#define _Deref_prepost_bytecount_(size) _SAL1_1_Source_(_Deref_prepost_bytecount_, (size), _Deref_pre_bytecount_(size) _Deref_post_bytecount_(size))
#define _Deref_prepost_opt_bytecount_(size) _SAL1_1_Source_(_Deref_prepost_opt_bytecount_, (size), _Deref_pre_opt_bytecount_(size) _Deref_post_opt_bytecount_(size))

#define _Deref_prepost_count_x_(size) _SAL1_1_Source_(_Deref_prepost_count_x_, (size), _Deref_pre_count_x_(size) _Deref_post_count_x_(size))
#define _Deref_prepost_opt_count_x_(size) _SAL1_1_Source_(_Deref_prepost_opt_count_x_, (size), _Deref_pre_opt_count_x_(size) _Deref_post_opt_count_x_(size))
#define _Deref_prepost_bytecount_x_(size) _SAL1_1_Source_(_Deref_prepost_bytecount_x_, (size), _Deref_pre_bytecount_x_(size) _Deref_post_bytecount_x_(size))
#define _Deref_prepost_opt_bytecount_x_(size) _SAL1_1_Source_(_Deref_prepost_opt_bytecount_x_, (size), _Deref_pre_opt_bytecount_x_(size) _Deref_post_opt_bytecount_x_(size))

#define _Deref_prepost_valid_ _SAL1_1_Source_(_Deref_prepost_valid_, (), _Deref_pre_valid_ _Deref_post_valid_)
#define _Deref_prepost_opt_valid_ _SAL1_1_Source_(_Deref_prepost_opt_valid_, (), _Deref_pre_opt_valid_ _Deref_post_opt_valid_)






#define _Deref_out_z_cap_c_(size) _SAL1_1_Source_(_Deref_out_z_cap_c_, (size), _Deref_pre_cap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_cap_c_(size) _SAL1_1_Source_(_Deref_inout_z_cap_c_, (size), _Deref_pre_z_cap_c_(size) _Deref_post_z_)
#define _Deref_out_z_bytecap_c_(size) _SAL1_1_Source_(_Deref_out_z_bytecap_c_, (size), _Deref_pre_bytecap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_bytecap_c_(size) _SAL1_1_Source_(_Deref_inout_z_bytecap_c_, (size), _Deref_pre_z_bytecap_c_(size) _Deref_post_z_)
#define _Deref_inout_z_ _SAL1_1_Source_(_Deref_inout_z_, (), _Deref_prepost_z_)

#pragma endregion Input Buffer SAL 1 compatibility macros
# 1623 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _SA_annotes0(n) 
#define _SA_annotes1(n,pp1) 
#define _SA_annotes2(n,pp1,pp2) 
#define _SA_annotes3(n,pp1,pp2,pp3) 

#define __ANNOTATION(fun) 
#define __PRIMOP(type,fun) 
#define __QUALIFIER(type,fun) 
# 2069 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _SAL_nop_impl_ X

#define _At_impl_(target,annos) 
#define _When_impl_(expr,annos) 
#define _Group_impl_(annos) 
#define _GrouP_impl_(annos) 
#define _At_buffer_impl_(target,iter,bound,annos) 
#define _Use_decl_anno_impl_ 
#define _Points_to_data_impl_ 
#define _Literal_impl_ 
#define _Notliteral_impl_ 
#define _Notref_impl_ 

#define _Pre_valid_impl_ 
#define _Post_valid_impl_ 
#define _Ret_valid_impl_ 

#define _Check_return_impl_ 
#define _Must_inspect_impl_ 

#define _Success_impl_(expr) 
#define _On_failure_impl_(annos) 
#define _Always_impl_(annos) 

#define _Printf_format_string_impl_ 
#define _Scanf_format_string_impl_ 
#define _Scanf_s_format_string_impl_ 

#define _In_bound_impl_ 
#define _Out_bound_impl_ 
#define _Ret_bound_impl_ 
#define _Deref_in_bound_impl_ 
#define _Deref_out_bound_impl_ 
#define _Deref_ret_bound_impl_ 

#define _Range_impl_(min,max) 
#define _In_range_impl_(min,max) 
#define _Out_range_impl_(min,max) 
#define _Ret_range_impl_(min,max) 
#define _Deref_in_range_impl_(min,max) 
#define _Deref_out_range_impl_(min,max) 
#define _Deref_ret_range_impl_(min,max) 

#define _Satisfies_impl_(expr) 
#define _Pre_satisfies_impl_(expr) 
#define _Post_satisfies_impl_(expr) 

#define _Null_impl_ 
#define _Notnull_impl_ 
#define _Maybenull_impl_ 

#define _Valid_impl_ 
#define _Notvalid_impl_ 
#define _Maybevalid_impl_ 

#define _Field_range_impl_(min,max) 

#define _Pre_impl_ 
#define _Pre1_impl_(p1) 
#define _Pre2_impl_(p1,p2) 
#define _Pre3_impl_(p1,p2,p3) 

#define _Post_impl_ 
#define _Post1_impl_(p1) 
#define _Post2_impl_(p1,p2) 
#define _Post3_impl_(p1,p2,p3) 

#define _Ret1_impl_(p1) 
#define _Ret2_impl_(p1,p2) 
#define _Ret3_impl_(p1,p2,p3) 

#define _Deref_pre1_impl_(p1) 
#define _Deref_pre2_impl_(p1,p2) 
#define _Deref_pre3_impl_(p1,p2,p3) 

#define _Deref_post1_impl_(p1) 
#define _Deref_post2_impl_(p1,p2) 
#define _Deref_post3_impl_(p1,p2,p3) 

#define _Deref_ret1_impl_(p1) 
#define _Deref_ret2_impl_(p1,p2) 
#define _Deref_ret3_impl_(p1,p2,p3) 

#define _Deref2_pre1_impl_(p1) 
#define _Deref2_post1_impl_(p1) 
#define _Deref2_ret1_impl_(p1) 

#define _Readable_bytes_impl_(size) 
#define _Readable_elements_impl_(size) 
#define _Writable_bytes_impl_(size) 
#define _Writable_elements_impl_(size) 

#define _Null_terminated_impl_ 
#define _NullNull_terminated_impl_ 


#define __inner_typefix(ctype) 
#define __inner_exceptthat 
# 2375 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __specstrings 
# 2384 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __nothrow 
# 2615 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __null 
#define __notnull 
#define __maybenull 
#define __readonly 
#define __notreadonly 
#define __maybereadonly 
#define __valid 
#define __notvalid 
#define __maybevalid 
#define __readableTo(extent) 
#define __elem_readableTo(size) 
#define __byte_readableTo(size) 
#define __writableTo(size) 
#define __elem_writableTo(size) 
#define __byte_writableTo(size) 
#define __deref 
#define __pre 
#define __post 
#define __precond(expr) 
#define __postcond(expr) 
#define __exceptthat 
#define __inner_override 
#define __inner_callback 
#define __inner_blocksOn(resource) 
#define __inner_fallthrough_dec 
#define __inner_fallthrough 
#define __refparam 
#define __inner_control_entrypoint(category) 
#define __inner_data_entrypoint(category) 

#define __post_except_maybenull 
#define __pre_except_maybenull 
#define __post_deref_except_maybenull 
#define __pre_deref_except_maybenull 

#define __inexpressible_readableTo(size) 
#define __inexpressible_writableTo(size) 
# 2665 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __ecount(size) _SAL1_Source_(__ecount, (size), __notnull __elem_writableTo(size))
#define __bcount(size) _SAL1_Source_(__bcount, (size), __notnull __byte_writableTo(size))
#define __in _SAL1_Source_(__in, (), _In_)
#define __in_ecount(size) _SAL1_Source_(__in_ecount, (size), _In_reads_(size))
#define __in_bcount(size) _SAL1_Source_(__in_bcount, (size), _In_reads_bytes_(size))
#define __in_z _SAL1_Source_(__in_z, (), _In_z_)
#define __in_ecount_z(size) _SAL1_Source_(__in_ecount_z, (size), _In_reads_z_(size))
#define __in_bcount_z(size) _SAL1_Source_(__in_bcount_z, (size), __in_bcount(size) __pre __nullterminated)
#define __in_nz _SAL1_Source_(__in_nz, (), __in)
#define __in_ecount_nz(size) _SAL1_Source_(__in_ecount_nz, (size), __in_ecount(size))
#define __in_bcount_nz(size) _SAL1_Source_(__in_bcount_nz, (size), __in_bcount(size))
#define __out _SAL1_Source_(__out, (), _Out_)
#define __out_ecount(size) _SAL1_Source_(__out_ecount, (size), _Out_writes_(size))
#define __out_bcount(size) _SAL1_Source_(__out_bcount, (size), _Out_writes_bytes_(size))
#define __out_ecount_part(size,length) _SAL1_Source_(__out_ecount_part, (size,length), _Out_writes_to_(size,length))
#define __out_bcount_part(size,length) _SAL1_Source_(__out_bcount_part, (size,length), _Out_writes_bytes_to_(size,length))
#define __out_ecount_full(size) _SAL1_Source_(__out_ecount_full, (size), _Out_writes_all_(size))
#define __out_bcount_full(size) _SAL1_Source_(__out_bcount_full, (size), _Out_writes_bytes_all_(size))
#define __out_z _SAL1_Source_(__out_z, (), __post __valid __refparam __post __nullterminated)
#define __out_z_opt _SAL1_Source_(__out_z_opt, (), __post __valid __refparam __post __nullterminated __pre_except_maybenull)
#define __out_ecount_z(size) _SAL1_Source_(__out_ecount_z, (size), __ecount(size) __post __valid __refparam __post __nullterminated)
#define __out_bcount_z(size) _SAL1_Source_(__out_bcount_z, (size), __bcount(size) __post __valid __refparam __post __nullterminated)
#define __out_ecount_part_z(size,length) _SAL1_Source_(__out_ecount_part_z, (size,length), __out_ecount_part(size,length) __post __nullterminated)
#define __out_bcount_part_z(size,length) _SAL1_Source_(__out_bcount_part_z, (size,length), __out_bcount_part(size,length) __post __nullterminated)
#define __out_ecount_full_z(size) _SAL1_Source_(__out_ecount_full_z, (size), __out_ecount_full(size) __post __nullterminated)
#define __out_bcount_full_z(size) _SAL1_Source_(__out_bcount_full_z, (size), __out_bcount_full(size) __post __nullterminated)
#define __out_nz _SAL1_Source_(__out_nz, (), __post __valid __refparam)
#define __out_nz_opt _SAL1_Source_(__out_nz_opt, (), __post __valid __refparam __post_except_maybenull_)
#define __out_ecount_nz(size) _SAL1_Source_(__out_ecount_nz, (size), __ecount(size) __post __valid __refparam)
#define __out_bcount_nz(size) _SAL1_Source_(__out_bcount_nz, (size), __bcount(size) __post __valid __refparam)
#define __inout _SAL1_Source_(__inout, (), _Inout_)
#define __inout_ecount(size) _SAL1_Source_(__inout_ecount, (size), _Inout_updates_(size))
#define __inout_bcount(size) _SAL1_Source_(__inout_bcount, (size), _Inout_updates_bytes_(size))
#define __inout_ecount_part(size,length) _SAL1_Source_(__inout_ecount_part, (size,length), _Inout_updates_to_(size,length))
#define __inout_bcount_part(size,length) _SAL1_Source_(__inout_bcount_part, (size,length), _Inout_updates_bytes_to_(size,length))
#define __inout_ecount_full(size) _SAL1_Source_(__inout_ecount_full, (size), _Inout_updates_all_(size))
#define __inout_bcount_full(size) _SAL1_Source_(__inout_bcount_full, (size), _Inout_updates_bytes_all_(size))
#define __inout_z _SAL1_Source_(__inout_z, (), _Inout_z_)
#define __inout_ecount_z(size) _SAL1_Source_(__inout_ecount_z, (size), _Inout_updates_z_(size))
#define __inout_bcount_z(size) _SAL1_Source_(__inout_bcount_z, (size), __inout_bcount(size) __pre __nullterminated __post __nullterminated)
#define __inout_nz _SAL1_Source_(__inout_nz, (), __inout)
#define __inout_ecount_nz(size) _SAL1_Source_(__inout_ecount_nz, (size), __inout_ecount(size))
#define __inout_bcount_nz(size) _SAL1_Source_(__inout_bcount_nz, (size), __inout_bcount(size))
#define __ecount_opt(size) _SAL1_Source_(__ecount_opt, (size), __ecount(size) __pre_except_maybenull)
#define __bcount_opt(size) _SAL1_Source_(__bcount_opt, (size), __bcount(size) __pre_except_maybenull)
#define __in_opt _SAL1_Source_(__in_opt, (), _In_opt_)
#define __in_ecount_opt(size) _SAL1_Source_(__in_ecount_opt, (size), _In_reads_opt_(size))
#define __in_bcount_opt(size) _SAL1_Source_(__in_bcount_opt, (size), _In_reads_bytes_opt_(size))
#define __in_z_opt _SAL1_Source_(__in_z_opt, (), _In_opt_z_)
#define __in_ecount_z_opt(size) _SAL1_Source_(__in_ecount_z_opt, (size), __in_ecount_opt(size) __pre __nullterminated)
#define __in_bcount_z_opt(size) _SAL1_Source_(__in_bcount_z_opt, (size), __in_bcount_opt(size) __pre __nullterminated)
#define __in_nz_opt _SAL1_Source_(__in_nz_opt, (), __in_opt)
#define __in_ecount_nz_opt(size) _SAL1_Source_(__in_ecount_nz_opt, (size), __in_ecount_opt(size))
#define __in_bcount_nz_opt(size) _SAL1_Source_(__in_bcount_nz_opt, (size), __in_bcount_opt(size))
#define __out_opt _SAL1_Source_(__out_opt, (), _Out_opt_)
#define __out_ecount_opt(size) _SAL1_Source_(__out_ecount_opt, (size), _Out_writes_opt_(size))
#define __out_bcount_opt(size) _SAL1_Source_(__out_bcount_opt, (size), _Out_writes_bytes_opt_(size))
#define __out_ecount_part_opt(size,length) _SAL1_Source_(__out_ecount_part_opt, (size,length), __out_ecount_part(size,length) __pre_except_maybenull)
#define __out_bcount_part_opt(size,length) _SAL1_Source_(__out_bcount_part_opt, (size,length), __out_bcount_part(size,length) __pre_except_maybenull)
#define __out_ecount_full_opt(size) _SAL1_Source_(__out_ecount_full_opt, (size), __out_ecount_full(size) __pre_except_maybenull)
#define __out_bcount_full_opt(size) _SAL1_Source_(__out_bcount_full_opt, (size), __out_bcount_full(size) __pre_except_maybenull)
#define __out_ecount_z_opt(size) _SAL1_Source_(__out_ecount_z_opt, (size), __out_ecount_opt(size) __post __nullterminated)
#define __out_bcount_z_opt(size) _SAL1_Source_(__out_bcount_z_opt, (size), __out_bcount_opt(size) __post __nullterminated)
#define __out_ecount_part_z_opt(size,length) _SAL1_Source_(__out_ecount_part_z_opt, (size,length), __out_ecount_part_opt(size,length) __post __nullterminated)
#define __out_bcount_part_z_opt(size,length) _SAL1_Source_(__out_bcount_part_z_opt, (size,length), __out_bcount_part_opt(size,length) __post __nullterminated)
#define __out_ecount_full_z_opt(size) _SAL1_Source_(__out_ecount_full_z_opt, (size), __out_ecount_full_opt(size) __post __nullterminated)
#define __out_bcount_full_z_opt(size) _SAL1_Source_(__out_bcount_full_z_opt, (size), __out_bcount_full_opt(size) __post __nullterminated)
#define __out_ecount_nz_opt(size) _SAL1_Source_(__out_ecount_nz_opt, (size), __out_ecount_opt(size) __post __nullterminated)
#define __out_bcount_nz_opt(size) _SAL1_Source_(__out_bcount_nz_opt, (size), __out_bcount_opt(size) __post __nullterminated)
#define __inout_opt _SAL1_Source_(__inout_opt, (), _Inout_opt_)
#define __inout_ecount_opt(size) _SAL1_Source_(__inout_ecount_opt, (size), __inout_ecount(size) __pre_except_maybenull)
#define __inout_bcount_opt(size) _SAL1_Source_(__inout_bcount_opt, (size), __inout_bcount(size) __pre_except_maybenull)
#define __inout_ecount_part_opt(size,length) _SAL1_Source_(__inout_ecount_part_opt, (size,length), __inout_ecount_part(size,length) __pre_except_maybenull)
#define __inout_bcount_part_opt(size,length) _SAL1_Source_(__inout_bcount_part_opt, (size,length), __inout_bcount_part(size,length) __pre_except_maybenull)
#define __inout_ecount_full_opt(size) _SAL1_Source_(__inout_ecount_full_opt, (size), __inout_ecount_full(size) __pre_except_maybenull)
#define __inout_bcount_full_opt(size) _SAL1_Source_(__inout_bcount_full_opt, (size), __inout_bcount_full(size) __pre_except_maybenull)
#define __inout_z_opt _SAL1_Source_(__inout_z_opt, (), __inout_opt __pre __nullterminated __post __nullterminated)
#define __inout_ecount_z_opt(size) _SAL1_Source_(__inout_ecount_z_opt, (size), __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated)
#define __inout_ecount_z_opt(size) _SAL1_Source_(__inout_ecount_z_opt, (size), __inout_ecount_opt(size) __pre __nullterminated __post __nullterminated)
#define __inout_bcount_z_opt(size) _SAL1_Source_(__inout_bcount_z_opt, (size), __inout_bcount_opt(size))
#define __inout_nz_opt _SAL1_Source_(__inout_nz_opt, (), __inout_opt)
#define __inout_ecount_nz_opt(size) _SAL1_Source_(__inout_ecount_nz_opt, (size), __inout_ecount_opt(size))
#define __inout_bcount_nz_opt(size) _SAL1_Source_(__inout_bcount_nz_opt, (size), __inout_bcount_opt(size))
#define __deref_ecount(size) _SAL1_Source_(__deref_ecount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __elem_writableTo(size))
#define __deref_bcount(size) _SAL1_Source_(__deref_bcount, (size), _Notref_ __ecount(1) __post _Notref_ __elem_readableTo(1) __post _Notref_ __deref _Notref_ __notnull __post __deref __byte_writableTo(size))
#define __deref_out _SAL1_Source_(__deref_out, (), _Outptr_)
#define __deref_out_ecount(size) _SAL1_Source_(__deref_out_ecount, (size), _Outptr_result_buffer_(size))
#define __deref_out_bcount(size) _SAL1_Source_(__deref_out_bcount, (size), _Outptr_result_bytebuffer_(size))
#define __deref_out_ecount_part(size,length) _SAL1_Source_(__deref_out_ecount_part, (size,length), _Outptr_result_buffer_to_(size,length))
#define __deref_out_bcount_part(size,length) _SAL1_Source_(__deref_out_bcount_part, (size,length), _Outptr_result_bytebuffer_to_(size,length))
#define __deref_out_ecount_full(size) _SAL1_Source_(__deref_out_ecount_full, (size), __deref_out_ecount_part(size,size))
#define __deref_out_bcount_full(size) _SAL1_Source_(__deref_out_bcount_full, (size), __deref_out_bcount_part(size,size))
#define __deref_out_z _SAL1_Source_(__deref_out_z, (), _Outptr_result_z_)
#define __deref_out_ecount_z(size) _SAL1_Source_(__deref_out_ecount_z, (size), __deref_out_ecount(size) __post __deref __nullterminated)
#define __deref_out_bcount_z(size) _SAL1_Source_(__deref_out_bcount_z, (size), __deref_out_bcount(size) __post __deref __nullterminated)
#define __deref_out_nz _SAL1_Source_(__deref_out_nz, (), __deref_out)
#define __deref_out_ecount_nz(size) _SAL1_Source_(__deref_out_ecount_nz, (size), __deref_out_ecount(size))
#define __deref_out_bcount_nz(size) _SAL1_Source_(__deref_out_bcount_nz, (size), __deref_out_ecount(size))
#define __deref_inout _SAL1_Source_(__deref_inout, (), _Notref_ __notnull _Notref_ __elem_readableTo(1) __pre __deref __valid __post _Notref_ __deref __valid __refparam)
#define __deref_inout_z _SAL1_Source_(__deref_inout_z, (), __deref_inout __pre __deref __nullterminated __post _Notref_ __deref __nullterminated)
#define __deref_inout_ecount(size) _SAL1_Source_(__deref_inout_ecount, (size), __deref_inout __pre __deref __elem_writableTo(size) __post _Notref_ __deref __elem_writableTo(size))
#define __deref_inout_bcount(size) _SAL1_Source_(__deref_inout_bcount, (size), __deref_inout __pre __deref __byte_writableTo(size) __post _Notref_ __deref __byte_writableTo(size))
#define __deref_inout_ecount_part(size,length) _SAL1_Source_(__deref_inout_ecount_part, (size,length), __deref_inout_ecount(size) __pre __deref __elem_readableTo(length) __post __deref __elem_readableTo(length))
#define __deref_inout_bcount_part(size,length) _SAL1_Source_(__deref_inout_bcount_part, (size,length), __deref_inout_bcount(size) __pre __deref __byte_readableTo(length) __post __deref __byte_readableTo(length))
#define __deref_inout_ecount_full(size) _SAL1_Source_(__deref_inout_ecount_full, (size), __deref_inout_ecount_part(size,size))
#define __deref_inout_bcount_full(size) _SAL1_Source_(__deref_inout_bcount_full, (size), __deref_inout_bcount_part(size,size))
#define __deref_inout_ecount_z(size) _SAL1_Source_(__deref_inout_ecount_z, (size), __deref_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_bcount_z(size) _SAL1_Source_(__deref_inout_bcount_z, (size), __deref_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_nz _SAL1_Source_(__deref_inout_nz, (), __deref_inout)
#define __deref_inout_ecount_nz(size) _SAL1_Source_(__deref_inout_ecount_nz, (size), __deref_inout_ecount(size))
#define __deref_inout_bcount_nz(size) _SAL1_Source_(__deref_inout_bcount_nz, (size), __deref_inout_ecount(size))
#define __deref_ecount_opt(size) _SAL1_Source_(__deref_ecount_opt, (size), __deref_ecount(size) __post_deref_except_maybenull)
#define __deref_bcount_opt(size) _SAL1_Source_(__deref_bcount_opt, (size), __deref_bcount(size) __post_deref_except_maybenull)
#define __deref_out_opt _SAL1_Source_(__deref_out_opt, (), __deref_out __post_deref_except_maybenull)
#define __deref_out_ecount_opt(size) _SAL1_Source_(__deref_out_ecount_opt, (size), __deref_out_ecount(size) __post_deref_except_maybenull)
#define __deref_out_bcount_opt(size) _SAL1_Source_(__deref_out_bcount_opt, (size), __deref_out_bcount(size) __post_deref_except_maybenull)
#define __deref_out_ecount_part_opt(size,length) _SAL1_Source_(__deref_out_ecount_part_opt, (size,length), __deref_out_ecount_part(size,length) __post_deref_except_maybenull)
#define __deref_out_bcount_part_opt(size,length) _SAL1_Source_(__deref_out_bcount_part_opt, (size,length), __deref_out_bcount_part(size,length) __post_deref_except_maybenull)
#define __deref_out_ecount_full_opt(size) _SAL1_Source_(__deref_out_ecount_full_opt, (size), __deref_out_ecount_full(size) __post_deref_except_maybenull)
#define __deref_out_bcount_full_opt(size) _SAL1_Source_(__deref_out_bcount_full_opt, (size), __deref_out_bcount_full(size) __post_deref_except_maybenull)
#define __deref_out_z_opt _SAL1_Source_(__deref_out_z_opt, (), _Outptr_result_maybenull_z_)
#define __deref_out_ecount_z_opt(size) _SAL1_Source_(__deref_out_ecount_z_opt, (size), __deref_out_ecount_opt(size) __post __deref __nullterminated)
#define __deref_out_bcount_z_opt(size) _SAL1_Source_(__deref_out_bcount_z_opt, (size), __deref_out_bcount_opt(size) __post __deref __nullterminated)
#define __deref_out_nz_opt _SAL1_Source_(__deref_out_nz_opt, (), __deref_out_opt)
#define __deref_out_ecount_nz_opt(size) _SAL1_Source_(__deref_out_ecount_nz_opt, (size), __deref_out_ecount_opt(size))
#define __deref_out_bcount_nz_opt(size) _SAL1_Source_(__deref_out_bcount_nz_opt, (size), __deref_out_bcount_opt(size))
#define __deref_inout_opt _SAL1_Source_(__deref_inout_opt, (), __deref_inout __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_opt(size) _SAL1_Source_(__deref_inout_ecount_opt, (size), __deref_inout_ecount(size) __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_opt(size) _SAL1_Source_(__deref_inout_bcount_opt, (size), __deref_inout_bcount(size) __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_part_opt(size,length) _SAL1_Source_(__deref_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part(size,length) __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_part_opt(size,length) _SAL1_Source_(__deref_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part(size,length) __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_ecount_full_opt(size) _SAL1_Source_(__deref_inout_ecount_full_opt, (size), __deref_inout_ecount_full(size) __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_bcount_full_opt(size) _SAL1_Source_(__deref_inout_bcount_full_opt, (size), __deref_inout_bcount_full(size) __pre_deref_except_maybenull __post_deref_except_maybenull)
#define __deref_inout_z_opt _SAL1_Source_(__deref_inout_z_opt, (), __deref_inout_opt __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_ecount_z_opt(size) _SAL1_Source_(__deref_inout_ecount_z_opt, (size), __deref_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_bcount_z_opt(size) _SAL1_Source_(__deref_inout_bcount_z_opt, (size), __deref_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_inout_nz_opt _SAL1_Source_(__deref_inout_nz_opt, (), __deref_inout_opt)
#define __deref_inout_ecount_nz_opt(size) _SAL1_Source_(__deref_inout_ecount_nz_opt, (size), __deref_inout_ecount_opt(size))
#define __deref_inout_bcount_nz_opt(size) _SAL1_Source_(__deref_inout_bcount_nz_opt, (size), __deref_inout_bcount_opt(size))
#define __deref_opt_ecount(size) _SAL1_Source_(__deref_opt_ecount, (size), __deref_ecount(size) __pre_except_maybenull)
#define __deref_opt_bcount(size) _SAL1_Source_(__deref_opt_bcount, (size), __deref_bcount(size) __pre_except_maybenull)
#define __deref_opt_out _SAL1_Source_(__deref_opt_out, (), _Outptr_opt_)
#define __deref_opt_out_z _SAL1_Source_(__deref_opt_out_z, (), _Outptr_opt_result_z_)
#define __deref_opt_out_ecount(size) _SAL1_Source_(__deref_opt_out_ecount, (size), __deref_out_ecount(size) __pre_except_maybenull)
#define __deref_opt_out_bcount(size) _SAL1_Source_(__deref_opt_out_bcount, (size), __deref_out_bcount(size) __pre_except_maybenull)
#define __deref_opt_out_ecount_part(size,length) _SAL1_Source_(__deref_opt_out_ecount_part, (size,length), __deref_out_ecount_part(size,length) __pre_except_maybenull)
#define __deref_opt_out_bcount_part(size,length) _SAL1_Source_(__deref_opt_out_bcount_part, (size,length), __deref_out_bcount_part(size,length) __pre_except_maybenull)
#define __deref_opt_out_ecount_full(size) _SAL1_Source_(__deref_opt_out_ecount_full, (size), __deref_out_ecount_full(size) __pre_except_maybenull)
#define __deref_opt_out_bcount_full(size) _SAL1_Source_(__deref_opt_out_bcount_full, (size), __deref_out_bcount_full(size) __pre_except_maybenull)
#define __deref_opt_inout _SAL1_Source_(__deref_opt_inout, (), _Inout_opt_)
#define __deref_opt_inout_ecount(size) _SAL1_Source_(__deref_opt_inout_ecount, (size), __deref_inout_ecount(size) __pre_except_maybenull)
#define __deref_opt_inout_bcount(size) _SAL1_Source_(__deref_opt_inout_bcount, (size), __deref_inout_bcount(size) __pre_except_maybenull)
#define __deref_opt_inout_ecount_part(size,length) _SAL1_Source_(__deref_opt_inout_ecount_part, (size,length), __deref_inout_ecount_part(size,length) __pre_except_maybenull)
#define __deref_opt_inout_bcount_part(size,length) _SAL1_Source_(__deref_opt_inout_bcount_part, (size,length), __deref_inout_bcount_part(size,length) __pre_except_maybenull)
#define __deref_opt_inout_ecount_full(size) _SAL1_Source_(__deref_opt_inout_ecount_full, (size), __deref_inout_ecount_full(size) __pre_except_maybenull)
#define __deref_opt_inout_bcount_full(size) _SAL1_Source_(__deref_opt_inout_bcount_full, (size), __deref_inout_bcount_full(size) __pre_except_maybenull)
#define __deref_opt_inout_z _SAL1_Source_(__deref_opt_inout_z, (), __deref_opt_inout __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_ecount_z(size) _SAL1_Source_(__deref_opt_inout_ecount_z, (size), __deref_opt_inout_ecount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_bcount_z(size) _SAL1_Source_(__deref_opt_inout_bcount_z, (size), __deref_opt_inout_bcount(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_nz _SAL1_Source_(__deref_opt_inout_nz, (), __deref_opt_inout)
#define __deref_opt_inout_ecount_nz(size) _SAL1_Source_(__deref_opt_inout_ecount_nz, (size), __deref_opt_inout_ecount(size))
#define __deref_opt_inout_bcount_nz(size) _SAL1_Source_(__deref_opt_inout_bcount_nz, (size), __deref_opt_inout_bcount(size))
#define __deref_opt_ecount_opt(size) _SAL1_Source_(__deref_opt_ecount_opt, (size), __deref_ecount_opt(size) __pre_except_maybenull)
#define __deref_opt_bcount_opt(size) _SAL1_Source_(__deref_opt_bcount_opt, (size), __deref_bcount_opt(size) __pre_except_maybenull)
#define __deref_opt_out_opt _SAL1_Source_(__deref_opt_out_opt, (), _Outptr_opt_result_maybenull_)
#define __deref_opt_out_ecount_opt(size) _SAL1_Source_(__deref_opt_out_ecount_opt, (size), __deref_out_ecount_opt(size) __pre_except_maybenull)
#define __deref_opt_out_bcount_opt(size) _SAL1_Source_(__deref_opt_out_bcount_opt, (size), __deref_out_bcount_opt(size) __pre_except_maybenull)
#define __deref_opt_out_ecount_part_opt(size,length) _SAL1_Source_(__deref_opt_out_ecount_part_opt, (size,length), __deref_out_ecount_part_opt(size,length) __pre_except_maybenull)
#define __deref_opt_out_bcount_part_opt(size,length) _SAL1_Source_(__deref_opt_out_bcount_part_opt, (size,length), __deref_out_bcount_part_opt(size,length) __pre_except_maybenull)
#define __deref_opt_out_ecount_full_opt(size) _SAL1_Source_(__deref_opt_out_ecount_full_opt, (size), __deref_out_ecount_full_opt(size) __pre_except_maybenull)
#define __deref_opt_out_bcount_full_opt(size) _SAL1_Source_(__deref_opt_out_bcount_full_opt, (size), __deref_out_bcount_full_opt(size) __pre_except_maybenull)
#define __deref_opt_out_z_opt _SAL1_Source_(__deref_opt_out_z_opt, (), __post __deref __valid __refparam __pre_except_maybenull __pre_deref_except_maybenull __post_deref_except_maybenull __post __deref __nullterminated)
#define __deref_opt_out_ecount_z_opt(size) _SAL1_Source_(__deref_opt_out_ecount_z_opt, (size), __deref_opt_out_ecount_opt(size) __post __deref __nullterminated)
#define __deref_opt_out_bcount_z_opt(size) _SAL1_Source_(__deref_opt_out_bcount_z_opt, (size), __deref_opt_out_bcount_opt(size) __post __deref __nullterminated)
#define __deref_opt_out_nz_opt _SAL1_Source_(__deref_opt_out_nz_opt, (), __deref_opt_out_opt)
#define __deref_opt_out_ecount_nz_opt(size) _SAL1_Source_(__deref_opt_out_ecount_nz_opt, (size), __deref_opt_out_ecount_opt(size))
#define __deref_opt_out_bcount_nz_opt(size) _SAL1_Source_(__deref_opt_out_bcount_nz_opt, (size), __deref_opt_out_bcount_opt(size))
#define __deref_opt_inout_opt _SAL1_Source_(__deref_opt_inout_opt, (), __deref_inout_opt __pre_except_maybenull)
#define __deref_opt_inout_ecount_opt(size) _SAL1_Source_(__deref_opt_inout_ecount_opt, (size), __deref_inout_ecount_opt(size) __pre_except_maybenull)
#define __deref_opt_inout_bcount_opt(size) _SAL1_Source_(__deref_opt_inout_bcount_opt, (size), __deref_inout_bcount_opt(size) __pre_except_maybenull)
#define __deref_opt_inout_ecount_part_opt(size,length) _SAL1_Source_(__deref_opt_inout_ecount_part_opt, (size,length), __deref_inout_ecount_part_opt(size,length) __pre_except_maybenull)
#define __deref_opt_inout_bcount_part_opt(size,length) _SAL1_Source_(__deref_opt_inout_bcount_part_opt, (size,length), __deref_inout_bcount_part_opt(size,length) __pre_except_maybenull)
#define __deref_opt_inout_ecount_full_opt(size) _SAL1_Source_(__deref_opt_inout_ecount_full_opt, (size), __deref_inout_ecount_full_opt(size) __pre_except_maybenull)
#define __deref_opt_inout_bcount_full_opt(size) _SAL1_Source_(__deref_opt_inout_bcount_full_opt, (size), __deref_inout_bcount_full_opt(size) __pre_except_maybenull)
#define __deref_opt_inout_z_opt _SAL1_Source_(__deref_opt_inout_z_opt, (), __deref_opt_inout_opt __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_ecount_z_opt(size) _SAL1_Source_(__deref_opt_inout_ecount_z_opt, (size), __deref_opt_inout_ecount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_bcount_z_opt(size) _SAL1_Source_(__deref_opt_inout_bcount_z_opt, (size), __deref_opt_inout_bcount_opt(size) __pre __deref __nullterminated __post __deref __nullterminated)
#define __deref_opt_inout_nz_opt _SAL1_Source_(__deref_opt_inout_nz_opt, (), __deref_opt_inout_opt)
#define __deref_opt_inout_ecount_nz_opt(size) _SAL1_Source_(__deref_opt_inout_ecount_nz_opt, (size), __deref_opt_inout_ecount_opt(size))
#define __deref_opt_inout_bcount_nz_opt(size) _SAL1_Source_(__deref_opt_inout_bcount_nz_opt, (size), __deref_opt_inout_bcount_opt(size))
# 2866 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __success(expr) _SAL1_1_Source_(__success, (expr), _Success_(expr))
#define __nullterminated _SAL1_Source_(__nullterminated, (), _Null_terminated_)
#define __nullnullterminated _SAL1_Source_(__nullnulltermiated, (), _SAL_nop_impl_)
#define __reserved _SAL1_Source_(__reserved, (), _Reserved_)
#define __checkReturn _SAL1_Source_(__checkReturn, (), _Check_return_)
#define __typefix(ctype) _SAL1_Source_(__typefix, (ctype), __inner_typefix(ctype))
#define __override __inner_override
#define __callback __inner_callback
#define __format_string _SAL1_1_Source_(__format_string, (), _Printf_format_string_)
#define __blocksOn(resource) _SAL_L_Source_(__blocksOn, (resource), __inner_blocksOn(resource))
#define __control_entrypoint(category) _SAL_L_Source_(__control_entrypoint, (category), __inner_control_entrypoint(category))
#define __data_entrypoint(category) _SAL_L_Source_(__data_entrypoint, (category), __inner_data_entrypoint(category))
# 2886 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __useHeader _Use_decl_anno_impl_
# 2896 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define __on_failure(annotes) _SAL1_1_Source_(__on_failure, (annotes), _On_failure_impl_(annotes _SAL_nop_impl_))



   
#define __fallthrough __inner_fallthrough






#define __analysis_assume(expr) 







#define _Analysis_assume_(expr) 



#define _Analysis_noreturn_ _SAL2_Source_(_Analysis_noreturn_, (), _SA_annotes0(SAL_terminates))
# 2929 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define _Analysis_assume_nullterminated_(x) 
# 2939 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"
#define ___MKID(x,y) x ## y
#define __MKID(x,y) ___MKID(x, y)
#define __GENSYM(x) __MKID(x, __COUNTER__)



#define _Analysis_mode_impl_(mode) _SAL2_Source_(_Analysis_mode_impl_, (mode), _SA_annotes1(SAL_analysisMode, #mode))







#define _Analysis_mode_(mode) __pragma(warning(disable: 28110 28111 28161 28162)) typedef _Analysis_mode_impl_(mode) int __GENSYM(__prefast_analysis_mode_flag);
# 2973 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h"


#define _In_function_class_(x) _In_function_class_(#x)
#define _Called_from_function_class_(x) _In_function_class_(x)

#define _Function_class_(x) _SAL2_Source_(_Function_class_, (x), _SA_annotes1(SAL_functionClassNew, _SA_SPECSTRIZE(x)))

#define _Enum_is_bitflag_ _SAL2_Source_(_Enum_is_bitflag_, (), _SA_annotes0(SAL_enumIsBitflag))
#define _Strict_type_match_ _SAL2_Source_(_Strict_type_match, (), _SA_annotes0(SAL_strictType2))

#define _Maybe_raises_SEH_exception_ _SAL2_Source_(_Maybe_raises_SEH_exception_, (x), _Pre_ _SA_annotes1(SAL_inTry,__yes))
#define _Raises_SEH_exception_ _SAL2_Source_(_Raises_SEH_exception_, (x), _Maybe_raises_SEH_exception_ _Analysis_noreturn_)



#define _Published_ _SAL2_Source_(_Published_, (), _SA_annotes0(SAL_externalIntf))





# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/ConcurrencySal.h" 1
# 17 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/ConcurrencySal.h"
#define CONCURRENCYSAL_H 

       
# 267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/ConcurrencySal.h"
#define _Interlocked_operand_ 


#define _Guarded_by_(lock) 
#define _Write_guarded_by_(lock) 
#define _Interlocked_ 
#define _Requires_lock_held_(lock) 
#define _Requires_exclusive_lock_held_(lock) 
#define _Requires_shared_lock_held_(lock) 
#define _Requires_lock_not_held_(lock) 
#define _Requires_no_locks_held_ 
#define _Acquires_lock_(lock) 
#define _Acquires_exclusive_lock_(lock) 
#define _Acquires_shared_lock_(lock) 
#define _Releases_lock_(lock) 
#define _Releases_exclusive_lock_(lock) 
#define _Releases_shared_lock_(lock) 
#define _Acquires_nonreentrant_lock_(lock) 
#define _Releases_nonreentrant_lock_(lock) 

#define _Post_same_lock_(lock1,lock2) 

#define _Internal_set_lock_count_(lock,count) 

#define _Create_lock_level_(level) 
#define _Has_lock_level_(level) 
#define _Internal_lock_level_order_(a,b) 
#define _Csalcat1_(x,y) 
#define _Csalcat2_(x,y) 
#define _Lock_level_order_(a,b) 
#define _No_competing_thread_ 
#define _Analysis_assume_lock_acquired_(lock) 
#define _Analysis_assume_lock_released_(lock) 
#define _Analysis_assume_lock_held_(lock) 
#define _Analysis_assume_lock_not_held_(lock) 
#define _Analysis_assume_same_lock_(lock1,lock2) 
#define _Function_ignore_lock_checking_(lock) 
#define _Analysis_suppress_lock_checking_(lock) 

#define _Benign_race_begin_ __pragma(warning(push))
#define _Benign_race_end_ __pragma(warning(pop))

#define _No_competing_thread_begin_ __pragma(warning(push))
#define _No_competing_thread_end_ __pragma(warning(pop))

#define _Has_lock_kind_(kind) 




#define __guarded_by(lock) 
#define __write_guarded_by(lock) 
#define __interlocked 
#define __requires_lock_held(lock) 
#define __requires_exclusive_lock_held(lock) 
#define __requires_shared_lock_held(lock) 
#define __requires_lock_not_held(lock) 
#define __requires_no_locks_held 
#define __acquires_lock(lock) 
#define __acquires_exclusive_lock(lock) 
#define __acquires_shared_lock(lock) 
#define __releases_lock(lock) 
#define __releases_exclusive_lock(lock) 
#define __releases_shared_lock(lock) 

#define __has_lock_property(kind) 
#define __declare_lock_level(level) 
#define __has_lock_level(level) 
#define __internal_lock_level_order(a,b) 
#define CSALCAT1(x,y) 
#define CSALCAT2(x,y) 
#define __lock_level_order(a,b) 
#define __no_competing_thread 
#define __analysis_assume_lock_acquired(lock) 
#define __analysis_assume_lock_released(lock) 
#define __function_ignore_lock_checking(lock) 
#define __analysis_suppress_lock_checking(lock) 

#define BENIGN_RACE_BEGIN __pragma(warning(push))
#define BENIGN_RACE_END __pragma(warning(pop))

#define NO_COMPETING_THREAD_BEGIN __pragma(warning(push))
#define NO_COMPETING_THREAD_END __pragma(warning(pop))
# 2995 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sal.h" 2
# 62 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h" 2



#define __SAL_H_FULL_VER 140050727
# 101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define __inner_bound 
#define __inner_range(lb,ub) 
#define __inner_assume_bound_dec 
#define __inner_assume_bound(i) 
#define __inner_allocator 

#define __static_context(ctx,annotes) 
#define __failure(x) 
#define __valueUndefined 
#define __failureDefault(x) 



#define __xcount(size) _SAL1_Source_(__xcount, (size), __notnull __inexpressible_writableTo(size))
#define __in_xcount(size) _SAL1_Source_(__in_xcount, (size), __in _Pre_ __inexpressible_readableTo(size))
#define __out_xcount(size) _SAL1_Source_(__out_xcount, (size), __xcount(size) _Post_ __valid __refparam)
#define __out_xcount_part(size,length) _SAL1_Source_(__out_xcount_part_, (size,length), __out_xcount(size) _Post_ __inexpressible_readableTo(length))
#define __out_xcount_full(size) _SAL1_Source_(__out_xcount_full, (size), __out_xcount_part(size,size))
#define __inout_xcount(size) _SAL1_Source_(__inout_xcount, (size), __out_xcount(size) _Pre_ __valid)
#define __inout_xcount_part(size,length) _SAL1_Source_(__inout_xcount_part, (size,length), __out_xcount_part(size,length) _Pre_ __valid _Pre_ __inexpressible_readableTo(length))
#define __inout_xcount_full(size) _SAL1_Source_(__inout_xcount_full, (size), __inout_xcount_part(size,size))
#define __xcount_opt(size) _SAL1_Source_(__xcount_opt, (size), __xcount(size) __exceptthat __maybenull)
#define __in_xcount_opt(size) _SAL1_Source_(__in_xcount_opt, (size), __in_xcount(size) __exceptthat __maybenull)
#define __out_xcount_opt(size) _SAL1_Source_(__out_xcount_opt, (size), __out_xcount(size) __exceptthat __maybenull)
#define __out_xcount_part_opt(size,length) _SAL1_Source_(__out_xcount_part_opt, (size,length), __out_xcount_part(size,length) __exceptthat __maybenull)
#define __out_xcount_full_opt(size) _SAL1_Source_(__out_xcount_full_opt, (size), __out_xcount_full(size) __exceptthat __maybenull)
#define __inout_xcount_opt(size) _SAL1_Source_(__inout_xcount_opt, (size), __inout_xcount(size) __exceptthat __maybenull)
#define __inout_xcount_part_opt(size,length) _SAL1_Source_(__inout_xcount_part_opt, (size, length), __inout_xcount_part(size,length) __exceptthat __maybenull)
#define __inout_xcount_full_opt(size) _SAL1_Source_(__inout_xcount_full_opt, (size), __inout_xcount_full(size) __exceptthat __maybenull)
#define __deref_xcount(size) _SAL1_Source_(__deref_xcount, (size), __ecount(1) _Post_ __elem_readableTo(1) _Post_ __deref __notnull _Post_ __deref __inexpressible_writableTo(size))
#define __deref_in _SAL1_Source_(__deref_in, (), __in _Pre_ __deref __deref __readonly)
#define __deref_in_ecount(size) _SAL1_Source_(__deref_in_ecount, (size), __deref_in _Pre_ __deref __elem_readableTo(size))
#define __deref_in_bcount(size) _SAL1_Source_(__deref_in_bcount, (size), __deref_in _Pre_ __deref __byte_readableTo(size))
#define __deref_in_xcount(size) _SAL1_Source_(__deref_in_xcount, (size), __deref_in _Pre_ __deref __inexpressible_readableTo(size))
#define __deref_out_xcount(size) _SAL1_Source_(__deref_out_xcount, (size), __deref_xcount(size) _Post_ __deref __valid __refparam)
#define __deref_out_xcount_part(size,length) _SAL1_Source_(__deref_out_xcount_part, (size,length), __deref_out_xcount(size) _Post_ __deref __inexpressible_readableTo(length))
#define __deref_out_xcount_full(size) _SAL1_Source_(__deref_out_xcount_full, (size), __deref_out_xcount_part(size,size))
#define __deref_out_xcount(size) _SAL1_Source_(__deref_out_xcount, (size), __deref_xcount(size) _Post_ __deref __valid __refparam)
#define __inout_xcount_opt(size) _SAL1_Source_(__inout_xcount_opt, (size), __inout_xcount(size) __exceptthat __maybenull)
#define __deref_xcount(size) _SAL1_Source_(__deref_xcount, (size), __ecount(1) _Post_ __elem_readableTo(1) _Post_ __deref __notnull _Post_ __deref __inexpressible_writableTo(size))
#define __deref_in _SAL1_Source_(__deref_in, (), __in _Pre_ __deref __deref __readonly)
#define __deref_in_ecount(size) _SAL1_Source_(__deref_in_ecount, (size), __deref_in _Pre_ __deref __elem_readableTo(size))
#define __deref_in_bcount(size) _SAL1_Source_(__deref_in_bcount, (size), __deref_in _Pre_ __deref __byte_readableTo(size))
#define __deref_in_xcount(size) _SAL1_Source_(__deref_in_xcount, (size), __deref_in _Pre_ __deref __inexpressible_readableTo(size))
#define __deref_out_xcount(size) _SAL1_Source_(__deref_out_xcount, (size), __deref_xcount(size) _Post_ __deref __valid __refparam)
#define __deref_out_xcount_part(size,length) _SAL1_Source_(__deref_out_xcount_part, (size,length), __deref_out_xcount(size) _Post_ __deref __inexpressible_readableTo(length))
#define __deref_out_xcount_full(size) _SAL1_Source_(__deref_out_xcount_full, (size), __deref_out_xcount_part(size,size))
#define __deref_out_xcount(size) _SAL1_Source_(__deref_out_xcount, (size), __deref_xcount(size) _Post_ __deref __valid __refparam)
#define __deref_inout_xcount(size) _SAL1_Source_(__deref_inout_xcount, (size), __deref_inout _Pre_ __deref __inexpressible_writableTo(size) _Post_ __deref __inexpressible_writableTo(size))
#define __deref_inout_xcount_part(size,length) _SAL1_Source_(__deref_inout_xcount_part, (size,length), __deref_inout_xcount(size) _Pre_ __deref __inexpressible_readableTo(length) _Post_ __deref __inexpressible_readableTo(length))
#define __deref_inout_xcount_full(size) _SAL1_Source_(__deref_inout_xcount_full, (size), __deref_inout_xcount_part(size,size))
#define __deref_xcount_opt(size) _SAL1_Source_(__deref_xcount_opt, (size), __deref_xcount(size) _Post_ __deref __exceptthat __maybenull)
#define __deref_in_opt _SAL1_Source_(__deref_in_opt, (), __deref_in _Pre_ __deref __exceptthat __maybenull)
#define __deref_in_opt_out _SAL1_Source_(__deref_in_opt_out, (), __deref_inout _Pre_ __deref __exceptthat __maybenull _Post_ __deref __notnull)
#define __deref_in_ecount_opt(size) _SAL1_Source_(__deref_in_ecount_opt, (size), __deref_in_ecount(size) _Pre_ __deref __exceptthat __maybenull)
#define __deref_in_bcount_opt(size) _SAL1_Source_(__deref_in_bcount_opt_, (size), __deref_in_bcount(size) _Pre_ __deref __exceptthat __maybenull)
#define __deref_in_xcount_opt(size) _SAL1_Source_(__deref_in_xcount_opt, (size), __deref_in_xcount(size) _Pre_ __deref __exceptthat __maybenull)
#define __deref_out_xcount_opt(size) _SAL1_Source_(__deref_out_xcount_opt, (size), __deref_out_xcount(size) _Post_ __deref __exceptthat __maybenull)
#define __deref_out_xcount_part_opt(size,length) _SAL1_Source_(__deref_out_xcount_part_opt, (size,length), __deref_out_xcount_part(size,length) _Post_ __deref __exceptthat __maybenull)
#define __deref_out_xcount_full_opt(size) _SAL1_Source_(__deref_out_xcount_full_opt, (size), __deref_out_xcount_full(size) _Post_ __deref __exceptthat __maybenull)
#define __deref_inout_xcount_opt(size) _SAL1_Source_(__deref_inout_xcount_opt, (size), __deref_inout_xcount(size) _Pre_ __deref __exceptthat __maybenull _Post_ __deref __exceptthat __maybenull)
#define __deref_inout_xcount_part_opt(size,length) _SAL1_Source_(__deref_inout_xcount_part_opt, (size,length), __deref_inout_xcount_part(size,length) _Pre_ __deref __exceptthat __maybenull _Post_ __deref __exceptthat __maybenull)
#define __deref_inout_xcount_full_opt(size) _SAL1_Source_(__deref_inout_xcount_full_opt, (size), __deref_inout_xcount_full(size) _Pre_ __deref __exceptthat __maybenull _Post_ __deref __exceptthat __maybenull)
#define __deref_opt_xcount(size) _SAL1_Source_(__deref_opt_xcount, (size), __deref_xcount(size) __exceptthat __maybenull)
#define __deref_opt_in _SAL1_Source_(__deref_opt_in, (), __deref_in __exceptthat __maybenull)
#define __deref_opt_in_ecount(size) _SAL1_Source_(__deref_opt_in_ecount, (size), __deref_in_ecount(size) __exceptthat __maybenull)
#define __deref_opt_in_bcount(size) _SAL1_Source_(__deref_opt_in_bcount, (size), __deref_in_bcount(size) __exceptthat __maybenull)
#define __deref_opt_in_xcount(size) _SAL1_Source_(__deref_opt_in_xcount, (size), __deref_in_xcount(size) __exceptthat __maybenull)
#define __deref_opt_out_xcount(size) _SAL1_Source_(__deref_opt_out_xcount, (size), __deref_out_xcount(size) __exceptthat __maybenull)
#define __deref_opt_out_xcount_part(size,length) _SAL1_Source_(__deref_opt_out_xcount_part, (size,length), __deref_out_xcount_part(size,length) __exceptthat __maybenull)
#define __deref_opt_out_xcount_full(size) _SAL1_Source_(__deref_opt_out_xcount_full, (size), __deref_out_xcount_full(size) __exceptthat __maybenull)
#define __deref_opt_inout_xcount(size) _SAL1_Source_(__deref_opt_inout_xcount, (size), __deref_inout_xcount(size) __exceptthat __maybenull)
#define __deref_opt_inout_xcount_part(size,length) _SAL1_Source_(__deref_opt_inout_xcount_part, (size,length), __deref_inout_xcount_part(size,length) __exceptthat __maybenull)
#define __deref_opt_inout_xcount_full(size) _SAL1_Source_(__deref_opt_inout_xcount_full, (size), __deref_inout_xcount_full(size) __exceptthat __maybenull)
#define __deref_opt_xcount_opt(size) _SAL1_Source_(__deref_opt_xcount_opt, (size), __deref_xcount_opt(size) __exceptthat __maybenull)
#define __deref_opt_in_opt _SAL1_Source_(__deref_opt_in_opt, (), __deref_in_opt __exceptthat __maybenull)
#define __deref_opt_in_ecount_opt(size) _SAL1_Source_(__deref_opt_in_ecount_opt, (size), __deref_in_ecount_opt(size) __exceptthat __maybenull)
#define __deref_opt_in_bcount_opt(size) _SAL1_Source_(__deref_opt_in_bcount_opt, (size), __deref_in_bcount_opt(size) __exceptthat __maybenull)
#define __deref_opt_in_xcount_opt(size) _SAL1_Source_(__deref_opt_in_xcount_opt, (size), __deref_in_xcount_opt(size) __exceptthat __maybenull)
#define __deref_opt_out_xcount_opt(size) _SAL1_Source_(__deref_opt_out_xcount_opt, (size), __deref_out_xcount_opt(size) __exceptthat __maybenull)
#define __deref_opt_out_xcount_part_opt(size,length) _SAL1_Source_(__deref_opt_out_xcount_part_opt, (size,length), __deref_out_xcount_part_opt(size,length) __exceptthat __maybenull)
#define __deref_opt_out_xcount_full_opt(size) _SAL1_Source_(__deref_opt_out_scount_full_opt, (size), __deref_out_xcount_full_opt(size) __exceptthat __maybenull)
#define __deref_opt_inout_xcount_opt(size) _SAL1_Source_(__deref_opt_inout_xcount_opt, (size), __deref_inout_xcount_opt(size) __exceptthat __maybenull)
#define __deref_opt_inout_xcount_part_opt(size,length) _SAL1_Source_(__deref_inout_xcount_part_opt(size, (size,length), length) __exceptthat __maybenull)
#define __deref_opt_inout_xcount_full_opt(size) _SAL1_Source_(__deref_opt_inout_scount_full_opt, (size), __deref_inout_xcount_full_opt(size) __exceptthat __maybenull)

#define __deref_in_ecount_iterator(size,incr) _SAL1_Source_(__deref_in_ecount_iterator, (size,incr), __inout _Pre_ __deref __elem_readableTo(size) __deref_out_range(==, _Old_(*_Curr_) + incr))
#define __deref_out_ecount_iterator(size,incr) _SAL1_Source_(__deref_out_ecount_iterator, (size,incr), __inout _Pre_ __deref __elem_writableTo(size) __deref_out_range(==, _Old_(*_Curr_) + incr))
#define __deref_inout_ecount_iterator(size,incr) _SAL1_Source_(__deref_inout_ecount_iterator, (size,incr), __inout _Pre_ __deref __elem_readableTo(size) _Pre_ __deref __elem_writableTo(size) __deref_out_range(==, _Old_(*_Curr_) + incr))

#define __post_bcount(size) _SAL1_Source_(__post_bcount, (size), _Post_ __byte_writableTo(size))
#define __post_ecount(size) _SAL1_Source_(__post_ecount, (size), _Post_ __elem_writableTo(size))

#define __deref_realloc_bcount(insize,outsize) _SAL1_Source_(__deref_realloc_bcount, (insize,outsize), __inout _Pre_ __deref __byte_readableTo(insize) _Post_ __deref __byte_writableTo(outsize))




#define __in_ecount_or_z(c) _SAL1_Source_(__in_ecount_or_z, (c), _When_(_String_length_(_Curr_) < (c), __in_z) _When_(_String_length_(_Curr_) >= (c), __in_ecount(c)))




#define __post_nullnullterminated 




#undef __nullnullterminated
#define __nullnullterminated _SAL1_Source_(__nullnullterminated, (), __inexpressible_readableTo("string terminated by two nulls") __nullterminated)

#undef __post_nullnullterminated
#define __post_nullnullterminated _SAL1_Source_(__post_nullnullterminated, (), _Post_ __inexpressible_readableTo("string terminated by two nulls") _Post_ __nullterminated)
# 321 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define __file_parser(typ) 
#define __file_parser_class(typ) 
#define __file_parser_library(typ) 
#define __source_code_content(typ) 
#define __class_code_content(typ) 
#define __analysis_assert(e) 
#define __analysis_hint(hint) 
#define __analysis_noreturn 

#define __inner_data_source(src_raw) 
#define __inner_this_data_source(src_raw) 
#define __inner_out_validated(typ_raw) 
#define __inner_this_out_validated(typ_raw) 
#define __inner_assume_validated_dec 
#define __inner_assume_validated(p) 
#define __inner_transfer(formal) 
#define __inner_encoded 
#define __inner_adt_prop(adt,prop) 
#define __inner_adt_add_prop(adt,prop) 
#define __inner_adt_remove_prop(adt,prop) 
#define __inner_adt_transfer_prop(arg) 
#define __inner_adt_type_props(typ) 
#define __inner_volatile 
#define __inner_nonvolatile 
#define __inner_possibly_notnullterminated 
# 355 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Memory_origin_(context) 
#define _Memory_origin_when_(previousContext,context) 
#define _Accessible_bytes_(context,expr) 
#define _Accessible_bytes_when_(previousContext,context,expr) 
#define _Pre_accessible_bytes_(context,expr) 
#define _Pre_accessible_bytes_when_(context,previousContext,expr) 
# 372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _User_ 
#define _User_on_(expr) 
#define _User_always_ 
#define _User_always_and_needs_probe_on_(mode) 
#define _Kernel_entry_ 
#define _Kernel_entry_always_ 



#define __field_ecount(size) _SAL1_Source_(__field_ecount, (size), __notnull __elem_writableTo(size))
#define __field_bcount(size) _SAL1_Source_(__field_bcount, (size), __notnull __byte_writableTo(size))
#define __field_xcount(size) _SAL1_Source_(__field_xcount, (size), __notnull __inexpressible_writableTo(size))

#define __field_ecount_opt(size) _SAL1_Source_(__field_ecount_opt, (size), __maybenull __elem_writableTo(size))
#define __field_bcount_opt(size) _SAL1_Source_(__field_bcount_opt, (size), __maybenull __byte_writableTo(size))
#define __field_xcount_opt(size) _SAL1_Source_(__field_xcount_opt, (size), __maybenull __inexpressible_writableTo(size))

#define __field_ecount_part(size,init) _SAL1_Source_(__field_ecount_part, (size,init), __notnull __elem_writableTo(size) __elem_readableTo(init))
#define __field_bcount_part(size,init) _SAL1_Source_(__field_bcount_part, (size,init), __notnull __byte_writableTo(size) __byte_readableTo(init))
#define __field_xcount_part(size,init) _SAL1_Source_(__field_xcount_part, (size,init), __notnull __inexpressible_writableTo(size) __inexpressible_readableTo(init))

#define __field_ecount_part_opt(size,init) _SAL1_Source_(__field_ecount_part_opt, (size,init), __maybenull __elem_writableTo(size) __elem_readableTo(init))
#define __field_bcount_part_opt(size,init) _SAL1_Source_(__field_bcount_part_opt, (size,init), __maybenull __byte_writableTo(size) __byte_readableTo(init))
#define __field_xcount_part_opt(size,init) _SAL1_Source_(__field_xcount_part_opt, (size,init), __maybenull __inexpressible_writableTo(size) __inexpressible_readableTo(init))

#define __field_ecount_full(size) _SAL1_Source_(__field_ecount_full, (size), __field_ecount_part(size,size))
#define __field_bcount_full(size) _SAL1_Source_(__field_bcount_full, (size), __field_bcount_part(size,size))
#define __field_xcount_full(size) _SAL1_Source_(__field_xcount_full, (size), __field_xcount_part(size,size))

#define __field_ecount_full_opt(size) _SAL1_Source_(__field_ecount_full_opt, (size), __field_ecount_part_opt(size,size))
#define __field_bcount_full_opt(size) _SAL1_Source_(__field_bcount_full_opt, (size), __field_bcount_part_opt(size,size))
#define __field_xcount_full_opt(size) _SAL1_Source_(__field_xcount_full_opt, (size), __field_xcount_part_opt(size,size))

#define __field_nullterminated _SAL1_Source_(__field_nullterminated, (), __nullterminated)

#define __struct_bcount(size) _SAL1_Source_(__struct_bcount, (size), __byte_writableTo(size))
#define __struct_xcount(size) _SAL1_Source_(__struct_xcount, (size), __inexpressible_writableTo(size))

#define __out_awcount(expr,size) _SAL1_Source_(__out_awcount, (expr,size), _Pre_ __notnull __byte_writableTo((expr) ? (size) : (size) * 2) _Post_ __valid __refparam)


#define __in_awcount(expr,size) _SAL1_Source_(__in_awcount, (expr,size), _Pre_ __valid _Pre_ _Notref_ __deref __readonly __byte_readableTo((expr) ? (size) : (size) * 2))


#define __post_invalid _SAL1_Source_(__post_invalid, (), _Post_ __notvalid)

#define __allocator _SAL_L_Source_(__allocator, (), __inner_allocator)
#define __deallocate(kind) _SAL_L_Source_(__deallocate, (kind), _Pre_ __notnull __post_invalid)
#define __deallocate_opt(kind) _SAL_L_Source_(__deallocate_opt, (kind), _Pre_ __maybenull __post_invalid)
#define __bound _SAL_L_Source_(__bound, (), __inner_bound)
#define __range(lb,ub) _SAL_L_Source_(__range, (lb,ub), __inner_range(lb,ub))
#define __in_bound _SAL_L_Source_(__in_bound, (), _Pre_ __inner_bound)
#define __out_bound _SAL_L_Source_(__out_bound, (), _Post_ __inner_bound)
#define __deref_out_bound _SAL_L_Source_(__deref_out_bound, (), _Post_ __deref __inner_bound)
#define __in_range(lb,ub) _SAL_L_Source_(__in_range, (lb,ub), _Pre_ __inner_range(lb,ub))
#define __out_range(lb,ub) _SAL_L_Source_(__out_range, (lb,ub), _Post_ __inner_range(lb,ub))
#define __deref_in_range(lb,ub) _SAL_L_Source_(__deref_in_range, (lb,ub), _Pre_ __deref __inner_range(lb,ub))
#define __deref_out_range(lb,ub) _SAL_L_Source_(__deref_out_range, (lb,ub), _Post_ __deref __inner_range(lb,ub))
#define __deref_inout_range(lb,ub) _SAL_L_Source_(__deref_inout_range, (lb,ub), __deref_in_range(lb,ub) __deref_out_range(lb,ub))
#define __field_range(lb,ub) _SAL_L_Source_(__field_range, (lb,ub), __range(lb,ub))
#define __field_data_source(src_sym) _SAL_L_Source_(__field_data_source, (lb,ub), __inner_data_source(#src_sym))

#define __range_max(a,b) _SAL_L_Source_(__range_max, (a,b), __range(==, a > b ? a : b))
#define __range_min(a,b) _SAL_L_Source_(__range_min, (a,b), __range(==, a < b ? a : b))



#define __in_data_source(src_sym) _SAL_L_Source_(__in_data_source, (src_sym), _Pre_ __inner_data_source(#src_sym))
#define __out_data_source(src_sym) _SAL_L_Source_(__out_data_source, (src_sym), _Post_ __inner_data_source(#src_sym))
#define __out_validated(typ_sym) _SAL_L_Source_(__out_validated, (src_sym), __inner_out_validated(#typ_sym))
#define __this_out_data_source(src_sym) _SAL_L_Source_(__this_out_data_source, (src_sym), __inner_this_data_source(#src_sym))
#define __this_out_validated(typ_sym) _SAL_L_Source_(__this_out_validated, (src_sym), __inner_this_out_validated(#typ_sym))
#define __transfer(formal) _SAL_L_Source_(__transfer, (src_sym), _Post_ __inner_transfer(formal))
#define __rpc_entry _SAL_L_Source_(__rpc_entry, (formal), __inner_control_entrypoint(RPC))
#define __kernel_entry _SAL_L_Source_(__kernel_entry, (), __inner_control_entrypoint(UserToKernel))
#define __gdi_entry _SAL_L_Source_(__gdi_entry, (), __inner_control_entrypoint(GDI))
#define __encoded_pointer _SAL_L_Source_(__encoded_pointer, (), __inner_encoded)
#define __encoded_array _SAL_L_Source_(__encoded_array, (), __inner_encoded)
#define __field_encoded_pointer _SAL_L_Source_(__field_encoded_pointer, (), __inner_encoded)
#define __field_encoded_array _SAL_L_Source_(__field_encoded_array, (), __inner_encoded)
# 466 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define __out_has_type_adt_props(typ) 

#define __deref_volatile _SAL_L_Source_(__deref_volatile, (), __deref __volatile)
#define __deref_nonvolatile _SAL_L_Source_(__deref_nonvolatile, (), __deref __nonvolatile)




#define __analysis_assume_nullterminated(x) _Analysis_assume_nullterminated_(x)
#define __assume_validated(p) __inner_assume_validated(p)
#define __assume_bound(i) __inner_assume_bound(i)
# 486 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Unreferenced_parameter_ _SAL2_Source_(_Unreferenced_parameter_, (), _Const_)





#define _Frees_ptr_ _SAL_L_Source_(_Frees_ptr_, (), _Pre_notnull_ _Post_ptr_invalid_ __drv_freesMem(Mem))


#define _Frees_ptr_opt_ _SAL_L_Source_(_Frees_ptr_opt_, (), _Pre_maybenull_ _Post_ptr_invalid_ __drv_freesMem(Mem))
# 505 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Reallocation_function_(after,before,size) _Success_((after) != NULL || (size) == 0) _At_((after), _Post_maybenull_ _Post_writable_byte_size_(size) _When_(((before) == NULL || (size) > 0), _Must_inspect_result_)) _At_((before), _Post_ptr_invalid_ __drv_freesMem(Mem))





#define _Ret_reallocated_bytes_(before,size) _Reallocation_function_(_Curr_, before, size)






#define _In_NLS_string_(size) _SAL_L_Source_(_In_NLS_string_, (size), _When_((size) < 0, _In_z_) _When_((size) >= 0, _In_reads_(size)))







#define _Flt_CompletionContext_Outptr_ _SAL_L_Source_(_Flt_CompletionContext_Outptr_, (), _Outptr_result_maybenull_ _Pre_valid_ _At_(*_Curr_, _Pre_null_ _When_(return != FLT_PREOP_SUCCESS_WITH_CALLBACK && return != FLT_PREOP_SYNCHRONIZE, _Post_null_)))







#define _Flt_ConnectionCookie_Outptr_ _SAL_L_Source_(_Flt_ConnectionCookie_Outptr_, (), _Outptr_result_maybenull_ _Pre_valid_ _At_(*_Curr_, _Pre_null_ _On_failure_(_Post_null_)))
# 557 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Writes_and_advances_ptr_(size) _SAL2_Source_(_Writes_and_advances_ptr_, (size), _At_((void*)_Curr_, _Inout_) _At_(_Curr_, _Pre_writable_size_(size) _Post_writable_size_(size) _Post_satisfies_(_Curr_ - _Old_(_Curr_) == _Old_(size) - size)) _At_(_Old_(_Curr_), _Post_readable_size_(_Old_(size) - size)))
# 568 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Writes_bytes_and_advances_ptr_(size) _SAL2_Source_(_Writes_bytes_and_advances_ptr, (size), _At_((void*)_Curr_, _Inout_) _At_(_Curr_, _Pre_writable_byte_size_(size) _Post_writable_byte_size_(size) _Post_satisfies_(((char*)_Curr_) - ((char*)_Old_(_Curr_)) == _Old_(size) - size)) _At_(_Old_(_Curr_), _Post_readable_byte_size_(_Old_(size) - size)))
# 584 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Post_equals_last_error_ _SAL2_Source_(_Post_equals_last_error_, (), _Post_satisfies_(_Curr_ != 0))
# 599 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Translates_Win32_to_HRESULT_(errorCode) _SAL2_Source_(_Translates_Win32_to_HRESULT_, (errorCode), _Always_( _When_((HRESULT)errorCode <= 0, _At_(_Curr_, _Post_equal_to_((HRESULT)errorCode))) _When_((HRESULT)errorCode > 0, _At_(_Curr_, _Post_equal_to_((HRESULT)((errorCode & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000))))))
# 619 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Translates_NTSTATUS_to_HRESULT_(status) _SAL2_Source_(_Translates_NTSTATUS_to_HRESULT_, (status), _Always_( _Post_equal_to_((HRESULT)(status | FACILITY_NT_BIT))))
# 637 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#define _Translates_last_error_to_HRESULT_ _SAL2_Source_(_Translates_last_error_to_HRESULT_, (), _Always_( _Post_satisfies_(_Curr_ < 0)))
# 674 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings_strict.h" 1
# 28 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings_strict.h"
#define __SPECSTRINGS_STRICT_LEVEL 1
# 675 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h" 2
# 689 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
#undef __ANNOTATION
#define __ANNOTATION(fun) 
#undef __PRIMOP
#define __PRIMOP(type,fun) 


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h" 1
# 118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define DRIVERSPECS_H 






# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/sdv_driverspecs.h" 1



#define __sdv_save_request(r) 


#define __sdv_retrieve_request(r) 



#define __sdv_save_adapter_context(c) 
# 126 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h" 2
# 256 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __internal_kernel_driver 
#define __kernel_code 
#define __kernel_driver 
#define __user_driver 
#define __user_code 
#define __drv_Mode_impl(x) 
#define __drv_WDM 
#define __drv_KMDF 
#define __drv_NDIS 
#define __prefast_operator_new_throws 
#define __prefast_operator_new_null 

#define _Analysis_assume_section_locked_(name) 
#define _Analysis_assume_section_unlocked_(name) 





#define _IRQL_limited_to_(level) ASSERT(KeGetCurrentIrql() <= level); _Analysis_assume_(KeGetCurrentIrql() <= level);
# 285 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __drv_deref(annotes) __deref _Group_(annotes _SAL_nop_impl_)
#define __drv_in(annotes) _Pre_ _Group_(annotes _SAL_nop_impl_)
#define __drv_in_deref(annotes) _Pre_ __deref _Group_(annotes _SAL_nop_impl_)
#define __drv_out(annotes) _Post_ _Group_(annotes _SAL_nop_impl_)
#define __drv_out_deref(annotes) _Post_ __deref _Group_(annotes _SAL_nop_impl_)
#define __drv_when(cond,annotes) _When_(cond, annotes _SAL_nop_impl_)
#define __drv_at(expr,annotes) _At_(expr, annotes _SAL_nop_impl_)

#define __drv_fun(annotes) _At_(return,annotes _SAL_nop_impl_)
#define __drv_ret(annotes) _At_(return,annotes _SAL_nop_impl_)
#define __drv_arg(expr,annotes) _At_(expr,annotes)
#define __drv_unit(p) typedef int ___drv_unit_ ##p __GENSYM(__prefast_flag_kernel_driver_mode);




#define ___drv_unit_internal_kernel_driver _SAL_L_Source_(__drv_unit_internal_kernel_driver, (), _SA_annotes0(SAL_internal_kernel_driver))
# 315 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define ___drv_unit_kernel_code _SAL_L_Source_(___drv_unit_kernel_code, (), _SA_annotes0(SAL_kernel) _SA_annotes0(SAL_nodriver))



#define ___drv_unit_kernel_driver _SAL_L_Source_(___drv_unit_kernel_driver, (), _SA_annotes0(SAL_kernel) _SA_annotes0(SAL_driver))



#define ___drv_unit_user_driver _SAL_L_Source_(___drv_unit_user_driver, (), _SA_annotes0(SAL_nokernel) _SA_annotes0(SAL_driver))



#define ___drv_unit_user_code _SAL_L_Source_(___drv_unit_user_code, (), _SA_annotes0(SAL_nokernel) _SA_annotes0(SAL_nodriver))
# 351 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __drv_defined(x) _Macro_defined_( #x )
# 363 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __drv_functionClass(x) _SAL1_Source_(__drv_functionClass, (x), _Function_class_(x))
# 380 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
   
#define _Kernel_acquires_resource_(kind) _SAL2_Source_(_Kernel_acquires_resource_, (#kind), _Post_ _SA_annotes1(SAL_acquire, #kind))


#define __drv_acquiresResource(kind) _SAL1_1_Source_(__drv_acquiresResource, (kind), _Acquires_lock_(_Curr_))





   
#define _Kernel_releases_resource_(kind) _SAL2_Source_(_Kernel_releases_resource_, (#kind), _Post_ _SA_annotes1(SAL_release, #kind))

#define __drv_releasesResource(kind) _SAL1_1_Source_(__drv_releasesResource, (kind), _Releases_lock_(_Curr_))





   
#define __drv_innerAcquiresGlobal(kind,param) _SAL1_1_Source_(_drv_innerAcquiresGlobal, (#kind, param\t), _Post_ _SA_annotes2(SAL_acquireGlobal, #kind, param\t))

#define __drv_acquiresResourceGlobal(kind,param) _SAL1_1_Source_(__drv_acquiresResourceGlobal, (kind, param), _Acquires_lock_(param))





   
#define __drv_innerReleasesGlobal(kind,param) _SAL1_1_Source_(__drv_InnerReleasesGlobal, (#kind, param\t), _Post_ _SA_annotes2(SAL_releaseGlobal,#kind, param\t))

#define __drv_releasesResourceGlobal(kind,param) _SAL1_1_Source_(__drv_releasesResourceGlobal, (kind, param), _Releases_lock_(param))





   
#define _Kernel_requires_resource_held_(kind) _SAL2_Source_(_Kernel_requires_resource_held_, (#kind), _Pre_ _SA_annotes1(SAL_mustHold, #kind))


#define __drv_mustHold(kind) _SAL_L_Source_(_drv_mustHold, (kind), _When_(!_Arg_comp_(#kind,"Memory"), _Requires_lock_held_(_Curr_)) _When_(_Arg_comp_(#kind,"Memory"), _Kernel_requires_resource_held_(kind)))







   
#define __drv_innerMustHoldGlobal(kind,param) _SAL_L_Source_(__drv_innerMustHoldGlobal, (#kind, param\t), _Pre_ _SA_annotes2(SAL_mustHoldGlobal, #kind, param\t))

#define __drv_mustHoldGlobal(kind,param) _SAL1_1_Source_(__drv_mustHoldGlobal, (kind, param), _Requires_lock_held_(param))





   
#define _Kernel_requires_resource_not_held_(kind) _SAL2_Source_(_Kernel_requires_resource_not_held_, (#kind), _Pre_ _SA_annotes1(SAL_neverHold, #kind))


#define __drv_neverHold(kind) _SAL1_1_Source_(__drv_neverHold, (kind), _Requires_lock_not_held_(_Curr_))






   
#define __drv_innerNeverHoldGlobal(kind,param) _SAL_L_Source_(__drv_innterNeverHoldGlobal, (#kind, param\t), _Pre_ _SA_annotes2(SAL_neverHoldGlobal, #kind, param\t))

#define __drv_neverHoldGlobal(kind,param) _SAL1_1_Source_(__drv_neverHoldGlobal, (kind, param), _Requires_lock_not_held_(param))



   
   
# 496 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __drv_setsIRQL(irql) 




#define _IRQL_raises_(irql) 
#define __drv_raisesIRQL _SAL1_1_Source_(__drv_raisesIRQL, (), _IRQL_raises_)




#define _IRQL_requires_(irql) 
#define __drv_requiresIRQL(irql) _SAL1_1_Source_(__drv_requiresIRQL, (irql), _IRQL_requires_(irql))




#define _IRQL_requires_max_(irql) 
#define __drv_maxIRQL(irql) _SAL1_1_Source_(__drv_maxIRQL, (irql), _IRQL_requires_max_(irql))




#define _IRQL_requires_min_(irql) 
#define __drv_minIRQL(irql) _SAL1_1_Source_(__drv_minIRQL, (irql), _IRQL_requires_min_(irql))




#define _IRQL_saves_ 
#define __drv_savesIRQL _SAL1_1_Source_(__drv_savesIRQL, (), _IRQL_saves_)





#define _IRQL_saves_global_(kind,param) 
#define __drv_savesIRQLGlobal(kind,param) _SAL1_1_Source_(__drv_savesIRQLGlobal, (kind,param), _IRQL_saves_global_(kind,param))




#define _IRQL_restores_ 
#define __drv_restoresIRQL _SAL1_1_Source_(__drv_restoresIRQL, (), _IRQL_restores_)





#define _IRQL_restores_global_(kind,param) 
#define __drv_restoresIRQLGlobal(kind,param) _SAL1_1_Source_(__drv_restoresIRQLGlobal, (kind,param), _IRQL_restores_global_(kind,param))





#define _IRQL_always_function_min_(irql) 
#define __drv_minFunctionIRQL(irql) _SAL1_1_Source_(__drv_minFunctionIRQL, (irql), _IRQL_always_function_min_(irql))




#define _IRQL_always_function_max_(irql) 
#define __drv_maxFunctionIRQL(irql) _SAL1_1_Source_(__drv_maxFunctionIRQL, (irql), _IRQL_always_function_max_(irql))





#define _IRQL_requires_same_ 
#define __drv_sameIRQL _SAL1_1_Source_(__drv_sameIRQL, (), _IRQL_requires_same_)





#define _IRQL_uses_cancel_ 
#define __drv_useCancelIRQL _SAL1_1_Source_(__drv_usesCancelIRQL, (), _IRQL_uses_cancel_)




#undef _IRQL_inout_
#define _IRQL_inout_ _IRQL_saves_ _IRQL_restores_







   
#define _Kernel_clear_do_init_(yesNo) _SAL2_Source_(_Kernel_clear_do_init_, (yesNo), _Post_ _SA_annotes1(SAL_clearDoInit,yesNo))

#define __drv_clearDoInit(yesNo) _SAL1_1_Source_(__drv_clearDoInit, (yesNo), _Kernel_clear_do_init_(yesNo))


   
#define _Kernel_IoGetDmaAdapter_ _SAL2_Source_(_Kernel_IoGetDmaAdapter_, (), _Post_ _SA_annotes0(SAL_IoGetDmaAdapter))

#define __drv_IoGetDmaAdapter _SAL1_1_Source_(__drv_IoGetDmaAdapter, (), _Kernel_IoGetDmaAdapter_)
# 611 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
   
#define __drv_valueIs(arglist) _SAL1_1_Source_(__drv_valueIs, (arglist), _Post_ _SA_annotes1(SAL_return,arglist))
# 625 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __drv_constant _SAL1_1_Source_(__drv_constant, (), _Literal_)





#define __drv_nonConstant _SAL1_1_Source_(__drv_nonConstant, (), _Notliteral_)





   
#define __drv_strictTypeMatch(mode) _SAL1_1_Source_(__drv_strictTypeMatch, (mode), _Pre_ _SA_annotes1(SAL_strictTypeMatch,mode))






   
#define __drv_strictType(typename,mode) _SAL1_1_Source_(__drv_strictType, (typename,mode), _Pre_ _SA_annotes2(SAL_strictType, typename, mode))



#define __drv_typeConst 0
#define __drv_typeCond 1
#define __drv_typeBitset 2
#define __drv_typeExpr 3





#define __drv_notPointer _SAL1_1_Source_(__drv_notPointer, (), _Pre_ _SA_annotes1(SAL_mayBePointer,__no))



#define __drv_isObjectPointer _SAL1_1_Source_(__drv_isObjectPointer, (), _Points_to_data_)
# 675 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
   
#define __drv_aliasesMem _SAL_L_Source_(__drv_aliasesMem, (), _Post_ _SA_annotes0(SAL_IsAliased))





   
#define __drv_allocatesMem(kind) _SAL_L_Source_(__drv_allocatesMem, (kind), _Post_ _SA_annotes1(SAL_NeedsRelease,__yes))

#define __drv_freesMem(kind) _SAL_L_Source_(__drv_freesMem, (kind), _Post_ _SA_annotes1(SAL_NeedsRelease,__no))
# 697 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
   

   

#define __drv_preferredFunction(func,why) _SAL_L_Source_(__drv_preferredFunction, (func,why), _Pre_ _SA_annotes2(SAL_preferredFunction, func, why))





   
   
#define __drv_reportError(why) _SAL_L_Source_(__drv_reportError, (why), _Pre_ _SA_annotes1(SAL_error,why))
# 723 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
   
#define _Kernel_float_saved_ _SAL2_Source_(_Kernel_float_saved_, (), _Post_ _SA_annotes0(SAL_floatSaved))
#define __drv_floatSaved _SAL1_1_Source_(__drv_floatSaved, (), _Kernel_float_saved_)



   
#define _Kernel_float_restored_ _SAL2_Source_(_Kernel_float_restored_, (), _Post_ _SA_annotes0(SAL_floatRestored))
#define __drv_floatRestored _SAL1_1_Source_(__drv_floatRestored, (), _Kernel_float_restored_)




   
#define _Kernel_float_used_ _SAL2_Source_(_Kernel_float_used_, (), _Post_ _SA_annotes0(SAL_floatUsed))
#define __drv_floatUsed _SAL1_1_Source_(__drv_floatUsed, (), _Kernel_float_used_)
# 748 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __drv_interlocked _SAL1_1_Source_(__drv_interlocked, (), _Interlocked_operand_)


#define __drv_inTry _SAL_L_Source_(__drv_inTry, (), _Pre_ _SA_annotes1(SAL_inTry,__yes))


#define __drv_notInTry _SAL_L_Source_(__drv_notInTry, (), _Pre_ _SA_annotes1(SAL_inTry,__no))





   
#define __drv_formatString(kind) _SAL1_1_Source_(__drv_formatString, (kind), _SA_annotes1(SAL_IsFormatString, #kind))







#define _Dispatch_type_(x) _SAL2_Source_(Dispatch_type_, (x), _SA_annotes1(SAL_functionClassNew, #x))


#define __drv_dispatchType(x) _SAL1_1_Source_(__drv_displatchType, (x), _SA_annotes1(SAL_functionClassNew, #x))



#define __drv_dispatchType_other _SAL1_1_Source_(__drv_dispatchType_other, (), __drv_dispatchType(IRP_MJ_OTHER))



   
#define __drv_completionType(kindlist) _SAL1_1_Source_(__drv_completionType, (kindlist), _SA_annotes1(SAL_completionType, #kindlist))



   
#define __drv_callbackType(kind) _SAL1_1_Source_(__drv_callbackType, (kind), _SA_annotes1(SAL_callbackType, #kind))
# 866 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/driverspecs.h"
#define __drv_acquiresExclusiveResource(kind) 
#define __drv_releasesExclusiveResource(kind) 
#define __drv_acquiresExclusiveResourceGlobal(kind,param) 
#define __drv_releasesExclusiveResourceGlobal(kind,param) 
#define __drv_acquiresCancelSpinLock 
#define __drv_releasesCancelSpinLock 
#define __drv_mustHoldCancelSpinLock 
#define __drv_holdsCancelSpinLock() 
#define __drv_neverHoldCancelSpinLock 
#define __drv_acquiresCriticalRegion 
#define __drv_releasesCriticalRegion 
#define __drv_mustHoldCriticalRegion 
#define __drv_neverHoldCriticalRegion 
#define __drv_holdsCriticalRegion() 
#define __drv_acquiresPriorityRegion 
#define __drv_releasesPriorityRegion 
#define __drv_mustHoldPriorityRegion 
#define __drv_neverHoldPriorityRegion 
#define __drv_holdsPriorityRegion() 




#define _IRQL_is_cancel_ 
#define __drv_isCancelIRQL _IRQL_is_cancel_


   
   
# 696 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h" 2
# 707 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h"
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/no_sal2.h" 1
# 19 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/no_sal2.h"
#define _NO_SAL_2_H_ 


#undef _When_

#define _When_(c,a) 

#undef _At_

#define _At_(t,a) 

#undef _At_buffer_

#define _At_buffer_(t,i,c,a) 

#undef _Group_

#define _Group_(a) 

#undef _Pre_

#define _Pre_ 

#undef _Post_

#define _Post_ 



#define _Deref_ 

#undef _Null_

#define _Null_ 

#undef _Notnull_

#define _Notnull_ 

#undef _Maybenull_

#define _Maybenull_ 

#undef _Const_

#define _Const_ 

#undef _Check_return_

#define _Check_return_ 

#undef _Must_inspect_result_

#define _Must_inspect_result_ 

#undef _Pre_satisfies_

#define _Pre_satisfies_(e) 

#undef _Post_satisfies_

#define _Post_satisfies_(e) 

#undef _Writable_elements_

#define _Writable_elements_(s) 

#undef _Writable_bytes_

#define _Writable_bytes_(s) 

#undef _Readable_elements_

#define _Readable_elements_(s) 

#undef _Readable_bytes_

#define _Readable_bytes_(s) 

#undef _Null_terminated_

#define _Null_terminated_ 

#undef _NullNull_terminated_

#define _NullNull_terminated_ 

#undef _Valid_

#define _Valid_ 

#undef _Notvalid_

#define _Notvalid_ 

#undef _Success_

#define _Success_(c) 

#undef _Return_type_success_

#define _Return_type_success_(c) 

#undef _On_failure_

#define _On_failure_(a) 

#undef _Always_

#define _Always_(a) 

#undef _Use_decl_annotations_

#define _Use_decl_annotations_ 

#undef _Pre_defensive_

#define _Pre_defensive_ 

#undef _Post_defensive_

#define _Post_defensive_ 

#undef _Pre_unknown_

#define _Pre_unknown_ 

#undef _Acquires_lock_

#define _Acquires_lock_(e) 

#undef _Releases_lock_

#define _Releases_lock_(e) 

#undef _Requires_lock_held_

#define _Requires_lock_held_(e) 

#undef _Requires_lock_not_held_

#define _Requires_lock_not_held_(e) 

#undef _Requires_no_locks_held_

#define _Requires_no_locks_held_ 

#undef _Guarded_by_

#define _Guarded_by_(e) 

#undef _Write_guarded_by_

#define _Write_guarded_by_(e) 

#undef _Interlocked_

#define _Interlocked_ 

#undef _Post_same_lock_

#define _Post_same_lock_(e1,e2) 

#undef _Benign_race_begin_

#define _Benign_race_begin_ 

#undef _Benign_race_end_

#define _Benign_race_end_ 

#undef _No_competing_thread_

#define _No_competing_thread_ 

#undef _No_competing_thread_begin_

#define _No_competing_thread_begin_ 

#undef _No_competing_thread_end_

#define _No_competing_thread_end_ 

#undef _Acquires_shared_lock_

#define _Acquires_shared_lock_(e) 

#undef _Releases_shared_lock_

#define _Releases_shared_lock_(e) 

#undef _Requires_shared_lock_held_

#define _Requires_shared_lock_held_(e) 

#undef _Acquires_exclusive_lock_

#define _Acquires_exclusive_lock_(e) 

#undef _Releases_exclusive_lock_

#define _Releases_exclusive_lock_(e) 

#undef _Requires_exclusive_lock_held_

#define _Requires_exclusive_lock_held_(e) 

#undef _Has_lock_kind_

#define _Has_lock_kind_(n) 

#undef _Create_lock_level_

#define _Create_lock_level_(n) 

#undef _Has_lock_level_

#define _Has_lock_level_(n) 

#undef _Lock_level_order_

#define _Lock_level_order_(n1,n2) 

#undef _Analysis_assume_lock_acquired_

#define _Analysis_assume_lock_acquired_(e) 

#undef _Analysis_assume_lock_released_

#define _Analysis_assume_lock_released_(e) 

#undef _Analysis_assume_lock_held_

#define _Analysis_assume_lock_held_(e) 

#undef _Analysis_assume_lock_not_held_

#define _Analysis_assume_lock_not_held_(e) 

#undef _Analysis_assume_same_lock_

#define _Analysis_assume_same_lock_(e) 

#undef _In_

#define _In_ 

#undef _Out_

#define _Out_ 

#undef _Inout_

#define _Inout_ 

#undef _In_z_

#define _In_z_ 

#undef _Inout_z_

#define _Inout_z_ 

#undef _In_reads_

#define _In_reads_(s) 

#undef _In_reads_bytes_

#define _In_reads_bytes_(s) 

#undef _In_reads_z_

#define _In_reads_z_(s) 

#undef _In_reads_or_z_

#define _In_reads_or_z_(s) 

#undef _Out_writes_

#define _Out_writes_(s) 

#undef _Out_writes_bytes_

#define _Out_writes_bytes_(s) 

#undef _Out_writes_z_

#define _Out_writes_z_(s) 

#undef _Inout_updates_

#define _Inout_updates_(s) 

#undef _Inout_updates_bytes_

#define _Inout_updates_bytes_(s) 

#undef _Inout_updates_z_

#define _Inout_updates_z_(s) 

#undef _Out_writes_to_

#define _Out_writes_to_(s,c) 

#undef _Out_writes_bytes_to_

#define _Out_writes_bytes_to_(s,c) 

#undef _Out_writes_all_

#define _Out_writes_all_(s) 

#undef _Out_writes_bytes_all_

#define _Out_writes_bytes_all_(s) 

#undef _Inout_updates_to_

#define _Inout_updates_to_(s,c) 

#undef _Inout_updates_bytes_to_

#define _Inout_updates_bytes_to_(s,c) 

#undef _Inout_updates_all_

#define _Inout_updates_all_(s) 

#undef _Inout_updates_bytes_all_

#define _Inout_updates_bytes_all_(s) 

#undef _In_reads_to_ptr_

#define _In_reads_to_ptr_(p) 

#undef _In_reads_to_ptr_z_

#define _In_reads_to_ptr_z_(p) 

#undef _Out_writes_to_ptr_

#define _Out_writes_to_ptr_(p) 

#undef _Out_writes_to_ptr_z_

#define _Out_writes_to_ptr_z_(p) 

#undef _In_opt_

#define _In_opt_ 

#undef _Out_opt_

#define _Out_opt_ 

#undef _Inout_opt_

#define _Inout_opt_ 

#undef _In_opt_z_

#define _In_opt_z_ 

#undef _Inout_opt_z_

#define _Inout_opt_z_ 

#undef _In_reads_opt_

#define _In_reads_opt_(s) 

#undef _In_reads_opt_z_

#define _In_reads_opt_z_(s) 

#undef _In_reads_bytes_opt_

#define _In_reads_bytes_opt_(s) 

#undef _Out_writes_opt_

#define _Out_writes_opt_(s) 

#undef _Out_writes_bytes_opt_

#define _Out_writes_bytes_opt_(s) 

#undef _Out_writes_opt_z_

#define _Out_writes_opt_z_(s) 

#undef _Inout_updates_opt_

#define _Inout_updates_opt_(s) 

#undef _Inout_updates_bytes_opt_

#define _Inout_updates_bytes_opt_(s) 

#undef _Inout_updates_opt_z_

#define _Inout_updates_opt_z_(s) 

#undef _Out_writes_to_opt_

#define _Out_writes_to_opt_(s,c) 

#undef _Out_writes_bytes_to_opt_

#define _Out_writes_bytes_to_opt_(s,c) 

#undef _Out_writes_all_opt_

#define _Out_writes_all_opt_(s) 

#undef _Out_writes_bytes_all_opt_

#define _Out_writes_bytes_all_opt_(s) 

#undef _Inout_updates_to_opt_

#define _Inout_updates_to_opt_(s,c) 

#undef _Inout_updates_bytes_to_opt_

#define _Inout_updates_bytes_to_opt_(s,c) 

#undef _Inout_updates_all_opt_

#define _Inout_updates_all_opt_(s) 

#undef _Inout_updates_bytes_all_opt_

#define _Inout_updates_bytes_all_opt_(s) 

#undef _In_reads_to_ptr_opt_

#define _In_reads_to_ptr_opt_(p) 

#undef _In_reads_to_ptr_opt_z_

#define _In_reads_to_ptr_opt_z_(p) 

#undef _Out_writes_to_ptr_opt_

#define _Out_writes_to_ptr_opt_(p) 

#undef _Out_writes_to_ptr_opt_z_

#define _Out_writes_to_ptr_opt_z_(p) 

#undef _Outptr_

#define _Outptr_ 

#undef _Outptr_opt_

#define _Outptr_opt_ 

#undef _Outptr_result_maybenull_

#define _Outptr_result_maybenull_ 

#undef _Outptr_opt_result_maybenull_

#define _Outptr_opt_result_maybenull_ 

#undef _Outptr_result_z_

#define _Outptr_result_z_ 

#undef _Outptr_opt_result_z_

#define _Outptr_opt_result_z_ 

#undef _Outptr_result_maybenull_z_

#define _Outptr_result_maybenull_z_ 

#undef _Outptr_opt_result_maybenull_z_

#define _Outptr_opt_result_maybenull_z_ 

#undef _COM_Outptr_

#define _COM_Outptr_ 

#undef _COM_Outptr_opt_

#define _COM_Outptr_opt_ 

#undef _COM_Outptr_result_maybenull_

#define _COM_Outptr_result_maybenull_ 

#undef _COM_Outptr_opt_result_maybenull_

#define _COM_Outptr_opt_result_maybenull_ 

#undef _Outptr_result_buffer_

#define _Outptr_result_buffer_(s) 

#undef _Outptr_result_buffer_maybenull_

#define _Outptr_result_buffer_maybenull_(s) 

#undef _Outptr_result_bytebuffer_

#define _Outptr_result_bytebuffer_(s) 

#undef _Outptr_result_bytebuffer_maybenull_

#define _Outptr_result_bytebuffer_maybenull_(s) 

#undef _Outptr_opt_result_buffer_

#define _Outptr_opt_result_buffer_(s) 

#undef _Outptr_opt_result_buffer_maybenull_

#define _Outptr_opt_result_buffer_maybenull_(s) 

#undef _Outptr_opt_result_bytebuffer_

#define _Outptr_opt_result_bytebuffer_(s) 

#undef _Outptr_opt_result_bytebuffer_maybenull_

#define _Outptr_opt_result_bytebuffer_maybenull_(s) 

#undef _Outptr_result_buffer_to_

#define _Outptr_result_buffer_to_(s,c) 

#undef _Outptr_result_bytebuffer_to_

#define _Outptr_result_bytebuffer_to_(s,c) 

#undef _Outptr_opt_result_buffer_to_

#define _Outptr_opt_result_buffer_to_(s,c) 

#undef _Outptr_opt_result_bytebuffer_to_

#define _Outptr_opt_result_bytebuffer_to_(s,c) 

#undef _Ret_

#define _Ret_ 

#undef _Ret_valid_

#define _Ret_valid_ 

#undef _Ret_z_

#define _Ret_z_ 

#undef _Ret_writes_

#define _Ret_writes_(s) 

#undef _Ret_writes_bytes_

#define _Ret_writes_bytes_(s) 

#undef _Ret_writes_z_

#define _Ret_writes_z_(s) 

#undef _Ret_writes_to_

#define _Ret_writes_to_(s,c) 

#undef _Ret_writes_bytes_to_

#define _Ret_writes_bytes_to_(s,c) 



#define _Ret_writes_to_ptr_(p) 



#define _Ret_writes_to_ptr_z_(p) 

#undef _Ret_writes_maybenull_

#define _Ret_writes_maybenull_(s) 

#undef _Ret_writes_bytes_maybenull_

#define _Ret_writes_bytes_maybenull_(s) 

#undef _Ret_writes_to_maybenull_

#define _Ret_writes_to_maybenull_(s,c) 

#undef _Ret_writes_bytes_to_maybenull_

#define _Ret_writes_bytes_to_maybenull_(s,c) 

#undef _Ret_writes_maybenull_z_

#define _Ret_writes_maybenull_z_(s) 

#undef _Ret_null_

#define _Ret_null_ 

#undef _Ret_notnull_

#define _Ret_notnull_ 

#undef _Ret_maybenull_

#define _Ret_maybenull_ 

#undef _Ret_maybenull_z_

#define _Ret_maybenull_z_ 

#undef _Field_size_

#define _Field_size_(s) 

#undef _Field_size_opt_

#define _Field_size_opt_(s) 

#undef _Field_size_bytes_

#define _Field_size_bytes_(s) 

#undef _Field_size_bytes_opt_

#define _Field_size_bytes_opt_(s) 

#undef _Field_size_part_

#define _Field_size_part_(s,c) 

#undef _Field_size_part_opt_

#define _Field_size_part_opt_(s,c) 

#undef _Field_size_bytes_part_

#define _Field_size_bytes_part_(s,c) 

#undef _Field_size_bytes_part_opt_

#define _Field_size_bytes_part_opt_(s,c) 

#undef _Field_size_full_

#define _Field_size_full_(s) 

#undef _Field_size_full_opt_

#define _Field_size_full_opt_(s) 

#undef _Field_size_bytes_full_

#define _Field_size_bytes_full_(s) 

#undef _Field_size_bytes_full_opt_

#define _Field_size_bytes_full_opt_(s) 

#undef _Printf_format_string_

#define _Printf_format_string_ 

#undef _Scanf_format_string_

#define _Scanf_format_string_ 

#undef _Scanf_s_format_string_

#define _Scanf_s_format_string_ 

#undef _Printf_format_string_params_

#define _Printf_format_string_params_(x) 

#undef _Scanf_format_string_params_

#define _Scanf_format_string_params_(x) 

#undef _Scanf_s_format_string_params_

#define _Scanf_s_format_string_params_(x) 

#undef _In_range_

#define _In_range_(l,h) 

#undef _Out_range_

#define _Out_range_(l,h) 

#undef _Ret_range_

#define _Ret_range_(l,h) 

#undef _Deref_in_range_

#define _Deref_in_range_(l,h) 

#undef _Deref_out_range_

#define _Deref_out_range_(l,h) 



#define _Deref_inout_range_(l,h) 

#undef _Field_range_

#define _Field_range_(l,h) 

#undef _Pre_equal_to_

#define _Pre_equal_to_(e) 

#undef _Post_equal_to_

#define _Post_equal_to_(e) 

#undef _Struct_size_bytes_

#define _Struct_size_bytes_(s) 

#undef _Analysis_assume_

#define _Analysis_assume_ 

#undef _Analysis_assume_nullterminated_

#define _Analysis_assume_nullterminated_(s) 

#undef _Analysis_mode_

#define _Analysis_mode_(m) 

#undef _Analysis_noreturn_

#define _Analysis_noreturn_ 

#undef _Raises_SEH_exception_

#define _Raises_SEH_exception_ 

#undef _Maybe_raises_SEH_exception_

#define _Maybe_raises_SEH_exception_ 

#undef _Function_class_

#define _Function_class_(n) 

#undef _Literal_

#define _Literal_ 

#undef _Notliteral_

#define _Notliteral_ 

#undef _Enum_is_bitflag_

#define _Enum_is_bitflag_ 

#undef _Strict_type_match_

#define _Strict_type_match_ 

#undef _Points_to_data_

#define _Points_to_data_ 

#undef _Interlocked_operand_

#define _Interlocked_operand_ 

#undef _IRQL_raises_

#define _IRQL_raises_(i) 

#undef _IRQL_requires_

#define _IRQL_requires_(i) 

#undef _IRQL_requires_max_

#define _IRQL_requires_max_(i) 

#undef _IRQL_requires_min_

#define _IRQL_requires_min_(i) 

#undef _IRQL_saves_

#define _IRQL_saves_ 

#undef _IRQL_saves_global_

#define _IRQL_saves_global_(k,s) 

#undef _IRQL_restores_

#define _IRQL_restores_ 

#undef _IRQL_restores_global_

#define _IRQL_restores_global_(k,s) 

#undef _IRQL_always_function_min_

#define _IRQL_always_function_min_(i) 

#undef _IRQL_always_function_max_

#define _IRQL_always_function_max_(i) 

#undef _IRQL_requires_same_

#define _IRQL_requires_same_ 

#undef _IRQL_uses_cancel_

#define _IRQL_uses_cancel_ 

#undef _IRQL_is_cancel_

#define _IRQL_is_cancel_ 

#undef _Kernel_float_saved_

#define _Kernel_float_saved_ 

#undef _Kernel_float_restored_

#define _Kernel_float_restored_ 

#undef _Kernel_float_used_

#define _Kernel_float_used_ 

#undef _Kernel_acquires_resource_

#define _Kernel_acquires_resource_(k) 

#undef _Kernel_releases_resource_

#define _Kernel_releases_resource_(k) 

#undef _Kernel_requires_resource_held_

#define _Kernel_requires_resource_held_(k) 

#undef _Kernel_requires_resource_not_held_

#define _Kernel_requires_resource_not_held_(k) 

#undef _Kernel_clear_do_init_

#define _Kernel_clear_do_init_(yn) 

#undef _Kernel_IoGetDmaAdapter_

#define _Kernel_IoGetDmaAdapter_ 

#undef _Outref_

#define _Outref_ 

#undef _Outref_result_maybenull_

#define _Outref_result_maybenull_ 

#undef _Outref_result_buffer_

#define _Outref_result_buffer_(s) 

#undef _Outref_result_bytebuffer_

#define _Outref_result_bytebuffer_(s) 

#undef _Outref_result_buffer_to_

#define _Outref_result_buffer_to_(s,c) 

#undef _Outref_result_bytebuffer_to_

#define _Outref_result_bytebuffer_to_(s,c) 

#undef _Outref_result_buffer_all_

#define _Outref_result_buffer_all_(s) 

#undef _Outref_result_bytebuffer_all_

#define _Outref_result_bytebuffer_all_(s) 

#undef _Outref_result_buffer_maybenull_

#define _Outref_result_buffer_maybenull_(s) 

#undef _Outref_result_bytebuffer_maybenull_

#define _Outref_result_bytebuffer_maybenull_(s) 

#undef _Outref_result_buffer_to_maybenull_

#define _Outref_result_buffer_to_maybenull_(s,c) 

#undef _Outref_result_bytebuffer_to_maybenull_

#define _Outref_result_bytebuffer_to_maybenull_(s,c) 

#undef _Outref_result_buffer_all_maybenull_

#define _Outref_result_buffer_all_maybenull_(s) 

#undef _Outref_result_bytebuffer_all_maybenull_

#define _Outref_result_bytebuffer_all_maybenull_(s) 

#undef _In_defensive_

#define _In_defensive_(a) 

#undef _Out_defensive_

#define _Out_defensive_(a) 

#undef _Inout_defensive_

#define _Inout_defensive_(a) 

#undef _Outptr_result_nullonfailure_

#define _Outptr_result_nullonfailure_ 

#undef _Outptr_opt_result_nullonfailure_

#define _Outptr_opt_result_nullonfailure_ 

#undef _Outref_result_nullonfailure_

#define _Outref_result_nullonfailure_ 

#undef _Result_nullonfailure_

#define _Result_nullonfailure_ 

#undef _Result_zeroonfailure_

#define _Result_zeroonfailure_ 

#undef _Acquires_nonreentrant_lock_

#define _Acquires_nonreentrant_lock_(e) 

#undef _Releases_nonreentrant_lock_

#define _Releases_nonreentrant_lock_(e) 

#undef _Function_ignore_lock_checking_

#define _Function_ignore_lock_checking_(e) 

#undef _Analysis_suppress_lock_checking_

#define _Analysis_suppress_lock_checking_(e) 
#undef _Reserved_
#define _Reserved_ _Pre_equal_to_(0) _Pre_ _Null_
#undef _Pre_z_
#define _Pre_z_ _Pre_ _Null_terminated_
#undef _Post_z_
#define _Post_z_ _Post_ _Null_terminated_
#undef _Prepost_z_
#define _Prepost_z_ _Pre_z_ _Post_z_
#undef _Pre_null_
#define _Pre_null_ _Pre_ _Null_
#undef _Pre_maybenull_
#define _Pre_maybenull_ _Pre_ _Maybenull_
#undef _Pre_notnull_
#define _Pre_notnull_ _Pre_ _Notnull_
#undef _Pre_valid_
#define _Pre_valid_ _Pre_notnull_ _Pre_ _Valid_
#undef _Pre_opt_valid_
#define _Pre_opt_valid_ _Pre_maybenull_ _Pre_ _Valid_
#undef _Post_valid_
#define _Post_valid_ _Post_ _Valid_
#undef _Post_invalid_
#define _Post_invalid_ _Post_ _Deref_ _Notvalid_
#undef _Post_ptr_invalid_
#define _Post_ptr_invalid_ _Post_ _Notvalid_
#undef _Pre_readable_size_
#define _Pre_readable_size_(s) _Pre_ _Readable_elements_(s) _Pre_ _Valid_
#undef _Pre_writable_size_
#define _Pre_writable_size_(s) _Pre_ _Writable_elements_(s)
#undef _Pre_readable_byte_size_
#define _Pre_readable_byte_size_(s) _Pre_ _Readable_bytes_(s) _Pre_ _Valid_
#undef _Pre_writable_byte_size_
#define _Pre_writable_byte_size_(s) _Pre_ _Writable_bytes_(s)
#undef _Post_readable_size_
#define _Post_readable_size_(s) _Post_ _Readable_elements_(s) _Post_ _Valid_
#undef _Post_writable_size_
#define _Post_writable_size_(s) _Post_ _Writable_elements_(s)
#undef _Post_readable_byte_size_
#define _Post_readable_byte_size_(s) _Post_ _Readable_bytes_(s) _Post_ _Valid_
#undef _Post_writable_byte_size_
#define _Post_writable_byte_size_(s) _Post_ _Writable_bytes_(s)
# 708 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/specstrings.h" 2
# 68 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h" 2
# 77 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h" 1
# 18 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h"
#define _INC_VADEFS 
# 40 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h"
#define _PRAGMA_DETECT_MISMATCH_STRING1(s) #s
#define _PRAGMA_DETECT_MISMATCH_STRING0(s) _PRAGMA_DETECT_MISMATCH_STRING1(s)

#define _PRAGMA_DETECT_MISMATCH(name,value) __pragma(comment(linker, "/FAILIFMISMATCH:\"" _PRAGMA_DETECT_MISMATCH_STRING0(name) "=" _PRAGMA_DETECT_MISMATCH_STRING0(value) "\""))
# 64 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h"
#define _W64 







typedef unsigned int uintptr_t;

#define _UINTPTR_T_DEFINED 






typedef char * va_list;

#define _VA_LIST_DEFINED 





#define _ADDRESSOF(v) ( &(v) )
# 105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h"
#define _SLOTSIZEOF(t) (sizeof(t))
#define _APALIGN(t,ap) (__alignof(t))
# 179 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h"
#define _INTSIZEOF(n) ( (sizeof(n) + sizeof(int) - 1) & ~(sizeof(int) - 1) )

#define _crt_va_start(ap,v) ( ap = (va_list)_ADDRESSOF(v) + _INTSIZEOF(v) )
#define _crt_va_arg(ap,t) ( *(t *)((ap += _INTSIZEOF(t)) - _INTSIZEOF(t)) )
#define _crt_va_end(ap) ( ap = (va_list)0 )
# 78 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h" 2






#define __CRT_STRINGIZE(_Value) #_Value
#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)

#define __CRT_WIDE(_String) L ## _String
#define _CRT_WIDE(_String) __CRT_WIDE(_String)


#define __CRT_APPEND(_Value1,_Value2) _Value1 ## _Value2
#define _CRT_APPEND(_Value1,_Value2) __CRT_APPEND(_Value1, _Value2)
# 109 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTIMP_NOIA64 _CRTIMP
# 119 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTIMP2 






#define _CRT_ALTERNATIVE_INLINES 
# 137 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTIMP_ALT 
# 157 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _MRTIMP __declspec(dllimport)
# 170 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _MRTIMP2 
# 180 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _MCRTIMP 




#define __clrcall __cdecl





#define __CLR_OR_THIS_CALL 






#define __CLRCALL_OR_CDECL __cdecl






#define _CRTIMP_PURE _CRTIMP
#define _CRTEXP_PURE _CRTEXP
# 216 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _MRTIMP2_NPURE 
# 229 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTIMP2_CALLING_CONVENTION __cdecl
#define _CRTIMP2_PURE_CALLING_CONVENTION __cdecl
#define _CRTIMP2_MEMBER_FUNCTION_CALLING_CONVENTION __thiscall
#define _CRTIMP2_PURE_MEMBER_FUNCTION_CALLING_CONVENTION __thiscall
#define _MRTIMP_CALLING_CONVENTION __cdecl
#define _MRTIMP2_CALLING_CONVENTION __cdecl
#define _MRTIMP2_NPURE_CALLING_CONVENTION __cdecl
# 246 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTDATA(x) _CRTIMP x







#define _CRTIMP2_PURE _CRTIMP2



#define _CRTIMP2_FUNCTION(type) _CRTIMP2 type _CRTIMP2_CALLING_CONVENTION
#define _CRTIMP2_PURE_FUNCTION(type) _CRTIMP2_PURE type _CRTIMP2_PURE_CALLING_CONVENTION
#define _CRTIMP2_PURE_CONSTRUCTOR _CRTIMP2_PURE _CRTIMP2_MEMBER_FUNCTION_CALLING_CONVENTION
#define _CRTIMP2_PURE_DESTRUCTOR _CRTIMP2_PURE _CRTIMP2_MEMBER_FUNCTION_CALLING_CONVENTION
#define _CRTIMP2_MEMBER_FUNCTION(type) _CRTIMP2 type _CRTIMP2_MEMBER_FUNCTION_CALLING_CONVENTION
#define _CRTIMP2_PURE_MEMBER_FUNCTION(type) _CRTIMP2_PURE type _CRTIMP2_PURE_MEMBER_FUNCTION_CALLING_CONVENTION
#define _MRTIMP_FUNCTION(type) _MRTIMP type _MRTIMP_CALLING_CONVENTION
#define _MRTIMP2_FUNCTION(type) _MRTIMP2 type _MRTIMP2_CALLING_CONVENTION
#define _MRTIMP2_NPURE_FUNCTION(type) _MRTIMP2_NPURE type _MRTIMP2_NPURE_CALLING_CONVENTION


#define _MSVCR80_FUNCTION(type) type __cdecl
#define _MSVCR80_FUNCTION_2(sal,type) sal type __cdecl
# 282 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTIMP_TYPEINFO _CRTIMP





#define _CRTIMP_PURE_TYPEINFO _CRTIMP_PURE
# 298 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _PGLOBAL 





#define _AGLOBAL 
# 315 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define __STDC_SECURE_LIB__ 200411L


#define __GOT_SECURE_LIB__ __STDC_SECURE_LIB__



#define __STDC_WANT_SECURE_LIB__ 1
# 334 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated)



#define _CRT_SECURE_NO_DEPRECATE_CORE 





#define _CRT_INSECURE_DEPRECATE_CORE(_Replacement) 






#define _CRT_SECURE_NO_DEPRECATE 





#define _CRT_SECURE_NO_WARNINGS 




#define _CRT_INSECURE_DEPRECATE(_Replacement) 
# 376 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_INSECURE_DEPRECATE_MEMORY(_Replacement) 
# 397 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_INSECURE_DEPRECATE_GLOBALS(_Replacement) _CRT_INSECURE_DEPRECATE(_Replacement)
# 418 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_MANAGED_HEAP_DEPRECATE 





#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE
# 438 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_OBSOLETE(_NewItem) _CRT_DEPRECATE_TEXT("This function or variable has been superceded by newer library or operating system functionality. Consider using " #_NewItem " instead. See online help for details.")
# 449 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_JIT_INTRINSIC 






#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES 0
# 467 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT 0
# 478 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES 1
# 490 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_NONSTDC_NO_DEPRECATE 





#define _CRT_NONSTDC_NO_WARNINGS 




#define _CRT_NONSTDC_DEPRECATE(_NewName) 
# 511 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
typedef unsigned int size_t;

#define _SIZE_T_DEFINED 




typedef size_t rsize_t;
#define _RSIZE_T_DEFINED 







typedef int intptr_t;

#define _INTPTR_T_DEFINED 
# 545 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
typedef int ptrdiff_t;

#define _PTRDIFF_T_DEFINED 



typedef unsigned short wchar_t;
#define _WCHAR_T_DEFINED 


typedef unsigned short wint_t;
typedef unsigned short wctype_t;
#define _WCTYPE_T_DEFINED 
# 570 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _ERRCODE_DEFINED 
typedef int errcode;
typedef int errno_t;


typedef long __time32_t;
#define _TIME32_T_DEFINED 

typedef __int64 __time64_t;
#define _TIME64_T_DEFINED 


#define _USE_32BIT_TIME_T 



typedef __time32_t time_t;



#define _TIME_T_DEFINED 

#define _NO_CPP_INLINES 

#define _CONST_RETURN 


#define _WConst_return _CONST_RETURN





#define UNALIGNED 







#define _CRT_ALIGN(x) __declspec(align(x))
# 630 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRTNOALIAS 

#define _CRTRESTRICT 





#define __cdecl 






#define __CRTDECL __cdecl
#define __CRTDECL_STDCALL __stdcall





#define __ALTDECL __cdecl



#define _ARGMAX 100


#define _TRUNCATE ((size_t)-1)
# 809 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType,_FuncName,_DstType,_Dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_DstType,_Dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType,_FuncName,_DstType,_Src) 




#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _VFuncName, _VFuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
# 1889 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define __RETURN_POLICY_SAME(_FunctionCall) 
#define __RETURN_POLICY_DST(_FunctionCall) 
#define __RETURN_POLICY_VOID(_FunctionCall) 
#define __EMPTY_DECLSPEC 

#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SecureVFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 




struct threadlocaleinfostruct;
struct threadmbcinfostruct;
typedef struct threadlocaleinfostruct * pthreadlocinfo;
typedef struct threadmbcinfostruct * pthreadmbcinfo;
struct __lc_time_data;

typedef struct localeinfo_struct
{
    pthreadlocinfo locinfo;
    pthreadmbcinfo mbcinfo;
} _locale_tstruct, *_locale_t;


typedef struct tagLC_ID {
        unsigned short wLanguage;
        unsigned short wCountry;
        unsigned short wCodePage;
} LC_ID, *LPLC_ID;
#define _TAGLC_ID_DEFINED 



typedef struct threadlocaleinfostruct {
        int refcount;
        unsigned int lc_codepage;
        unsigned int lc_collate_cp;
        unsigned long lc_handle[6];
        LC_ID lc_id[6];
        struct {
            char *locale;
            wchar_t *wlocale;
            int *refcount;
            int *wrefcount;
        } lc_category[6];
        int lc_clike;
        int mb_cur_max;
        int * lconv_intl_refcount;
        int * lconv_num_refcount;
        int * lconv_mon_refcount;
        struct lconv * lconv;
        int * ctype1_refcount;
        unsigned short * ctype1;
        const unsigned short * pctype;
        const unsigned char * pclmap;
        const unsigned char * pcumap;
        struct __lc_time_data * lc_time_curr;
} threadlocinfo;
#define _THREADLOCALEINFO 
# 2093 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
void

__fastcall

_guard_check_icall (
    uintptr_t Target
    );

int

_guard_icall_checks_enforced (
    void
    );
# 2124 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _Check_return_opt_ 





#define _Check_return_wat_ 





#define __crt_typefix(ctype) 
# 2147 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_UNUSED(x) (void)x







#define __FORCE_INSTANCE_CRTIMP2 _CRTIMP2
#define __FORCE_INSTANCE_EXTERN extern
# 2166 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h"
#define _CRT_STDIO_IMP _CRTIMP



#define _CRT_STDIO_IMP_ALT _CRTIMP_ALT
# 23 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdarg.h" 2






# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h" 1
# 30 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdarg.h" 2

#define va_start _crt_va_start
#define va_arg _crt_va_arg
#define va_end _crt_va_end
# 1078 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1091 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_EXTERN extern


#define SQLITE_API 


#define SQLITE_CDECL 


#define SQLITE_APICALL 


#define SQLITE_STDCALL SQLITE_APICALL


#define SQLITE_CALLBACK 


#define SQLITE_SYSAPI 
# 1125 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEPRECATED 
#define SQLITE_EXPERIMENTAL 
# 1168 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_VERSION "3.30.1"
#define SQLITE_VERSION_NUMBER 3030001
#define SQLITE_SOURCE_ID "2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b"
# 1204 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char sqlite3_version[] = "3.30.1";
 const char *sqlite3_libversion(void);
 const char *sqlite3_sourceid(void);
 int sqlite3_libversion_number(void);
# 1232 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_compileoption_used(const char *zOptName);
 const char *sqlite3_compileoption_get(int N);
# 1275 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_threadsafe(void);
# 1291 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3 sqlite3;
# 1320 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  typedef long long int sqlite_int64;
  typedef unsigned long long int sqlite_uint64;

typedef sqlite_int64 sqlite3_int64;
typedef sqlite_uint64 sqlite3_uint64;
# 1376 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_close(sqlite3*);
 int sqlite3_close_v2(sqlite3*);






typedef int (*sqlite3_callback)(void*,int,char**, char**);
# 1448 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_exec(
  sqlite3*,
  const char *sql,
  int (*callback)(void*,int,char**,char**),
  void *,
  char **errmsg
);
# 1467 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_OK 0

#define SQLITE_ERROR 1
#define SQLITE_INTERNAL 2
#define SQLITE_PERM 3
#define SQLITE_ABORT 4
#define SQLITE_BUSY 5
#define SQLITE_LOCKED 6
#define SQLITE_NOMEM 7
#define SQLITE_READONLY 8
#define SQLITE_INTERRUPT 9
#define SQLITE_IOERR 10
#define SQLITE_CORRUPT 11
#define SQLITE_NOTFOUND 12
#define SQLITE_FULL 13
#define SQLITE_CANTOPEN 14
#define SQLITE_PROTOCOL 15
#define SQLITE_EMPTY 16
#define SQLITE_SCHEMA 17
#define SQLITE_TOOBIG 18
#define SQLITE_CONSTRAINT 19
#define SQLITE_MISMATCH 20
#define SQLITE_MISUSE 21
#define SQLITE_NOLFS 22
#define SQLITE_AUTH 23
#define SQLITE_FORMAT 24
#define SQLITE_RANGE 25
#define SQLITE_NOTADB 26
#define SQLITE_NOTICE 27
#define SQLITE_WARNING 28
#define SQLITE_ROW 100
#define SQLITE_DONE 101
# 1518 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_ERROR_MISSING_COLLSEQ (SQLITE_ERROR | (1<<8))
#define SQLITE_ERROR_RETRY (SQLITE_ERROR | (2<<8))
#define SQLITE_ERROR_SNAPSHOT (SQLITE_ERROR | (3<<8))
#define SQLITE_IOERR_READ (SQLITE_IOERR | (1<<8))
#define SQLITE_IOERR_SHORT_READ (SQLITE_IOERR | (2<<8))
#define SQLITE_IOERR_WRITE (SQLITE_IOERR | (3<<8))
#define SQLITE_IOERR_FSYNC (SQLITE_IOERR | (4<<8))
#define SQLITE_IOERR_DIR_FSYNC (SQLITE_IOERR | (5<<8))
#define SQLITE_IOERR_TRUNCATE (SQLITE_IOERR | (6<<8))
#define SQLITE_IOERR_FSTAT (SQLITE_IOERR | (7<<8))
#define SQLITE_IOERR_UNLOCK (SQLITE_IOERR | (8<<8))
#define SQLITE_IOERR_RDLOCK (SQLITE_IOERR | (9<<8))
#define SQLITE_IOERR_DELETE (SQLITE_IOERR | (10<<8))
#define SQLITE_IOERR_BLOCKED (SQLITE_IOERR | (11<<8))
#define SQLITE_IOERR_NOMEM (SQLITE_IOERR | (12<<8))
#define SQLITE_IOERR_ACCESS (SQLITE_IOERR | (13<<8))
#define SQLITE_IOERR_CHECKRESERVEDLOCK (SQLITE_IOERR | (14<<8))
#define SQLITE_IOERR_LOCK (SQLITE_IOERR | (15<<8))
#define SQLITE_IOERR_CLOSE (SQLITE_IOERR | (16<<8))
#define SQLITE_IOERR_DIR_CLOSE (SQLITE_IOERR | (17<<8))
#define SQLITE_IOERR_SHMOPEN (SQLITE_IOERR | (18<<8))
#define SQLITE_IOERR_SHMSIZE (SQLITE_IOERR | (19<<8))
#define SQLITE_IOERR_SHMLOCK (SQLITE_IOERR | (20<<8))
#define SQLITE_IOERR_SHMMAP (SQLITE_IOERR | (21<<8))
#define SQLITE_IOERR_SEEK (SQLITE_IOERR | (22<<8))
#define SQLITE_IOERR_DELETE_NOENT (SQLITE_IOERR | (23<<8))
#define SQLITE_IOERR_MMAP (SQLITE_IOERR | (24<<8))
#define SQLITE_IOERR_GETTEMPPATH (SQLITE_IOERR | (25<<8))
#define SQLITE_IOERR_CONVPATH (SQLITE_IOERR | (26<<8))
#define SQLITE_IOERR_VNODE (SQLITE_IOERR | (27<<8))
#define SQLITE_IOERR_AUTH (SQLITE_IOERR | (28<<8))
#define SQLITE_IOERR_BEGIN_ATOMIC (SQLITE_IOERR | (29<<8))
#define SQLITE_IOERR_COMMIT_ATOMIC (SQLITE_IOERR | (30<<8))
#define SQLITE_IOERR_ROLLBACK_ATOMIC (SQLITE_IOERR | (31<<8))
#define SQLITE_LOCKED_SHAREDCACHE (SQLITE_LOCKED | (1<<8))
#define SQLITE_LOCKED_VTAB (SQLITE_LOCKED | (2<<8))
#define SQLITE_BUSY_RECOVERY (SQLITE_BUSY | (1<<8))
#define SQLITE_BUSY_SNAPSHOT (SQLITE_BUSY | (2<<8))
#define SQLITE_CANTOPEN_NOTEMPDIR (SQLITE_CANTOPEN | (1<<8))
#define SQLITE_CANTOPEN_ISDIR (SQLITE_CANTOPEN | (2<<8))
#define SQLITE_CANTOPEN_FULLPATH (SQLITE_CANTOPEN | (3<<8))
#define SQLITE_CANTOPEN_CONVPATH (SQLITE_CANTOPEN | (4<<8))
#define SQLITE_CANTOPEN_DIRTYWAL (SQLITE_CANTOPEN | (5<<8))
#define SQLITE_CORRUPT_VTAB (SQLITE_CORRUPT | (1<<8))
#define SQLITE_CORRUPT_SEQUENCE (SQLITE_CORRUPT | (2<<8))
#define SQLITE_READONLY_RECOVERY (SQLITE_READONLY | (1<<8))
#define SQLITE_READONLY_CANTLOCK (SQLITE_READONLY | (2<<8))
#define SQLITE_READONLY_ROLLBACK (SQLITE_READONLY | (3<<8))
#define SQLITE_READONLY_DBMOVED (SQLITE_READONLY | (4<<8))
#define SQLITE_READONLY_CANTINIT (SQLITE_READONLY | (5<<8))
#define SQLITE_READONLY_DIRECTORY (SQLITE_READONLY | (6<<8))
#define SQLITE_ABORT_ROLLBACK (SQLITE_ABORT | (2<<8))
#define SQLITE_CONSTRAINT_CHECK (SQLITE_CONSTRAINT | (1<<8))
#define SQLITE_CONSTRAINT_COMMITHOOK (SQLITE_CONSTRAINT | (2<<8))
#define SQLITE_CONSTRAINT_FOREIGNKEY (SQLITE_CONSTRAINT | (3<<8))
#define SQLITE_CONSTRAINT_FUNCTION (SQLITE_CONSTRAINT | (4<<8))
#define SQLITE_CONSTRAINT_NOTNULL (SQLITE_CONSTRAINT | (5<<8))
#define SQLITE_CONSTRAINT_PRIMARYKEY (SQLITE_CONSTRAINT | (6<<8))
#define SQLITE_CONSTRAINT_TRIGGER (SQLITE_CONSTRAINT | (7<<8))
#define SQLITE_CONSTRAINT_UNIQUE (SQLITE_CONSTRAINT | (8<<8))
#define SQLITE_CONSTRAINT_VTAB (SQLITE_CONSTRAINT | (9<<8))
#define SQLITE_CONSTRAINT_ROWID (SQLITE_CONSTRAINT |(10<<8))
#define SQLITE_NOTICE_RECOVER_WAL (SQLITE_NOTICE | (1<<8))
#define SQLITE_NOTICE_RECOVER_ROLLBACK (SQLITE_NOTICE | (2<<8))
#define SQLITE_WARNING_AUTOINDEX (SQLITE_WARNING | (1<<8))
#define SQLITE_AUTH_USER (SQLITE_AUTH | (1<<8))
#define SQLITE_OK_LOAD_PERMANENTLY (SQLITE_OK | (1<<8))
# 1593 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_OPEN_READONLY 0x00000001
#define SQLITE_OPEN_READWRITE 0x00000002
#define SQLITE_OPEN_CREATE 0x00000004
#define SQLITE_OPEN_DELETEONCLOSE 0x00000008
#define SQLITE_OPEN_EXCLUSIVE 0x00000010
#define SQLITE_OPEN_AUTOPROXY 0x00000020
#define SQLITE_OPEN_URI 0x00000040
#define SQLITE_OPEN_MEMORY 0x00000080
#define SQLITE_OPEN_MAIN_DB 0x00000100
#define SQLITE_OPEN_TEMP_DB 0x00000200
#define SQLITE_OPEN_TRANSIENT_DB 0x00000400
#define SQLITE_OPEN_MAIN_JOURNAL 0x00000800
#define SQLITE_OPEN_TEMP_JOURNAL 0x00001000
#define SQLITE_OPEN_SUBJOURNAL 0x00002000
#define SQLITE_OPEN_MASTER_JOURNAL 0x00004000
#define SQLITE_OPEN_NOMUTEX 0x00008000
#define SQLITE_OPEN_FULLMUTEX 0x00010000
#define SQLITE_OPEN_SHAREDCACHE 0x00020000
#define SQLITE_OPEN_PRIVATECACHE 0x00040000
#define SQLITE_OPEN_WAL 0x00080000
# 1649 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_IOCAP_ATOMIC 0x00000001
#define SQLITE_IOCAP_ATOMIC512 0x00000002
#define SQLITE_IOCAP_ATOMIC1K 0x00000004
#define SQLITE_IOCAP_ATOMIC2K 0x00000008
#define SQLITE_IOCAP_ATOMIC4K 0x00000010
#define SQLITE_IOCAP_ATOMIC8K 0x00000020
#define SQLITE_IOCAP_ATOMIC16K 0x00000040
#define SQLITE_IOCAP_ATOMIC32K 0x00000080
#define SQLITE_IOCAP_ATOMIC64K 0x00000100
#define SQLITE_IOCAP_SAFE_APPEND 0x00000200
#define SQLITE_IOCAP_SEQUENTIAL 0x00000400
#define SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN 0x00000800
#define SQLITE_IOCAP_POWERSAFE_OVERWRITE 0x00001000
#define SQLITE_IOCAP_IMMUTABLE 0x00002000
#define SQLITE_IOCAP_BATCH_ATOMIC 0x00004000
# 1672 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_LOCK_NONE 0
#define SQLITE_LOCK_SHARED 1
#define SQLITE_LOCK_RESERVED 2
#define SQLITE_LOCK_PENDING 3
#define SQLITE_LOCK_EXCLUSIVE 4
# 1704 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SYNC_NORMAL 0x00002
#define SQLITE_SYNC_FULL 0x00003
#define SQLITE_SYNC_DATAONLY 0x00010
# 1719 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_file sqlite3_file;
struct sqlite3_file {
  const struct sqlite3_io_methods *pMethods;
};
# 1818 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_io_methods sqlite3_io_methods;
struct sqlite3_io_methods {
  int iVersion;
  int (*xClose)(sqlite3_file*);
  int (*xRead)(sqlite3_file*, void*, int iAmt, sqlite3_int64 iOfst);
  int (*xWrite)(sqlite3_file*, const void*, int iAmt, sqlite3_int64 iOfst);
  int (*xTruncate)(sqlite3_file*, sqlite3_int64 size);
  int (*xSync)(sqlite3_file*, int flags);
  int (*xFileSize)(sqlite3_file*, sqlite3_int64 *pSize);
  int (*xLock)(sqlite3_file*, int);
  int (*xUnlock)(sqlite3_file*, int);
  int (*xCheckReservedLock)(sqlite3_file*, int *pResOut);
  int (*xFileControl)(sqlite3_file*, int op, void *pArg);
  int (*xSectorSize)(sqlite3_file*);
  int (*xDeviceCharacteristics)(sqlite3_file*);

  int (*xShmMap)(sqlite3_file*, int iPg, int pgsz, int, void volatile**);
  int (*xShmLock)(sqlite3_file*, int offset, int n, int flags);
  void (*xShmBarrier)(sqlite3_file*);
  int (*xShmUnmap)(sqlite3_file*, int deleteFlag);

  int (*xFetch)(sqlite3_file*, sqlite3_int64 iOfst, int iAmt, void **pp);
  int (*xUnfetch)(sqlite3_file*, sqlite3_int64 iOfst, void *p);


};
# 2154 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_FCNTL_LOCKSTATE 1
#define SQLITE_FCNTL_GET_LOCKPROXYFILE 2
#define SQLITE_FCNTL_SET_LOCKPROXYFILE 3
#define SQLITE_FCNTL_LAST_ERRNO 4
#define SQLITE_FCNTL_SIZE_HINT 5
#define SQLITE_FCNTL_CHUNK_SIZE 6
#define SQLITE_FCNTL_FILE_POINTER 7
#define SQLITE_FCNTL_SYNC_OMITTED 8
#define SQLITE_FCNTL_WIN32_AV_RETRY 9
#define SQLITE_FCNTL_PERSIST_WAL 10
#define SQLITE_FCNTL_OVERWRITE 11
#define SQLITE_FCNTL_VFSNAME 12
#define SQLITE_FCNTL_POWERSAFE_OVERWRITE 13
#define SQLITE_FCNTL_PRAGMA 14
#define SQLITE_FCNTL_BUSYHANDLER 15
#define SQLITE_FCNTL_TEMPFILENAME 16
#define SQLITE_FCNTL_MMAP_SIZE 18
#define SQLITE_FCNTL_TRACE 19
#define SQLITE_FCNTL_HAS_MOVED 20
#define SQLITE_FCNTL_SYNC 21
#define SQLITE_FCNTL_COMMIT_PHASETWO 22
#define SQLITE_FCNTL_WIN32_SET_HANDLE 23
#define SQLITE_FCNTL_WAL_BLOCK 24
#define SQLITE_FCNTL_ZIPVFS 25
#define SQLITE_FCNTL_RBU 26
#define SQLITE_FCNTL_VFS_POINTER 27
#define SQLITE_FCNTL_JOURNAL_POINTER 28
#define SQLITE_FCNTL_WIN32_GET_HANDLE 29
#define SQLITE_FCNTL_PDB 30
#define SQLITE_FCNTL_BEGIN_ATOMIC_WRITE 31
#define SQLITE_FCNTL_COMMIT_ATOMIC_WRITE 32
#define SQLITE_FCNTL_ROLLBACK_ATOMIC_WRITE 33
#define SQLITE_FCNTL_LOCK_TIMEOUT 34
#define SQLITE_FCNTL_DATA_VERSION 35
#define SQLITE_FCNTL_SIZE_LIMIT 36


#define SQLITE_GET_LOCKPROXYFILE SQLITE_FCNTL_GET_LOCKPROXYFILE
#define SQLITE_SET_LOCKPROXYFILE SQLITE_FCNTL_SET_LOCKPROXYFILE
#define SQLITE_LAST_ERRNO SQLITE_FCNTL_LAST_ERRNO
# 2206 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_mutex sqlite3_mutex;
# 2216 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_api_routines sqlite3_api_routines;
# 2387 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_vfs sqlite3_vfs;
typedef void (*sqlite3_syscall_ptr)(void);
struct sqlite3_vfs {
  int iVersion;
  int szOsFile;
  int mxPathname;
  sqlite3_vfs *pNext;
  const char *zName;
  void *pAppData;
  int (*xOpen)(sqlite3_vfs*, const char *zName, sqlite3_file*,
               int flags, int *pOutFlags);
  int (*xDelete)(sqlite3_vfs*, const char *zName, int syncDir);
  int (*xAccess)(sqlite3_vfs*, const char *zName, int flags, int *pResOut);
  int (*xFullPathname)(sqlite3_vfs*, const char *zName, int nOut, char *zOut);
  void *(*xDlOpen)(sqlite3_vfs*, const char *zFilename);
  void (*xDlError)(sqlite3_vfs*, int nByte, char *zErrMsg);
  void (*(*xDlSym)(sqlite3_vfs*,void*, const char *zSymbol))(void);
  void (*xDlClose)(sqlite3_vfs*, void*);
  int (*xRandomness)(sqlite3_vfs*, int nByte, char *zOut);
  int (*xSleep)(sqlite3_vfs*, int microseconds);
  int (*xCurrentTime)(sqlite3_vfs*, double*);
  int (*xGetLastError)(sqlite3_vfs*, int, char *);




  int (*xCurrentTimeInt64)(sqlite3_vfs*, sqlite3_int64*);




  int (*xSetSystemCall)(sqlite3_vfs*, const char *zName, sqlite3_syscall_ptr);
  sqlite3_syscall_ptr (*xGetSystemCall)(sqlite3_vfs*, const char *zName);
  const char *(*xNextSystemCall)(sqlite3_vfs*, const char *zName);





};
# 2448 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_ACCESS_EXISTS 0
#define SQLITE_ACCESS_READWRITE 1
#define SQLITE_ACCESS_READ 2
# 2474 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SHM_UNLOCK 1
#define SQLITE_SHM_LOCK 2
#define SQLITE_SHM_SHARED 4
#define SQLITE_SHM_EXCLUSIVE 8
# 2487 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SHM_NLOCK 8
# 2565 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_initialize(void);
 int sqlite3_shutdown(void);
 int sqlite3_os_init(void);
 int sqlite3_os_end(void);
# 2601 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_config(int, ...);
# 2620 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_db_config(sqlite3*, int op, ...);
# 2685 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_mem_methods sqlite3_mem_methods;
struct sqlite3_mem_methods {
  void *(*xMalloc)(int);
  void (*xFree)(void*);
  void *(*xRealloc)(void*,int);
  int (*xSize)(void*);
  int (*xRoundup)(int);
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  void *pAppData;
};
# 3049 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_CONFIG_SINGLETHREAD 1
#define SQLITE_CONFIG_MULTITHREAD 2
#define SQLITE_CONFIG_SERIALIZED 3
#define SQLITE_CONFIG_MALLOC 4
#define SQLITE_CONFIG_GETMALLOC 5
#define SQLITE_CONFIG_SCRATCH 6
#define SQLITE_CONFIG_PAGECACHE 7
#define SQLITE_CONFIG_HEAP 8
#define SQLITE_CONFIG_MEMSTATUS 9
#define SQLITE_CONFIG_MUTEX 10
#define SQLITE_CONFIG_GETMUTEX 11

#define SQLITE_CONFIG_LOOKASIDE 13
#define SQLITE_CONFIG_PCACHE 14
#define SQLITE_CONFIG_GETPCACHE 15
#define SQLITE_CONFIG_LOG 16
#define SQLITE_CONFIG_URI 17
#define SQLITE_CONFIG_PCACHE2 18
#define SQLITE_CONFIG_GETPCACHE2 19
#define SQLITE_CONFIG_COVERING_INDEX_SCAN 20
#define SQLITE_CONFIG_SQLLOG 21
#define SQLITE_CONFIG_MMAP_SIZE 22
#define SQLITE_CONFIG_WIN32_HEAPSIZE 23
#define SQLITE_CONFIG_PCACHE_HDRSZ 24
#define SQLITE_CONFIG_PMASZ 25
#define SQLITE_CONFIG_STMTJRNL_SPILL 26
#define SQLITE_CONFIG_SMALL_MALLOC 27
#define SQLITE_CONFIG_SORTERREF_SIZE 28
#define SQLITE_CONFIG_MEMDB_MAXSIZE 29
# 3306 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DBCONFIG_MAINDBNAME 1000
#define SQLITE_DBCONFIG_LOOKASIDE 1001
#define SQLITE_DBCONFIG_ENABLE_FKEY 1002
#define SQLITE_DBCONFIG_ENABLE_TRIGGER 1003
#define SQLITE_DBCONFIG_ENABLE_FTS3_TOKENIZER 1004
#define SQLITE_DBCONFIG_ENABLE_LOAD_EXTENSION 1005
#define SQLITE_DBCONFIG_NO_CKPT_ON_CLOSE 1006
#define SQLITE_DBCONFIG_ENABLE_QPSG 1007
#define SQLITE_DBCONFIG_TRIGGER_EQP 1008
#define SQLITE_DBCONFIG_RESET_DATABASE 1009
#define SQLITE_DBCONFIG_DEFENSIVE 1010
#define SQLITE_DBCONFIG_WRITABLE_SCHEMA 1011
#define SQLITE_DBCONFIG_LEGACY_ALTER_TABLE 1012
#define SQLITE_DBCONFIG_DQS_DML 1013
#define SQLITE_DBCONFIG_DQS_DDL 1014
#define SQLITE_DBCONFIG_ENABLE_VIEW 1015
#define SQLITE_DBCONFIG_MAX 1015
# 3332 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_extended_result_codes(sqlite3*, int onoff);
# 3394 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_int64 sqlite3_last_insert_rowid(sqlite3*);
# 3404 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_set_last_insert_rowid(sqlite3*,sqlite3_int64);
# 3462 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_changes(sqlite3*);
# 3499 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_total_changes(sqlite3*);
# 3536 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_interrupt(sqlite3*);
# 3571 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_complete(const char *sql);
 int sqlite3_complete16(const void *sql);
# 3633 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_busy_handler(sqlite3*,int(*)(void*,int),void*);
# 3656 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_busy_timeout(sqlite3*, int ms);
# 3731 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrmsg
);
 void sqlite3_free_table(char **result);
# 3781 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_mprintf(const char*,...);
 char *sqlite3_vmprintf(const char*, va_list);
 char *sqlite3_snprintf(int,char*,const char*, ...);
 char *sqlite3_vsnprintf(int,char*,const char*, va_list);
# 3874 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_malloc(int);
 void *sqlite3_malloc64(sqlite3_uint64);
 void *sqlite3_realloc(void*, int);
 void *sqlite3_realloc64(void*, sqlite3_uint64);
 void sqlite3_free(void*);
 sqlite3_uint64 sqlite3_msize(void*);
# 3904 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_int64 sqlite3_memory_used(void);
 sqlite3_int64 sqlite3_memory_highwater(int resetFlag);
# 3928 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_randomness(int N, void *P);
# 4019 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_set_authorizer(
  sqlite3*,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pUserData
);
# 4037 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DENY 1
#define SQLITE_IGNORE 2
# 4060 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_CREATE_INDEX 1
#define SQLITE_CREATE_TABLE 2
#define SQLITE_CREATE_TEMP_INDEX 3
#define SQLITE_CREATE_TEMP_TABLE 4
#define SQLITE_CREATE_TEMP_TRIGGER 5
#define SQLITE_CREATE_TEMP_VIEW 6
#define SQLITE_CREATE_TRIGGER 7
#define SQLITE_CREATE_VIEW 8
#define SQLITE_DELETE 9
#define SQLITE_DROP_INDEX 10
#define SQLITE_DROP_TABLE 11
#define SQLITE_DROP_TEMP_INDEX 12
#define SQLITE_DROP_TEMP_TABLE 13
#define SQLITE_DROP_TEMP_TRIGGER 14
#define SQLITE_DROP_TEMP_VIEW 15
#define SQLITE_DROP_TRIGGER 16
#define SQLITE_DROP_VIEW 17
#define SQLITE_INSERT 18
#define SQLITE_PRAGMA 19
#define SQLITE_READ 20
#define SQLITE_SELECT 21
#define SQLITE_TRANSACTION 22
#define SQLITE_UPDATE 23
#define SQLITE_ATTACH 24
#define SQLITE_DETACH 25
#define SQLITE_ALTER_TABLE 26
#define SQLITE_REINDEX 27
#define SQLITE_ANALYZE 28
#define SQLITE_CREATE_VTABLE 29
#define SQLITE_DROP_VTABLE 30
#define SQLITE_FUNCTION 31
#define SQLITE_SAVEPOINT 32
#define SQLITE_COPY 0
#define SQLITE_RECURSIVE 33
# 4127 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_trace(sqlite3*,
   void(*xTrace)(void*,const char*), void*);
 void *sqlite3_profile(sqlite3*,
   void(*xProfile)(void*,const char*,sqlite3_uint64), void*);
# 4184 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_TRACE_STMT 0x01
#define SQLITE_TRACE_PROFILE 0x02
#define SQLITE_TRACE_ROW 0x04
#define SQLITE_TRACE_CLOSE 0x08
# 4218 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_trace_v2(
  sqlite3*,
  unsigned uMask,
  int(*xCallback)(unsigned,void*,void*,void*),
  void *pCtx
);
# 4257 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_progress_handler(sqlite3*, int, int(*)(void*), void*);
# 4486 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_open(
  const char *filename,
  sqlite3 **ppDb
);
 int sqlite3_open16(
  const void *filename,
  sqlite3 **ppDb
);
 int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
);
# 4542 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam);
 int sqlite3_uri_boolean(const char *zFile, const char *zParam, int bDefault);
 sqlite3_int64 sqlite3_uri_int64(const char*, const char*, sqlite3_int64);
# 4599 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_errcode(sqlite3 *db);
 int sqlite3_extended_errcode(sqlite3 *db);
 const char *sqlite3_errmsg(sqlite3*);
 const void *sqlite3_errmsg16(sqlite3*);
 const char *sqlite3_errstr(int);
# 4629 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_stmt sqlite3_stmt;
# 4671 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_limit(sqlite3*, int id, int newVal);
# 4729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_LIMIT_LENGTH 0
#define SQLITE_LIMIT_SQL_LENGTH 1
#define SQLITE_LIMIT_COLUMN 2
#define SQLITE_LIMIT_EXPR_DEPTH 3
#define SQLITE_LIMIT_COMPOUND_SELECT 4
#define SQLITE_LIMIT_VDBE_OP 5
#define SQLITE_LIMIT_FUNCTION_ARG 6
#define SQLITE_LIMIT_ATTACHED 7
#define SQLITE_LIMIT_LIKE_PATTERN_LENGTH 8
#define SQLITE_LIMIT_VARIABLE_NUMBER 9
#define SQLITE_LIMIT_TRIGGER_DEPTH 10
#define SQLITE_LIMIT_WORKER_THREADS 11
# 4777 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_PREPARE_PERSISTENT 0x01
#define SQLITE_PREPARE_NORMALIZE 0x02
#define SQLITE_PREPARE_NO_VTAB 0x04
# 4881 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
 int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
 int sqlite3_prepare_v3(
  sqlite3 *db,
  const char *zSql,
  int nByte,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const char **pzTail
);
 int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
 int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
 int sqlite3_prepare16_v3(
  sqlite3 *db,
  const void *zSql,
  int nByte,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const void **pzTail
);
# 4964 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_sql(sqlite3_stmt *pStmt);
 char *sqlite3_expanded_sql(sqlite3_stmt *pStmt);
 const char *sqlite3_normalized_sql(sqlite3_stmt *pStmt);
# 5002 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_stmt_readonly(sqlite3_stmt *pStmt);
# 5014 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt);
# 5035 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_stmt_busy(sqlite3_stmt*);
# 5077 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_value sqlite3_value;
# 5091 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_context sqlite3_context;
# 5211 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_bind_blob(sqlite3_stmt*, int, const void*, int n, void(*)(void*));
 int sqlite3_bind_blob64(sqlite3_stmt*, int, const void*, sqlite3_uint64,
                        void(*)(void*));
 int sqlite3_bind_double(sqlite3_stmt*, int, double);
 int sqlite3_bind_int(sqlite3_stmt*, int, int);
 int sqlite3_bind_int64(sqlite3_stmt*, int, sqlite3_int64);
 int sqlite3_bind_null(sqlite3_stmt*, int);
 int sqlite3_bind_text(sqlite3_stmt*,int,const char*,int,void(*)(void*));
 int sqlite3_bind_text16(sqlite3_stmt*, int, const void*, int, void(*)(void*));
 int sqlite3_bind_text64(sqlite3_stmt*, int, const char*, sqlite3_uint64,
                         void(*)(void*), unsigned char encoding);
 int sqlite3_bind_value(sqlite3_stmt*, int, const sqlite3_value*);
 int sqlite3_bind_pointer(sqlite3_stmt*, int, void*, const char*,void(*)(void*));
 int sqlite3_bind_zeroblob(sqlite3_stmt*, int, int n);
 int sqlite3_bind_zeroblob64(sqlite3_stmt*, int, sqlite3_uint64);
# 5246 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_bind_parameter_count(sqlite3_stmt*);
# 5274 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_bind_parameter_name(sqlite3_stmt*, int);
# 5292 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_bind_parameter_index(sqlite3_stmt*, const char *zName);
# 5302 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_clear_bindings(sqlite3_stmt*);
# 5318 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_column_count(sqlite3_stmt *pStmt);
# 5347 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_column_name(sqlite3_stmt*, int N);
 const void *sqlite3_column_name16(sqlite3_stmt*, int N);
# 5396 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_column_database_name(sqlite3_stmt*,int);
 const void *sqlite3_column_database_name16(sqlite3_stmt*,int);
 const char *sqlite3_column_table_name(sqlite3_stmt*,int);
 const void *sqlite3_column_table_name16(sqlite3_stmt*,int);
 const char *sqlite3_column_origin_name(sqlite3_stmt*,int);
 const void *sqlite3_column_origin_name16(sqlite3_stmt*,int);
# 5433 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_column_decltype(sqlite3_stmt*,int);
 const void *sqlite3_column_decltype16(sqlite3_stmt*,int);
# 5518 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_step(sqlite3_stmt*);
# 5539 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_data_count(sqlite3_stmt *pStmt);
# 5562 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_INTEGER 1
#define SQLITE_FLOAT 2
#define SQLITE_BLOB 4
#define SQLITE_NULL 5



#define SQLITE_TEXT 3

#define SQLITE3_TEXT 3
# 5782 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const void *sqlite3_column_blob(sqlite3_stmt*, int iCol);
 double sqlite3_column_double(sqlite3_stmt*, int iCol);
 int sqlite3_column_int(sqlite3_stmt*, int iCol);
 sqlite3_int64 sqlite3_column_int64(sqlite3_stmt*, int iCol);
 const unsigned char *sqlite3_column_text(sqlite3_stmt*, int iCol);
 const void *sqlite3_column_text16(sqlite3_stmt*, int iCol);
 sqlite3_value *sqlite3_column_value(sqlite3_stmt*, int iCol);
 int sqlite3_column_bytes(sqlite3_stmt*, int iCol);
 int sqlite3_column_bytes16(sqlite3_stmt*, int iCol);
 int sqlite3_column_type(sqlite3_stmt*, int iCol);
# 5819 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_finalize(sqlite3_stmt *pStmt);
# 5846 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_reset(sqlite3_stmt *pStmt);
# 5964 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
 int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
);
 int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void(*xDestroy)(void*)
);
 int sqlite3_create_window_function(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int eTextRep,
  void *pApp,
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value**),
  void(*xDestroy)(void*)
);







#define SQLITE_UTF8 1
#define SQLITE_UTF16LE 2
#define SQLITE_UTF16BE 3
#define SQLITE_UTF16 4
#define SQLITE_ANY 5
#define SQLITE_UTF16_ALIGNED 8
# 6049 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DETERMINISTIC 0x000000800
#define SQLITE_DIRECTONLY 0x000080000
#define SQLITE_SUBTYPE 0x000100000
# 6064 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_aggregate_count(sqlite3_context*);
 int sqlite3_expired(sqlite3_stmt*);
 int sqlite3_transfer_bindings(sqlite3_stmt*, sqlite3_stmt*);
 int sqlite3_global_recover(void);
 void sqlite3_thread_cleanup(void);
 int sqlite3_memory_alarm(void(*)(void*,sqlite3_int64,int),
                      void*,sqlite3_int64);
# 6201 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const void *sqlite3_value_blob(sqlite3_value*);
 double sqlite3_value_double(sqlite3_value*);
 int sqlite3_value_int(sqlite3_value*);
 sqlite3_int64 sqlite3_value_int64(sqlite3_value*);
 void *sqlite3_value_pointer(sqlite3_value*, const char*);
 const unsigned char *sqlite3_value_text(sqlite3_value*);
 const void *sqlite3_value_text16(sqlite3_value*);
 const void *sqlite3_value_text16le(sqlite3_value*);
 const void *sqlite3_value_text16be(sqlite3_value*);
 int sqlite3_value_bytes(sqlite3_value*);
 int sqlite3_value_bytes16(sqlite3_value*);
 int sqlite3_value_type(sqlite3_value*);
 int sqlite3_value_numeric_type(sqlite3_value*);
 int sqlite3_value_nochange(sqlite3_value*);
 int sqlite3_value_frombind(sqlite3_value*);
# 6227 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 unsigned int sqlite3_value_subtype(sqlite3_value*);
# 6243 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_value *sqlite3_value_dup(const sqlite3_value*);
 void sqlite3_value_free(sqlite3_value*);
# 6289 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_aggregate_context(sqlite3_context*, int nBytes);
# 6304 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_user_data(sqlite3_context*);
# 6316 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3 *sqlite3_context_db_handle(sqlite3_context*);
# 6375 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_get_auxdata(sqlite3_context*, int N);
 void sqlite3_set_auxdata(sqlite3_context*, int N, void*, void (*)(void*));
# 6393 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef void (*sqlite3_destructor_type)(void*);
#define SQLITE_STATIC ((sqlite3_destructor_type)0)
#define SQLITE_TRANSIENT ((sqlite3_destructor_type)-1)
# 6523 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_result_blob(sqlite3_context*, const void*, int, void(*)(void*));
 void sqlite3_result_blob64(sqlite3_context*,const void*,
                           sqlite3_uint64,void(*)(void*));
 void sqlite3_result_double(sqlite3_context*, double);
 void sqlite3_result_error(sqlite3_context*, const char*, int);
 void sqlite3_result_error16(sqlite3_context*, const void*, int);
 void sqlite3_result_error_toobig(sqlite3_context*);
 void sqlite3_result_error_nomem(sqlite3_context*);
 void sqlite3_result_error_code(sqlite3_context*, int);
 void sqlite3_result_int(sqlite3_context*, int);
 void sqlite3_result_int64(sqlite3_context*, sqlite3_int64);
 void sqlite3_result_null(sqlite3_context*);
 void sqlite3_result_text(sqlite3_context*, const char*, int, void(*)(void*));
 void sqlite3_result_text64(sqlite3_context*, const char*,sqlite3_uint64,
                           void(*)(void*), unsigned char encoding);
 void sqlite3_result_text16(sqlite3_context*, const void*, int, void(*)(void*));
 void sqlite3_result_text16le(sqlite3_context*, const void*, int,void(*)(void*));
 void sqlite3_result_text16be(sqlite3_context*, const void*, int,void(*)(void*));
 void sqlite3_result_value(sqlite3_context*, sqlite3_value*);
 void sqlite3_result_pointer(sqlite3_context*, void*,const char*,void(*)(void*));
 void sqlite3_result_zeroblob(sqlite3_context*, int n);
 int sqlite3_result_zeroblob64(sqlite3_context*, sqlite3_uint64 n);
# 6559 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_result_subtype(sqlite3_context*,unsigned int);
# 6641 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_create_collation(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
 int sqlite3_create_collation_v2(
  sqlite3*,
  const char *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDestroy)(void*)
);
 int sqlite3_create_collation16(
  sqlite3*,
  const void *zName,
  int eTextRep,
  void *pArg,
  int(*xCompare)(void*,int,const void*,int,const void*)
);
# 6691 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_collation_needed(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const char*)
);
 int sqlite3_collation_needed16(
  sqlite3*,
  void*,
  void(*)(void*,sqlite3*,int eTextRep,const void*)
);
# 6774 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_sleep(int);
# 6832 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_temp_directory;
# 6869 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_data_directory;
# 6890 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_win32_set_directory(
  unsigned long type,
  void *zValue
);
 int sqlite3_win32_set_directory8(unsigned long type, const char *zValue);
 int sqlite3_win32_set_directory16(unsigned long type, const void *zValue);







#define SQLITE_WIN32_DATA_DIRECTORY_TYPE 1
#define SQLITE_WIN32_TEMP_DIRECTORY_TYPE 2
# 6928 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_get_autocommit(sqlite3*);
# 6941 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3 *sqlite3_db_handle(sqlite3_stmt*);
# 6958 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName);
# 6968 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_db_readonly(sqlite3 *db, const char *zDbName);
# 6984 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt);
# 7033 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_commit_hook(sqlite3*, int(*)(void*), void*);
 void *sqlite3_rollback_hook(sqlite3*, void(*)(void *), void*);
# 7085 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_update_hook(
  sqlite3*,
  void(*)(void *,int ,char const *,char const *,sqlite3_int64),
  void*
);
# 7126 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_enable_shared_cache(int);
# 7142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_release_memory(int);
# 7156 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_db_release_memory(sqlite3*);
# 7209 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 N);
# 7220 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_soft_heap_limit(int N);
# 7292 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
);
# 7348 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
);
# 7380 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_enable_load_extension(sqlite3 *db, int onoff);
# 7418 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_auto_extension(void(*xEntryPoint)(void));
# 7430 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_cancel_auto_extension(void(*xEntryPoint)(void));







 void sqlite3_reset_auto_extension(void);
# 7452 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_vtab sqlite3_vtab;
typedef struct sqlite3_index_info sqlite3_index_info;
typedef struct sqlite3_vtab_cursor sqlite3_vtab_cursor;
typedef struct sqlite3_module sqlite3_module;
# 7473 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_module {
  int iVersion;
  int (*xCreate)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xConnect)(sqlite3*, void *pAux,
               int argc, const char *const*argv,
               sqlite3_vtab **ppVTab, char**);
  int (*xBestIndex)(sqlite3_vtab *pVTab, sqlite3_index_info*);
  int (*xDisconnect)(sqlite3_vtab *pVTab);
  int (*xDestroy)(sqlite3_vtab *pVTab);
  int (*xOpen)(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor);
  int (*xClose)(sqlite3_vtab_cursor*);
  int (*xFilter)(sqlite3_vtab_cursor*, int idxNum, const char *idxStr,
                int argc, sqlite3_value **argv);
  int (*xNext)(sqlite3_vtab_cursor*);
  int (*xEof)(sqlite3_vtab_cursor*);
  int (*xColumn)(sqlite3_vtab_cursor*, sqlite3_context*, int);
  int (*xRowid)(sqlite3_vtab_cursor*, sqlite3_int64 *pRowid);
  int (*xUpdate)(sqlite3_vtab *, int, sqlite3_value **, sqlite3_int64 *);
  int (*xBegin)(sqlite3_vtab *pVTab);
  int (*xSync)(sqlite3_vtab *pVTab);
  int (*xCommit)(sqlite3_vtab *pVTab);
  int (*xRollback)(sqlite3_vtab *pVTab);
  int (*xFindFunction)(sqlite3_vtab *pVtab, int nArg, const char *zName,
                       void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
                       void **ppArg);
  int (*xRename)(sqlite3_vtab *pVtab, const char *zNew);


  int (*xSavepoint)(sqlite3_vtab *pVTab, int);
  int (*xRelease)(sqlite3_vtab *pVTab, int);
  int (*xRollbackTo)(sqlite3_vtab *pVTab, int);


  int (*xShadowName)(const char*);
};
# 7607 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_index_info {

  int nConstraint;
  struct sqlite3_index_constraint {
     int iColumn;
     unsigned char op;
     unsigned char usable;
     int iTermOffset;
  } *aConstraint;
  int nOrderBy;
  struct sqlite3_index_orderby {
     int iColumn;
     unsigned char desc;
  } *aOrderBy;

  struct sqlite3_index_constraint_usage {
    int argvIndex;
    unsigned char omit;
  } *aConstraintUsage;
  int idxNum;
  char *idxStr;
  int needToFreeIdxStr;
  int orderByConsumed;
  double estimatedCost;

  sqlite3_int64 estimatedRows;

  int idxFlags;

  sqlite3_uint64 colUsed;
};
# 7646 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_INDEX_SCAN_UNIQUE 1
# 7656 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_INDEX_CONSTRAINT_EQ 2
#define SQLITE_INDEX_CONSTRAINT_GT 4
#define SQLITE_INDEX_CONSTRAINT_LE 8
#define SQLITE_INDEX_CONSTRAINT_LT 16
#define SQLITE_INDEX_CONSTRAINT_GE 32
#define SQLITE_INDEX_CONSTRAINT_MATCH 64
#define SQLITE_INDEX_CONSTRAINT_LIKE 65
#define SQLITE_INDEX_CONSTRAINT_GLOB 66
#define SQLITE_INDEX_CONSTRAINT_REGEXP 67
#define SQLITE_INDEX_CONSTRAINT_NE 68
#define SQLITE_INDEX_CONSTRAINT_ISNOT 69
#define SQLITE_INDEX_CONSTRAINT_ISNOTNULL 70
#define SQLITE_INDEX_CONSTRAINT_ISNULL 71
#define SQLITE_INDEX_CONSTRAINT_IS 72
#define SQLITE_INDEX_CONSTRAINT_FUNCTION 150
# 7704 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData
);
 int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *p,
  void *pClientData,
  void(*xDestroy)(void*)
);
# 7730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_drop_modules(
  sqlite3 *db,
  const char **azKeep
);
# 7753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_vtab {
  const sqlite3_module *pModule;
  int nRef;
  char *zErrMsg;

};
# 7777 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_vtab_cursor {
  sqlite3_vtab *pVtab;

};
# 7790 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_declare_vtab(sqlite3*, const char *zSQL);
# 7809 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_overload_function(sqlite3*, const char *zFuncName, int nArg);
# 7833 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_blob sqlite3_blob;
# 7918 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_blob_open(
  sqlite3*,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite3_int64 iRow,
  int flags,
  sqlite3_blob **ppBlob
);
# 7951 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_blob_reopen(sqlite3_blob *, sqlite3_int64);
# 7974 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_blob_close(sqlite3_blob *);
# 7990 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_blob_bytes(sqlite3_blob *);
# 8019 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_blob_read(sqlite3_blob *, void *Z, int N, int iOffset);
# 8061 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_blob_write(sqlite3_blob *, const void *z, int n, int iOffset);
# 8092 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_vfs *sqlite3_vfs_find(const char *zVfsName);
 int sqlite3_vfs_register(sqlite3_vfs*, int makeDflt);
 int sqlite3_vfs_unregister(sqlite3_vfs*);
# 8210 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_mutex *sqlite3_mutex_alloc(int);
 void sqlite3_mutex_free(sqlite3_mutex*);
 void sqlite3_mutex_enter(sqlite3_mutex*);
 int sqlite3_mutex_try(sqlite3_mutex*);
 void sqlite3_mutex_leave(sqlite3_mutex*);
# 8281 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_mutex_methods sqlite3_mutex_methods;
struct sqlite3_mutex_methods {
  int (*xMutexInit)(void);
  int (*xMutexEnd)(void);
  sqlite3_mutex *(*xMutexAlloc)(int);
  void (*xMutexFree)(sqlite3_mutex *);
  void (*xMutexEnter)(sqlite3_mutex *);
  int (*xMutexTry)(sqlite3_mutex *);
  void (*xMutexLeave)(sqlite3_mutex *);
  int (*xMutexHeld)(sqlite3_mutex *);
  int (*xMutexNotheld)(sqlite3_mutex *);
};
# 8324 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_mutex_held(sqlite3_mutex*);
 int sqlite3_mutex_notheld(sqlite3_mutex*);
# 8338 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MUTEX_FAST 0
#define SQLITE_MUTEX_RECURSIVE 1
#define SQLITE_MUTEX_STATIC_MASTER 2
#define SQLITE_MUTEX_STATIC_MEM 3
#define SQLITE_MUTEX_STATIC_MEM2 4
#define SQLITE_MUTEX_STATIC_OPEN 4
#define SQLITE_MUTEX_STATIC_PRNG 5
#define SQLITE_MUTEX_STATIC_LRU 6
#define SQLITE_MUTEX_STATIC_LRU2 7
#define SQLITE_MUTEX_STATIC_PMEM 7
#define SQLITE_MUTEX_STATIC_APP1 8
#define SQLITE_MUTEX_STATIC_APP2 9
#define SQLITE_MUTEX_STATIC_APP3 10
#define SQLITE_MUTEX_STATIC_VFS1 11
#define SQLITE_MUTEX_STATIC_VFS2 12
#define SQLITE_MUTEX_STATIC_VFS3 13
# 8365 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_mutex *sqlite3_db_mutex(sqlite3*);
# 8408 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_file_control(sqlite3*, const char *zDbName, int op, void*);
# 8427 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_test_control(int op, ...);
# 8440 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_TESTCTRL_FIRST 5
#define SQLITE_TESTCTRL_PRNG_SAVE 5
#define SQLITE_TESTCTRL_PRNG_RESTORE 6
#define SQLITE_TESTCTRL_PRNG_RESET 7
#define SQLITE_TESTCTRL_BITVEC_TEST 8
#define SQLITE_TESTCTRL_FAULT_INSTALL 9
#define SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS 10
#define SQLITE_TESTCTRL_PENDING_BYTE 11
#define SQLITE_TESTCTRL_ASSERT 12
#define SQLITE_TESTCTRL_ALWAYS 13
#define SQLITE_TESTCTRL_RESERVE 14
#define SQLITE_TESTCTRL_OPTIMIZATIONS 15
#define SQLITE_TESTCTRL_ISKEYWORD 16
#define SQLITE_TESTCTRL_SCRATCHMALLOC 17
#define SQLITE_TESTCTRL_INTERNAL_FUNCTIONS 17
#define SQLITE_TESTCTRL_LOCALTIME_FAULT 18
#define SQLITE_TESTCTRL_EXPLAIN_STMT 19
#define SQLITE_TESTCTRL_ONCE_RESET_THRESHOLD 19
#define SQLITE_TESTCTRL_NEVER_CORRUPT 20
#define SQLITE_TESTCTRL_VDBE_COVERAGE 21
#define SQLITE_TESTCTRL_BYTEORDER 22
#define SQLITE_TESTCTRL_ISINIT 23
#define SQLITE_TESTCTRL_SORTER_MMAP 24
#define SQLITE_TESTCTRL_IMPOSTER 25
#define SQLITE_TESTCTRL_PARSER_COVERAGE 26
#define SQLITE_TESTCTRL_RESULT_INTREAL 27
#define SQLITE_TESTCTRL_PRNG_SEED 28
#define SQLITE_TESTCTRL_EXTRA_SCHEMA_CHECKS 29
#define SQLITE_TESTCTRL_LAST 29
# 8517 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_keyword_count(void);
 int sqlite3_keyword_name(int,const char**,int*);
 int sqlite3_keyword_check(const char*,int);
# 8537 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_str sqlite3_str;
# 8564 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_str *sqlite3_str_new(sqlite3*);
# 8579 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_str_finish(sqlite3_str*);
# 8613 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_str_appendf(sqlite3_str*, const char *zFormat, ...);
 void sqlite3_str_vappendf(sqlite3_str*, const char *zFormat, va_list);
 void sqlite3_str_append(sqlite3_str*, const char *zIn, int N);
 void sqlite3_str_appendall(sqlite3_str*, const char *zIn);
 void sqlite3_str_appendchar(sqlite3_str*, int N, char C);
 void sqlite3_str_reset(sqlite3_str*);
# 8649 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_str_errcode(sqlite3_str*);
 int sqlite3_str_length(sqlite3_str*);
 char *sqlite3_str_value(sqlite3_str*);
# 8679 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag);
 int sqlite3_status64(
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwater,
  int resetFlag
);
# 8755 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_STATUS_MEMORY_USED 0
#define SQLITE_STATUS_PAGECACHE_USED 1
#define SQLITE_STATUS_PAGECACHE_OVERFLOW 2
#define SQLITE_STATUS_SCRATCH_USED 3
#define SQLITE_STATUS_SCRATCH_OVERFLOW 4
#define SQLITE_STATUS_MALLOC_SIZE 5
#define SQLITE_STATUS_PARSER_STACK 6
#define SQLITE_STATUS_PAGECACHE_SIZE 7
#define SQLITE_STATUS_SCRATCH_SIZE 8
#define SQLITE_STATUS_MALLOC_COUNT 9
# 8789 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_db_status(sqlite3*, int op, int *pCur, int *pHiwtr, int resetFlg);
# 8902 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DBSTATUS_LOOKASIDE_USED 0
#define SQLITE_DBSTATUS_CACHE_USED 1
#define SQLITE_DBSTATUS_SCHEMA_USED 2
#define SQLITE_DBSTATUS_STMT_USED 3
#define SQLITE_DBSTATUS_LOOKASIDE_HIT 4
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE 5
#define SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL 6
#define SQLITE_DBSTATUS_CACHE_HIT 7
#define SQLITE_DBSTATUS_CACHE_MISS 8
#define SQLITE_DBSTATUS_CACHE_WRITE 9
#define SQLITE_DBSTATUS_DEFERRED_FKS 10
#define SQLITE_DBSTATUS_CACHE_USED_SHARED 11
#define SQLITE_DBSTATUS_CACHE_SPILL 12
#define SQLITE_DBSTATUS_MAX 12
# 8942 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_stmt_status(sqlite3_stmt*, int op,int resetFlg);
# 8999 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_STMTSTATUS_FULLSCAN_STEP 1
#define SQLITE_STMTSTATUS_SORT 2
#define SQLITE_STMTSTATUS_AUTOINDEX 3
#define SQLITE_STMTSTATUS_VM_STEP 4
#define SQLITE_STMTSTATUS_REPREPARE 5
#define SQLITE_STMTSTATUS_RUN 6
#define SQLITE_STMTSTATUS_MEMUSED 99
# 9018 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_pcache sqlite3_pcache;
# 9030 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_pcache_page sqlite3_pcache_page;
struct sqlite3_pcache_page {
  void *pBuf;
  void *pExtra;
};
# 9195 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_pcache_methods2 sqlite3_pcache_methods2;
struct sqlite3_pcache_methods2 {
  int iVersion;
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int szExtra, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  sqlite3_pcache_page *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, sqlite3_pcache_page*, int discard);
  void (*xRekey)(sqlite3_pcache*, sqlite3_pcache_page*,
      unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
  void (*xShrink)(sqlite3_pcache*);
};






typedef struct sqlite3_pcache_methods sqlite3_pcache_methods;
struct sqlite3_pcache_methods {
  void *pArg;
  int (*xInit)(void*);
  void (*xShutdown)(void*);
  sqlite3_pcache *(*xCreate)(int szPage, int bPurgeable);
  void (*xCachesize)(sqlite3_pcache*, int nCachesize);
  int (*xPagecount)(sqlite3_pcache*);
  void *(*xFetch)(sqlite3_pcache*, unsigned key, int createFlag);
  void (*xUnpin)(sqlite3_pcache*, void*, int discard);
  void (*xRekey)(sqlite3_pcache*, void*, unsigned oldKey, unsigned newKey);
  void (*xTruncate)(sqlite3_pcache*, unsigned iLimit);
  void (*xDestroy)(sqlite3_pcache*);
};
# 9244 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_backup sqlite3_backup;
# 9432 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_backup *sqlite3_backup_init(
  sqlite3 *pDest,
  const char *zDestName,
  sqlite3 *pSource,
  const char *zSourceName
);
 int sqlite3_backup_step(sqlite3_backup *p, int nPage);
 int sqlite3_backup_finish(sqlite3_backup *p);
 int sqlite3_backup_remaining(sqlite3_backup *p);
 int sqlite3_backup_pagecount(sqlite3_backup *p);
# 9558 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_unlock_notify(
  sqlite3 *pBlocked,
  void (*xNotify)(void **apArg, int nArg),
  void *pNotifyArg
);
# 9573 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_stricmp(const char *, const char *);
 int sqlite3_strnicmp(const char *, const char *, int);
# 9591 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_strglob(const char *zGlob, const char *zStr);
# 9614 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_strlike(const char *zGlob, const char *zStr, unsigned int cEsc);
# 9637 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_log(int iErrCode, const char *zFormat, ...);
# 9673 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_wal_hook(
  sqlite3*,
  int(*)(void *,sqlite3*,const char*,int),
  void*
);
# 9708 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_wal_autocheckpoint(sqlite3 *db, int N);
# 9730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb);
# 9824 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
);
# 9841 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_CHECKPOINT_PASSIVE 0
#define SQLITE_CHECKPOINT_FULL 1
#define SQLITE_CHECKPOINT_RESTART 2
#define SQLITE_CHECKPOINT_TRUNCATE 3
# 9860 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_vtab_config(sqlite3*, int op, ...);
# 9902 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_VTAB_CONSTRAINT_SUPPORT 1
# 9914 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_vtab_on_conflict(sqlite3 *);
# 9933 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_vtab_nochange(sqlite3_context*);
# 9948 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_vtab_collation(sqlite3_index_info*,int);
# 9962 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_ROLLBACK 1

#define SQLITE_FAIL 3

#define SQLITE_REPLACE 5
# 10015 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SCANSTAT_NLOOP 0
#define SQLITE_SCANSTAT_NVISIT 1
#define SQLITE_SCANSTAT_EST 2
#define SQLITE_SCANSTAT_NAME 3
#define SQLITE_SCANSTAT_EXPLAIN 4
#define SQLITE_SCANSTAT_SELECTID 5
# 10053 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_stmt_scanstatus(
  sqlite3_stmt *pStmt,
  int idx,
  int iScanStatusOp,
  void *pOut
);
# 10069 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_stmt_scanstatus_reset(sqlite3_stmt*);
# 10101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_db_cacheflush(sqlite3*);
# 10215 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_system_errno(sqlite3*);
# 10237 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3_snapshot {
  unsigned char hidden[48];
} sqlite3_snapshot;
# 10284 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_snapshot_get(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot **ppSnapshot
);
# 10333 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_snapshot_open(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_snapshot *pSnapshot
);
# 10350 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_snapshot_free(sqlite3_snapshot*);
# 10377 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_snapshot_cmp(
  sqlite3_snapshot *p1,
  sqlite3_snapshot *p2
);
# 10405 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_snapshot_recover(sqlite3 *db, const char *zDb);
# 10443 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 unsigned char *sqlite3_serialize(
  sqlite3 *db,
  const char *zSchema,
  sqlite3_int64 *piSize,
  unsigned int mFlags
);
# 10464 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SERIALIZE_NOCOPY 0x001
# 10495 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_deserialize(
  sqlite3 *db,
  const char *zSchema,
  unsigned char *pData,
  sqlite3_int64 szDb,
  sqlite3_int64 szBuf,
  unsigned mFlags
);
# 10525 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DESERIALIZE_FREEONCLOSE 1
#define SQLITE_DESERIALIZE_RESIZEABLE 2
#define SQLITE_DESERIALIZE_READONLY 4
# 10557 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define _SQLITE3RTREE_H_ 






typedef struct sqlite3_rtree_geometry sqlite3_rtree_geometry;
typedef struct sqlite3_rtree_query_info sqlite3_rtree_query_info;







  typedef double sqlite3_rtree_dbl;
# 10582 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_rtree_geometry_callback(
  sqlite3 *db,
  const char *zGeom,
  int (*xGeom)(sqlite3_rtree_geometry*, int, sqlite3_rtree_dbl*,int*),
  void *pContext
);






struct sqlite3_rtree_geometry {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void *);
};







 int sqlite3_rtree_query_callback(
  sqlite3 *db,
  const char *zQueryFunc,
  int (*xQueryFunc)(sqlite3_rtree_query_info*),
  void *pContext,
  void (*xDestructor)(void*)
);
# 10626 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_rtree_query_info {
  void *pContext;
  int nParam;
  sqlite3_rtree_dbl *aParam;
  void *pUser;
  void (*xDelUser)(void*);
  sqlite3_rtree_dbl *aCoord;
  unsigned int *anQueue;
  int nCoord;
  int iLevel;
  int mxLevel;
  sqlite3_int64 iRowid;
  sqlite3_rtree_dbl rParentScore;
  int eParentWithin;
  int eWithin;
  sqlite3_rtree_dbl rScore;

  sqlite3_value **apSqlParam;
};




#define NOT_WITHIN 0
#define PARTLY_WITHIN 1
#define FULLY_WITHIN 2
# 12345 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define _FTS5_H 
# 12359 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct Fts5ExtensionApi Fts5ExtensionApi;
typedef struct Fts5Context Fts5Context;
typedef struct Fts5PhraseIter Fts5PhraseIter;

typedef void (*fts5_extension_function)(
  const Fts5ExtensionApi *pApi,
  Fts5Context *pFts,
  sqlite3_context *pCtx,
  int nVal,
  sqlite3_value **apVal
);

struct Fts5PhraseIter {
  const unsigned char *a;
  const unsigned char *b;
};
# 12587 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Fts5ExtensionApi {
  int iVersion;

  void *(*xUserData)(Fts5Context*);

  int (*xColumnCount)(Fts5Context*);
  int (*xRowCount)(Fts5Context*, sqlite3_int64 *pnRow);
  int (*xColumnTotalSize)(Fts5Context*, int iCol, sqlite3_int64 *pnToken);

  int (*xTokenize)(Fts5Context*,
    const char *pText, int nText,
    void *pCtx,
    int (*xToken)(void*, int, const char*, int, int, int)
  );

  int (*xPhraseCount)(Fts5Context*);
  int (*xPhraseSize)(Fts5Context*, int iPhrase);

  int (*xInstCount)(Fts5Context*, int *pnInst);
  int (*xInst)(Fts5Context*, int iIdx, int *piPhrase, int *piCol, int *piOff);

  sqlite3_int64 (*xRowid)(Fts5Context*);
  int (*xColumnText)(Fts5Context*, int iCol, const char **pz, int *pn);
  int (*xColumnSize)(Fts5Context*, int iCol, int *pnToken);

  int (*xQueryPhrase)(Fts5Context*, int iPhrase, void *pUserData,
    int(*)(const Fts5ExtensionApi*,Fts5Context*,void*)
  );
  int (*xSetAuxdata)(Fts5Context*, void *pAux, void(*xDelete)(void*));
  void *(*xGetAuxdata)(Fts5Context*, int bClear);

  int (*xPhraseFirst)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*, int*);
  void (*xPhraseNext)(Fts5Context*, Fts5PhraseIter*, int *piCol, int *piOff);

  int (*xPhraseFirstColumn)(Fts5Context*, int iPhrase, Fts5PhraseIter*, int*);
  void (*xPhraseNextColumn)(Fts5Context*, Fts5PhraseIter*, int *piCol);
};
# 12821 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct Fts5Tokenizer Fts5Tokenizer;
typedef struct fts5_tokenizer fts5_tokenizer;
struct fts5_tokenizer {
  int (*xCreate)(void*, const char **azArg, int nArg, Fts5Tokenizer **ppOut);
  void (*xDelete)(Fts5Tokenizer*);
  int (*xTokenize)(Fts5Tokenizer*,
      void *pCtx,
      int flags,
      const char *pText, int nText,
      int (*xToken)(
        void *pCtx,
        int tflags,
        const char *pToken,
        int nToken,
        int iStart,
        int iEnd
      )
  );
};


#define FTS5_TOKENIZE_QUERY 0x0001
#define FTS5_TOKENIZE_PREFIX 0x0002
#define FTS5_TOKENIZE_DOCUMENT 0x0004
#define FTS5_TOKENIZE_AUX 0x0008



#define FTS5_TOKEN_COLOCATED 0x0001
# 12858 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct fts5_api fts5_api;
struct fts5_api {
  int iVersion;


  int (*xCreateTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_tokenizer *pTokenizer,
    void (*xDestroy)(void*)
  );


  int (*xFindTokenizer)(
    fts5_api *pApi,
    const char *zName,
    void **ppContext,
    fts5_tokenizer *pTokenizer
  );


  int (*xCreateFunction)(
    fts5_api *pApi,
    const char *zName,
    void *pContext,
    fts5_extension_function xFunction,
    void (*xDestroy)(void*)
  );
};
# 12938 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_LENGTH 1000000000
# 12959 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_COLUMN 2000
# 12970 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_SQL_LENGTH 1000000000
# 12984 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_EXPR_DEPTH 1000
# 12996 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_COMPOUND_SELECT 500







#define SQLITE_MAX_VDBE_OP 250000000






#define SQLITE_MAX_FUNCTION_ARG 127
# 13024 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEFAULT_CACHE_SIZE -2000







#define SQLITE_DEFAULT_WAL_AUTOCHECKPOINT 1000
# 13042 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_ATTACHED 10







#define SQLITE_MAX_VARIABLE_NUMBER 999
# 13067 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_PAGE_SIZE 65536






#define SQLITE_DEFAULT_PAGE_SIZE 4096
# 13089 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192
# 13105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_PAGE_COUNT 1073741823







#define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000
# 13124 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_TRIGGER_DEPTH 1000
# 13169 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_INT_TO_PTR(X) ((void*)(__PTRDIFF_TYPE__)(X))
#define SQLITE_PTR_TO_INT(X) ((int)(__PTRDIFF_TYPE__)(X))
# 13184 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_NOINLINE __attribute__((noinline))
# 13230 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_THREADSAFE 1
# 13239 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_POWERSAFE_OVERWRITE 1
# 13248 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEFAULT_MEMSTATUS 1
# 13281 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SYSTEM_MALLOC 1







#define SQLITE_MALLOC_SOFT_LIMIT 1024
# 13314 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define NDEBUG 1
# 13345 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define testcase(X) 
# 13356 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TESTONLY(X) 
# 13370 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define VVA_ONLY(X) 
# 13395 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ALWAYS(X) (X)
#define NEVER(X) (X)
# 13410 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OK_IF_ALWAYS_TRUE(X) (X)
#define OK_IF_ALWAYS_FALSE(X) (X)
# 13426 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ONLY_IF_REALLOC_STRESS(X) (0)
# 13438 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OSTRACE(X) 
#undef SQLITE_HAVE_OS_TRACE
# 13452 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#undef SQLITE_NEED_ERR_NAME
# 13467 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IS_BIG_INT(X) (((X)&~(i64)0xffffffff)!=0)
# 13476 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define likely(X) (X)
#define unlikely(X) (X)
# 13496 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_HASH_H 


typedef struct Hash Hash;
typedef struct HashElem HashElem;
# 13523 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Hash {
  unsigned int htsize;
  unsigned int count;
  HashElem *first;
  struct _ht {
    unsigned int count;
    HashElem *chain;
  } *ht;
};







struct HashElem {
  HashElem *next, *prev;
  void *data;
  const char *pKey;
};




static void sqlite3HashInit(Hash*);
static void *sqlite3HashInsert(Hash*, const char *pKey, void *pData);
static void *sqlite3HashFind(const Hash*, const char *pKey);
static void sqlite3HashClear(Hash*);
# 13565 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqliteHashFirst(H) ((H)->first)
#define sqliteHashNext(E) ((E)->next)
#define sqliteHashData(E) ((E)->data)
# 13582 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TK_SEMI 1
#define TK_EXPLAIN 2
#define TK_QUERY 3
#define TK_PLAN 4
#define TK_BEGIN 5
#define TK_TRANSACTION 6
#define TK_DEFERRED 7
#define TK_IMMEDIATE 8
#define TK_EXCLUSIVE 9
#define TK_COMMIT 10
#define TK_END 11
#define TK_ROLLBACK 12
#define TK_SAVEPOINT 13
#define TK_RELEASE 14
#define TK_TO 15
#define TK_TABLE 16
#define TK_CREATE 17
#define TK_IF 18
#define TK_NOT 19
#define TK_EXISTS 20
#define TK_TEMP 21
#define TK_LP 22
#define TK_RP 23
#define TK_AS 24
#define TK_WITHOUT 25
#define TK_COMMA 26
#define TK_ABORT 27
#define TK_ACTION 28
#define TK_AFTER 29
#define TK_ANALYZE 30
#define TK_ASC 31
#define TK_ATTACH 32
#define TK_BEFORE 33
#define TK_BY 34
#define TK_CASCADE 35
#define TK_CAST 36
#define TK_CONFLICT 37
#define TK_DATABASE 38
#define TK_DESC 39
#define TK_DETACH 40
#define TK_EACH 41
#define TK_FAIL 42
#define TK_OR 43
#define TK_AND 44
#define TK_IS 45
#define TK_MATCH 46
#define TK_LIKE_KW 47
#define TK_BETWEEN 48
#define TK_IN 49
#define TK_ISNULL 50
#define TK_NOTNULL 51
#define TK_NE 52
#define TK_EQ 53
#define TK_GT 54
#define TK_LE 55
#define TK_LT 56
#define TK_GE 57
#define TK_ESCAPE 58
#define TK_ID 59
#define TK_COLUMNKW 60
#define TK_DO 61
#define TK_FOR 62
#define TK_IGNORE 63
#define TK_INITIALLY 64
#define TK_INSTEAD 65
#define TK_NO 66
#define TK_KEY 67
#define TK_OF 68
#define TK_OFFSET 69
#define TK_PRAGMA 70
#define TK_RAISE 71
#define TK_RECURSIVE 72
#define TK_REPLACE 73
#define TK_RESTRICT 74
#define TK_ROW 75
#define TK_ROWS 76
#define TK_TRIGGER 77
#define TK_VACUUM 78
#define TK_VIEW 79
#define TK_VIRTUAL 80
#define TK_WITH 81
#define TK_NULLS 82
#define TK_FIRST 83
#define TK_LAST 84
#define TK_CURRENT 85
#define TK_FOLLOWING 86
#define TK_PARTITION 87
#define TK_PRECEDING 88
#define TK_RANGE 89
#define TK_UNBOUNDED 90
#define TK_EXCLUDE 91
#define TK_GROUPS 92
#define TK_OTHERS 93
#define TK_TIES 94
#define TK_REINDEX 95
#define TK_RENAME 96
#define TK_CTIME_KW 97
#define TK_ANY 98
#define TK_BITAND 99
#define TK_BITOR 100
#define TK_LSHIFT 101
#define TK_RSHIFT 102
#define TK_PLUS 103
#define TK_MINUS 104
#define TK_STAR 105
#define TK_SLASH 106
#define TK_REM 107
#define TK_CONCAT 108
#define TK_COLLATE 109
#define TK_BITNOT 110
#define TK_ON 111
#define TK_INDEXED 112
#define TK_STRING 113
#define TK_JOIN_KW 114
#define TK_CONSTRAINT 115
#define TK_DEFAULT 116
#define TK_NULL 117
#define TK_PRIMARY 118
#define TK_UNIQUE 119
#define TK_CHECK 120
#define TK_REFERENCES 121
#define TK_AUTOINCR 122
#define TK_INSERT 123
#define TK_DELETE 124
#define TK_UPDATE 125
#define TK_SET 126
#define TK_DEFERRABLE 127
#define TK_FOREIGN 128
#define TK_DROP 129
#define TK_UNION 130
#define TK_ALL 131
#define TK_EXCEPT 132
#define TK_INTERSECT 133
#define TK_SELECT 134
#define TK_VALUES 135
#define TK_DISTINCT 136
#define TK_DOT 137
#define TK_FROM 138
#define TK_JOIN 139
#define TK_USING 140
#define TK_ORDER 141
#define TK_GROUP 142
#define TK_HAVING 143
#define TK_LIMIT 144
#define TK_WHERE 145
#define TK_INTO 146
#define TK_NOTHING 147
#define TK_FLOAT 148
#define TK_BLOB 149
#define TK_INTEGER 150
#define TK_VARIABLE 151
#define TK_CASE 152
#define TK_WHEN 153
#define TK_THEN 154
#define TK_ELSE 155
#define TK_INDEX 156
#define TK_ALTER 157
#define TK_ADD 158
#define TK_WINDOW 159
#define TK_OVER 160
#define TK_FILTER 161
#define TK_COLUMN 162
#define TK_AGG_FUNCTION 163
#define TK_AGG_COLUMN 164
#define TK_TRUEFALSE 165
#define TK_ISNOT 166
#define TK_FUNCTION 167
#define TK_UMINUS 168
#define TK_UPLUS 169
#define TK_TRUTH 170
#define TK_REGISTER 171
#define TK_VECTOR 172
#define TK_SELECT_COLUMN 173
#define TK_IF_NULL_ROW 174
#define TK_ASTERISK 175
#define TK_SPAN 176
#define TK_SPACE 177
#define TK_ILLEGAL 178



# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h" 1







       
#define _INC_STDIO 

# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h" 1







       

# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h" 1
# 22 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define _UCRT 
# 43 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define _VCRUNTIME_H 


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vadefs.h" 1
# 47 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h" 2
# 73 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define _CRT_BEGIN_C_HEADER __pragma(pack(push, _CRT_PACKING))


#define _CRT_END_C_HEADER __pragma(pack(pop))




__pragma(pack(push, _CRT_PACKING))




#define _HAS_EXCEPTIONS 1




#define _CRT_STRINGIZE_(x) #x
#define _CRT_STRINGIZE(x) _CRT_STRINGIZE_(x)

#define _CRT_WIDE_(s) L ## s
#define _CRT_WIDE(s) _CRT_WIDE_(s)

#define _CRT_CONCATENATE_(a,b) a ## b
#define _CRT_CONCATENATE(a,b) _CRT_CONCATENATE_(a, b)

#define _CRT_UNPARENTHESIZE_(...) __VA_ARGS__
#define _CRT_UNPARENTHESIZE(...) _CRT_UNPARENTHESIZE_ __VA_ARGS__





#define _VCRTIMP _CRTIMP
# 138 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define _VCRTIMP_PURE _VCRTIMP







#define __CLRCALL_OR_CDECL __cdecl
#define __CLR_OR_THIS_CALL 





#define __CLRCALL_PURE_OR_CDECL __cdecl


#define __CRTDECL __CLRCALL_PURE_OR_CDECL


#define _VCRT_NOALIAS __declspec(noalias)
#define _VCRT_RESTRICT __declspec(restrict)




#define _VCRT_ALLOCATOR 





#define _VCRT_JIT_INTRINSIC 





#define _VCRT_ALIGN(x) __declspec(align(x))
# 190 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define _WConst_return _CONST_RETURN







    typedef unsigned int size_t;
    typedef int ptrdiff_t;
    typedef int intptr_t;
# 226 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define NULL ((void *)0)






#define _UNALIGNED 
# 245 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define __crt_countof(_Array) (sizeof(_Array) / sizeof(_Array[0]))



#define _CRT_DEPRECATE_TEXT(_Text) __declspec(deprecated(_Text))
# 282 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h"
#define _CRT_WARNING(description) message("" __FILE__ "(" _CRT_STRINGIZE(__LINE__) ") : warning CRT0000 : " _CRT_STRINGIZE(description))





    void __security_init_cookie(void);





        void __security_check_cookie( uintptr_t _StackCookie);
        __declspec(noreturn) void __report_gsfailure( uintptr_t _StackCookie);



extern uintptr_t __security_cookie;


#define __vcrt_malloc_normal(_Size) malloc(_Size)
#define __vcrt_calloc_normal(_Count,_Size) calloc(_Count, _Size)
#define __vcrt_free_normal(_Memory) free(_Memory)


__pragma(pack(pop))
# 11 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h" 2

__pragma(pack(push, _CRT_PACKING))
# 23 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _ACRTIMP _CRTIMP
# 34 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _ACRTIMP_ALT _ACRTIMP




#define _DCRTIMP _CRTIMP
# 50 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _CRTRESTRICT __declspec(restrict)





#define _CRTALLOCATOR 







#define _CRT_JIT_INTRINSIC 






#define _CRT_GUARDOVERFLOW 





#define _CRT_HYBRIDPATCHABLE 
# 89 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _WConst_return _CONST_RETURN
# 102 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _Check_return_opt_ 





#define _Check_return_wat_ 





#define __crt_typefix(ctype) 
# 145 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
    typedef _Bool __crt_bool;


#define _ARGMAX 100
#define _TRUNCATE ((size_t)-1)
#define _CRT_INT_MAX 2147483647
#define _CRT_SIZE_MAX ((size_t)-1)

#define __FILEW__ _CRT_WIDE(__FILE__)
#define __FUNCTIONW__ _CRT_WIDE(__FUNCTION__)


#define _STATIC_ASSERT(expr) typedef char __static_assert_t[(expr) != 0]
# 181 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _CRT_FUNCTIONS_REQUIRED 1
# 213 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _CRT_USE_WINAPI_FAMILY_DESKTOP_APP 




#define _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE 0




#define _CRT_BUILD_DESKTOP_APP 1
# 253 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
 void _invalid_parameter_noinfo(void);
 __declspec(noreturn) void _invalid_parameter_noinfo_noreturn(void);

__declspec(noreturn)
 void _invoke_watson(
    wchar_t const* _Expression,
    wchar_t const* _FunctionName,
    wchar_t const* _FileName,
    unsigned int _LineNo,
    uintptr_t _Reserved);
# 280 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _CRT_SECURE_INVALID_PARAMETER(expr) ::_invalid_parameter_noinfo_noreturn()
# 292 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _CRT_INTERNAL_NONSTDC_NAMES ( ( defined _CRT_DECLARE_NONSTDC_NAMES && _CRT_DECLARE_NONSTDC_NAMES) || (!defined _CRT_DECLARE_NONSTDC_NAMES && !__STDC__ ) )
# 373 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define __STDC_SECURE_LIB__ 200411L
#define __GOT_SECURE_LIB__ __STDC_SECURE_LIB__
# 406 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _SECURECRT_FILL_BUFFER_PATTERN 0xFE
# 455 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY 0







#define _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY 0
# 472 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define _CRT_SECURE_CPP_NOTHROW throw()
# 482 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
typedef int errno_t;
typedef unsigned short wint_t;
typedef unsigned short wctype_t;
typedef long __time32_t;
typedef __int64 __time64_t;

typedef struct __crt_locale_data_public
{
      unsigned short const* _locale_pctype;
    int _locale_mb_cur_max;
               unsigned int _locale_lc_codepage;
} __crt_locale_data_public;

typedef struct __crt_locale_pointers
{
    struct __crt_locale_data* locinfo;
    struct __crt_multibyte_data* mbcinfo;
} __crt_locale_pointers;

typedef __crt_locale_pointers* _locale_t;

typedef struct _Mbstatet
{
    unsigned long _Wchar;
    unsigned short _Byte, _State;
} _Mbstatet;

typedef _Mbstatet mbstate_t;
# 521 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
        typedef __time32_t time_t;
# 533 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
    typedef size_t rsize_t;
# 697 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_0(_ReturnType,_FuncName,_DstType,_Dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_3(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_4(_ReturnType,_FuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_1(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_2(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_1_3(_ReturnType,_FuncName,_HType1,_HArg1,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_2_0(_ReturnType,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_DstType,_Dst) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_1_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_0_2_ARGLIST(_ReturnType,_FuncName,_VFuncName,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 
#define __DEFINE_CPP_OVERLOAD_SECURE_FUNC_SPLITPATH(_ReturnType,_FuncName,_DstType,_Src) 






#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _CC, _FuncName, _VFuncName, _VFuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)




#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3, _TType4, _TArg4)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType, _ReturnPolicy, _DeclSpec, _FuncName, _FuncName ##_s, _HType1, _HArg1, _HType2, _HArg2, _SalAttributeDst, _DstType, _Dst)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType, _ReturnPolicy, _DeclSpec, __cdecl, _FuncName, _FuncName ##_s, _VFuncName, _VFuncName ##_s, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2)


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE(_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec, _FuncName, _FuncName ##_s, _DstType, _SalAttributeDst, _DstType, _Dst, _TType1, _TArg1, _TType2, _TArg2, _TType3, _TArg3)
# 1788 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
#define __RETURN_POLICY_SAME(_FunctionCall) 
#define __RETURN_POLICY_DST(_FunctionCall) 
#define __RETURN_POLICY_VOID(_FunctionCall) 
#define __EMPTY_DECLSPEC 



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_0_CGETS(_ReturnType,_DeclSpec,_FuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SecureVFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_FUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_0_GETS(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_4_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3,_TType4,_TArg4) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3, _TType4 _TArg4);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_1_1_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _SalAttributeDst _DstType *_Dst, _TType1 _TArg1);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_2_0_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_SecureFuncName,_HType1,_HArg1,_HType2,_HArg2,_SalAttributeDst,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType __cdecl _FuncName(_HType1 _HArg1, _HType2 _HArg2, _SalAttributeDst _DstType *_Dst);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_1_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_SecureFuncName,_VFuncName,_SecureVFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, ...); _CRT_INSECURE_DEPRECATE(_SecureVFuncName) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST(_ReturnType,_ReturnPolicy,_DeclSpec,_FuncName,_VFuncName,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType __cdecl _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_ARGLIST_EX(_ReturnType,_ReturnPolicy,_DeclSpec,_CC,_FuncName,_VFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_FuncName ##_s) _DeclSpec _ReturnType _CC _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, ...); _CRT_INSECURE_DEPRECATE(_VFuncName ##_s) _DeclSpec _ReturnType _CC _VFuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, va_list _Args);



#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_2_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2);


#define __DEFINE_CPP_OVERLOAD_STANDARD_NFUNC_0_3_SIZE_EX(_DeclSpec,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) _DeclSpec size_t __cdecl _FuncName(_SalAttributeDst _DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3);



#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 

#define __DECLARE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)




#define __DEFINE_CPP_OVERLOAD_INLINE_FUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_0_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_1_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_2_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2) 

#define __DECLARE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) _CRT_INSECURE_DEPRECATE(_SecureFuncName) __inline _ReturnType __CRTDECL _FuncName(_DstType *_Dst, _TType1 _TArg1, _TType2 _TArg2, _TType3 _TArg3)




#define __DEFINE_CPP_OVERLOAD_INLINE_NFUNC_0_3_EX(_ReturnType,_ReturnPolicy,_FuncName,_SecureFuncName,_SecureDstType,_SalAttributeDst,_DstType,_Dst,_TType1,_TArg1,_TType2,_TArg2,_TType3,_TArg3) 
# 1982 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt.h"
__pragma(pack(pop))
# 12 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h" 1
# 10 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
       


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_stdio_config.h" 1







       



__pragma(pack(push, _CRT_PACKING))
# 22 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_stdio_config.h"
#define _CRT_STDIO_INLINE __inline
# 83 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_stdio_config.h"
   
    __declspec(noinline) __inline unsigned __int64* __local_stdio_printf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }



   
    __declspec(noinline) __inline unsigned __int64* __local_stdio_scanf_options(void)
    {
        static unsigned __int64 _OptionsStorage;
        return &_OptionsStorage;
    }






#define _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS (*__local_stdio_printf_options())
#define _CRT_INTERNAL_LOCAL_SCANF_OPTIONS (*__local_stdio_scanf_options ())



#define _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION (1ULL << 0)
#define _CRT_INTERNAL_PRINTF_STANDARD_SNPRINTF_BEHAVIOR (1ULL << 1)
#define _CRT_INTERNAL_PRINTF_LEGACY_WIDE_SPECIFIERS (1ULL << 2)
#define _CRT_INTERNAL_PRINTF_LEGACY_MSVCRT_COMPATIBILITY (1ULL << 3)
#define _CRT_INTERNAL_PRINTF_LEGACY_THREE_DIGIT_EXPONENTS (1ULL << 4)


#define _CRT_INTERNAL_SCANF_SECURECRT (1ULL << 0)
#define _CRT_INTERNAL_SCANF_LEGACY_WIDE_SPECIFIERS (1ULL << 1)
#define _CRT_INTERNAL_SCANF_LEGACY_MSVCRT_COMPATIBILITY (1ULL << 2)



__pragma(pack(pop))
# 14 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h" 2

__pragma(pack(push, _CRT_PACKING))
# 24 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
#define _FILE_DEFINED 
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;


 FILE* __acrt_iob_func(unsigned _Ix);

#define stdin (__acrt_iob_func(0))
#define stdout (__acrt_iob_func(1))
#define stderr (__acrt_iob_func(2))

#define WEOF ((wint_t)(0xFFFF))
# 47 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
   
    wint_t fgetwc(
        FILE* _Stream
        );

   
    wint_t _fgetwchar(void);

   
    wint_t fputwc(
        wchar_t _Character,
        FILE* _Stream);

   
    wint_t _fputwchar(
        wchar_t _Character
        );

   
    wint_t getwc(
        FILE* _Stream
        );

   
    wint_t getwchar(void);


   
   
    wchar_t* fgetws(
        wchar_t* _Buffer,
        int _BufferCount,
        FILE* _Stream
        );

   
    int fputws(
        wchar_t const* _Buffer,
        FILE* _Stream
        );

   
   
    wchar_t* _getws_s(
        wchar_t* _Buffer,
        size_t _BufferCount
        );

   





   
    wint_t putwc(
        wchar_t _Character,
        FILE* _Stream
        );

   
    wint_t putwchar(
        wchar_t _Character
        );

   
    int _putws(
        wchar_t const* _Buffer
        );

   
    wint_t ungetwc(
        wint_t _Character,
        FILE* _Stream
        );

   
    FILE * _wfdopen(
        int _FileHandle,
        wchar_t const* _Mode
        );

   
    FILE* _wfopen(
        wchar_t const* _FileName,
        wchar_t const* _Mode
        );

   
    errno_t _wfopen_s(
        FILE** _Stream,
        wchar_t const* _FileName,
        wchar_t const* _Mode
        );

   
   
    FILE* _wfreopen(
        wchar_t const* _FileName,
        wchar_t const* _Mode,
        FILE* _OldStream
        );

   
    errno_t _wfreopen_s(
        FILE** _Stream,
        wchar_t const* _FileName,
        wchar_t const* _Mode,
        FILE* _OldStream
        );

   
    FILE* _wfsopen(
        wchar_t const* _FileName,
        wchar_t const* _Mode,
        int _ShFlag
        );

    void _wperror(
        wchar_t const* _ErrorMessage
        );



       
        FILE* _wpopen(
            wchar_t const* _Command,
            wchar_t const* _Mode
            );



    int _wremove(
        wchar_t const* _FileName
        );

           
#undef _wtempnam

   
    wchar_t* _wtempnam(
        wchar_t const* _Directory,
        wchar_t const* _FilePrefix
        );

           

   
   
    errno_t _wtmpnam_s(
        wchar_t* _Buffer,
        size_t _BufferCount
        );

   





    wchar_t* _wtmpnam( wchar_t *_Buffer);
# 220 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
   
    wint_t _fgetwc_nolock(
        FILE* _Stream
        );

   
    wint_t _fputwc_nolock(
        wchar_t _Character,
        FILE* _Stream
        );

   
    wint_t _getwc_nolock(
        FILE* _Stream
        );

   
    wint_t _putwc_nolock(
        wchar_t _Character,
        FILE* _Stream
        );

   
    wint_t _ungetwc_nolock(
        wint_t _Character,
        FILE* _Stream
        );
# 268 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
   
    int __stdio_common_vfwprintf(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    int __stdio_common_vfwprintf_s(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    int __stdio_common_vfwprintf_p(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    __inline int _vfwprintf_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }


   
    __inline int vfwprintf(
        FILE* const _Stream,
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_l(_Stream, _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vfwprintf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }




       
        __inline int vfwprintf_s(
            FILE* const _Stream,
            wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }




   
    __inline int _vfwprintf_p_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }


   
    __inline int _vfwprintf_p(
        FILE* const _Stream,
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }


   
    __inline int vwprintf(
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vwprintf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }




       
        __inline int vwprintf_s(
            wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        }




   
    __inline int _vwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }


   
    __inline int _vwprintf_p(
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }


   
    __inline int _fwprintf_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int fwprintf(
        FILE* const _Stream,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l(_Stream, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _fwprintf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int fwprintf_s(
            FILE* const _Stream,
            wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   
    __inline int _fwprintf_p_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _fwprintf_p(
        FILE* const _Stream,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _wprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int wprintf(
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _wprintf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int wprintf_s(
            wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   
    __inline int _wprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _wprintf_p(
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
# 701 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
   
    int __stdio_common_vfwscanf(
        unsigned __int64 _Options,
        FILE* _Stream,
        wchar_t const* _Format,
        _locale_t _Locale,
                                               va_list _ArgList
        );

   
    __inline int _vfwscanf_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }


   
    __inline int vfwscanf(
        FILE* const _Stream,
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l(_Stream, _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vfwscanf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfwscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }




       
        __inline int vfwscanf_s(
            FILE* const _Stream,
            wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }




    __inline int _vwscanf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }


   
    __inline int vwscanf(
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vwscanf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }




       
        __inline int vwscanf_s(
            wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        }




   
    __inline int _fwscanf_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int fwscanf(
        FILE* const _Stream,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l(_Stream, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _fwscanf_s_l(
        FILE* const _Stream,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int fwscanf_s(
            FILE* const _Stream,
            wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   
    __inline int _wscanf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int wscanf(
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _wscanf_s_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int wscanf_s(
            wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
# 993 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
#define _SWPRINTFS_DEPRECATED _CRT_DEPRECATE_TEXT( "function has been changed to conform with the ISO C standard, " "adding an extra character count parameter. To use the traditional " "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")







   
   
    int __stdio_common_vswprintf(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
   
    int __stdio_common_vswprintf_s(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
   
    int __stdio_common_vsnwprintf_s(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        size_t _MaxCount,
        wchar_t const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
   
    int __stdio_common_vswprintf_p(
        unsigned __int64 _Options,
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
   
    __inline int _vsnwprintf_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                     va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


#pragma warning(push)
#pragma warning(disable: 4793)

   
   
    __inline int _vsnwprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsnwprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vsnwprintf_s(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
    }


    __inline int _snwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, ...); __inline int _vsnwprintf( wchar_t *_Buffer, size_t _BufferCount, wchar_t const* _Format, va_list _Args);
# 1118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
#pragma warning(pop)

   
   
    __inline int _vsnwprintf(
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
                                                     va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)
    }


   
# 1148 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
   
   
    __inline int _vswprintf_c_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vswprintf_c(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }


   
   
    __inline int _vswprintf_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)
    }


   
   
    __inline int __vswprintf_l(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }


   
   
    __inline int _vswprintf(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
                                         va_list _ArgList
        )



    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, ((void *)0), _ArgList);
    }


   
   
    __inline int vswprintf(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }


   
   
    __inline int _vswprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




       
        __inline int vswprintf_s(
            wchar_t* const _Buffer,
            size_t const _BufferCount,
            wchar_t const* const _Format,
                                                          va_list _ArgList
            )



        {
            return _vswprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        }




   







   
   
    __inline int _vswprintf_p_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vswprintf_p(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
                                                      va_list _ArgList
        )



    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }


   
   
    __inline int _vscwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vscwprintf(
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscwprintf_l(_Format, ((void *)0), _ArgList);
    }


   
   
    __inline int _vscwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vswprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vscwprintf_p(
        wchar_t const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscwprintf_p_l(_Format, ((void *)0), _ArgList);
    }


   
   
    __inline int __swprintf_l(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _swprintf_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _swprintf(
        wchar_t* const _Buffer,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = __vswprintf_l(_Buffer, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int swprintf(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


#pragma warning(push)


#pragma warning(disable:4793 4996)

    __inline int __swprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, ...); __inline int __vswprintf_l( wchar_t *_Buffer, wchar_t const* _Format, _locale_t _Locale, va_list _Args);
# 1497 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
    __inline int _swprintf( wchar_t *_Buffer, wchar_t const* _Format, ...); __inline int _vswprintf( wchar_t *_Buffer, wchar_t const* _Format, va_list _Args);






#pragma warning(pop)

   
   
    __inline int _swprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int swprintf_s(
            wchar_t* const _Buffer,
            size_t const _BufferCount,
            wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   






   
   
    __inline int _swprintf_p_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _swprintf_p(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _swprintf_c_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _swprintf_c(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snwprintf_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snwprintf(
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snwprintf_s_l(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snwprintf_s(
        wchar_t* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   







   
    __inline int _scwprintf_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _scwprintf(
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscwprintf_l(_Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _scwprintf_p_l(
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _scwprintf_p(
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscwprintf_p_l(_Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




#pragma warning(push)
#pragma warning(disable: 4141 4412 4793 4996 6054)
# 1875 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
#pragma warning(pop)
# 1891 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
   
    int __stdio_common_vswscanf(
        unsigned __int64 _Options,
        wchar_t const* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Format,
        _locale_t _Locale,
                                               va_list _ArgList
        );

   
   
    __inline int _vswscanf_l(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }


   
   
    __inline int vswscanf(
        wchar_t const* _Buffer,
        wchar_t const* _Format,
                                      va_list _ArgList
        )



    {
        return _vswscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
    }


   
   
    __inline int _vswscanf_s_l(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




       
       
        __inline int vswscanf_s(
            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vswscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
        }




   







   
   
    __inline int _vsnwscanf_l(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                               va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }


   
   
    __inline int _vsnwscanf_s_l(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
                                                 va_list _ArgList
        )



    {
        return __stdio_common_vswscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }


   
   
    __inline int _swscanf_l(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int swscanf(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vswscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _swscanf_s_l(
        wchar_t const* const _Buffer,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
       
        __inline int swscanf_s(
            wchar_t const* const _Buffer,
            wchar_t const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vswscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   
   
    __inline int _snwscanf_l(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snwscanf(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snwscanf_s_l(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snwscanf_s(
        wchar_t const* const _Buffer,
        size_t const _BufferCount,
        wchar_t const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
# 2198 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdio.h"
__pragma(pack(pop))
# 13 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h" 2

__pragma(pack(push, _CRT_PACKING))



#define BUFSIZ 512







#define _NFILE _NSTREAM_

#define _NSTREAM_ 512





#define _IOB_ENTRIES 3

#define EOF (-1)

#define _IOFBF 0x0000
#define _IOLBF 0x0040
#define _IONBF 0x0004



#define L_tmpnam 260

#define L_tmpnam_s L_tmpnam






#define SEEK_CUR 1
#define SEEK_END 2
#define SEEK_SET 0


#define FILENAME_MAX 260
#define FOPEN_MAX 20
#define _SYS_OPEN 20
#define TMP_MAX _CRT_INT_MAX

#define TMP_MAX_S TMP_MAX
#define _TMP_MAX_S TMP_MAX



typedef __int64 fpos_t;





   
    errno_t _get_stream_buffer_pointers(
        FILE* _Stream,
        char*** _Base,
        char*** _Pointer,
        int** _Count
        );
# 90 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
       
        errno_t clearerr_s(
            FILE* _Stream
            );

       
        errno_t fopen_s(
            FILE** _Stream,
            char const* _FileName,
            char const* _Mode
            );

       
       
        size_t fread_s(
            void* _Buffer,
            size_t _BufferSize,
            size_t _ElementSize,
            size_t _ElementCount,
            FILE* _Stream
            );

       
        errno_t freopen_s(
            FILE** _Stream,
            char const* _FileName,
            char const* _Mode,
            FILE* _OldStream
            );

       
        char* gets_s(
            char* _Buffer,
            rsize_t _Size
            );

       
        errno_t tmpfile_s(
            FILE** _Stream
            );

       
       
        errno_t tmpnam_s(
            char* _Buffer,
            rsize_t _Size
            );



    void clearerr(
        FILE* _Stream
        );

   
   
    int fclose(
        FILE* _Stream
        );

   
    int _fcloseall(void);

   
    FILE* _fdopen(
        int _FileHandle,
        char const* _Mode
        );

   
    int feof(
        FILE* _Stream
        );

   
    int ferror(
        FILE* _Stream
        );

   
    int fflush(
        FILE* _Stream
        );

   
   
    int fgetc(
        FILE* _Stream
        );

   
    int _fgetchar(void);

   
   
    int fgetpos(
        FILE* _Stream,
        fpos_t* _Position
        );

   
   
    char* fgets(
        char* _Buffer,
        int _MaxCount,
        FILE* _Stream
        );

   
    int _fileno(
        FILE* _Stream
        );

   
    int _flushall(void);

   
    FILE* fopen(
        char const* _FileName,
        char const* _Mode
        );


   
   
    int fputc(
        int _Character,
        FILE* _Stream
        );

   
    int _fputchar(
        int _Character
        );

   
   
    int fputs(
        char const* _Buffer,
        FILE* _Stream
        );

   
    size_t fread(
        void* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream
        );

   
   
    FILE* freopen(
        char const* _FileName,
        char const* _Mode,
        FILE* _Stream
        );

   
    FILE* _fsopen(
        char const* _FileName,
        char const* _Mode,
        int _ShFlag
        );

   
   
    int fsetpos(
        FILE* _Stream,
        fpos_t const* _Position
        );

   
   
    int fseek(
        FILE* _Stream,
        long _Offset,
        int _Origin
        );

   
   
    int _fseeki64(
        FILE* _Stream,
        __int64 _Offset,
        int _Origin
        );

   
   
    long ftell(
        FILE* _Stream
        );

   
   
    __int64 _ftelli64(
        FILE* _Stream
        );

   
    size_t fwrite(
        void const* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream
        );

   
   
    int getc(
        FILE* _Stream
        );

   
    int getchar(void);

   
    int _getmaxstdio(void);

   



   
    int _getw(
        FILE* _Stream
        );

    void perror(
        char const* _ErrorMessage
        );



       
       
        int _pclose(
            FILE* _Stream
            );

       
        FILE* _popen(
            char const* _Command,
            char const* _Mode
            );



   
   
    int putc(
        int _Character,
        FILE* _Stream
        );

   
    int putchar(
        int _Character
        );

   
    int puts(
        char const* _Buffer
        );

   
   
    int _putw(
        int _Word,
        FILE* _Stream
        );

    int remove(
        char const* _FileName
        );

   
    int rename(
        char const* _OldFileName,
        char const* _NewFileName
        );

    int _unlink(
        char const* _FileName
        );
# 386 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
    void rewind(
        FILE* _Stream
        );

   
    int _rmtmp(void);

   
    void setbuf(
        FILE* _Stream,
        char* _Buffer
        );

   
    int _setmaxstdio(
        int _Maximum
        );

   
   
    int setvbuf(
        FILE* _Stream,
        char* _Buffer,
        int _Mode,
        size_t _Size
        );






   
    char* _tempnam(
        char const* _DirectoryName,
        char const* _FilePrefix
        );





   
    FILE* tmpfile(void);

   





#pragma warning(push)
#pragma warning(disable: 28726)
 char* tmpnam( char *_Buffer);




#pragma warning(pop)

   
   
    int ungetc(
        int _Character,
        FILE* _Stream
        );
# 460 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
    void _lock_file(
        FILE* _Stream
        );

    void _unlock_file(
        FILE* _Stream
        );

   
   
    int _fclose_nolock(
        FILE* _Stream
        );

   
   
    int _fflush_nolock(
        FILE* _Stream
        );

   
   
    int _fgetc_nolock(
        FILE* _Stream
        );

   
   
    int _fputc_nolock(
        int _Character,
        FILE* _Stream
        );

   
    size_t _fread_nolock(
        void* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream
        );

   
   
    size_t _fread_nolock_s(
        void* _Buffer,
        size_t _BufferSize,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream
        );

   
    int _fseek_nolock(
        FILE* _Stream,
        long _Offset,
        int _Origin
        );

   
    int _fseeki64_nolock(
        FILE* _Stream,
        __int64 _Offset,
        int _Origin
        );

   
    long _ftell_nolock(
        FILE* _Stream
        );

   
    __int64 _ftelli64_nolock(
        FILE* _Stream
        );

   
    size_t _fwrite_nolock(
        void const* _Buffer,
        size_t _ElementSize,
        size_t _ElementCount,
        FILE* _Stream
        );

   
    int _getc_nolock(
        FILE* _Stream
        );

   
    int _putc_nolock(
        int _Character,
        FILE* _Stream
        );

   
    int _ungetc_nolock(
        int _Character,
        FILE* _Stream
        );

#define _getchar_nolock() _getc_nolock(stdin)
#define _putchar_nolock(_Ch) _putc_nolock(_Ch, stdout)
#define _getwchar_nolock() _getwc_nolock(stdin)
#define _putwchar_nolock(_Ch) _putwc_nolock(_Ch, stdout)
# 585 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
    int* __p__commode(void);




#define _commode (*__p__commode())
# 605 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
    int __stdio_common_vfprintf(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

    int __stdio_common_vfprintf_s(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    int __stdio_common_vfprintf_p(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    __inline int _vfprintf_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }


   
    __inline int vfprintf(
        FILE* const _Stream,
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_l(_Stream, _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vfprintf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }




       
        __inline int vfprintf_s(
            FILE* const _Stream,
            char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }




   
    __inline int _vfprintf_p_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
                 va_list _ArgList
        )



    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }


   
    __inline int _vfprintf_p(
        FILE* const _Stream,
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vprintf_l(
        char const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }


   
    __inline int vprintf(
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vprintf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }




       
        __inline int vprintf_s(
            char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        }




   
    __inline int _vprintf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }


   
    __inline int _vprintf_p(
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
    }


   
    __inline int _fprintf_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int fprintf(
        FILE* const _Stream,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_l(_Stream, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


    int _set_printf_count_output(
        int _Value
        );

    int _get_printf_count_output(void);

   
    __inline int _fprintf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int fprintf_s(
            FILE* const _Stream,
            char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfprintf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   
    __inline int _fprintf_p_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _fprintf_p(
        FILE* const _Stream,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l(_Stream, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _printf_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int printf(
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _printf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int printf_s(
            char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   
    __inline int _printf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _printf_p(
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }
# 1042 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
    int __stdio_common_vfscanf(
        unsigned __int64 _Options,
        FILE* _Stream,
        char const* _Format,
        _locale_t _Locale,
                                               va_list _Arglist
        );

   
    __inline int _vfscanf_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()),
            _Stream, _Format, _Locale, _ArgList);
    }


   
    __inline int vfscanf(
        FILE* const _Stream,
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l(_Stream, _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vfscanf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vfscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Stream, _Format, _Locale, _ArgList);
    }





       
        __inline int vfscanf_s(
            FILE* const _Stream,
            char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
        }




   
    __inline int _vscanf_l(
        char const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }


   
    __inline int vscanf(
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vscanf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }




       
        __inline int vscanf_s(
            char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vfscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        }




   
    __inline int _fscanf_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int fscanf(
        FILE* const _Stream,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfscanf_l(_Stream, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _fscanf_s_l(
        FILE* const _Stream,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int fscanf_s(
            FILE* const _Stream,
            char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfscanf_s_l(_Stream, _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   
    __inline int _scanf_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int scanf(
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _scanf_s_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int scanf_s(
            char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }
# 1334 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
   
    int __stdio_common_vsprintf(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    int __stdio_common_vsprintf_s(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    int __stdio_common_vsnprintf_s(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        size_t _MaxCount,
        char const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
    int __stdio_common_vsprintf_p(
        unsigned __int64 _Options,
        char* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
                                                va_list _ArgList
        );

   
   
    __inline int _vsnprintf_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
                                                     va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vsnprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
                                                    va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
#pragma warning(pop)
    }
# 1426 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
   
   
    __inline int vsnprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vsprintf_l(
        char* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
                                         va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
#pragma warning(pop)
    }


   
   
    __inline int vsprintf(
        char* const _Buffer,
        char const* const _Format,
                                         va_list _ArgList
        )



    {
#pragma warning(push)
#pragma warning(disable: 4996)
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, ((void *)0), _ArgList);
#pragma warning(pop)
    }


   
   
    __inline int _vsprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }




       
       
        __inline int vsprintf_s(
            char* const _Buffer,
            size_t const _BufferCount,
            char const* const _Format,
                                                          va_list _ArgList
            )



        {
            return _vsprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        }


       
# 1532 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
   
   
    __inline int _vsprintf_p_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
                                                      va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vsprintf_p(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
                                                      va_list _ArgList
        )



    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }


   
   
    __inline int _vsnprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        _locale_t const _Locale,
                                                          va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsnprintf_s(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vsnprintf_s(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
                                                          va_list _ArgList
        )



    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
    }


   
# 1619 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
       
       
        __inline int vsnprintf_s(
            char* const _Buffer,
            size_t const _BufferCount,
            size_t const _MaxCount,
            char const* const _Format,
                                                              va_list _ArgList
            )



        {
            return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        }


       
# 1647 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
   
    __inline int _vscprintf_l(
        char const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
    __inline int _vscprintf(
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscprintf_l(_Format, ((void *)0), _ArgList);
    }


   
    __inline int _vscprintf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf_p(
            (*__local_stdio_printf_options()) | (1ULL << 1),
            ((void *)0), 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
    __inline int _vscprintf_p(
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vscprintf_p_l(_Format, ((void *)0), _ArgList);
    }


   
    __inline int _vsnprintf_c_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
                                                va_list _ArgList
        )



    {
        int const _Result = __stdio_common_vsprintf(
            (*__local_stdio_printf_options()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }


   
   
    __inline int _vsnprintf_c(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
                                       va_list _ArgList
        )



    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
    }


   
   
    __inline int _sprintf_l(
        char* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
#pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int sprintf(
        char* const _Buffer,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
        _Result = _vsprintf_l(_Buffer, _Format, ((void *)0), _ArgList);
#pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }


#pragma warning(push)
#pragma warning(disable: 4996)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
    int sprintf( char *_Buffer, char const* _Format, ...); int vsprintf( char *_Buffer, char const* _Format, va_list _Args);





#pragma warning(pop)

   
   
    __inline int _sprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
       
        __inline int sprintf_s(
            char* const _Buffer,
            size_t const _BufferCount,
            char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);
            _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
            __crt_va_end(_ArgList);
            return _Result;
        }




   






   
   
    __inline int _sprintf_p_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _sprintf_p(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snprintf_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

#pragma warning(push)
#pragma warning(disable: 4996)
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

        __crt_va_end(_ArgList);
        return _Result;
    }
# 1936 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
   
   
    __inline int snprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
#pragma warning(suppress:28719)
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snprintf(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
#pragma warning(suppress:28719)
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


    int _snprintf( char *_Buffer, size_t _BufferCount, char const* _Format, ...); int _vsnprintf( char *_Buffer, size_t _BufferCount, char const* _Format, va_list _Args);
# 1987 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
   
   
    __inline int _snprintf_c_l(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snprintf_c(
        char* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snprintf_s_l(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
   
    __inline int _snprintf_s(
        char* const _Buffer,
        size_t const _BufferCount,
        size_t const _MaxCount,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   







   
    __inline int _scprintf_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _scprintf(
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscprintf_l(_Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _scprintf_p_l(
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _scprintf_p(
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vscprintf_p(_Format, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }







    int __stdio_common_vsscanf(
        unsigned __int64 _Options,
        char const* _Buffer,
        size_t _BufferCount,
        char const* _Format,
        _locale_t _Locale,
                                               va_list _ArgList
        );

   
    __inline int _vsscanf_l(
        char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }


   
    __inline int vsscanf(
        char const* const _Buffer,
        char const* const _Format,
                                      va_list _ArgList
        )



    {
        return _vsscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
    }


   
    __inline int _vsscanf_s_l(
        char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
                                      va_list _ArgList
        )



    {
        return __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }




#pragma warning(push)
#pragma warning(disable:6530)

       
        __inline int vsscanf_s(
            char const* const _Buffer,
            char const* const _Format,
                                          va_list _ArgList
            )



        {
            return _vsscanf_s_l(_Buffer, _Format, ((void *)0), _ArgList);
        }


       






#pragma warning(pop)



   
    __inline int _sscanf_l(
        char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int sscanf(
        char const* const _Buffer,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);
        _Result = _vsscanf_l(_Buffer, _Format, ((void *)0), _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _sscanf_s_l(
        char const* const _Buffer,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        __crt_va_end(_ArgList);
        return _Result;
    }




       
        __inline int sscanf_s(
            char const* const _Buffer,
            char const* const _Format,
            ...)



        {
            int _Result;
            va_list _ArgList;
            __crt_va_start(_ArgList, _Format);

#pragma warning(push)
#pragma warning(disable: 4996)
            _Result = vsscanf_s(_Buffer, _Format, _ArgList);
#pragma warning(pop)

            __crt_va_end(_ArgList);
            return _Result;
        }




#pragma warning(push)
#pragma warning(disable:6530)

   
    __inline int _snscanf_l(
        char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _snscanf(
        char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }



   
    __inline int _snscanf_s_l(
        char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        _locale_t const _Locale,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Locale);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }


   
    __inline int _snscanf_s(
        char const* const _Buffer,
        size_t const _BufferCount,
        char const* const _Format,
        ...)



    {
        int _Result;
        va_list _ArgList;
        __crt_va_start(_ArgList, _Format);

        _Result = __stdio_common_vsscanf(
            (*__local_stdio_scanf_options ()) | (1ULL << 0),
            _Buffer, _BufferCount, _Format, ((void *)0), _ArgList);

        __crt_va_end(_ArgList);
        return _Result;
    }


#pragma warning(pop)
# 2469 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdio.h"
__pragma(pack(pop))
# 13764 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h" 1







       
#define _INC_STDLIB 


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_malloc.h" 1
# 9 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_malloc.h"
       



__pragma(pack(push, _CRT_PACKING))
# 53 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_malloc.h"

 __declspec(restrict)
void* _calloc_base(
    size_t _Count,
    size_t _Size
    );


 __declspec(restrict)
void* calloc(
    size_t _Count,
    size_t _Size
    );


 int _callnewh(
    size_t _Size
    );



void* _expand(
    void* _Block,
    size_t _Size
    );


void _free_base(
    void* _Block
    );


void free(
    void* _Block
    );


 __declspec(restrict)
void* _malloc_base(
    size_t _Size
    );


 __declspec(restrict)
void* malloc(
    size_t _Size
    );



size_t _msize_base(
    void* _Block
    );



size_t _msize(
    void* _Block
    );


 __declspec(restrict)
void* _realloc_base(
    void* _Block,
    size_t _Size
    );


 __declspec(restrict)
void* realloc(
    void* _Block,
    size_t _Size
    );


 __declspec(restrict)
void* _recalloc_base(
    void* _Block,
    size_t _Count,
    size_t _Size
    );


 __declspec(restrict)
void* _recalloc(
    void* _Block,
    size_t _Count,
    size_t _Size
    );


void _aligned_free(
    void* _Block
    );


 __declspec(restrict)
void* _aligned_malloc(
    size_t _Size,
    size_t _Alignment
    );


 __declspec(restrict)
void* _aligned_offset_malloc(
    size_t _Size,
    size_t _Alignment,
    size_t _Offset
    );



size_t _aligned_msize(
    void* _Block,
    size_t _Alignment,
    size_t _Offset
    );


 __declspec(restrict)
void* _aligned_offset_realloc(
    void* _Block,
    size_t _Size,
    size_t _Alignment,
    size_t _Offset
    );


 __declspec(restrict)
void* _aligned_offset_recalloc(
    void* _Block,
    size_t _Count,
    size_t _Size,
    size_t _Alignment,
    size_t _Offset
    );


 __declspec(restrict)
void* _aligned_realloc(
    void* _Block,
    size_t _Size,
    size_t _Alignment
    );


 __declspec(restrict)
void* _aligned_recalloc(
    void* _Block,
    size_t _Count,
    size_t _Size,
    size_t _Alignment
    );
# 228 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_malloc.h"
__pragma(pack(pop))
# 13 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_search.h" 1
# 11 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_search.h"
       


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stddef.h" 1







       
#define _INC_STDDEF 



__pragma(pack(push, _CRT_PACKING))
# 30 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stddef.h"
    int* _errno(void);
#define errno (*_errno())

    errno_t _set_errno( int _Value);
    errno_t _get_errno( int* _Value);
# 47 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stddef.h"
#define offsetof(s,m) __builtin_offsetof(s,m)


 extern unsigned long __threadid(void);
#define _threadid (__threadid())
 extern uintptr_t __threadhandle(void);



__pragma(pack(pop))
# 15 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_search.h" 2

__pragma(pack(push, _CRT_PACKING))


    typedef int (* _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int (* _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);




   
    void* bsearch_s(
        void const* _Key,
        void const* _Base,
        rsize_t _NumOfElements,
        rsize_t _SizeOfElements,
        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        void* _Context
        );

    void qsort_s(
        void* _Base,
        rsize_t _NumOfElements,
        rsize_t _SizeOfElements,
        _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
        void* _Context
        );






 void* bsearch(
    void const* _Key,
    void const* _Base,
    size_t _NumOfElements,
    size_t _SizeOfElements,
    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );

 void qsort(
    void* _Base,
    size_t _NumOfElements,
    size_t _SizeOfElements,
    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


 void* _lfind_s(
    void const* _Key,
    void const* _Base,
    unsigned int* _NumOfElements,
    size_t _SizeOfElements,
    _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    void* _Context
    );


 void* _lfind(
    void const* _Key,
    void const* _Base,
    unsigned int* _NumOfElements,
    unsigned int _SizeOfElements,
    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );


 void* _lsearch_s(
    void const* _Key,
    void* _Base,
    unsigned int* _NumOfElements,
    size_t _SizeOfElements,
    _CoreCrtSecureSearchSortCompareFunction _CompareFunction,
    void* _Context
    );


 void* _lsearch(
    void const* _Key,
    void* _Base,
    unsigned int* _NumOfElements,
    unsigned int _SizeOfElements,
    _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction
    );
# 212 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_search.h"
__pragma(pack(pop))
# 14 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdlib.h" 1
# 9 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdlib.h"
       



__pragma(pack(push, _CRT_PACKING))






#define _MAX_ITOSTR_BASE16_COUNT (8 + 1)
#define _MAX_ITOSTR_BASE10_COUNT (1 + 10 + 1)
#define _MAX_ITOSTR_BASE8_COUNT (11 + 1)
#define _MAX_ITOSTR_BASE2_COUNT (32 + 1)

#define _MAX_LTOSTR_BASE16_COUNT (8 + 1)
#define _MAX_LTOSTR_BASE10_COUNT (1 + 10 + 1)
#define _MAX_LTOSTR_BASE8_COUNT (11 + 1)
#define _MAX_LTOSTR_BASE2_COUNT (32 + 1)

#define _MAX_ULTOSTR_BASE16_COUNT (8 + 1)
#define _MAX_ULTOSTR_BASE10_COUNT (10 + 1)
#define _MAX_ULTOSTR_BASE8_COUNT (11 + 1)
#define _MAX_ULTOSTR_BASE2_COUNT (32 + 1)

#define _MAX_I64TOSTR_BASE16_COUNT (16 + 1)
#define _MAX_I64TOSTR_BASE10_COUNT (1 + 19 + 1)
#define _MAX_I64TOSTR_BASE8_COUNT (22 + 1)
#define _MAX_I64TOSTR_BASE2_COUNT (64 + 1)

#define _MAX_U64TOSTR_BASE16_COUNT (16 + 1)
#define _MAX_U64TOSTR_BASE10_COUNT (20 + 1)
#define _MAX_U64TOSTR_BASE8_COUNT (22 + 1)
#define _MAX_U64TOSTR_BASE2_COUNT (64 + 1)




   
   
    errno_t _itow_s(
        int _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix
        );

   






    wchar_t* _itow(int _Value, wchar_t *_Buffer, int _Radix);






   
   
    errno_t _ltow_s(
        long _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix
        );

   






    wchar_t* _ltow(long _Value, wchar_t *_Buffer, int _Radix);






   
    errno_t _ultow_s(
        unsigned long _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix
        );

   






    wchar_t* _ultow(unsigned long _Value, wchar_t *_Buffer, int _Radix);






   
    double wcstod(
        wchar_t const* _String,
        wchar_t** _EndPtr
        );

   
    double _wcstod_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        _locale_t _Locale
        );

   
    long wcstol(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix
        );

   
    long _wcstol_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale
        );

   
    long long wcstoll(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix
        );

   
    long long _wcstoll_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale
        );

   
    unsigned long wcstoul(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix
        );

   
    unsigned long _wcstoul_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale
        );

   
    unsigned long long wcstoull(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix
        );

   
    unsigned long long _wcstoull_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale
        );

   
    long double wcstold(
        wchar_t const* _String,
        wchar_t** _EndPtr
        );

   
    long double _wcstold_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        _locale_t _Locale
        );

   
    float wcstof(
        wchar_t const* _String,
        wchar_t** _EndPtr
        );

   
    float _wcstof_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        _locale_t _Locale
        );

   
    double _wtof(
        wchar_t const* _String
        );

   
    double _wtof_l(
        wchar_t const* _String,
        _locale_t _Locale
        );

   
    int _wtoi(
        wchar_t const* _String
        );

   
    int _wtoi_l(
        wchar_t const* _String,
        _locale_t _Locale
        );

   
    long _wtol(
        wchar_t const* _String
        );

   
    long _wtol_l(
        wchar_t const* _String,
        _locale_t _Locale
        );

   
    long long _wtoll(
        wchar_t const* _String
        );

   
    long long _wtoll_l(
        wchar_t const* _String,
        _locale_t _Locale
        );

   
    errno_t _i64tow_s(
        __int64 _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix
        );

   
    wchar_t* _i64tow(
        __int64 _Value,
        wchar_t* _Buffer,
        int _Radix
        );

   
    errno_t _ui64tow_s(
        unsigned __int64 _Value,
        wchar_t* _Buffer,
        size_t _BufferCount,
        int _Radix
        );

   
    wchar_t* _ui64tow(
        unsigned __int64 _Value,
        wchar_t* _Buffer,
        int _Radix
        );

   
    __int64 _wtoi64(
        wchar_t const* _String
        );

   
    __int64 _wtoi64_l(
        wchar_t const* _String,
        _locale_t _Locale
        );

   
    __int64 _wcstoi64(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix
        );

   
    __int64 _wcstoi64_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale
        );

   
    unsigned __int64 _wcstoui64(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix
        );

   
    unsigned __int64 _wcstoui64_l(
        wchar_t const* _String,
        wchar_t** _EndPtr,
        int _Radix,
        _locale_t _Locale
        );

           
#undef _wfullpath

   
   
    wchar_t* _wfullpath(
        wchar_t* _Buffer,
        wchar_t const* _Path,
        size_t _BufferCount
        );

           

   
    errno_t _wmakepath_s(
        wchar_t* _Buffer,
        size_t _BufferCount,
        wchar_t const* _Drive,
        wchar_t const* _Dir,
        wchar_t const* _Filename,
        wchar_t const* _Ext
        );

   
# 362 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 void _wmakepath( wchar_t *_Buffer, wchar_t const* _Drive, wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);







#pragma warning(pop)

    void _wperror(
        wchar_t const* _ErrorMessage
        );

   
    void _wsplitpath(
        wchar_t const* _FullPath,
        wchar_t* _Drive,
        wchar_t* _Dir,
        wchar_t* _Filename,
        wchar_t* _Ext
        );

    errno_t _wsplitpath_s(
        wchar_t const* _FullPath,
        wchar_t* _Drive,
        size_t _DriveCount,
        wchar_t* _Dir,
        size_t _DirCount,
        wchar_t* _Filename,
        size_t _FilenameCount,
        wchar_t* _Ext,
        size_t _ExtCount
        );

   
# 409 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstdlib.h"
               
#undef _wdupenv_s

       
        errno_t _wdupenv_s(
            wchar_t** _Buffer,
            size_t* _BufferCount,
            wchar_t const* _VarName
            );

               

       
        wchar_t* _wgetenv(
            wchar_t const* _VarName
            );

       
       
        errno_t _wgetenv_s(
            size_t* _RequiredCount,
            wchar_t* _Buffer,
            size_t _BufferCount,
            wchar_t const* _VarName
            );

       







       
        int _wputenv(
            wchar_t const* _EnvString
            );

       
        errno_t _wputenv_s(
            wchar_t const* _Name,
            wchar_t const* _Value
            );

        errno_t _wsearchenv_s(
            wchar_t const* _Filename,
            wchar_t const* _VarName,
            wchar_t* _Buffer,
            size_t _BufferCount
            );

       






        void _wsearchenv(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t *_ResultPath);






        int _wsystem(
            wchar_t const* _Command
            );






__pragma(pack(pop))
# 15 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h" 1
# 19 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h"
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h" 1
# 20 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h" 2


#define _INC_LIMITS 


#define CHAR_BIT 8
#define SCHAR_MIN (-128)
#define SCHAR_MAX 127
#define UCHAR_MAX 0xff


#define CHAR_MIN SCHAR_MIN
#define CHAR_MAX SCHAR_MAX





#define MB_LEN_MAX 5
#define SHRT_MIN (-32768)
#define SHRT_MAX 32767
#define USHRT_MAX 0xffff
#define INT_MIN (-2147483647 - 1)
#define INT_MAX 2147483647
#define UINT_MAX 0xffffffff
#define LONG_MIN (-2147483647L - 1)
#define LONG_MAX 2147483647L
#define ULONG_MAX 0xffffffffUL
#define LLONG_MAX 9223372036854775807i64
#define LLONG_MIN (-9223372036854775807i64 - 1)
#define ULLONG_MAX 0xffffffffffffffffui64

#define _I8_MIN (-127i8 - 1)
#define _I8_MAX 127i8
#define _UI8_MAX 0xffui8

#define _I16_MIN (-32767i16 - 1)
#define _I16_MAX 32767i16
#define _UI16_MAX 0xffffui16

#define _I32_MIN (-2147483647i32 - 1)
#define _I32_MAX 2147483647i32
#define _UI32_MAX 0xffffffffui32


#define _I64_MIN (-9223372036854775807i64 - 1)

#define _I64_MAX 9223372036854775807i64

#define _UI64_MAX 0xffffffffffffffffui64
# 84 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h"
#define SIZE_MAX UINT_MAX
# 93 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h"
#define RSIZE_MAX SIZE_MAX
# 16 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h" 2

__pragma(pack(push, _CRT_PACKING))




#define _countof __crt_countof





#define __max(a,b) (((a) > (b)) ? (a) : (b))
#define __min(a,b) (((a) < (b)) ? (a) : (b))



 void _swab(
    char* _Buf1,
    char* _Buf2,
    int _SizeInBytes
    );
# 47 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define EXIT_SUCCESS 0
#define EXIT_FAILURE 1


    __declspec(noreturn) void exit( int _Code);
    __declspec(noreturn) void _exit( int _Code);
    __declspec(noreturn) void _Exit( int _Code);
    __declspec(noreturn) void quick_exit( int _Code);
    __declspec(noreturn) void abort(void);



#define _WRITE_ABORT_MSG 0x1
#define _CALL_REPORTFAULT 0x2

 unsigned int _set_abort_behavior(
    unsigned int _Flags,
    unsigned int _Mask
    );




#define _CRT_ONEXIT_T_DEFINED 

    typedef int (* _onexit_t)(void);
# 139 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
    int atexit(void (*)(void));
    _onexit_t _onexit( _onexit_t _Func);


int at_quick_exit(void (*)(void));
# 154 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
    typedef void (* _purecall_handler)(void);


    typedef void (* _invalid_parameter_handler)(
        wchar_t const*,
        wchar_t const*,
        wchar_t const*,
        unsigned int,
        uintptr_t
        );


    _purecall_handler _set_purecall_handler(
        _purecall_handler _Handler
        );

    _purecall_handler _get_purecall_handler(void);


    _invalid_parameter_handler _set_invalid_parameter_handler(
        _invalid_parameter_handler _Handler
        );

    _invalid_parameter_handler _get_invalid_parameter_handler(void);

    _invalid_parameter_handler _set_thread_local_invalid_parameter_handler(
        _invalid_parameter_handler _Handler
        );

    _invalid_parameter_handler _get_thread_local_invalid_parameter_handler(void);
# 202 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define _OUT_TO_DEFAULT 0
#define _OUT_TO_STDERR 1
#define _OUT_TO_MSGBOX 2
#define _REPORT_ERRMODE 3

 int _set_error_mode( int _Mode);




    int* _errno(void);
#define errno (*_errno())

    errno_t _set_errno( int _Value);
    errno_t _get_errno( int* _Value);

    unsigned long* __doserrno(void);
#define _doserrno (*__doserrno())

    errno_t _set_doserrno( unsigned long _Value);
    errno_t _get_doserrno( unsigned long * _Value);


    char** __sys_errlist(void);
#define _sys_errlist (__sys_errlist())

    int * __sys_nerr(void);
#define _sys_nerr (*__sys_nerr())

    void perror( char const* _ErrMsg);





 char** __p__pgmptr (void);
 wchar_t** __p__wpgmptr(void);
 int* __p__fmode (void);
# 248 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define _pgmptr (*__p__pgmptr ())
#define _wpgmptr (*__p__wpgmptr())
#define _fmode (*__p__fmode ())



 errno_t _get_pgmptr ( char** _Value);


 errno_t _get_wpgmptr( wchar_t** _Value);

 errno_t _set_fmode ( int _Mode );

 errno_t _get_fmode ( int* _PMode);
# 270 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
typedef struct _div_t
{
    int quot;
    int rem;
} div_t;

typedef struct _ldiv_t
{
    long quot;
    long rem;
} ldiv_t;

typedef struct _lldiv_t
{
    long long quot;
    long long rem;
} lldiv_t;

 int abs ( int _Number);
 long labs ( long _Number);
 long long llabs ( long long _Number);
 __int64 _abs64( __int64 _Number);

 unsigned short _byteswap_ushort( unsigned short _Number);
 unsigned long _byteswap_ulong ( unsigned long _Number);
 unsigned __int64 _byteswap_uint64( unsigned __int64 _Number);

 div_t div ( int _Numerator, int _Denominator);
 ldiv_t ldiv ( long _Numerator, long _Denominator);
 lldiv_t lldiv( long long _Numerator, long long _Denominator);



#pragma warning (push)
#pragma warning (disable:6540)

unsigned int _rotl(
    unsigned int _Value,
    int _Shift
    );


unsigned long _lrotl(
    unsigned long _Value,
    int _Shift
    );

unsigned __int64 _rotl64(
    unsigned __int64 _Value,
    int _Shift
    );

unsigned int _rotr(
    unsigned int _Value,
    int _Shift
    );


unsigned long _lrotr(
    unsigned long _Value,
    int _Shift
    );

unsigned __int64 _rotr64(
    unsigned __int64 _Value,
    int _Shift
    );

#pragma warning (pop)




#define RAND_MAX 0x7fff

 void srand( unsigned int _Seed);

 int rand(void);
# 385 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define _CRT_DOUBLE_DEC 



#pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
#pragma pack(pop)

#define _PTR_LD(x) ((unsigned char*)(&(x)->ld))
# 410 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
typedef struct
{
    double x;
} _CRT_DOUBLE;

typedef struct
{
    float f;
} _CRT_FLOAT;


       
#undef long

typedef struct
{
    long double x;
} _LONGDOUBLE;

       

#pragma pack(push, 4)
typedef struct
{
    unsigned char ld12[12];
} _LDBL12;
#pragma pack(pop)
# 445 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
 double atof ( char const* _String);
 int atoi ( char const* _String);
 long atol ( char const* _String);
 long long atoll ( char const* _String);
 __int64 _atoi64( char const* _String);

 double _atof_l ( char const* _String, _locale_t _Locale);
 int _atoi_l ( char const* _String, _locale_t _Locale);
 long _atol_l ( char const* _String, _locale_t _Locale);
 long long _atoll_l ( char const* _String, _locale_t _Locale);
 __int64 _atoi64_l( char const* _String, _locale_t _Locale);

 int _atoflt ( _CRT_FLOAT* _Result, char const* _String);
 int _atodbl ( _CRT_DOUBLE* _Result, char* _String);
 int _atoldbl( _LDOUBLE* _Result, char* _String);


 int _atoflt_l(
    _CRT_FLOAT* _Result,
    char const* _String,
    _locale_t _Locale
    );


 int _atodbl_l(
    _CRT_DOUBLE* _Result,
    char* _String,
    _locale_t _Locale
    );



 int _atoldbl_l(
    _LDOUBLE* _Result,
    char* _String,
    _locale_t _Locale
    );


 float strtof(
    char const* _String,
    char** _EndPtr
    );


 float _strtof_l(
    char const* _String,
    char** _EndPtr,
    _locale_t _Locale
    );


 double strtod(
    char const* _String,
    char** _EndPtr
    );


 double _strtod_l(
    char const* _String,
    char** _EndPtr,
    _locale_t _Locale
    );


 long double strtold(
    char const* _String,
    char** _EndPtr
    );


 long double _strtold_l(
    char const* _String,
    char** _EndPtr,
    _locale_t _Locale
    );


 long strtol(
    char const* _String,
    char** _EndPtr,
    int _Radix
    );


 long _strtol_l(
    char const* _String,
    char** _EndPtr,
    int _Radix,
    _locale_t _Locale
    );


 long long strtoll(
    char const* _String,
    char** _EndPtr,
    int _Radix
    );


 long long _strtoll_l(
    char const* _String,
    char** _EndPtr,
    int _Radix,
    _locale_t _Locale
    );


 unsigned long strtoul(
    char const* _String,
    char** _EndPtr,
    int _Radix
    );


 unsigned long _strtoul_l(
    char const* _String,
    char** _EndPtr,
    int _Radix,
    _locale_t _Locale
    );


 unsigned long long strtoull(
    char const* _String,
    char** _EndPtr,
    int _Radix
    );


 unsigned long long _strtoull_l(
    char const* _String,
    char** _EndPtr,
    int _Radix,
    _locale_t _Locale
    );


 __int64 _strtoi64(
    char const* _String,
    char** _EndPtr,
    int _Radix
    );


 __int64 _strtoi64_l(
    char const* _String,
    char** _EndPtr,
    int _Radix,
    _locale_t _Locale
    );


 unsigned __int64 _strtoui64(
    char const* _String,
    char** _EndPtr,
    int _Radix
    );


 unsigned __int64 _strtoui64_l(
    char const* _String,
    char** _EndPtr,
    int _Radix,
    _locale_t _Locale
    );
# 619 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"


 errno_t _itoa_s(
    int _Value,
    char* _Buffer,
    size_t _BufferCount,
    int _Radix
    );









#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 char* _itoa(int _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



 errno_t _ltoa_s(
    long _Value,
    char* _Buffer,
    size_t _BufferCount,
    int _Radix
    );








 char* _ltoa(long _Value, char *_Buffer, int _Radix);








 errno_t _ultoa_s(
    unsigned long _Value,
    char* _Buffer,
    size_t _BufferCount,
    int _Radix
    );








#pragma warning(push)
#pragma warning(disable: 28726)
 char* _ultoa(unsigned long _Value, char *_Buffer, int _Radix);





#pragma warning(pop)



 errno_t _i64toa_s(
    __int64 _Value,
    char* _Buffer,
    size_t _BufferCount,
    int _Radix
    );



 char* _i64toa(
    __int64 _Value,
    char* _Buffer,
    int _Radix
    );



 errno_t _ui64toa_s(
    unsigned __int64 _Value,
    char* _Buffer,
    size_t _BufferCount,
    int _Radix
    );


 char* _ui64toa(
    unsigned __int64 _Value,
    char* _Buffer,
    int _Radix
    );
# 739 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define _CVTBUFSIZE (309 + 40)



 errno_t _ecvt_s(
    char* _Buffer,
    size_t _BufferCount,
    double _Value,
    int _DigitCount,
    int* _PtDec,
    int* _PtSign
    );


# 761 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"

 char* _ecvt(
    double _Value,
    int _DigitCount,
    int* _PtDec,
    int* _PtSign
    );



 errno_t _fcvt_s(
    char* _Buffer,
    size_t _BufferCount,
    double _Value,
    int _FractionalDigitCount,
    int* _PtDec,
    int* _PtSign
    );


# 790 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"


 char* _fcvt(
    double _Value,
    int _FractionalDigitCount,
    int* _PtDec,
    int* _PtSign
    );


 errno_t _gcvt_s(
    char* _Buffer,
    size_t _BufferCount,
    double _Value,
    int _DigitCount
    );










 char* _gcvt(
    double _Value,
    int _DigitCount,
    char* _Buffer
    );
# 835 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define MB_CUR_MAX ___mb_cur_max_func()





#define __mb_cur_max (___mb_cur_max_func())


   
    int ___mb_cur_max_func(void);

   
    int ___mb_cur_max_l_func(_locale_t _Locale);





 int mblen(
    char const* _Ch,
    size_t _MaxCount
    );


 int _mblen_l(
    char const* _Ch,
    size_t _MaxCount,
    _locale_t _Locale
    );



 size_t _mbstrlen(
    char const* _String
    );



 size_t _mbstrlen_l(
    char const* _String,
    _locale_t _Locale
    );



 size_t _mbstrnlen(
    char const* _String,
    size_t _MaxCount
    );



 size_t _mbstrnlen_l(
    char const* _String,
    size_t _MaxCount,
    _locale_t _Locale
    );


 int mbtowc(
    wchar_t* _DstCh,
    char const* _SrcCh,
    size_t _SrcSizeInBytes
    );


 int _mbtowc_l(
    wchar_t* _DstCh,
    char const* _SrcCh,
    size_t _SrcSizeInBytes,
    _locale_t _Locale
    );


 errno_t mbstowcs_s(
    size_t* _PtNumOfCharConverted,
    wchar_t* _DstBuf,
    size_t _SizeInWords,
    char const* _SrcBuf,
    size_t _MaxCount
    );









 size_t mbstowcs( wchar_t *_Dest, char const* _Source, size_t _MaxCount);







 errno_t _mbstowcs_s_l(
    size_t* _PtNumOfCharConverted,
    wchar_t* _DstBuf,
    size_t _SizeInWords,
    char const* _SrcBuf,
    size_t _MaxCount,
    _locale_t _Locale
    );


# 952 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
 size_t _mbstowcs_l( wchar_t *_Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);
# 964 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"

 int wctomb(
    char* _MbCh,
    wchar_t _WCh
    );


 int _wctomb_l(
    char* _MbCh,
    wchar_t _WCh,
    _locale_t _Locale
    );



   
    errno_t wctomb_s(
        int* _SizeConverted,
        char* _MbCh,
        rsize_t _SizeInBytes,
        wchar_t _WCh
        );




 errno_t _wctomb_s_l(
    int* _SizeConverted,
    char* _MbCh,
    size_t _SizeInBytes,
    wchar_t _WCh,
    _locale_t _Locale);


 errno_t wcstombs_s(
    size_t* _PtNumOfCharConverted,
    char* _Dst,
    size_t _DstSizeInBytes,
    wchar_t const* _Src,
    size_t _MaxCountInBytes
    );









 size_t wcstombs( char *_Dest, wchar_t const* _Source, size_t _MaxCount);







 errno_t _wcstombs_s_l(
    size_t* _PtNumOfCharConverted,
    char* _Dst,
    size_t _DstSizeInBytes,
    wchar_t const* _Src,
    size_t _MaxCountInBytes,
    _locale_t _Locale
    );


# 1040 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
 size_t _wcstombs_l( char *_Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);
# 1058 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define _MAX_PATH 260
#define _MAX_DRIVE 3
#define _MAX_DIR 256
#define _MAX_FNAME 256
#define _MAX_EXT 256


       
#undef _fullpath



 char* _fullpath(
    char* _Buffer,
    char const* _Path,
    size_t _BufferCount
    );

       


 errno_t _makepath_s(
    char* _Buffer,
    size_t _BufferCount,
    char const* _Drive,
    char const* _Dir,
    char const* _Filename,
    char const* _Ext
    );


# 1097 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 void _makepath( char *_Buffer, char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext);







#pragma warning(pop)


 void _splitpath(
    char const* _FullPath,
    char* _Drive,
    char* _Dir,
    char* _Filename,
    char* _Ext
    );


 errno_t _splitpath_s(
    char const* _FullPath,
    char* _Drive,
    size_t _DriveCount,
    char* _Dir,
    size_t _DirCount,
    char* _Filename,
    size_t _FilenameCount,
    char* _Ext,
    size_t _ExtCount
    );


# 1145 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
   
   
    errno_t getenv_s(
        size_t* _RequiredCount,
        char* _Buffer,
        rsize_t _BufferCount,
        char const* _VarName
        );






    int* __p___argc (void);
    char*** __p___argv (void);
    wchar_t*** __p___wargv(void);






#define __argc (*__p___argc())
#define __argv (*__p___argv())
#define __wargv (*__p___wargv())


    char*** __p__environ (void);
    wchar_t*** __p__wenviron(void);


#define _CRT_V12_LEGACY_FUNCTIONALITY 
# 1186 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
#define _environ (*__p__environ())
#define _wenviron (*__p__wenviron())





#define _MAX_ENV 32767




       
        char* getenv(
            char const* _VarName
            );

       
# 1215 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
       
        errno_t _dupenv_s(
            char** _Buffer,
            size_t* _BufferCount,
            char const* _VarName
            );





        int system(
            char const* _Command
            );



#pragma warning (push)
#pragma warning (disable:6540)

       
        int _putenv(
            char const* _EnvString
            );

       
        errno_t _putenv_s(
            char const* _Name,
            char const* _Value
            );

#pragma warning (pop)

        errno_t _searchenv_s(
            char const* _Filename,
            char const* _VarName,
            char* _Buffer,
            size_t _BufferCount
            );

       






        void _searchenv(char const* _Filename, char const* _VarName, char *_Buffer);







        __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetErrorMode" " instead. See online help for details."))
        void _seterrormode(
            int _Mode
            );

        __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Beep" " instead. See online help for details."))
        void _beep(
            unsigned _Frequency,
            unsigned _Duration
            );

        __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "Sleep" " instead. See online help for details."))
        void _sleep(
            unsigned long _Duration
            );
# 1381 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdlib.h"
__pragma(pack(pop))
# 13765 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/string.h" 1







       
#define _INC_STRING 


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memory.h" 1
# 11 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memory.h"
       


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memcpy_s.h" 1







       


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/errno.h" 1







       
#define _INC_ERRNO 



__pragma(pack(push, _CRT_PACKING))




    int* _errno(void);
#define errno (*_errno())

    errno_t _set_errno( int _Value);
    errno_t _get_errno( int* _Value);

    unsigned long* __doserrno(void);
#define _doserrno (*__doserrno())

    errno_t _set_doserrno( unsigned long _Value);
    errno_t _get_doserrno( unsigned long * _Value);





#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EAGAIN 11
#define ENOMEM 12
#define EACCES 13
#define EFAULT 14
#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32
#define EDOM 33
#define EDEADLK 36
#define ENAMETOOLONG 38
#define ENOLCK 39
#define ENOSYS 40
#define ENOTEMPTY 41



#define _SECURECRT_ERRCODE_VALUES_DEFINED 
#define EINVAL 22
#define ERANGE 34
#define EILSEQ 42
#define STRUNCATE 80



#define EDEADLOCK EDEADLK



#define EADDRINUSE 100
#define EADDRNOTAVAIL 101
#define EAFNOSUPPORT 102
#define EALREADY 103
#define EBADMSG 104
#define ECANCELED 105
#define ECONNABORTED 106
#define ECONNREFUSED 107
#define ECONNRESET 108
#define EDESTADDRREQ 109
#define EHOSTUNREACH 110
#define EIDRM 111
#define EINPROGRESS 112
#define EISCONN 113
#define ELOOP 114
#define EMSGSIZE 115
#define ENETDOWN 116
#define ENETRESET 117
#define ENETUNREACH 118
#define ENOBUFS 119
#define ENODATA 120
#define ENOLINK 121
#define ENOMSG 122
#define ENOPROTOOPT 123
#define ENOSR 124
#define ENOSTR 125
#define ENOTCONN 126
#define ENOTRECOVERABLE 127
#define ENOTSOCK 128
#define ENOTSUP 129
#define EOPNOTSUPP 130
#define EOTHER 131
#define EOVERFLOW 132
#define EOWNERDEAD 133
#define EPROTO 134
#define EPROTONOSUPPORT 135
#define EPROTOTYPE 136
#define ETIME 137
#define ETIMEDOUT 138
#define ETXTBSY 139
#define EWOULDBLOCK 140




__pragma(pack(pop))
# 12 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memcpy_s.h" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime_string.h" 1







       

# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h" 1
# 11 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime_string.h" 2



__pragma(pack(push, _CRT_PACKING))




 void * memchr(
    void const* _Buf,
    int _Val,
    size_t _MaxCount
    );


int memcmp(
    void const* _Buf1,
    void const* _Buf2,
    size_t _Size
    );









void* memcpy(
    void* _Dst,
    void const* _Src,
    size_t _Size
    );


 void* memmove(
    void* _Dst,
    void const* _Src,
    size_t _Size
    );








void* memset(
    void* _Dst,
    int _Val,
    size_t _Size
    );


 char * strchr(
    char const* _Str,
    int _Val
    );


 char * strrchr(
    char const* _Str,
    int _Ch
    );


 char * strstr(
    char const* _Str,
    char const* _SubStr
    );



 wchar_t * wcschr(
    wchar_t const* _Str,
    wchar_t _Ch
    );


 wchar_t * wcsrchr(
    wchar_t const* _Str,
    wchar_t _Ch
    );



 wchar_t * wcsstr(
    wchar_t const* _Str,
    wchar_t const* _SubStr
    );



__pragma(pack(pop))
# 13 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memcpy_s.h" 2

__pragma(pack(push, _CRT_PACKING))


#define _CRT_MEMCPY_S_INLINE static __inline


#define _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(expr,errorcode) { int _Expr_val=!!(expr); if (!(_Expr_val)) { errno = errorcode; _invalid_parameter_noinfo(); return errorcode; } }
# 33 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memcpy_s.h"
   
   
    static __inline errno_t memcpy_s(
        void* const _Destination,
        rsize_t const _DestinationSize,
        void const* const _Source,
        rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        if (_Source == ((void *)0) || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            { int _Expr_val=!!(_Source != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
            { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };


            return 22;
        }

        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

   
    static __inline errno_t memmove_s(
        void* const _Destination,
        rsize_t const _DestinationSize,
        void const* const _Source,
        rsize_t const _SourceSize
        )
    {
        if (_SourceSize == 0)
        {
            return 0;
        }

        { int _Expr_val=!!(_Destination != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_Source != ((void *)0)); if (!(_Expr_val)) { (*_errno()) = 22; _invalid_parameter_noinfo(); return 22; } };
        { int _Expr_val=!!(_DestinationSize >= _SourceSize); if (!(_Expr_val)) { (*_errno()) = 34; _invalid_parameter_noinfo(); return 34; } };

        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }



#undef _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE

__pragma(pack(pop))
# 15 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memory.h" 2




__pragma(pack(push, _CRT_PACKING))




 int _memicmp(
    void const* _Buf1,
    void const* _Buf2,
    size_t _Size
    );


 int _memicmp_l(
    void const* _Buf1,
    void const* _Buf2,
    size_t _Size,
    _locale_t _Locale
    );
# 114 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_memory.h"
__pragma(pack(pop))
# 13 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/string.h" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstring.h" 1
# 9 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstring.h"
       






__pragma(pack(push, _CRT_PACKING))
# 27 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstring.h"
   
    errno_t wcscat_s(
        wchar_t* _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source
        );

   
    errno_t wcscpy_s(
        wchar_t* _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source
        );

   
    errno_t wcsncat_s(
        wchar_t* _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source,
        rsize_t _MaxCount
        );

   
    errno_t wcsncpy_s(
        wchar_t* _Destination,
        rsize_t _SizeInWords,
        wchar_t const* _Source,
        rsize_t _MaxCount
        );

   
    wchar_t* wcstok_s(
        wchar_t* _String,
        wchar_t const* _Delimiter,
        wchar_t** _Context
        );
# 78 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstring.h"

 wchar_t* _wcsdup(
    wchar_t const* _String
    );















#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
    wchar_t* wcscat( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)



 int wcscmp(
    wchar_t const* _String1,
    wchar_t const* _String2
    );







#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 wchar_t* wcscpy( wchar_t *_Destination, wchar_t const* _Source);




#pragma warning(pop)


 size_t wcscspn(
    wchar_t const* _String,
    wchar_t const* _Control
    );


 size_t wcslen(
    wchar_t const* _String
    );










 size_t wcsnlen(
    wchar_t const* _Source,
    size_t _MaxCount
    );



   
   



   



    static __inline size_t wcsnlen_s(
        wchar_t const* _Source,
        size_t _MaxCount
        )
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }










 wchar_t* wcsncat( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








 int wcsncmp(
    wchar_t const* _String1,
    wchar_t const* _String2,
    size_t _MaxCount
    );








 wchar_t* wcsncpy( wchar_t *_Destination, wchar_t const* _Source, size_t _Count);








 wchar_t * wcspbrk(
    wchar_t const* _String,
    wchar_t const* _Control
    );


 size_t wcsspn(
    wchar_t const* _String,
    wchar_t const* _Control
    );


 wchar_t* wcstok(
    wchar_t* _String,
    wchar_t const* _Delimiter,
    wchar_t** _Context
    );






#define _WCSTOK_DEPRECATED _CRT_DEPRECATE_TEXT( "wcstok has been changed to conform with the ISO C standard, " "adding an extra context parameter. To use the legacy Microsoft " "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")





#pragma warning(push)
#pragma warning(disable: 4141 4996)

   
    static __inline wchar_t* _wcstok(
        wchar_t* const _String,
        wchar_t const* const _Delimiter
        )
    {
        return wcstok(_String, _Delimiter, 0);
    }
# 270 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstring.h"
#pragma warning(pop)







 wchar_t* _wcserror(
    int _ErrorNumber
    );


 errno_t _wcserror_s(
    wchar_t* _Buffer,
    size_t _SizeInWords,
    int _ErrorNumber
    );










 wchar_t* __wcserror(
    wchar_t const* _String
    );

 errno_t __wcserror_s(
    wchar_t* _Buffer,
    size_t _SizeInWords,
    wchar_t const* _ErrorMessage
    );







 int _wcsicmp(
    wchar_t const* _String1,
    wchar_t const* _String2
    );

 int _wcsicmp_l(
    wchar_t const* _String1,
    wchar_t const* _String2,
    _locale_t _Locale
    );

 int _wcsnicmp(
    wchar_t const* _String1,
    wchar_t const* _String2,
    size_t _MaxCount
    );

 int _wcsnicmp_l(
    wchar_t const* _String1,
    wchar_t const* _String2,
    size_t _MaxCount,
    _locale_t _Locale
    );

 errno_t _wcsnset_s(
    wchar_t* _Destination,
    size_t _SizeInWords,
    wchar_t _Value,
    size_t _MaxCount
    );








 wchar_t* _wcsnset( wchar_t *_String, wchar_t _Value, size_t _MaxCount);







 wchar_t* _wcsrev(
    wchar_t* _String
    );

 errno_t _wcsset_s(
    wchar_t* _Destination,
    size_t _SizeInWords,
    wchar_t _Value
    );







 wchar_t* _wcsset( wchar_t *_String, wchar_t _Value);






 errno_t _wcslwr_s(
    wchar_t* _String,
    size_t _SizeInWords
    );






 wchar_t* _wcslwr( wchar_t *_String);





 errno_t _wcslwr_s_l(
    wchar_t* _String,
    size_t _SizeInWords,
    _locale_t _Locale
    );







 wchar_t* _wcslwr_l( wchar_t *_String, _locale_t _Locale);







 errno_t _wcsupr_s(
    wchar_t* _String,
    size_t _Size
    );






 wchar_t* _wcsupr( wchar_t *_String);





 errno_t _wcsupr_s_l(
    wchar_t* _String,
    size_t _Size,
    _locale_t _Locale
    );







 wchar_t* _wcsupr_l( wchar_t *_String, _locale_t _Locale);








 size_t wcsxfrm(
    wchar_t* _Destination,
    wchar_t const* _Source,
    size_t _MaxCount
    );



 size_t _wcsxfrm_l(
    wchar_t* _Destination,
    wchar_t const* _Source,
    size_t _MaxCount,
    _locale_t _Locale
    );


 int wcscoll(
    wchar_t const* _String1,
    wchar_t const* _String2
    );


 int _wcscoll_l(
    wchar_t const* _String1,
    wchar_t const* _String2,
    _locale_t _Locale
    );


 int _wcsicoll(
    wchar_t const* _String1,
    wchar_t const* _String2
    );


 int _wcsicoll_l(
    wchar_t const* _String1,
    wchar_t const* _String2,
    _locale_t _Locale
    );


 int _wcsncoll(
    wchar_t const* _String1,
    wchar_t const* _String2,
    size_t _MaxCount
    );


 int _wcsncoll_l(
    wchar_t const* _String1,
    wchar_t const* _String2,
    size_t _MaxCount,
    _locale_t _Locale
    );


 int _wcsnicoll(
    wchar_t const* _String1,
    wchar_t const* _String2,
    size_t _MaxCount
    );


 int _wcsnicoll_l(
    wchar_t const* _String1,
    wchar_t const* _String2,
    size_t _MaxCount,
    _locale_t _Locale
    );
# 647 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wstring.h"
__pragma(pack(pop))
# 14 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/string.h" 2




__pragma(pack(push, _CRT_PACKING))



#define _NLSCMPERROR _CRT_INT_MAX



   
    errno_t strcpy_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source
        );

   
    errno_t strcat_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source
        );

   
    errno_t strerror_s(
        char* _Buffer,
        size_t _SizeInBytes,
        int _ErrorNumber);

   
    errno_t strncat_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source,
        rsize_t _MaxCount
        );

   
    errno_t strncpy_s(
        char* _Destination,
        rsize_t _SizeInBytes,
        char const* _Source,
        rsize_t _MaxCount
        );

   
    char* strtok_s(
        char* _String,
        char const* _Delimiter,
        char** _Context
        );



 void* _memccpy(
    void* _Dst,
    void const* _Src,
    int _Val,
    size_t _MaxCount
    );









#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
    char* strcat( char *_Destination, char const* _Source);




#pragma warning(pop)




int strcmp(
    char const* _Str1,
    char const* _Str2
    );


 int _strcmpi(
    char const* _String1,
    char const* _String2
    );


 int strcoll(
    char const* _String1,
    char const* _String2
    );


 int _strcoll_l(
    char const* _String1,
    char const* _String2,
    _locale_t _Locale
    );







#pragma warning(push)
#pragma warning(disable: 28719)
#pragma warning(disable: 28726)
 char* strcpy( char *_Destination, char const* _Source);




#pragma warning(pop)


 size_t strcspn(
    char const* _Str,
    char const* _Control
    );







 char* _strdup(
    char const* _Source
    );








 char* _strerror(
    char const* _ErrorMessage
    );


 errno_t _strerror_s(
    char* _Buffer,
    size_t _SizeInBytes,
    char const* _ErrorMessage
    );









 char* strerror(
    int _ErrorMessage
    );








 int _stricmp(
    char const* _String1,
    char const* _String2
    );


 int _stricoll(
    char const* _String1,
    char const* _String2
    );


 int _stricoll_l(
    char const* _String1,
    char const* _String2,
    _locale_t _Locale
    );


 int _stricmp_l(
    char const* _String1,
    char const* _String2,
    _locale_t _Locale
    );


size_t strlen(
    char const* _Str
    );


 errno_t _strlwr_s(
    char* _String,
    size_t _Size
    );






 char* _strlwr( char *_String);





 errno_t _strlwr_s_l(
    char* _String,
    size_t _Size,
    _locale_t _Locale
    );







 char* _strlwr_l( char *_String, _locale_t _Locale);













 char* strncat( char *_Destination, char const* _Source, size_t _Count);








 int strncmp(
    char const* _Str1,
    char const* _Str2,
    size_t _MaxCount
    );


 int _strnicmp(
    char const* _String1,
    char const* _String2,
    size_t _MaxCount
    );


 int _strnicmp_l(
    char const* _String1,
    char const* _String2,
    size_t _MaxCount,
    _locale_t _Locale
    );


 int _strnicoll(
    char const* _String1,
    char const* _String2,
    size_t _MaxCount
    );


 int _strnicoll_l(
    char const* _String1,
    char const* _String2,
    size_t _MaxCount,
    _locale_t _Locale
    );


 int _strncoll(
    char const* _String1,
    char const* _String2,
    size_t _MaxCount
    );


 int _strncoll_l(
    char const* _String1,
    char const* _String2,
    size_t _MaxCount,
    _locale_t _Locale
    );

 size_t __strncnt(
    char const* _String,
    size_t _Count
    );








 char* strncpy( char *_Destination, char const* _Source, size_t _Count);
















 size_t strnlen(
    char const* _String,
    size_t _MaxCount
    );



   
   



   



    static __inline size_t strnlen_s(
        char const* _String,
        size_t _MaxCount
        )
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }




 errno_t _strnset_s(
    char* _String,
    size_t _SizeInBytes,
    int _Value,
    size_t _MaxCount
    );








 char* _strnset( char *_Destination, int _Value, size_t _Count);








 char * strpbrk(
    char const* _Str,
    char const* _Control
    );

 char* _strrev(
    char* _Str
    );


 errno_t _strset_s(
    char* _Destination,
    size_t _DestinationSize,
    int _Value
    );







 char* _strset( char *_Destination, int _Value);






 size_t strspn(
    char const* _Str,
    char const* _Control
    );


 char* strtok(
    char* _String,
    char const* _Delimiter
    );


 errno_t _strupr_s(
    char* _String,
    size_t _Size
    );






 char* _strupr( char *_String);





 errno_t _strupr_s_l(
    char* _String,
    size_t _Size,
    _locale_t _Locale
    );







 char* _strupr_l( char *_String, _locale_t _Locale);








 size_t strxfrm(
    char* _Destination,
    char const* _Source,
    size_t _MaxCount
    );



 size_t _strxfrm_l(
    char* _Destination,
    char const* _Source,
    size_t _MaxCount,
    _locale_t _Locale
    );
# 597 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/string.h"
__pragma(pack(pop))
# 13766 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/assert.h" 1
# 14 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/assert.h"
__pragma(pack(push, _CRT_PACKING))



#undef assert



#define assert(expression) ((void)0)
# 41 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/assert.h"
__pragma(pack(pop))
# 13767 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 13798 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_BIG_DBL (1e99)
# 13809 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OMIT_TEMPDB 0
# 13818 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_FILE_FORMAT 4

#define SQLITE_DEFAULT_FILE_FORMAT 4







#define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0







#define SQLITE_TEMP_STORE 1
# 13849 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_WORKER_THREADS 8


#define SQLITE_DEFAULT_WORKER_THREADS 0
# 13869 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEFAULT_PCACHE_INITSZ 20






#define SQLITE_DEFAULT_SORTERREF_SIZE 0x7fffffff
# 13900 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define MIN(A,B) ((A)<(B)?(A):(B))


#define MAX(A,B) ((A)>(B)?(A):(B))





#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}
# 13918 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_ASCII 1
# 13932 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define UINT32_TYPE unsigned int






#define UINT16_TYPE unsigned short int






#define INT16_TYPE short int






#define UINT8_TYPE unsigned char






#define INT8_TYPE signed char



#define LONGDOUBLE_TYPE long double

typedef sqlite_int64 i64;
typedef sqlite_uint64 u64;
typedef unsigned int u32;
typedef unsigned short int u16;
typedef short int i16;
typedef unsigned char u8;
typedef signed char i8;







#define SQLITE_MAX_U32 ((((u64)1)<<32)-1)
# 13991 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 typedef u32 tRowcnt;
# 14017 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef short int LogEst;






#define SQLITE_PTRSIZE __SIZEOF_POINTER__
# 14041 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  typedef u64 uptr;
# 14052 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_WITHIN(P,S,E) (((uptr)(P)>=(uptr)(S))&&((uptr)(P)<(uptr)(E)))
# 14069 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_BYTEORDER 1234
# 14082 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_BIGENDIAN 0
#define SQLITE_LITTLEENDIAN 1
#define SQLITE_UTF16NATIVE SQLITE_UTF16LE
# 14101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define LARGEST_INT64 (0xffffffff|(((i64)0x7fffffff)<<32))
#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)





#define ROUND8(x) (((x)+7)&~7)




#define ROUNDDOWN8(x) ((x)&~7)
# 14127 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define EIGHT_BYTE_ALIGNMENT(X) ((((char*)(X) - (char*)0)&7)==0)
# 14142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/TargetConditionals.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/TargetConditionals.h" 3 4
#define __TARGETCONDITIONALS__ 
# 210 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/TargetConditionals.h" 3 4
#define DYNAMIC_TARGETS_ENABLED 0






#define TARGET_OS_MAC 1
#define TARGET_OS_WIN32 0
#define TARGET_OS_WINDOWS 0
#define TARGET_OS_UNIX 0
#define TARGET_OS_LINUX 0


#define TARGET_OS_OSX 1
#define TARGET_OS_IPHONE 0
#define TARGET_OS_IOS 0
#define TARGET_OS_WATCH 0

#define TARGET_OS_TV 0
#define TARGET_OS_MACCATALYST 0
#define TARGET_OS_MACCATALYST 0

#define TARGET_OS_UIKITFORMAC 0

#define TARGET_OS_SIMULATOR 0
#define TARGET_OS_EMBEDDED 0
#define TARGET_OS_RTKIT 0
#define TARGET_OS_DRIVERKIT 0


#define TARGET_IPHONE_SIMULATOR TARGET_OS_SIMULATOR
#define TARGET_OS_NANO TARGET_OS_WATCH

#define TARGET_ABI_USES_IOS_VALUES (!TARGET_CPU_X86_64 || (TARGET_OS_IPHONE && !TARGET_OS_MACCATALYST))
# 331 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/TargetConditionals.h" 3 4
#define TARGET_CPU_PPC 0
#define TARGET_CPU_PPC64 0
#define TARGET_CPU_68K 0
#define TARGET_CPU_X86 0
#define TARGET_CPU_X86_64 0
#define TARGET_CPU_ARM 0
#define TARGET_CPU_ARM64 1
#define TARGET_CPU_MIPS 0
#define TARGET_CPU_SPARC 0
#define TARGET_CPU_ALPHA 0
#define TARGET_RT_MAC_CFM 0
#define TARGET_RT_MAC_MACHO 1
#define TARGET_RT_LITTLE_ENDIAN 1
#define TARGET_RT_BIG_ENDIAN 0

#define TARGET_RT_64_BIT 1
# 14143 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 14151 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_MMAP_SIZE 0x7fff0000
# 14163 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEFAULT_MMAP_SIZE 0
# 14177 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SELECTTRACE_ENABLED 0
# 14189 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct BusyHandler BusyHandler;
struct BusyHandler {
  int (*xBusyHandler)(void *,int);
  void *pBusyArg;
  int nBusy;
  u8 bExtraFileArg;
};






#define MASTER_NAME "sqlite_master"
#define TEMP_MASTER_NAME "sqlite_temp_master"




#define MASTER_ROOT 1




#define SCHEMA_TABLE(x) ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)





#define ArraySize(X) ((int)(sizeof(X)/sizeof(X[0])))




#define IsPowerOfTwo(X) (((X)&((X)-1))==0)
# 14234 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DYNAMIC ((sqlite3_destructor_type)sqlite3MallocSize)
# 14257 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_WSD 
#define GLOBAL(t,v) v
#define sqlite3GlobalConfig sqlite3Config
# 14278 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define UNUSED_PARAMETER(x) (void)(x)
#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)




typedef struct AggInfo AggInfo;
typedef struct AuthContext AuthContext;
typedef struct AutoincInfo AutoincInfo;
typedef struct Bitvec Bitvec;
typedef struct CollSeq CollSeq;
typedef struct Column Column;
typedef struct Db Db;
typedef struct Schema Schema;
typedef struct Expr Expr;
typedef struct ExprList ExprList;
typedef struct FKey FKey;
typedef struct FuncDestructor FuncDestructor;
typedef struct FuncDef FuncDef;
typedef struct FuncDefHash FuncDefHash;
typedef struct IdList IdList;
typedef struct Index Index;
typedef struct IndexSample IndexSample;
typedef struct KeyClass KeyClass;
typedef struct KeyInfo KeyInfo;
typedef struct Lookaside Lookaside;
typedef struct LookasideSlot LookasideSlot;
typedef struct Module Module;
typedef struct NameContext NameContext;
typedef struct Parse Parse;
typedef struct PreUpdate PreUpdate;
typedef struct PrintfArguments PrintfArguments;
typedef struct RenameToken RenameToken;
typedef struct RowSet RowSet;
typedef struct Savepoint Savepoint;
typedef struct Select Select;
typedef struct SQLiteThread SQLiteThread;
typedef struct SelectDest SelectDest;
typedef struct SrcList SrcList;
typedef struct sqlite3_str StrAccum;
typedef struct Table Table;
typedef struct TableLock TableLock;
typedef struct Token Token;
typedef struct TreeView TreeView;
typedef struct Trigger Trigger;
typedef struct TriggerPrg TriggerPrg;
typedef struct TriggerStep TriggerStep;
typedef struct UnpackedRecord UnpackedRecord;
typedef struct Upsert Upsert;
typedef struct VTable VTable;
typedef struct VtabCtx VtabCtx;
typedef struct Walker Walker;
typedef struct WhereInfo WhereInfo;
typedef struct Window Window;
typedef struct With With;
# 14345 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  typedef u64 Bitmask;





#define BMS ((int)(sizeof(Bitmask)*8))




#define MASKBIT(n) (((Bitmask)1)<<(n))
#define MASKBIT32(n) (((unsigned int)1)<<(n))
#define ALLBITS ((Bitmask)-1)







typedef int VList;
# 14391 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_BTREE_H 




#define SQLITE_N_BTREE_META 16






#define SQLITE_DEFAULT_AUTOVACUUM 0


#define BTREE_AUTOVACUUM_NONE 0
#define BTREE_AUTOVACUUM_FULL 1
#define BTREE_AUTOVACUUM_INCR 2




typedef struct Btree Btree;
typedef struct BtCursor BtCursor;
typedef struct BtShared BtShared;
typedef struct BtreePayload BtreePayload;


static int sqlite3BtreeOpen(
  sqlite3_vfs *pVfs,
  const char *zFilename,
  sqlite3 *db,
  Btree **ppBtree,
  int flags,
  int vfsFlags
);







#define BTREE_OMIT_JOURNAL 1
#define BTREE_MEMORY 2
#define BTREE_SINGLE 4
#define BTREE_UNORDERED 8

static int sqlite3BtreeClose(Btree*);
static int sqlite3BtreeSetCacheSize(Btree*,int);
static int sqlite3BtreeSetSpillSize(Btree*,int);

static int sqlite3BtreeSetMmapLimit(Btree*,sqlite3_int64);

static int sqlite3BtreeSetPagerFlags(Btree*,unsigned);
static int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);
static int sqlite3BtreeGetPageSize(Btree*);
static int sqlite3BtreeMaxPageCount(Btree*,int);
static u32 sqlite3BtreeLastPage(Btree*);
static int sqlite3BtreeSecureDelete(Btree*,int);
static int sqlite3BtreeGetOptimalReserve(Btree*);
static int sqlite3BtreeGetReserveNoMutex(Btree *p);
static int sqlite3BtreeSetAutoVacuum(Btree *, int);
static int sqlite3BtreeGetAutoVacuum(Btree *);
static int sqlite3BtreeBeginTrans(Btree*,int,int*);
static int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);
static int sqlite3BtreeCommitPhaseTwo(Btree*, int);
static int sqlite3BtreeCommit(Btree*);
static int sqlite3BtreeRollback(Btree*,int,int);
static int sqlite3BtreeBeginStmt(Btree*,int);
static int sqlite3BtreeCreateTable(Btree*, int*, int flags);
static int sqlite3BtreeIsInTrans(Btree*);
static int sqlite3BtreeIsInReadTrans(Btree*);
static int sqlite3BtreeIsInBackup(Btree*);
static void *sqlite3BtreeSchema(Btree *, int, void(*)(void *));
static int sqlite3BtreeSchemaLocked(Btree *pBtree);

static int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);

static int sqlite3BtreeSavepoint(Btree *, int, int);

static const char *sqlite3BtreeGetFilename(Btree *);
static const char *sqlite3BtreeGetJournalname(Btree *);
static int sqlite3BtreeCopyFile(Btree *, Btree *);

static int sqlite3BtreeIncrVacuum(Btree *);
# 14488 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BTREE_INTKEY 1
#define BTREE_BLOBKEY 2

static int sqlite3BtreeDropTable(Btree*, int, int*);
static int sqlite3BtreeClearTable(Btree*, int, int*);
static int sqlite3BtreeClearTableOfCursor(BtCursor*);
static int sqlite3BtreeTripAllCursors(Btree*, int, int);

static void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);
static int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);

static int sqlite3BtreeNewDb(Btree *p);
# 14518 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BTREE_FREE_PAGE_COUNT 0
#define BTREE_SCHEMA_VERSION 1
#define BTREE_FILE_FORMAT 2
#define BTREE_DEFAULT_CACHE_SIZE 3
#define BTREE_LARGEST_ROOT_PAGE 4
#define BTREE_TEXT_ENCODING 5
#define BTREE_USER_VERSION 6
#define BTREE_INCR_VACUUM 7
#define BTREE_APPLICATION_ID 8
#define BTREE_DATA_VERSION 15
# 14556 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BTREE_HINT_RANGE 0
# 14571 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BTREE_BULKLOAD 0x00000001
#define BTREE_SEEK_EQ 0x00000002
# 14597 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BTREE_WRCSR 0x00000004
#define BTREE_FORDELETE 0x00000008

static int sqlite3BtreeCursor(
  Btree*,
  int iTable,
  int wrFlag,
  struct KeyInfo*,
  BtCursor *pCursor
);
static BtCursor *sqlite3BtreeFakeValidCursor(void);
static int sqlite3BtreeCursorSize(void);
static void sqlite3BtreeCursorZero(BtCursor*);
static void sqlite3BtreeCursorHintFlags(BtCursor*, unsigned);




static int sqlite3BtreeCloseCursor(BtCursor*);
static int sqlite3BtreeMovetoUnpacked(
  BtCursor*,
  UnpackedRecord *pUnKey,
  i64 intKey,
  int bias,
  int *pRes
);
static int sqlite3BtreeCursorHasMoved(BtCursor*);
static int sqlite3BtreeCursorRestore(BtCursor*, int*);
static int sqlite3BtreeDelete(BtCursor*, u8 flags);


#define BTREE_SAVEPOSITION 0x02
#define BTREE_AUXDELETE 0x04
#define BTREE_APPEND 0x08
# 14665 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct BtreePayload {
  const void *pKey;
  sqlite3_int64 nKey;
  const void *pData;
  sqlite3_value *aMem;
  u16 nMem;
  int nData;
  int nZero;
};

static int sqlite3BtreeInsert(BtCursor*, const BtreePayload *pPayload,
                       int flags, int seekResult);
static int sqlite3BtreeFirst(BtCursor*, int *pRes);
static int sqlite3BtreeLast(BtCursor*, int *pRes);
static int sqlite3BtreeNext(BtCursor*, int flags);
static int sqlite3BtreeEof(BtCursor*);
static int sqlite3BtreePrevious(BtCursor*, int flags);
static i64 sqlite3BtreeIntegerKey(BtCursor*);



static int sqlite3BtreePayload(BtCursor*, u32 offset, u32 amt, void*);
static const void *sqlite3BtreePayloadFetch(BtCursor*, u32 *pAmt);
static u32 sqlite3BtreePayloadSize(BtCursor*);
static sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor*);

static char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*);
static struct Pager *sqlite3BtreePager(Btree*);
static i64 sqlite3BtreeRowCountEst(BtCursor*);


static int sqlite3BtreePayloadChecked(BtCursor*, u32 offset, u32 amt, void*);
static int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);
static void sqlite3BtreeIncrblobCursor(BtCursor *);

static void sqlite3BtreeClearCursor(BtCursor *);
static int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);
static int sqlite3BtreeCursorHasHint(BtCursor*, unsigned int mask);
static int sqlite3BtreeIsReadonly(Btree *pBt);
static int sqlite3HeaderSizeBtree(void);




static int sqlite3BtreeCursorIsValidNN(BtCursor*);


static int sqlite3BtreeCount(BtCursor *, i64 *);
# 14721 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);
# 14730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BtreeEnter(Btree*);
static void sqlite3BtreeEnterAll(sqlite3*);
static int sqlite3BtreeSharable(Btree*);
static void sqlite3BtreeEnterCursor(BtCursor*);
static int sqlite3BtreeConnectionCount(Btree*);
# 14744 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BtreeLeave(Btree*);
static void sqlite3BtreeLeaveCursor(BtCursor*);
static void sqlite3BtreeLeaveAll(sqlite3*);
# 14789 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_VDBE_H 







typedef struct Vdbe Vdbe;





typedef struct sqlite3_value Mem;
typedef struct SubProgram SubProgram;






struct VdbeOp {
  u8 opcode;
  signed char p4type;
  u16 p5;
  int p1;
  int p2;
  int p3;
  union p4union {
    int i;
    void *p;
    char *z;
    i64 *pI64;
    double *pReal;
    FuncDef *pFunc;
    sqlite3_context *pCtx;
    CollSeq *pColl;
    Mem *pMem;
    VTable *pVtab;
    KeyInfo *pKeyInfo;
    int *ai;
    SubProgram *pProgram;
    Table *pTab;



    int (*xAdvance)(BtCursor *, int);
  } p4;
# 14849 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};
typedef struct VdbeOp VdbeOp;





struct SubProgram {
  VdbeOp *aOp;
  int nOp;
  int nMem;
  int nCsr;
  u8 *aOnce;
  void *token;
  SubProgram *pNext;
};





struct VdbeOpList {
  u8 opcode;
  signed char p1;
  signed char p2;
  signed char p3;
};
typedef struct VdbeOpList VdbeOpList;




#define P4_NOTUSED 0
#define P4_TRANSIENT 0
#define P4_STATIC (-1)
#define P4_COLLSEQ (-2)
#define P4_INT32 (-3)
#define P4_SUBPROGRAM (-4)
#define P4_ADVANCE (-5)
#define P4_TABLE (-6)

#define P4_FREE_IF_LE (-7)
#define P4_DYNAMIC (-7)
#define P4_FUNCDEF (-8)
#define P4_KEYINFO (-9)
#define P4_EXPR (-10)
#define P4_MEM (-11)
#define P4_VTAB (-12)
#define P4_REAL (-13)
#define P4_INT64 (-14)
#define P4_INTARRAY (-15)
#define P4_FUNCCTX (-16)
#define P4_DYNBLOB (-17)


#define P5_ConstraintNotNull 1
#define P5_ConstraintUnique 2
#define P5_ConstraintCheck 3
#define P5_ConstraintFK 4





#define COLNAME_NAME 0
#define COLNAME_DECLTYPE 1
#define COLNAME_DATABASE 2
#define COLNAME_TABLE 3
#define COLNAME_COLUMN 4






#define COLNAME_N 2
# 14933 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ADDR(X) (~(X))
# 14943 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OP_Savepoint 0
#define OP_AutoCommit 1
#define OP_Transaction 2
#define OP_SorterNext 3
#define OP_Prev 4
#define OP_Next 5
#define OP_Checkpoint 6
#define OP_JournalMode 7
#define OP_Vacuum 8
#define OP_VFilter 9
#define OP_VUpdate 10
#define OP_Goto 11
#define OP_Gosub 12
#define OP_InitCoroutine 13
#define OP_Yield 14
#define OP_MustBeInt 15
#define OP_Jump 16
#define OP_Once 17
#define OP_If 18
#define OP_Not 19
#define OP_IfNot 20
#define OP_IfNullRow 21
#define OP_SeekLT 22
#define OP_SeekLE 23
#define OP_SeekGE 24
#define OP_SeekGT 25
#define OP_IfNoHope 26
#define OP_NoConflict 27
#define OP_NotFound 28
#define OP_Found 29
#define OP_SeekRowid 30
#define OP_NotExists 31
#define OP_Last 32
#define OP_IfSmaller 33
#define OP_SorterSort 34
#define OP_Sort 35
#define OP_Rewind 36
#define OP_IdxLE 37
#define OP_IdxGT 38
#define OP_IdxLT 39
#define OP_IdxGE 40
#define OP_RowSetRead 41
#define OP_RowSetTest 42
#define OP_Or 43
#define OP_And 44
#define OP_Program 45
#define OP_FkIfZero 46
#define OP_IfPos 47
#define OP_IfNotZero 48
#define OP_DecrJumpZero 49
#define OP_IsNull 50
#define OP_NotNull 51
#define OP_Ne 52
#define OP_Eq 53
#define OP_Gt 54
#define OP_Le 55
#define OP_Lt 56
#define OP_Ge 57
#define OP_ElseNotEq 58
#define OP_IncrVacuum 59
#define OP_VNext 60
#define OP_Init 61
#define OP_PureFunc0 62
#define OP_Function0 63
#define OP_PureFunc 64
#define OP_Function 65
#define OP_Return 66
#define OP_EndCoroutine 67
#define OP_HaltIfNull 68
#define OP_Halt 69
#define OP_Integer 70
#define OP_Int64 71
#define OP_String 72
#define OP_Null 73
#define OP_SoftNull 74
#define OP_Blob 75
#define OP_Variable 76
#define OP_Move 77
#define OP_Copy 78
#define OP_SCopy 79
#define OP_IntCopy 80
#define OP_ResultRow 81
#define OP_CollSeq 82
#define OP_AddImm 83
#define OP_RealAffinity 84
#define OP_Cast 85
#define OP_Permutation 86
#define OP_Compare 87
#define OP_IsTrue 88
#define OP_Offset 89
#define OP_Column 90
#define OP_Affinity 91
#define OP_MakeRecord 92
#define OP_Count 93
#define OP_ReadCookie 94
#define OP_SetCookie 95
#define OP_ReopenIdx 96
#define OP_OpenRead 97
#define OP_OpenWrite 98
#define OP_BitAnd 99
#define OP_BitOr 100
#define OP_ShiftLeft 101
#define OP_ShiftRight 102
#define OP_Add 103
#define OP_Subtract 104
#define OP_Multiply 105
#define OP_Divide 106
#define OP_Remainder 107
#define OP_Concat 108
#define OP_OpenDup 109
#define OP_BitNot 110
#define OP_OpenAutoindex 111
#define OP_OpenEphemeral 112
#define OP_String8 113
#define OP_SorterOpen 114
#define OP_SequenceTest 115
#define OP_OpenPseudo 116
#define OP_Close 117
#define OP_ColumnsUsed 118
#define OP_SeekHit 119
#define OP_Sequence 120
#define OP_NewRowid 121
#define OP_Insert 122
#define OP_Delete 123
#define OP_ResetCount 124
#define OP_SorterCompare 125
#define OP_SorterData 126
#define OP_RowData 127
#define OP_Rowid 128
#define OP_NullRow 129
#define OP_SeekEnd 130
#define OP_SorterInsert 131
#define OP_IdxInsert 132
#define OP_IdxDelete 133
#define OP_DeferredSeek 134
#define OP_IdxRowid 135
#define OP_Destroy 136
#define OP_Clear 137
#define OP_ResetSorter 138
#define OP_CreateBtree 139
#define OP_SqlExec 140
#define OP_ParseSchema 141
#define OP_LoadAnalysis 142
#define OP_DropTable 143
#define OP_DropIndex 144
#define OP_DropTrigger 145
#define OP_IntegrityCk 146
#define OP_RowSetAdd 147
#define OP_Real 148
#define OP_Param 149
#define OP_FkCounter 150
#define OP_MemMax 151
#define OP_OffsetLimit 152
#define OP_AggInverse 153
#define OP_AggStep 154
#define OP_AggStep1 155
#define OP_AggValue 156
#define OP_AggFinal 157
#define OP_Expire 158
#define OP_TableLock 159
#define OP_VBegin 160
#define OP_VCreate 161
#define OP_VDestroy 162
#define OP_VOpen 163
#define OP_VColumn 164
#define OP_VRename 165
#define OP_Pagecount 166
#define OP_MaxPgcnt 167
#define OP_Trace 168
#define OP_CursorHint 169
#define OP_Noop 170
#define OP_Explain 171
#define OP_Abortable 172





#define OPFLG_JUMP 0x01
#define OPFLG_IN1 0x02
#define OPFLG_IN2 0x04
#define OPFLG_IN3 0x08
#define OPFLG_OUT2 0x10
#define OPFLG_OUT3 0x20
#define OPFLG_INITIALIZER { 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x03, 0x12, 0x03, 0x01, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x23, 0x0b, 0x26, 0x26, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00, 0x12, 0x20, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,}
# 15157 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MX_JUMP_OPCODE 61







#define SQLITE_PREPARE_SAVESQL 0x80
#define SQLITE_PREPARE_MASK 0x0f





static Vdbe *sqlite3VdbeCreate(Parse*);
static int sqlite3VdbeAddOp0(Vdbe*,int);
static int sqlite3VdbeAddOp1(Vdbe*,int,int);
static int sqlite3VdbeAddOp2(Vdbe*,int,int,int);
static int sqlite3VdbeGoto(Vdbe*,int);
static int sqlite3VdbeLoadString(Vdbe*,int,const char*);
static void sqlite3VdbeMultiLoad(Vdbe*,int,const char*,...);
static int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);
static int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);
static int sqlite3VdbeAddOp4Dup8(Vdbe*,int,int,int,int,const u8*,int);
static int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);
static void sqlite3VdbeEndCoroutine(Vdbe*,int);




#define sqlite3VdbeVerifyNoMallocRequired(A,B) 
#define sqlite3VdbeVerifyNoResultRow(A) 




#define sqlite3VdbeVerifyAbortable(A,B) 

static VdbeOp *sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp,int iLineno);

static void sqlite3VdbeExplain(Parse*,u8,const char*,...);
static void sqlite3VdbeExplainPop(Parse*);
static int sqlite3VdbeExplainParent(Parse*);
#define ExplainQueryPlan(P) sqlite3VdbeExplain P
#define ExplainQueryPlanPop(P) sqlite3VdbeExplainPop(P)
#define ExplainQueryPlanParent(P) sqlite3VdbeExplainParent(P)
# 15213 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqlite3ExplainBreakpoint(A,B) 

static void sqlite3VdbeAddParseSchemaOp(Vdbe*,int,char*);
static void sqlite3VdbeChangeOpcode(Vdbe*, int addr, u8);
static void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);
static void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);
static void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);
static void sqlite3VdbeChangeP5(Vdbe*, u16 P5);
static void sqlite3VdbeJumpHere(Vdbe*, int addr);
static int sqlite3VdbeChangeToNoop(Vdbe*, int addr);
static int sqlite3VdbeDeletePriorOpcode(Vdbe*, u8 op);
static void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);
static void sqlite3VdbeAppendP4(Vdbe*, void *pP4, int p4type);
static void sqlite3VdbeSetP4KeyInfo(Parse*, Index*);
static void sqlite3VdbeUsesBtree(Vdbe*, int);
static VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);
static int sqlite3VdbeMakeLabel(Parse*);
static void sqlite3VdbeRunOnlyOnce(Vdbe*);
static void sqlite3VdbeReusable(Vdbe*);
static void sqlite3VdbeDelete(Vdbe*);
static void sqlite3VdbeClearObject(sqlite3*,Vdbe*);
static void sqlite3VdbeMakeReady(Vdbe*,Parse*);
static int sqlite3VdbeFinalize(Vdbe*);
static void sqlite3VdbeResolveLabel(Vdbe*, int);
static int sqlite3VdbeCurrentAddr(Vdbe*);



static void sqlite3VdbeResetStepResult(Vdbe*);
static void sqlite3VdbeRewind(Vdbe*);
static int sqlite3VdbeReset(Vdbe*);
static void sqlite3VdbeSetNumCols(Vdbe*,int);
static int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));
static void sqlite3VdbeCountChanges(Vdbe*);
static sqlite3 *sqlite3VdbeDb(Vdbe*);
static u8 sqlite3VdbePrepareFlags(Vdbe*);
static void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, u8);




static void sqlite3VdbeSwap(Vdbe*,Vdbe*);
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);
static sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe*, int, u8);
static void sqlite3VdbeSetVarmask(Vdbe*, int);

static char *sqlite3VdbeExpandSql(Vdbe*, const char*);

static int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);
static int sqlite3BlobCompare(const Mem*, const Mem*);

static void sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,UnpackedRecord*);
static int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*);
static int sqlite3VdbeRecordCompareWithSkip(int, const void *, UnpackedRecord *, int);
static UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(KeyInfo*);

typedef int (*RecordCompare)(int,const void*,UnpackedRecord*);
static RecordCompare sqlite3VdbeFindCompare(UnpackedRecord*);


static void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);


static int sqlite3NotPureFunc(sqlite3_context*);
# 15296 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define VdbeComment(X) 
#define VdbeNoopComment(X) 
#define VdbeModuleComment(X) 
# 15357 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define VdbeCoverage(v) 
#define VdbeCoverageIf(v,x) 
#define VdbeCoverageAlwaysTaken(v) 
#define VdbeCoverageNeverTaken(v) 
#define VdbeCoverageNeverNull(v) 
#define VdbeCoverageNeverNullIf(v,x) 
#define VdbeCoverageEqNe(v) 
#define VDBE_OFFSET_LINENO(x) 0





#define sqlite3VdbeScanStatus(a,b,c,d,e) 
# 15400 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_PAGER_H 







#define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1






typedef u32 Pgno;




typedef struct Pager Pager;




typedef struct PgHdr DbPage;
# 15435 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))+1))






#define PAGER_OMIT_JOURNAL 0x0001
#define PAGER_MEMORY 0x0002




#define PAGER_LOCKINGMODE_QUERY -1
#define PAGER_LOCKINGMODE_NORMAL 0
#define PAGER_LOCKINGMODE_EXCLUSIVE 1
# 15459 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PAGER_JOURNALMODE_QUERY (-1)
#define PAGER_JOURNALMODE_DELETE 0
#define PAGER_JOURNALMODE_PERSIST 1
#define PAGER_JOURNALMODE_OFF 2
#define PAGER_JOURNALMODE_TRUNCATE 3
#define PAGER_JOURNALMODE_MEMORY 4
#define PAGER_JOURNALMODE_WAL 5




#define PAGER_GET_NOCONTENT 0x01
#define PAGER_GET_READONLY 0x02
# 15481 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PAGER_SYNCHRONOUS_OFF 0x01
#define PAGER_SYNCHRONOUS_NORMAL 0x02
#define PAGER_SYNCHRONOUS_FULL 0x03
#define PAGER_SYNCHRONOUS_EXTRA 0x04
#define PAGER_SYNCHRONOUS_MASK 0x07
#define PAGER_FULLFSYNC 0x08
#define PAGER_CKPT_FULLFSYNC 0x10
#define PAGER_CACHESPILL 0x20
#define PAGER_FLAGS_MASK 0x38
# 15498 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerOpen(
  sqlite3_vfs*,
  Pager **ppPager,
  const char*,
  int,
  int,
  int,
  void(*)(DbPage*)
);
static int sqlite3PagerClose(Pager *pPager, sqlite3*);
static int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);


static void sqlite3PagerSetBusyHandler(Pager*, int(*)(void *), void *);
static int sqlite3PagerSetPagesize(Pager*, u32*, int);



static int sqlite3PagerMaxPageCount(Pager*, int);
static void sqlite3PagerSetCachesize(Pager*, int);
static int sqlite3PagerSetSpillsize(Pager*, int);
static void sqlite3PagerSetMmapLimit(Pager *, sqlite3_int64);
static void sqlite3PagerShrink(Pager*);
static void sqlite3PagerSetFlags(Pager*,unsigned);
static int sqlite3PagerLockingMode(Pager *, int);
static int sqlite3PagerSetJournalMode(Pager *, int);
static int sqlite3PagerGetJournalMode(Pager*);
static int sqlite3PagerOkToChangeJournalMode(Pager*);
static i64 sqlite3PagerJournalSizeLimit(Pager *, i64);
static sqlite3_backup **sqlite3PagerBackupPtr(Pager*);
static int sqlite3PagerFlush(Pager*);


static int sqlite3PagerGet(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);
static DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);
static void sqlite3PagerRef(DbPage*);
static void sqlite3PagerUnref(DbPage*);
static void sqlite3PagerUnrefNotNull(DbPage*);
static void sqlite3PagerUnrefPageOne(DbPage*);


static int sqlite3PagerWrite(DbPage*);
static void sqlite3PagerDontWrite(DbPage*);
static int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);
static int sqlite3PagerPageRefcount(DbPage*);
static void *sqlite3PagerGetData(DbPage *);
static void *sqlite3PagerGetExtra(DbPage *);


static void sqlite3PagerPagecount(Pager*, int*);
static int sqlite3PagerBegin(Pager*, int exFlag, int);
static int sqlite3PagerCommitPhaseOne(Pager*,const char *zMaster, int);
static int sqlite3PagerExclusiveLock(Pager*);
static int sqlite3PagerSync(Pager *pPager, const char *zMaster);
static int sqlite3PagerCommitPhaseTwo(Pager*);
static int sqlite3PagerRollback(Pager*);
static int sqlite3PagerOpenSavepoint(Pager *pPager, int n);
static int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);
static int sqlite3PagerSharedLock(Pager *pPager);


static int sqlite3PagerCheckpoint(Pager *pPager, sqlite3*, int, int*, int*);
static int sqlite3PagerWalSupported(Pager *pPager);
static int sqlite3PagerWalCallback(Pager *pPager);
static int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);
static int sqlite3PagerCloseWal(Pager *pPager, sqlite3*);
# 15582 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u8 sqlite3PagerIsreadonly(Pager*);
static u32 sqlite3PagerDataVersion(Pager*);



static int sqlite3PagerMemUsed(Pager*);
static const char *sqlite3PagerFilename(Pager*, int);
static sqlite3_vfs *sqlite3PagerVfs(Pager*);
static sqlite3_file *sqlite3PagerFile(Pager*);
static sqlite3_file *sqlite3PagerJrnlFile(Pager*);
static const char *sqlite3PagerJournalname(Pager*);
static void *sqlite3PagerTempSpace(Pager*);
static int sqlite3PagerIsMemdb(Pager*);
static void sqlite3PagerCacheStat(Pager *, int, int, int *);
static void sqlite3PagerClearCache(Pager*);
static int sqlite3SectorSize(sqlite3_file *);



#define sqlite3PagerResetLockTimeout(X) 



static void sqlite3PagerTruncateImage(Pager*,Pgno);

static void sqlite3PagerRekey(DbPage*, Pgno, u16);
# 15624 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define disable_simulated_io_errors() 
#define enable_simulated_io_errors() 
# 15651 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct PgHdr PgHdr;
typedef struct PCache PCache;





struct PgHdr {
  sqlite3_pcache_page *pPage;
  void *pData;
  void *pExtra;
  PCache *pCache;
  PgHdr *pDirty;
  Pager *pPager;
  Pgno pgno;



  u16 flags;






  i16 nRef;
  PgHdr *pDirtyNext;
  PgHdr *pDirtyPrev;


};


#define PGHDR_CLEAN 0x001
#define PGHDR_DIRTY 0x002
#define PGHDR_WRITEABLE 0x004
#define PGHDR_NEED_SYNC 0x008

#define PGHDR_DONT_WRITE 0x010
#define PGHDR_MMAP 0x020

#define PGHDR_WAL_APPEND 0x040


static int sqlite3PcacheInitialize(void);
static void sqlite3PcacheShutdown(void);




static void sqlite3PCacheBufferSetup(void *, int sz, int n);





static int sqlite3PcacheOpen(
  int szPage,
  int szExtra,
  int bPurgeable,
  int (*xStress)(void*, PgHdr*),
  void *pStress,
  PCache *pToInit
);


static int sqlite3PcacheSetPageSize(PCache *, int);




static int sqlite3PcacheSize(void);




static sqlite3_pcache_page *sqlite3PcacheFetch(PCache*, Pgno, int createFlag);
static int sqlite3PcacheFetchStress(PCache*, Pgno, sqlite3_pcache_page**);
static PgHdr *sqlite3PcacheFetchFinish(PCache*, Pgno, sqlite3_pcache_page *pPage);
static void sqlite3PcacheRelease(PgHdr*);

static void sqlite3PcacheDrop(PgHdr*);
static void sqlite3PcacheMakeDirty(PgHdr*);
static void sqlite3PcacheMakeClean(PgHdr*);
static void sqlite3PcacheCleanAll(PCache*);
static void sqlite3PcacheClearWritable(PCache*);


static void sqlite3PcacheMove(PgHdr*, Pgno);


static void sqlite3PcacheTruncate(PCache*, Pgno x);


static PgHdr *sqlite3PcacheDirtyList(PCache*);


static void sqlite3PcacheClose(PCache*);


static void sqlite3PcacheClearSyncFlags(PCache *);


static void sqlite3PcacheClear(PCache*);


static int sqlite3PcacheRefCount(PCache*);


static void sqlite3PcacheRef(PgHdr*);

static int sqlite3PcachePageRefcount(PgHdr*);


static int sqlite3PcachePagecount(PCache*);
# 15786 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PcacheSetCachesize(PCache *, int);
# 15796 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PcacheSetSpillsize(PCache *, int);


static void sqlite3PcacheShrink(PCache*);
# 15810 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PCacheSetDefault(void);


static int sqlite3HeaderSizePcache(void);
static int sqlite3HeaderSizePcache1(void);


static int sqlite3PCachePercentDirty(PCache*);
# 15849 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define _SQLITE_OS_H_ 
# 15873 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_OS_SETUP_H 
# 15894 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_OS_OTHER 0






#define SQLITE_OS_WIN 0
#define SQLITE_OS_UNIX 1
# 15922 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SET_FULLSYNC(x,y) 






#define SQLITE_DEFAULT_SECTOR_SIZE 4096
# 15954 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_TEMP_FILE_PREFIX "etilqs_"
# 15974 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define NO_LOCK 0
#define SHARED_LOCK 1
#define RESERVED_LOCK 2
#define PENDING_LOCK 3
#define EXCLUSIVE_LOCK 4
# 16038 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PENDING_BYTE sqlite3PendingByte

#define RESERVED_BYTE (PENDING_BYTE+1)
#define SHARED_FIRST (PENDING_BYTE+2)
#define SHARED_SIZE 510




static int sqlite3OsInit(void);




static void sqlite3OsClose(sqlite3_file*);
static int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);
static int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);
static int sqlite3OsTruncate(sqlite3_file*, i64 size);
static int sqlite3OsSync(sqlite3_file*, int);
static int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);
static int sqlite3OsLock(sqlite3_file*, int);
static int sqlite3OsUnlock(sqlite3_file*, int);
static int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);
static int sqlite3OsFileControl(sqlite3_file*,int,void*);
static void sqlite3OsFileControlHint(sqlite3_file*,int,void*);
#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0
static int sqlite3OsSectorSize(sqlite3_file *id);
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id);

static int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);
static int sqlite3OsShmLock(sqlite3_file *id, int, int, int);
static void sqlite3OsShmBarrier(sqlite3_file *id);
static int sqlite3OsShmUnmap(sqlite3_file *id, int);

static int sqlite3OsFetch(sqlite3_file *id, i64, int, void **);
static int sqlite3OsUnfetch(sqlite3_file *, i64, void *);





static int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);
static int sqlite3OsDelete(sqlite3_vfs *, const char *, int);
static int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);
static int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);

static void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);
static void sqlite3OsDlError(sqlite3_vfs *, int, char *);
static void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);
static void sqlite3OsDlClose(sqlite3_vfs *, void *);

static int sqlite3OsRandomness(sqlite3_vfs *, int, char *);
static int sqlite3OsSleep(sqlite3_vfs *, int);
static int sqlite3OsGetLastError(sqlite3_vfs*);
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);





static int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);
static void sqlite3OsCloseFree(sqlite3_file *);
# 16151 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MUTEX_PTHREADS 
# 16175 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define MUTEX_LOGIC(X) X
 int sqlite3_mutex_held(sqlite3_mutex*);
# 16207 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEFAULT_SYNCHRONOUS 2


#define SQLITE_DEFAULT_WAL_SYNCHRONOUS SQLITE_DEFAULT_SYNCHRONOUS
# 16220 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Db {
  char *zDbSName;
  Btree *pBt;
  u8 safety_level;
  u8 bSyncSet;
  Schema *pSchema;
};
# 16245 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Schema {
  int schema_cookie;
  int iGeneration;
  Hash tblHash;
  Hash idxHash;
  Hash trigHash;
  Hash fkeyHash;
  Table *pSeqTab;
  u8 file_format;
  u8 enc;
  u16 schemaFlags;
  int cache_size;
};





#define DbHasProperty(D,I,P) (((D)->aDb[I].pSchema->schemaFlags&(P))==(P))
#define DbHasAnyProperty(D,I,P) (((D)->aDb[I].pSchema->schemaFlags&(P))!=0)
#define DbSetProperty(D,I,P) (D)->aDb[I].pSchema->schemaFlags|=(P)
#define DbClearProperty(D,I,P) (D)->aDb[I].pSchema->schemaFlags&=~(P)
# 16278 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define DB_SchemaLoaded 0x0001
#define DB_UnresetViews 0x0002
#define DB_Empty 0x0004
#define DB_ResetWanted 0x0008





#define SQLITE_N_LIMIT (SQLITE_LIMIT_WORKER_THREADS+1)
# 16309 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Lookaside {
  u32 bDisable;
  u16 sz;
  u8 bMalloced;
  u32 nSlot;
  u32 anStat[3];
  LookasideSlot *pInit;
  LookasideSlot *pFree;
  void *pStart;
  void *pEnd;
};
struct LookasideSlot {
  LookasideSlot *pNext;
};
# 16332 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_FUNC_HASH_SZ 23
struct FuncDefHash {
  FuncDef *a[23];
};
#define SQLITE_FUNC_HASH(C,L) (((C)+(L))%SQLITE_FUNC_HASH_SZ)
# 16372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  typedef int (*sqlite3_xauth)(void*,int,const char*,const char*,const char*,
                               const char*);






#define SQLITE_TRACE_LEGACY 0x40
#define SQLITE_TRACE_XPROFILE 0x80




#define SQLITE_TRACE_NONLEGACY_MASK 0x0f





struct sqlite3 {
  sqlite3_vfs *pVfs;
  struct Vdbe *pVdbe;
  CollSeq *pDfltColl;
  sqlite3_mutex *mutex;
  Db *aDb;
  int nDb;
  u32 mDbFlags;
  u64 flags;
  i64 lastRowid;
  i64 szMmap;
  u32 nSchemaLock;
  unsigned int openFlags;
  int errCode;
  int errMask;
  int iSysErrno;
  u16 dbOptFlags;
  u8 enc;
  u8 autoCommit;
  u8 temp_store;
  u8 mallocFailed;
  u8 bBenignMalloc;
  u8 dfltLockMode;
  signed char nextAutovac;
  u8 suppressErr;
  u8 vtabOnConflict;
  u8 isTransactionSavepoint;
  u8 mTrace;
  u8 noSharedCache;
  u8 nSqlExec;
  int nextPagesize;
  u32 magic;
  int nChange;
  int nTotalChange;
  int aLimit[(11 +1)];
  int nMaxSorterMmap;
  struct sqlite3InitInfo {
    int newTnum;
    u8 iDb;
    u8 busy;
    unsigned orphanTrigger : 1;
    unsigned imposterTable : 1;
    unsigned reopenMemdb : 1;
    char **azInit;
  } init;
  int nVdbeActive;
  int nVdbeRead;
  int nVdbeWrite;
  int nVdbeExec;
  int nVDestroy;
  int nExtension;
  void **aExtension;
  int (*xTrace)(u32,void*,void*,void*);
  void *pTraceArg;

  void (*xProfile)(void*,const char*,u64);
  void *pProfileArg;

  void *pCommitArg;
  int (*xCommitCallback)(void*);
  void *pRollbackArg;
  void (*xRollbackCallback)(void*);
  void *pUpdateArg;
  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);
  Parse *pParse;
# 16465 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  int (*xWalCallback)(void *, sqlite3 *, const char *, int);
  void *pWalArg;

  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);
  void *pCollNeededArg;
  sqlite3_value *pErr;
  union {
    volatile int isInterrupted;
    double notUsed1;
  } u1;
  Lookaside lookaside;

  sqlite3_xauth xAuth;
  void *pAuthArg;


  int (*xProgress)(void *);
  void *pProgressArg;
  unsigned nProgressOps;


  int nVTrans;
  Hash aModule;
  VtabCtx *pVtabCtx;
  VTable **aVTrans;
  VTable *pDisconnect;

  Hash aFunc;
  Hash aCollSeq;
  BusyHandler busyHandler;
  Db aDbStatic[2];
  Savepoint *pSavepoint;
  int busyTimeout;
  int nSavepoint;
  int nStatement;
  i64 nDeferredCons;
  i64 nDeferredImmCons;
  int *pnBytesFreed;
# 16524 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};




#define SCHEMA_ENC(db) ((db)->aDb[0].pSchema->enc)
#define ENC(db) ((db)->enc)
# 16540 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_WriteSchema 0x00000001
#define SQLITE_LegacyFileFmt 0x00000002
#define SQLITE_FullColNames 0x00000004
#define SQLITE_FullFSync 0x00000008
#define SQLITE_CkptFullFSync 0x00000010
#define SQLITE_CacheSpill 0x00000020
#define SQLITE_ShortColNames 0x00000040
#define SQLITE_CountRows 0x00000080


#define SQLITE_NullCallback 0x00000100

#define SQLITE_IgnoreChecks 0x00000200
#define SQLITE_ReadUncommit 0x00000400
#define SQLITE_NoCkptOnClose 0x00000800
#define SQLITE_ReverseOrder 0x00001000
#define SQLITE_RecTriggers 0x00002000
#define SQLITE_ForeignKeys 0x00004000
#define SQLITE_AutoIndex 0x00008000
#define SQLITE_LoadExtension 0x00010000
#define SQLITE_LoadExtFunc 0x00020000
#define SQLITE_EnableTrigger 0x00040000
#define SQLITE_DeferFKs 0x00080000
#define SQLITE_QueryOnly 0x00100000
#define SQLITE_CellSizeCk 0x00200000
#define SQLITE_Fts3Tokenizer 0x00400000
#define SQLITE_EnableQPSG 0x00800000
#define SQLITE_TriggerEQP 0x01000000
#define SQLITE_ResetDatabase 0x02000000
#define SQLITE_LegacyAlter 0x04000000
#define SQLITE_NoSchemaError 0x08000000
#define SQLITE_Defensive 0x10000000
#define SQLITE_DqsDDL 0x20000000
#define SQLITE_DqsDML 0x40000000
#define SQLITE_EnableView 0x80000000


#define HI(X) ((u64)(X)<<32)
# 16590 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define DBFLAG_SchemaChange 0x0001
#define DBFLAG_PreferBuiltin 0x0002
#define DBFLAG_Vacuum 0x0004
#define DBFLAG_VacuumInto 0x0008
#define DBFLAG_SchemaKnownOk 0x0010






#define SQLITE_QueryFlattener 0x0001
#define SQLITE_WindowFunc 0x0002
#define SQLITE_GroupByOrder 0x0004
#define SQLITE_FactorOutConst 0x0008
#define SQLITE_DistinctOpt 0x0010
#define SQLITE_CoverIdxScan 0x0020
#define SQLITE_OrderByIdxJoin 0x0040
#define SQLITE_Transitive 0x0080
#define SQLITE_OmitNoopJoin 0x0100
#define SQLITE_CountOfView 0x0200
#define SQLITE_CursorHints 0x0400
#define SQLITE_Stat4 0x0800

#define SQLITE_PushDown 0x1000
#define SQLITE_SimplifyJoin 0x2000
#define SQLITE_SkipScan 0x4000
#define SQLITE_PropagateConst 0x8000
#define SQLITE_AllOpts 0xffff




#define OptimizationDisabled(db,mask) (((db)->dbOptFlags&(mask))!=0)
#define OptimizationEnabled(db,mask) (((db)->dbOptFlags&(mask))==0)





#define ConstFactorOk(P) ((P)->okConstFactor)






#define SQLITE_MAGIC_OPEN 0xa029a697
#define SQLITE_MAGIC_CLOSED 0x9f3c2d33
#define SQLITE_MAGIC_SICK 0x4b771290
#define SQLITE_MAGIC_BUSY 0xf03b7906
#define SQLITE_MAGIC_ERROR 0xb5357930
#define SQLITE_MAGIC_ZOMBIE 0x64cffc7f
# 16654 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct FuncDef {
  i8 nArg;
  u32 funcFlags;
  void *pUserData;
  FuncDef *pNext;
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**);
  void (*xFinalize)(sqlite3_context*);
  void (*xValue)(sqlite3_context*);
  void (*xInverse)(sqlite3_context*,int,sqlite3_value**);
  const char *zName;
  union {
    FuncDef *pHash;
    FuncDestructor *pDestructor;
  } u;
};
# 16684 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct FuncDestructor {
  int nRef;
  void (*xDestroy)(void *);
  void *pUserData;
};
# 16704 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_FUNC_ENCMASK 0x0003
#define SQLITE_FUNC_LIKE 0x0004
#define SQLITE_FUNC_CASE 0x0008
#define SQLITE_FUNC_EPHEM 0x0010
#define SQLITE_FUNC_NEEDCOLL 0x0020
#define SQLITE_FUNC_LENGTH 0x0040
#define SQLITE_FUNC_TYPEOF 0x0080
#define SQLITE_FUNC_COUNT 0x0100
#define SQLITE_FUNC_COALESCE 0x0200
#define SQLITE_FUNC_UNLIKELY 0x0400
#define SQLITE_FUNC_CONSTANT 0x0800
#define SQLITE_FUNC_MINMAX 0x1000
#define SQLITE_FUNC_SLOCHNG 0x2000

#define SQLITE_FUNC_AFFINITY 0x4000
#define SQLITE_FUNC_OFFSET 0x8000
#define SQLITE_FUNC_WINDOW 0x00010000
#define SQLITE_FUNC_INTERNAL 0x00040000
#define SQLITE_FUNC_DIRECT 0x00080000
#define SQLITE_FUNC_SUBTYPE 0x00100000
# 16772 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define FUNCTION(zName,nArg,iArg,bNC,xFunc) {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }


#define VFUNCTION(zName,nArg,iArg,bNC,xFunc) {nArg, SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }


#define DFUNCTION(zName,nArg,iArg,bNC,xFunc) {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8, 0, 0, xFunc, 0, 0, 0, #zName, {0} }


#define PURE_DATE(zName,nArg,iArg,bNC,xFunc) {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, (void*)&sqlite3Config, 0, xFunc, 0, 0, 0, #zName, {0} }


#define FUNCTION2(zName,nArg,iArg,bNC,xFunc,extraFlags) {nArg,SQLITE_FUNC_CONSTANT|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL)|extraFlags, SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, 0, #zName, {0} }


#define STR_FUNCTION(zName,nArg,pArg,bNC,xFunc) {nArg, SQLITE_FUNC_SLOCHNG|SQLITE_UTF8|(bNC*SQLITE_FUNC_NEEDCOLL), pArg, 0, xFunc, 0, 0, 0, #zName, }


#define LIKEFUNC(zName,nArg,arg,flags) {nArg, SQLITE_FUNC_CONSTANT|SQLITE_UTF8|flags, (void *)arg, 0, likeFunc, 0, 0, 0, #zName, {0} }


#define AGGREGATE(zName,nArg,arg,nc,xStep,xFinal,xValue) {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL), SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xValue,0,#zName, {0}}


#define AGGREGATE2(zName,nArg,arg,nc,xStep,xFinal,extraFlags) {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|extraFlags, SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xFinal,0,#zName, {0}}


#define WAGGREGATE(zName,nArg,arg,nc,xStep,xFinal,xValue,xInverse,f) {nArg, SQLITE_UTF8|(nc*SQLITE_FUNC_NEEDCOLL)|f, SQLITE_INT_TO_PTR(arg), 0, xStep,xFinal,xValue,xInverse,#zName, {0}}


#define INTERNAL_FUNCTION(zName,nArg,xFunc) {nArg, SQLITE_FUNC_INTERNAL|SQLITE_UTF8|SQLITE_FUNC_CONSTANT, 0, 0, xFunc, 0, 0, 0, #zName, {0} }
# 16813 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Savepoint {
  char *zName;
  i64 nDeferredCons;
  i64 nDeferredImmCons;
  Savepoint *pNext;
};





#define SAVEPOINT_BEGIN 0
#define SAVEPOINT_RELEASE 1
#define SAVEPOINT_ROLLBACK 2







struct Module {
  const sqlite3_module *pModule;
  const char *zName;
  int nRefModule;
  void *pAux;
  void (*xDestroy)(void *);
  Table *pEpoTab;
};





struct Column {
  char *zName;
  Expr *pDflt;
  char *zColl;
  u8 notNull;
  char affinity;
  u8 szEst;
  u8 colFlags;
};



#define COLFLAG_PRIMKEY 0x0001
#define COLFLAG_HIDDEN 0x0002
#define COLFLAG_HASTYPE 0x0004
#define COLFLAG_UNIQUE 0x0008
#define COLFLAG_SORTERREF 0x0010
# 16874 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct CollSeq {
  char *zName;
  u8 enc;
  void *pUser;
  int (*xCmp)(void*,int, const void*, int, const void*);
  void (*xDel)(void*);
};




#define SQLITE_SO_ASC 0
#define SQLITE_SO_DESC 1
#define SQLITE_SO_UNDEFINED -1
# 16903 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_AFF_NONE 0x40
#define SQLITE_AFF_BLOB 0x41
#define SQLITE_AFF_TEXT 0x42
#define SQLITE_AFF_NUMERIC 0x43
#define SQLITE_AFF_INTEGER 0x44
#define SQLITE_AFF_REAL 0x45

#define sqlite3IsNumericAffinity(X) ((X)>=SQLITE_AFF_NUMERIC)





#define SQLITE_AFF_MASK 0x47
# 16927 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_KEEPNULL 0x08
#define SQLITE_JUMPIFNULL 0x10
#define SQLITE_STOREP2 0x20
#define SQLITE_NULLEQ 0x80
#define SQLITE_NOTNULL 0x90
# 16975 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct VTable {
  sqlite3 *db;
  Module *pMod;
  sqlite3_vtab *pVtab;
  int nRef;
  u8 bConstraint;
  int iSavepoint;
  VTable *pNext;
};





struct Table {
  char *zName;
  Column *aCol;
  Index *pIndex;
  Select *pSelect;
  FKey *pFKey;
  char *zColAff;
  ExprList *pCheck;

  int tnum;
  u32 nTabRef;
  u32 tabFlags;
  i16 iPKey;
  i16 nCol;
  LogEst nRowLogEst;
  LogEst szTabRow;



  u8 keyConf;

  int addColOffset;


  int nModuleArg;
  char **azModuleArg;
  VTable *pVTable;

  Trigger *pTrigger;
  Schema *pSchema;
  Table *pNextZombie;
};
# 17031 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TF_Readonly 0x0001
#define TF_Ephemeral 0x0002
#define TF_HasPrimaryKey 0x0004
#define TF_Autoincrement 0x0008
#define TF_HasStat1 0x0010
#define TF_WithoutRowid 0x0020
#define TF_NoVisibleRowid 0x0040
#define TF_OOOHidden 0x0080
#define TF_StatsUsed 0x0100

#define TF_HasNotNull 0x0200
#define TF_Shadow 0x0400







#define IsVirtual(X) ((X)->nModuleArg)
# 17065 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IsHiddenColumn(X) (((X)->colFlags & COLFLAG_HIDDEN)!=0)
#define IsOrdinaryHiddenColumn(X) 0







#define HasRowid(X) (((X)->tabFlags & TF_WithoutRowid)==0)
#define VisibleRowid(X) (((X)->tabFlags & TF_NoVisibleRowid)==0)
# 17105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct FKey {
  Table *pFrom;
  FKey *pNextFrom;
  char *zTo;
  FKey *pNextTo;
  FKey *pPrevTo;
  int nCol;

  u8 isDeferred;
  u8 aAction[2];
  Trigger *apTrigger[2];
  struct sColMap {
    int iFrom;
    char *zCol;
  } aCol[1];
};
# 17147 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OE_None 0
#define OE_Rollback 1
#define OE_Abort 2
#define OE_Fail 3
#define OE_Ignore 4
#define OE_Replace 5
#define OE_Update 6
#define OE_Restrict 7
#define OE_SetNull 8
#define OE_SetDflt 9
#define OE_Cascade 10
#define OE_Default 11
# 17170 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct KeyInfo {
  u32 nRef;
  u8 enc;
  u16 nKeyField;
  u16 nAllField;
  sqlite3 *db;
  u8 *aSortFlags;
  CollSeq *aColl[1];
};




#define KEYINFO_ORDER_DESC 0x01
#define KEYINFO_ORDER_BIGNULL 0x02
# 17221 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct UnpackedRecord {
  KeyInfo *pKeyInfo;
  Mem *aMem;
  u16 nField;
  i8 default_rc;
  u8 errCode;
  i8 r1;
  i8 r2;
  u8 eqSeen;
};
# 17267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Index {
  char *zName;
  i16 *aiColumn;
  LogEst *aiRowLogEst;
  Table *pTable;
  char *zColAff;
  Index *pNext;
  Schema *pSchema;
  u8 *aSortOrder;
  const char **azColl;
  Expr *pPartIdxWhere;
  ExprList *aColExpr;
  int tnum;
  LogEst szIdxRow;
  u16 nKeyCol;
  u16 nColumn;
  u8 onError;
  unsigned idxType:2;
  unsigned bUnordered:1;
  unsigned uniqNotNull:1;
  unsigned isResized:1;
  unsigned isCovering:1;
  unsigned noSkipScan:1;
  unsigned hasStat1:1;
  unsigned bNoQuery:1;
  unsigned bAscKeyBug:1;
# 17301 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  Bitmask colNotIdxed;
};




#define SQLITE_IDXTYPE_APPDEF 0
#define SQLITE_IDXTYPE_UNIQUE 1
#define SQLITE_IDXTYPE_PRIMARYKEY 2
#define SQLITE_IDXTYPE_IPK 3


#define IsPrimaryKeyIndex(X) ((X)->idxType==SQLITE_IDXTYPE_PRIMARYKEY)


#define IsUniqueIndex(X) ((X)->onError!=OE_None)




#define XN_ROWID (-1)
#define XN_EXPR (-2)






struct IndexSample {
  void *p;
  int n;
  tRowcnt *anEq;
  tRowcnt *anLt;
  tRowcnt *anDLt;
};




#define SQLITE_TOKEN_QUOTED 0x1
#define SQLITE_TOKEN_KEYWORD 0x2
# 17353 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Token {
  const char *z;
  unsigned int n;
};
# 17371 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct AggInfo {
  u8 directMode;

  u8 useSortingIdx;

  int sortingIdx;
  int sortingIdxPTab;
  int nSortingColumn;
  int mnReg, mxReg;
  ExprList *pGroupBy;
  struct AggInfo_col {
    Table *pTab;
    int iTable;
    int iColumn;
    int iSorterColumn;
    int iMem;
    Expr *pExpr;
  } *aCol;
  int nColumn;
  int nAccumulator;


  struct AggInfo_func {
    Expr *pExpr;
    FuncDef *pFunc;
    int iMem;
    int iDistinct;
  } *aFunc;
  int nFunc;
};
# 17413 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef i16 ynVar;
# 17481 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Expr {
  u8 op;
  char affExpr;
  u32 flags;
  union {
    char *zToken;
    int iValue;
  } u;






  Expr *pLeft;
  Expr *pRight;
  union {
    ExprList *pList;
    Select *pSelect;
  } x;







  int nHeight;

  int iTable;






  ynVar iColumn;


  i16 iAgg;
  i16 iRightJoinTable;
  u8 op2;


  AggInfo *pAggInfo;
  union {
    Table *pTab;

    Window *pWin;
    struct {
      int iAddr;
      int regReturn;
    } sub;
  } y;
};
# 17544 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define EP_FromJoin 0x000001
#define EP_Distinct 0x000002
#define EP_HasFunc 0x000004
#define EP_FixedCol 0x000008
#define EP_Agg 0x000010
#define EP_VarSelect 0x000020
#define EP_DblQuoted 0x000040
#define EP_InfixFunc 0x000080
#define EP_Collate 0x000100

#define EP_IntValue 0x000400
#define EP_xIsSelect 0x000800
#define EP_Skip 0x001000
#define EP_Reduced 0x002000
#define EP_TokenOnly 0x004000
#define EP_Win 0x008000
#define EP_MemToken 0x010000
#define EP_NoReduce 0x020000
#define EP_Unlikely 0x040000
#define EP_ConstFunc 0x080000
#define EP_CanBeNull 0x100000
#define EP_Subquery 0x200000
#define EP_Alias 0x400000
#define EP_Leaf 0x800000
#define EP_WinFunc 0x1000000
#define EP_Subrtn 0x2000000
#define EP_Quoted 0x4000000
#define EP_Static 0x8000000
#define EP_IsTrue 0x10000000
#define EP_IsFalse 0x20000000
#define EP_Indirect 0x40000000





#define EP_Propagate (EP_Collate|EP_Subquery|EP_HasFunc)





#define ExprHasProperty(E,P) (((E)->flags&(P))!=0)
#define ExprHasAllProperty(E,P) (((E)->flags&(P))==(P))
#define ExprSetProperty(E,P) (E)->flags|=(P)
#define ExprClearProperty(E,P) (E)->flags&=~(P)
#define ExprAlwaysTrue(E) (((E)->flags&(EP_FromJoin|EP_IsTrue))==EP_IsTrue)
#define ExprAlwaysFalse(E) (((E)->flags&(EP_FromJoin|EP_IsFalse))==EP_IsFalse)
# 17600 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ExprSetVVAProperty(E,P) 







#define EXPR_FULLSIZE sizeof(Expr)
#define EXPR_REDUCEDSIZE offsetof(Expr,iTable)
#define EXPR_TOKENONLYSIZE offsetof(Expr,pLeft)





#define EXPRDUP_REDUCE 0x0001
# 17625 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IsWindowFunc(p) ( ExprHasProperty((p), EP_WinFunc) && p->y.pWin->eFrmType!=TK_FILTER )
# 17646 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct ExprList {
  int nExpr;
  struct ExprList_item {
    Expr *pExpr;
    char *zName;
    char *zSpan;
    u8 sortFlags;
    unsigned done :1;
    unsigned bSpanIsTab :1;
    unsigned reusable :1;
    unsigned bSorterRef :1;
    unsigned bNulls: 1;
    union {
      struct {
        u16 iOrderByCol;
        u16 iAlias;
      } x;
      int iConstExprReg;
    } u;
  } a[1];
};
# 17683 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct IdList {
  struct IdList_item {
    char *zName;
    int idx;
  } *a;
  int nId;
};
# 17710 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct SrcList {
  int nSrc;
  u32 nAlloc;
  struct SrcList_item {
    Schema *pSchema;
    char *zDatabase;
    char *zName;
    char *zAlias;
    Table *pTab;
    Select *pSelect;
    int addrFillSub;
    int regReturn;
    int regResult;
    struct {
      u8 jointype;
      unsigned notIndexed :1;
      unsigned isIndexedBy :1;
      unsigned isTabFunc :1;
      unsigned isCorrelated :1;
      unsigned viaCoroutine :1;
      unsigned isRecursive :1;
    } fg;
    int iCursor;
    Expr *pOn;
    IdList *pUsing;
    Bitmask colUsed;
    union {
      char *zIndexedBy;
      ExprList *pFuncArg;
    } u1;
    Index *pIBIndex;
  } a[1];
};




#define JT_INNER 0x0001
#define JT_CROSS 0x0002
#define JT_NATURAL 0x0004
#define JT_LEFT 0x0008
#define JT_RIGHT 0x0010
#define JT_OUTER 0x0020
#define JT_ERROR 0x0040
# 17763 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WHERE_ORDERBY_NORMAL 0x0000
#define WHERE_ORDERBY_MIN 0x0001
#define WHERE_ORDERBY_MAX 0x0002
#define WHERE_ONEPASS_DESIRED 0x0004
#define WHERE_ONEPASS_MULTIROW 0x0008
#define WHERE_DUPLICATES_OK 0x0010
#define WHERE_OR_SUBCLAUSE 0x0020

#define WHERE_GROUPBY 0x0040
#define WHERE_DISTINCTBY 0x0080
#define WHERE_WANT_DISTINCT 0x0100
#define WHERE_SORTBYGROUP 0x0200
#define WHERE_SEEK_TABLE 0x0400
#define WHERE_ORDERBY_LIMIT 0x0800
#define WHERE_SEEK_UNIQ_TABLE 0x1000

#define WHERE_USE_LIMIT 0x4000




#define WHERE_DISTINCT_NOOP 0
#define WHERE_DISTINCT_UNIQUE 1
#define WHERE_DISTINCT_ORDERED 2
#define WHERE_DISTINCT_UNORDERED 3
# 17810 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct NameContext {
  Parse *pParse;
  SrcList *pSrcList;
  union {
    ExprList *pEList;
    AggInfo *pAggInfo;
    Upsert *pUpsert;
  } uNC;
  NameContext *pNext;
  int nRef;
  int nErr;
  int ncFlags;
  Select *pWinSelect;
};
# 17834 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define NC_AllowAgg 0x0001
#define NC_PartIdx 0x0002
#define NC_IsCheck 0x0004
#define NC_InAggFunc 0x0008
#define NC_HasAgg 0x0010
#define NC_IdxExpr 0x0020
#define NC_VarSelect 0x0040
#define NC_UEList 0x0080
#define NC_UAggInfo 0x0100
#define NC_UUpsert 0x0200
#define NC_MinMaxAgg 0x1000
#define NC_Complex 0x2000
#define NC_AllowWin 0x4000
#define NC_HasWin 0x8000
#define NC_IsDDL 0x10000
# 17864 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Upsert {
  ExprList *pUpsertTarget;
  Expr *pUpsertTargetWhere;
  ExprList *pUpsertSet;
  Expr *pUpsertWhere;




  Index *pUpsertIdx;
  SrcList *pUpsertSrc;
  int regData;
  int iDataCur;
  int iIdxCur;
};
# 17897 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Select {
  ExprList *pEList;
  u8 op;
  LogEst nSelectRow;
  u32 selFlags;
  int iLimit, iOffset;
  u32 selId;
  int addrOpenEphm[2];
  SrcList *pSrc;
  Expr *pWhere;
  ExprList *pGroupBy;
  Expr *pHaving;
  ExprList *pOrderBy;
  Select *pPrior;
  Select *pNext;
  Expr *pLimit;
  With *pWith;

  Window *pWin;
  Window *pWinDefn;

};
# 17929 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SF_Distinct 0x00001
#define SF_All 0x00002
#define SF_Resolved 0x00004
#define SF_Aggregate 0x00008
#define SF_HasAgg 0x00010
#define SF_UsesEphemeral 0x00020
#define SF_Expanded 0x00040
#define SF_HasTypeInfo 0x00080
#define SF_Compound 0x00100
#define SF_Values 0x00200
#define SF_MultiValue 0x00400
#define SF_NestedFrom 0x00800
#define SF_MinMaxAgg 0x01000
#define SF_Recursive 0x02000
#define SF_FixedLimit 0x04000
#define SF_MaybeConvert 0x08000
#define SF_Converted 0x10000
#define SF_IncludeHidden 0x20000
#define SF_ComplexResult 0x40000
#define SF_WhereBegin 0x80000
# 18014 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SRT_Union 1
#define SRT_Except 2
#define SRT_Exists 3
#define SRT_Discard 4
#define SRT_Fifo 5
#define SRT_DistFifo 6
#define SRT_Queue 7
#define SRT_DistQueue 8


#define IgnorableOrderby(X) ((X->eDest)<=SRT_DistQueue)

#define SRT_Output 9
#define SRT_Mem 10
#define SRT_Set 11
#define SRT_EphemTab 12
#define SRT_Coroutine 13
#define SRT_Table 14





struct SelectDest {
  u8 eDest;
  int iSDParm;
  int iSdst;
  int nSdst;
  char *zAffSdst;
  ExprList *pOrderBy;
};
# 18055 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct AutoincInfo {
  AutoincInfo *pNext;
  Table *pTab;
  int iDb;
  int regCtr;
};
# 18080 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct TriggerPrg {
  Trigger *pTrigger;
  TriggerPrg *pNext;
  SubProgram *pProgram;
  int orconf;
  u32 aColmask[2];
};
# 18099 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  typedef unsigned int yDbMask;
#define DbMaskTest(M,I) (((M)&(((yDbMask)1)<<(I)))!=0)
#define DbMaskZero(M) (M)=0
#define DbMaskSet(M,I) (M)|=(((yDbMask)1)<<(I))
#define DbMaskAllZero(M) (M)==0
#define DbMaskNonZero(M) (M)!=0
# 18123 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Parse {
  sqlite3 *db;
  char *zErrMsg;
  Vdbe *pVdbe;
  int rc;
  u8 colNamesSet;
  u8 checkSchema;
  u8 nested;
  u8 nTempReg;
  u8 isMultiWrite;
  u8 mayAbort;
  u8 hasCompound;
  u8 okConstFactor;
  u8 disableLookaside;
  u8 disableVtab;
  int nRangeReg;
  int iRangeReg;
  int nErr;
  int nTab;
  int nMem;
  int szOpAlloc;
  int iSelfTab;

  int nLabel;
  int nLabelAlloc;
  int *aLabel;
  ExprList *pConstExpr;
  Token constraintName;
  yDbMask writeMask;
  yDbMask cookieMask;
  int regRowid;
  int regRoot;
  int nMaxArg;
  int nSelect;

  int nTableLock;
  TableLock *aTableLock;

  AutoincInfo *pAinc;
  Parse *pToplevel;
  Table *pTriggerTab;
  Parse *pParentParse;
  int addrCrTab;
  u32 nQueryLoop;
  u32 oldmask;
  u32 newmask;
  u8 eTriggerOp;
  u8 eOrconf;
  u8 disableTriggers;
# 18180 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  int aTempReg[8];
  Token sNameToken;
# 18190 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  Token sLastToken;
  ynVar nVar;
  u8 iPkSortOrder;
  u8 explain;

  u8 eParseMode;


  int nVtabLock;

  int nHeight;

  int addrExplain;

  VList *pVList;
  Vdbe *pReprepare;
  const char *zTail;
  Table *pNewTable;
  Index *pNewIndex;


  Trigger *pNewTrigger;
  const char *zAuthContext;

  Token sArg;
  Table **apVtabLock;

  Table *pZombieTab;
  TriggerPrg *pTriggerPrg;
  With *pWith;
  With *pWithToFree;

  RenameToken *pRename;

};

#define PARSE_MODE_NORMAL 0
#define PARSE_MODE_DECLARE_VTAB 1
#define PARSE_MODE_RENAME_COLUMN 2
#define PARSE_MODE_RENAME_TABLE 3




#define PARSE_HDR_SZ offsetof(Parse,aTempReg)
#define PARSE_RECURSE_SZ offsetof(Parse,sLastToken)
#define PARSE_TAIL_SZ (sizeof(Parse)-PARSE_RECURSE_SZ)
#define PARSE_TAIL(X) (((char*)(X))+PARSE_RECURSE_SZ)







#define IN_DECLARE_VTAB (pParse->eParseMode==PARSE_MODE_DECLARE_VTAB)





#define IN_RENAME_OBJECT (pParse->eParseMode>=PARSE_MODE_RENAME_COLUMN)





#define IN_SPECIAL_PARSE (pParse->eParseMode!=PARSE_MODE_NORMAL)






struct AuthContext {
  const char *zAuthContext;
  Parse *pParse;
};
# 18281 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OPFLAG_NCHANGE 0x01

#define OPFLAG_NOCHNG 0x01
#define OPFLAG_EPHEM 0x01
#define OPFLAG_LASTROWID 0x20
#define OPFLAG_ISUPDATE 0x04
#define OPFLAG_APPEND 0x08
#define OPFLAG_USESEEKRESULT 0x10
#define OPFLAG_ISNOOP 0x40
#define OPFLAG_LENGTHARG 0x40
#define OPFLAG_TYPEOFARG 0x80
#define OPFLAG_BULKCSR 0x01
#define OPFLAG_SEEKEQ 0x02
#define OPFLAG_FORDELETE 0x08
#define OPFLAG_P2ISREG 0x10
#define OPFLAG_PERMUTE 0x01
#define OPFLAG_SAVEPOSITION 0x02
#define OPFLAG_AUXDELETE 0x04
#define OPFLAG_NOCHNG_MAGIC 0x6d
# 18316 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Trigger {
  char *zName;
  char *table;
  u8 op;
  u8 tr_tm;
  Expr *pWhen;
  IdList *pColumns;

  Schema *pSchema;
  Schema *pTabSchema;
  TriggerStep *step_list;
  Trigger *pNext;
};
# 18337 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TRIGGER_BEFORE 1
#define TRIGGER_AFTER 2
# 18378 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct TriggerStep {
  u8 op;
  u8 orconf;
  Trigger *pTrig;
  Select *pSelect;
  char *zTarget;
  Expr *pWhere;
  ExprList *pExprList;
  IdList *pIdList;
  Upsert *pUpsert;
  char *zSpan;
  TriggerStep *pNext;
  TriggerStep *pLast;
};






typedef struct DbFixer DbFixer;
struct DbFixer {
  Parse *pParse;
  Schema *pSchema;
  int bVarOnly;
  const char *zDb;
  const char *zType;
  const Token *pName;
};





struct sqlite3_str {
  sqlite3 *db;
  char *zText;
  u32 nAlloc;
  u32 mxAlloc;
  u32 nChar;
  u8 accError;
  u8 printfFlags;
};
#define SQLITE_PRINTF_INTERNAL 0x01
#define SQLITE_PRINTF_SQLFUNC 0x02
#define SQLITE_PRINTF_MALLOCED 0x04

#define isMalloced(X) (((X)->printfFlags & SQLITE_PRINTF_MALLOCED)!=0)






typedef struct {
  sqlite3 *db;
  char **pzErrMsg;
  int iDb;
  int rc;
  u32 mInitFlags;
  u32 nInitRow;
} InitData;




#define INITFLAG_AlterTable 0x0001






struct Sqlite3Config {
  int bMemstat;
  u8 bCoreMutex;
  u8 bFullMutex;
  u8 bOpenUri;
  u8 bUseCis;
  u8 bSmallMalloc;
  u8 bExtraSchemaChecks;
  int mxStrlen;
  int neverCorrupt;
  int szLookaside;
  int nLookaside;
  int nStmtSpill;
  sqlite3_mem_methods m;
  sqlite3_mutex_methods mutex;
  sqlite3_pcache_methods2 pcache2;
  void *pHeap;
  int nHeap;
  int mnReq, mxReq;
  sqlite3_int64 szMmap;
  sqlite3_int64 mxMmap;
  void *pPage;
  int szPage;
  int nPage;
  int mxParserStack;
  int sharedCacheEnabled;
  u32 szPma;


  int isInit;
  int inProgress;
  int isMutexInit;
  int isMallocInit;
  int isPCacheInit;
  int nRefInitMutex;
  sqlite3_mutex *pInitMutex;
  void (*xLog)(void*,int,const char*);
  void *pLogArg;
# 18504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  int (*xTestCallback)(int);

  int bLocaltimeFault;
  int bInternalFunctions;
  int iOnceResetThreshold;
  u32 szSorterRef;
  unsigned int iPrngSeed;
};
# 18529 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define CORRUPT_DB (sqlite3Config.neverCorrupt==0)




struct Walker {
  Parse *pParse;
  int (*xExprCallback)(Walker*, Expr*);
  int (*xSelectCallback)(Walker*,Select*);
  void (*xSelectCallback2)(Walker*,Select*);
  int walkerDepth;
  u8 eCode;
  union {
    NameContext *pNC;
    int n;
    int iCur;
    SrcList *pSrcList;
    struct SrcCount *pSrcCount;
    struct CCurHint *pCCurHint;
    int *aiCol;
    struct IdxCover *pIdxCover;
    struct IdxExprTrans *pIdxTrans;
    ExprList *pGroupBy;
    Select *pSelect;
    struct WindowRewrite *pRewrite;
    struct WhereConst *pConst;
    struct RenameCtx *pRename;
  } u;
};


static int sqlite3WalkExpr(Walker*, Expr*);
static int sqlite3WalkExprList(Walker*, ExprList*);
static int sqlite3WalkSelect(Walker*, Select*);
static int sqlite3WalkSelectExpr(Walker*, Select*);
static int sqlite3WalkSelectFrom(Walker*, Select*);
static int sqlite3ExprWalkNoop(Walker*, Expr*);
static int sqlite3SelectWalkNoop(Walker*, Select*);
static int sqlite3SelectWalkFail(Walker*, Select*);
# 18576 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WRC_Continue 0
#define WRC_Prune 1
#define WRC_Abort 2





struct With {
  int nCte;
  With *pOuter;
  struct Cte {
    char *zName;
    ExprList *pCols;
    Select *pSelect;
    const char *zCteErr;
  } a[1];
};
# 18629 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Window {
  char *zName;
  char *zBase;
  ExprList *pPartition;
  ExprList *pOrderBy;
  u8 eFrmType;
  u8 eStart;
  u8 eEnd;
  u8 bImplicitFrame;
  u8 eExclude;
  Expr *pStart;
  Expr *pEnd;
  Window **ppThis;
  Window *pNextWin;
  Expr *pFilter;
  FuncDef *pFunc;
  int iEphCsr;
  int regAccum;
  int regResult;
  int csrApp;
  int regApp;
  int regPart;
  Expr *pOwner;
  int nBufferCol;
  int iArgCol;
  int regOne;
  int regStartRowid;
  int regEndRowid;
  u8 bExprArgs;

};


static void sqlite3WindowDelete(sqlite3*, Window*);
static void sqlite3WindowUnlinkFromSelect(Window*);
static void sqlite3WindowListDelete(sqlite3 *db, Window *p);
static Window *sqlite3WindowAlloc(Parse*, int, int, Expr*, int , Expr*, u8);
static void sqlite3WindowAttach(Parse*, Expr*, Window*);
static void sqlite3WindowLink(Select *pSel, Window *pWin);
static int sqlite3WindowCompare(Parse*, Window*, Window*, int);
static void sqlite3WindowCodeInit(Parse*, Window*);
static void sqlite3WindowCodeStep(Parse*, Select*, WhereInfo*, int, int);
static int sqlite3WindowRewrite(Parse*, Select*);
static int sqlite3ExpandSubquery(Parse*, struct SrcList_item*);
static void sqlite3WindowUpdate(Parse*, Window*, Window*, FuncDef*);
static Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p);
static Window *sqlite3WindowListDup(sqlite3 *db, Window *p);
static void sqlite3WindowFunctions(void);
static void sqlite3WindowChain(Parse*, Window*, Window*);
static Window *sqlite3WindowAssemble(Parse*, Window*, ExprList*, ExprList*, Token*);
# 18689 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SKIP_UTF8(zIn) { if( (*(zIn++))>=0xc0 ){ while( (*zIn & 0xc0)==0x80 ){ zIn++; } } }
# 18702 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ReportError(int iErr, int lineno, const char *zType);
static int sqlite3CorruptError(int);
static int sqlite3MisuseError(int);
static int sqlite3CantopenError(int);
#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)
#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)
#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)
# 18717 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_NOMEM_BKPT SQLITE_NOMEM
#define SQLITE_IOERR_NOMEM_BKPT SQLITE_IOERR_NOMEM
#define SQLITE_CORRUPT_PGNO(P) sqlite3CorruptError(__LINE__)
# 18754 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqlite3Toupper(x) ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))
#define sqlite3Isspace(x) (sqlite3CtypeMap[(unsigned char)(x)]&0x01)
#define sqlite3Isalnum(x) (sqlite3CtypeMap[(unsigned char)(x)]&0x06)
#define sqlite3Isalpha(x) (sqlite3CtypeMap[(unsigned char)(x)]&0x02)
#define sqlite3Isdigit(x) (sqlite3CtypeMap[(unsigned char)(x)]&0x04)
#define sqlite3Isxdigit(x) (sqlite3CtypeMap[(unsigned char)(x)]&0x08)
#define sqlite3Tolower(x) (sqlite3UpperToLower[(unsigned char)(x)])
#define sqlite3Isquote(x) (sqlite3CtypeMap[(unsigned char)(x)]&0x80)
# 18772 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3IsIdChar(u8);




static int sqlite3StrICmp(const char*,const char*);
static int sqlite3Strlen30(const char*);
#define sqlite3Strlen30NN(C) (strlen(C)&0x3fffffff)
static char *sqlite3ColumnType(Column*,char*);
#define sqlite3StrNICmp sqlite3_strnicmp

static int sqlite3MallocInit(void);
static void sqlite3MallocEnd(void);
static void *sqlite3Malloc(u64);
static void *sqlite3MallocZero(u64);
static void *sqlite3DbMallocZero(sqlite3*, u64);
static void *sqlite3DbMallocRaw(sqlite3*, u64);
static void *sqlite3DbMallocRawNN(sqlite3*, u64);
static char *sqlite3DbStrDup(sqlite3*,const char*);
static char *sqlite3DbStrNDup(sqlite3*,const char*, u64);
static char *sqlite3DbSpanDup(sqlite3*,const char*,const char*);
static void *sqlite3Realloc(void*, u64);
static void *sqlite3DbReallocOrFree(sqlite3 *, void *, u64);
static void *sqlite3DbRealloc(sqlite3 *, void *, u64);
static void sqlite3DbFree(sqlite3*, void*);
static void sqlite3DbFreeNN(sqlite3*, void*);
static int sqlite3MallocSize(void*);
static int sqlite3DbMallocSize(sqlite3*, void*);
static void *sqlite3PageMalloc(int);
static void sqlite3PageFree(void*);
static void sqlite3MemSetDefault(void);

static void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));

static int sqlite3HeapNearlyFull(void);
# 18821 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqlite3StackAllocRaw(D,N) sqlite3DbMallocRaw(D,N)
#define sqlite3StackAllocZero(D,N) sqlite3DbMallocZero(D,N)
#define sqlite3StackFree(D,P) sqlite3DbFree(D,P)
# 18839 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_mutex_methods const *sqlite3DefaultMutex(void);
static sqlite3_mutex_methods const *sqlite3NoopMutex(void);
static sqlite3_mutex *sqlite3MutexAlloc(int);
static int sqlite3MutexInit(void);
static int sqlite3MutexEnd(void);


static void sqlite3MemoryBarrier(void);




static sqlite3_int64 sqlite3StatusValue(int);
static void sqlite3StatusUp(int, int);
static void sqlite3StatusDown(int, int);
static void sqlite3StatusHighwater(int, int);
static int sqlite3LookasideUsed(sqlite3*,int*);


static sqlite3_mutex *sqlite3Pcache1Mutex(void);
static sqlite3_mutex *sqlite3MallocMutex(void);




#define sqlite3MutexWarnOnContention(x) 



#define EXP754 (((u64)0x7ff)<<52)
#define MAN754 ((((u64)1)<<52)-1)
#define IsNaN(X) (((X)&EXP754)==EXP754 && ((X)&MAN754)!=0)
static int sqlite3IsNaN(double);
# 18881 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct PrintfArguments {
  int nArg;
  int nUsed;
  sqlite3_value **apArg;
};

static char *sqlite3MPrintf(sqlite3*,const char*, ...);
static char *sqlite3VMPrintf(sqlite3*,const char*, va_list);
# 18910 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SetString(char **, sqlite3*, const char*);
static void sqlite3ErrorMsg(Parse*, const char*, ...);
static int sqlite3ErrorToParser(sqlite3*,int);
static void sqlite3Dequote(char*);
static void sqlite3DequoteExpr(Expr*);
static void sqlite3TokenInit(Token*,char*);
static int sqlite3KeywordCode(const unsigned char*, int);
static int sqlite3RunParser(Parse*, const char*, char **);
static void sqlite3FinishCoding(Parse*);
static int sqlite3GetTempReg(Parse*);
static void sqlite3ReleaseTempReg(Parse*,int);
static int sqlite3GetTempRange(Parse*,int);
static void sqlite3ReleaseTempRange(Parse*,int,int);
static void sqlite3ClearTempRegCache(Parse*);



static Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);
static Expr *sqlite3Expr(sqlite3*,int,const char*);
static void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);
static Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*);
static void sqlite3PExprAddSelect(Parse*, Expr*, Select*);
static Expr *sqlite3ExprAnd(Parse*,Expr*, Expr*);
static Expr *sqlite3ExprSimplifiedAndOr(Expr*);
static Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*, int);
static void sqlite3ExprAssignVarNumber(Parse*, Expr*, u32);
static void sqlite3ExprDelete(sqlite3*, Expr*);
static void sqlite3ExprUnmapAndDelete(Parse*, Expr*);
static ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);
static ExprList *sqlite3ExprListAppendVector(Parse*,ExprList*,IdList*,Expr*);
static void sqlite3ExprListSetSortOrder(ExprList*,int,int);
static void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);
static void sqlite3ExprListSetSpan(Parse*,ExprList*,const char*,const char*);
static void sqlite3ExprListDelete(sqlite3*, ExprList*);
static u32 sqlite3ExprListFlags(const ExprList*);
static int sqlite3IndexHasDuplicateRootPage(Index*);
static int sqlite3Init(sqlite3*, char**);
static int sqlite3InitCallback(void*, int, char**, char**);
static int sqlite3InitOne(sqlite3*, int, char**, u32);
static void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);

static Module *sqlite3PragmaVtabRegister(sqlite3*,const char *zName);

static void sqlite3ResetAllSchemasOfConnection(sqlite3*);
static void sqlite3ResetOneSchema(sqlite3*,int);
static void sqlite3CollapseDatabaseArray(sqlite3*);
static void sqlite3CommitInternalChanges(sqlite3*);
static void sqlite3DeleteColumnNames(sqlite3*,Table*);
static int sqlite3ColumnsFromExprList(Parse*,ExprList*,i16*,Column**);
static void sqlite3SelectAddColumnTypeAndCollation(Parse*,Table*,Select*,char);
static Table *sqlite3ResultSetOfSelect(Parse*,Select*,char);
static void sqlite3OpenMasterTable(Parse *, int);
static Index *sqlite3PrimaryKeyIndex(Table*);
static i16 sqlite3ColumnOfIndex(Index*, i16);
static void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);



#define sqlite3ColumnPropertiesFromName(T,C) 

static void sqlite3AddColumn(Parse*,Token*,Token*);
static void sqlite3AddNotNull(Parse*, int);
static void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);
static void sqlite3AddCheckConstraint(Parse*, Expr*);
static void sqlite3AddDefaultValue(Parse*,Expr*,const char*,const char*);
static void sqlite3AddCollateType(Parse*, Token*);
static void sqlite3EndTable(Parse*,Token*,Token*,u8,Select*);
static int sqlite3ParseUri(const char*,const char*,unsigned int*,
                    sqlite3_vfs**,char**,char **);



#define sqlite3CodecQueryParameters(A,B,C) 0

static Btree *sqlite3DbNameToBtree(sqlite3*,const char*);




static int sqlite3FaultSim(int);


static Bitvec *sqlite3BitvecCreate(u32);
static int sqlite3BitvecTest(Bitvec*, u32);
static int sqlite3BitvecTestNotNull(Bitvec*, u32);
static int sqlite3BitvecSet(Bitvec*, u32);
static void sqlite3BitvecClear(Bitvec*, u32, void*);
static void sqlite3BitvecDestroy(Bitvec*);
static u32 sqlite3BitvecSize(Bitvec*);

static int sqlite3BitvecBuiltinTest(int,int*);


static RowSet *sqlite3RowSetInit(sqlite3*);
static void sqlite3RowSetDelete(void*);
static void sqlite3RowSetClear(void*);
static void sqlite3RowSetInsert(RowSet*, i64);
static int sqlite3RowSetTest(RowSet*, int iBatch, i64);
static int sqlite3RowSetNext(RowSet*, i64*);

static void sqlite3CreateView(Parse*,Token*,Token*,Token*,ExprList*,Select*,int,int);


static int sqlite3ViewGetColumnNames(Parse*,Table*);







static void sqlite3DropTable(Parse*, SrcList*, int, int);
static void sqlite3CodeDropTable(Parse*, Table*, int, int);
static void sqlite3DeleteTable(sqlite3*, Table*);
static void sqlite3FreeIndex(sqlite3*, Index*);

static void sqlite3AutoincrementBegin(Parse *pParse);
static void sqlite3AutoincrementEnd(Parse *pParse);




static void sqlite3Insert(Parse*, SrcList*, Select*, IdList*, int, Upsert*);
static void *sqlite3ArrayAllocate(sqlite3*,void*,int,int*,int*);
static IdList *sqlite3IdListAppend(Parse*, IdList*, Token*);
static int sqlite3IdListIndex(IdList*,const char*);
static SrcList *sqlite3SrcListEnlarge(Parse*, SrcList*, int, int);
static SrcList *sqlite3SrcListAppend(Parse*, SrcList*, Token*, Token*);
static SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,
                                      Token*, Select*, Expr*, IdList*);
static void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);
static void sqlite3SrcListFuncArgs(Parse*, SrcList*, ExprList*);
static int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);
static void sqlite3SrcListShiftJoinType(SrcList*);
static void sqlite3SrcListAssignCursors(Parse*, SrcList*);
static void sqlite3IdListDelete(sqlite3*, IdList*);
static void sqlite3SrcListDelete(sqlite3*, SrcList*);
static Index *sqlite3AllocateIndexObject(sqlite3*,i16,int,char**);
static void sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,
                          Expr*, int, int, u8);
static void sqlite3DropIndex(Parse*, SrcList*, int);
static int sqlite3Select(Parse*, Select*, SelectDest*);
static Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,
                         Expr*,ExprList*,u32,Expr*);
static void sqlite3SelectDelete(sqlite3*, Select*);
static Table *sqlite3SrcListLookup(Parse*, SrcList*);
static int sqlite3IsReadOnly(Parse*, Table*, int);
static void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);



static void sqlite3DeleteFrom(Parse*, SrcList*, Expr*, ExprList*, Expr*);
static void sqlite3Update(Parse*, SrcList*, ExprList*,Expr*,int,ExprList*,Expr*,
                   Upsert*);
static WhereInfo *sqlite3WhereBegin(Parse*,SrcList*,Expr*,ExprList*,ExprList*,u16,int);
static void sqlite3WhereEnd(WhereInfo*);
static LogEst sqlite3WhereOutputRowCount(WhereInfo*);
static int sqlite3WhereIsDistinct(WhereInfo*);
static int sqlite3WhereIsOrdered(WhereInfo*);
static int sqlite3WhereOrderByLimitOptLabel(WhereInfo*);
static int sqlite3WhereIsSorted(WhereInfo*);
static int sqlite3WhereContinueLabel(WhereInfo*);
static int sqlite3WhereBreakLabel(WhereInfo*);
static int sqlite3WhereOkOnePass(WhereInfo*, int*);
#define ONEPASS_OFF 0
#define ONEPASS_SINGLE 1
#define ONEPASS_MULTI 2
static void sqlite3ExprCodeLoadIndexColumn(Parse*, Index*, int, int, int);
static int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int, u8);
static void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);
static void sqlite3ExprCodeMove(Parse*, int, int, int);
static void sqlite3ExprCode(Parse*, Expr*, int);
static void sqlite3ExprCodeCopy(Parse*, Expr*, int);
static void sqlite3ExprCodeFactorable(Parse*, Expr*, int);
static int sqlite3ExprCodeAtInit(Parse*, Expr*, int);
static int sqlite3ExprCodeTemp(Parse*, Expr*, int*);
static int sqlite3ExprCodeTarget(Parse*, Expr*, int);
static void sqlite3ExprCodeAndCache(Parse*, Expr*, int);
static int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int, u8);
#define SQLITE_ECEL_DUP 0x01
#define SQLITE_ECEL_FACTOR 0x02
#define SQLITE_ECEL_REF 0x04
#define SQLITE_ECEL_OMITREF 0x08
static void sqlite3ExprIfTrue(Parse*, Expr*, int, int);
static void sqlite3ExprIfFalse(Parse*, Expr*, int, int);
static void sqlite3ExprIfFalseDup(Parse*, Expr*, int, int);
static Table *sqlite3FindTable(sqlite3*,const char*, const char*);
#define LOCATE_VIEW 0x01
#define LOCATE_NOERR 0x02
static Table *sqlite3LocateTable(Parse*,u32 flags,const char*, const char*);
static Table *sqlite3LocateTableItem(Parse*,u32 flags,struct SrcList_item *);
static Index *sqlite3FindIndex(sqlite3*,const char*, const char*);
static void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);
static void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);
static void sqlite3Vacuum(Parse*,Token*,Expr*);
static int sqlite3RunVacuum(char**, sqlite3*, int, sqlite3_value*);
static char *sqlite3NameFromToken(sqlite3*, Token*);
static int sqlite3ExprCompare(Parse*,Expr*, Expr*, int);
static int sqlite3ExprCompareSkip(Expr*, Expr*, int);
static int sqlite3ExprListCompare(ExprList*, ExprList*, int);
static int sqlite3ExprImpliesExpr(Parse*,Expr*, Expr*, int);
static int sqlite3ExprImpliesNonNullRow(Expr*,int);
static void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);
static void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);
static int sqlite3ExprCoveredByIndex(Expr*, int iCur, Index *pIdx);
static int sqlite3FunctionUsesThisSrc(Expr*, SrcList*);
static Vdbe *sqlite3GetVdbe(Parse*);

static void sqlite3PrngSaveState(void);
static void sqlite3PrngRestoreState(void);

static void sqlite3RollbackAll(sqlite3*,int);
static void sqlite3CodeVerifySchema(Parse*, int);
static void sqlite3CodeVerifyNamedSchema(Parse*, const char *zDb);
static void sqlite3BeginTransaction(Parse*, int);
static void sqlite3EndTransaction(Parse*,int);
static void sqlite3Savepoint(Parse*, int, Token*);
static void sqlite3CloseSavepoints(sqlite3 *);
static void sqlite3LeaveMutexAndCloseZombie(sqlite3*);
static int sqlite3ExprIdToTrueFalse(Expr*);
static int sqlite3ExprTruthValue(const Expr*);
static int sqlite3ExprIsConstant(Expr*);
static int sqlite3ExprIsConstantNotJoin(Expr*);
static int sqlite3ExprIsConstantOrFunction(Expr*, u8);
static int sqlite3ExprIsConstantOrGroupBy(Parse*, Expr*, ExprList*);
static int sqlite3ExprIsTableConstant(Expr*,int);



static int sqlite3ExprIsInteger(Expr*, int*);
static int sqlite3ExprCanBeNull(const Expr*);
static int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);
static int sqlite3IsRowid(const char*);
static void sqlite3GenerateRowDelete(
    Parse*,Table*,Trigger*,int,int,int,i16,u8,u8,u8,int);
static void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int, int*, int);
static int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int, int*,Index*,int);
static void sqlite3ResolvePartIdxLabel(Parse*,int);
static int sqlite3ExprReferencesUpdatedColumn(Expr*,int*,int);
static void sqlite3GenerateConstraintChecks(Parse*,Table*,int*,int,int,int,int,
                                     u8,u8,int,int*,int*,Upsert*);



#define sqlite3SetMakeRecordP5(A,B) 

static void sqlite3CompleteInsertion(Parse*,Table*,int,int,int,int*,int,int,int);
static int sqlite3OpenTableAndIndices(Parse*, Table*, int, u8, int, u8*, int*, int*);
static void sqlite3BeginWriteOperation(Parse*, int, int);
static void sqlite3MultiWrite(Parse*);
static void sqlite3MayAbort(Parse*);
static void sqlite3HaltConstraint(Parse*, int, int, char*, i8, u8);
static void sqlite3UniqueConstraint(Parse*, int, Index*);
static void sqlite3RowidConstraint(Parse*, int, Table*);
static Expr *sqlite3ExprDup(sqlite3*,Expr*,int);
static ExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);
static SrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);
static IdList *sqlite3IdListDup(sqlite3*,IdList*);
static Select *sqlite3SelectDup(sqlite3*,Select*,int);
static FuncDef *sqlite3FunctionSearch(int,const char*);
static void sqlite3InsertBuiltinFuncs(FuncDef*,int);
static FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,u8,u8);
static void sqlite3RegisterBuiltinFunctions(void);
static void sqlite3RegisterDateTimeFunctions(void);
static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3*);
static int sqlite3SafetyCheckOk(sqlite3*);
static int sqlite3SafetyCheckSickOrOk(sqlite3*);
static void sqlite3ChangeCookie(Parse*, int);


static void sqlite3MaterializeView(Parse*, Table*, Expr*, ExprList*,Expr*,int);



static void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,
                           Expr*,int, int);
static void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);
static void sqlite3DropTrigger(Parse*, SrcList*, int);
static void sqlite3DropTriggerPtr(Parse*, Trigger*);
static Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);
static Trigger *sqlite3TriggerList(Parse *, Table *);
static void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,
                            int, int, int);
static void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);
  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);
static void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);
static TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*,
                                        const char*,const char*);
static TriggerStep *sqlite3TriggerInsertStep(Parse*,Token*, IdList*,
                                        Select*,u8,Upsert*,
                                        const char*,const char*);
static TriggerStep *sqlite3TriggerUpdateStep(Parse*,Token*,ExprList*, Expr*, u8,
                                        const char*,const char*);
static TriggerStep *sqlite3TriggerDeleteStep(Parse*,Token*, Expr*,
                                        const char*,const char*);
static void sqlite3DeleteTrigger(sqlite3*, Trigger*);
static void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);
static u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);
#define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))
#define sqlite3IsToplevel(p) ((p)->pToplevel==0)
# 19223 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3JoinType(Parse*, Token*, Token*, Token*);
static void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);
static void sqlite3DeferForeignKey(Parse*, int);

static void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);
static int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);
static void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);
static void sqlite3AuthContextPop(AuthContext*);
static int sqlite3AuthReadCol(Parse*, const char *, const char *, int);






static void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);
static void sqlite3Detach(Parse*, Expr*);
static void sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);
static int sqlite3FixSrcList(DbFixer*, SrcList*);
static int sqlite3FixSelect(DbFixer*, Select*);
static int sqlite3FixExpr(DbFixer*, Expr*);
static int sqlite3FixExprList(DbFixer*, ExprList*);
static int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);
static int sqlite3RealSameAsInt(double,sqlite3_int64);
static int sqlite3AtoF(const char *z, double*, int, u8);
static int sqlite3GetInt32(const char *, int*);
static int sqlite3Atoi(const char*);

static int sqlite3Utf16ByteLen(const void *pData, int nChar);

static int sqlite3Utf8CharLen(const char *pData, int nByte);
static u32 sqlite3Utf8Read(const u8**);
static LogEst sqlite3LogEst(u64);
static LogEst sqlite3LogEstAdd(LogEst,LogEst);

static LogEst sqlite3LogEstFromDouble(double);






static VList *sqlite3VListAdd(sqlite3*,VList*,const char*,int,int);
static const char *sqlite3VListNumToName(VList*,int);
static int sqlite3VListNameToNum(VList*,const char*,int);






static int sqlite3PutVarint(unsigned char*, u64);
static u8 sqlite3GetVarint(const unsigned char *, u64 *);
static u8 sqlite3GetVarint32(const unsigned char *, u32 *);
static int sqlite3VarintLen(u64 v);






#define getVarint32(A,B) (u8)((*(A)<(u8)0x80)?((B)=(u32)*(A)),1:sqlite3GetVarint32((A),(u32 *)&(B)))

#define putVarint32(A,B) (u8)(((u32)(B)<(u32)0x80)?(*(A)=(unsigned char)(B)),1: sqlite3PutVarint((A),(B)))


#define getVarint sqlite3GetVarint
#define putVarint sqlite3PutVarint


static const char *sqlite3IndexAffinityStr(sqlite3*, Index*);
static void sqlite3TableAffinity(Vdbe*, Table*, int);
static char sqlite3CompareAffinity(Expr *pExpr, char aff2);
static int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);
static char sqlite3TableColumnAffinity(Table*,int);
static char sqlite3ExprAffinity(Expr *pExpr);
static int sqlite3Atoi64(const char*, i64*, int, u8);
static int sqlite3DecOrHexToI64(const char*, i64*);
static void sqlite3ErrorWithMsg(sqlite3*, int, const char*,...);
static void sqlite3Error(sqlite3*,int);
static void sqlite3SystemError(sqlite3*,int);
static void *sqlite3HexToBlob(sqlite3*, const char *z, int n);
static u8 sqlite3HexToInt(int h);
static int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);
# 19316 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *sqlite3ErrStr(int);
static int sqlite3ReadSchema(Parse *pParse);
static CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);
static int sqlite3IsBinary(const CollSeq*);
static CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);
static CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);
static CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr);
static int sqlite3ExprCollSeqMatch(Parse*,Expr*,Expr*);
static Expr *sqlite3ExprAddCollateToken(Parse *pParse, Expr*, const Token*, int);
static Expr *sqlite3ExprAddCollateString(Parse*,Expr*,const char*);
static Expr *sqlite3ExprSkipCollate(Expr*);
static Expr *sqlite3ExprSkipCollateAndLikely(Expr*);
static int sqlite3CheckCollSeq(Parse *, CollSeq *);
static int sqlite3WritableSchema(sqlite3*);
static int sqlite3CheckObjectName(Parse*, const char*,const char*,const char*);
static void sqlite3VdbeSetChanges(sqlite3 *, int);
static int sqlite3AddInt64(i64*,i64);
static int sqlite3SubInt64(i64*,i64);
static int sqlite3MulInt64(i64*,i64);
static int sqlite3AbsInt32(int);



#define sqlite3FileSuffix3(X,Y) 

static u8 sqlite3GetBoolean(const char *z,u8);

static const void *sqlite3ValueText(sqlite3_value*, u8);
static int sqlite3ValueBytes(sqlite3_value*, u8);
static void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8,
                        void(*)(void*));
static void sqlite3ValueSetNull(sqlite3_value*);
static void sqlite3ValueFree(sqlite3_value*);

static void sqlite3ResultIntReal(sqlite3_context*);

static sqlite3_value *sqlite3ValueNew(sqlite3 *);

static char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);

static int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);
static void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);
# 19372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3RootPageMoved(sqlite3*, int, int, int);
static void sqlite3Reindex(Parse*, Token*, Token*);
static void sqlite3AlterFunctions(void);
static void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);
static void sqlite3AlterRenameColumn(Parse*, SrcList*, Token*, Token*);
static int sqlite3GetToken(const unsigned char *, int *);
static void sqlite3NestedParse(Parse*, const char*, ...);
static void sqlite3ExpirePreparedStatements(sqlite3*, int);
static void sqlite3CodeRhsOfIN(Parse*, Expr*, int);
static int sqlite3CodeSubselect(Parse*, Expr*);
static void sqlite3SelectPrep(Parse*, Select*, NameContext*);
static void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p);
static int sqlite3MatchSpanName(const char*, const char*, const char*, const char*);
static int sqlite3ResolveExprNames(NameContext*, Expr*);
static int sqlite3ResolveExprListNames(NameContext*, ExprList*);
static void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);
static int sqlite3ResolveSelfReference(Parse*,Table*,int,Expr*,ExprList*);
static int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);
static void sqlite3ColumnDefault(Vdbe *, Table *, int, int);
static void sqlite3AlterFinishAddColumn(Parse *, Token *);
static void sqlite3AlterBeginAddColumn(Parse *, SrcList *);
static void *sqlite3RenameTokenMap(Parse*, void*, Token*);
static void sqlite3RenameTokenRemap(Parse*, void *pTo, void *pFrom);
static void sqlite3RenameExprUnmap(Parse*, Expr*);
static void sqlite3RenameExprlistUnmap(Parse*, ExprList*);
static CollSeq *sqlite3GetCollSeq(Parse*, u8, CollSeq *, const char*);
static char sqlite3AffinityType(const char*, Column*);
static void sqlite3Analyze(Parse*, Token*, Token*);
static int sqlite3InvokeBusyHandler(BusyHandler*, sqlite3_file*);
static int sqlite3FindDb(sqlite3*, Token*);
static int sqlite3FindDbName(sqlite3 *, const char *);
static int sqlite3AnalysisLoad(sqlite3*,int iDB);
static void sqlite3DeleteIndexSamples(sqlite3*,Index*);
static void sqlite3DefaultRowEst(Index*);
static void sqlite3RegisterLikeFunctions(sqlite3*, int);
static int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);
static void sqlite3SchemaClear(void *);
static Schema *sqlite3SchemaGet(sqlite3 *, Btree *);
static int sqlite3SchemaToIndex(sqlite3 *db, Schema *);
static KeyInfo *sqlite3KeyInfoAlloc(sqlite3*,int,int);
static void sqlite3KeyInfoUnref(KeyInfo*);
static KeyInfo *sqlite3KeyInfoRef(KeyInfo*);
static KeyInfo *sqlite3KeyInfoOfIndex(Parse*, Index*);
static KeyInfo *sqlite3KeyInfoFromExprList(Parse*, ExprList*, int, int);
static int sqlite3HasExplicitNulls(Parse*, ExprList*);




static int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *,
  void (*)(sqlite3_context*,int,sqlite3_value **),
  void (*)(sqlite3_context*,int,sqlite3_value **),
  void (*)(sqlite3_context*),
  void (*)(sqlite3_context*),
  void (*)(sqlite3_context*,int,sqlite3_value **),
  FuncDestructor *pDestructor
);
static void sqlite3NoopDestructor(void*);
static void sqlite3OomFault(sqlite3*);
static void sqlite3OomClear(sqlite3*);
static int sqlite3ApiExit(sqlite3 *db, int);
static int sqlite3OpenTempDatabase(Parse *);

static void sqlite3StrAccumInit(StrAccum*, sqlite3*, char*, int, int);
static char *sqlite3StrAccumFinish(StrAccum*);
static void sqlite3SelectDestInit(SelectDest*,int,int);
static Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);

static void sqlite3BackupRestart(sqlite3_backup *);
static void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);


static int sqlite3ExprCheckIN(Parse*, Expr*);
# 19465 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Parser(void*, int, Token);
static int sqlite3ParserFallback(int);




static void sqlite3AutoLoadExtensions(sqlite3*);

static void sqlite3CloseExtensions(sqlite3*);





static void sqlite3TableLock(Parse *, int, int, u8, const char *);
# 19501 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VtabClear(sqlite3 *db, Table*);
static void sqlite3VtabDisconnect(sqlite3 *db, Table *p);
static int sqlite3VtabSync(sqlite3 *db, Vdbe*);
static int sqlite3VtabRollback(sqlite3 *db);
static int sqlite3VtabCommit(sqlite3 *db);
static void sqlite3VtabLock(VTable *);
static void sqlite3VtabUnlock(VTable *);
static void sqlite3VtabModuleUnref(sqlite3*,Module*);
static void sqlite3VtabUnlockList(sqlite3*);
static int sqlite3VtabSavepoint(sqlite3 *, int, int);
static void sqlite3VtabImportErrmsg(Vdbe*, sqlite3_vtab*);
static VTable *sqlite3GetVTable(sqlite3*, Table*);
static Module *sqlite3VtabCreateModule(
     sqlite3*,
     const char*,
     const sqlite3_module*,
     void*,
     void(*)(void*)
   );
#define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)

static int sqlite3VtabEponymousTableInit(Parse*,Module*);
static void sqlite3VtabEponymousTableClear(sqlite3*,Module*);
static void sqlite3VtabMakeWritable(Parse*,Table*);
static void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*, int);
static void sqlite3VtabFinishParse(Parse*, Token*);
static void sqlite3VtabArgInit(Parse*);
static void sqlite3VtabArgExtend(Parse*, Token*);
static int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);
static int sqlite3VtabCallConnect(Parse*, Table*);
static int sqlite3VtabCallDestroy(sqlite3*, int, const char *);
static int sqlite3VtabBegin(sqlite3 *, VTable *);
static FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);
static sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context*);
static int sqlite3VdbeParameterIndex(Vdbe*, const char*, int);
static int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);
static void sqlite3ParserReset(Parse*);



static int sqlite3Reprepare(Vdbe*);
static void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);
static CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);
static int sqlite3TempInMemory(const sqlite3*);
static const char *sqlite3JournalModename(int);

static int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);
static int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);


static With *sqlite3WithAdd(Parse*,With*,Token*,ExprList*,Select*);
static void sqlite3WithDelete(sqlite3*,With*);
static void sqlite3WithPush(Parse*, With*, u8);





static Upsert *sqlite3UpsertNew(sqlite3*,ExprList*,Expr*,ExprList*,Expr*);
static void sqlite3UpsertDelete(sqlite3*,Upsert*);
static Upsert *sqlite3UpsertDup(sqlite3*,Upsert*);
static int sqlite3UpsertAnalyzeTarget(Parse*,SrcList*,Upsert*);
static void sqlite3UpsertDoUpdate(Parse*,Upsert*,Table*,Index*,int);
# 19579 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3FkCheck(Parse*, Table*, int, int, int*, int);
static void sqlite3FkDropTable(Parse*, SrcList *, Table*);
static void sqlite3FkActions(Parse*, Table*, ExprList*, int, int*, int);
static int sqlite3FkRequired(Parse*, Table*, int*, int);
static u32 sqlite3FkOldmask(Parse*, Table*);
static FKey *sqlite3FkReferences(Table *);
# 19594 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3FkDelete(sqlite3 *, Table*);
static int sqlite3FkLocateIndex(Parse*,Table*,FKey*,Index**,int**);
# 19605 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_FAULTINJECTOR_MALLOC 0
#define SQLITE_FAULTINJECTOR_COUNT 1







static void sqlite3BeginBenignMalloc(void);
static void sqlite3EndBenignMalloc(void);
# 19624 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IN_INDEX_ROWID 1
#define IN_INDEX_EPH 2
#define IN_INDEX_INDEX_ASC 3
#define IN_INDEX_INDEX_DESC 4
#define IN_INDEX_NOOP 5



#define IN_INDEX_NOOP_OK 0x0001
#define IN_INDEX_MEMBERSHIP 0x0002
#define IN_INDEX_LOOP 0x0004
static int sqlite3FindInIndex(Parse *, Expr *, u32, int*, int*, int*);

static int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);
static int sqlite3JournalSize(sqlite3_vfs *);





static int sqlite3JournalIsInMemory(sqlite3_file *p);
static void sqlite3MemJournalOpen(sqlite3_file *);

static void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p);

static int sqlite3SelectExprHeight(Select *);
static int sqlite3ExprCheckHeight(Parse*, int);





static u32 sqlite3Get4byte(const u8*);
static void sqlite3Put4byte(u8*, u32);






#define sqlite3ConnectionBlocked(x,y) 
#define sqlite3ConnectionUnlocked(x) 
#define sqlite3ConnectionClosed(x) 
# 19686 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IOTRACE(A) 
#define sqlite3VdbeIOTraceSql(X) 
# 19723 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqlite3MemdebugSetType(X,Y) 
#define sqlite3MemdebugHasType(X,Y) 1
#define sqlite3MemdebugNoType(X,Y) 1

#define MEMTYPE_HEAP 0x01
#define MEMTYPE_LOOKASIDE 0x02
#define MEMTYPE_PCACHE 0x04





static int sqlite3ThreadCreate(SQLiteThread**,void*(*)(void*),void*);
static int sqlite3ThreadJoin(SQLiteThread*, void**);
# 19746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprVectorSize(Expr *pExpr);
static int sqlite3ExprIsVector(Expr *pExpr);
static Expr *sqlite3VectorFieldSubexpr(Expr*, int);
static Expr *sqlite3ExprForVectorField(Parse*,Expr*,int);
static void sqlite3VectorErrorMsg(Parse*, Expr*);


static const char **sqlite3CompileOptions(int *pnOpt);
# 19783 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const unsigned char sqlite3UpperToLower[] = {

      0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,
     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,
    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,
    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,
    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,
    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,
    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,
    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,
    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,
    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,
    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,
    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,
    252,253,254,255
# 19819 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};
# 19850 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const unsigned char sqlite3CtypeMap[256] = {
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x01, 0x00, 0x80, 0x00, 0x40, 0x00, 0x00, 0x80,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
  0x02, 0x02, 0x02, 0x80, 0x00, 0x00, 0x00, 0x40,
  0x80, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,
  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,

  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,
  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40
};
# 19907 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_USE_URI 0
# 19916 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_ALLOW_COVERING_INDEX_SCAN 1
# 19930 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_SORTER_PMASZ 250
# 19942 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_STMTJRNL_SPILL (64*1024)
# 19954 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEFAULT_LOOKASIDE 1200,100







#define SQLITE_MEMDB_DEFAULT_MAXSIZE 1073741824






static struct Sqlite3Config sqlite3Config = {
   1,
   1,
   1==1,
   0,
   1,
   0,
   1,
   0x7ffffffe,
   0,
   1200,100,
   (64*1024),
   {0,0,0,0,0,0,0,0},
   {0,0,0,0,0,0,0,0,0},
   {0,0,0,0,0,0,0,0,0,0,0,0,0},
   (void*)0,
   0,
   0, 0,
   0,
   0x7fff0000,
   (void*)0,
   0,
   20,
   0,
   0,
   250,

   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
   0,
# 20017 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   0,

   0,
   0,
   0x7ffffffe,
   0x7fffffff,
   0,
};






static FuncDefHash sqlite3BuiltinFunctions;
# 20060 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PendingByte = 0x40000000;
# 20070 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const unsigned char sqlite3OpcodeProperty[] = { 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x00, 0x10, 0x00, 0x01, 0x00, 0x01, 0x01, 0x01, 0x03, 0x03, 0x01, 0x01, 0x03, 0x12, 0x03, 0x01, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x09, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x23, 0x0b, 0x26, 0x26, 0x01, 0x01, 0x03, 0x03, 0x03, 0x03, 0x03, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x0b, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x02, 0x02, 0x08, 0x00, 0x10, 0x10, 0x10, 0x10, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x02, 0x02, 0x02, 0x00, 0x00, 0x12, 0x20, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x26, 0x00, 0x12, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x04, 0x04, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x10, 0x10, 0x00, 0x04, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,};




static const char sqlite3StrBINARY[] = "BINARY";
# 20115 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_VDBEINT_H 






#define SQLITE_MAX_SCHEMA_RETRY 50
# 20131 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define VDBE_DISPLAY_P4 1
# 20141 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct VdbeOp Op;




typedef unsigned Bool;


typedef struct VdbeSorter VdbeSorter;


typedef struct AuxData AuxData;


#define CURTYPE_BTREE 0
#define CURTYPE_SORTER 1
#define CURTYPE_VTAB 2
#define CURTYPE_PSEUDO 3
# 20170 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct VdbeCursor VdbeCursor;
struct VdbeCursor {
  u8 eCurType;
  i8 iDb;
  u8 nullRow;
  u8 deferredMoveto;
  u8 isTable;




  Bool isEphemeral:1;
  Bool useRandomRowid:1;
  Bool isOrdered:1;
  Bool seekHit:1;
  Btree *pBtx;
  i64 seqCount;
  int *aAltMap;





  u32 cacheStatus;
  int seekResult;
# 20203 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  VdbeCursor *pAltCursor;
  union {
    BtCursor *pCursor;
    sqlite3_vtab_cursor *pVCur;
    VdbeSorter *pSorter;
  } uc;
  KeyInfo *pKeyInfo;
  u32 iHdrOffset;
  Pgno pgnoRoot;
  i16 nField;
  u16 nHdrParsed;
  i64 movetoTarget;
  u32 *aOffset;
  const u8 *aRow;
  u32 payloadSize;
  u32 szRow;







  u32 aType[1];
};





#define CACHE_STALE 0
# 20256 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct VdbeFrame VdbeFrame;
struct VdbeFrame {
  Vdbe *v;
  VdbeFrame *pParent;
  Op *aOp;
  i64 *anExec;
  Mem *aMem;
  VdbeCursor **apCsr;
  u8 *aOnce;
  void *token;
  i64 lastRowid;
  AuxData *pAuxData;



  int nCursor;
  int pc;
  int nOp;
  int nMem;
  int nChildMem;
  int nChildCsr;
  int nChange;
  int nDbChange;
};


#define SQLITE_FRAME_MAGIC 0x879fb71e





#define VdbeFrameMem(p) ((Mem *)&((u8 *)p)[ROUND8(sizeof(VdbeFrame))])






struct sqlite3_value {
  union MemValue {
    double r;
    i64 i;
    int nZero;
    const char *zPType;
    FuncDef *pDef;
  } u;
  u16 flags;
  u8 enc;
  u8 eSubtype;
  int n;
  char *z;

  char *zMalloc;
  int szMalloc;
  u32 uTemp;
  sqlite3 *db;
  void (*xDel)(void*);




};





#define MEMCELLSIZE offsetof(Mem,zMalloc)
# 20339 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define MEM_Null 0x0001
#define MEM_Str 0x0002
#define MEM_Int 0x0004
#define MEM_Real 0x0008
#define MEM_Blob 0x0010
#define MEM_IntReal 0x0020
#define MEM_AffMask 0x003f
#define MEM_FromBind 0x0040
#define MEM_Undefined 0x0080
#define MEM_Cleared 0x0100
#define MEM_TypeMask 0xc1bf







#define MEM_Term 0x0200
#define MEM_Dyn 0x0400
#define MEM_Static 0x0800
#define MEM_Ephem 0x1000
#define MEM_Agg 0x2000
#define MEM_Zero 0x4000
#define MEM_Subtype 0x8000
# 20372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define VdbeMemDynamic(X) (((X)->flags&(MEM_Agg|MEM_Dyn))!=0)





#define MemSetTypeFlag(p,f) ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f)





#define MemNullNochng(X) ((X)->flags==(MEM_Null|MEM_Zero) && (X)->n==0 && (X)->u.nZero==0)
# 20402 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct AuxData {
  int iAuxOp;
  int iAuxArg;
  void *pAux;
  void (*xDeleteAux)(void*);
  AuxData *pNextAux;
};
# 20423 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_context {
  Mem *pOut;
  FuncDef *pFunc;
  Mem *pMem;
  Vdbe *pVdbe;
  int iOp;
  int isError;
  u8 skipFlag;
  u8 argc;
  sqlite3_value *argv[1];
};




typedef unsigned bft;




typedef struct ScanStatus ScanStatus;
struct ScanStatus {
  int addrExplain;
  int addrLoop;
  int addrVisit;
  int iSelectID;
  LogEst nEst;
  char *zName;
};
# 20460 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct DblquoteStr DblquoteStr;
struct DblquoteStr {
  DblquoteStr *pNextStr;
  char z[8];
};
# 20473 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Vdbe {
  sqlite3 *db;
  Vdbe *pPrev,*pNext;
  Parse *pParse;
  ynVar nVar;
  u32 magic;
  int nMem;
  int nCursor;
  u32 cacheCtr;
  int pc;
  int rc;
  int nChange;
  int iStatement;
  i64 iCurrentTime;
  i64 nFkConstraint;
  i64 nStmtDefCons;
  i64 nStmtDefImmCons;
  Mem *aMem;
  Mem **apArg;
  VdbeCursor **apCsr;
  Mem *aVar;




  Op *aOp;
  int nOp;
  int nOpAlloc;
  Mem *aColName;
  Mem *pResultSet;
  char *zErrMsg;
  VList *pVList;

  i64 startTime;





  u16 nResColumn;
  u8 errorAction;
  u8 minWriteFileFormat;
  u8 prepFlags;
  bft expired:2;
  bft explain:2;
  bft doingRerun:1;
  bft changeCntOn:1;
  bft runOnlyOnce:1;
  bft usesStmtJournal:1;
  bft readOnly:1;
  bft bIsReader:1;
  yDbMask btreeMask;
  yDbMask lockMask;
  u32 aCounter[7];
  char *zSql;




  void *pFree;
  VdbeFrame *pFrame;
  VdbeFrame *pDelFrame;
  int nFrame;
  u32 expmask;
  SubProgram *pProgram;
  AuxData *pAuxData;





};




#define VDBE_MAGIC_INIT 0x16bceaa5
#define VDBE_MAGIC_RUN 0x2df20da3
#define VDBE_MAGIC_HALT 0x319c2973
#define VDBE_MAGIC_RESET 0x48fa9f76
#define VDBE_MAGIC_DEAD 0x5606c3c8





struct PreUpdate {
  Vdbe *v;
  VdbeCursor *pCsr;
  int op;
  u8 *aRecord;
  KeyInfo keyinfo;
  UnpackedRecord *pUnpacked;
  UnpackedRecord *pNewUnpacked;
  int iNewReg;
  i64 iKey1;
  i64 iKey2;
  Mem *aNew;
  Table *pTab;
  Index *pPk;
};




static void sqlite3VdbeError(Vdbe*, const char *, ...);
static void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);
void sqliteVdbePopStack(Vdbe*,int);
static int sqlite3VdbeCursorMoveto(VdbeCursor**, int*);
static int sqlite3VdbeCursorRestore(VdbeCursor*);
static u32 sqlite3VdbeSerialTypeLen(u32);
static u8 sqlite3VdbeOneByteSerialTypeLen(u8);
static u32 sqlite3VdbeSerialPut(unsigned char*, Mem*, u32);
static u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);
static void sqlite3VdbeDeleteAuxData(sqlite3*, AuxData**, int, int);

int sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);
static int sqlite3VdbeIdxKeyCompare(sqlite3*,VdbeCursor*,UnpackedRecord*,int*);
static int sqlite3VdbeIdxRowid(sqlite3*, BtCursor*, i64*);
static int sqlite3VdbeExec(Vdbe*);

static int sqlite3VdbeList(Vdbe*);

static int sqlite3VdbeHalt(Vdbe*);
static int sqlite3VdbeChangeEncoding(Mem *, int);
static int sqlite3VdbeMemTooBig(Mem*);
static int sqlite3VdbeMemCopy(Mem*, const Mem*);
static void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);
static void sqlite3VdbeMemMove(Mem*, Mem*);
static int sqlite3VdbeMemNulTerminate(Mem*);
static int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));
static void sqlite3VdbeMemSetInt64(Mem*, i64);



static void sqlite3VdbeMemSetDouble(Mem*, double);

static void sqlite3VdbeMemSetPointer(Mem*, void*, const char*, void(*)(void*));
static void sqlite3VdbeMemInit(Mem*,sqlite3*,u16);
static void sqlite3VdbeMemSetNull(Mem*);
static void sqlite3VdbeMemSetZeroBlob(Mem*,int);



static int sqlite3VdbeMemSetRowSet(Mem*);
static int sqlite3VdbeMemMakeWriteable(Mem*);
static int sqlite3VdbeMemStringify(Mem*, u8, u8);
static i64 sqlite3VdbeIntValue(Mem*);
static int sqlite3VdbeMemIntegerify(Mem*);
static double sqlite3VdbeRealValue(Mem*);
static int sqlite3VdbeBooleanValue(Mem*, int ifNull);
static void sqlite3VdbeIntegerAffinity(Mem*);
static int sqlite3VdbeMemRealify(Mem*);
static int sqlite3VdbeMemNumerify(Mem*);
static void sqlite3VdbeMemCast(Mem*,u8,u8);
static int sqlite3VdbeMemFromBtree(BtCursor*,u32,u32,Mem*);
static void sqlite3VdbeMemRelease(Mem *p);
static int sqlite3VdbeMemFinalize(Mem*, FuncDef*);

static int sqlite3VdbeMemAggValue(Mem*, Mem*, FuncDef*);


static const char *sqlite3OpcodeName(int);

static int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);
static int sqlite3VdbeMemClearAndResize(Mem *pMem, int n);
static int sqlite3VdbeCloseStatement(Vdbe *, int);



static void sqlite3VdbeFrameMemDel(void*);
static void sqlite3VdbeFrameDelete(VdbeFrame*);
static int sqlite3VdbeFrameRestore(VdbeFrame *);



static int sqlite3VdbeTransferError(Vdbe *p);

static int sqlite3VdbeSorterInit(sqlite3 *, int, VdbeCursor *);
static void sqlite3VdbeSorterReset(sqlite3 *, VdbeSorter *);
static void sqlite3VdbeSorterClose(sqlite3 *, VdbeCursor *);
static int sqlite3VdbeSorterRowkey(const VdbeCursor *, Mem *);
static int sqlite3VdbeSorterNext(sqlite3 *, const VdbeCursor *);
static int sqlite3VdbeSorterRewind(const VdbeCursor *, int *);
static int sqlite3VdbeSorterWrite(const VdbeCursor *, Mem *);
static int sqlite3VdbeSorterCompare(const VdbeCursor *, Mem *, int, int *);





#define sqlite3VdbeIncrWriteCounter(V,C) 
#define sqlite3VdbeAssertAbortable(V) 



static void sqlite3VdbeEnter(Vdbe*);





static void sqlite3VdbeLeave(Vdbe*);
# 20686 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeCheckFk(Vdbe *, int);
# 20696 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemTranslate(Mem*, u8);
static int sqlite3VdbeMemHandleBom(Mem *pMem);



static int sqlite3VdbeMemExpandBlob(Mem *);
#define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)
# 20717 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef sqlite3_int64 sqlite3StatValueType;



typedef struct sqlite3StatType sqlite3StatType;
static struct sqlite3StatType {
  sqlite3StatValueType nowValue[10];
  sqlite3StatValueType mxValue[10];
} sqlite3Stat = { {0,}, {0,} };





static const char statMutex[] = {
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
};
# 20755 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define wsdStatInit 
#define wsdStat sqlite3Stat






static sqlite3_int64 sqlite3StatusValue(int op){
  ;
  ((void)0);
  ((void)0);
  ((void)0)
                                                                    ;
  return sqlite3Stat.nowValue[op];
}
# 20783 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3StatusUp(int op, int N){
  ;
  ((void)0);
  ((void)0);
  ((void)0)
                                                                    ;
  sqlite3Stat.nowValue[op] += N;
  if( sqlite3Stat.nowValue[op]>sqlite3Stat.mxValue[op] ){
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
}
static void sqlite3StatusDown(int op, int N){
  ;
  ((void)0);
  ((void)0);
  ((void)0)
                                                                    ;
  ((void)0);
  sqlite3Stat.nowValue[op] -= N;
}





static void sqlite3StatusHighwater(int op, int X){
  sqlite3StatValueType newValue;
  ;
  ((void)0);
  newValue = (sqlite3StatValueType)X;
  ((void)0);
  ((void)0);
  ((void)0)
                                                                    ;
  ((void)0)

                                             ;
  if( newValue>sqlite3Stat.mxValue[op] ){
    sqlite3Stat.mxValue[op] = newValue;
  }
}




 int sqlite3_status64(
  int op,
  sqlite3_int64 *pCurrent,
  sqlite3_int64 *pHighwater,
  int resetFlag
){
  sqlite3_mutex *pMutex;
  ;
  if( op<0 || op>=((int)(sizeof(sqlite3Stat.nowValue)/sizeof(sqlite3Stat.nowValue[0]))) ){
    return sqlite3MisuseError(20837);
  }



  pMutex = statMutex[op] ? sqlite3Pcache1Mutex() : sqlite3MallocMutex();
  sqlite3_mutex_enter(pMutex);
  *pCurrent = sqlite3Stat.nowValue[op];
  *pHighwater = sqlite3Stat.mxValue[op];
  if( resetFlag ){
    sqlite3Stat.mxValue[op] = sqlite3Stat.nowValue[op];
  }
  sqlite3_mutex_leave(pMutex);
  (void)pMutex;
  return 0;
}
 int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){
  sqlite3_int64 iCur = 0, iHwtr = 0;
  int rc;



  rc = sqlite3_status64(op, &iCur, &iHwtr, resetFlag);
  if( rc==0 ){
    *pCurrent = (int)iCur;
    *pHighwater = (int)iHwtr;
  }
  return rc;
}




static u32 countLookasideSlots(LookasideSlot *p){
  u32 cnt = 0;
  while( p ){
    p = p->pNext;
    cnt++;
  }
  return cnt;
}




static int sqlite3LookasideUsed(sqlite3 *db, int *pHighwater){
  u32 nInit = countLookasideSlots(db->lookaside.pInit);
  u32 nFree = countLookasideSlots(db->lookaside.pFree);
  if( pHighwater ) *pHighwater = db->lookaside.nSlot - nInit;
  return db->lookaside.nSlot - (nInit+nFree);
}




 int sqlite3_db_status(
  sqlite3 *db,
  int op,
  int *pCurrent,
  int *pHighwater,
  int resetFlag
){
  int rc = 0;





  sqlite3_mutex_enter(db->mutex);
  switch( op ){
    case 0: {
      *pCurrent = sqlite3LookasideUsed(db, pHighwater);
      if( resetFlag ){
        LookasideSlot *p = db->lookaside.pFree;
        if( p ){
          while( p->pNext ) p = p->pNext;
          p->pNext = db->lookaside.pInit;
          db->lookaside.pInit = db->lookaside.pFree;
          db->lookaside.pFree = 0;
        }
      }
      break;
    }

    case 4:
    case 5:
    case 6: {
      ;
      ;
      ;
      ((void)0);
      ((void)0);
      *pCurrent = 0;
      *pHighwater = db->lookaside.anStat[op - 4];
      if( resetFlag ){
        db->lookaside.anStat[op - 4] = 0;
      }
      break;
    }






    case 11:
    case 1: {
      int totalUsed = 0;
      int i;
      sqlite3BtreeEnterAll(db);
      for(i=0; i<db->nDb; i++){
        Btree *pBt = db->aDb[i].pBt;
        if( pBt ){
          Pager *pPager = sqlite3BtreePager(pBt);
          int nByte = sqlite3PagerMemUsed(pPager);
          if( op==11 ){
            nByte = nByte / sqlite3BtreeConnectionCount(pBt);
          }
          totalUsed += nByte;
        }
      }
      sqlite3BtreeLeaveAll(db);
      *pCurrent = totalUsed;
      *pHighwater = 0;
      break;
    }






    case 2: {
      int i;
      int nByte = 0;

      sqlite3BtreeEnterAll(db);
      db->pnBytesFreed = &nByte;
      for(i=0; i<db->nDb; i++){
        Schema *pSchema = db->aDb[i].pSchema;
        if( (pSchema!=0) ){
          HashElem *p;

          nByte += sqlite3Config.m.xRoundup(sizeof(HashElem)) * (
              pSchema->tblHash.count
            + pSchema->trigHash.count
            + pSchema->idxHash.count
            + pSchema->fkeyHash.count
          );
          nByte += sqlite3_msize(pSchema->tblHash.ht);
          nByte += sqlite3_msize(pSchema->trigHash.ht);
          nByte += sqlite3_msize(pSchema->idxHash.ht);
          nByte += sqlite3_msize(pSchema->fkeyHash.ht);

          for(p=((&pSchema->trigHash)->first); p; p=((p)->next)){
            sqlite3DeleteTrigger(db, (Trigger*)((p)->data));
          }
          for(p=((&pSchema->tblHash)->first); p; p=((p)->next)){
            sqlite3DeleteTable(db, (Table *)((p)->data));
          }
        }
      }
      db->pnBytesFreed = 0;
      sqlite3BtreeLeaveAll(db);

      *pHighwater = 0;
      *pCurrent = nByte;
      break;
    }






    case 3: {
      struct Vdbe *pVdbe;
      int nByte = 0;

      db->pnBytesFreed = &nByte;
      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){
        sqlite3VdbeClearObject(db, pVdbe);
        sqlite3DbFree(db, pVdbe);
      }
      db->pnBytesFreed = 0;

      *pHighwater = 0;
      *pCurrent = nByte;

      break;
    }






    case 12:
      op = 9 +1;

    case 7:
    case 8:
    case 9:{
      int i;
      int nRet = 0;
      ((void)0);
      ((void)0);

      for(i=0; i<db->nDb; i++){
        if( db->aDb[i].pBt ){
          Pager *pPager = sqlite3BtreePager(db->aDb[i].pBt);
          sqlite3PagerCacheStat(pPager, op, resetFlag, &nRet);
        }
      }
      *pHighwater = 0;


      *pCurrent = nRet;
      break;
    }





    case 10: {
      *pHighwater = 0;
      *pCurrent = db->nDeferredImmCons>0 || db->nDeferredCons>0;
      break;
    }

    default: {
      rc = 1;
    }
  }
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 21126 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h" 1







       
#define _INC_TIME 


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wtime.h" 1
# 9 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wtime.h"
       



__pragma(pack(push, _CRT_PACKING))
# 22 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wtime.h"
struct tm
{
    int tm_sec;
    int tm_min;
    int tm_hour;
    int tm_mday;
    int tm_mon;
    int tm_year;
    int tm_wday;
    int tm_yday;
    int tm_isdst;
};










 wchar_t* _wasctime(
    struct tm const* _Tm
    );



 errno_t _wasctime_s(
    wchar_t* _Buffer,
    size_t _SizeInWords,
    struct tm const* _Tm
    );










 size_t wcsftime(
    wchar_t* _Buffer,
    size_t _SizeInWords,
    wchar_t const* _Format,
    struct tm const* _Tm
    );



 size_t _wcsftime_l(
    wchar_t* _Buffer,
    size_t _SizeInWords,
    wchar_t const* _Format,
    struct tm const* _Tm,
    _locale_t _Locale
    );



 wchar_t* _wctime32(
    __time32_t const* _Time
    );


 errno_t _wctime32_s(
    wchar_t* _Buffer,
    size_t _SizeInWords,
    __time32_t const* _Time
    );










 wchar_t* _wctime64(
    __time64_t const* _Time
    );


 errno_t _wctime64_s(
    wchar_t* _Buffer,
    size_t _SizeInWords,
    __time64_t const* _Time);








 errno_t _wstrdate_s(
    wchar_t* _Buffer,
    size_t _SizeInWords
    );






 wchar_t* _wstrdate( wchar_t *_Buffer);





 errno_t _wstrtime_s(
    wchar_t* _Buffer,
    size_t _SizeInWords
    );






 wchar_t* _wstrtime( wchar_t *_Buffer);
# 160 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wtime.h"
#pragma warning(push)
#pragma warning(disable: 4996)



       
        static __inline wchar_t* _wctime(
            time_t const* const _Time
            )
        {
            return _wctime32(_Time);
        }

       
        static __inline errno_t _wctime_s(
            wchar_t* const _Buffer,
            size_t const _SizeInWords,
            time_t const* const _Time)
        {
            return _wctime32_s(_Buffer, _SizeInWords, _Time);
        }
# 203 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_wtime.h"
#pragma warning(pop)




__pragma(pack(pop))
# 13 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h" 2

__pragma(pack(push, _CRT_PACKING))
# 23 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h"
typedef long clock_t;

struct _timespec32
{
    __time32_t tv_sec;
    long tv_nsec;
};

struct _timespec64
{
    __time64_t tv_sec;
    long tv_nsec;
};


    struct timespec
    {
        time_t tv_sec;
        long tv_nsec;
    };





#define CLOCKS_PER_SEC ((clock_t)1000)

#define TIME_UTC 1
# 60 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h"

 int* __daylight(void);

#define _daylight (*__daylight())



 long* __dstbias(void);

#define _dstbias (*__dstbias())



 long* __timezone(void);

#define _timezone (*__timezone())



 char** __tzname(void);

#define _tzname (__tzname())


 errno_t _get_daylight(
    int* _Daylight
    );


 errno_t _get_dstbias(
    long* _DaylightSavingsBias
    );


 errno_t _get_timezone(
    long* _TimeZone
    );


 errno_t _get_tzname(
    size_t* _ReturnValue,
    char* _Buffer,
    size_t _SizeInBytes,
    int _Index
    );
# 113 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h"



 char* asctime(
    struct tm const* _Tm
    );


   
   
    errno_t asctime_s(
        char* _Buffer,
        size_t _SizeInBytes,
        struct tm const* _Tm
        );









 clock_t clock(void);




 char* _ctime32(
    __time32_t const* _Time
    );


 errno_t _ctime32_s(
    char* _Buffer,
    size_t _SizeInBytes,
    __time32_t const* _Time
    );










 char* _ctime64(
    __time64_t const* _Time
    );


 errno_t _ctime64_s(
    char* _Buffer,
    size_t _SizeInBytes,
    __time64_t const* _Time
    );








 double _difftime32(
    __time32_t _Time1,
    __time32_t _Time2
    );


 double _difftime64(
    __time64_t _Time1,
    __time64_t _Time2
    );



 struct tm* _gmtime32(
    __time32_t const* _Time
    );


 errno_t _gmtime32_s(
    struct tm* _Tm,
    __time32_t const* _Time
    );



 struct tm* _gmtime64(
    __time64_t const* _Time
    );


 errno_t _gmtime64_s(
    struct tm* _Tm,
    __time64_t const* _Time
    );



 struct tm* _localtime32(
    __time32_t const* _Time
    );


 errno_t _localtime32_s(
    struct tm* _Tm,
    __time32_t const* _Time
    );



 struct tm* _localtime64(
    __time64_t const* _Time
    );


 errno_t _localtime64_s(
    struct tm* _Tm,
    __time64_t const* _Time
    );


 __time32_t _mkgmtime32(
    struct tm* _Tm
    );


 __time64_t _mkgmtime64(
    struct tm* _Tm
    );


 __time32_t _mktime32(
    struct tm* _Tm
    );


 __time64_t _mktime64(
    struct tm* _Tm
    );



 size_t strftime(
    char* _Buffer,
    size_t _SizeInBytes,
    char const* _Format,
    struct tm const* _Tm
    );



 size_t _strftime_l(
    char* _Buffer,
    size_t _MaxSize,
    char const* _Format,
    struct tm const* _Tm,
    _locale_t _Locale
    );


 errno_t _strdate_s(
    char* _Buffer,
    size_t _SizeInBytes
    );






 char* _strdate( char *_Buffer);





 errno_t _strtime_s(
    char* _Buffer,
    size_t _SizeInBytes
    );






 char* _strtime( char *_Buffer);




 __time32_t _time32(
    __time32_t* _Time
    );

 __time64_t _time64(
    __time64_t* _Time
    );



 int _timespec32_get(
    struct _timespec32* _Ts,
    int _Base
    );



 int _timespec64_get(
    struct _timespec64* _Ts,
    int _Base
    );
# 341 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h"
    void _tzset(void);


    __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "GetLocalTime" " instead. See online help for details."))
    unsigned _getsystime(
        struct tm* _Tm
        );

    __declspec(deprecated("This function or variable has been superceded by newer library or operating system functionality. Consider using " "SetLocalTime" " instead. See online help for details."))
    unsigned _setsystime(
        struct tm* _Tm,
        unsigned _Milliseconds
        );
# 368 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h"
       
        static __inline char* ctime(
            time_t const* const _Time
            )
        {
#pragma warning(push)
#pragma warning(disable: 4996)
            return _ctime32(_Time);
#pragma warning(pop)
        }

       
        static __inline double difftime(
            time_t const _Time1,
            time_t const _Time2
            )
        {
            return _difftime32(_Time1, _Time2);
        }

       
        static __inline struct tm* gmtime(
            time_t const* const _Time
            )
        {
#pragma warning(push)
#pragma warning(disable: 4996)
            return _gmtime32(_Time);
#pragma warning(pop)
        }

       
        static __inline struct tm* localtime(
            time_t const* const _Time
            )
        {
#pragma warning(push)
#pragma warning(disable: 4996)
            return _localtime32(_Time);
#pragma warning(pop)
        }

       
        static __inline time_t _mkgmtime(
            struct tm* const _Tm
            )
        {
            return _mkgmtime32(_Tm);
        }

       
        static __inline time_t mktime(
            struct tm* const _Tm
            )
        {
            return _mktime32(_Tm);
        }

        static __inline time_t time(
            time_t* const _Time
            )
        {
            return _time32(_Time);
        }

       
        static __inline int timespec_get(
            struct timespec* const _Ts,
            int const _Base
            )
        {
            return _timespec32_get((struct _timespec32*)_Ts, _Base);
        }


           
            static __inline errno_t ctime_s(
                char* const _Buffer,
                size_t const _SizeInBytes,
                time_t const* const _Time
                )
            {
                return _ctime32_s(_Buffer, _SizeInBytes, _Time);
            }

           
            static __inline errno_t gmtime_s(
                struct tm* const _Tm,
                time_t const* const _Time
                )
            {
                return _gmtime32_s(_Tm, _Time);
            }

           
            static __inline errno_t localtime_s(
                struct tm* const _Tm,
                time_t const* const _Time
                )
            {
                return _localtime32_s(_Tm, _Time);
            }
# 600 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/time.h"
__pragma(pack(pop))
# 21127 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 21143 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct DateTime DateTime;
struct DateTime {
  sqlite3_int64 iJD;
  int Y, M, D;
  int h, m;
  int tz;
  double s;
  char validJD;
  char rawS;
  char validYMD;
  char validHMS;
  char validTZ;
  char tzSet;
  char isError;
};
# 21187 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getDigits(const char *zDate, const char *zFormat, ...){


  static const u16 aMx[] = { 12, 14, 24, 31, 59, 9999 };
  va_list ap;
  int cnt = 0;
  char nextC;
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  do{
    char N = zFormat[0] - '0';
    char min = zFormat[1] - '0';
    int val = 0;
    u16 max;

    ((void)0);
    max = aMx[zFormat[2] - 'a'];
    nextC = zFormat[3];
    val = 0;
    while( N-- ){
      if( !(sqlite3CtypeMap[(unsigned char)(*zDate)]&0x04) ){
        goto end_getDigits;
      }
      val = val*10 + *zDate - '0';
      zDate++;
    }
    if( val<(int)min || val>(int)max || (nextC!=0 && nextC!=*zDate) ){
      goto end_getDigits;
    }
    *( *(int* *)((ap += ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ) = val;
    zDate++;
    cnt++;
    zFormat += 4;
  }while( nextC );
end_getDigits:
  ( ap = (va_list)0 );
  return cnt;
}
# 21241 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int parseTimezone(const char *zDate, DateTime *p){
  int sgn = 0;
  int nHr, nMn;
  int c;
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) ){ zDate++; }
  p->tz = 0;
  c = *zDate;
  if( c=='-' ){
    sgn = -1;
  }else if( c=='+' ){
    sgn = +1;
  }else if( c=='Z' || c=='z' ){
    zDate++;
    goto zulu_time;
  }else{
    return c!=0;
  }
  zDate++;
  if( getDigits(zDate, "20b:20e", &nHr, &nMn)!=2 ){
    return 1;
  }
  zDate += 5;
  p->tz = sgn*(nMn + nHr*60);
zulu_time:
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) ){ zDate++; }
  p->tzSet = 1;
  return *zDate!=0;
}
# 21277 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int parseHhMmSs(const char *zDate, DateTime *p){
  int h, m, s;
  double ms = 0.0;
  if( getDigits(zDate, "20c:20e", &h, &m)!=2 ){
    return 1;
  }
  zDate += 5;
  if( *zDate==':' ){
    zDate++;
    if( getDigits(zDate, "20e", &s)!=1 ){
      return 1;
    }
    zDate += 2;
    if( *zDate=='.' && (sqlite3CtypeMap[(unsigned char)(zDate[1])]&0x04) ){
      double rScale = 1.0;
      zDate++;
      while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x04) ){
        ms = ms*10.0 + *zDate - '0';
        rScale *= 10.0;
        zDate++;
      }
      ms /= rScale;
    }
  }else{
    s = 0;
  }
  p->validJD = 0;
  p->rawS = 0;
  p->validHMS = 1;
  p->h = h;
  p->m = m;
  p->s = s + ms;
  if( parseTimezone(zDate, p) ) return 1;
  p->validTZ = (p->tz!=0)?1:0;
  return 0;
}




static void datetimeError(DateTime *p){
  memset(p, 0, sizeof(*p));
  p->isError = 1;
}







static void computeJD(DateTime *p){
  int Y, M, D, A, B, X1, X2;

  if( p->validJD ) return;
  if( p->validYMD ){
    Y = p->Y;
    M = p->M;
    D = p->D;
  }else{
    Y = 2000;
    M = 1;
    D = 1;
  }
  if( Y<-4713 || Y>9999 || p->rawS ){
    datetimeError(p);
    return;
  }
  if( M<=2 ){
    Y--;
    M += 12;
  }
  A = Y/100;
  B = 2 - A + (A/4);
  X1 = 36525*(Y+4716)/100;
  X2 = 306001*(M+1)/10000;
  p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);
  p->validJD = 1;
  if( p->validHMS ){
    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000);
    if( p->validTZ ){
      p->iJD -= p->tz*60000;
      p->validYMD = 0;
      p->validHMS = 0;
      p->validTZ = 0;
    }
  }
}
# 21378 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int parseYyyyMmDd(const char *zDate, DateTime *p){
  int Y, M, D, neg;

  if( zDate[0]=='-' ){
    zDate++;
    neg = 1;
  }else{
    neg = 0;
  }
  if( getDigits(zDate, "40f-21a-21d", &Y, &M, &D)!=3 ){
    return 1;
  }
  zDate += 10;
  while( (sqlite3CtypeMap[(unsigned char)(*zDate)]&0x01) || 'T'==*(u8*)zDate ){ zDate++; }
  if( parseHhMmSs(zDate, p)==0 ){

  }else if( *zDate==0 ){
    p->validHMS = 0;
  }else{
    return 1;
  }
  p->validJD = 0;
  p->validYMD = 1;
  p->Y = neg ? -Y : Y;
  p->M = M;
  p->D = D;
  if( p->validTZ ){
    computeJD(p);
  }
  return 0;
}






static int setDateTimeToCurrent(sqlite3_context *context, DateTime *p){
  p->iJD = sqlite3StmtCurrentTime(context);
  if( p->iJD>0 ){
    p->validJD = 1;
    return 0;
  }else{
    return 1;
  }
}







static void setRawDateNumber(DateTime *p, double r){
  p->s = r;
  p->rawS = 1;
  if( r>=0.0 && r<5373484.5 ){
    p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);
    p->validJD = 1;
  }
}
# 21456 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int parseDateOrTime(
  sqlite3_context *context,
  const char *zDate,
  DateTime *p
){
  double r;
  if( parseYyyyMmDd(zDate,p)==0 ){
    return 0;
  }else if( parseHhMmSs(zDate, p)==0 ){
    return 0;
  }else if( sqlite3StrICmp(zDate,"now")==0 && sqlite3NotPureFunc(context) ){
    return setDateTimeToCurrent(context, p);
  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), 1)>0 ){
    setRawDateNumber(p, r);
    return 0;
  }
  return 1;
}
# 21482 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define INT_464269060799999 ((((i64)0x1a640)<<32)|0x1072fdff)






static int validJulianDay(sqlite3_int64 iJD){
  return iJD>=0 && iJD<=((((i64)0x1a640)<<32)|0x1072fdff);
}




static void computeYMD(DateTime *p){
  int Z, A, B, C, D, E, X1;
  if( p->validYMD ) return;
  if( !p->validJD ){
    p->Y = 2000;
    p->M = 1;
    p->D = 1;
  }else if( !validJulianDay(p->iJD) ){
    datetimeError(p);
    return;
  }else{
    Z = (int)((p->iJD + 43200000)/86400000);
    A = (int)((Z - 1867216.25)/36524.25);
    A = Z + 1 + A - (A/4);
    B = A + 1524;
    C = (int)((B - 122.1)/365.25);
    D = (36525*(C&32767))/100;
    E = (int)((B-D)/30.6001);
    X1 = (int)(30.6001*E);
    p->D = B - D - X1;
    p->M = E<14 ? E-1 : E-13;
    p->Y = p->M>2 ? C - 4716 : C - 4715;
  }
  p->validYMD = 1;
}




static void computeHMS(DateTime *p){
  int s;
  if( p->validHMS ) return;
  computeJD(p);
  s = (int)((p->iJD + 43200000) % 86400000);
  p->s = s/1000.0;
  s = (int)p->s;
  p->s -= s;
  p->h = s/3600;
  s -= p->h*3600;
  p->m = s/60;
  p->s += s - p->m*60;
  p->rawS = 0;
  p->validHMS = 1;
}




static void computeYMD_HMS(DateTime *p){
  computeYMD(p);
  computeHMS(p);
}




static void clearYMD_HMS_TZ(DateTime *p){
  p->validYMD = 0;
  p->validHMS = 0;
  p->validTZ = 0;
}
# 21590 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int osLocaltime(time_t *t, struct tm *pTm){
  int rc;

  struct tm *pX;

  sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

  sqlite3_mutex_enter(mutex);
  pX = localtime(t);

  if( sqlite3Config.bLocaltimeFault ) pX = 0;

  if( pX ) *pTm = *pX;
  sqlite3_mutex_leave(mutex);
  rc = pX==0;
# 21615 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return rc;
}
# 21629 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_int64 localtimeOffset(
  DateTime *p,
  sqlite3_context *pCtx,
  int *pRc
){
  DateTime x, y;
  time_t t;
  struct tm sLocal;


  memset(&sLocal, 0, sizeof(sLocal));

  x = *p;
  computeYMD_HMS(&x);
  if( x.Y<1971 || x.Y>=2038 ){





    x.Y = 2000;
    x.M = 1;
    x.D = 1;
    x.h = 0;
    x.m = 0;
    x.s = 0.0;
  } else {
    int s = (int)(x.s + 0.5);
    x.s = s;
  }
  x.tz = 0;
  x.validJD = 0;
  computeJD(&x);
  t = (time_t)(x.iJD/1000 - 21086676*(i64)10000);
  if( osLocaltime(&t, &sLocal) ){
    sqlite3_result_error(pCtx, "local time unavailable", -1);
    *pRc = 1;
    return 0;
  }
  y.Y = sLocal.tm_year + 1900;
  y.M = sLocal.tm_mon + 1;
  y.D = sLocal.tm_mday;
  y.h = sLocal.tm_hour;
  y.m = sLocal.tm_min;
  y.s = sLocal.tm_sec;
  y.validYMD = 1;
  y.validHMS = 1;
  y.validJD = 0;
  y.rawS = 0;
  y.validTZ = 0;
  y.isError = 0;
  computeJD(&y);
  *pRc = 0;
  return y.iJD - x.iJD;
}
# 21694 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const struct {
  u8 eType;
  u8 nName;
  char *zName;
  double rLimit;
  double rXform;
} aXformType[] = {
  { 0, 6, "second", 464269060800.0, 86400000.0/(24.0*60.0*60.0) },
  { 0, 6, "minute", 7737817680.0, 86400000.0/(24.0*60.0) },
  { 0, 4, "hour", 128963628.0, 86400000.0/24.0 },
  { 0, 3, "day", 5373485.0, 86400000.0 },
  { 1, 5, "month", 176546.0, 30.0*86400000.0 },
  { 2, 4, "year", 14713.0, 365.0*86400000.0 },
};
# 21733 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int parseModifier(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  DateTime *p
){
  int rc = 1;
  double r;
  switch(sqlite3UpperToLower[(u8)z[0]] ){

    case 'l': {





      if( sqlite3_stricmp(z, "localtime")==0 && sqlite3NotPureFunc(pCtx) ){
        computeJD(p);
        p->iJD += localtimeOffset(p, pCtx, &rc);
        clearYMD_HMS_TZ(p);
      }
      break;
    }

    case 'u': {






      if( sqlite3_stricmp(z, "unixepoch")==0 && p->rawS ){
        r = p->s*1000.0 + 210866760000000.0;
        if( r>=0.0 && r<464269060800000.0 ){
          clearYMD_HMS_TZ(p);
          p->iJD = (sqlite3_int64)r;
          p->validJD = 1;
          p->rawS = 0;
          rc = 0;
        }
      }

      else if( sqlite3_stricmp(z, "utc")==0 && sqlite3NotPureFunc(pCtx) ){
        if( p->tzSet==0 ){
          sqlite3_int64 c1;
          computeJD(p);
          c1 = localtimeOffset(p, pCtx, &rc);
          if( rc==0 ){
            p->iJD -= c1;
            clearYMD_HMS_TZ(p);
            p->iJD += c1 - localtimeOffset(p, pCtx, &rc);
          }
          p->tzSet = 1;
        }else{
          rc = 0;
        }
      }

      break;
    }
    case 'w': {







      if( sqlite3_strnicmp(z, "weekday ", 8)==0
               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), 1)>0
               && (n=(int)r)==r && n>=0 && r<7 ){
        sqlite3_int64 Z;
        computeYMD_HMS(p);
        p->validTZ = 0;
        p->validJD = 0;
        computeJD(p);
        Z = ((p->iJD + 129600000)/86400000) % 7;
        if( Z>n ) Z -= 7;
        p->iJD += (n - Z)*86400000;
        clearYMD_HMS_TZ(p);
        rc = 0;
      }
      break;
    }
    case 's': {






      if( sqlite3_strnicmp(z, "start of ", 9)!=0 ) break;
      if( !p->validJD && !p->validYMD && !p->validHMS ) break;
      z += 9;
      computeYMD(p);
      p->validHMS = 1;
      p->h = p->m = 0;
      p->s = 0.0;
      p->rawS = 0;
      p->validTZ = 0;
      p->validJD = 0;
      if( sqlite3_stricmp(z,"month")==0 ){
        p->D = 1;
        rc = 0;
      }else if( sqlite3_stricmp(z,"year")==0 ){
        p->M = 1;
        p->D = 1;
        rc = 0;
      }else if( sqlite3_stricmp(z,"day")==0 ){
        rc = 0;
      }
      break;
    }
    case '+':
    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9': {
      double rRounder;
      int i;
      for(n=1; z[n] && z[n]!=':' && !(sqlite3CtypeMap[(unsigned char)(z[n])]&0x01); n++){}
      if( sqlite3AtoF(z, &r, n, 1)<=0 ){
        rc = 1;
        break;
      }
      if( z[n]==':' ){





        const char *z2 = z;
        DateTime tx;
        sqlite3_int64 day;
        if( !(sqlite3CtypeMap[(unsigned char)(*z2)]&0x04) ) z2++;
        memset(&tx, 0, sizeof(tx));
        if( parseHhMmSs(z2, &tx) ) break;
        computeJD(&tx);
        tx.iJD -= 43200000;
        day = tx.iJD/86400000;
        tx.iJD -= day*86400000;
        if( z[0]=='-' ) tx.iJD = -tx.iJD;
        computeJD(p);
        clearYMD_HMS_TZ(p);
        p->iJD += tx.iJD;
        rc = 0;
        break;
      }



      z += n;
      while( (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z++;
      n = sqlite3Strlen30(z);
      if( n>10 || n<3 ) break;
      if( sqlite3UpperToLower[(u8)z[n-1]]=='s' ) n--;
      computeJD(p);
      rc = 1;
      rRounder = r<0 ? -0.5 : +0.5;
      for(i=0; i<((int)(sizeof(aXformType)/sizeof(aXformType[0]))); i++){
        if( aXformType[i].nName==n
         && sqlite3_strnicmp(aXformType[i].zName, z, n)==0
         && r>-aXformType[i].rLimit && r<aXformType[i].rLimit
        ){
          switch( aXformType[i].eType ){
            case 1: {
              int x;
              computeYMD_HMS(p);
              p->M += (int)r;
              x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;
              p->Y += x;
              p->M -= x*12;
              p->validJD = 0;
              r -= (int)r;
              break;
            }
            case 2: {
              int y = (int)r;
              computeYMD_HMS(p);
              p->Y += y;
              p->validJD = 0;
              r -= (int)r;
              break;
            }
          }
          computeJD(p);
          p->iJD += (sqlite3_int64)(r*aXformType[i].rXform + rRounder);
          rc = 0;
          break;
        }
      }
      clearYMD_HMS_TZ(p);
      break;
    }
    default: {
      break;
    }
  }
  return rc;
}
# 21950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isDate(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv,
  DateTime *p
){
  int i, n;
  const unsigned char *z;
  int eType;
  memset(p, 0, sizeof(*p));
  if( argc==0 ){
    return setDateTimeToCurrent(context, p);
  }
  if( (eType = sqlite3_value_type(argv[0]))==2
                   || eType==1 ){
    setRawDateNumber(p, sqlite3_value_double(argv[0]));
  }else{
    z = sqlite3_value_text(argv[0]);
    if( !z || parseDateOrTime(context, (char*)z, p) ){
      return 1;
    }
  }
  for(i=1; i<argc; i++){
    z = sqlite3_value_text(argv[i]);
    n = sqlite3_value_bytes(argv[i]);
    if( z==0 || parseModifier(context, (char*)z, n, p) ) return 1;
  }
  computeJD(p);
  if( p->isError || !validJulianDay(p->iJD) ) return 1;
  return 0;
}
# 21993 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void juliandayFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    computeJD(&x);
    sqlite3_result_double(context, x.iJD/86400000.0);
  }
}






static void datetimeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    char zBuf[100];
    computeYMD_HMS(&x);
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d %02d:%02d:%02d",
                     x.Y, x.M, x.D, x.h, x.m, (int)(x.s));
    sqlite3_result_text(context, zBuf, -1, ((sqlite3_destructor_type)-1));
  }
}






static void timeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    char zBuf[100];
    computeHMS(&x);
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%02d:%02d:%02d", x.h, x.m, (int)x.s);
    sqlite3_result_text(context, zBuf, -1, ((sqlite3_destructor_type)-1));
  }
}






static void dateFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  if( isDate(context, argc, argv, &x)==0 ){
    char zBuf[100];
    computeYMD(&x);
    sqlite3_snprintf(sizeof(zBuf), zBuf, "%04d-%02d-%02d", x.Y, x.M, x.D);
    sqlite3_result_text(context, zBuf, -1, ((sqlite3_destructor_type)-1));
  }
}
# 22082 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void strftimeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  DateTime x;
  u64 n;
  size_t i,j;
  char *z;
  sqlite3 *db;
  const char *zFmt;
  char zBuf[100];
  if( argc==0 ) return;
  zFmt = (const char*)sqlite3_value_text(argv[0]);
  if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;
  db = sqlite3_context_db_handle(context);
  for(i=0, n=1; zFmt[i]; i++, n++){
    if( zFmt[i]=='%' ){
      switch( zFmt[i+1] ){
        case 'd':
        case 'H':
        case 'm':
        case 'M':
        case 'S':
        case 'W':
          n++;

        case 'w':
        case '%':
          break;
        case 'f':
          n += 8;
          break;
        case 'j':
          n += 3;
          break;
        case 'Y':
          n += 8;
          break;
        case 's':
        case 'J':
          n += 50;
          break;
        default:
          return;
      }
      i++;
    }
  }
  ;
  ;
  ;
  ;
  if( n<sizeof(zBuf) ){
    z = zBuf;
  }else if( n>(u64)db->aLimit[0] ){
    sqlite3_result_error_toobig(context);
    return;
  }else{
    z = sqlite3DbMallocRawNN(db, (int)n);
    if( z==0 ){
      sqlite3_result_error_nomem(context);
      return;
    }
  }
  computeJD(&x);
  computeYMD_HMS(&x);
  for(i=j=0; zFmt[i]; i++){
    if( zFmt[i]!='%' ){
      z[j++] = zFmt[i];
    }else{
      i++;
      switch( zFmt[i] ){
        case 'd': sqlite3_snprintf(3, &z[j],"%02d",x.D); j+=2; break;
        case 'f': {
          double s = x.s;
          if( s>59.999 ) s = 59.999;
          sqlite3_snprintf(7, &z[j],"%06.3f", s);
          j += sqlite3Strlen30(&z[j]);
          break;
        }
        case 'H': sqlite3_snprintf(3, &z[j],"%02d",x.h); j+=2; break;
        case 'W':
        case 'j': {
          int nDay;
          DateTime y = x;
          y.validJD = 0;
          y.M = 1;
          y.D = 1;
          computeJD(&y);
          nDay = (int)((x.iJD-y.iJD+43200000)/86400000);
          if( zFmt[i]=='W' ){
            int wd;
            wd = (int)(((x.iJD+43200000)/86400000)%7);
            sqlite3_snprintf(3, &z[j],"%02d",(nDay+7-wd)/7);
            j += 2;
          }else{
            sqlite3_snprintf(4, &z[j],"%03d",nDay+1);
            j += 3;
          }
          break;
        }
        case 'J': {
          sqlite3_snprintf(20, &z[j],"%.16g",x.iJD/86400000.0);
          j+=sqlite3Strlen30(&z[j]);
          break;
        }
        case 'm': sqlite3_snprintf(3, &z[j],"%02d",x.M); j+=2; break;
        case 'M': sqlite3_snprintf(3, &z[j],"%02d",x.m); j+=2; break;
        case 's': {
          sqlite3_snprintf(30,&z[j],"%lld",
                           (i64)(x.iJD/1000 - 21086676*(i64)10000));
          j += sqlite3Strlen30(&z[j]);
          break;
        }
        case 'S': sqlite3_snprintf(3,&z[j],"%02d",(int)x.s); j+=2; break;
        case 'w': {
          z[j++] = (char)(((x.iJD+129600000)/86400000) % 7) + '0';
          break;
        }
        case 'Y': {
          sqlite3_snprintf(5,&z[j],"%04d",x.Y); j+=sqlite3Strlen30(&z[j]);
          break;
        }
        default: z[j++] = '%'; break;
      }
    }
  }
  z[j] = 0;
  sqlite3_result_text(context, z, -1,
                      z==zBuf ? ((sqlite3_destructor_type)-1) : ((sqlite3_destructor_type)sqlite3MallocSize));
}






static void ctimeFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  timeFunc(context, 0, 0);
}






static void cdateFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  dateFunc(context, 0, 0);
}






static void ctimestampFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);
  datetimeFunc(context, 0, 0);
}
# 22308 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3RegisterDateTimeFunctions(void){
  static FuncDef aDateTimeFuncs[] = {

    {-1, 0x2000|1|0x0800, (void*)&sqlite3Config, 0, juliandayFunc, 0, 0, 0, "julianday", {0} },
    {-1, 0x2000|1|0x0800, (void*)&sqlite3Config, 0, dateFunc, 0, 0, 0, "date", {0} },
    {-1, 0x2000|1|0x0800, (void*)&sqlite3Config, 0, timeFunc, 0, 0, 0, "time", {0} },
    {-1, 0x2000|1|0x0800, (void*)&sqlite3Config, 0, datetimeFunc, 0, 0, 0, "datetime", {0} },
    {-1, 0x2000|1|0x0800, (void*)&sqlite3Config, 0, strftimeFunc, 0, 0, 0, "strftime", {0} },
    {0, 0x2000|1, 0, 0, ctimeFunc, 0, 0, 0, "current_time", {0} },
    {0, 0x2000|1, 0, 0, ctimestampFunc, 0, 0, 0, "current_timestamp", {0} },
    {0, 0x2000|1, 0, 0, cdateFunc, 0, 0, 0, "current_date", {0} },





  };
  sqlite3InsertBuiltinFuncs(aDateTimeFuncs, ((int)(sizeof(aDateTimeFuncs)/sizeof(aDateTimeFuncs[0]))));
}
# 22402 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define DO_OS_MALLOC_TEST(x) 
# 22411 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3OsClose(sqlite3_file *pId){
  if( pId->pMethods ){
    pId->pMethods->xClose(pId);
    pId->pMethods = 0;
  }
}
static int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){
  ;
  return id->pMethods->xRead(id, pBuf, amt, offset);
}
static int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){
  ;
  return id->pMethods->xWrite(id, pBuf, amt, offset);
}
static int sqlite3OsTruncate(sqlite3_file *id, i64 size){
  return id->pMethods->xTruncate(id, size);
}
static int sqlite3OsSync(sqlite3_file *id, int flags){
  ;
  return flags ? id->pMethods->xSync(id, flags) : 0;
}
static int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){
  ;
  return id->pMethods->xFileSize(id, pSize);
}
static int sqlite3OsLock(sqlite3_file *id, int lockType){
  ;
  return id->pMethods->xLock(id, lockType);
}
static int sqlite3OsUnlock(sqlite3_file *id, int lockType){
  return id->pMethods->xUnlock(id, lockType);
}
static int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){
  ;
  return id->pMethods->xCheckReservedLock(id, pResOut);
}
# 22456 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){
  if( id->pMethods==0 ) return 12;
# 22475 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return id->pMethods->xFileControl(id, op, pArg);
}
static void sqlite3OsFileControlHint(sqlite3_file *id, int op, void *pArg){
  if( id->pMethods ) (void)id->pMethods->xFileControl(id, op, pArg);
}

static int sqlite3OsSectorSize(sqlite3_file *id){
  int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;
  return (xSectorSize ? xSectorSize(id) : 4096);
}
static int sqlite3OsDeviceCharacteristics(sqlite3_file *id){
  return id->pMethods->xDeviceCharacteristics(id);
}

static int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){
  return id->pMethods->xShmLock(id, offset, n, flags);
}
static void sqlite3OsShmBarrier(sqlite3_file *id){
  id->pMethods->xShmBarrier(id);
}
static int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){
  return id->pMethods->xShmUnmap(id, deleteFlag);
}
static int sqlite3OsShmMap(
  sqlite3_file *id,
  int iPage,
  int pgsz,
  int bExtend,
  void volatile **pp
){
  ;
  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);
}




static int sqlite3OsFetch(sqlite3_file *id, i64 iOff, int iAmt, void **pp){
  ;
  return id->pMethods->xFetch(id, iOff, iAmt, pp);
}
static int sqlite3OsUnfetch(sqlite3_file *id, i64 iOff, void *p){
  return id->pMethods->xUnfetch(id, iOff, p);
}
# 22534 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3OsOpen(
  sqlite3_vfs *pVfs,
  const char *zPath,
  sqlite3_file *pFile,
  int flags,
  int *pFlagsOut
){
  int rc;
  ;




  rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x87f7f, pFlagsOut);
  ((void)0);
  return rc;
}
static int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){
  ;
  ((void)0);
  return pVfs->xDelete(pVfs, zPath, dirSync);
}
static int sqlite3OsAccess(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int flags,
  int *pResOut
){
  ;
  return pVfs->xAccess(pVfs, zPath, flags, pResOut);
}
static int sqlite3OsFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nPathOut,
  char *zPathOut
){
  ;
  zPathOut[0] = 0;
  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);
}

static void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){
  return pVfs->xDlOpen(pVfs, zPath);
}
static void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  pVfs->xDlError(pVfs, nByte, zBufOut);
}
static void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){
  return pVfs->xDlSym(pVfs, pHdle, zSym);
}
static void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){
  pVfs->xDlClose(pVfs, pHandle);
}

static int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){
  if( sqlite3Config.iPrngSeed ){
    memset(zBufOut, 0, nByte);
    if( (nByte>(signed)sizeof(unsigned)) ) nByte = sizeof(unsigned int);
    memcpy(zBufOut, &sqlite3Config.iPrngSeed, nByte);
    return 0;
  }else{
    return pVfs->xRandomness(pVfs, nByte, zBufOut);
  }

}
static int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){
  return pVfs->xSleep(pVfs, nMicro);
}
static int sqlite3OsGetLastError(sqlite3_vfs *pVfs){
  return pVfs->xGetLastError ? pVfs->xGetLastError(pVfs, 0, 0) : 0;
}
static int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){
  int rc;






  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){
    rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);
  }else{
    double r;
    rc = pVfs->xCurrentTime(pVfs, &r);
    *pTimeOut = (sqlite3_int64)(r*86400000.0);
  }
  return rc;
}

static int sqlite3OsOpenMalloc(
  sqlite3_vfs *pVfs,
  const char *zFile,
  sqlite3_file **ppFile,
  int flags,
  int *pOutFlags
){
  int rc;
  sqlite3_file *pFile;
  pFile = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile);
  if( pFile ){
    rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);
    if( rc!=0 ){
      sqlite3_free(pFile);
    }else{
      *ppFile = pFile;
    }
  }else{
    rc = 7;
  }
  return rc;
}
static void sqlite3OsCloseFree(sqlite3_file *pFile){
  ((void)0);
  sqlite3OsClose(pFile);
  sqlite3_free(pFile);
}







static int sqlite3OsInit(void){
  void *p = sqlite3_malloc(10);
  if( p==0 ) return 7;
  sqlite3_free(p);
  return sqlite3_os_init();
}




static sqlite3_vfs * vfsList = 0;
#define vfsList GLOBAL(sqlite3_vfs *, vfsList)





 sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){
  sqlite3_vfs *pVfs = 0;

  sqlite3_mutex *mutex;


  int rc = sqlite3_initialize();
  if( rc ) return 0;


  mutex = sqlite3MutexAlloc(2);

  sqlite3_mutex_enter(mutex);
  for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){
    if( zVfs==0 ) break;
    if( strcmp(zVfs, pVfs->zName)==0 ) break;
  }
  sqlite3_mutex_leave(mutex);
  return pVfs;
}




static void vfsUnlink(sqlite3_vfs *pVfs){
  ((void)0);
  if( pVfs==0 ){

  }else if( vfsList==pVfs ){
    vfsList = pVfs->pNext;
  }else if( vfsList ){
    sqlite3_vfs *p = vfsList;
    while( p->pNext && p->pNext!=pVfs ){
      p = p->pNext;
    }
    if( p->pNext==pVfs ){
      p->pNext = pVfs->pNext;
    }
  }
}






 int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){
  sqlite3_mutex *mutex;

  int rc = sqlite3_initialize();
  if( rc ) return rc;





  mutex = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(mutex);
  vfsUnlink(pVfs);
  if( makeDflt || vfsList==0 ){
    pVfs->pNext = vfsList;
    vfsList = pVfs;
  }else{
    pVfs->pNext = vfsList->pNext;
    vfsList->pNext = pVfs;
  }
  ((void)0);
  sqlite3_mutex_leave(mutex);
  return 0;
}




 int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){
  sqlite3_mutex *mutex;

  int rc = sqlite3_initialize();
  if( rc ) return rc;

  mutex = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(mutex);
  vfsUnlink(pVfs);
  sqlite3_mutex_leave(mutex);
  return 0;
}
# 22797 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct BenignMallocHooks BenignMallocHooks;
static struct BenignMallocHooks {
  void (*xBenignBegin)(void);
  void (*xBenignEnd)(void);
} sqlite3Hooks = { 0, 0 };
# 22814 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define wsdHooksInit 
#define wsdHooks sqlite3Hooks







static void sqlite3BenignMallocHooks(
  void (*xBenignBegin)(void),
  void (*xBenignEnd)(void)
){
  ;
  sqlite3Hooks.xBenignBegin = xBenignBegin;
  sqlite3Hooks.xBenignEnd = xBenignEnd;
}






static void sqlite3BeginBenignMalloc(void){
  ;
  if( sqlite3Hooks.xBenignBegin ){
    sqlite3Hooks.xBenignBegin();
  }
}
static void sqlite3EndBenignMalloc(void){
  ;
  if( sqlite3Hooks.xBenignEnd ){
    sqlite3Hooks.xBenignEnd();
  }
}
# 22973 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 1 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define _SYS_SYSCTL_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define _CDEFS_H_ 





#define __BEGIN_DECLS 
#define __END_DECLS 
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __has_feature(x) 0





#define __has_extension(x) 0
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __P(protos) protos
#define __CONCAT(x,y) x ## y
#define __STRING(x) #x

#define __const const
#define __signed signed
#define __volatile volatile
# 162 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __dead2 __attribute__((__noreturn__))
#define __pure2 __attribute__((__const__))
#define __stateful_pure __attribute__((__pure__))




#define __unused __attribute__((__unused__))




#define __used __attribute__((__used__))





#define __cold __attribute__((__cold__))
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __exported __attribute__((__visibility__("default")))
#define __exported_push _Pragma("GCC visibility push(default)")
#define __exported_pop _Pragma("GCC visibility pop")
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __deprecated __attribute__((__deprecated__))



#define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))







#define __deprecated_enum_msg(_msg) 


#define __kpi_deprecated(_msg) 





#define __unavailable __attribute__((__unavailable__))




#define __kpi_unavailable 

#define __kpi_deprecated_arm64_macos_unavailable 



#define __dead 
#define __pure 
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __restrict restrict
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __nullable 


#define __nonnull 


#define __null_unspecified 


#define _Nullable 


#define _Nonnull 


#define _Null_unspecified 
# 282 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __disable_tail_calls 
# 294 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __not_tail_called 
# 303 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __result_use_check __attribute__((__warn_unused_result__))
# 315 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __swift_unavailable(_msg) 
# 324 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __abortlike __dead2 __cold __not_tail_called
# 349 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __header_inline extern __inline __attribute__((__gnu_inline__))
# 360 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __header_always_inline __header_inline __attribute__ ((__always_inline__))
# 379 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __unreachable_ok_push _Pragma("GCC diagnostic push") _Pragma("GCC diagnostic ignored \"-Wunreachable-code\"")


#define __unreachable_ok_pop _Pragma("GCC diagnostic pop")
# 397 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __printflike(fmtarg,firstvararg) __attribute__((__format__ (__printf__, fmtarg, firstvararg)))

#define __printf0like(fmtarg,firstvararg) __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))

#define __scanflike(fmtarg,firstvararg) __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))


#define __IDSTRING(name,string) static const char name[] __used = string


#define __COPYRIGHT(s) __IDSTRING(copyright,s)



#define __RCSID(s) __IDSTRING(rcsid,s)



#define __SCCSID(s) __IDSTRING(sccsid,s)



#define __PROJECT_VERSION(s) __IDSTRING(project_version,s)




#define __FBSDID(s) 



#define __DECONST(type,var) __CAST_AWAY_QUALIFIER(var, const, type)



#define __DEVOLATILE(type,var) __CAST_AWAY_QUALIFIER(var, volatile, type)



#define __DEQUALIFY(type,var) __CAST_AWAY_QUALIFIER(var, const volatile, type)
# 454 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __alloc_size(...) __attribute__((alloc_size(__VA_ARGS__)))
# 508 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_ONLY_64_BIT_INO_T 1
#define __DARWIN_ONLY_UNIX_CONFORMANCE 1
#define __DARWIN_ONLY_VERS_1050 1
# 536 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_UNIX03 1
# 568 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_64_BIT_INO_T 1
# 579 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_VERS_1050 1
# 588 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_NON_CANCELABLE 0







#define __DARWIN_SUF_UNIX03 






#define __DARWIN_SUF_64_BIT_INO_T 
# 613 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_SUF_1050 
# 624 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_SUF_NON_CANCELABLE 
# 634 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"




#define __DARWIN_ALIAS(sym) __asm("_" __STRING(sym) __DARWIN_SUF_UNIX03)
#define __DARWIN_ALIAS_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_NON_CANCELABLE __DARWIN_SUF_UNIX03)
#define __DARWIN_ALIAS_I(sym) __asm("_" __STRING(sym) __DARWIN_SUF_64_BIT_INO_T __DARWIN_SUF_UNIX03)
#define __DARWIN_NOCANCEL(sym) __asm("_" __STRING(sym) __DARWIN_SUF_NON_CANCELABLE)
#define __DARWIN_INODE64(sym) __asm("_" __STRING(sym) __DARWIN_SUF_64_BIT_INO_T)

#define __DARWIN_1050(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050)
#define __DARWIN_1050ALIAS(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_UNIX03)
#define __DARWIN_1050ALIAS_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_NON_CANCELABLE __DARWIN_SUF_UNIX03)
#define __DARWIN_1050ALIAS_I(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_64_BIT_INO_T __DARWIN_SUF_UNIX03)
#define __DARWIN_1050INODE64(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_64_BIT_INO_T)

#define __DARWIN_EXTSN(sym) __asm("_" __STRING(sym) __DARWIN_SUF_EXTSN)
#define __DARWIN_EXTSN_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_EXTSN __DARWIN_SUF_NON_CANCELABLE)




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_symbol_aliasing.h" 3 4
#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_5_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_5_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_6_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_6_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_7_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_7_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_5(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_6(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_7(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_5(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_15_0(x) 



#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_0(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_3(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_5(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_6(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_7(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_8(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_9(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_10(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_10_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_10_3(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_3(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_5(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_6(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_15(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_15_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_16(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_11_0(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_11_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_11_3(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_12_0(x) x
# 658 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 2 3 4




#define __DARWIN_ALIAS_STARTING(_mac,_iphone,x) __DARWIN_ALIAS_STARTING_MAC_ ##_mac(x)
# 723 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_posix_availability.h" 3 4
#define ___POSIX_C_DEPRECATED_STARTING_198808L 





#define ___POSIX_C_DEPRECATED_STARTING_199009L 





#define ___POSIX_C_DEPRECATED_STARTING_199209L 





#define ___POSIX_C_DEPRECATED_STARTING_199309L 





#define ___POSIX_C_DEPRECATED_STARTING_199506L 





#define ___POSIX_C_DEPRECATED_STARTING_200112L 





#define ___POSIX_C_DEPRECATED_STARTING_200809L 
# 724 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 2 3 4

#define __POSIX_C_DEPRECATED(ver) ___POSIX_C_DEPRECATED_STARTING_ ##ver







#define __DARWIN_C_ANSI 010000L
#define __DARWIN_C_FULL 900000L






#define __DARWIN_C_LEVEL __DARWIN_C_FULL







#define __STDC_WANT_LIB_EXT1__ 1
# 760 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_NO_LONG_LONG 0
# 772 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define _DARWIN_FEATURE_64_BIT_INODE 1
# 782 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define _DARWIN_FEATURE_ONLY_64_BIT_INODE 1







#define _DARWIN_FEATURE_ONLY_VERS_1050 1







#define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1







#define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
# 817 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __CAST_AWAY_QUALIFIER(variable,qualifier,type) (type) (long)(variable)







#define __XNU_PRIVATE_EXTERN __attribute__((visibility("hidden")))
# 842 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __compiler_barrier() __asm__ __volatile__("" ::: "memory")





#define __enum_open 
#define __enum_closed 





#define __enum_options 
# 875 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/cdefs.h" 3 4
#define __enum_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_open

#define __enum_closed_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_closed

#define __options_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_open __enum_options

#define __options_closed_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_closed __enum_options




#define __kernel_ptr_semantics 
#define __kernel_data_semantics 
#define __kernel_dual_semantics 
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/appleapiopts.h" 3 4
#define __SYS_APPLEAPIOPTS_H__ 



#define __APPLE_API_STANDARD 



#define __APPLE_API_STABLE 





#define __APPLE_API_EVOLVING 



#define __APPLE_API_UNSTABLE 



#define __APPLE_API_PRIVATE 



#define __APPLE_API_OBSOLETE 
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 3 4
#define _SYS_TIME_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types.h" 3 4
#define _SYS__TYPES_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/_types.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/_types.h" 3 4
#define _BSD_MACHINE__TYPES_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_types.h" 1 3 4




#define _BSD_ARM__TYPES_H_ 
# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_types.h" 3 4

# 15 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types.h" 2 3 4
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types.h" 3 4
#define __DARWIN_NULL ((void *)0)


typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
#define _SYS__PTHREAD_TYPES_H_ 





#define __PTHREAD_SIZE__ 8176
#define __PTHREAD_ATTR_SIZE__ 56
#define __PTHREAD_MUTEXATTR_SIZE__ 8
#define __PTHREAD_MUTEX_SIZE__ 56
#define __PTHREAD_CONDATTR_SIZE__ 8
#define __PTHREAD_COND_SIZE__ 40
#define __PTHREAD_ONCE_SIZE__ 8
#define __PTHREAD_RWLOCK_SIZE__ 192
#define __PTHREAD_RWLOCKATTR_SIZE__ 16
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types.h" 2 3 4


#define __offsetof(type,field) __builtin_offsetof(type, field)
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __AVAILABILITY__ 
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __API_TO_BE_DEPRECATED 100000


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/AvailabilityVersions.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/AvailabilityVersions.h" 3 4
#define __AVAILABILITY_VERSIONS__ 

#define __MAC_10_0 1000
#define __MAC_10_1 1010
#define __MAC_10_2 1020
#define __MAC_10_3 1030
#define __MAC_10_4 1040
#define __MAC_10_5 1050
#define __MAC_10_6 1060
#define __MAC_10_7 1070
#define __MAC_10_8 1080
#define __MAC_10_9 1090
#define __MAC_10_10 101000
#define __MAC_10_10_2 101002
#define __MAC_10_10_3 101003
#define __MAC_10_11 101100
#define __MAC_10_11_2 101102
#define __MAC_10_11_3 101103
#define __MAC_10_11_4 101104
#define __MAC_10_12 101200
#define __MAC_10_12_1 101201
#define __MAC_10_12_2 101202
#define __MAC_10_12_4 101204
#define __MAC_10_13 101300
#define __MAC_10_13_1 101301
#define __MAC_10_13_2 101302
#define __MAC_10_13_4 101304
#define __MAC_10_14 101400
#define __MAC_10_14_1 101401
#define __MAC_10_14_4 101404
#define __MAC_10_14_6 101406
#define __MAC_10_15 101500
#define __MAC_10_15_1 101501
#define __MAC_10_15_4 101504
#define __MAC_10_16 101600
#define __MAC_11_0 110000
#define __MAC_11_1 110100
#define __MAC_11_3 110300
#define __MAC_11_4 110400
#define __MAC_11_5 110500
#define __MAC_12_0 120000


#define __IPHONE_2_0 20000
#define __IPHONE_2_1 20100
#define __IPHONE_2_2 20200
#define __IPHONE_3_0 30000
#define __IPHONE_3_1 30100
#define __IPHONE_3_2 30200
#define __IPHONE_4_0 40000
#define __IPHONE_4_1 40100
#define __IPHONE_4_2 40200
#define __IPHONE_4_3 40300
#define __IPHONE_5_0 50000
#define __IPHONE_5_1 50100
#define __IPHONE_6_0 60000
#define __IPHONE_6_1 60100
#define __IPHONE_7_0 70000
#define __IPHONE_7_1 70100
#define __IPHONE_8_0 80000
#define __IPHONE_8_1 80100
#define __IPHONE_8_2 80200
#define __IPHONE_8_3 80300
#define __IPHONE_8_4 80400
#define __IPHONE_9_0 90000
#define __IPHONE_9_1 90100
#define __IPHONE_9_2 90200
#define __IPHONE_9_3 90300
#define __IPHONE_10_0 100000
#define __IPHONE_10_1 100100
#define __IPHONE_10_2 100200
#define __IPHONE_10_3 100300
#define __IPHONE_11_0 110000
#define __IPHONE_11_1 110100
#define __IPHONE_11_2 110200
#define __IPHONE_11_3 110300
#define __IPHONE_11_4 110400
#define __IPHONE_12_0 120000
#define __IPHONE_12_1 120100
#define __IPHONE_12_2 120200
#define __IPHONE_12_3 120300
#define __IPHONE_12_4 120400
#define __IPHONE_13_0 130000
#define __IPHONE_13_1 130100
#define __IPHONE_13_2 130200
#define __IPHONE_13_3 130300
#define __IPHONE_13_4 130400
#define __IPHONE_13_5 130500
#define __IPHONE_13_6 130600
#define __IPHONE_13_7 130700
#define __IPHONE_14_0 140000
#define __IPHONE_14_1 140100
#define __IPHONE_14_2 140200
#define __IPHONE_14_3 140300
#define __IPHONE_14_5 140500
#define __IPHONE_14_6 140600
#define __IPHONE_14_7 140700
#define __IPHONE_14_8 140800
#define __IPHONE_15_0 150000


#define __TVOS_9_0 90000
#define __TVOS_9_1 90100
#define __TVOS_9_2 90200
#define __TVOS_10_0 100000
#define __TVOS_10_0_1 100001
#define __TVOS_10_1 100100
#define __TVOS_10_2 100200
#define __TVOS_11_0 110000
#define __TVOS_11_1 110100
#define __TVOS_11_2 110200
#define __TVOS_11_3 110300
#define __TVOS_11_4 110400
#define __TVOS_12_0 120000
#define __TVOS_12_1 120100
#define __TVOS_12_2 120200
#define __TVOS_12_3 120300
#define __TVOS_12_4 120400
#define __TVOS_13_0 130000
#define __TVOS_13_2 130200
#define __TVOS_13_3 130300
#define __TVOS_13_4 130400
#define __TVOS_14_0 140000
#define __TVOS_14_1 140100
#define __TVOS_14_2 140200
#define __TVOS_14_3 140300
#define __TVOS_14_5 140500
#define __TVOS_14_6 140600
#define __TVOS_14_7 140700
#define __TVOS_15_0 150000

#define __WATCHOS_1_0 10000
#define __WATCHOS_2_0 20000
#define __WATCHOS_2_1 20100
#define __WATCHOS_2_2 20200
#define __WATCHOS_3_0 30000
#define __WATCHOS_3_1 30100
#define __WATCHOS_3_1_1 30101
#define __WATCHOS_3_2 30200
#define __WATCHOS_4_0 40000
#define __WATCHOS_4_1 40100
#define __WATCHOS_4_2 40200
#define __WATCHOS_4_3 40300
#define __WATCHOS_5_0 50000
#define __WATCHOS_5_1 50100
#define __WATCHOS_5_2 50200
#define __WATCHOS_5_3 50300
#define __WATCHOS_6_0 60000
#define __WATCHOS_6_1 60100
#define __WATCHOS_6_2 60200
#define __WATCHOS_7_0 70000
#define __WATCHOS_7_1 70100
#define __WATCHOS_7_2 70200
#define __WATCHOS_7_3 70300
#define __WATCHOS_7_4 70400
#define __WATCHOS_7_5 70500
#define __WATCHOS_7_6 70600
#define __WATCHOS_8_0 80000







#define MAC_OS_X_VERSION_10_0 1000
#define MAC_OS_X_VERSION_10_1 1010
#define MAC_OS_X_VERSION_10_2 1020
#define MAC_OS_X_VERSION_10_3 1030
#define MAC_OS_X_VERSION_10_4 1040
#define MAC_OS_X_VERSION_10_5 1050
#define MAC_OS_X_VERSION_10_6 1060
#define MAC_OS_X_VERSION_10_7 1070
#define MAC_OS_X_VERSION_10_8 1080
#define MAC_OS_X_VERSION_10_9 1090
#define MAC_OS_X_VERSION_10_10 101000
#define MAC_OS_X_VERSION_10_10_2 101002
#define MAC_OS_X_VERSION_10_10_3 101003
#define MAC_OS_X_VERSION_10_11 101100
#define MAC_OS_X_VERSION_10_11_2 101102
#define MAC_OS_X_VERSION_10_11_3 101103
#define MAC_OS_X_VERSION_10_11_4 101104
#define MAC_OS_X_VERSION_10_12 101200
#define MAC_OS_X_VERSION_10_12_1 101201
#define MAC_OS_X_VERSION_10_12_2 101202
#define MAC_OS_X_VERSION_10_12_4 101204
#define MAC_OS_X_VERSION_10_13 101300
#define MAC_OS_X_VERSION_10_13_1 101301
#define MAC_OS_X_VERSION_10_13_2 101302
#define MAC_OS_X_VERSION_10_13_4 101304
#define MAC_OS_X_VERSION_10_14 101400
#define MAC_OS_X_VERSION_10_14_1 101401
#define MAC_OS_X_VERSION_10_14_4 101404
#define MAC_OS_X_VERSION_10_14_6 101406
#define MAC_OS_X_VERSION_10_15 101500
#define MAC_OS_X_VERSION_10_15_1 101501
#define MAC_OS_X_VERSION_10_16 101600
#define MAC_OS_VERSION_11_0 110000
#define MAC_OS_VERSION_12_0 120000



#define __DRIVERKIT_19_0 190000
#define __DRIVERKIT_20_0 200000
#define __DRIVERKIT_21_0 210000
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 2 3 4
# 1 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 1 3 4
# 40 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 3 4
#define __AVAILABILITY_INTERNAL__ 
# 49 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 3 4
#define __MAC_OS_X_VERSION_MIN_REQUIRED __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
# 102 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 3 4
#define __MAC_OS_X_VERSION_MAX_ALLOWED __MAC_12_3
# 118 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 3 4
#define __AVAILABILITY_INTERNAL_DEPRECATED __attribute__((deprecated))




#define __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg) __attribute__((deprecated))






#define __AVAILABILITY_INTERNAL_UNAVAILABLE __attribute__((unavailable))
#define __AVAILABILITY_INTERNAL_WEAK_IMPORT __attribute__((weak_import))
#define __AVAILABILITY_INTERNAL_REGULAR 
# 157 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 3 4
#define __ENABLE_LEGACY_MAC_AVAILABILITY 1
# 4703 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 3 4
#define __API_AVAILABLE_GET_MACRO(...) 
#define __API_AVAILABLE_BEGIN_GET_MACRO(...) 
#define __API_DEPRECATED_MSG_GET_MACRO(...) 
#define __API_DEPRECATED_REP_GET_MACRO(...) 
#define __API_DEPRECATED_BEGIN_MSG_GET_MACRO(...) 
#define __API_DEPRECATED_BEGIN_REP_GET_MACRO 
#define __API_UNAVAILABLE_GET_MACRO(...) 
#define __API_UNAVAILABLE_BEGIN_GET_MACRO(...) 
# 4745 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/AvailabilityInternal.h" 3 4
#define __swift_compiler_version_at_least(...) 1







#define __SPI_AVAILABLE(...) 
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 2 3 4
# 178 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __OSX_AVAILABLE_STARTING(_osx,_ios) 
#define __OSX_AVAILABLE_BUT_DEPRECATED(_osxIntro,_osxDep,_iosIntro,_iosDep) 
#define __OSX_AVAILABLE_BUT_DEPRECATED_MSG(_osxIntro,_osxDep,_iosIntro,_iosDep,_msg) 
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __OS_AVAILABILITY(_target,_availability) 
#define __OS_AVAILABILITY_MSG(_target,_availability,_msg) 
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __OSX_EXTENSION_UNAVAILABLE(_msg) 
#define __IOS_EXTENSION_UNAVAILABLE(_msg) 






#define __OS_EXTENSION_UNAVAILABLE(_msg) __OSX_EXTENSION_UNAVAILABLE(_msg) __IOS_EXTENSION_UNAVAILABLE(_msg)
# 241 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __OSX_UNAVAILABLE 



#define __OSX_AVAILABLE(_vers) 



#define __OSX_DEPRECATED(_start,_dep,_msg) 
# 264 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __IOS_UNAVAILABLE 



#define __IOS_PROHIBITED 



#define __IOS_AVAILABLE(_vers) 



#define __IOS_DEPRECATED(_start,_dep,_msg) 
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __TVOS_UNAVAILABLE 



#define __TVOS_PROHIBITED 



#define __TVOS_AVAILABLE(_vers) 



#define __TVOS_DEPRECATED(_start,_dep,_msg) 
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __WATCHOS_UNAVAILABLE 



#define __WATCHOS_PROHIBITED 



#define __WATCHOS_AVAILABLE(_vers) 



#define __WATCHOS_DEPRECATED(_start,_dep,_msg) 
# 343 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __SWIFT_UNAVAILABLE 



#define __SWIFT_UNAVAILABLE_MSG(_msg) 
# 429 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __API_AVAILABLE(...) 
#define __API_AVAILABLE_BEGIN(...) 
#define __API_AVAILABLE_END 
#define __API_DEPRECATED(...) 
#define __API_DEPRECATED_WITH_REPLACEMENT(...) 
#define __API_DEPRECATED_BEGIN(...) 
#define __API_DEPRECATED_END 
#define __API_DEPRECATED_WITH_REPLACEMENT_BEGIN(...) 
#define __API_DEPRECATED_WITH_REPLACEMENT_END 
#define __API_UNAVAILABLE(...) 
#define __API_UNAVAILABLE_BEGIN(...) 
#define __API_UNAVAILABLE_END 
# 475 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/Availability.h" 3 4
#define __SPI_DEPRECATED(...) 



#define __SPI_DEPRECATED_WITH_REPLACEMENT(...) 
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_def.h" 3 4
#define _FD_SET 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/types.h" 3 4
#define _BSD_MACHINE_TYPES_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 3 4
#define _ARM_MACHTYPES_H_ 
#define _MACHTYPES_H_ 
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int8_t.h" 3 4
#define _INT8_T 
typedef signed char int8_t;
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int16_t.h" 3 4
#define _INT16_T 
typedef short int16_t;
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int32_t.h" 3 4
#define _INT32_T 
typedef int int32_t;
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_int64_t.h" 3 4
#define _INT64_T 
typedef long long int64_t;
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
#define _U_INT8_T 
typedef unsigned char u_int8_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
#define _U_INT16_T 
typedef unsigned short u_int16_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
#define _U_INT32_T 
typedef unsigned int u_int32_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
#define _U_INT64_T 
typedef unsigned long long u_int64_t;
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4


typedef int64_t register_t;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
#define _INTPTR_T 
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/types.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
#define _UINTPTR_T 




typedef unsigned long uintptr_t;
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 2 3 4




typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 3 4
#define USER_ADDR_NULL ((user_addr_t) 0)
#define CAST_USER_ADDR_T(a_ptr) ((user_addr_t)((uintptr_t)(a_ptr)))
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/types.h" 3 4
typedef u_int64_t syscall_arg_t;
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/types.h" 2 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_def.h" 2 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_def.h" 3 4
#define __DARWIN_FD_SETSIZE 1024

#define __DARWIN_NBBY 8
#define __DARWIN_NFDBITS (sizeof(__int32_t) * __DARWIN_NBBY)
#define __DARWIN_howmany(x,y) ((((x) % (y)) == 0) ? ((x) / (y)) : (((x) / (y)) + 1))


typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

int __darwin_check_fd_set_overflow(int, const void *, int) ;


extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int
__darwin_check_fd_set(int _a, const void *_b)
{




 if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t) 0) {



  return __darwin_check_fd_set_overflow(_a, _b, 0);

 } else {
  return 1;
 }



}


extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int
__darwin_fd_isset(int _fd, const struct fd_set *_p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
 }

 return 0;
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void
__darwin_fd_set(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void
__darwin_fd_clr(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}


#define __DARWIN_FD_SET(n,p) __darwin_fd_set((n), (p))
#define __DARWIN_FD_CLR(n,p) __darwin_fd_clr((n), (p))
#define __DARWIN_FD_ISSET(n,p) __darwin_fd_isset((n), (p))






#define __DARWIN_FD_ZERO(p) __builtin_bzero(p, sizeof(*(p)))




#define __DARWIN_FD_COPY(f,t) bcopy(f, t, sizeof(*(f)))
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_timespec.h" 3 4
#define _STRUCT_TIMESPEC struct timespec



struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_timeval.h" 3 4
#define _STRUCT_TIMEVAL struct timeval




struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_timeval64.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_timeval64.h" 3 4
#define _STRUCT_TIMEVAL64 



struct timeval64 {
 __int64_t tv_sec;
 __int64_t tv_usec;
};
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_time_t.h" 3 4
#define _TIME_T 

typedef __darwin_time_t time_t;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
#define _SUSECONDS_T 

typedef __darwin_suseconds_t suseconds_t;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4





struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};





#define ITIMER_REAL 0
#define ITIMER_VIRTUAL 1
#define ITIMER_PROF 2







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_setsize.h" 3 4
#define FD_SETSIZE __DARWIN_FD_SETSIZE
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_set.h" 3 4
#define FD_SET(n,p) __DARWIN_FD_SET(n, p)
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_clr.h" 3 4
#define FD_CLR(n,p) __DARWIN_FD_CLR(n, p)
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_isset.h" 3 4
#define FD_ISSET(n,p) __DARWIN_FD_ISSET(n, p)
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_zero.h" 3 4
#define FD_ZERO(p) __DARWIN_FD_ZERO(p)
# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fd_copy.h" 3 4
#define FD_COPY(f,t) __DARWIN_FD_COPY(f, t)
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4

#define TIMEVAL_TO_TIMESPEC(tv,ts) { (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }



#define TIMESPEC_TO_TIMEVAL(tv,ts) { (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }




struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
#define DST_NONE 0
#define DST_USA 1
#define DST_AUST 2
#define DST_WET 3
#define DST_MET 4
#define DST_EET 5
#define DST_CAN 6


#define timerclear(tvp) (tvp)->tv_sec = (tvp)->tv_usec = 0
#define timerisset(tvp) ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp,uvp,cmp) (((tvp)->tv_sec == (uvp)->tv_sec) ? ((tvp)->tv_usec cmp (uvp)->tv_usec) : ((tvp)->tv_sec cmp (uvp)->tv_sec))



#define timeradd(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec; if ((vvp)->tv_usec >= 1000000) { (vvp)->tv_sec++; (vvp)->tv_usec -= 1000000; } } while (0)
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 3 4
#define timersub(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec; if ((vvp)->tv_usec < 0) { (vvp)->tv_sec--; (vvp)->tv_usec += 1000000; } } while (0)
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 3 4
#define timevalcmp(l,r,cmp) timercmp(l, r, cmp)




struct clockinfo {
 int hz;
 int tick;
 int tickadj;
 int stathz;
 int profhz;
};
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 3 4



int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *) ;
int settimeofday(const struct timeval *, const struct timezone *);


int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * restrict, void * restrict);

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_select.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_select.h" 3 4
#define _SYS__SELECT_H_ 





int select(int, fd_set * restrict, fd_set * restrict,
    fd_set * restrict, struct timeval * restrict)





__asm("_" "select" )




;
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/time.h" 2 3 4

int setitimer(int, const struct itimerval * restrict,
    struct itimerval * restrict);
int utimes(const char *, const struct timeval *);


# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ucred.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ucred.h" 3 4
#define _SYS_UCRED_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 3 4
#define _SYS_PARAM_H_ 

#define BSD 199506
#define BSD4_3 1
#define BSD4_4 1

#define NeXTBSD 1995064
#define NeXTBSD4_0 0


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 3 4
#define _SYS_TYPES_H_ 
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/endian.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/endian.h" 3 4
#define _BSD_MACHINE_ENDIAN_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/endian.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/endian.h" 3 4
#define _ARM__ENDIAN_H_ 
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/endian.h" 3 4
#define _QUAD_HIGHWORD 1
#define _QUAD_LOWWORD 0





#define __DARWIN_LITTLE_ENDIAN 1234
#define __DARWIN_BIG_ENDIAN 4321
#define __DARWIN_PDP_ENDIAN 3412

#define __DARWIN_BYTE_ORDER __DARWIN_LITTLE_ENDIAN



#define LITTLE_ENDIAN __DARWIN_LITTLE_ENDIAN
#define BIG_ENDIAN __DARWIN_BIG_ENDIAN
#define PDP_ENDIAN __DARWIN_PDP_ENDIAN

#define BYTE_ORDER __DARWIN_BYTE_ORDER

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_endian.h" 1 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_endian.h" 3 4
#define _SYS__ENDIAN_H_ 
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
#define _OS__OSBYTEORDER_H 
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
#define __DARWIN_OSSwapConstInt16(x) ((__uint16_t)((((__uint16_t)(x) & 0xff00U) >> 8) | (((__uint16_t)(x) & 0x00ffU) << 8)))



#define __DARWIN_OSSwapConstInt32(x) ((__uint32_t)((((__uint32_t)(x) & 0xff000000U) >> 24) | (((__uint32_t)(x) & 0x00ff0000U) >> 8) | (((__uint32_t)(x) & 0x0000ff00U) << 8) | (((__uint32_t)(x) & 0x000000ffU) << 24)))





#define __DARWIN_OSSwapConstInt64(x) ((__uint64_t)((((__uint64_t)(x) & 0xff00000000000000ULL) >> 56) | (((__uint64_t)(x) & 0x00ff000000000000ULL) >> 40) | (((__uint64_t)(x) & 0x0000ff0000000000ULL) >> 24) | (((__uint64_t)(x) & 0x000000ff00000000ULL) >> 8) | (((__uint64_t)(x) & 0x00000000ff000000ULL) << 8) | (((__uint64_t)(x) & 0x0000000000ff0000ULL) << 24) | (((__uint64_t)(x) & 0x000000000000ff00ULL) << 40) | (((__uint64_t)(x) & 0x00000000000000ffULL) << 56)))
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
#define __DARWIN_OS_INLINE static inline
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 1 3 4





#define _OS_OSBYTEORDERARM_H 

# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdint.h" 1 3 4







       
#define _STDINT 



# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/vcruntime.h" 1 3 4
# 14 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdint.h" 2 3 4



typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long intmax_t;
typedef unsigned long long uintmax_t;


#define INT8_MIN (-127i8 - 1)
#define INT16_MIN (-32767i16 - 1)
#define INT32_MIN (-2147483647i32 - 1)
#define INT64_MIN (-9223372036854775807i64 - 1)
#define INT8_MAX 127i8
#define INT16_MAX 32767i16
#define INT32_MAX 2147483647i32
#define INT64_MAX 9223372036854775807i64
#define UINT8_MAX 0xffui8
#define UINT16_MAX 0xffffui16
#define UINT32_MAX 0xffffffffui32
#define UINT64_MAX 0xffffffffffffffffui64

#define INT_LEAST8_MIN INT8_MIN
#define INT_LEAST16_MIN INT16_MIN
#define INT_LEAST32_MIN INT32_MIN
#define INT_LEAST64_MIN INT64_MIN
#define INT_LEAST8_MAX INT8_MAX
#define INT_LEAST16_MAX INT16_MAX
#define INT_LEAST32_MAX INT32_MAX
#define INT_LEAST64_MAX INT64_MAX
#define UINT_LEAST8_MAX UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX

#define INT_FAST8_MIN INT8_MIN
#define INT_FAST16_MIN INT32_MIN
#define INT_FAST32_MIN INT32_MIN
#define INT_FAST64_MIN INT64_MIN
#define INT_FAST8_MAX INT8_MAX
#define INT_FAST16_MAX INT32_MAX
#define INT_FAST32_MAX INT32_MAX
#define INT_FAST64_MAX INT64_MAX
#define UINT_FAST8_MAX UINT8_MAX
#define UINT_FAST16_MAX UINT32_MAX
#define UINT_FAST32_MAX UINT32_MAX
#define UINT_FAST64_MAX UINT64_MAX






#define INTPTR_MIN INT32_MIN
#define INTPTR_MAX INT32_MAX
#define UINTPTR_MAX UINT32_MAX


#define INTMAX_MIN INT64_MIN
#define INTMAX_MAX INT64_MAX
#define UINTMAX_MAX UINT64_MAX

#define PTRDIFF_MIN INTPTR_MIN
#define PTRDIFF_MAX INTPTR_MAX





#define SIG_ATOMIC_MIN INT32_MIN
#define SIG_ATOMIC_MAX INT32_MAX

#define WCHAR_MIN 0x0000
#define WCHAR_MAX 0xffff

#define WINT_MIN 0x0000
#define WINT_MAX 0xffff

#define INT8_C(x) (x)
#define INT16_C(x) (x)
#define INT32_C(x) (x)
#define INT64_C(x) (x ## LL)

#define UINT8_C(x) (x)
#define UINT16_C(x) (x)
#define UINT32_C(x) (x ## U)
#define UINT64_C(x) (x ## ULL)

#define INTMAX_C(x) INT64_C(x)
#define UINTMAX_C(x) UINT64_C(x)
# 9 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/arch.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/arch.h" 3 4
#define _ARM_ARCH_H 
# 10 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 2 3 4



static inline
uint16_t
_OSSwapInt16(
 uint16_t _data
 )
{

 return (uint16_t)(_data << 8 | _data >> 8);
}

static inline
uint32_t
_OSSwapInt32(
 uint32_t _data
 )
{




 _data = (((_data ^ (_data >> 16 | (_data << 16))) & 0xFF00FFFF) >> 8) ^ (_data >> 8 | _data << 24);


 return _data;
}

static inline
uint64_t
_OSSwapInt64(
 uint64_t _data
 )
{



 union {
  uint64_t _ull;
  uint32_t _ul[2];
 } _u;


 _u._ul[0] = (uint32_t)(_data >> 32);
 _u._ul[1] = (uint32_t)(_data & 0xffffffff);
 _u._ul[0] = _OSSwapInt32(_u._ul[0]);
 _u._ul[1] = _OSSwapInt32(_u._ul[1]);
 return _u._ull;

}



struct _OSUnalignedU16 {
 volatile uint16_t __val;
} __attribute__((__packed__));

struct _OSUnalignedU32 {
 volatile uint32_t __val;
} __attribute__((__packed__));

struct _OSUnalignedU64 {
 volatile uint64_t __val;
} __attribute__((__packed__));
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint16_t
OSReadSwapInt16(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt16(((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val);
}
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint32_t
OSReadSwapInt32(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt32(((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val);
}
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
uint64_t
OSReadSwapInt64(
 const volatile void * _base,
 uintptr_t _offset
 )
{
 return _OSSwapInt64(((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val);
}
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt16(
 volatile void * _base,
 uintptr_t _offset,
 uint16_t _data
 )
{
 ((struct _OSUnalignedU16 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt16(_data);
}
# 180 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt32(
 volatile void * _base,
 uintptr_t _offset,
 uint32_t _data
 )
{
 ((struct _OSUnalignedU32 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt32(_data);
}
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/arm/OSByteOrder.h" 3 4
static inline
void
OSWriteSwapInt64(
 volatile void * _base,
 uintptr_t _offset,
 uint64_t _data
 )
{
 ((struct _OSUnalignedU64 *)((uintptr_t)_base + _offset))->__val = _OSSwapInt64(_data);
}
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4



#define __DARWIN_OSSwapInt16(x) ((__uint16_t)(__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt16(x) : _OSSwapInt16(x)))


#define __DARWIN_OSSwapInt32(x) (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt32(x) : _OSSwapInt32(x))


#define __DARWIN_OSSwapInt64(x) (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt64(x) : _OSSwapInt64(x))
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_endian.h" 2 3 4

#define ntohs(x) __DARWIN_OSSwapInt16(x)
#define htons(x) __DARWIN_OSSwapInt16(x)

#define ntohl(x) __DARWIN_OSSwapInt32(x)
#define htonl(x) __DARWIN_OSSwapInt32(x)



#define ntohll(x) __DARWIN_OSSwapInt64(x)
#define htonll(x) __DARWIN_OSSwapInt64(x)

#define NTOHL(x) (x) = ntohl((__uint32_t)x)
#define NTOHS(x) (x) = ntohs((__uint16_t)x)
#define NTOHLL(x) (x) = ntohll((__uint64_t)x)
#define HTONL(x) (x) = htonl((__uint32_t)x)
#define HTONS(x) (x) = htons((__uint16_t)x)
#define HTONLL(x) (x) = htonll((__uint64_t)x)
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/endian.h" 2 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/endian.h" 2 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_char.h" 3 4
#define _U_CHAR 
typedef unsigned char u_char;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_short.h" 3 4
#define _U_SHORT 
typedef unsigned short u_short;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_u_int.h" 3 4
#define _U_INT 
typedef unsigned int u_int;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;
#define _U_LONG 

typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
#define _CADDR_T 
typedef char * caddr_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_dev_t.h" 3 4
#define _DEV_T 

typedef __darwin_dev_t dev_t;
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4

typedef u_int32_t fixpt_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
#define _BLKCNT_T 

typedef __darwin_blkcnt_t blkcnt_t;
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
#define _BLKSIZE_T 

typedef __darwin_blksize_t blksize_t;
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_gid_t.h" 3 4
#define _GID_T 

typedef __darwin_gid_t gid_t;
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
#define _IN_ADDR_T 

typedef __uint32_t in_addr_t;
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
#define _IN_PORT_T 

typedef __uint16_t in_port_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ino_t.h" 3 4
#define _INO_T 

typedef __darwin_ino_t ino_t;
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ino64_t.h" 3 4
#define _INO64_T 

typedef __darwin_ino64_t ino64_t;
# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_key_t.h" 3 4
#define _KEY_T 

typedef __int32_t key_t;
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_mode_t.h" 3 4
#define _MODE_T 

typedef __darwin_mode_t mode_t;
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
#define _NLINK_T 

typedef __uint16_t nlink_t;
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_id_t.h" 3 4
#define _ID_T 

typedef __darwin_id_t id_t;
# 122 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_pid_t.h" 3 4
#define _PID_T 

typedef __darwin_pid_t pid_t;
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_off_t.h" 3 4
#define _OFF_T 

typedef __darwin_off_t off_t;
# 124 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t segsz_t;
typedef int32_t swblk_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_uid_t.h" 3 4
#define _UID_T 

typedef __darwin_uid_t uid_t;
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 3 4
#define major(x) ((int32_t)(((u_int32_t)(x) >> 24) & 0xff))
#define minor(x) ((int32_t)((x) & 0xffffff))
#define makedev(x,y) ((dev_t)(((x) << 24) | (y)))




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_clock_t.h" 3 4
#define _CLOCK_T 

typedef __darwin_clock_t clock_t;
# 166 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_size_t.h" 3 4
#define _SIZE_T 

typedef __darwin_size_t size_t;
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
#define _SSIZE_T 

typedef __darwin_ssize_t ssize_t;
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
#define _USECONDS_T 

typedef __darwin_useconds_t useconds_t;
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_rsize_t.h" 3 4
#define _RSIZE_T 

typedef __darwin_size_t rsize_t;
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_errno_t.h" 3 4
#define _ERRNO_T 
typedef int errno_t;
# 176 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 186 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 3 4
#define NBBY __DARWIN_NBBY
#define NFDBITS __DARWIN_NFDBITS
#define howmany(x,y) __DARWIN_howmany(x, y)
typedef __int32_t fd_mask;
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
#define _PTHREAD_ATTR_T 

typedef __darwin_pthread_attr_t pthread_attr_t;
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
#define _PTHREAD_COND_T 

typedef __darwin_pthread_cond_t pthread_cond_t;
# 217 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
#define _PTHREAD_CONDATTR_T 

typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
#define _PTHREAD_MUTEX_T 

typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
#define _PTHREAD_MUTEXATTR_T 

typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
#define _PTHREAD_ONCE_T 

typedef __darwin_pthread_once_t pthread_once_t;
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
#define _PTHREAD_RWLOCK_T 

typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 222 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
#define _PTHREAD_RWLOCKATTR_T 

typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 223 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
#define _PTHREAD_T 

typedef __darwin_pthread_t pthread_t;
# 224 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
#define _PTHREAD_KEY_T 

typedef __darwin_pthread_key_t pthread_key_t;
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
#define _FSBLKCNT_T 

typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 233 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
#define _FSFILCNT_T 

typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 234 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/types.h" 2 3 4
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 2 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/syslimits.h" 3 4
#define _SYS_SYSLIMITS_H_ 







#define ARG_MAX (1024 * 1024)
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/syslimits.h" 3 4
#define CHILD_MAX 266
#define GID_MAX 2147483647U

#define LINK_MAX 32767
#define MAX_CANON 1024
#define MAX_INPUT 1024
#define NAME_MAX 255
#define NGROUPS_MAX 16

#define UID_MAX 2147483647U

#define OPEN_MAX 10240


#define PATH_MAX 1024
#define PIPE_BUF 512

#define BC_BASE_MAX 99
#define BC_DIM_MAX 2048
#define BC_SCALE_MAX 99
#define BC_STRING_MAX 1000
#define CHARCLASS_NAME_MAX 14
#define COLL_WEIGHTS_MAX 2
#define EQUIV_CLASS_MAX 2
#define EXPR_NEST_MAX 32
#define LINE_MAX 2048
#define RE_DUP_MAX 255


#define NZERO 20
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 2 3 4

#define MAXCOMLEN 16
#define MAXINTERP 64
#define MAXLOGNAME 255
#define MAXUPRC CHILD_MAX
#define NCARGS ARG_MAX
#define NGROUPS NGROUPS_MAX
#define NOFILE 256
#define NOGROUP 65535
#define MAXHOSTNAMELEN 256
#define MAXDOMNAMELEN 256


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/param.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/param.h" 3 4
#define _BSD_MACHINE_PARAM_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/param.h" 1 3 4
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/param.h" 3 4
#define _ARM_PARAM_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_param.h" 1 3 4





#define _ARM__PARAM_H_ 
# 17 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_param.h" 3 4
#define __DARWIN_ALIGNBYTES (sizeof(__darwin_size_t) - 1)
#define __DARWIN_ALIGN(p) ((__darwin_size_t)((__darwin_size_t)(p) + __DARWIN_ALIGNBYTES) &~ __DARWIN_ALIGNBYTES)

#define __DARWIN_ALIGNBYTES32 (sizeof(__uint32_t) - 1)
#define __DARWIN_ALIGN32(p) ((__darwin_size_t)((__darwin_size_t)(p) + __DARWIN_ALIGNBYTES32) &~ __DARWIN_ALIGNBYTES32)
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/param.h" 2 3 4






#define ALIGNBYTES __DARWIN_ALIGNBYTES
#define ALIGN(p) __DARWIN_ALIGN(p)

#define NBPG 4096
#define PGOFSET (NBPG-1)
#define PGSHIFT 12

#define DEV_BSIZE 512
#define DEV_BSHIFT 9
#define BLKDEV_IOSIZE 2048
#define MAXPHYS (64 * 1024)

#define CLSIZE 1
#define CLSIZELOG2 0
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/param.h" 3 4
#define MSIZESHIFT 8
#define MSIZE (1 << MSIZESHIFT)
#define MCLSHIFT 11
#define MCLBYTES (1 << MCLSHIFT)
#define MBIGCLSHIFT 12
#define MBIGCLBYTES (1 << MBIGCLSHIFT)
#define M16KCLSHIFT 14
#define M16KCLBYTES (1 << M16KCLSHIFT)

#define MCLOFSET (MCLBYTES - 1)

#define NMBCLUSTERS CONFIG_NMBCLUSTERS






#define ctos(x) (x)
#define stoc(x) (x)


#define ctod(x) ((x)<<(PGSHIFT-DEV_BSHIFT))
#define dtoc(x) ((x)>>(PGSHIFT-DEV_BSHIFT))
#define dtob(x) ((x)<<DEV_BSHIFT)


#define ctob(x) ((x)<<PGSHIFT)


#define btoc(x) (((unsigned)(x)+(NBPG-1))>>PGSHIFT)


#define btodb(bytes,devBlockSize) ((unsigned)(bytes) / devBlockSize)

#define dbtob(db,devBlockSize) ((unsigned)(db) * devBlockSize)
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/param.h" 3 4
#define bdbtofsb(bn) ((bn) / (BLKDEV_IOSIZE/DEV_BSIZE))




#define STATUS_WORD(rpl,ipl) (((ipl) << 8) | (rpl))
#define USERMODE(x) (((x) & 3) == 3)
#define BASEPRI(x) (((x) & (255 << 8)) == 0)






#define DELAY(n) { int N = (n); while (--N > 0); }
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/param.h" 2 3 4
# 108 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 2 3 4


# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h" 1 3 4
# 19 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h" 3 4
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/crtdefs.h" 1 3 4
# 20 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/limits.h" 2 3 4
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 3 4
#define _SYS_SIGNAL_H_ 





#define __DARWIN_NSIG 32


#define NSIG __DARWIN_NSIG


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/signal.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/signal.h" 3 4
#define _BSD_MACHINE_SIGNAL_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/signal.h" 1 3 4
# 10 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/signal.h" 3 4
#define _ARM_SIGNAL_ 1






typedef int sig_atomic_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 2 3 4

#define SIGHUP 1
#define SIGINT 2
#define SIGQUIT 3
#define SIGILL 4
#define SIGTRAP 5
#define SIGABRT 6



#define SIGIOT SIGABRT
#define SIGEMT 7

#define SIGFPE 8
#define SIGKILL 9
#define SIGBUS 10
#define SIGSEGV 11
#define SIGSYS 12
#define SIGPIPE 13
#define SIGALRM 14
#define SIGTERM 15
#define SIGURG 16
#define SIGSTOP 17
#define SIGTSTP 18
#define SIGCONT 19
#define SIGCHLD 20
#define SIGTTIN 21
#define SIGTTOU 22

#define SIGIO 23

#define SIGXCPU 24
#define SIGXFSZ 25
#define SIGVTALRM 26
#define SIGPROF 27

#define SIGWINCH 28
#define SIGINFO 29

#define SIGUSR1 30
#define SIGUSR2 31







#define SIG_DFL (void (*)(int))0
#define SIG_IGN (void (*)(int))1
#define SIG_HOLD (void (*)(int))5
#define SIG_ERR ((void (*)(int))-1)
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/_mcontext.h" 3 4
#define _BSD_MACHINE__MCONTEXT_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_mcontext.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_mcontext.h" 3 4
#define __ARM_MCONTEXT_H_ 





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/_structs.h" 3 4
#define _MACH_MACHINE__STRUCTS_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _MACH_ARM__STRUCTS_H_ 







#define _STRUCT_ARM_EXCEPTION_STATE struct __darwin_arm_exception_state
struct __darwin_arm_exception_state
{
 __uint32_t __exception;
 __uint32_t __fsr;
 __uint32_t __far;
};
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_EXCEPTION_STATE64 struct __darwin_arm_exception_state64
struct __darwin_arm_exception_state64
{
 __uint64_t __far;
 __uint32_t __esr;
 __uint32_t __exception;
};
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_THREAD_STATE struct __darwin_arm_thread_state
struct __darwin_arm_thread_state
{
 __uint32_t __r[13];
 __uint32_t __sp;
 __uint32_t __lr;
 __uint32_t __pc;
 __uint32_t __cpsr;
};
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define __DARWIN_OPAQUE_ARM_THREAD_STATE64 0
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_THREAD_STATE64 struct __darwin_arm_thread_state64
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
struct __darwin_arm_thread_state64
{
 __uint64_t __x[29];
 __uint64_t __fp;
 __uint64_t __lr;
 __uint64_t __sp;
 __uint64_t __pc;
 __uint32_t __cpsr;
 __uint32_t __pad;
};
# 347 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define __darwin_arm_thread_state64_get_pc(ts) ((ts).__pc)


#define __darwin_arm_thread_state64_get_pc_fptr(ts) ((void*)(uintptr_t)((ts).__pc))


#define __darwin_arm_thread_state64_set_pc_fptr(ts,fptr) ((ts).__pc = (uintptr_t)(fptr))


#define __darwin_arm_thread_state64_get_lr(ts) ((ts).__lr)


#define __darwin_arm_thread_state64_get_lr_fptr(ts) ((void*)(uintptr_t)((ts).__lr))


#define __darwin_arm_thread_state64_set_lr_fptr(ts,fptr) ((ts).__lr = (uintptr_t)(fptr))


#define __darwin_arm_thread_state64_get_sp(ts) ((ts).__sp)


#define __darwin_arm_thread_state64_set_sp(ts,ptr) ((ts).__sp = (uintptr_t)(ptr))


#define __darwin_arm_thread_state64_get_fp(ts) ((ts).__fp)


#define __darwin_arm_thread_state64_set_fp(ts,ptr) ((ts).__fp = (uintptr_t)(ptr))


#define __darwin_arm_thread_state64_ptrauth_strip(ts) (void)(ts)
# 423 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_VFP_STATE struct __darwin_arm_vfp_state
struct __darwin_arm_vfp_state
{
 __uint32_t __r[64];
 __uint32_t __fpscr;
};
# 439 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_NEON_STATE64 struct __darwin_arm_neon_state64
#define _STRUCT_ARM_NEON_STATE struct __darwin_arm_neon_state


struct __darwin_arm_neon_state64
{
 __uint128_t __v[32];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};

struct __darwin_arm_neon_state
{
 __uint128_t __v[16];
 __uint32_t __fpsr;
 __uint32_t __fpcr;
};
# 513 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_AMX_STATE_V1 struct __darwin_arm_amx_state_v1
struct __darwin_arm_amx_state_v1
{
 __uint8_t __x[8][64];
 __uint8_t __y[8][64];
 __uint8_t __z[64][64];
 __uint64_t __amx_state_t_el1;
} __attribute__((aligned(64)));
# 532 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_PAGEIN_STATE struct __arm_pagein_state
struct __arm_pagein_state
{
 int __pagein_error;
};
# 569 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_LEGACY_DEBUG_STATE struct __arm_legacy_debug_state
struct __arm_legacy_debug_state
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
};
# 592 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_DEBUG_STATE32 struct __darwin_arm_debug_state32
struct __darwin_arm_debug_state32
{
 __uint32_t __bvr[16];
 __uint32_t __bcr[16];
 __uint32_t __wvr[16];
 __uint32_t __wcr[16];
 __uint64_t __mdscr_el1;
};

#define _STRUCT_ARM_DEBUG_STATE64 struct __darwin_arm_debug_state64
struct __darwin_arm_debug_state64
{
 __uint64_t __bvr[16];
 __uint64_t __bcr[16];
 __uint64_t __wvr[16];
 __uint64_t __wcr[16];
 __uint64_t __mdscr_el1;
};
# 634 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/_structs.h" 3 4
#define _STRUCT_ARM_CPMU_STATE64 struct __darwin_arm_cpmu_state64
struct __darwin_arm_cpmu_state64
{
 __uint64_t __ctrs[16];
};
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_mcontext.h" 2 3 4



#define _STRUCT_MCONTEXT32 struct __darwin_mcontext32
struct __darwin_mcontext32
{
 struct __darwin_arm_exception_state __es;
 struct __darwin_arm_thread_state __ss;
 struct __darwin_arm_vfp_state __fs;
};
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_mcontext.h" 3 4
#define _STRUCT_MCONTEXT64 struct __darwin_mcontext64
struct __darwin_mcontext64
{
 struct __darwin_arm_exception_state64 __es;
 struct __darwin_arm_thread_state64 __ss;
 struct __darwin_arm_neon_state64 __ns;
};
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/arm/_mcontext.h" 3 4
#define _MCONTEXT_T 

typedef struct __darwin_mcontext64 *mcontext_t;
#define _STRUCT_MCONTEXT _STRUCT_MCONTEXT64
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
#define _STRUCT_SIGALTSTACK struct __darwin_sigaltstack






struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ucontext.h" 3 4
#define _STRUCT_UCONTEXT struct __darwin_ucontext
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_ucontext.h" 3 4
struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
#define _SIGSET_T 

typedef __darwin_sigset_t sigset_t;
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 2 3 4



union sigval {

 int sival_int;
 void *sival_ptr;
};

#define SIGEV_NONE 0
#define SIGEV_SIGNAL 1
#define SIGEV_THREAD 3

struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 206 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 3 4
#define ILL_NOOP 0

#define ILL_ILLOPC 1
#define ILL_ILLTRP 2
#define ILL_PRVOPC 3
#define ILL_ILLOPN 4
#define ILL_ILLADR 5
#define ILL_PRVREG 6
#define ILL_COPROC 7
#define ILL_BADSTK 8



#define FPE_NOOP 0

#define FPE_FLTDIV 1
#define FPE_FLTOVF 2
#define FPE_FLTUND 3
#define FPE_FLTRES 4
#define FPE_FLTINV 5
#define FPE_FLTSUB 6
#define FPE_INTDIV 7
#define FPE_INTOVF 8



#define SEGV_NOOP 0

#define SEGV_MAPERR 1
#define SEGV_ACCERR 2



#define BUS_NOOP 0

#define BUS_ADRALN 1
#define BUS_ADRERR 2
#define BUS_OBJERR 3


#define TRAP_BRKPT 1
#define TRAP_TRACE 2



#define CLD_NOOP 0

#define CLD_EXITED 1
#define CLD_KILLED 2
#define CLD_DUMPED 3
#define CLD_TRAPPED 4
#define CLD_STOPPED 5
#define CLD_CONTINUED 6


#define POLL_IN 1
#define POLL_OUT 2
#define POLL_MSG 3
#define POLL_ERR 4
#define POLL_PRI 5
#define POLL_HUP 6


union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
     void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};




#define sa_handler __sigaction_u.__sa_handler
#define sa_sigaction __sigaction_u.__sa_sigaction

#define SA_ONSTACK 0x0001
#define SA_RESTART 0x0002
#define SA_RESETHAND 0x0004
#define SA_NOCLDSTOP 0x0008
#define SA_NODEFER 0x0010
#define SA_NOCLDWAIT 0x0020
#define SA_SIGINFO 0x0040

#define SA_USERTRAMP 0x0100

#define SA_64REGSET 0x0200





#define SA_USERSPACE_MASK (SA_ONSTACK | SA_RESTART | SA_RESETHAND | SA_NOCLDSTOP | SA_NODEFER | SA_NOCLDWAIT | SA_SIGINFO)




#define SIG_BLOCK 1
#define SIG_UNBLOCK 2
#define SIG_SETMASK 3


#define SI_USER 0x10001
#define SI_QUEUE 0x10002
#define SI_TIMER 0x10003
#define SI_ASYNCIO 0x10004
#define SI_MESGQ 0x10005


typedef void (*sig_t)(int);






#define SS_ONSTACK 0x0001
#define SS_DISABLE 0x0004
#define MINSIGSTKSZ 32768
#define SIGSTKSZ 131072






struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};

#define SV_ONSTACK SA_ONSTACK
#define SV_INTERRUPT SA_RESTART
#define SV_RESETHAND SA_RESETHAND
#define SV_NODEFER SA_NODEFER
#define SV_NOCLDSTOP SA_NOCLDSTOP
#define SV_SIGINFO SA_SIGINFO

#define sv_onstack sv_flags





struct sigstack {
 char *ss_sp;
 int ss_onstack;
};






#define sigmask(m) (1 << ((m)-1))


#define BADSIG SIG_ERR
# 389 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/signal.h" 3 4

    void(*signal(int, void (*)(int)))(int);

# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 2 3 4





#define PSWP 0
#define PVM 4
#define PINOD 8
#define PRIBIO 16
#define PVFS 20
#define PZERO 22
#define PSOCK 24
#define PWAIT 32
#define PLOCK 36
#define PPAUSE 40
#define PUSER 50
#define MAXPRI 127

#define PRIMASK 0x0ff
#define PCATCH 0x100
#define PTTYBLOCK 0x200
#define PDROP 0x400
#define PSPIN 0x800

#define NBPW sizeof(int)

#define CMASK 022
#define NODEV (dev_t)(-1)






#define CLBYTES (CLSIZE*NBPG)
#define CLOFSET (CLSIZE*NBPG-1)
#define claligned(x) ((((int)(x))&CLOFSET)==0)
#define CLOFF CLOFSET
#define CLSHIFT (PGSHIFT+CLSIZELOG2)


#define clbase(i) (i)
#define clrnd(i) (i)







#define CBLOCK 64
#define CBQSIZE (CBLOCK/NBBY)

#define CBSIZE (CBLOCK - sizeof(struct cblock *) - CBQSIZE)
#define CROUND (CBLOCK - 1)
# 181 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 3 4
#define MAXBSIZE (256 * 4096)
#define MAXPHYSIO MAXPHYS
#define MAXFRAG 8

#define MAXPHYSIO_WIRED (16 * 1024 * 1024)
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 3 4
#define MAXPATHLEN PATH_MAX
#define MAXSYMLINKS 32


#define setbit(a,i) (((unsigned char *)(a))[(i)/NBBY] |= 1u<<((i)%NBBY))
#define clrbit(a,i) (((unsigned char *)(a))[(i)/NBBY] &= ~(1u<<((i)%NBBY)))
#define isset(a,i) (((unsigned char *)(a))[(i)/NBBY] & (1u<<((i)%NBBY)))
#define isclr(a,i) ((((unsigned char *)(a))[(i)/NBBY] & (1u<<((i)%NBBY))) == 0)





#define roundup(x,y) ((((x) % (y)) == 0) ? (x) : ((x) + ((y) - ((x) % (y)))))

#define powerof2(x) ((((x)-1)&(x))==0)
# 232 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/param.h" 3 4
#define FSHIFT 11
#define FSCALE (1<<FSHIFT)
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ucred.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/bsm/audit.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/bsm/audit.h" 3 4
#define _BSM_AUDIT_H 




#define AUDIT_RECORD_MAGIC 0x828a0f1b
#define MAX_AUDIT_RECORDS 20
#define MAXAUDITDATA (0x8000 - 1)
#define MAX_AUDIT_RECORD_SIZE MAXAUDITDATA
#define MIN_AUDIT_FILE_SIZE (512 * 1024)







#define AUDIT_HARD_LIMIT_FREE_BLOCKS 4




#define AUDIT_TRIGGER_MIN 1
#define AUDIT_TRIGGER_LOW_SPACE 1
#define AUDIT_TRIGGER_ROTATE_KERNEL 2
#define AUDIT_TRIGGER_READ_FILE 3
#define AUDIT_TRIGGER_CLOSE_AND_DIE 4
#define AUDIT_TRIGGER_NO_SPACE 5
#define AUDIT_TRIGGER_ROTATE_USER 6
#define AUDIT_TRIGGER_INITIALIZE 7
#define AUDIT_TRIGGER_EXPIRE_TRAILS 8
#define AUDIT_TRIGGER_MAX 8




#define AUDITDEV_FILENAME "audit"
#define AUDIT_TRIGGER_FILE ("/dev/" AUDITDEV_FILENAME)




#define AU_DEFAUDITID (uid_t)(-1)
#define AU_DEFAUDITSID 0
#define AU_ASSIGN_ASID -1




#define AT_IPC_MSG ((unsigned char)1)
#define AT_IPC_SEM ((unsigned char)2)
#define AT_IPC_SHM ((unsigned char)3)




#define AUC_UNSET 0
#define AUC_AUDITING 1
#define AUC_NOAUDIT 2
#define AUC_DISABLED -1




#define A_OLDGETPOLICY 2
#define A_OLDSETPOLICY 3
#define A_GETKMASK 4
#define A_SETKMASK 5
#define A_OLDGETQCTRL 6
#define A_OLDSETQCTRL 7
#define A_GETCWD 8
#define A_GETCAR 9
#define A_GETSTAT 12
#define A_SETSTAT 13
#define A_SETUMASK 14
#define A_SETSMASK 15
#define A_OLDGETCOND 20
#define A_OLDSETCOND 21
#define A_GETCLASS 22
#define A_SETCLASS 23
#define A_GETPINFO 24
#define A_SETPMASK 25
#define A_SETFSIZE 26
#define A_GETFSIZE 27
#define A_GETPINFO_ADDR 28
#define A_GETKAUDIT 29
#define A_SETKAUDIT 30
#define A_SENDTRIGGER 31
#define A_GETSINFO_ADDR 32
#define A_GETPOLICY 33
#define A_SETPOLICY 34
#define A_GETQCTRL 35
#define A_SETQCTRL 36
#define A_GETCOND 37
#define A_SETCOND 38
#define A_GETSFLAGS 39
#define A_SETSFLAGS 40
#define A_GETCTLMODE 41
#define A_SETCTLMODE 42
#define A_GETEXPAFTER 43
#define A_SETEXPAFTER 44




#define AUDIT_CNT 0x0001
#define AUDIT_AHLT 0x0002
#define AUDIT_ARGV 0x0004
#define AUDIT_ARGE 0x0008
#define AUDIT_SEQ 0x0010
#define AUDIT_WINDATA 0x0020
#define AUDIT_USER 0x0040
#define AUDIT_GROUP 0x0080
#define AUDIT_TRAIL 0x0100
#define AUDIT_PATH 0x0200
#define AUDIT_SCNT 0x0400
#define AUDIT_PUBLIC 0x0800
#define AUDIT_ZONENAME 0x1000
#define AUDIT_PERZONE 0x2000




#define AQ_HIWATER 100
#define AQ_MAXHIGH 10000
#define AQ_LOWATER 10
#define AQ_BUFSZ MAXAUDITDATA
#define AQ_MAXBUFSZ 1048576




#define AU_FS_MINFREE 20





#define AU_IPv4 4
#define AU_IPv6 16





#define AU_CLASS_MASK_RESERVED 0x10000000




#define AUDIT_CTLMODE_NORMAL ((unsigned char)1)
#define AUDIT_CTLMODE_EXTERNAL ((unsigned char)2)




#define AUDIT_EXPIRE_OP_AND ((unsigned char)0)
#define AUDIT_EXPIRE_OP_OR ((unsigned char)1)



typedef uid_t au_id_t;
typedef pid_t au_asid_t;
typedef u_int16_t au_event_t;
typedef u_int16_t au_emod_t;
typedef u_int32_t au_class_t;
typedef u_int64_t au_asflgs_t __attribute__ ((aligned(8)));
typedef unsigned char au_ctlmode_t;

struct au_tid {
 dev_t port;
 u_int32_t machine;
};
typedef struct au_tid au_tid_t;

struct au_tid_addr {
 dev_t at_port;
 u_int32_t at_type;
 u_int32_t at_addr[4];
};
typedef struct au_tid_addr au_tid_addr_t;

struct au_mask {
 unsigned int am_success;
 unsigned int am_failure;
};
typedef struct au_mask au_mask_t;

struct auditinfo {
 au_id_t ai_auid;
 au_mask_t ai_mask;
 au_tid_t ai_termid;
 au_asid_t ai_asid;
};
typedef struct auditinfo auditinfo_t;

struct auditinfo_addr {
 au_id_t ai_auid;
 au_mask_t ai_mask;
 au_tid_addr_t ai_termid;
 au_asid_t ai_asid;
 au_asflgs_t ai_flags;
};
typedef struct auditinfo_addr auditinfo_addr_t;

struct auditpinfo {
 pid_t ap_pid;
 au_id_t ap_auid;
 au_mask_t ap_mask;
 au_tid_t ap_termid;
 au_asid_t ap_asid;
};
typedef struct auditpinfo auditpinfo_t;

struct auditpinfo_addr {
 pid_t ap_pid;
 au_id_t ap_auid;
 au_mask_t ap_mask;
 au_tid_addr_t ap_termid;
 au_asid_t ap_asid;
 au_asflgs_t ap_flags;
};
typedef struct auditpinfo_addr auditpinfo_addr_t;

struct au_session {
 auditinfo_addr_t *as_aia_p;
 au_mask_t as_mask;
};
typedef struct au_session au_session_t;

struct au_expire_after {
 time_t age;
 size_t size;
 unsigned char op_type;
};
typedef struct au_expire_after au_expire_after_t;




typedef struct au_token token_t;
# 283 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/bsm/audit.h" 3 4
struct au_qctrl {
 int aq_hiwater;


 int aq_lowater;


 int aq_bufsz;
 int aq_delay;
 int aq_minfree;
};
typedef struct au_qctrl au_qctrl_t;




struct audit_stat {
 unsigned int as_version;
 unsigned int as_numevent;
 int as_generated;
 int as_nonattrib;
 int as_kernel;
 int as_audit;
 int as_auditctl;
 int as_enqueue;
 int as_written;
 int as_wblocked;
 int as_rblocked;
 int as_dropped;
 int as_totalsize;
 unsigned int as_memused;
};
typedef struct audit_stat au_stat_t;




struct audit_fstat {
 u_int64_t af_filesz;
 u_int64_t af_currsz;
};
typedef struct audit_fstat au_fstat_t;




struct au_evclass_map {
 au_event_t ec_number;
 au_class_t ec_class;
};
typedef struct au_evclass_map au_evclass_map_t;




#define __AUDIT_API_DEPRECATED __API_DEPRECATED("audit is deprecated", macos(10.4, 11.0))
# 347 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/bsm/audit.h" 3 4
int audit(const void *, int)
;
int auditon(int, void *, int)
;
int auditctl(const char *)
;
int getauid(au_id_t *);
int setauid(const au_id_t *);
int getaudit_addr(struct auditinfo_addr *, int);
int setaudit_addr(const struct auditinfo_addr *, int);
# 366 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/bsm/audit.h" 3 4
int getaudit(struct auditinfo *)

                               ;
int setaudit(const struct auditinfo *)

                               ;
# 381 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/bsm/audit.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 1 3 4
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 3 4
#define _MACH_PORT_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/boolean.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/boolean.h" 3 4
#define _MACH_BOOLEAN_H_ 






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/boolean.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/boolean.h" 3 4
#define _MACH_MACHINE_BOOLEAN_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/boolean.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/boolean.h" 3 4
#define _MACH_ARM_BOOLEAN_H_ 



typedef int boolean_t;
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/boolean.h" 2 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/boolean.h" 2 3 4







#define TRUE 1



#define FALSE 0
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/vm_types.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/vm_types.h" 3 4
#define _MACH_MACHINE_VM_TYPES_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_types.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_types.h" 3 4
#define _MACH_ARM_VM_TYPES_H_ 
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_types.h" 3 4
typedef __darwin_natural_t natural_t;
typedef int integer_t;






typedef uintptr_t vm_offset_t ;
typedef uintptr_t vm_size_t;

typedef uint64_t mach_vm_address_t ;
typedef uint64_t mach_vm_offset_t ;
typedef uint64_t mach_vm_size_t;

typedef uint64_t vm_map_offset_t ;
typedef uint64_t vm_map_address_t ;
typedef uint64_t vm_map_size_t;
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_types.h" 3 4
typedef uint32_t vm32_offset_t;
typedef uint32_t vm32_address_t;
typedef uint32_t vm32_size_t;

typedef vm_offset_t mach_port_context_t;







#define MACH_MSG_TYPE_INTEGER_T MACH_MSG_TYPE_INTEGER_32
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/vm_types.h" 2 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 2 3 4
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_name_t;
typedef mach_port_name_t *mach_port_name_array_t;
# 127 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_mach_port_t.h" 3 4
#define _MACH_PORT_T 

typedef __darwin_mach_port_t mach_port_t;
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 2 3 4


typedef mach_port_t *mach_port_array_t;
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 3 4
#define MACH_PORT_NULL 0
#define MACH_PORT_DEAD ((mach_port_name_t) ~0)
#define MACH_PORT_VALID(name) (((name) != MACH_PORT_NULL) && ((name) != MACH_PORT_DEAD))
# 164 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 3 4
#define MACH_PORT_INDEX(name) ((name) >> 8)
#define MACH_PORT_GEN(name) (((name) & 0xff) << 24)
#define MACH_PORT_MAKE(index,gen) (((index) << 8) | (gen) >> 24)
# 188 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 3 4
typedef natural_t mach_port_right_t;

#define MACH_PORT_RIGHT_SEND ((mach_port_right_t) 0)
#define MACH_PORT_RIGHT_RECEIVE ((mach_port_right_t) 1)
#define MACH_PORT_RIGHT_SEND_ONCE ((mach_port_right_t) 2)
#define MACH_PORT_RIGHT_PORT_SET ((mach_port_right_t) 3)
#define MACH_PORT_RIGHT_DEAD_NAME ((mach_port_right_t) 4)
#define MACH_PORT_RIGHT_LABELH ((mach_port_right_t) 5)
#define MACH_PORT_RIGHT_NUMBER ((mach_port_right_t) 6)


typedef natural_t mach_port_type_t;
typedef mach_port_type_t *mach_port_type_array_t;

#define MACH_PORT_TYPE(right) ((mach_port_type_t)(((mach_port_type_t) 1) << ((right) + ((mach_port_right_t) 16))))


#define MACH_PORT_TYPE_NONE ((mach_port_type_t) 0L)
#define MACH_PORT_TYPE_SEND MACH_PORT_TYPE(MACH_PORT_RIGHT_SEND)
#define MACH_PORT_TYPE_RECEIVE MACH_PORT_TYPE(MACH_PORT_RIGHT_RECEIVE)
#define MACH_PORT_TYPE_SEND_ONCE MACH_PORT_TYPE(MACH_PORT_RIGHT_SEND_ONCE)
#define MACH_PORT_TYPE_PORT_SET MACH_PORT_TYPE(MACH_PORT_RIGHT_PORT_SET)
#define MACH_PORT_TYPE_DEAD_NAME MACH_PORT_TYPE(MACH_PORT_RIGHT_DEAD_NAME)
#define MACH_PORT_TYPE_LABELH MACH_PORT_TYPE(MACH_PORT_RIGHT_LABELH)




#define MACH_PORT_TYPE_SEND_RECEIVE (MACH_PORT_TYPE_SEND|MACH_PORT_TYPE_RECEIVE)

#define MACH_PORT_TYPE_SEND_RIGHTS (MACH_PORT_TYPE_SEND|MACH_PORT_TYPE_SEND_ONCE)

#define MACH_PORT_TYPE_PORT_RIGHTS (MACH_PORT_TYPE_SEND_RIGHTS|MACH_PORT_TYPE_RECEIVE)

#define MACH_PORT_TYPE_PORT_OR_DEAD (MACH_PORT_TYPE_PORT_RIGHTS|MACH_PORT_TYPE_DEAD_NAME)

#define MACH_PORT_TYPE_ALL_RIGHTS (MACH_PORT_TYPE_PORT_OR_DEAD|MACH_PORT_TYPE_PORT_SET)




#define MACH_PORT_TYPE_DNREQUEST 0x80000000
#define MACH_PORT_TYPE_SPREQUEST 0x40000000
#define MACH_PORT_TYPE_SPREQUEST_DELAYED 0x20000000



typedef natural_t mach_port_urefs_t;
typedef integer_t mach_port_delta_t;



typedef natural_t mach_port_seqno_t;
typedef natural_t mach_port_mscount_t;
typedef natural_t mach_port_msgcount_t;
typedef natural_t mach_port_rights_t;




#define MACH_PORT_SRIGHTS_NONE 0
#define MACH_PORT_SRIGHTS_PRESENT 1
typedef unsigned int mach_port_srights_t;

typedef struct mach_port_status {
 mach_port_rights_t mps_pset;
 mach_port_seqno_t mps_seqno;
 mach_port_mscount_t mps_mscount;
 mach_port_msgcount_t mps_qlimit;
 mach_port_msgcount_t mps_msgcount;
 mach_port_rights_t mps_sorights;
 boolean_t mps_srights;
 boolean_t mps_pdrequest;
 boolean_t mps_nsrequest;
 natural_t mps_flags;
} mach_port_status_t;


#define MACH_PORT_QLIMIT_ZERO (0)
#define MACH_PORT_QLIMIT_BASIC (5)
#define MACH_PORT_QLIMIT_SMALL (16)
#define MACH_PORT_QLIMIT_LARGE (1024)
#define MACH_PORT_QLIMIT_KERNEL (65534)
#define MACH_PORT_QLIMIT_MIN MACH_PORT_QLIMIT_ZERO
#define MACH_PORT_QLIMIT_DEFAULT MACH_PORT_QLIMIT_BASIC
#define MACH_PORT_QLIMIT_MAX MACH_PORT_QLIMIT_LARGE

typedef struct mach_port_limits {
 mach_port_msgcount_t mpl_qlimit;
} mach_port_limits_t;


#define MACH_PORT_STATUS_FLAG_TEMPOWNER 0x01
#define MACH_PORT_STATUS_FLAG_GUARDED 0x02
#define MACH_PORT_STATUS_FLAG_STRICT_GUARD 0x04
#define MACH_PORT_STATUS_FLAG_IMP_DONATION 0x08
#define MACH_PORT_STATUS_FLAG_REVIVE 0x10
#define MACH_PORT_STATUS_FLAG_TASKPTR 0x20
#define MACH_PORT_STATUS_FLAG_GUARD_IMMOVABLE_RECEIVE 0x40
#define MACH_PORT_STATUS_FLAG_NO_GRANT 0x80

typedef struct mach_port_info_ext {
 mach_port_status_t mpie_status;
 mach_port_msgcount_t mpie_boost_cnt;
 uint32_t reserved[6];
} mach_port_info_ext_t;

typedef struct mach_port_guard_info {
 uint64_t mpgi_guard;
} mach_port_guard_info_t;

typedef integer_t *mach_port_info_t;


typedef int mach_port_flavor_t;
#define MACH_PORT_LIMITS_INFO 1
#define MACH_PORT_RECEIVE_STATUS 2
#define MACH_PORT_DNREQUESTS_SIZE 3
#define MACH_PORT_TEMPOWNER 4
#define MACH_PORT_IMPORTANCE_RECEIVER 5
#define MACH_PORT_DENAP_RECEIVER 6
#define MACH_PORT_INFO_EXT 7
#define MACH_PORT_GUARD_INFO 8

#define MACH_PORT_LIMITS_INFO_COUNT ((natural_t) (sizeof(mach_port_limits_t)/sizeof(natural_t)))

#define MACH_PORT_RECEIVE_STATUS_COUNT ((natural_t) (sizeof(mach_port_status_t)/sizeof(natural_t)))

#define MACH_PORT_DNREQUESTS_SIZE_COUNT 1
#define MACH_PORT_INFO_EXT_COUNT ((natural_t) (sizeof(mach_port_info_ext_t)/sizeof(natural_t)))

#define MACH_PORT_GUARD_INFO_COUNT ((natural_t) (sizeof(mach_port_guard_info_t)/sizeof(natural_t)))






typedef struct mach_port_qos {
 unsigned int name:1;
 unsigned int prealloc:1;
 boolean_t pad1:30;
 natural_t len;
} mach_port_qos_t;




#define MACH_SERVICE_PORT_INFO_STRING_NAME_MAX_BUF_LEN 255

typedef struct mach_service_port_info {
 char mspi_string_name[255];
 uint8_t mspi_domain_type;
} mach_service_port_info_data_t;

#define MACH_SERVICE_PORT_INFO_COUNT ((char) (sizeof(mach_service_port_info_data_t)/sizeof(char)))


typedef struct mach_service_port_info * mach_service_port_info_t;







#define MPO_CONTEXT_AS_GUARD 0x01
#define MPO_QLIMIT 0x02
#define MPO_TEMPOWNER 0x04
#define MPO_IMPORTANCE_RECEIVER 0x08
#define MPO_INSERT_SEND_RIGHT 0x10
#define MPO_STRICT 0x20
#define MPO_DENAP_RECEIVER 0x40
#define MPO_IMMOVABLE_RECEIVE 0x80
#define MPO_FILTER_MSG 0x100
#define MPO_TG_BLOCK_TRACKING 0x200
#define MPO_SERVICE_PORT 0x400
#define MPO_CONNECTION_PORT 0x800





typedef struct mach_port_options {
 uint32_t flags;
 mach_port_limits_t mpl;
 union {
  uint64_t reserved[2];
  mach_port_name_t work_interval_port;
  mach_service_port_info_t service_port_info;
  mach_port_name_t service_port_name;
 };
}mach_port_options_t;

typedef mach_port_options_t *mach_port_options_ptr_t;
# 391 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/port.h" 3 4
#define GUARD_TYPE_MACH_PORT 0x1


enum mach_port_guard_exception_codes {
 kGUARD_EXC_DESTROY = 1u << 0,
 kGUARD_EXC_MOD_REFS = 1u << 1,
 kGUARD_EXC_SET_CONTEXT = 1u << 2,
 kGUARD_EXC_UNGUARDED = 1u << 3,
 kGUARD_EXC_INCORRECT_GUARD = 1u << 4,
 kGUARD_EXC_IMMOVABLE = 1u << 5,
 kGUARD_EXC_STRICT_REPLY = 1u << 6,
 kGUARD_EXC_MSG_FILTERED = 1u << 7,

 kGUARD_EXC_INVALID_RIGHT = 1u << 8,
 kGUARD_EXC_INVALID_NAME = 1u << 9,
 kGUARD_EXC_INVALID_VALUE = 1u << 10,
 kGUARD_EXC_INVALID_ARGUMENT = 1u << 11,
 kGUARD_EXC_RIGHT_EXISTS = 1u << 12,
 kGUARD_EXC_KERN_NO_SPACE = 1u << 13,
 kGUARD_EXC_KERN_FAILURE = 1u << 14,
 kGUARD_EXC_KERN_RESOURCE = 1u << 15,
 kGUARD_EXC_SEND_INVALID_REPLY = 1u << 16,
 kGUARD_EXC_SEND_INVALID_VOUCHER = 1u << 17,
 kGUARD_EXC_SEND_INVALID_RIGHT = 1u << 18,
 kGUARD_EXC_RCV_INVALID_NAME = 1u << 19,

 kGUARD_EXC_RCV_GUARDED_DESC = 1u << 20,
 kGUARD_EXC_MOD_REFS_NON_FATAL = 1u << 21,
 kGUARD_EXC_IMMOVABLE_NON_FATAL = 1u << 22,
};

#define MAX_FATAL_kGUARD_EXC_CODE (1u << 7)




#define MPG_FLAGS_NONE (0x00ull)

#define MAX_OPTIONAL_kGUARD_EXC_CODE (1u << 19)




#define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_DISP (0x01ull << 56)
#define MPG_FLAGS_STRICT_REPLY_INVALID_REPLY_PORT (0x02ull << 56)
#define MPG_FLAGS_STRICT_REPLY_INVALID_VOUCHER (0x04ull << 56)
#define MPG_FLAGS_STRICT_REPLY_NO_BANK_ATTR (0x08ull << 56)
#define MPG_FLAGS_STRICT_REPLY_MISMATCHED_PERSONA (0x10ull << 56)
#define MPG_FLAGS_STRICT_REPLY_MASK (0xffull << 56)




#define MPG_FLAGS_MOD_REFS_PINNED_DEALLOC (0x01ull << 56)
#define MPG_FLAGS_MOD_REFS_PINNED_DESTROY (0x02ull << 56)
#define MPG_FLAGS_MOD_REFS_PINNED_COPYIN (0x04ull << 56)




#define MPG_FLAGS_IMMOVABLE_PINNED (0x01ull << 56)





#define MPG_STRICT 0x01
#define MPG_IMMOVABLE_RECEIVE 0x02
# 382 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/bsm/audit.h" 2 3 4
mach_port_name_t audit_session_self(void);
au_asid_t audit_session_join(mach_port_name_t port);
int audit_session_port(au_asid_t asid, mach_port_name_t *portname);





# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ucred.h" 2 3 4

struct label;


struct ucred;
struct posix_cred;


#define _KAUTH_CRED_T 
typedef struct ucred *kauth_cred_t;
typedef struct posix_cred *posix_cred_t;





#define CRF_NOMEMBERD 0x00000001
#define CRF_MAC_ENFORCE 0x00000002





struct xucred {
 u_int cr_version;
 uid_t cr_uid;
 short cr_ngroups;
 gid_t cr_groups[16];
};
#define XUCRED_VERSION 0

#define cr_gid cr_groups[0]
#define NOCRED ((kauth_cred_t )0)
#define FSCRED ((kauth_cred_t )-1)

#define IS_VALID_CRED(_cr) ((_cr) != NOCRED && (_cr) != FSCRED)
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/proc.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/proc.h" 3 4
#define _SYS_PROC_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/select.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/select.h" 3 4
#define _SYS_SELECT_H_ 
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/select.h" 3 4



int pselect(int, fd_set * restrict, fd_set * restrict,
    fd_set * restrict, const struct timespec * restrict,
    const sigset_t * restrict)




__asm("_" "pselect" )




;





# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/proc.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 1 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define _SYS_QUEUE_H_ 


#define __improbable(x) (x)
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define QMD_TRACE_ELEM(elem) 
#define QMD_TRACE_HEAD(head) 
#define TRACEBUF 
#define TRASHIT(x) 
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define __MISMATCH_TAGS_PUSH 
#define __MISMATCH_TAGS_POP 
# 229 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define __NULLABILITY_COMPLETENESS_PUSH 
#define __NULLABILITY_COMPLETENESS_POP 





#define SLIST_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *slh_first; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define SLIST_HEAD_INITIALIZER(head) { NULL }


#define SLIST_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *sle_next; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 260 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define SLIST_EMPTY(head) ((head)->slh_first == NULL)

#define SLIST_FIRST(head) ((head)->slh_first)

#define SLIST_FOREACH(var,head,field) for ((var) = SLIST_FIRST((head)); (var); (var) = SLIST_NEXT((var), field))




#define SLIST_FOREACH_SAFE(var,head,field,tvar) for ((var) = SLIST_FIRST((head)); (var) && ((tvar) = SLIST_NEXT((var), field), 1); (var) = (tvar))




#define SLIST_FOREACH_PREVPTR(var,varp,head,field) for ((varp) = &SLIST_FIRST((head)); ((var) = *(varp)) != NULL; (varp) = &SLIST_NEXT((var), field))




#define SLIST_INIT(head) do { SLIST_FIRST((head)) = NULL; } while (0)



#define SLIST_INSERT_AFTER(slistelm,elm,field) do { SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field); SLIST_NEXT((slistelm), field) = (elm); } while (0)




#define SLIST_INSERT_HEAD(head,elm,field) do { SLIST_NEXT((elm), field) = SLIST_FIRST((head)); SLIST_FIRST((head)) = (elm); } while (0)




#define SLIST_NEXT(elm,field) ((elm)->field.sle_next)

#define SLIST_REMOVE(head,elm,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { if (SLIST_FIRST((head)) == (elm)) { SLIST_REMOVE_HEAD((head), field); } else { struct type *curelm = SLIST_FIRST((head)); while (SLIST_NEXT(curelm, field) != (elm)) curelm = SLIST_NEXT(curelm, field); SLIST_REMOVE_AFTER(curelm, field); } TRASHIT((elm)->field.sle_next); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 313 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define SLIST_REMOVE_AFTER(elm,field) do { SLIST_NEXT(elm, field) = SLIST_NEXT(SLIST_NEXT(elm, field), field); } while (0)




#define SLIST_REMOVE_HEAD(head,field) do { SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field); } while (0)






#define STAILQ_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *stqh_first; struct type **stqh_last; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 335 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_HEAD_INITIALIZER(head) { NULL, &(head).stqh_first }


#define STAILQ_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *stqe_next; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 350 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_CONCAT(head1,head2) do { if (!STAILQ_EMPTY((head2))) { *(head1)->stqh_last = (head2)->stqh_first; (head1)->stqh_last = (head2)->stqh_last; STAILQ_INIT((head2)); } } while (0)







#define STAILQ_EMPTY(head) ((head)->stqh_first == NULL)

#define STAILQ_FIRST(head) ((head)->stqh_first)

#define STAILQ_FOREACH(var,head,field) for((var) = STAILQ_FIRST((head)); (var); (var) = STAILQ_NEXT((var), field))





#define STAILQ_FOREACH_SAFE(var,head,field,tvar) for ((var) = STAILQ_FIRST((head)); (var) && ((tvar) = STAILQ_NEXT((var), field), 1); (var) = (tvar))




#define STAILQ_INIT(head) do { STAILQ_FIRST((head)) = NULL; (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)




#define STAILQ_INSERT_AFTER(head,tqelm,elm,field) do { if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_NEXT((tqelm), field) = (elm); } while (0)





#define STAILQ_INSERT_HEAD(head,elm,field) do { if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_FIRST((head)) = (elm); } while (0)





#define STAILQ_INSERT_TAIL(head,elm,field) do { STAILQ_NEXT((elm), field) = NULL; *(head)->stqh_last = (elm); (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)





#define STAILQ_LAST(head,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (STAILQ_EMPTY((head)) ? NULL : ((struct type *)(void *) ((char *)((head)->stqh_last) - __offsetof(struct type, field))))__NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 406 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_NEXT(elm,field) ((elm)->field.stqe_next)

#define STAILQ_REMOVE(head,elm,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { if (STAILQ_FIRST((head)) == (elm)) { STAILQ_REMOVE_HEAD((head), field); } else { struct type *curelm = STAILQ_FIRST((head)); while (STAILQ_NEXT(curelm, field) != (elm)) curelm = STAILQ_NEXT(curelm, field); STAILQ_REMOVE_AFTER(head, curelm, field); } TRASHIT((elm)->field.stqe_next); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 426 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_REMOVE_HEAD(head,field) do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)





#define STAILQ_REMOVE_HEAD_UNTIL(head,elm,field) do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)




#define STAILQ_REMOVE_AFTER(head,elm,field) do { if ((STAILQ_NEXT(elm, field) = STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)





#define STAILQ_SWAP(head1,head2,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_first = STAILQ_FIRST(head1); struct type **swap_last = (head1)->stqh_last; STAILQ_FIRST(head1) = STAILQ_FIRST(head2); (head1)->stqh_last = (head2)->stqh_last; STAILQ_FIRST(head2) = swap_first; (head2)->stqh_last = swap_last; if (STAILQ_EMPTY(head1)) (head1)->stqh_last = &STAILQ_FIRST(head1); if (STAILQ_EMPTY(head2)) (head2)->stqh_last = &STAILQ_FIRST(head2); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 465 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define LIST_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *lh_first; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 474 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define LIST_HEAD_INITIALIZER(head) { NULL }


#define LIST_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *le_next; struct type **le_prev; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 491 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define LIST_CHECK_HEAD(head,field) 
#define LIST_CHECK_NEXT(elm,field) 
#define LIST_CHECK_PREV(elm,field) 

#define LIST_EMPTY(head) ((head)->lh_first == NULL)

#define LIST_FIRST(head) ((head)->lh_first)

#define LIST_FOREACH(var,head,field) for ((var) = LIST_FIRST((head)); (var); (var) = LIST_NEXT((var), field))




#define LIST_FOREACH_SAFE(var,head,field,tvar) for ((var) = LIST_FIRST((head)); (var) && ((tvar) = LIST_NEXT((var), field), 1); (var) = (tvar))




#define LIST_INIT(head) do { LIST_FIRST((head)) = NULL; } while (0)



#define LIST_INSERT_AFTER(listelm,elm,field) do { LIST_CHECK_NEXT(listelm, field); if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL) LIST_NEXT((listelm), field)->field.le_prev = &LIST_NEXT((elm), field); LIST_NEXT((listelm), field) = (elm); (elm)->field.le_prev = &LIST_NEXT((listelm), field); } while (0)
# 522 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define LIST_INSERT_BEFORE(listelm,elm,field) do { LIST_CHECK_PREV(listelm, field); (elm)->field.le_prev = (listelm)->field.le_prev; LIST_NEXT((elm), field) = (listelm); *(listelm)->field.le_prev = (elm); (listelm)->field.le_prev = &LIST_NEXT((elm), field); } while (0)







#define LIST_INSERT_HEAD(head,elm,field) do { LIST_CHECK_HEAD((head), field); if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL) LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field); LIST_FIRST((head)) = (elm); (elm)->field.le_prev = &LIST_FIRST((head)); } while (0)







#define LIST_NEXT(elm,field) ((elm)->field.le_next)

#define LIST_REMOVE(elm,field) do { LIST_CHECK_NEXT(elm, field); LIST_CHECK_PREV(elm, field); if (LIST_NEXT((elm), field) != NULL) LIST_NEXT((elm), field)->field.le_prev = (elm)->field.le_prev; *(elm)->field.le_prev = LIST_NEXT((elm), field); TRASHIT((elm)->field.le_next); TRASHIT((elm)->field.le_prev); } while (0)
# 551 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define LIST_SWAP(head1,head2,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_tmp = LIST_FIRST((head1)); LIST_FIRST((head1)) = LIST_FIRST((head2)); LIST_FIRST((head2)) = swap_tmp; if ((swap_tmp = LIST_FIRST((head1))) != NULL) swap_tmp->field.le_prev = &LIST_FIRST((head1)); if ((swap_tmp = LIST_FIRST((head2))) != NULL) swap_tmp->field.le_prev = &LIST_FIRST((head2)); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 569 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *tqh_first; struct type **tqh_last; TRACEBUF } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 580 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_HEAD_INITIALIZER(head) { NULL, &(head).tqh_first }


#define TAILQ_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *tqe_next; struct type **tqe_prev; TRACEBUF } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 597 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_CHECK_HEAD(head,field) 
#define TAILQ_CHECK_NEXT(elm,field) 
#define TAILQ_CHECK_PREV(elm,field) 

#define TAILQ_CONCAT(head1,head2,field) do { if (!TAILQ_EMPTY(head2)) { *(head1)->tqh_last = (head2)->tqh_first; (head2)->tqh_first->field.tqe_prev = (head1)->tqh_last; (head1)->tqh_last = (head2)->tqh_last; TAILQ_INIT((head2)); QMD_TRACE_HEAD(head1); QMD_TRACE_HEAD(head2); } } while (0)
# 612 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_EMPTY(head) ((head)->tqh_first == NULL)

#define TAILQ_FIRST(head) ((head)->tqh_first)

#define TAILQ_FOREACH(var,head,field) for ((var) = TAILQ_FIRST((head)); (var); (var) = TAILQ_NEXT((var), field))




#define TAILQ_FOREACH_SAFE(var,head,field,tvar) for ((var) = TAILQ_FIRST((head)); (var) && ((tvar) = TAILQ_NEXT((var), field), 1); (var) = (tvar))




#define TAILQ_FOREACH_REVERSE(var,head,headname,field) for ((var) = TAILQ_LAST((head), headname); (var); (var) = TAILQ_PREV((var), headname, field))




#define TAILQ_FOREACH_REVERSE_SAFE(var,head,headname,field,tvar) for ((var) = TAILQ_LAST((head), headname); (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1); (var) = (tvar))





#define TAILQ_INIT(head) do { TAILQ_FIRST((head)) = NULL; (head)->tqh_last = &TAILQ_FIRST((head)); QMD_TRACE_HEAD(head); } while (0)






#define TAILQ_INSERT_AFTER(head,listelm,elm,field) do { TAILQ_CHECK_NEXT(listelm, field); if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = &TAILQ_NEXT((elm), field); else { (head)->tqh_last = &TAILQ_NEXT((elm), field); QMD_TRACE_HEAD(head); } TAILQ_NEXT((listelm), field) = (elm); (elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field); QMD_TRACE_ELEM(&(elm)->field); QMD_TRACE_ELEM(&listelm->field); } while (0)
# 659 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_INSERT_BEFORE(listelm,elm,field) do { TAILQ_CHECK_PREV(listelm, field); (elm)->field.tqe_prev = (listelm)->field.tqe_prev; TAILQ_NEXT((elm), field) = (listelm); *(listelm)->field.tqe_prev = (elm); (listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field); QMD_TRACE_ELEM(&(elm)->field); QMD_TRACE_ELEM(&listelm->field); } while (0)
# 669 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_INSERT_HEAD(head,elm,field) do { TAILQ_CHECK_HEAD(head, field); if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL) TAILQ_FIRST((head))->field.tqe_prev = &TAILQ_NEXT((elm), field); else (head)->tqh_last = &TAILQ_NEXT((elm), field); TAILQ_FIRST((head)) = (elm); (elm)->field.tqe_prev = &TAILQ_FIRST((head)); QMD_TRACE_HEAD(head); QMD_TRACE_ELEM(&(elm)->field); } while (0)
# 682 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_INSERT_TAIL(head,elm,field) do { TAILQ_NEXT((elm), field) = NULL; (elm)->field.tqe_prev = (head)->tqh_last; *(head)->tqh_last = (elm); (head)->tqh_last = &TAILQ_NEXT((elm), field); QMD_TRACE_HEAD(head); QMD_TRACE_ELEM(&(elm)->field); } while (0)
# 691 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_LAST(head,headname) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (*(((struct headname *)((head)->tqh_last))->tqh_last)) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP






#define TAILQ_NEXT(elm,field) ((elm)->field.tqe_next)

#define TAILQ_PREV(elm,headname,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (*(((struct headname *)((elm)->field.tqe_prev))->tqh_last)) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP






#define TAILQ_REMOVE(head,elm,field) do { TAILQ_CHECK_NEXT(elm, field); TAILQ_CHECK_PREV(elm, field); if ((TAILQ_NEXT((elm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = (elm)->field.tqe_prev; else { (head)->tqh_last = (elm)->field.tqe_prev; QMD_TRACE_HEAD(head); } *(elm)->field.tqe_prev = TAILQ_NEXT((elm), field); TRASHIT((elm)->field.tqe_next); TRASHIT((elm)->field.tqe_prev); QMD_TRACE_ELEM(&(elm)->field); } while (0)
# 726 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_SWAP(head1,head2,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_first = (head1)->tqh_first; struct type **swap_last = (head1)->tqh_last; (head1)->tqh_first = (head2)->tqh_first; (head1)->tqh_last = (head2)->tqh_last; (head2)->tqh_first = swap_first; (head2)->tqh_last = swap_last; if ((swap_first = (head1)->tqh_first) != NULL) swap_first->field.tqe_prev = &(head1)->tqh_first; else (head1)->tqh_last = &(head1)->tqh_first; if ((swap_first = (head2)->tqh_first) != NULL) swap_first->field.tqe_prev = &(head2)->tqh_first; else (head2)->tqh_last = &(head2)->tqh_first; } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 751 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *cqh_first; struct type *cqh_last; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 761 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *cqe_next; struct type *cqe_prev; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 774 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_CHECK_HEAD(head,field) 
#define CIRCLEQ_CHECK_NEXT(head,elm,field) 
#define CIRCLEQ_CHECK_PREV(head,elm,field) 

#define CIRCLEQ_EMPTY(head) ((head)->cqh_first == (void *)(head))

#define CIRCLEQ_FIRST(head) ((head)->cqh_first)

#define CIRCLEQ_FOREACH(var,head,field) for((var) = (head)->cqh_first; (var) != (void *)(head); (var) = (var)->field.cqe_next)




#define CIRCLEQ_INIT(head) do { (head)->cqh_first = (void *)(head); (head)->cqh_last = (void *)(head); } while (0)




#define CIRCLEQ_INSERT_AFTER(head,listelm,elm,field) do { CIRCLEQ_CHECK_NEXT(head, listelm, field); (elm)->field.cqe_next = (listelm)->field.cqe_next; (elm)->field.cqe_prev = (listelm); if ((listelm)->field.cqe_next == (void *)(head)) (head)->cqh_last = (elm); else (listelm)->field.cqe_next->field.cqe_prev = (elm); (listelm)->field.cqe_next = (elm); } while (0)
# 803 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_INSERT_BEFORE(head,listelm,elm,field) do { CIRCLEQ_CHECK_PREV(head, listelm, field); (elm)->field.cqe_next = (listelm); (elm)->field.cqe_prev = (listelm)->field.cqe_prev; if ((listelm)->field.cqe_prev == (void *)(head)) (head)->cqh_first = (elm); else (listelm)->field.cqe_prev->field.cqe_next = (elm); (listelm)->field.cqe_prev = (elm); } while (0)
# 814 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_INSERT_HEAD(head,elm,field) do { CIRCLEQ_CHECK_HEAD(head, field); (elm)->field.cqe_next = (head)->cqh_first; (elm)->field.cqe_prev = (void *)(head); if ((head)->cqh_last == (void *)(head)) (head)->cqh_last = (elm); else (head)->cqh_first->field.cqe_prev = (elm); (head)->cqh_first = (elm); } while (0)
# 825 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_INSERT_TAIL(head,elm,field) do { (elm)->field.cqe_next = (void *)(head); (elm)->field.cqe_prev = (head)->cqh_last; if ((head)->cqh_first == (void *)(head)) (head)->cqh_first = (elm); else (head)->cqh_last->field.cqe_next = (elm); (head)->cqh_last = (elm); } while (0)
# 835 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_LAST(head) ((head)->cqh_last)

#define CIRCLEQ_NEXT(elm,field) ((elm)->field.cqe_next)

#define CIRCLEQ_PREV(elm,field) ((elm)->field.cqe_prev)

#define CIRCLEQ_REMOVE(head,elm,field) do { CIRCLEQ_CHECK_NEXT(head, elm, field); CIRCLEQ_CHECK_PREV(head, elm, field); if ((elm)->field.cqe_next == (void *)(head)) (head)->cqh_last = (elm)->field.cqe_prev; else (elm)->field.cqe_next->field.cqe_prev = (elm)->field.cqe_prev; if ((elm)->field.cqe_prev == (void *)(head)) (head)->cqh_first = (elm)->field.cqe_next; else (elm)->field.cqe_prev->field.cqe_next = (elm)->field.cqe_next; } while (0)
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/proc.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/lock.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/lock.h" 3 4
#define _SYS_LOCK_H_ 
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/proc.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define _SYS_EVENT_H_ 
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define EVFILT_READ (-1)
#define EVFILT_WRITE (-2)
#define EVFILT_AIO (-3)
#define EVFILT_VNODE (-4)
#define EVFILT_PROC (-5)
#define EVFILT_SIGNAL (-6)
#define EVFILT_TIMER (-7)
#define EVFILT_MACHPORT (-8)
#define EVFILT_FS (-9)
#define EVFILT_USER (-10)
#define EVFILT_VM (-12)
#define EVFILT_EXCEPT (-15)

#define EVFILT_SYSCOUNT 17
#define EVFILT_THREADMARKER EVFILT_SYSCOUNT

#pragma pack(4)

struct kevent {
 uintptr_t ident;
 int16_t filter;
 uint16_t flags;
 uint32_t fflags;
 intptr_t data;
 void *udata;
};


#pragma pack()

struct kevent64_s {
 uint64_t ident;
 int16_t filter;
 uint16_t flags;
 uint32_t fflags;
 int64_t data;
 uint64_t udata;
 uint64_t ext[2];
};


#define EV_SET(kevp,a,b,c,d,e,f) do { struct kevent *__kevp__ = (kevp); __kevp__->ident = (a); __kevp__->filter = (b); __kevp__->flags = (c); __kevp__->fflags = (d); __kevp__->data = (e); __kevp__->udata = (f); } while(0)
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define EV_SET64(kevp,a,b,c,d,e,f,g,h) do { struct kevent64_s *__kevp__ = (kevp); __kevp__->ident = (a); __kevp__->filter = (b); __kevp__->flags = (c); __kevp__->fflags = (d); __kevp__->data = (e); __kevp__->udata = (f); __kevp__->ext[0] = (g); __kevp__->ext[1] = (h); } while(0)
# 133 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define KEVENT_FLAG_NONE 0x000000
#define KEVENT_FLAG_IMMEDIATE 0x000001
#define KEVENT_FLAG_ERROR_EVENTS 0x000002



#define EV_ADD 0x0001
#define EV_DELETE 0x0002
#define EV_ENABLE 0x0004
#define EV_DISABLE 0x0008


#define EV_ONESHOT 0x0010
#define EV_CLEAR 0x0020
#define EV_RECEIPT 0x0040




#define EV_DISPATCH 0x0080
#define EV_UDATA_SPECIFIC 0x0100

#define EV_DISPATCH2 (EV_DISPATCH | EV_UDATA_SPECIFIC)





#define EV_VANISHED 0x0200


#define EV_SYSFLAGS 0xF000
#define EV_FLAG0 0x1000
#define EV_FLAG1 0x2000


#define EV_EOF 0x8000
#define EV_ERROR 0x4000
# 197 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define EV_POLL EV_FLAG0
#define EV_OOBAND EV_FLAG1
# 207 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define NOTE_TRIGGER 0x01000000
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define NOTE_FFNOP 0x00000000
#define NOTE_FFAND 0x40000000
#define NOTE_FFOR 0x80000000
#define NOTE_FFCOPY 0xc0000000
#define NOTE_FFCTRLMASK 0xc0000000
#define NOTE_FFLAGSMASK 0x00ffffff
# 230 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define NOTE_LOWAT 0x00000001


#define NOTE_OOB 0x00000002




#define NOTE_DELETE 0x00000001
#define NOTE_WRITE 0x00000002
#define NOTE_EXTEND 0x00000004
#define NOTE_ATTRIB 0x00000008
#define NOTE_LINK 0x00000010
#define NOTE_RENAME 0x00000020
#define NOTE_REVOKE 0x00000040
#define NOTE_NONE 0x00000080
#define NOTE_FUNLOCK 0x00000100
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
enum {
 eNoteReapDeprecated = 0x10000000
};

#define NOTE_EXIT 0x80000000
#define NOTE_FORK 0x40000000
#define NOTE_EXEC 0x20000000
#define NOTE_REAP ((unsigned int)eNoteReapDeprecated )
#define NOTE_SIGNAL 0x08000000
#define NOTE_EXITSTATUS 0x04000000
#define NOTE_EXIT_DETAIL 0x02000000

#define NOTE_PDATAMASK 0x000fffff
#define NOTE_PCTRLMASK (~NOTE_PDATAMASK)




enum {
 eNoteExitReparentedDeprecated = 0x00080000
};
#define NOTE_EXIT_REPARENTED ((unsigned int)eNoteExitReparentedDeprecated)




#define NOTE_EXIT_DETAIL_MASK 0x00070000
#define NOTE_EXIT_DECRYPTFAIL 0x00010000
#define NOTE_EXIT_MEMORY 0x00020000
#define NOTE_EXIT_CSERROR 0x00040000





#define NOTE_VM_PRESSURE 0x80000000
#define NOTE_VM_PRESSURE_TERMINATE 0x40000000
#define NOTE_VM_PRESSURE_SUDDEN_TERMINATE 0x20000000
#define NOTE_VM_ERROR 0x10000000
# 306 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define NOTE_SECONDS 0x00000001
#define NOTE_USECONDS 0x00000002
#define NOTE_NSECONDS 0x00000004
#define NOTE_ABSOLUTE 0x00000008

#define NOTE_LEEWAY 0x00000010
#define NOTE_CRITICAL 0x00000020
#define NOTE_BACKGROUND 0x00000040
#define NOTE_MACH_CONTINUOUS_TIME 0x00000080







#define NOTE_MACHTIME 0x00000100
# 364 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/event.h" 3 4
#define NOTE_TRACK 0x00000001
#define NOTE_TRACKERR 0x00000002
#define NOTE_CHILD 0x00000004




struct knote;
 struct klist { struct knote *slh_first; } ;


struct timespec;


int kqueue(void);
int kevent(int kq,
    const struct kevent *changelist, int nchanges,
    struct kevent *eventlist, int nevents,
    const struct timespec *timeout);
int kevent64(int kq,
    const struct kevent64_s *changelist, int nchanges,
    struct kevent64_s *eventlist, int nevents,
    unsigned int flags,
    const struct timespec *timeout);



# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/proc.h" 2 3 4







struct session;
struct pgrp;
struct proc;
struct proc_ident;


struct extern_proc {
 union {
  struct {
   struct proc *__p_forw;
   struct proc *__p_back;
  } p_st1;
  struct timeval __p_starttime;
 } p_un;
#define p_forw p_un.p_st1.__p_forw
#define p_back p_un.p_st1.__p_back
#define p_starttime p_un.__p_starttime
 struct vmspace *p_vmspace;
 struct sigacts *p_sigacts;
 int p_flag;
 char p_stat;
 pid_t p_pid;
 pid_t p_oppid;
 int p_dupfd;

 caddr_t user_stack;
 void *exit_thread;
 int p_debugger;
 boolean_t sigwait;

 u_int p_estcpu;
 int p_cpticks;
 fixpt_t p_pctcpu;
 void *p_wchan;
 char *p_wmesg;
 u_int p_swtime;
 u_int p_slptime;
 struct itimerval p_realtimer;
 struct timeval p_rtime;
 u_quad_t p_uticks;
 u_quad_t p_sticks;
 u_quad_t p_iticks;
 int p_traceflag;
 struct vnode *p_tracep;
 int p_siglist;
 struct vnode *p_textvp;
 int p_holdcnt;
 sigset_t p_sigmask;
 sigset_t p_sigignore;
 sigset_t p_sigcatch;
 u_char p_priority;
 u_char p_usrpri;
 char p_nice;
 char p_comm[16 + 1];
 struct pgrp *p_pgrp;
 struct user *p_addr;
 u_short p_xstat;
 u_short p_acflag;
 struct rusage *p_ru;
};



#define SIDL 1
#define SRUN 2
#define SSLEEP 3
#define SSTOP 4
#define SZOMB 5


#define P_ADVLOCK 0x00000001
#define P_CONTROLT 0x00000002
#define P_LP64 0x00000004
#define P_NOCLDSTOP 0x00000008

#define P_PPWAIT 0x00000010
#define P_PROFIL 0x00000020
#define P_SELECT 0x00000040
#define P_CONTINUED 0x00000080

#define P_SUGID 0x00000100
#define P_SYSTEM 0x00000200
#define P_TIMEOUT 0x00000400
#define P_TRACED 0x00000800

#define P_DISABLE_ASLR 0x00001000
#define P_WEXIT 0x00002000
#define P_EXEC 0x00004000


#define P_OWEUPC 0x00008000

#define P_AFFINITY 0x00010000
#define P_TRANSLATED 0x00020000
#define P_CLASSIC P_TRANSLATED

#define P_DELAYIDLESLEEP 0x00040000
#define P_CHECKOPENEVT 0x00080000

#define P_DEPENDENCY_CAPABLE 0x00100000
#define P_REBOOT 0x00200000
#define P_RESV6 0x00400000
#define P_RESV7 0x00800000

#define P_THCWD 0x01000000
#define P_RESV9 0x02000000
#define P_ADOPTPERSONA 0x04000000
#define P_RESV11 0x08000000

#define P_NOSHLIB 0x10000000

#define P_FORCEQUOTA 0x20000000
#define P_NOCLDWAIT 0x40000000
#define P_NOREMOTEHANG 0x80000000

#define P_INMEM 0
#define P_NOSWAP 0
#define P_PHYSIO 0
#define P_FSTRACE 0
#define P_SSTEP 0

#define P_DIRTY_TRACK 0x00000001
#define P_DIRTY_ALLOW_IDLE_EXIT 0x00000002
#define P_DIRTY_DEFER 0x00000004
#define P_DIRTY 0x00000008
#define P_DIRTY_SHUTDOWN 0x00000010
#define P_DIRTY_TERMINATED 0x00000020
#define P_DIRTY_BUSY 0x00000040
#define P_DIRTY_MARKED 0x00000080
#define P_DIRTY_AGING_IN_PROGRESS 0x00000100
#define P_DIRTY_LAUNCH_IN_PROGRESS 0x00000200
#define P_DIRTY_DEFER_ALWAYS 0x00000400


#define P_DIRTY_IS_DIRTY (P_DIRTY | P_DIRTY_SHUTDOWN)
#define P_DIRTY_IDLE_EXIT_ENABLED (P_DIRTY_TRACK|P_DIRTY_ALLOW_IDLE_EXIT)
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/vm.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/vm.h" 3 4
#define _SYS_VM_H 
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/vm.h" 3 4
struct vmspace {
 int32_t dummy;
 caddr_t dummy2;
 int32_t dummy3[5];
 caddr_t dummy4[3];
};
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 2 3 4
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define CTL_MAXNAME 12
# 133 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
struct ctlname {
 char *ctl_name;
 int ctl_type;
};

#define CTLTYPE 0xf
#define CTLTYPE_NODE 1
#define CTLTYPE_INT 2
#define CTLTYPE_STRING 3
#define CTLTYPE_QUAD 4
#define CTLTYPE_OPAQUE 5
#define CTLTYPE_STRUCT CTLTYPE_OPAQUE

#define CTLFLAG_RD 0x80000000
#define CTLFLAG_WR 0x40000000
#define CTLFLAG_RW (CTLFLAG_RD|CTLFLAG_WR)
#define CTLFLAG_NOLOCK 0x20000000
#define CTLFLAG_ANYBODY 0x10000000
#define CTLFLAG_SECURE 0x08000000
#define CTLFLAG_MASKED 0x04000000
#define CTLFLAG_NOAUTO 0x02000000
#define CTLFLAG_KERN 0x01000000
#define CTLFLAG_LOCKED 0x00800000
#define CTLFLAG_OID2 0x00400000
#define CTLFLAG_EXPERIMENT 0x00100000
# 172 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define OID_AUTO (-1)
#define OID_AUTO_START 100


#define SYSCTL_DEF_ENABLED 





#define CTL_UNSPEC 0
#define CTL_KERN 1
#define CTL_VM 2
#define CTL_VFS 3
#define CTL_NET 4
#define CTL_DEBUG 5
#define CTL_HW 6
#define CTL_MACHDEP 7
#define CTL_USER 8
#define CTL_MAXID 9

#define CTL_NAMES { { 0, 0 }, { "kern", CTLTYPE_NODE }, { "vm", CTLTYPE_NODE }, { "vfs", CTLTYPE_NODE }, { "net", CTLTYPE_NODE }, { "debug", CTLTYPE_NODE }, { "hw", CTLTYPE_NODE }, { "machdep", CTLTYPE_NODE }, { "user", CTLTYPE_NODE }, }
# 208 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define KERN_OSTYPE 1
#define KERN_OSRELEASE 2
#define KERN_OSREV 3
#define KERN_VERSION 4
#define KERN_MAXVNODES 5
#define KERN_MAXPROC 6
#define KERN_MAXFILES 7
#define KERN_ARGMAX 8
#define KERN_SECURELVL 9
#define KERN_HOSTNAME 10
#define KERN_HOSTID 11
#define KERN_CLOCKRATE 12
#define KERN_VNODE 13
#define KERN_PROC 14
#define KERN_FILE 15
#define KERN_PROF 16
#define KERN_POSIX1 17
#define KERN_NGROUPS 18
#define KERN_JOB_CONTROL 19
#define KERN_SAVED_IDS 20
#define KERN_BOOTTIME 21
#define KERN_NISDOMAINNAME 22
#define KERN_DOMAINNAME KERN_NISDOMAINNAME
#define KERN_MAXPARTITIONS 23
#define KERN_KDEBUG 24
#define KERN_UPDATEINTERVAL 25
#define KERN_OSRELDATE 26
#define KERN_NTP_PLL 27
#define KERN_BOOTFILE 28
#define KERN_MAXFILESPERPROC 29
#define KERN_MAXPROCPERUID 30
#define KERN_DUMPDEV 31
#define KERN_IPC 32
#define KERN_DUMMY 33
#define KERN_PS_STRINGS 34
#define KERN_USRSTACK32 35
#define KERN_LOGSIGEXIT 36
#define KERN_SYMFILE 37
#define KERN_PROCARGS 38

#define KERN_NETBOOT 40

#define KERN_SYSV 42
#define KERN_AFFINITY 43
#define KERN_TRANSLATE 44
#define KERN_CLASSIC KERN_TRANSLATE
#define KERN_EXEC 45
#define KERN_CLASSICHANDLER KERN_EXEC
#define KERN_AIOMAX 46
#define KERN_AIOPROCMAX 47
#define KERN_AIOTHREADS 48

#define KERN_PROCARGS2 49

#define KERN_COREFILE 50
#define KERN_COREDUMP 51
#define KERN_SUGID_COREDUMP 52
#define KERN_PROCDELAYTERM 53
#define KERN_SHREG_PRIVATIZABLE 54

#define KERN_LOW_PRI_WINDOW 56
#define KERN_LOW_PRI_DELAY 57
#define KERN_POSIX 58
#define KERN_USRSTACK64 59
#define KERN_NX_PROTECTION 60
#define KERN_TFP 61
#define KERN_PROCNAME 62
#define KERN_THALTSTACK 63
#define KERN_SPECULATIVE_READS 64
#define KERN_OSVERSION 65
#define KERN_SAFEBOOT 66

#define KERN_RAGEVNODE 68
#define KERN_TTY 69
#define KERN_CHECKOPENEVT 70
#define KERN_THREADNAME 71
#define KERN_MAXID 72
# 293 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define KERN_USRSTACK KERN_USRSTACK64






#define KERN_RAGE_PROC 1
#define KERN_RAGE_THREAD 2
#define KERN_UNRAGE_PROC 3
#define KERN_UNRAGE_THREAD 4


#define KERN_OPENEVT_PROC 1
#define KERN_UNOPENEVT_PROC 2


#define KERN_TFP_POLICY 1


#define KERN_TFP_POLICY_DENY 0
#define KERN_TFP_POLICY_DEFAULT 2


#define KERN_KDEFLAGS 1
#define KERN_KDDFLAGS 2
#define KERN_KDENABLE 3
#define KERN_KDSETBUF 4
#define KERN_KDGETBUF 5
#define KERN_KDSETUP 6
#define KERN_KDREMOVE 7
#define KERN_KDSETREG 8
#define KERN_KDGETREG 9
#define KERN_KDREADTR 10
#define KERN_KDPIDTR 11
#define KERN_KDTHRMAP 12

#define KERN_KDPIDEX 14
#define KERN_KDSETRTCDEC 15
#define KERN_KDGETENTROPY 16
#define KERN_KDWRITETR 17
#define KERN_KDWRITEMAP 18
#define KERN_KDTEST 19

#define KERN_KDREADCURTHRMAP 21
#define KERN_KDSET_TYPEFILTER 22
#define KERN_KDBUFWAIT 23
#define KERN_KDCPUMAP 24
#define KERN_KDCPUMAP_EXT 25

#define KERN_KDWRITETR_V3 28

#define CTL_KERN_NAMES { { 0, 0 }, { "ostype", CTLTYPE_STRING }, { "osrelease", CTLTYPE_STRING }, { "osrevision", CTLTYPE_INT }, { "version", CTLTYPE_STRING }, { "maxvnodes", CTLTYPE_INT }, { "maxproc", CTLTYPE_INT }, { "maxfiles", CTLTYPE_INT }, { "argmax", CTLTYPE_INT }, { "securelevel", CTLTYPE_INT }, { "hostname", CTLTYPE_STRING }, { "hostid", CTLTYPE_INT }, { "clockrate", CTLTYPE_STRUCT }, { "vnode", CTLTYPE_STRUCT }, { "proc", CTLTYPE_STRUCT }, { "file", CTLTYPE_STRUCT }, { "profiling", CTLTYPE_NODE }, { "posix1version", CTLTYPE_INT }, { "ngroups", CTLTYPE_INT }, { "job_control", CTLTYPE_INT }, { "saved_ids", CTLTYPE_INT }, { "boottime", CTLTYPE_STRUCT }, { "nisdomainname", CTLTYPE_STRING }, { "maxpartitions", CTLTYPE_INT }, { "kdebug", CTLTYPE_INT }, { "update", CTLTYPE_INT }, { "osreldate", CTLTYPE_INT }, { "ntp_pll", CTLTYPE_NODE }, { "bootfile", CTLTYPE_STRING }, { "maxfilesperproc", CTLTYPE_INT }, { "maxprocperuid", CTLTYPE_INT }, { "dumpdev", CTLTYPE_STRUCT }, { "ipc", CTLTYPE_NODE }, { "dummy", CTLTYPE_INT }, { "dummy", CTLTYPE_INT }, { "usrstack", CTLTYPE_INT }, { "logsigexit", CTLTYPE_INT }, { "symfile",CTLTYPE_STRING }, { "procargs",CTLTYPE_STRUCT }, { "dummy", CTLTYPE_INT }, { "netboot", CTLTYPE_INT }, { "dummy", CTLTYPE_INT }, { "sysv", CTLTYPE_NODE }, { "dummy", CTLTYPE_INT }, { "dummy", CTLTYPE_INT }, { "exec", CTLTYPE_NODE }, { "aiomax", CTLTYPE_INT }, { "aioprocmax", CTLTYPE_INT }, { "aiothreads", CTLTYPE_INT }, { "procargs2",CTLTYPE_STRUCT }, { "corefile",CTLTYPE_STRING }, { "coredump", CTLTYPE_INT }, { "sugid_coredump", CTLTYPE_INT }, { "delayterm", CTLTYPE_INT }, { "shreg_private", CTLTYPE_INT }, { "proc_low_pri_io", CTLTYPE_INT }, { "low_pri_window", CTLTYPE_INT }, { "low_pri_delay", CTLTYPE_INT }, { "posix", CTLTYPE_NODE }, { "usrstack64", CTLTYPE_QUAD }, { "nx", CTLTYPE_INT }, { "tfp", CTLTYPE_NODE }, { "procname", CTLTYPE_STRING }, { "threadsigaltstack", CTLTYPE_INT }, { "speculative_reads_disabled", CTLTYPE_INT }, { "osversion", CTLTYPE_STRING }, { "safeboot", CTLTYPE_INT }, { "dummy", CTLTYPE_INT }, { "rage_vnode", CTLTYPE_INT }, { "tty", CTLTYPE_NODE }, { "check_openevt", CTLTYPE_INT }, { "thread_name", CTLTYPE_STRING } }
# 423 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define CTL_VFS_NAMES { { "vfsconf", CTLTYPE_STRUCT } }






#define KERN_PROC_ALL 0
#define KERN_PROC_PID 1
#define KERN_PROC_PGRP 2
#define KERN_PROC_SESSION 3
#define KERN_PROC_TTY 4
#define KERN_PROC_UID 5
#define KERN_PROC_RUID 6
#define KERN_PROC_LCID 7




#define KERN_VFSNSPACE_HANDLE_PROC 1
#define KERN_VFSNSPACE_UNHANDLE_PROC 2





struct _pcred {
 char pc_lock[72];
 struct ucred *pc_ucred;
 uid_t p_ruid;
 uid_t p_svuid;
 gid_t p_rgid;
 gid_t p_svgid;
 int p_refcnt;
};

struct _ucred {
 int32_t cr_ref;
 uid_t cr_uid;
 short cr_ngroups;
 gid_t cr_groups[16];
};

struct kinfo_proc {
 struct extern_proc kp_proc;
 struct eproc {
  struct proc *e_paddr;
  struct session *e_sess;
  struct _pcred e_pcred;
  struct _ucred e_ucred;
  struct vmspace e_vm;
  pid_t e_ppid;
  pid_t e_pgid;
  short e_jobc;
  dev_t e_tdev;
  pid_t e_tpgid;
  struct session *e_tsess;
#define WMESGLEN 7
  char e_wmesg[7 + 1];
  segsz_t e_xsize;
  short e_xrssize;
  short e_xccount;
  short e_xswrss;
  int32_t e_flag;
#define EPROC_CTTY 0x01
#define EPROC_SLEADER 0x02
#define COMAPT_MAXLOGNAME 12
  char e_login[12];
  int32_t e_spare[4];
 } kp_eproc;
};






#define KIPC_MAXSOCKBUF 1
#define KIPC_SOCKBUF_WASTE 2
#define KIPC_SOMAXCONN 3
#define KIPC_MAX_LINKHDR 4
#define KIPC_MAX_PROTOHDR 5
#define KIPC_MAX_HDR 6
#define KIPC_MAX_DATALEN 7
#define KIPC_MBSTAT 8
#define KIPC_NMBCLUSTERS 9
#define KIPC_SOQLIMITCOMPAT 10




#define VM_METER 1
#define VM_LOADAVG 2




#define VM_MACHFACTOR 4
#define VM_SWAPUSAGE 5
#define VM_MAXID 6

#define CTL_VM_NAMES { { 0, 0 }, { "vmmeter", CTLTYPE_STRUCT }, { "loadavg", CTLTYPE_STRUCT }, { 0, 0 }, { "dummy", CTLTYPE_INT }, { "swapusage", CTLTYPE_STRUCT } }
# 533 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
struct xsw_usage {
 u_int64_t xsu_total;
 u_int64_t xsu_avail;
 u_int64_t xsu_used;
 u_int32_t xsu_pagesize;
 boolean_t xsu_encrypted;
};




struct loadavg {
 fixpt_t ldavg[3];
 long fscale;
};
extern struct loadavg averunnable;
#define LSCALE 1000







#define HW_MACHINE 1
#define HW_MODEL 2
#define HW_NCPU 3
#define HW_BYTEORDER 4
#define HW_PHYSMEM 5
#define HW_USERMEM 6
#define HW_PAGESIZE 7
#define HW_DISKNAMES 8
#define HW_DISKSTATS 9
#define HW_EPOCH 10
#define HW_FLOATINGPT 11
#define HW_MACHINE_ARCH 12
#define HW_VECTORUNIT 13
#define HW_BUS_FREQ 14
#define HW_CPU_FREQ 15
#define HW_CACHELINE 16
#define HW_L1ICACHESIZE 17
#define HW_L1DCACHESIZE 18
#define HW_L2SETTINGS 19
#define HW_L2CACHESIZE 20
#define HW_L3SETTINGS 21
#define HW_L3CACHESIZE 22
#define HW_TB_FREQ 23
#define HW_MEMSIZE 24
#define HW_AVAILCPU 25
#define HW_TARGET 26
#define HW_PRODUCT 27
#define HW_MAXID 28

#define CTL_HW_NAMES { { 0, 0 }, { "machine", CTLTYPE_STRING }, { "model", CTLTYPE_STRING }, { "ncpu", CTLTYPE_INT }, { "byteorder", CTLTYPE_INT }, { "physmem", CTLTYPE_INT }, { "usermem", CTLTYPE_INT }, { "pagesize", CTLTYPE_INT }, { "disknames", CTLTYPE_STRUCT }, { "diskstats", CTLTYPE_STRUCT }, { "epoch", CTLTYPE_INT }, { "floatingpoint", CTLTYPE_INT }, { "machinearch", CTLTYPE_STRING }, { "vectorunit", CTLTYPE_INT }, { "busfrequency", CTLTYPE_INT }, { "cpufrequency", CTLTYPE_INT }, { "cachelinesize", CTLTYPE_INT }, { "l1icachesize", CTLTYPE_INT }, { "l1dcachesize", CTLTYPE_INT }, { "l2settings", CTLTYPE_INT }, { "l2cachesize", CTLTYPE_INT }, { "l3settings", CTLTYPE_INT }, { "l3cachesize", CTLTYPE_INT }, { "tbfrequency", CTLTYPE_INT }, { "memsize", CTLTYPE_QUAD }, { "availcpu", CTLTYPE_INT }, { "target", CTLTYPE_STRING }, { "product", CTLTYPE_STRING }, }
# 726 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define USER_CS_PATH 1
#define USER_BC_BASE_MAX 2
#define USER_BC_DIM_MAX 3
#define USER_BC_SCALE_MAX 4
#define USER_BC_STRING_MAX 5
#define USER_COLL_WEIGHTS_MAX 6
#define USER_EXPR_NEST_MAX 7
#define USER_LINE_MAX 8
#define USER_RE_DUP_MAX 9
#define USER_POSIX2_VERSION 10
#define USER_POSIX2_C_BIND 11
#define USER_POSIX2_C_DEV 12
#define USER_POSIX2_CHAR_TERM 13
#define USER_POSIX2_FORT_DEV 14
#define USER_POSIX2_FORT_RUN 15
#define USER_POSIX2_LOCALEDEF 16
#define USER_POSIX2_SW_DEV 17
#define USER_POSIX2_UPE 18
#define USER_STREAM_MAX 19
#define USER_TZNAME_MAX 20
#define USER_MAXID 21

#define CTL_USER_NAMES { { 0, 0 }, { "cs_path", CTLTYPE_STRING }, { "bc_base_max", CTLTYPE_INT }, { "bc_dim_max", CTLTYPE_INT }, { "bc_scale_max", CTLTYPE_INT }, { "bc_string_max", CTLTYPE_INT }, { "coll_weights_max", CTLTYPE_INT }, { "expr_nest_max", CTLTYPE_INT }, { "line_max", CTLTYPE_INT }, { "re_dup_max", CTLTYPE_INT }, { "posix2_version", CTLTYPE_INT }, { "posix2_c_bind", CTLTYPE_INT }, { "posix2_c_dev", CTLTYPE_INT }, { "posix2_char_term", CTLTYPE_INT }, { "posix2_fort_dev", CTLTYPE_INT }, { "posix2_fort_run", CTLTYPE_INT }, { "posix2_localedef", CTLTYPE_INT }, { "posix2_sw_dev", CTLTYPE_INT }, { "posix2_upe", CTLTYPE_INT }, { "stream_max", CTLTYPE_INT }, { "tzname_max", CTLTYPE_INT } }
# 780 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4
#define CTL_DEBUG_NAME 0
#define CTL_DEBUG_VALUE 1
#define CTL_DEBUG_MAXID 20
# 791 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sysctl.h" 3 4

int sysctl(int *, u_int, void *, size_t *, void *, size_t);
int sysctlbyname(const char *, void *, size_t *, void *, size_t);
int sysctlnametomib(const char *, int *, size_t *);

# 22974 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/malloc/malloc.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/malloc/malloc.h" 3 4
#define _MALLOC_MALLOC_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 1 3 4
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 3 4
#define _MACH_MACH_TYPES_H_ 





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_info.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_info.h" 3 4
#define _MACH_HOST_INFO_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 1 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
#define _MACH_MESSAGE_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kern_return.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kern_return.h" 3 4
#define _MACH_KERN_RETURN_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/kern_return.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/kern_return.h" 3 4
#define _MACH_MACHINE_KERN_RETURN_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/kern_return.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/kern_return.h" 3 4
#define _MACH_ARM_KERN_RETURN_H_ 




typedef int kern_return_t;
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/kern_return.h" 2 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kern_return.h" 2 3 4

#define KERN_SUCCESS 0

#define KERN_INVALID_ADDRESS 1



#define KERN_PROTECTION_FAILURE 2




#define KERN_NO_SPACE 3





#define KERN_INVALID_ARGUMENT 4




#define KERN_FAILURE 5



#define KERN_RESOURCE_SHORTAGE 6




#define KERN_NOT_RECEIVER 7




#define KERN_NO_ACCESS 8



#define KERN_MEMORY_FAILURE 9





#define KERN_MEMORY_ERROR 10







#define KERN_ALREADY_IN_SET 11



#define KERN_NOT_IN_SET 12



#define KERN_NAME_EXISTS 13



#define KERN_ABORTED 14




#define KERN_INVALID_NAME 15



#define KERN_INVALID_TASK 16



#define KERN_INVALID_RIGHT 17



#define KERN_INVALID_VALUE 18



#define KERN_UREFS_OVERFLOW 19



#define KERN_INVALID_CAPABILITY 20



#define KERN_RIGHT_EXISTS 21




#define KERN_INVALID_HOST 22



#define KERN_MEMORY_PRESENT 23





#define KERN_MEMORY_DATA_MOVED 24
# 198 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kern_return.h" 3 4
#define KERN_MEMORY_RESTART_COPY 25







#define KERN_INVALID_PROCESSOR_SET 26




#define KERN_POLICY_LIMIT 27




#define KERN_INVALID_POLICY 28




#define KERN_INVALID_OBJECT 29




#define KERN_ALREADY_WAITING 30




#define KERN_DEFAULT_SET 31




#define KERN_EXCEPTION_PROTECTED 32





#define KERN_INVALID_LEDGER 33



#define KERN_INVALID_MEMORY_CONTROL 34



#define KERN_INVALID_SECURITY 35




#define KERN_NOT_DEPRESSED 36




#define KERN_TERMINATED 37



#define KERN_LOCK_SET_DESTROYED 38



#define KERN_LOCK_UNSTABLE 39




#define KERN_LOCK_OWNED 40



#define KERN_LOCK_OWNED_SELF 41



#define KERN_SEMAPHORE_DESTROYED 42



#define KERN_RPC_SERVER_TERMINATED 43




#define KERN_RPC_TERMINATE_ORPHAN 44



#define KERN_RPC_CONTINUE_ORPHAN 45



#define KERN_NOT_SUPPORTED 46



#define KERN_NODE_DOWN 47



#define KERN_NOT_WAITING 48


#define KERN_OPERATION_TIMED_OUT 49



#define KERN_CODESIGN_ERROR 50




#define KERN_POLICY_STATIC 51



#define KERN_INSUFFICIENT_BUFFER_SIZE 52



#define KERN_DENIED 53



#define KERN_MISSING_KC 54



#define KERN_INVALID_KC 55



#define KERN_NOT_FOUND 56



#define KERN_RETURN_MAX 0x100
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 2 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef natural_t mach_msg_timeout_t;






#define MACH_MSG_TIMEOUT_NONE ((mach_msg_timeout_t) 0)
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
#define MACH_MSGH_BITS_ZERO 0x00000000

#define MACH_MSGH_BITS_REMOTE_MASK 0x0000001f
#define MACH_MSGH_BITS_LOCAL_MASK 0x00001f00
#define MACH_MSGH_BITS_VOUCHER_MASK 0x001f0000

#define MACH_MSGH_BITS_PORTS_MASK (MACH_MSGH_BITS_REMOTE_MASK | MACH_MSGH_BITS_LOCAL_MASK | MACH_MSGH_BITS_VOUCHER_MASK)




#define MACH_MSGH_BITS_COMPLEX 0x80000000U

#define MACH_MSGH_BITS_USER 0x801f1f1fU

#define MACH_MSGH_BITS_RAISEIMP 0x20000000U
#define MACH_MSGH_BITS_DENAP MACH_MSGH_BITS_RAISEIMP

#define MACH_MSGH_BITS_IMPHOLDASRT 0x10000000U
#define MACH_MSGH_BITS_DENAPHOLDASRT MACH_MSGH_BITS_IMPHOLDASRT

#define MACH_MSGH_BITS_CIRCULAR 0x10000000U

#define MACH_MSGH_BITS_USED 0xb01f1f1fU


#define MACH_MSGH_BITS(remote,local) ((remote) | ((local) << 8))

#define MACH_MSGH_BITS_SET_PORTS(remote,local,voucher) (((remote) & MACH_MSGH_BITS_REMOTE_MASK) | (((local) << 8) & MACH_MSGH_BITS_LOCAL_MASK) | (((voucher) << 16) & MACH_MSGH_BITS_VOUCHER_MASK))



#define MACH_MSGH_BITS_SET(remote,local,voucher,other) (MACH_MSGH_BITS_SET_PORTS((remote), (local), (voucher)) | ((other) &~ MACH_MSGH_BITS_PORTS_MASK))




#define MACH_MSGH_BITS_REMOTE(bits) ((bits) & MACH_MSGH_BITS_REMOTE_MASK)

#define MACH_MSGH_BITS_LOCAL(bits) (((bits) & MACH_MSGH_BITS_LOCAL_MASK) >> 8)

#define MACH_MSGH_BITS_VOUCHER(bits) (((bits) & MACH_MSGH_BITS_VOUCHER_MASK) >> 16)

#define MACH_MSGH_BITS_PORTS(bits) ((bits) & MACH_MSGH_BITS_PORTS_MASK)

#define MACH_MSGH_BITS_OTHER(bits) ((bits) &~ MACH_MSGH_BITS_PORTS_MASK)



#define MACH_MSGH_BITS_HAS_REMOTE(bits) (MACH_MSGH_BITS_REMOTE(bits) != MACH_MSGH_BITS_ZERO)

#define MACH_MSGH_BITS_HAS_LOCAL(bits) (MACH_MSGH_BITS_LOCAL(bits) != MACH_MSGH_BITS_ZERO)

#define MACH_MSGH_BITS_HAS_VOUCHER(bits) (MACH_MSGH_BITS_VOUCHER(bits) != MACH_MSGH_BITS_ZERO)

#define MACH_MSGH_BITS_IS_COMPLEX(bits) (((bits) & MACH_MSGH_BITS_COMPLEX) != MACH_MSGH_BITS_ZERO)



#define MACH_MSGH_BITS_RAISED_IMPORTANCE(bits) (((bits) & MACH_MSGH_BITS_RAISEIMP) != MACH_MSGH_BITS_ZERO)

#define MACH_MSGH_BITS_HOLDS_IMPORTANCE_ASSERTION(bits) (((bits) & MACH_MSGH_BITS_IMPHOLDASRT) != MACH_MSGH_BITS_ZERO)
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef unsigned int mach_msg_bits_t;
typedef natural_t mach_msg_size_t;
typedef integer_t mach_msg_id_t;

#define MACH_MSG_SIZE_NULL (mach_msg_size_t *) 0

typedef unsigned int mach_msg_priority_t;

#define MACH_MSG_PRIORITY_UNSPECIFIED (mach_msg_priority_t) 0


typedef unsigned int mach_msg_type_name_t;

#define MACH_MSG_TYPE_MOVE_RECEIVE 16
#define MACH_MSG_TYPE_MOVE_SEND 17
#define MACH_MSG_TYPE_MOVE_SEND_ONCE 18
#define MACH_MSG_TYPE_COPY_SEND 19
#define MACH_MSG_TYPE_MAKE_SEND 20
#define MACH_MSG_TYPE_MAKE_SEND_ONCE 21
#define MACH_MSG_TYPE_COPY_RECEIVE 22
#define MACH_MSG_TYPE_DISPOSE_RECEIVE 24
#define MACH_MSG_TYPE_DISPOSE_SEND 25
#define MACH_MSG_TYPE_DISPOSE_SEND_ONCE 26

typedef unsigned int mach_msg_copy_options_t;

#define MACH_MSG_PHYSICAL_COPY 0
#define MACH_MSG_VIRTUAL_COPY 1
#define MACH_MSG_ALLOCATE 2
#define MACH_MSG_OVERWRITE 3




#define MACH_MSG_GUARD_FLAGS_NONE 0x0000
#define MACH_MSG_GUARD_FLAGS_IMMOVABLE_RECEIVE 0x0001
#define MACH_MSG_GUARD_FLAGS_UNGUARDED_ON_SEND 0x0002
#define MACH_MSG_GUARD_FLAGS_MASK 0x0003
typedef unsigned int mach_msg_guard_flags_t;
# 273 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef unsigned int mach_msg_descriptor_type_t;

#define MACH_MSG_PORT_DESCRIPTOR 0
#define MACH_MSG_OOL_DESCRIPTOR 1
#define MACH_MSG_OOL_PORTS_DESCRIPTOR 2
#define MACH_MSG_OOL_VOLATILE_DESCRIPTOR 3
#define MACH_MSG_GUARDED_PORT_DESCRIPTOR 4

#pragma pack(push, 4)

typedef struct{
 natural_t pad1;
 mach_msg_size_t pad2;
 unsigned int pad3 : 24;
 mach_msg_descriptor_type_t type : 8;
} mach_msg_type_descriptor_t;

typedef struct{
 mach_port_t name;

 mach_msg_size_t pad1;
 unsigned int pad2 : 16;
 mach_msg_type_name_t disposition : 8;
 mach_msg_descriptor_type_t type : 8;
} mach_msg_port_descriptor_t;


typedef struct{
 uint32_t address;
 mach_msg_size_t size;
 boolean_t deallocate: 8;
 mach_msg_copy_options_t copy: 8;
 unsigned int pad1: 8;
 mach_msg_descriptor_type_t type: 8;
} mach_msg_ool_descriptor32_t;

typedef struct{
 uint64_t address;
 boolean_t deallocate: 8;
 mach_msg_copy_options_t copy: 8;
 unsigned int pad1: 8;
 mach_msg_descriptor_type_t type: 8;
 mach_msg_size_t size;
} mach_msg_ool_descriptor64_t;

typedef struct{
 void* address;



 boolean_t deallocate: 8;
 mach_msg_copy_options_t copy: 8;
 unsigned int pad1: 8;
 mach_msg_descriptor_type_t type: 8;

 mach_msg_size_t size;

} mach_msg_ool_descriptor_t;

typedef struct{
 uint32_t address;
 mach_msg_size_t count;
 boolean_t deallocate: 8;
 mach_msg_copy_options_t copy: 8;
 mach_msg_type_name_t disposition : 8;
 mach_msg_descriptor_type_t type : 8;
} mach_msg_ool_ports_descriptor32_t;

typedef struct{
 uint64_t address;
 boolean_t deallocate: 8;
 mach_msg_copy_options_t copy: 8;
 mach_msg_type_name_t disposition : 8;
 mach_msg_descriptor_type_t type : 8;
 mach_msg_size_t count;
} mach_msg_ool_ports_descriptor64_t;

typedef struct{
 void* address;



 boolean_t deallocate: 8;
 mach_msg_copy_options_t copy: 8;
 mach_msg_type_name_t disposition : 8;
 mach_msg_descriptor_type_t type : 8;

 mach_msg_size_t count;

} mach_msg_ool_ports_descriptor_t;

typedef struct{
 uint32_t context;
 mach_port_name_t name;
 mach_msg_guard_flags_t flags : 16;
 mach_msg_type_name_t disposition : 8;
 mach_msg_descriptor_type_t type : 8;
} mach_msg_guarded_port_descriptor32_t;

typedef struct{
 uint64_t context;
 mach_msg_guard_flags_t flags : 16;
 mach_msg_type_name_t disposition : 8;
 mach_msg_descriptor_type_t type : 8;
 mach_port_name_t name;
} mach_msg_guarded_port_descriptor64_t;

typedef struct{
 mach_port_context_t context;



 mach_msg_guard_flags_t flags : 16;
 mach_msg_type_name_t disposition : 8;
 mach_msg_descriptor_type_t type : 8;

 mach_port_name_t name;

} mach_msg_guarded_port_descriptor_t;






typedef union{
 mach_msg_port_descriptor_t port;
 mach_msg_ool_descriptor_t out_of_line;
 mach_msg_ool_ports_descriptor_t ool_ports;
 mach_msg_type_descriptor_t type;
 mach_msg_guarded_port_descriptor_t guarded_port;
} mach_msg_descriptor_t;

typedef struct{
 mach_msg_size_t msgh_descriptor_count;
} mach_msg_body_t;

#define MACH_MSG_BODY_NULL ((mach_msg_body_t *) 0)
#define MACH_MSG_DESCRIPTOR_NULL ((mach_msg_descriptor_t *) 0)

typedef struct{
 mach_msg_bits_t msgh_bits;
 mach_msg_size_t msgh_size;
 mach_port_t msgh_remote_port;
 mach_port_t msgh_local_port;
 mach_port_name_t msgh_voucher_port;
 mach_msg_id_t msgh_id;
} mach_msg_header_t;

#define msgh_reserved msgh_voucher_port
#define MACH_MSG_NULL ((mach_msg_header_t *) 0)

typedef struct{
 mach_msg_header_t header;
 mach_msg_body_t body;
} mach_msg_base_t;


typedef unsigned int mach_msg_trailer_type_t;

#define MACH_MSG_TRAILER_FORMAT_0 0

typedef unsigned int mach_msg_trailer_size_t;
typedef char *mach_msg_trailer_info_t;

typedef struct{
 mach_msg_trailer_type_t msgh_trailer_type;
 mach_msg_trailer_size_t msgh_trailer_size;
} mach_msg_trailer_t;
# 452 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef struct{
 mach_msg_trailer_type_t msgh_trailer_type;
 mach_msg_trailer_size_t msgh_trailer_size;
 mach_port_seqno_t msgh_seqno;
} mach_msg_seqno_trailer_t;

typedef struct{
 unsigned int val[2];
} security_token_t;

typedef struct{
 mach_msg_trailer_type_t msgh_trailer_type;
 mach_msg_trailer_size_t msgh_trailer_size;
 mach_port_seqno_t msgh_seqno;
 security_token_t msgh_sender;
} mach_msg_security_trailer_t;
# 478 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef struct{
 unsigned int val[8];
} audit_token_t;

typedef struct{
 mach_msg_trailer_type_t msgh_trailer_type;
 mach_msg_trailer_size_t msgh_trailer_size;
 mach_port_seqno_t msgh_seqno;
 security_token_t msgh_sender;
 audit_token_t msgh_audit;
} mach_msg_audit_trailer_t;

typedef struct{
 mach_msg_trailer_type_t msgh_trailer_type;
 mach_msg_trailer_size_t msgh_trailer_size;
 mach_port_seqno_t msgh_seqno;
 security_token_t msgh_sender;
 audit_token_t msgh_audit;
 mach_port_context_t msgh_context;
} mach_msg_context_trailer_t;



typedef struct{
 mach_port_name_t sender;
} msg_labels_t;

typedef int mach_msg_filter_id;
#define MACH_MSG_FILTER_POLICY_ALLOW (mach_msg_filter_id)0






typedef struct{
 mach_msg_trailer_type_t msgh_trailer_type;
 mach_msg_trailer_size_t msgh_trailer_size;
 mach_port_seqno_t msgh_seqno;
 security_token_t msgh_sender;
 audit_token_t msgh_audit;
 mach_port_context_t msgh_context;
 mach_msg_filter_id msgh_ad;
 msg_labels_t msgh_labels;
} mach_msg_mac_trailer_t;


#define MACH_MSG_TRAILER_MINIMUM_SIZE sizeof(mach_msg_trailer_t)
# 537 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef mach_msg_mac_trailer_t mach_msg_max_trailer_t;
#define MAX_TRAILER_SIZE ((mach_msg_size_t)sizeof(mach_msg_max_trailer_t))
# 547 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef mach_msg_security_trailer_t mach_msg_format_0_trailer_t;




#define MACH_MSG_TRAILER_FORMAT_0_SIZE sizeof(mach_msg_format_0_trailer_t)

#define KERNEL_SECURITY_TOKEN_VALUE { {0, 1} }
extern const security_token_t KERNEL_SECURITY_TOKEN;

#define KERNEL_AUDIT_TOKEN_VALUE { {0, 0, 0, 0, 0, 0, 0, 0} }
extern const audit_token_t KERNEL_AUDIT_TOKEN;

typedef integer_t mach_msg_options_t;

typedef struct{
 mach_msg_header_t header;
} mach_msg_empty_send_t;

typedef struct{
 mach_msg_header_t header;
 mach_msg_trailer_t trailer;
} mach_msg_empty_rcv_t;

typedef union{
 mach_msg_empty_send_t send;
 mach_msg_empty_rcv_t rcv;
} mach_msg_empty_t;

#pragma pack(pop)


#define round_msg(x) (((mach_msg_size_t)(x) + sizeof (natural_t) - 1) & ~(sizeof (natural_t) - 1))






#define MACH_MSG_SIZE_MAX ((mach_msg_size_t) ~0)
# 597 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
#define MACH_MSG_SIZE_RELIABLE ((mach_msg_size_t) 256 * 1024)





#define MACH_MSGH_KIND_NORMAL 0x00000000
#define MACH_MSGH_KIND_NOTIFICATION 0x00000001
#define msgh_kind msgh_seqno
#define mach_msg_kind_t mach_port_seqno_t

typedef natural_t mach_msg_type_size_t;
typedef natural_t mach_msg_type_number_t;
# 620 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
#define MACH_MSG_TYPE_PORT_NONE 0

#define MACH_MSG_TYPE_PORT_NAME 15
#define MACH_MSG_TYPE_PORT_RECEIVE MACH_MSG_TYPE_MOVE_RECEIVE
#define MACH_MSG_TYPE_PORT_SEND MACH_MSG_TYPE_MOVE_SEND
#define MACH_MSG_TYPE_PORT_SEND_ONCE MACH_MSG_TYPE_MOVE_SEND_ONCE

#define MACH_MSG_TYPE_LAST 22






#define MACH_MSG_TYPE_POLYMORPHIC ((mach_msg_type_name_t) -1)





#define MACH_MSG_TYPE_PORT_ANY(x) (((x) >= MACH_MSG_TYPE_MOVE_RECEIVE) && ((x) <= MACH_MSG_TYPE_MAKE_SEND_ONCE))



#define MACH_MSG_TYPE_PORT_ANY_SEND(x) (((x) >= MACH_MSG_TYPE_MOVE_SEND) && ((x) <= MACH_MSG_TYPE_MAKE_SEND_ONCE))



#define MACH_MSG_TYPE_PORT_ANY_RIGHT(x) (((x) >= MACH_MSG_TYPE_MOVE_RECEIVE) && ((x) <= MACH_MSG_TYPE_MOVE_SEND_ONCE))



typedef integer_t mach_msg_option_t;

#define MACH_MSG_OPTION_NONE 0x00000000

#define MACH_SEND_MSG 0x00000001
#define MACH_RCV_MSG 0x00000002

#define MACH_RCV_LARGE 0x00000004
#define MACH_RCV_LARGE_IDENTITY 0x00000008

#define MACH_SEND_TIMEOUT 0x00000010
#define MACH_SEND_OVERRIDE 0x00000020
#define MACH_SEND_INTERRUPT 0x00000040
#define MACH_SEND_NOTIFY 0x00000080
#define MACH_SEND_ALWAYS 0x00010000
#define MACH_SEND_FILTER_NONFATAL 0x00010000
#define MACH_SEND_TRAILER 0x00020000
#define MACH_SEND_NOIMPORTANCE 0x00040000
#define MACH_SEND_NODENAP MACH_SEND_NOIMPORTANCE
#define MACH_SEND_IMPORTANCE 0x00080000
#define MACH_SEND_SYNC_OVERRIDE 0x00100000
#define MACH_SEND_PROPAGATE_QOS 0x00200000
#define MACH_SEND_SYNC_USE_THRPRI MACH_SEND_PROPAGATE_QOS
#define MACH_SEND_KERNEL 0x00400000
#define MACH_SEND_SYNC_BOOTSTRAP_CHECKIN 0x00800000

#define MACH_RCV_TIMEOUT 0x00000100
#define MACH_RCV_NOTIFY 0x00000000
#define MACH_RCV_INTERRUPT 0x00000400
#define MACH_RCV_VOUCHER 0x00000800
#define MACH_RCV_OVERWRITE 0x00000000
#define MACH_RCV_GUARDED_DESC 0x00001000
#define MACH_RCV_SYNC_WAIT 0x00004000
#define MACH_RCV_SYNC_PEEK 0x00008000

#define MACH_MSG_STRICT_REPLY 0x00000200
# 701 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
#define MACH_RCV_TRAILER_NULL 0
#define MACH_RCV_TRAILER_SEQNO 1
#define MACH_RCV_TRAILER_SENDER 2
#define MACH_RCV_TRAILER_AUDIT 3
#define MACH_RCV_TRAILER_CTX 4
#define MACH_RCV_TRAILER_AV 7
#define MACH_RCV_TRAILER_LABELS 8

#define MACH_RCV_TRAILER_TYPE(x) (((x) & 0xf) << 28)
#define MACH_RCV_TRAILER_ELEMENTS(x) (((x) & 0xf) << 24)
#define MACH_RCV_TRAILER_MASK ((0xf << 24))

#define GET_RCV_ELEMENTS(y) (((y) >> 24) & 0xf)
# 725 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
#define REQUESTED_TRAILER_SIZE_NATIVE(y) ((mach_msg_trailer_size_t) ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_NULL) ? sizeof(mach_msg_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_SEQNO) ? sizeof(mach_msg_seqno_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_SENDER) ? sizeof(mach_msg_security_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_AUDIT) ? sizeof(mach_msg_audit_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_CTX) ? sizeof(mach_msg_context_trailer_t) : ((GET_RCV_ELEMENTS(y) == MACH_RCV_TRAILER_AV) ? sizeof(mach_msg_mac_trailer_t) : sizeof(mach_msg_max_trailer_t))))))))
# 742 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
#define REQUESTED_TRAILER_SIZE(y) REQUESTED_TRAILER_SIZE_NATIVE(y)
# 755 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4
typedef kern_return_t mach_msg_return_t;

#define MACH_MSG_SUCCESS 0x00000000


#define MACH_MSG_MASK 0x00003e00

#define MACH_MSG_IPC_SPACE 0x00002000

#define MACH_MSG_VM_SPACE 0x00001000

#define MACH_MSG_IPC_KERNEL 0x00000800

#define MACH_MSG_VM_KERNEL 0x00000400


#define MACH_SEND_IN_PROGRESS 0x10000001

#define MACH_SEND_INVALID_DATA 0x10000002

#define MACH_SEND_INVALID_DEST 0x10000003

#define MACH_SEND_TIMED_OUT 0x10000004

#define MACH_SEND_INVALID_VOUCHER 0x10000005

#define MACH_SEND_INTERRUPTED 0x10000007

#define MACH_SEND_MSG_TOO_SMALL 0x10000008

#define MACH_SEND_INVALID_REPLY 0x10000009

#define MACH_SEND_INVALID_RIGHT 0x1000000a

#define MACH_SEND_INVALID_NOTIFY 0x1000000b

#define MACH_SEND_INVALID_MEMORY 0x1000000c

#define MACH_SEND_NO_BUFFER 0x1000000d

#define MACH_SEND_TOO_LARGE 0x1000000e

#define MACH_SEND_INVALID_TYPE 0x1000000f

#define MACH_SEND_INVALID_HEADER 0x10000010

#define MACH_SEND_INVALID_TRAILER 0x10000011

#define MACH_SEND_INVALID_CONTEXT 0x10000012

#define MACH_SEND_INVALID_RT_OOL_SIZE 0x10000015

#define MACH_SEND_NO_GRANT_DEST 0x10000016

#define MACH_SEND_MSG_FILTERED 0x10000017


#define MACH_RCV_IN_PROGRESS 0x10004001

#define MACH_RCV_INVALID_NAME 0x10004002

#define MACH_RCV_TIMED_OUT 0x10004003

#define MACH_RCV_TOO_LARGE 0x10004004

#define MACH_RCV_INTERRUPTED 0x10004005

#define MACH_RCV_PORT_CHANGED 0x10004006

#define MACH_RCV_INVALID_NOTIFY 0x10004007

#define MACH_RCV_INVALID_DATA 0x10004008

#define MACH_RCV_PORT_DIED 0x10004009

#define MACH_RCV_IN_SET 0x1000400a

#define MACH_RCV_HEADER_ERROR 0x1000400b

#define MACH_RCV_BODY_ERROR 0x1000400c

#define MACH_RCV_INVALID_TYPE 0x1000400d

#define MACH_RCV_SCATTER_SMALL 0x1000400e

#define MACH_RCV_INVALID_TRAILER 0x1000400f

#define MACH_RCV_IN_PROGRESS_TIMED 0x10004011

#define MACH_RCV_INVALID_REPLY 0x10004012





# 867 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4

extern mach_msg_return_t mach_msg_overwrite(
 mach_msg_header_t *msg,
 mach_msg_option_t option,
 mach_msg_size_t send_size,
 mach_msg_size_t rcv_size,
 mach_port_name_t rcv_name,
 mach_msg_timeout_t timeout,
 mach_port_name_t notify,
 mach_msg_header_t *rcv_msg,
 mach_msg_size_t rcv_limit);
# 888 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/message.h" 3 4

extern mach_msg_return_t mach_msg(
 mach_msg_header_t *msg,
 mach_msg_option_t option,
 mach_msg_size_t send_size,
 mach_msg_size_t rcv_size,
 mach_port_name_t rcv_name,
 mach_msg_timeout_t timeout,
 mach_port_name_t notify);








extern kern_return_t mach_voucher_deallocate(
 mach_port_name_t voucher);



# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_info.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 3 4
#define _MACH_VM_STATISTICS_H_ 
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 3 4
struct vm_statistics {
 natural_t free_count;
 natural_t active_count;
 natural_t inactive_count;
 natural_t wire_count;
 natural_t zero_fill_count;
 natural_t reactivations;
 natural_t pageins;
 natural_t pageouts;
 natural_t faults;
 natural_t cow_faults;
 natural_t lookups;
 natural_t hits;


 natural_t purgeable_count;
 natural_t purges;
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 3 4
 natural_t speculative_count;
};


typedef struct vm_statistics *vm_statistics_t;
typedef struct vm_statistics vm_statistics_data_t;
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 3 4
struct vm_statistics64 {
 natural_t free_count;
 natural_t active_count;
 natural_t inactive_count;
 natural_t wire_count;
 uint64_t zero_fill_count;
 uint64_t reactivations;
 uint64_t pageins;
 uint64_t pageouts;
 uint64_t faults;
 uint64_t cow_faults;
 uint64_t lookups;
 uint64_t hits;
 uint64_t purges;
 natural_t purgeable_count;






 natural_t speculative_count;


 uint64_t decompressions;
 uint64_t compressions;
 uint64_t swapins;
 uint64_t swapouts;
 natural_t compressor_page_count;
 natural_t throttled_count;
 natural_t external_page_count;
 natural_t internal_page_count;
 uint64_t total_uncompressed_pages_in_compressor;
} __attribute__((aligned(8)));

typedef struct vm_statistics64 *vm_statistics64_t;
typedef struct vm_statistics64 vm_statistics64_data_t;

kern_return_t vm_stats(void *info, unsigned int *count);







#define VM_STATISTICS_TRUNCATE_TO_32_BIT(value) ((uint32_t)(((value) > UINT32_MAX ) ? UINT32_MAX : (value)))
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 3 4
struct vm_extmod_statistics {
 int64_t task_for_pid_count;
 int64_t task_for_pid_caller_count;
 int64_t thread_creation_count;
 int64_t thread_creation_caller_count;
 int64_t thread_set_state_count;
 int64_t thread_set_state_caller_count;
} __attribute__((aligned(8)));

typedef struct vm_extmod_statistics *vm_extmod_statistics_t;
typedef struct vm_extmod_statistics vm_extmod_statistics_data_t;

typedef struct vm_purgeable_stat {
 uint64_t count;
 uint64_t size;
}vm_purgeable_stat_t;

struct vm_purgeable_info {
 vm_purgeable_stat_t fifo_data[8];
 vm_purgeable_stat_t obsolete_data;
 vm_purgeable_stat_t lifo_data[8];
};

typedef struct vm_purgeable_info *vm_purgeable_info_t;



#define VM_PAGE_QUERY_PAGE_PRESENT 0x1
#define VM_PAGE_QUERY_PAGE_FICTITIOUS 0x2
#define VM_PAGE_QUERY_PAGE_REF 0x4
#define VM_PAGE_QUERY_PAGE_DIRTY 0x8
#define VM_PAGE_QUERY_PAGE_PAGED_OUT 0x10
#define VM_PAGE_QUERY_PAGE_COPIED 0x20
#define VM_PAGE_QUERY_PAGE_SPECULATIVE 0x40
#define VM_PAGE_QUERY_PAGE_EXTERNAL 0x80
#define VM_PAGE_QUERY_PAGE_CS_VALIDATED 0x100
#define VM_PAGE_QUERY_PAGE_CS_TAINTED 0x200
#define VM_PAGE_QUERY_PAGE_CS_NX 0x400
#define VM_PAGE_QUERY_PAGE_REUSABLE 0x800
# 266 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 3 4
#define VM_FLAGS_FIXED 0x0000
#define VM_FLAGS_ANYWHERE 0x0001
#define VM_FLAGS_PURGABLE 0x0002
#define VM_FLAGS_4GB_CHUNK 0x0004
#define VM_FLAGS_RANDOM_ADDR 0x0008
#define VM_FLAGS_NO_CACHE 0x0010
#define VM_FLAGS_RESILIENT_CODESIGN 0x0020
#define VM_FLAGS_RESILIENT_MEDIA 0x0040
#define VM_FLAGS_PERMANENT 0x0080
#define VM_FLAGS_OVERWRITE 0x4000





#define VM_FLAGS_SUPERPAGE_MASK 0x70000
#define VM_FLAGS_RETURN_DATA_ADDR 0x100000
#define VM_FLAGS_RETURN_4K_DATA_ADDR 0x800000
#define VM_FLAGS_ALIAS_MASK 0xFF000000
#define VM_GET_FLAGS_ALIAS(flags,alias) (alias) = ((flags) & VM_FLAGS_ALIAS_MASK) >> 24

#define VM_SET_FLAGS_ALIAS(flags,alias) (flags) = (((flags) & ~VM_FLAGS_ALIAS_MASK) | (((alias) & ~VM_FLAGS_ALIAS_MASK) << 24))




#define VM_FLAGS_USER_ALLOCATE (VM_FLAGS_FIXED | VM_FLAGS_ANYWHERE | VM_FLAGS_PURGABLE | VM_FLAGS_4GB_CHUNK | VM_FLAGS_RANDOM_ADDR | VM_FLAGS_NO_CACHE | VM_FLAGS_PERMANENT | VM_FLAGS_OVERWRITE | VM_FLAGS_SUPERPAGE_MASK | VM_FLAGS_ALIAS_MASK)
# 302 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_statistics.h" 3 4
#define VM_FLAGS_USER_MAP (VM_FLAGS_USER_ALLOCATE | VM_FLAGS_RETURN_4K_DATA_ADDR | VM_FLAGS_RETURN_DATA_ADDR)


#define VM_FLAGS_USER_REMAP (VM_FLAGS_FIXED | VM_FLAGS_ANYWHERE | VM_FLAGS_RANDOM_ADDR | VM_FLAGS_OVERWRITE| VM_FLAGS_RETURN_DATA_ADDR | VM_FLAGS_RESILIENT_CODESIGN | VM_FLAGS_RESILIENT_MEDIA)







#define VM_FLAGS_SUPERPAGE_SHIFT 16
#define SUPERPAGE_NONE 0
#define SUPERPAGE_SIZE_ANY 1
#define VM_FLAGS_SUPERPAGE_NONE (SUPERPAGE_NONE << VM_FLAGS_SUPERPAGE_SHIFT)
#define VM_FLAGS_SUPERPAGE_SIZE_ANY (SUPERPAGE_SIZE_ANY << VM_FLAGS_SUPERPAGE_SHIFT)
#define SUPERPAGE_SIZE_2MB 2
#define VM_FLAGS_SUPERPAGE_SIZE_2MB (SUPERPAGE_SIZE_2MB<<VM_FLAGS_SUPERPAGE_SHIFT)




#define GUARD_TYPE_VIRT_MEMORY 0x5


enum virtual_memory_guard_exception_codes {
 kGUARD_EXC_DEALLOC_GAP = 1u << 0
};



#define __VM_LEDGER_ACCOUNTING_POSTMARK 2019032600


#define VM_LEDGER_TAG_NONE 0x00000000
#define VM_LEDGER_TAG_DEFAULT 0x00000001
#define VM_LEDGER_TAG_NETWORK 0x00000002
#define VM_LEDGER_TAG_MEDIA 0x00000003
#define VM_LEDGER_TAG_GRAPHICS 0x00000004
#define VM_LEDGER_TAG_NEURAL 0x00000005
#define VM_LEDGER_TAG_MAX 0x00000005

#define VM_LEDGER_FLAG_NO_FOOTPRINT (1 << 0)
#define VM_LEDGER_FLAG_NO_FOOTPRINT_FOR_DEBUG (1 << 1)
#define VM_LEDGER_FLAGS (VM_LEDGER_FLAG_NO_FOOTPRINT | VM_LEDGER_FLAG_NO_FOOTPRINT_FOR_DEBUG)


#define VM_MEMORY_MALLOC 1
#define VM_MEMORY_MALLOC_SMALL 2
#define VM_MEMORY_MALLOC_LARGE 3
#define VM_MEMORY_MALLOC_HUGE 4
#define VM_MEMORY_SBRK 5
#define VM_MEMORY_REALLOC 6
#define VM_MEMORY_MALLOC_TINY 7
#define VM_MEMORY_MALLOC_LARGE_REUSABLE 8
#define VM_MEMORY_MALLOC_LARGE_REUSED 9

#define VM_MEMORY_ANALYSIS_TOOL 10

#define VM_MEMORY_MALLOC_NANO 11
#define VM_MEMORY_MALLOC_MEDIUM 12
#define VM_MEMORY_MALLOC_PGUARD 13
#define VM_MEMORY_MALLOC_PROB_GUARD 13

#define VM_MEMORY_MACH_MSG 20
#define VM_MEMORY_IOKIT 21
#define VM_MEMORY_STACK 30
#define VM_MEMORY_GUARD 31
#define VM_MEMORY_SHARED_PMAP 32

#define VM_MEMORY_DYLIB 33
#define VM_MEMORY_OBJC_DISPATCHERS 34


#define VM_MEMORY_UNSHARED_PMAP 35




#define VM_MEMORY_APPKIT 40
#define VM_MEMORY_FOUNDATION 41
#define VM_MEMORY_COREGRAPHICS 42
#define VM_MEMORY_CORESERVICES 43
#define VM_MEMORY_CARBON VM_MEMORY_CORESERVICES
#define VM_MEMORY_JAVA 44
#define VM_MEMORY_COREDATA 45
#define VM_MEMORY_COREDATA_OBJECTIDS 46
#define VM_MEMORY_ATS 50
#define VM_MEMORY_LAYERKIT 51
#define VM_MEMORY_CGIMAGE 52
#define VM_MEMORY_TCMALLOC 53


#define VM_MEMORY_COREGRAPHICS_DATA 54


#define VM_MEMORY_COREGRAPHICS_SHARED 55


#define VM_MEMORY_COREGRAPHICS_FRAMEBUFFERS 56


#define VM_MEMORY_COREGRAPHICS_BACKINGSTORES 57


#define VM_MEMORY_COREGRAPHICS_XALLOC 58


#define VM_MEMORY_COREGRAPHICS_MISC VM_MEMORY_COREGRAPHICS


#define VM_MEMORY_DYLD 60

#define VM_MEMORY_DYLD_MALLOC 61


#define VM_MEMORY_SQLITE 62


#define VM_MEMORY_JAVASCRIPT_CORE 63
#define VM_MEMORY_WEBASSEMBLY VM_MEMORY_JAVASCRIPT_CORE

#define VM_MEMORY_JAVASCRIPT_JIT_EXECUTABLE_ALLOCATOR 64
#define VM_MEMORY_JAVASCRIPT_JIT_REGISTER_FILE 65


#define VM_MEMORY_GLSL 66


#define VM_MEMORY_OPENCL 67


#define VM_MEMORY_COREIMAGE 68


#define VM_MEMORY_WEBCORE_PURGEABLE_BUFFERS 69


#define VM_MEMORY_IMAGEIO 70


#define VM_MEMORY_COREPROFILE 71


#define VM_MEMORY_ASSETSD 72


#define VM_MEMORY_OS_ALLOC_ONCE 73


#define VM_MEMORY_LIBDISPATCH 74


#define VM_MEMORY_ACCELERATE 75


#define VM_MEMORY_COREUI 76


#define VM_MEMORY_COREUIFILE 77


#define VM_MEMORY_GENEALOGY 78


#define VM_MEMORY_RAWCAMERA 79


#define VM_MEMORY_CORPSEINFO 80


#define VM_MEMORY_ASL 81


#define VM_MEMORY_SWIFT_RUNTIME 82


#define VM_MEMORY_SWIFT_METADATA 83


#define VM_MEMORY_DHMM 84



#define VM_MEMORY_SCENEKIT 86


#define VM_MEMORY_SKYWALK 87

#define VM_MEMORY_IOSURFACE 88

#define VM_MEMORY_LIBNETWORK 89

#define VM_MEMORY_AUDIO 90

#define VM_MEMORY_VIDEOBITSTREAM 91


#define VM_MEMORY_CM_XPC 92

#define VM_MEMORY_CM_RPC 93

#define VM_MEMORY_CM_MEMORYPOOL 94

#define VM_MEMORY_CM_READCACHE 95

#define VM_MEMORY_CM_CRABS 96


#define VM_MEMORY_QUICKLOOK_THUMBNAILS 97


#define VM_MEMORY_ACCOUNTS 98


#define VM_MEMORY_SANITIZER 99


#define VM_MEMORY_IOACCELERATOR 100


#define VM_MEMORY_CM_REGWARP 101


#define VM_MEMORY_EAR_DECODER 102


#define VM_MEMORY_COREUI_CACHED_IMAGE_DATA 103


#define VM_MEMORY_COLORSYNC 104


#define VM_MEMORY_ROSETTA 230
#define VM_MEMORY_ROSETTA_THREAD_CONTEXT 231
#define VM_MEMORY_ROSETTA_INDIRECT_BRANCH_MAP 232
#define VM_MEMORY_ROSETTA_RETURN_STACK 233
#define VM_MEMORY_ROSETTA_EXECUTABLE_HEAP 234
#define VM_MEMORY_ROSETTA_USER_LDT 235
#define VM_MEMORY_ROSETTA_ARENA 236
#define VM_MEMORY_ROSETTA_10 239


#define VM_MEMORY_APPLICATION_SPECIFIC_1 240
#define VM_MEMORY_APPLICATION_SPECIFIC_16 255

#define VM_MAKE_TAG(tag) ((tag) << 24)
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_info.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine.h" 1 3 4
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine.h" 3 4
#define _MACH_MACHINE_H_ 







typedef integer_t cpu_type_t;
typedef integer_t cpu_subtype_t;
typedef integer_t cpu_threadtype_t;

#define CPU_STATE_MAX 4

#define CPU_STATE_USER 0
#define CPU_STATE_SYSTEM 1
#define CPU_STATE_IDLE 2
#define CPU_STATE_NICE 3






#define CPU_ARCH_MASK 0xff000000
#define CPU_ARCH_ABI64 0x01000000
#define CPU_ARCH_ABI64_32 0x02000000





#define CPU_TYPE_ANY ((cpu_type_t) -1)

#define CPU_TYPE_VAX ((cpu_type_t) 1)




#define CPU_TYPE_MC680x0 ((cpu_type_t) 6)
#define CPU_TYPE_X86 ((cpu_type_t) 7)
#define CPU_TYPE_I386 CPU_TYPE_X86
#define CPU_TYPE_X86_64 (CPU_TYPE_X86 | CPU_ARCH_ABI64)



#define CPU_TYPE_MC98000 ((cpu_type_t) 10)
#define CPU_TYPE_HPPA ((cpu_type_t) 11)
#define CPU_TYPE_ARM ((cpu_type_t) 12)
#define CPU_TYPE_ARM64 (CPU_TYPE_ARM | CPU_ARCH_ABI64)
#define CPU_TYPE_ARM64_32 (CPU_TYPE_ARM | CPU_ARCH_ABI64_32)
#define CPU_TYPE_MC88000 ((cpu_type_t) 13)
#define CPU_TYPE_SPARC ((cpu_type_t) 14)
#define CPU_TYPE_I860 ((cpu_type_t) 15)


#define CPU_TYPE_POWERPC ((cpu_type_t) 18)
#define CPU_TYPE_POWERPC64 (CPU_TYPE_POWERPC | CPU_ARCH_ABI64)
# 134 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine.h" 3 4
#define CPU_SUBTYPE_MASK 0xff000000
#define CPU_SUBTYPE_LIB64 0x80000000
#define CPU_SUBTYPE_PTRAUTH_ABI 0x80000000






#define CPU_SUBTYPE_ANY ((cpu_subtype_t) -1)
# 156 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine.h" 3 4
#define CPU_SUBTYPE_MULTIPLE ((cpu_subtype_t) -1)
#define CPU_SUBTYPE_LITTLE_ENDIAN ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_BIG_ENDIAN ((cpu_subtype_t) 1)





#define CPU_THREADTYPE_NONE ((cpu_threadtype_t) 0)






#define CPU_SUBTYPE_VAX_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_VAX780 ((cpu_subtype_t) 1)
#define CPU_SUBTYPE_VAX785 ((cpu_subtype_t) 2)
#define CPU_SUBTYPE_VAX750 ((cpu_subtype_t) 3)
#define CPU_SUBTYPE_VAX730 ((cpu_subtype_t) 4)
#define CPU_SUBTYPE_UVAXI ((cpu_subtype_t) 5)
#define CPU_SUBTYPE_UVAXII ((cpu_subtype_t) 6)
#define CPU_SUBTYPE_VAX8200 ((cpu_subtype_t) 7)
#define CPU_SUBTYPE_VAX8500 ((cpu_subtype_t) 8)
#define CPU_SUBTYPE_VAX8600 ((cpu_subtype_t) 9)
#define CPU_SUBTYPE_VAX8650 ((cpu_subtype_t) 10)
#define CPU_SUBTYPE_VAX8800 ((cpu_subtype_t) 11)
#define CPU_SUBTYPE_UVAXIII ((cpu_subtype_t) 12)
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine.h" 3 4
#define CPU_SUBTYPE_MC680x0_ALL ((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MC68030 ((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MC68040 ((cpu_subtype_t) 2)
#define CPU_SUBTYPE_MC68030_ONLY ((cpu_subtype_t) 3)





#define CPU_SUBTYPE_INTEL(f,m) ((cpu_subtype_t) (f) + ((m) << 4))

#define CPU_SUBTYPE_I386_ALL CPU_SUBTYPE_INTEL(3, 0)
#define CPU_SUBTYPE_386 CPU_SUBTYPE_INTEL(3, 0)
#define CPU_SUBTYPE_486 CPU_SUBTYPE_INTEL(4, 0)
#define CPU_SUBTYPE_486SX CPU_SUBTYPE_INTEL(4, 8)
#define CPU_SUBTYPE_586 CPU_SUBTYPE_INTEL(5, 0)
#define CPU_SUBTYPE_PENT CPU_SUBTYPE_INTEL(5, 0)
#define CPU_SUBTYPE_PENTPRO CPU_SUBTYPE_INTEL(6, 1)
#define CPU_SUBTYPE_PENTII_M3 CPU_SUBTYPE_INTEL(6, 3)
#define CPU_SUBTYPE_PENTII_M5 CPU_SUBTYPE_INTEL(6, 5)
#define CPU_SUBTYPE_CELERON CPU_SUBTYPE_INTEL(7, 6)
#define CPU_SUBTYPE_CELERON_MOBILE CPU_SUBTYPE_INTEL(7, 7)
#define CPU_SUBTYPE_PENTIUM_3 CPU_SUBTYPE_INTEL(8, 0)
#define CPU_SUBTYPE_PENTIUM_3_M CPU_SUBTYPE_INTEL(8, 1)
#define CPU_SUBTYPE_PENTIUM_3_XEON CPU_SUBTYPE_INTEL(8, 2)
#define CPU_SUBTYPE_PENTIUM_M CPU_SUBTYPE_INTEL(9, 0)
#define CPU_SUBTYPE_PENTIUM_4 CPU_SUBTYPE_INTEL(10, 0)
#define CPU_SUBTYPE_PENTIUM_4_M CPU_SUBTYPE_INTEL(10, 1)
#define CPU_SUBTYPE_ITANIUM CPU_SUBTYPE_INTEL(11, 0)
#define CPU_SUBTYPE_ITANIUM_2 CPU_SUBTYPE_INTEL(11, 1)
#define CPU_SUBTYPE_XEON CPU_SUBTYPE_INTEL(12, 0)
#define CPU_SUBTYPE_XEON_MP CPU_SUBTYPE_INTEL(12, 1)

#define CPU_SUBTYPE_INTEL_FAMILY(x) ((x) & 15)
#define CPU_SUBTYPE_INTEL_FAMILY_MAX 15

#define CPU_SUBTYPE_INTEL_MODEL(x) ((x) >> 4)
#define CPU_SUBTYPE_INTEL_MODEL_ALL 0





#define CPU_SUBTYPE_X86_ALL ((cpu_subtype_t)3)
#define CPU_SUBTYPE_X86_64_ALL ((cpu_subtype_t)3)
#define CPU_SUBTYPE_X86_ARCH1 ((cpu_subtype_t)4)
#define CPU_SUBTYPE_X86_64_H ((cpu_subtype_t)8)


#define CPU_THREADTYPE_INTEL_HTT ((cpu_threadtype_t) 1)





#define CPU_SUBTYPE_MIPS_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_MIPS_R2300 ((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MIPS_R2600 ((cpu_subtype_t) 2)
#define CPU_SUBTYPE_MIPS_R2800 ((cpu_subtype_t) 3)
#define CPU_SUBTYPE_MIPS_R2000a ((cpu_subtype_t) 4)
#define CPU_SUBTYPE_MIPS_R2000 ((cpu_subtype_t) 5)
#define CPU_SUBTYPE_MIPS_R3000a ((cpu_subtype_t) 6)
#define CPU_SUBTYPE_MIPS_R3000 ((cpu_subtype_t) 7)




#define CPU_SUBTYPE_MC98000_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_MC98601 ((cpu_subtype_t) 1)






#define CPU_SUBTYPE_HPPA_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_HPPA_7100 ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_HPPA_7100LC ((cpu_subtype_t) 1)




#define CPU_SUBTYPE_MC88000_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_MC88100 ((cpu_subtype_t) 1)
#define CPU_SUBTYPE_MC88110 ((cpu_subtype_t) 2)




#define CPU_SUBTYPE_SPARC_ALL ((cpu_subtype_t) 0)




#define CPU_SUBTYPE_I860_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_I860_860 ((cpu_subtype_t) 1)




#define CPU_SUBTYPE_POWERPC_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_POWERPC_601 ((cpu_subtype_t) 1)
#define CPU_SUBTYPE_POWERPC_602 ((cpu_subtype_t) 2)
#define CPU_SUBTYPE_POWERPC_603 ((cpu_subtype_t) 3)
#define CPU_SUBTYPE_POWERPC_603e ((cpu_subtype_t) 4)
#define CPU_SUBTYPE_POWERPC_603ev ((cpu_subtype_t) 5)
#define CPU_SUBTYPE_POWERPC_604 ((cpu_subtype_t) 6)
#define CPU_SUBTYPE_POWERPC_604e ((cpu_subtype_t) 7)
#define CPU_SUBTYPE_POWERPC_620 ((cpu_subtype_t) 8)
#define CPU_SUBTYPE_POWERPC_750 ((cpu_subtype_t) 9)
#define CPU_SUBTYPE_POWERPC_7400 ((cpu_subtype_t) 10)
#define CPU_SUBTYPE_POWERPC_7450 ((cpu_subtype_t) 11)
#define CPU_SUBTYPE_POWERPC_970 ((cpu_subtype_t) 100)




#define CPU_SUBTYPE_ARM_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_ARM_V4T ((cpu_subtype_t) 5)
#define CPU_SUBTYPE_ARM_V6 ((cpu_subtype_t) 6)
#define CPU_SUBTYPE_ARM_V5TEJ ((cpu_subtype_t) 7)
#define CPU_SUBTYPE_ARM_XSCALE ((cpu_subtype_t) 8)
#define CPU_SUBTYPE_ARM_V7 ((cpu_subtype_t) 9)
#define CPU_SUBTYPE_ARM_V7F ((cpu_subtype_t) 10)
#define CPU_SUBTYPE_ARM_V7S ((cpu_subtype_t) 11)
#define CPU_SUBTYPE_ARM_V7K ((cpu_subtype_t) 12)
#define CPU_SUBTYPE_ARM_V8 ((cpu_subtype_t) 13)
#define CPU_SUBTYPE_ARM_V6M ((cpu_subtype_t) 14)
#define CPU_SUBTYPE_ARM_V7M ((cpu_subtype_t) 15)
#define CPU_SUBTYPE_ARM_V7EM ((cpu_subtype_t) 16)
#define CPU_SUBTYPE_ARM_V8M ((cpu_subtype_t) 17)




#define CPU_SUBTYPE_ARM64_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_ARM64_V8 ((cpu_subtype_t) 1)
#define CPU_SUBTYPE_ARM64E ((cpu_subtype_t) 2)


#define CPU_SUBTYPE_ARM64_PTR_AUTH_MASK 0x0f000000
#define CPU_SUBTYPE_ARM64_PTR_AUTH_VERSION(x) (((x) & CPU_SUBTYPE_ARM64_PTR_AUTH_MASK) >> 24)




#define CPU_SUBTYPE_ARM64_32_ALL ((cpu_subtype_t) 0)
#define CPU_SUBTYPE_ARM64_32_V8 ((cpu_subtype_t) 1)
# 364 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine.h" 3 4
#define CPUFAMILY_UNKNOWN 0
#define CPUFAMILY_POWERPC_G3 0xcee41549
#define CPUFAMILY_POWERPC_G4 0x77c184ae
#define CPUFAMILY_POWERPC_G5 0xed76d8aa
#define CPUFAMILY_INTEL_6_13 0xaa33392b
#define CPUFAMILY_INTEL_PENRYN 0x78ea4fbc
#define CPUFAMILY_INTEL_NEHALEM 0x6b5a4cd2
#define CPUFAMILY_INTEL_WESTMERE 0x573b5eec
#define CPUFAMILY_INTEL_SANDYBRIDGE 0x5490b78c
#define CPUFAMILY_INTEL_IVYBRIDGE 0x1f65e835
#define CPUFAMILY_INTEL_HASWELL 0x10b282dc
#define CPUFAMILY_INTEL_BROADWELL 0x582ed09c
#define CPUFAMILY_INTEL_SKYLAKE 0x37fc219f
#define CPUFAMILY_INTEL_KABYLAKE 0x0f817246
#define CPUFAMILY_INTEL_ICELAKE 0x38435547
#define CPUFAMILY_INTEL_COMETLAKE 0x1cf8a03e
#define CPUFAMILY_ARM_9 0xe73283ae
#define CPUFAMILY_ARM_11 0x8ff620d8
#define CPUFAMILY_ARM_XSCALE 0x53b005f5
#define CPUFAMILY_ARM_12 0xbd1b0ae9
#define CPUFAMILY_ARM_13 0x0cc90e64
#define CPUFAMILY_ARM_14 0x96077ef1
#define CPUFAMILY_ARM_15 0xa8511bca
#define CPUFAMILY_ARM_SWIFT 0x1e2d6381
#define CPUFAMILY_ARM_CYCLONE 0x37a09642
#define CPUFAMILY_ARM_TYPHOON 0x2c91a47e
#define CPUFAMILY_ARM_TWISTER 0x92fb37c8
#define CPUFAMILY_ARM_HURRICANE 0x67ceee93
#define CPUFAMILY_ARM_MONSOON_MISTRAL 0xe81e7ef6
#define CPUFAMILY_ARM_VORTEX_TEMPEST 0x07d34b9f
#define CPUFAMILY_ARM_LIGHTNING_THUNDER 0x462504d2
#define CPUFAMILY_ARM_FIRESTORM_ICESTORM 0x1b588bb3

#define CPUSUBFAMILY_UNKNOWN 0
#define CPUSUBFAMILY_ARM_HP 1
#define CPUSUBFAMILY_ARM_HG 2
#define CPUSUBFAMILY_ARM_M 3
#define CPUSUBFAMILY_ARM_HS 4
#define CPUSUBFAMILY_ARM_HC_HD 5


#define CPUFAMILY_INTEL_6_23 CPUFAMILY_INTEL_PENRYN
#define CPUFAMILY_INTEL_6_26 CPUFAMILY_INTEL_NEHALEM
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_info.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/time_value.h" 1 3 4
# 58 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/time_value.h" 3 4
#define _MACH_TIME_VALUE_H_ 







struct time_value {
 integer_t seconds;
 integer_t microseconds;
};

typedef struct time_value time_value_t;





#define TIME_MICROS_MAX (1000000)

#define time_value_add_usec(val,micros) { if (((val)->microseconds += (micros)) >= TIME_MICROS_MAX) { (val)->microseconds -= TIME_MICROS_MAX; (val)->seconds++; } }







#define time_value_add(result,addend) { (result)->microseconds += (addend)->microseconds; (result)->seconds += (addend)->seconds; if ((result)->microseconds >= TIME_MICROS_MAX) { (result)->microseconds -= TIME_MICROS_MAX; (result)->seconds++; } }
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_info.h" 2 3 4






typedef integer_t *host_info_t;
typedef integer_t *host_info64_t;

#define HOST_INFO_MAX (1024)
typedef integer_t host_info_data_t[(1024)];

#define KERNEL_VERSION_MAX (512)
typedef char kernel_version_t[(512)];

#define KERNEL_BOOT_INFO_MAX (4096)
typedef char kernel_boot_info_t[(4096)];





typedef integer_t host_flavor_t;
#define HOST_BASIC_INFO 1
#define HOST_SCHED_INFO 3
#define HOST_RESOURCE_SIZES 4
#define HOST_PRIORITY_INFO 5
#define HOST_SEMAPHORE_TRAPS 7
#define HOST_MACH_MSG_TRAP 8
#define HOST_VM_PURGABLE 9
#define HOST_DEBUG_INFO_INTERNAL 10
#define HOST_CAN_HAS_DEBUGGER 11
#define HOST_PREFERRED_USER_ARCH 12


struct host_can_has_debugger_info {
 boolean_t can_has_debugger;
};
typedef struct host_can_has_debugger_info host_can_has_debugger_info_data_t;
typedef struct host_can_has_debugger_info *host_can_has_debugger_info_t;
#define HOST_CAN_HAS_DEBUGGER_COUNT ((mach_msg_type_number_t) (sizeof(host_can_has_debugger_info_data_t)/sizeof(integer_t)))


#pragma pack(push, 4)

struct host_basic_info {
 integer_t max_cpus;
 integer_t avail_cpus;
 natural_t memory_size;
 cpu_type_t cpu_type;
 cpu_subtype_t cpu_subtype;
 cpu_threadtype_t cpu_threadtype;
 integer_t physical_cpu;
 integer_t physical_cpu_max;
 integer_t logical_cpu;
 integer_t logical_cpu_max;
 uint64_t max_mem;
};

#pragma pack(pop)

typedef struct host_basic_info host_basic_info_data_t;
typedef struct host_basic_info *host_basic_info_t;
#define HOST_BASIC_INFO_COUNT ((mach_msg_type_number_t) (sizeof(host_basic_info_data_t)/sizeof(integer_t)))


struct host_sched_info {
 integer_t min_timeout;
 integer_t min_quantum;
};

typedef struct host_sched_info host_sched_info_data_t;
typedef struct host_sched_info *host_sched_info_t;
#define HOST_SCHED_INFO_COUNT ((mach_msg_type_number_t) (sizeof(host_sched_info_data_t)/sizeof(integer_t)))


struct kernel_resource_sizes {
 natural_t task;
 natural_t thread;
 natural_t port;
 natural_t memory_region;
 natural_t memory_object;
};

typedef struct kernel_resource_sizes kernel_resource_sizes_data_t;
typedef struct kernel_resource_sizes *kernel_resource_sizes_t;
#define HOST_RESOURCE_SIZES_COUNT ((mach_msg_type_number_t) (sizeof(kernel_resource_sizes_data_t)/sizeof(integer_t)))


struct host_priority_info {
 integer_t kernel_priority;
 integer_t system_priority;
 integer_t server_priority;
 integer_t user_priority;
 integer_t depress_priority;
 integer_t idle_priority;
 integer_t minimum_priority;
 integer_t maximum_priority;
};

typedef struct host_priority_info host_priority_info_data_t;
typedef struct host_priority_info *host_priority_info_t;
#define HOST_PRIORITY_INFO_COUNT ((mach_msg_type_number_t) (sizeof(host_priority_info_data_t)/sizeof(integer_t)))



#define HOST_LOAD_INFO 1
#define HOST_VM_INFO 2
#define HOST_CPU_LOAD_INFO 3


#define HOST_VM_INFO64 4
#define HOST_EXTMOD_INFO64 5
#define HOST_EXPIRED_TASK_INFO 6


struct host_load_info {
 integer_t avenrun[3];
 integer_t mach_factor[3];
};

typedef struct host_load_info host_load_info_data_t;
typedef struct host_load_info *host_load_info_t;
#define HOST_LOAD_INFO_COUNT ((mach_msg_type_number_t) (sizeof(host_load_info_data_t)/sizeof(integer_t)))


typedef struct vm_purgeable_info host_purgable_info_data_t;
typedef struct vm_purgeable_info *host_purgable_info_t;
#define HOST_VM_PURGABLE_COUNT ((mach_msg_type_number_t) (sizeof(host_purgable_info_data_t)/sizeof(integer_t)))




#define HOST_VM_INFO64_COUNT ((mach_msg_type_number_t) (sizeof(vm_statistics64_data_t)/sizeof(integer_t)))



#define HOST_VM_INFO64_LATEST_COUNT HOST_VM_INFO64_COUNT
#define HOST_VM_INFO64_REV1_COUNT HOST_VM_INFO64_LATEST_COUNT

#define HOST_VM_INFO64_REV0_COUNT ((mach_msg_type_number_t) (HOST_VM_INFO64_REV1_COUNT - 14))





#define HOST_EXTMOD_INFO64_COUNT ((mach_msg_type_number_t) (sizeof(vm_extmod_statistics_data_t)/sizeof(integer_t)))



#define HOST_EXTMOD_INFO64_LATEST_COUNT HOST_EXTMOD_INFO64_COUNT


#define HOST_VM_INFO_COUNT ((mach_msg_type_number_t) (sizeof(vm_statistics_data_t)/sizeof(integer_t)))



#define HOST_VM_INFO_LATEST_COUNT HOST_VM_INFO_COUNT
#define HOST_VM_INFO_REV2_COUNT HOST_VM_INFO_LATEST_COUNT

#define HOST_VM_INFO_REV1_COUNT ((mach_msg_type_number_t) (HOST_VM_INFO_REV2_COUNT - 1))


#define HOST_VM_INFO_REV0_COUNT ((mach_msg_type_number_t) (HOST_VM_INFO_REV1_COUNT - 2))



struct host_cpu_load_info {
 natural_t cpu_ticks[4];
};

typedef struct host_cpu_load_info host_cpu_load_info_data_t;
typedef struct host_cpu_load_info *host_cpu_load_info_t;
#define HOST_CPU_LOAD_INFO_COUNT ((mach_msg_type_number_t) (sizeof (host_cpu_load_info_data_t) / sizeof (integer_t)))


struct host_preferred_user_arch {
 cpu_type_t cpu_type;
 cpu_subtype_t cpu_subtype;
};

typedef struct host_preferred_user_arch host_preferred_user_arch_data_t;
typedef struct host_preferred_user_arch *host_preferred_user_arch_t;
#define HOST_PREFERRED_USER_ARCH_COUNT ((mach_msg_type_number_t) (sizeof(host_preferred_user_arch_data_t)/sizeof(integer_t)))
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_notify.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_notify.h" 3 4
#define _MACH_HOST_NOTIFY_H_ 

#define HOST_NOTIFY_CALENDAR_CHANGE 0
#define HOST_NOTIFY_CALENDAR_SET 1
#define HOST_NOTIFY_TYPE_MAX 1

#define HOST_CALENDAR_CHANGED_REPLYID 950
#define HOST_CALENDAR_SET_REPLYID 951
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_special_ports.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_special_ports.h" 3 4
#define _MACH_HOST_SPECIAL_PORTS_H_ 




#define HOST_SECURITY_PORT 0

#define HOST_MIN_SPECIAL_PORT HOST_SECURITY_PORT




#define HOST_PORT 1
#define HOST_PRIV_PORT 2
#define HOST_IO_MASTER_PORT 3
#define HOST_MAX_SPECIAL_KERNEL_PORT 7

#define HOST_LAST_SPECIAL_KERNEL_PORT HOST_IO_MASTER_PORT




#define HOST_DYNAMIC_PAGER_PORT (1 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_AUDIT_CONTROL_PORT (2 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_USER_NOTIFICATION_PORT (3 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_AUTOMOUNTD_PORT (4 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_LOCKD_PORT (5 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_KTRACE_BACKGROUND_PORT (6 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_SEATBELT_PORT (7 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_KEXTD_PORT (8 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_LAUNCHCTL_PORT (9 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_UNFREED_PORT (10 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_AMFID_PORT (11 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_GSSD_PORT (12 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_TELEMETRY_PORT (13 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_ATM_NOTIFICATION_PORT (14 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_COALITION_PORT (15 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_SYSDIAGNOSE_PORT (16 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_XPC_EXCEPTION_PORT (17 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_CONTAINERD_PORT (18 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_NODE_PORT (19 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_RESOURCE_NOTIFY_PORT (20 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_CLOSURED_PORT (21 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_SYSPOLICYD_PORT (22 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_FILECOORDINATIOND_PORT (23 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_FAIRPLAYD_PORT (24 + HOST_MAX_SPECIAL_KERNEL_PORT)
#define HOST_IOCOMPRESSIONSTATS_PORT (25 + HOST_MAX_SPECIAL_KERNEL_PORT)

#define HOST_MAX_SPECIAL_PORT HOST_IOCOMPRESSIONSTATS_PORT



#define HOST_CHUD_PORT HOST_LAUNCHCTL_PORT




#define HOST_LOCAL_NODE -1
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/host_special_ports.h" 3 4
#define host_get_host_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_PORT, (port)))


#define host_set_host_port(host,port) (KERN_INVALID_ARGUMENT)

#define host_get_host_priv_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_PRIV_PORT, (port)))


#define host_set_host_priv_port(host,port) (KERN_INVALID_ARGUMENT)

#define host_get_io_master_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_IO_MASTER_PORT, (port)))


#define host_set_io_master_port(host,port) (KERN_INVALID_ARGUMENT)




#define host_get_dynamic_pager_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_DYNAMIC_PAGER_PORT, (port)))


#define host_set_dynamic_pager_port(host,port) (host_set_special_port((host), HOST_DYNAMIC_PAGER_PORT, (port)))


#define host_get_audit_control_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_AUDIT_CONTROL_PORT, (port)))


#define host_set_audit_control_port(host,port) (host_set_special_port((host), HOST_AUDIT_CONTROL_PORT, (port)))


#define host_get_user_notification_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_USER_NOTIFICATION_PORT, (port)))


#define host_set_user_notification_port(host,port) (host_set_special_port((host), HOST_USER_NOTIFICATION_PORT, (port)))


#define host_get_automountd_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_AUTOMOUNTD_PORT, (port)))


#define host_set_automountd_port(host,port) (host_set_special_port((host), HOST_AUTOMOUNTD_PORT, (port)))


#define host_get_lockd_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_LOCKD_PORT, (port)))


#define host_set_lockd_port(host,port) (host_set_special_port((host), HOST_LOCKD_PORT, (port)))


#define host_get_ktrace_background_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_KTRACE_BACKGROUND_PORT, (port)))


#define host_set_ktrace_background_port(host,port) (host_set_special_port((host), HOST_KTRACE_BACKGROUND_PORT, (port)))


#define host_get_kextd_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_KEXTD_PORT, (port)))


#define host_set_kextd_port(host,port) (host_set_special_port((host), HOST_KEXTD_PORT, (port)))


#define host_get_launchctl_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_LAUNCHCTL_PORT, (port)))


#define host_set_launchctl_port(host,port) (host_set_special_port((host), HOST_LAUNCHCTL_PORT, (port)))


#define host_get_chud_port(host,port) host_get_launchctl_port(host, port)
#define host_set_chud_port(host,port) host_set_launchctl_port(host, port)

#define host_get_unfreed_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_UNFREED_PORT, (port)))


#define host_set_unfreed_port(host,port) (host_set_special_port((host), HOST_UNFREED_PORT, (port)))


#define host_get_amfid_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_AMFID_PORT, (port)))


#define host_set_amfid_port(host,port) (host_set_special_port((host), HOST_AMFID_PORT, (port)))


#define host_get_gssd_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_GSSD_PORT, (port)))


#define host_set_gssd_port(host,port) (host_set_special_port((host), HOST_GSSD_PORT, (port)))


#define host_get_telemetry_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_TELEMETRY_PORT, (port)))


#define host_set_telemetry_port(host,port) (host_set_special_port((host), HOST_TELEMETRY_PORT, (port)))


#define host_get_atm_notification_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_ATM_NOTIFICATION_PORT, (port)))


#define host_set_atm_notification_port(host,port) (host_set_special_port((host), HOST_ATM_NOTIFICATION_PORT, (port)))


#define host_get_coalition_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_COALITION_PORT, (port)))


#define host_set_coalition_port(host,port) (host_set_special_port((host), HOST_COALITION_PORT, (port)))


#define host_get_sysdiagnose_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_SYSDIAGNOSE_PORT, (port)))


#define host_set_sysdiagnose_port(host,port) (host_set_special_port((host), HOST_SYSDIAGNOSE_PORT, (port)))


#define host_get_container_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_CONTAINERD_PORT, (port)))


#define host_set_container_port(host,port) (host_set_special_port((host), HOST_CONTAINERD_PORT, (port)))


#define host_get_node_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_NODE_PORT, (port)))


#define host_set_node_port(host,port) (host_set_special_port((host), HOST_NODE_PORT, (port)))


#define host_get_closured_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_CLOSURED_PORT, (port)))


#define host_set_closured_port(host,port) (host_set_special_port((host), HOST_CLOSURED_PORT, (port)))


#define host_get_syspolicyd_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_SYSPOLICYD_PORT, (port)))


#define host_set_syspolicyd_port(host,port) (host_set_special_port((host), HOST_SYSPOLICYD_PORT, (port)))


#define host_get_filecoordinationd_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_FILECOORDINATIOND_PORT, (port)))


#define host_set_filecoordinationd_port(host,port) (host_set_special_port((host), HOST_FILECOORDINATIOND_PORT, (port)))


#define host_get_fairplayd_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_FAIRPLAYD_PORT, (port)))


#define host_set_fairplayd_port(host,port) (host_set_special_port((host), HOST_FAIRPLAYD_PORT, (port)))


#define host_get_iocompressionstats_port(host,port) (host_get_special_port((host), HOST_LOCAL_NODE, HOST_IOCOMPRESSIONSTATS_PORT, (port)))


#define host_set_iocompressionstats_port(host,port) (host_set_special_port((host), HOST_IOCOMPRESSIONSTATS_PORT, (port)))
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 3 4
#define _MACH_MEMORY_OBJECT_TYPES_H_ 
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_prot.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_prot.h" 3 4
#define _MACH_VM_PROT_H_ 







typedef int vm_prot_t;





#define VM_PROT_NONE ((vm_prot_t) 0x00)

#define VM_PROT_READ ((vm_prot_t) 0x01)
#define VM_PROT_WRITE ((vm_prot_t) 0x02)
#define VM_PROT_EXECUTE ((vm_prot_t) 0x04)





#define VM_PROT_DEFAULT (VM_PROT_READ|VM_PROT_WRITE)





#define VM_PROT_ALL (VM_PROT_READ|VM_PROT_WRITE|VM_PROT_EXECUTE)
# 106 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_prot.h" 3 4
#define VM_PROT_NO_CHANGE_LEGACY ((vm_prot_t) 0x08)
#define VM_PROT_NO_CHANGE ((vm_prot_t) 0x01000000)
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_prot.h" 3 4
#define VM_PROT_COPY ((vm_prot_t) 0x10)
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_prot.h" 3 4
#define VM_PROT_WANTS_COPY ((vm_prot_t) 0x10)







#define VM_PROT_IS_MASK ((vm_prot_t) 0x40)
# 150 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_prot.h" 3 4
#define VM_PROT_STRIP_READ ((vm_prot_t) 0x80)
#define VM_PROT_EXECUTE_ONLY (VM_PROT_EXECUTE|VM_PROT_STRIP_READ)
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_prot.h" 3 4
#define VM_PROT_ALLEXEC (VM_PROT_EXECUTE)
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_sync.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_sync.h" 3 4
#define _MACH_VM_SYNC_H_ 

typedef unsigned vm_sync_t;





#define VM_SYNC_ASYNCHRONOUS ((vm_sync_t) 0x01)
#define VM_SYNC_SYNCHRONOUS ((vm_sync_t) 0x02)
#define VM_SYNC_INVALIDATE ((vm_sync_t) 0x04)
#define VM_SYNC_KILLPAGES ((vm_sync_t) 0x08)
#define VM_SYNC_DEACTIVATE ((vm_sync_t) 0x10)
#define VM_SYNC_CONTIGUOUS ((vm_sync_t) 0x20)
#define VM_SYNC_REUSABLEPAGES ((vm_sync_t) 0x40)
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_types.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_types.h" 3 4
#define _MACH_VM_TYPES_H_ 







typedef vm_offset_t pointer_t ;
typedef vm_offset_t vm_address_t ;







typedef uint64_t addr64_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_types.h" 3 4
typedef uint32_t reg64_t;






typedef uint32_t ppnum_t;
#define PPNUM_MAX UINT32_MAX



typedef mach_port_t vm_map_t, vm_map_read_t, vm_map_inspect_t;


#define VM_MAP_NULL ((vm_map_t) 0)
#define VM_MAP_INSPECT_NULL ((vm_map_inspect_t) 0)
#define VM_MAP_READ_NULL ((vm_map_read_t) 0)





typedef uint64_t vm_object_offset_t;
typedef uint64_t vm_object_size_t;




typedef mach_port_t upl_t;
typedef mach_port_t vm_named_entry_t;


#define UPL_NULL ((upl_t) 0)
#define VM_NAMED_ENTRY_NULL ((vm_named_entry_t) 0)
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 2 3 4





#define VM_64_BIT_DATA_OBJECTS 

typedef unsigned long long memory_object_offset_t;
typedef unsigned long long memory_object_size_t;
typedef natural_t memory_object_cluster_size_t;
typedef natural_t * memory_object_fault_info_t;

typedef unsigned long long vm_object_id_t;







typedef mach_port_t memory_object_t;





typedef mach_port_t memory_object_control_t;


typedef memory_object_t *memory_object_array_t;




typedef mach_port_t memory_object_name_t;



typedef mach_port_t memory_object_default_t;



#define MEMORY_OBJECT_NULL ((memory_object_t) 0)
#define MEMORY_OBJECT_CONTROL_NULL ((memory_object_control_t) 0)
#define MEMORY_OBJECT_NAME_NULL ((memory_object_name_t) 0)
#define MEMORY_OBJECT_DEFAULT_NULL ((memory_object_default_t) 0)


typedef int memory_object_copy_strategy_t;

#define MEMORY_OBJECT_COPY_NONE 0

#define MEMORY_OBJECT_COPY_CALL 1

#define MEMORY_OBJECT_COPY_DELAY 2



#define MEMORY_OBJECT_COPY_TEMPORARY 3




#define MEMORY_OBJECT_COPY_SYMMETRIC 4
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 3 4
#define MEMORY_OBJECT_COPY_INVALID 5
# 162 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 3 4
typedef int memory_object_return_t;


#define MEMORY_OBJECT_RETURN_NONE 0

#define MEMORY_OBJECT_RETURN_DIRTY 1

#define MEMORY_OBJECT_RETURN_ALL 2

#define MEMORY_OBJECT_RETURN_ANYTHING 3






#define MEMORY_OBJECT_DATA_FLUSH 0x1
#define MEMORY_OBJECT_DATA_NO_CHANGE 0x2
#define MEMORY_OBJECT_DATA_PURGE 0x4
#define MEMORY_OBJECT_COPY_SYNC 0x8
#define MEMORY_OBJECT_DATA_SYNC 0x10
#define MEMORY_OBJECT_IO_SYNC 0x20
#define MEMORY_OBJECT_DATA_FLUSH_ALL 0x40





#define MEMORY_OBJECT_INFO_MAX (1024)
typedef int *memory_object_info_t;
typedef int memory_object_flavor_t;
typedef int memory_object_info_data_t[(1024)];


#define MEMORY_OBJECT_PERFORMANCE_INFO 11
#define MEMORY_OBJECT_ATTRIBUTE_INFO 14
#define MEMORY_OBJECT_BEHAVIOR_INFO 15


struct memory_object_perf_info {
 memory_object_cluster_size_t cluster_size;
 boolean_t may_cache;
};

struct memory_object_attr_info {
 memory_object_copy_strategy_t copy_strategy;
 memory_object_cluster_size_t cluster_size;
 boolean_t may_cache_object;
 boolean_t temporary;
};

struct memory_object_behave_info {
 memory_object_copy_strategy_t copy_strategy;
 boolean_t temporary;
 boolean_t invalidate;
 boolean_t silent_overwrite;
 boolean_t advisory_pageout;
};


typedef struct memory_object_behave_info *memory_object_behave_info_t;
typedef struct memory_object_behave_info memory_object_behave_info_data_t;

typedef struct memory_object_perf_info *memory_object_perf_info_t;
typedef struct memory_object_perf_info memory_object_perf_info_data_t;

typedef struct memory_object_attr_info *memory_object_attr_info_t;
typedef struct memory_object_attr_info memory_object_attr_info_data_t;

#define MEMORY_OBJECT_BEHAVE_INFO_COUNT ((mach_msg_type_number_t) (sizeof(memory_object_behave_info_data_t)/sizeof(int)))

#define MEMORY_OBJECT_PERF_INFO_COUNT ((mach_msg_type_number_t) (sizeof(memory_object_perf_info_data_t)/sizeof(int)))

#define MEMORY_OBJECT_ATTR_INFO_COUNT ((mach_msg_type_number_t) (sizeof(memory_object_attr_info_data_t)/sizeof(int)))


#define invalid_memory_object_flavor(f) (f != MEMORY_OBJECT_ATTRIBUTE_INFO && f != MEMORY_OBJECT_PERFORMANCE_INFO && f != OLD_MEMORY_OBJECT_BEHAVIOR_INFO && f != MEMORY_OBJECT_BEHAVIOR_INFO && f != OLD_MEMORY_OBJECT_ATTRIBUTE_INFO)
# 249 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 3 4
#define MEMORY_OBJECT_TERMINATE_IDLE 0x1
#define MEMORY_OBJECT_RESPECT_CACHE 0x2
#define MEMORY_OBJECT_RELEASE_NO_OP 0x4




#define MAP_MEM_NOOP 0
#define MAP_MEM_COPYBACK 1
#define MAP_MEM_IO 2
#define MAP_MEM_WTHRU 3
#define MAP_MEM_WCOMB 4

#define MAP_MEM_INNERWBACK 5
#define MAP_MEM_POSTED 6
#define MAP_MEM_RT 7
#define MAP_MEM_POSTED_REORDERED 8
#define MAP_MEM_POSTED_COMBINED_REORDERED 9

#define GET_MAP_MEM(flags) ((((unsigned int)(flags)) >> 24) & 0xFF)


#define SET_MAP_MEM(caching,flags) ((flags) = ((((unsigned int)(caching)) << 24) & 0xFF000000) | ((flags) & 0xFFFFFF));




#define MAP_MEM_LEDGER_TAGGED 0x002000
#define MAP_MEM_PURGABLE_KERNEL_ONLY 0x004000
#define MAP_MEM_GRAB_SECLUDED 0x008000
#define MAP_MEM_ONLY 0x010000
#define MAP_MEM_NAMED_CREATE 0x020000
#define MAP_MEM_PURGABLE 0x040000
#define MAP_MEM_NAMED_REUSE 0x080000
#define MAP_MEM_USE_DATA_ADDR 0x100000
#define MAP_MEM_VM_COPY 0x200000
#define MAP_MEM_VM_SHARE 0x400000
#define MAP_MEM_4K_DATA_ADDR 0x800000

#define MAP_MEM_FLAGS_MASK 0x00FFFF00
#define MAP_MEM_FLAGS_USER ( MAP_MEM_PURGABLE_KERNEL_ONLY | MAP_MEM_GRAB_SECLUDED | MAP_MEM_ONLY | MAP_MEM_NAMED_CREATE | MAP_MEM_PURGABLE | MAP_MEM_NAMED_REUSE | MAP_MEM_USE_DATA_ADDR | MAP_MEM_VM_COPY | MAP_MEM_VM_SHARE | MAP_MEM_LEDGER_TAGGED | MAP_MEM_4K_DATA_ADDR)
# 301 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/memory_object_types.h" 3 4
#define MAP_MEM_FLAGS_ALL ( MAP_MEM_FLAGS_USER)
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/exception_types.h" 1 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/exception_types.h" 3 4
#define _MACH_EXCEPTION_TYPES_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/exception.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/exception.h" 3 4
#define _MACH_MACHINE_EXCEPTION_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/exception.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/exception.h" 3 4
#define _MACH_ARM_EXCEPTION_H_ 



#define EXC_TYPES_COUNT 14

#define EXC_MASK_MACHINE 0

#define EXCEPTION_CODE_MAX 2
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/exception.h" 3 4
#define EXC_ARM_UNDEFINED 1





#define EXC_ARM_FP_UNDEFINED 0
#define EXC_ARM_FP_IO 1
#define EXC_ARM_FP_DZ 2
#define EXC_ARM_FP_OF 3
#define EXC_ARM_FP_UF 4
#define EXC_ARM_FP_IX 5
#define EXC_ARM_FP_ID 6






#define EXC_ARM_DA_ALIGN 0x101
#define EXC_ARM_DA_DEBUG 0x102
#define EXC_ARM_SP_ALIGN 0x103
#define EXC_ARM_SWP 0x104
#define EXC_ARM_PAC_FAIL 0x105





#define EXC_ARM_BREAKPOINT 1
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/exception.h" 2 3 4
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/exception_types.h" 2 3 4





#define EXC_BAD_ACCESS 1



#define EXC_BAD_INSTRUCTION 2


#define EXC_ARITHMETIC 3


#define EXC_EMULATION 4



#define EXC_SOFTWARE 5




#define EXC_BREAKPOINT 6


#define EXC_SYSCALL 7

#define EXC_MACH_SYSCALL 8

#define EXC_RPC_ALERT 9

#define EXC_CRASH 10

#define EXC_RESOURCE 11


#define EXC_GUARD 12

#define EXC_CORPSE_NOTIFY 13

#define EXC_CORPSE_VARIANT_BIT 0x100






#define EXCEPTION_DEFAULT 1



#define EXCEPTION_STATE 2




#define EXCEPTION_STATE_IDENTITY 3




#define EXCEPTION_IDENTITY_PROTECTED 4




#define MACH_EXCEPTION_ERRORS 0x40000000


#define MACH_EXCEPTION_CODES 0x80000000


#define MACH_EXCEPTION_MASK (MACH_EXCEPTION_CODES | MACH_EXCEPTION_ERRORS)





#define EXC_MASK_BAD_ACCESS (1 << EXC_BAD_ACCESS)
#define EXC_MASK_BAD_INSTRUCTION (1 << EXC_BAD_INSTRUCTION)
#define EXC_MASK_ARITHMETIC (1 << EXC_ARITHMETIC)
#define EXC_MASK_EMULATION (1 << EXC_EMULATION)
#define EXC_MASK_SOFTWARE (1 << EXC_SOFTWARE)
#define EXC_MASK_BREAKPOINT (1 << EXC_BREAKPOINT)
#define EXC_MASK_SYSCALL (1 << EXC_SYSCALL)
#define EXC_MASK_MACH_SYSCALL (1 << EXC_MACH_SYSCALL)
#define EXC_MASK_RPC_ALERT (1 << EXC_RPC_ALERT)
#define EXC_MASK_CRASH (1 << EXC_CRASH)
#define EXC_MASK_RESOURCE (1 << EXC_RESOURCE)
#define EXC_MASK_GUARD (1 << EXC_GUARD)
#define EXC_MASK_CORPSE_NOTIFY (1 << EXC_CORPSE_NOTIFY)

#define EXC_MASK_ALL (EXC_MASK_BAD_ACCESS | EXC_MASK_BAD_INSTRUCTION | EXC_MASK_ARITHMETIC | EXC_MASK_EMULATION | EXC_MASK_SOFTWARE | EXC_MASK_BREAKPOINT | EXC_MASK_SYSCALL | EXC_MASK_MACH_SYSCALL | EXC_MASK_RPC_ALERT | EXC_MASK_RESOURCE | EXC_MASK_GUARD | EXC_MASK_MACHINE)
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/exception_types.h" 3 4
#define FIRST_EXCEPTION 1







#define EXC_SOFT_SIGNAL 0x10003

#define EXC_MACF_MIN 0x20000
#define EXC_MACF_MAX 0x2FFFF




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_status.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_status.h" 3 4
#define _MACH_THREAD_STATUS_H_ 






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/thread_status.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/thread_status.h" 3 4
#define _MACH_MACHINE_THREAD_STATUS_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_status.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_status.h" 3 4
#define _ARM_THREAD_STATUS_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/thread_state.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/thread_state.h" 3 4
#define _MACH_MACHINE_THREAD_STATE_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_state.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_state.h" 3 4
#define _MACH_ARM_THREAD_STATE_H_ 




#define ARM_THREAD_STATE_MAX (1296)
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/thread_state.h" 2 3 4





#define THREAD_STATE_MAX 1296
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_status.h" 2 3 4
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_status.h" 3 4
#define ARM_THREAD_STATE 1
#define ARM_UNIFIED_THREAD_STATE ARM_THREAD_STATE
#define ARM_VFP_STATE 2
#define ARM_EXCEPTION_STATE 3
#define ARM_DEBUG_STATE 4
#define THREAD_STATE_NONE 5
#define ARM_THREAD_STATE64 6
#define ARM_EXCEPTION_STATE64 7

#define ARM_THREAD_STATE32 9



#define ARM_DEBUG_STATE32 14
#define ARM_DEBUG_STATE64 15
#define ARM_NEON_STATE 16
#define ARM_NEON_STATE64 17
#define ARM_CPMU_STATE64 18



#define ARM_AMX_STATE 24
#define ARM_AMX_STATE_V1 25
#define ARM_STATE_FLAVOR_IS_OTHER_VALID(_flavor_) ((_flavor_) == ARM_AMX_STATE_V1)

#define ARM_PAGEIN_STATE 27

#define VALID_THREAD_STATE_FLAVOR(x) ((x == ARM_THREAD_STATE) || (x == ARM_VFP_STATE) || (x == ARM_EXCEPTION_STATE) || (x == ARM_DEBUG_STATE) || (x == THREAD_STATE_NONE) || (x == ARM_THREAD_STATE32) || (x == ARM_THREAD_STATE64) || (x == ARM_EXCEPTION_STATE64) || (x == ARM_NEON_STATE) || (x == ARM_NEON_STATE64) || (x == ARM_DEBUG_STATE32) || (x == ARM_DEBUG_STATE64) || (x == ARM_PAGEIN_STATE) || (ARM_STATE_FLAVOR_IS_OTHER_VALID(x)))
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_status.h" 3 4
struct arm_state_hdr {
 uint32_t flavor;
 uint32_t count;
};
typedef struct arm_state_hdr arm_state_hdr_t;

typedef struct __darwin_arm_thread_state arm_thread_state_t;
typedef struct __darwin_arm_thread_state arm_thread_state32_t;
typedef struct __darwin_arm_thread_state64 arm_thread_state64_t;






#define arm_thread_state64_get_pc(ts) __darwin_arm_thread_state64_get_pc(ts)




#define arm_thread_state64_get_pc_fptr(ts) __darwin_arm_thread_state64_get_pc_fptr(ts)


#define arm_thread_state64_set_pc_fptr(ts,fptr) __darwin_arm_thread_state64_set_pc_fptr(ts, fptr)


#define arm_thread_state64_get_lr(ts) __darwin_arm_thread_state64_get_lr(ts)




#define arm_thread_state64_get_lr_fptr(ts) __darwin_arm_thread_state64_get_lr_fptr(ts)


#define arm_thread_state64_set_lr_fptr(ts,fptr) __darwin_arm_thread_state64_set_lr_fptr(ts, fptr)


#define arm_thread_state64_get_sp(ts) __darwin_arm_thread_state64_get_sp(ts)


#define arm_thread_state64_set_sp(ts,ptr) __darwin_arm_thread_state64_set_sp(ts, ptr)


#define arm_thread_state64_get_fp(ts) __darwin_arm_thread_state64_get_fp(ts)


#define arm_thread_state64_set_fp(ts,ptr) __darwin_arm_thread_state64_set_fp(ts, ptr)


#define arm_thread_state64_ptrauth_strip(ts) __darwin_arm_thread_state64_ptrauth_strip(ts)




struct arm_unified_thread_state {
 arm_state_hdr_t ash;
 union {
  arm_thread_state32_t ts_32;
  arm_thread_state64_t ts_64;
 } uts;
};
#define ts_32 uts.ts_32
#define ts_64 uts.ts_64
typedef struct arm_unified_thread_state arm_unified_thread_state_t;

#define ARM_THREAD_STATE_COUNT ((mach_msg_type_number_t) (sizeof (arm_thread_state_t)/sizeof(uint32_t)))

#define ARM_THREAD_STATE32_COUNT ((mach_msg_type_number_t) (sizeof (arm_thread_state32_t)/sizeof(uint32_t)))

#define ARM_THREAD_STATE64_COUNT ((mach_msg_type_number_t) (sizeof (arm_thread_state64_t)/sizeof(uint32_t)))

#define ARM_UNIFIED_THREAD_STATE_COUNT ((mach_msg_type_number_t) (sizeof (arm_unified_thread_state_t)/sizeof(uint32_t)))



typedef struct __darwin_arm_vfp_state arm_vfp_state_t;
typedef struct __darwin_arm_neon_state arm_neon_state_t;
typedef struct __darwin_arm_neon_state arm_neon_state32_t;
typedef struct __darwin_arm_neon_state64 arm_neon_state64_t;

typedef struct __darwin_arm_amx_state_v1 arm_amx_state_v1_t;

typedef struct __darwin_arm_exception_state arm_exception_state_t;
typedef struct __darwin_arm_exception_state arm_exception_state32_t;
typedef struct __darwin_arm_exception_state64 arm_exception_state64_t;

typedef struct __darwin_arm_debug_state32 arm_debug_state32_t;
typedef struct __darwin_arm_debug_state64 arm_debug_state64_t;

typedef struct __arm_pagein_state arm_pagein_state_t;
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/thread_status.h" 3 4
typedef struct __arm_legacy_debug_state arm_debug_state_t;




#define ARM_VFP_STATE_COUNT ((mach_msg_type_number_t) (sizeof (arm_vfp_state_t)/sizeof(uint32_t)))


#define ARM_EXCEPTION_STATE_COUNT ((mach_msg_type_number_t) (sizeof (arm_exception_state_t)/sizeof(uint32_t)))


#define ARM_EXCEPTION_STATE64_COUNT ((mach_msg_type_number_t) (sizeof (arm_exception_state64_t)/sizeof(uint32_t)))


#define ARM_DEBUG_STATE_COUNT ((mach_msg_type_number_t) (sizeof (arm_debug_state_t)/sizeof(uint32_t)))


#define ARM_DEBUG_STATE32_COUNT ((mach_msg_type_number_t) (sizeof (arm_debug_state32_t)/sizeof(uint32_t)))


#define ARM_PAGEIN_STATE_COUNT ((mach_msg_type_number_t) (sizeof (arm_pagein_state_t)/sizeof(uint32_t)))


#define ARM_DEBUG_STATE64_COUNT ((mach_msg_type_number_t) (sizeof (arm_debug_state64_t)/sizeof(uint32_t)))


#define ARM_NEON_STATE_COUNT ((mach_msg_type_number_t) (sizeof (arm_neon_state_t)/sizeof(uint32_t)))


#define ARM_NEON_STATE64_COUNT ((mach_msg_type_number_t) (sizeof (arm_neon_state64_t)/sizeof(uint32_t)))


#define MACHINE_THREAD_STATE ARM_THREAD_STATE
#define MACHINE_THREAD_STATE_COUNT ARM_UNIFIED_THREAD_STATE_COUNT


struct arm_amx_state {
 arm_state_hdr_t ash;
 union {
  arm_amx_state_v1_t as_v1;
 } uas;
};
#define as_v1 uas.as_v1
typedef struct arm_amx_state arm_amx_state_t;

#define ARM_AMX_STATE_V1_COUNT ((mach_msg_type_number_t) (sizeof(arm_amx_state_v1_t)/sizeof(unsigned int)))


#define ARM_AMX_STATE_COUNT ((mach_msg_type_number_t) (sizeof(arm_amx_state_t)/sizeof(unsigned int)))






#define THREAD_MACHINE_STATE_MAX THREAD_STATE_MAX
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/thread_status.h" 2 3 4
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_status.h" 2 3 4






typedef natural_t *thread_state_t;


typedef natural_t thread_state_data_t[1296];

#define THREAD_STATE_FLAVOR_LIST 0
#define THREAD_STATE_FLAVOR_LIST_NEW 128
#define THREAD_STATE_FLAVOR_LIST_10_9 129
#define THREAD_STATE_FLAVOR_LIST_10_13 130
#define THREAD_STATE_FLAVOR_LIST_10_15 131

typedef int thread_state_flavor_t;
typedef thread_state_flavor_t *thread_state_flavor_array_t;

#define THREAD_CONVERT_THREAD_STATE_TO_SELF 1
#define THREAD_CONVERT_THREAD_STATE_FROM_SELF 2
# 188 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/exception_types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach_debug/ipc_info.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach_debug/ipc_info.h" 3 4
#define _MACH_DEBUG_IPC_INFO_H_ 
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach_debug/ipc_info.h" 3 4
typedef struct ipc_info_space {
 natural_t iis_genno_mask;
 natural_t iis_table_size;
 natural_t iis_table_next;
 natural_t iis_tree_size;
 natural_t iis_tree_small;
 natural_t iis_tree_hash;
} ipc_info_space_t;

typedef struct ipc_info_space_basic {
 natural_t iisb_genno_mask;
 natural_t iisb_table_size;
 natural_t iisb_table_next;
 natural_t iisb_table_inuse;
 natural_t iisb_reserved[2];
} ipc_info_space_basic_t;

typedef struct ipc_info_name {
 mach_port_name_t iin_name;
              integer_t iin_collision;
 mach_port_type_t iin_type;
 mach_port_urefs_t iin_urefs;
 natural_t iin_object;
 natural_t iin_next;
 natural_t iin_hash;
} ipc_info_name_t;

typedef ipc_info_name_t *ipc_info_name_array_t;


typedef struct ipc_info_tree_name {
 ipc_info_name_t iitn_name;
 mach_port_name_t iitn_lchild;
 mach_port_name_t iitn_rchild;
} ipc_info_tree_name_t;

typedef ipc_info_tree_name_t *ipc_info_tree_name_array_t;

typedef struct ipc_info_port {
 natural_t iip_port_object;
 natural_t iip_receiver_object;
} ipc_info_port_t;

typedef ipc_info_port_t *exception_handler_info_array_t;
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/exception_types.h" 2 3 4




typedef int exception_type_t;
typedef integer_t exception_data_type_t;
typedef int64_t mach_exception_data_type_t;
typedef int exception_behavior_t;
typedef exception_data_type_t *exception_data_t;
typedef mach_exception_data_type_t *mach_exception_data_t;
typedef unsigned int exception_mask_t;
typedef exception_mask_t *exception_mask_array_t;
typedef exception_behavior_t *exception_behavior_array_t;
typedef thread_state_flavor_t *exception_flavor_array_t;
typedef mach_port_t *exception_port_array_t;
typedef ipc_info_port_t *exception_port_info_array_t;
typedef mach_exception_data_type_t mach_exception_code_t;
typedef mach_exception_data_type_t mach_exception_subcode_t;
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_voucher_types.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_voucher_types.h" 3 4
#define _MACH_VOUCHER_TYPES_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/std_types.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/std_types.h" 3 4
#define _MACH_STD_TYPES_H_ 
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/std_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_uuid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_uuid_t.h" 3 4
#define _UUID_T 

typedef __darwin_uuid_t uuid_t;
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/std_types.h" 2 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_voucher_types.h" 2 3 4
# 54 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_voucher_types.h" 3 4
typedef mach_port_t mach_voucher_t;
#define MACH_VOUCHER_NULL ((mach_voucher_t) 0)

typedef mach_port_name_t mach_voucher_name_t;
#define MACH_VOUCHER_NAME_NULL ((mach_voucher_name_t) 0)

typedef mach_voucher_name_t *mach_voucher_name_array_t;
#define MACH_VOUCHER_NAME_ARRAY_NULL ((mach_voucher_name_array_t) 0)





typedef mach_voucher_t ipc_voucher_t;
#define IPC_VOUCHER_NULL ((ipc_voucher_t) 0)






typedef uint32_t mach_voucher_selector_t;
#define MACH_VOUCHER_SELECTOR_CURRENT ((mach_voucher_selector_t)0)
#define MACH_VOUCHER_SELECTOR_EFFECTIVE ((mach_voucher_selector_t)1)







typedef uint32_t mach_voucher_attr_key_t;
typedef mach_voucher_attr_key_t *mach_voucher_attr_key_array_t;

#define MACH_VOUCHER_ATTR_KEY_ALL ((mach_voucher_attr_key_t)~0)
#define MACH_VOUCHER_ATTR_KEY_NONE ((mach_voucher_attr_key_t)0)


#define MACH_VOUCHER_ATTR_KEY_ATM ((mach_voucher_attr_key_t)1)
#define MACH_VOUCHER_ATTR_KEY_IMPORTANCE ((mach_voucher_attr_key_t)2)
#define MACH_VOUCHER_ATTR_KEY_BANK ((mach_voucher_attr_key_t)3)
#define MACH_VOUCHER_ATTR_KEY_PTHPRIORITY ((mach_voucher_attr_key_t)4)

#define MACH_VOUCHER_ATTR_KEY_USER_DATA ((mach_voucher_attr_key_t)7)
#define MACH_VOUCHER_ATTR_KEY_BITS MACH_VOUCHER_ATTR_KEY_USER_DATA
#define MACH_VOUCHER_ATTR_KEY_TEST ((mach_voucher_attr_key_t)8)

#define MACH_VOUCHER_ATTR_KEY_NUM_WELL_KNOWN MACH_VOUCHER_ATTR_KEY_TEST
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_voucher_types.h" 3 4
typedef uint8_t *mach_voucher_attr_content_t;
typedef uint32_t mach_voucher_attr_content_size_t;





typedef uint32_t mach_voucher_attr_command_t;
# 127 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_voucher_types.h" 3 4
typedef uint32_t mach_voucher_attr_recipe_command_t;
typedef mach_voucher_attr_recipe_command_t *mach_voucher_attr_recipe_command_array_t;

#define MACH_VOUCHER_ATTR_NOOP ((mach_voucher_attr_recipe_command_t)0)
#define MACH_VOUCHER_ATTR_COPY ((mach_voucher_attr_recipe_command_t)1)
#define MACH_VOUCHER_ATTR_REMOVE ((mach_voucher_attr_recipe_command_t)2)
#define MACH_VOUCHER_ATTR_SET_VALUE_HANDLE ((mach_voucher_attr_recipe_command_t)3)
#define MACH_VOUCHER_ATTR_AUTO_REDEEM ((mach_voucher_attr_recipe_command_t)4)
#define MACH_VOUCHER_ATTR_SEND_PREPROCESS ((mach_voucher_attr_recipe_command_t)5)


#define MACH_VOUCHER_ATTR_REDEEM ((mach_voucher_attr_recipe_command_t)10)


#define MACH_VOUCHER_ATTR_IMPORTANCE_SELF ((mach_voucher_attr_recipe_command_t)200)


#define MACH_VOUCHER_ATTR_USER_DATA_STORE ((mach_voucher_attr_recipe_command_t)211)
#define MACH_VOUCHER_ATTR_BITS_STORE MACH_VOUCHER_ATTR_USER_DATA_STORE


#define MACH_VOUCHER_ATTR_TEST_STORE MACH_VOUCHER_ATTR_USER_DATA_STORE






#pragma pack(push, 1)

typedef struct mach_voucher_attr_recipe_data {
 mach_voucher_attr_key_t key;
 mach_voucher_attr_recipe_command_t command;
 mach_voucher_name_t previous_voucher;
 mach_voucher_attr_content_size_t content_size;
 uint8_t content[];
} mach_voucher_attr_recipe_data_t;
typedef mach_voucher_attr_recipe_data_t *mach_voucher_attr_recipe_t;
typedef mach_msg_type_number_t mach_voucher_attr_recipe_size_t;


typedef uint8_t *mach_voucher_attr_raw_recipe_t;
typedef mach_voucher_attr_raw_recipe_t mach_voucher_attr_raw_recipe_array_t;
typedef mach_msg_type_number_t mach_voucher_attr_raw_recipe_size_t;
typedef mach_msg_type_number_t mach_voucher_attr_raw_recipe_array_size_t;

#define MACH_VOUCHER_ATTR_MAX_RAW_RECIPE_ARRAY_SIZE 5120
#define MACH_VOUCHER_TRAP_STACK_LIMIT 256

#pragma pack(pop)
# 188 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_voucher_types.h" 3 4
typedef mach_port_t mach_voucher_attr_manager_t;
#define MACH_VOUCHER_ATTR_MANAGER_NULL ((mach_voucher_attr_manager_t) 0)







typedef mach_port_t mach_voucher_attr_control_t;
#define MACH_VOUCHER_ATTR_CONTROL_NULL ((mach_voucher_attr_control_t) 0)






typedef mach_port_t ipc_voucher_attr_manager_t;
typedef mach_port_t ipc_voucher_attr_control_t;
#define IPC_VOUCHER_ATTR_MANAGER_NULL ((ipc_voucher_attr_manager_t) 0)
#define IPC_VOUCHER_ATTR_CONTROL_NULL ((ipc_voucher_attr_control_t) 0)







typedef uint64_t mach_voucher_attr_value_handle_t ;
typedef mach_voucher_attr_value_handle_t *mach_voucher_attr_value_handle_array_t;

typedef mach_msg_type_number_t mach_voucher_attr_value_handle_array_size_t;
#define MACH_VOUCHER_ATTR_VALUE_MAX_NESTED ((mach_voucher_attr_value_handle_array_size_t)4)

typedef uint32_t mach_voucher_attr_value_reference_t;
typedef uint32_t mach_voucher_attr_value_flags_t;
#define MACH_VOUCHER_ATTR_VALUE_FLAGS_NONE ((mach_voucher_attr_value_flags_t)0)
#define MACH_VOUCHER_ATTR_VALUE_FLAGS_PERSIST ((mach_voucher_attr_value_flags_t)1)


typedef uint32_t mach_voucher_attr_control_flags_t;
#define MACH_VOUCHER_ATTR_CONTROL_FLAGS_NONE ((mach_voucher_attr_control_flags_t)0)







#define MACH_VOUCHER_IMPORTANCE_ATTR_ADD_EXTERNAL 1
#define MACH_VOUCHER_IMPORTANCE_ATTR_DROP_EXTERNAL 2
typedef uint32_t mach_voucher_attr_importance_refs;




#define MACH_ACTIVITY_ID_COUNT_MAX 16
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/processor_info.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/processor_info.h" 3 4
#define _MACH_PROCESSOR_INFO_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/processor_info.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/processor_info.h" 3 4
#define _MACH_MACHINE_PROCESSOR_INFO_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/processor_info.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/processor_info.h" 3 4
#define _MACH_ARM_PROCESSOR_INFO_H_ 



#define PROCESSOR_CPU_STAT 0x10000003
#define PROCESSOR_CPU_STAT64 0x10000004



struct processor_cpu_stat {
 uint32_t irq_ex_cnt;
 uint32_t ipi_cnt;
 uint32_t timer_cnt;
 uint32_t undef_ex_cnt;
 uint32_t unaligned_cnt;
 uint32_t vfp_cnt;
 uint32_t vfp_shortv_cnt;
 uint32_t data_ex_cnt;
 uint32_t instr_ex_cnt;
};

typedef struct processor_cpu_stat processor_cpu_stat_data_t;
typedef struct processor_cpu_stat *processor_cpu_stat_t;
#define PROCESSOR_CPU_STAT_COUNT ((mach_msg_type_number_t) (sizeof(processor_cpu_stat_data_t) / sizeof(natural_t)))


struct processor_cpu_stat64 {
 uint64_t irq_ex_cnt;
 uint64_t ipi_cnt;
 uint64_t timer_cnt;
 uint64_t undef_ex_cnt;
 uint64_t unaligned_cnt;
 uint64_t vfp_cnt;
 uint64_t vfp_shortv_cnt;
 uint64_t data_ex_cnt;
 uint64_t instr_ex_cnt;
 uint64_t pmi_cnt;
} __attribute__((packed, aligned(4)));

typedef struct processor_cpu_stat64 processor_cpu_stat64_data_t;
typedef struct processor_cpu_stat64 *processor_cpu_stat64_t;
#define PROCESSOR_CPU_STAT64_COUNT ((mach_msg_type_number_t) (sizeof(processor_cpu_stat64_data_t) / sizeof(integer_t)))
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/processor_info.h" 2 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/processor_info.h" 2 3 4




typedef integer_t *processor_info_t;
typedef integer_t *processor_info_array_t;

#define PROCESSOR_INFO_MAX (1024)
typedef integer_t processor_info_data_t[(1024)];


typedef integer_t *processor_set_info_t;

#define PROCESSOR_SET_INFO_MAX (1024)
typedef integer_t processor_set_info_data_t[(1024)];




typedef int processor_flavor_t;
#define PROCESSOR_BASIC_INFO 1
#define PROCESSOR_CPU_LOAD_INFO 2
#define PROCESSOR_PM_REGS_INFO 0x10000001
#define PROCESSOR_TEMPERATURE 0x10000002

struct processor_basic_info {
 cpu_type_t cpu_type;
 cpu_subtype_t cpu_subtype;
 boolean_t running;
 int slot_num;
 boolean_t is_master;
};

typedef struct processor_basic_info processor_basic_info_data_t;
typedef struct processor_basic_info *processor_basic_info_t;
#define PROCESSOR_BASIC_INFO_COUNT ((mach_msg_type_number_t) (sizeof(processor_basic_info_data_t)/sizeof(natural_t)))


struct processor_cpu_load_info {
 unsigned int cpu_ticks[4];
};

typedef struct processor_cpu_load_info processor_cpu_load_info_data_t;
typedef struct processor_cpu_load_info *processor_cpu_load_info_t;
#define PROCESSOR_CPU_LOAD_INFO_COUNT ((mach_msg_type_number_t) (sizeof(processor_cpu_load_info_data_t)/sizeof(natural_t)))





#define LOAD_SCALE 1000

typedef int processor_set_flavor_t;
#define PROCESSOR_SET_BASIC_INFO 5

struct processor_set_basic_info {
 int processor_count;
 int default_policy;
};

typedef struct processor_set_basic_info processor_set_basic_info_data_t;
typedef struct processor_set_basic_info *processor_set_basic_info_t;
#define PROCESSOR_SET_BASIC_INFO_COUNT ((mach_msg_type_number_t) (sizeof(processor_set_basic_info_data_t)/sizeof(natural_t)))


#define PROCESSOR_SET_LOAD_INFO 4

struct processor_set_load_info {
 int task_count;
 int thread_count;
 integer_t load_average;
 integer_t mach_factor;
};

typedef struct processor_set_load_info processor_set_load_info_data_t;
typedef struct processor_set_load_info *processor_set_load_info_t;
#define PROCESSOR_SET_LOAD_INFO_COUNT ((mach_msg_type_number_t) (sizeof(processor_set_load_info_data_t)/sizeof(natural_t)))
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_info.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_info.h" 3 4
#define _MACH_TASK_INFO_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/policy.h" 1 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/policy.h" 3 4
#define _MACH_POLICY_H_ 
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/policy.h" 3 4
typedef int policy_t;
typedef integer_t *policy_info_t;
typedef integer_t *policy_base_t;
typedef integer_t *policy_limit_t;






#define POLICY_NULL 0
#define POLICY_TIMESHARE 1
#define POLICY_RR 2
#define POLICY_FIFO 4

#define __NEW_SCHEDULING_FRAMEWORK__ 




#define POLICYCLASS_FIXEDPRI (POLICY_RR | POLICY_FIFO)




#define invalid_policy(policy) ((policy) != POLICY_TIMESHARE && (policy) != POLICY_RR && (policy) != POLICY_FIFO)
# 113 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/policy.h" 3 4
struct policy_timeshare_base {
 integer_t base_priority;
};
struct policy_timeshare_limit {
 integer_t max_priority;
};
struct policy_timeshare_info {
 integer_t max_priority;
 integer_t base_priority;
 integer_t cur_priority;
 boolean_t depressed;
 integer_t depress_priority;
};

typedef struct policy_timeshare_base *policy_timeshare_base_t;
typedef struct policy_timeshare_limit *policy_timeshare_limit_t;
typedef struct policy_timeshare_info *policy_timeshare_info_t;

typedef struct policy_timeshare_base policy_timeshare_base_data_t;
typedef struct policy_timeshare_limit policy_timeshare_limit_data_t;
typedef struct policy_timeshare_info policy_timeshare_info_data_t;


#define POLICY_TIMESHARE_BASE_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_timeshare_base)/sizeof(integer_t)))

#define POLICY_TIMESHARE_LIMIT_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_timeshare_limit)/sizeof(integer_t)))

#define POLICY_TIMESHARE_INFO_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_timeshare_info)/sizeof(integer_t)))






struct policy_rr_base {
 integer_t base_priority;
 integer_t quantum;
};
struct policy_rr_limit {
 integer_t max_priority;
};
struct policy_rr_info {
 integer_t max_priority;
 integer_t base_priority;
 integer_t quantum;
 boolean_t depressed;
 integer_t depress_priority;
};

typedef struct policy_rr_base *policy_rr_base_t;
typedef struct policy_rr_limit *policy_rr_limit_t;
typedef struct policy_rr_info *policy_rr_info_t;

typedef struct policy_rr_base policy_rr_base_data_t;
typedef struct policy_rr_limit policy_rr_limit_data_t;
typedef struct policy_rr_info policy_rr_info_data_t;

#define POLICY_RR_BASE_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_rr_base)/sizeof(integer_t)))

#define POLICY_RR_LIMIT_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_rr_limit)/sizeof(integer_t)))

#define POLICY_RR_INFO_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_rr_info)/sizeof(integer_t)))






struct policy_fifo_base {
 integer_t base_priority;
};
struct policy_fifo_limit {
 integer_t max_priority;
};
struct policy_fifo_info {
 integer_t max_priority;
 integer_t base_priority;
 boolean_t depressed;
 integer_t depress_priority;
};

typedef struct policy_fifo_base *policy_fifo_base_t;
typedef struct policy_fifo_limit *policy_fifo_limit_t;
typedef struct policy_fifo_info *policy_fifo_info_t;

typedef struct policy_fifo_base policy_fifo_base_data_t;
typedef struct policy_fifo_limit policy_fifo_limit_data_t;
typedef struct policy_fifo_info policy_fifo_info_data_t;

#define POLICY_FIFO_BASE_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_fifo_base)/sizeof(integer_t)))

#define POLICY_FIFO_LIMIT_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_fifo_limit)/sizeof(integer_t)))

#define POLICY_FIFO_INFO_COUNT ((mach_msg_type_number_t) (sizeof(struct policy_fifo_info)/sizeof(integer_t)))






struct policy_bases {
 policy_timeshare_base_data_t ts;
 policy_rr_base_data_t rr;
 policy_fifo_base_data_t fifo;
};

struct policy_limits {
 policy_timeshare_limit_data_t ts;
 policy_rr_limit_data_t rr;
 policy_fifo_limit_data_t fifo;
};

struct policy_infos {
 policy_timeshare_info_data_t ts;
 policy_rr_info_data_t rr;
 policy_fifo_info_data_t fifo;
};

typedef struct policy_bases policy_base_data_t;
typedef struct policy_limits policy_limit_data_t;
typedef struct policy_infos policy_info_data_t;
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_info.h" 2 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_info.h" 3 4
typedef natural_t task_flavor_t;
typedef integer_t *task_info_t;


#define TASK_INFO_MAX (1024)
typedef integer_t task_info_data_t[(1024)];





#pragma pack(push, 4)


#define TASK_BASIC_INFO_32 4
#define TASK_BASIC2_INFO_32 6

struct task_basic_info_32 {
 integer_t suspend_count;
 natural_t virtual_size;
 natural_t resident_size;
 time_value_t user_time;

 time_value_t system_time;

 policy_t policy;
};
typedef struct task_basic_info_32 task_basic_info_32_data_t;
typedef struct task_basic_info_32 *task_basic_info_32_t;
#define TASK_BASIC_INFO_32_COUNT (sizeof(task_basic_info_32_data_t) / sizeof(natural_t))



struct task_basic_info_64 {
 integer_t suspend_count;

 mach_vm_size_t virtual_size;
 mach_vm_size_t resident_size;




 time_value_t user_time;

 time_value_t system_time;

 policy_t policy;
};
typedef struct task_basic_info_64 task_basic_info_64_data_t;
typedef struct task_basic_info_64 *task_basic_info_64_t;
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_info.h" 3 4
#define TASK_BASIC_INFO_64 TASK_BASIC_INFO_64_2
#define TASK_BASIC_INFO_64_COUNT TASK_BASIC_INFO_64_2_COUNT
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_info.h" 3 4
struct task_basic_info {
 integer_t suspend_count;
 vm_size_t virtual_size;
 vm_size_t resident_size;
 time_value_t user_time;

 time_value_t system_time;

 policy_t policy;
};

typedef struct task_basic_info task_basic_info_data_t;
typedef struct task_basic_info *task_basic_info_t;
#define TASK_BASIC_INFO_COUNT (sizeof(task_basic_info_data_t) / sizeof(natural_t))




#define TASK_BASIC_INFO TASK_BASIC_INFO_64




#define TASK_EVENTS_INFO 2

struct task_events_info {
 integer_t faults;
 integer_t pageins;
 integer_t cow_faults;
 integer_t messages_sent;
 integer_t messages_received;
 integer_t syscalls_mach;
 integer_t syscalls_unix;
 integer_t csw;
};
typedef struct task_events_info task_events_info_data_t;
typedef struct task_events_info *task_events_info_t;
#define TASK_EVENTS_INFO_COUNT ((mach_msg_type_number_t) (sizeof(task_events_info_data_t) / sizeof(natural_t)))


#define TASK_THREAD_TIMES_INFO 3


struct task_thread_times_info {
 time_value_t user_time;

 time_value_t system_time;

};

typedef struct task_thread_times_info task_thread_times_info_data_t;
typedef struct task_thread_times_info *task_thread_times_info_t;
#define TASK_THREAD_TIMES_INFO_COUNT ((mach_msg_type_number_t) (sizeof(task_thread_times_info_data_t) / sizeof(natural_t)))


#define TASK_ABSOLUTETIME_INFO 1

struct task_absolutetime_info {
 uint64_t total_user;
 uint64_t total_system;
 uint64_t threads_user;
 uint64_t threads_system;
};

typedef struct task_absolutetime_info task_absolutetime_info_data_t;
typedef struct task_absolutetime_info *task_absolutetime_info_t;
#define TASK_ABSOLUTETIME_INFO_COUNT ((mach_msg_type_number_t) (sizeof (task_absolutetime_info_data_t) / sizeof (natural_t)))


#define TASK_KERNELMEMORY_INFO 7

struct task_kernelmemory_info {
 uint64_t total_palloc;
 uint64_t total_pfree;
 uint64_t total_salloc;
 uint64_t total_sfree;
};

typedef struct task_kernelmemory_info task_kernelmemory_info_data_t;
typedef struct task_kernelmemory_info *task_kernelmemory_info_t;
#define TASK_KERNELMEMORY_INFO_COUNT ((mach_msg_type_number_t) (sizeof (task_kernelmemory_info_data_t) / sizeof (natural_t)))


#define TASK_SECURITY_TOKEN 13
#define TASK_SECURITY_TOKEN_COUNT ((mach_msg_type_number_t) (sizeof(security_token_t) / sizeof(natural_t)))


#define TASK_AUDIT_TOKEN 15
#define TASK_AUDIT_TOKEN_COUNT (sizeof(audit_token_t) / sizeof(natural_t))



#define TASK_AFFINITY_TAG_INFO 16

struct task_affinity_tag_info {
 integer_t set_count;
 integer_t min;
 integer_t max;
 integer_t task_count;
};
typedef struct task_affinity_tag_info task_affinity_tag_info_data_t;
typedef struct task_affinity_tag_info *task_affinity_tag_info_t;
#define TASK_AFFINITY_TAG_INFO_COUNT (sizeof(task_affinity_tag_info_data_t) / sizeof(natural_t))


#define TASK_DYLD_INFO 17

struct task_dyld_info {
 mach_vm_address_t all_image_info_addr;
 mach_vm_size_t all_image_info_size;
 integer_t all_image_info_format;
};
typedef struct task_dyld_info task_dyld_info_data_t;
typedef struct task_dyld_info *task_dyld_info_t;
#define TASK_DYLD_INFO_COUNT (sizeof(task_dyld_info_data_t) / sizeof(natural_t))

#define TASK_DYLD_ALL_IMAGE_INFO_32 0
#define TASK_DYLD_ALL_IMAGE_INFO_64 1





#define TASK_BASIC_INFO_64_2 18

struct task_basic_info_64_2 {
 integer_t suspend_count;
 mach_vm_size_t virtual_size;
 mach_vm_size_t resident_size;
 time_value_t user_time;

 time_value_t system_time;

 policy_t policy;
};
typedef struct task_basic_info_64_2 task_basic_info_64_2_data_t;
typedef struct task_basic_info_64_2 *task_basic_info_64_2_t;
#define TASK_BASIC_INFO_64_2_COUNT (sizeof(task_basic_info_64_2_data_t) / sizeof(natural_t))



#define TASK_EXTMOD_INFO 19

struct task_extmod_info {
 unsigned char task_uuid[16];
 vm_extmod_statistics_data_t extmod_statistics;
};
typedef struct task_extmod_info task_extmod_info_data_t;
typedef struct task_extmod_info *task_extmod_info_t;
#define TASK_EXTMOD_INFO_COUNT (sizeof(task_extmod_info_data_t) / sizeof(natural_t))



#define MACH_TASK_BASIC_INFO 20
struct mach_task_basic_info {
 mach_vm_size_t virtual_size;
 mach_vm_size_t resident_size;
 mach_vm_size_t resident_size_max;
 time_value_t user_time;

 time_value_t system_time;

 policy_t policy;
 integer_t suspend_count;
};
typedef struct mach_task_basic_info mach_task_basic_info_data_t;
typedef struct mach_task_basic_info *mach_task_basic_info_t;
#define MACH_TASK_BASIC_INFO_COUNT (sizeof(mach_task_basic_info_data_t) / sizeof(natural_t))



#define TASK_POWER_INFO 21

struct task_power_info {
 uint64_t total_user;
 uint64_t total_system;
 uint64_t task_interrupt_wakeups;
 uint64_t task_platform_idle_wakeups;
 uint64_t task_timer_wakeups_bin_1;
 uint64_t task_timer_wakeups_bin_2;
};

typedef struct task_power_info task_power_info_data_t;
typedef struct task_power_info *task_power_info_t;
#define TASK_POWER_INFO_COUNT ((mach_msg_type_number_t) (sizeof (task_power_info_data_t) / sizeof (natural_t)))




#define TASK_VM_INFO 22
#define TASK_VM_INFO_PURGEABLE 23
struct task_vm_info {
 mach_vm_size_t virtual_size;
 integer_t region_count;
 integer_t page_size;
 mach_vm_size_t resident_size;
 mach_vm_size_t resident_size_peak;

 mach_vm_size_t device;
 mach_vm_size_t device_peak;
 mach_vm_size_t internal;
 mach_vm_size_t internal_peak;
 mach_vm_size_t external;
 mach_vm_size_t external_peak;
 mach_vm_size_t reusable;
 mach_vm_size_t reusable_peak;
 mach_vm_size_t purgeable_volatile_pmap;
 mach_vm_size_t purgeable_volatile_resident;
 mach_vm_size_t purgeable_volatile_virtual;
 mach_vm_size_t compressed;
 mach_vm_size_t compressed_peak;
 mach_vm_size_t compressed_lifetime;


 mach_vm_size_t phys_footprint;


 mach_vm_address_t min_address;
 mach_vm_address_t max_address;


 int64_t ledger_phys_footprint_peak;
 int64_t ledger_purgeable_nonvolatile;
 int64_t ledger_purgeable_novolatile_compressed;
 int64_t ledger_purgeable_volatile;
 int64_t ledger_purgeable_volatile_compressed;
 int64_t ledger_tag_network_nonvolatile;
 int64_t ledger_tag_network_nonvolatile_compressed;
 int64_t ledger_tag_network_volatile;
 int64_t ledger_tag_network_volatile_compressed;
 int64_t ledger_tag_media_footprint;
 int64_t ledger_tag_media_footprint_compressed;
 int64_t ledger_tag_media_nofootprint;
 int64_t ledger_tag_media_nofootprint_compressed;
 int64_t ledger_tag_graphics_footprint;
 int64_t ledger_tag_graphics_footprint_compressed;
 int64_t ledger_tag_graphics_nofootprint;
 int64_t ledger_tag_graphics_nofootprint_compressed;
 int64_t ledger_tag_neural_footprint;
 int64_t ledger_tag_neural_footprint_compressed;
 int64_t ledger_tag_neural_nofootprint;
 int64_t ledger_tag_neural_nofootprint_compressed;


 uint64_t limit_bytes_remaining;


 integer_t decompressions;
};
typedef struct task_vm_info task_vm_info_data_t;
typedef struct task_vm_info *task_vm_info_t;
#define TASK_VM_INFO_COUNT ((mach_msg_type_number_t) (sizeof (task_vm_info_data_t) / sizeof (natural_t)))

#define TASK_VM_INFO_REV5_COUNT TASK_VM_INFO_COUNT
#define TASK_VM_INFO_REV4_COUNT ((mach_msg_type_number_t) (TASK_VM_INFO_REV5_COUNT - 1))

#define TASK_VM_INFO_REV3_COUNT ((mach_msg_type_number_t) (TASK_VM_INFO_REV4_COUNT - 2))

#define TASK_VM_INFO_REV2_COUNT ((mach_msg_type_number_t) (TASK_VM_INFO_REV3_COUNT - 42))

#define TASK_VM_INFO_REV1_COUNT ((mach_msg_type_number_t) (TASK_VM_INFO_REV2_COUNT - 4))

#define TASK_VM_INFO_REV0_COUNT ((mach_msg_type_number_t) (TASK_VM_INFO_REV1_COUNT - 2))


typedef struct vm_purgeable_info task_purgable_info_t;


#define TASK_TRACE_MEMORY_INFO 24
struct task_trace_memory_info {
 uint64_t user_memory_address;
 uint64_t buffer_size;
 uint64_t mailbox_array_size;
};
typedef struct task_trace_memory_info task_trace_memory_info_data_t;
typedef struct task_trace_memory_info * task_trace_memory_info_t;
#define TASK_TRACE_MEMORY_INFO_COUNT ((mach_msg_type_number_t) (sizeof(task_trace_memory_info_data_t) / sizeof(natural_t)))


#define TASK_WAIT_STATE_INFO 25
struct task_wait_state_info {
 uint64_t total_wait_state_time;
 uint64_t total_wait_sfi_state_time;
 uint32_t _reserved[4];
};
typedef struct task_wait_state_info task_wait_state_info_data_t;
typedef struct task_wait_state_info * task_wait_state_info_t;
#define TASK_WAIT_STATE_INFO_COUNT ((mach_msg_type_number_t) (sizeof(task_wait_state_info_data_t) / sizeof(natural_t)))


#define TASK_POWER_INFO_V2 26

typedef struct {
 uint64_t task_gpu_utilisation;
 uint64_t task_gpu_stat_reserved0;
 uint64_t task_gpu_stat_reserved1;
 uint64_t task_gpu_stat_reserved2;
} gpu_energy_data;

typedef gpu_energy_data *gpu_energy_data_t;
struct task_power_info_v2 {
 task_power_info_data_t cpu_energy;
 gpu_energy_data gpu_energy;

 uint64_t task_energy;

 uint64_t task_ptime;
 uint64_t task_pset_switches;
};

typedef struct task_power_info_v2 task_power_info_v2_data_t;
typedef struct task_power_info_v2 *task_power_info_v2_t;
#define TASK_POWER_INFO_V2_COUNT_OLD ((mach_msg_type_number_t) (sizeof (task_power_info_v2_data_t) - sizeof(uint64_t)*2) / sizeof (natural_t))

#define TASK_POWER_INFO_V2_COUNT ((mach_msg_type_number_t) (sizeof (task_power_info_v2_data_t) / sizeof (natural_t)))


#define TASK_VM_INFO_PURGEABLE_ACCOUNT 27


#define TASK_FLAGS_INFO 28
struct task_flags_info {
 uint32_t flags;
};
typedef struct task_flags_info task_flags_info_data_t;
typedef struct task_flags_info * task_flags_info_t;
#define TASK_FLAGS_INFO_COUNT ((mach_msg_type_number_t) (sizeof(task_flags_info_data_t) / sizeof (natural_t)))


#define TF_LP64 0x00000001
#define TF_64B_DATA 0x00000002

#define TASK_DEBUG_INFO_INTERNAL 29






typedef uint32_t task_exc_guard_behavior_t;


#define TASK_EXC_GUARD_NONE 0x00
#define TASK_EXC_GUARD_VM_DELIVER 0x01
#define TASK_EXC_GUARD_VM_ONCE 0x02
#define TASK_EXC_GUARD_VM_CORPSE 0x04
#define TASK_EXC_GUARD_VM_FATAL 0x08
#define TASK_EXC_GUARD_VM_ALL 0x0f

#define TASK_EXC_GUARD_MP_DELIVER 0x10
#define TASK_EXC_GUARD_MP_ONCE 0x20
#define TASK_EXC_GUARD_MP_CORPSE 0x40
#define TASK_EXC_GUARD_MP_FATAL 0x80
#define TASK_EXC_GUARD_MP_ALL 0xf0

#define TASK_EXC_GUARD_ALL 0xff






typedef uint32_t task_corpse_forking_behavior_t;

#define TASK_CORPSE_FORKING_DISABLED_MEM_DIAG 0x01






#define TASK_SCHED_TIMESHARE_INFO 10
#define TASK_SCHED_RR_INFO 11
#define TASK_SCHED_FIFO_INFO 12

#define TASK_SCHED_INFO 14

#pragma pack(pop)
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_inspect.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_inspect.h" 3 4
#define MACH_TASK_INSPECT_H 
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_inspect.h" 3 4
typedef natural_t task_inspect_flavor_t;

enum task_inspect_flavor {
 TASK_INSPECT_BASIC_COUNTS = 1,
};

struct task_inspect_basic_counts {
 uint64_t instructions;
 uint64_t cycles;
};
#define TASK_INSPECT_BASIC_COUNTS_COUNT (sizeof(struct task_inspect_basic_counts) / sizeof(natural_t))

typedef struct task_inspect_basic_counts task_inspect_basic_counts_data_t;
typedef struct task_inspect_basic_counts *task_inspect_basic_counts_t;

typedef integer_t *task_inspect_info_t;
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_policy.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_policy.h" 3 4
#define _MACH_TASK_POLICY_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_policy.h" 2 3 4
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_policy.h" 3 4
typedef natural_t task_policy_flavor_t;
typedef integer_t *task_policy_t;
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_policy.h" 3 4
#define TASK_CATEGORY_POLICY 1

#define TASK_SUPPRESSION_POLICY 3
#define TASK_POLICY_STATE 4
#define TASK_BASE_QOS_POLICY 8
#define TASK_OVERRIDE_QOS_POLICY 9
#define TASK_BASE_LATENCY_QOS_POLICY 10
#define TASK_BASE_THROUGHPUT_QOS_POLICY 11

typedef enum task_role {
 TASK_RENICED = -1,
 TASK_UNSPECIFIED = 0,
 TASK_FOREGROUND_APPLICATION = 1,
 TASK_BACKGROUND_APPLICATION = 2,
 TASK_CONTROL_APPLICATION = 3,
 TASK_GRAPHICS_SERVER = 4,
 TASK_THROTTLE_APPLICATION = 5,
 TASK_NONUI_APPLICATION = 6,
 TASK_DEFAULT_APPLICATION = 7,
 TASK_DARWINBG_APPLICATION = 8,
} task_role_t;

struct task_category_policy {
 task_role_t role;
};

typedef struct task_category_policy task_category_policy_data_t;
typedef struct task_category_policy *task_category_policy_t;

#define TASK_CATEGORY_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (task_category_policy_data_t) / sizeof (integer_t)))



enum task_latency_qos {
 LATENCY_QOS_TIER_UNSPECIFIED = 0x0,
 LATENCY_QOS_TIER_0 = ((0xFF << 16) | 1),
 LATENCY_QOS_TIER_1 = ((0xFF << 16) | 2),
 LATENCY_QOS_TIER_2 = ((0xFF << 16) | 3),
 LATENCY_QOS_TIER_3 = ((0xFF << 16) | 4),
 LATENCY_QOS_TIER_4 = ((0xFF << 16) | 5),
 LATENCY_QOS_TIER_5 = ((0xFF << 16) | 6)
};
typedef integer_t task_latency_qos_t;
enum task_throughput_qos {
 THROUGHPUT_QOS_TIER_UNSPECIFIED = 0x0,
 THROUGHPUT_QOS_TIER_0 = ((0xFE << 16) | 1),
 THROUGHPUT_QOS_TIER_1 = ((0xFE << 16) | 2),
 THROUGHPUT_QOS_TIER_2 = ((0xFE << 16) | 3),
 THROUGHPUT_QOS_TIER_3 = ((0xFE << 16) | 4),
 THROUGHPUT_QOS_TIER_4 = ((0xFE << 16) | 5),
 THROUGHPUT_QOS_TIER_5 = ((0xFE << 16) | 6),
};

#define LATENCY_QOS_LAUNCH_DEFAULT_TIER LATENCY_QOS_TIER_3
#define THROUGHPUT_QOS_LAUNCH_DEFAULT_TIER THROUGHPUT_QOS_TIER_3

typedef integer_t task_throughput_qos_t;

struct task_qos_policy {
 task_latency_qos_t task_latency_qos_tier;
 task_throughput_qos_t task_throughput_qos_tier;
};

typedef struct task_qos_policy *task_qos_policy_t;
#define TASK_QOS_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (struct task_qos_policy) / sizeof (integer_t)))



#define PROC_FLAG_DARWINBG 0x8000
#define PROC_FLAG_EXT_DARWINBG 0x10000
#define PROC_FLAG_IOS_APPLEDAEMON 0x20000
#define PROC_FLAG_IOS_IMPPROMOTION 0x80000
#define PROC_FLAG_ADAPTIVE 0x100000
#define PROC_FLAG_ADAPTIVE_IMPORTANT 0x200000
#define PROC_FLAG_IMPORTANCE_DONOR 0x400000
#define PROC_FLAG_SUPPRESSED 0x800000
#define PROC_FLAG_APPLICATION 0x1000000
#define PROC_FLAG_IOS_APPLICATION PROC_FLAG_APPLICATION
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_special_ports.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_special_ports.h" 3 4
#define _MACH_TASK_SPECIAL_PORTS_H_ 

typedef int task_special_port_t;

#define TASK_KERNEL_PORT 1

#define TASK_HOST_PORT 2

#define TASK_NAME_PORT 3

#define TASK_BOOTSTRAP_PORT 4

#define TASK_INSPECT_PORT 5

#define TASK_READ_PORT 6
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/task_special_ports.h" 3 4
#define TASK_ACCESS_PORT 9

#define TASK_DEBUG_CONTROL_PORT 10

#define TASK_RESOURCE_NOTIFY_PORT 11

#define TASK_MAX_SPECIAL_PORT TASK_RESOURCE_NOTIFY_PORT





#define task_get_kernel_port(task,port) (task_get_special_port((task), TASK_KERNEL_PORT, (port)))


#define task_set_kernel_port(task,port) (task_set_special_port((task), TASK_KERNEL_PORT, (port)))


#define task_get_host_port(task,port) (task_get_special_port((task), TASK_HOST_PORT, (port)))


#define task_set_host_port(task,port) (task_set_special_port((task), TASK_HOST_PORT, (port)))


#define task_get_bootstrap_port(task,port) (task_get_special_port((task), TASK_BOOTSTRAP_PORT, (port)))


#define task_get_debug_control_port(task,port) (task_get_special_port((task), TASK_DEBUG_CONTROL_PORT, (port)))


#define task_set_bootstrap_port(task,port) (task_set_special_port((task), TASK_BOOTSTRAP_PORT, (port)))


#define task_get_task_access_port(task,port) (task_get_special_port((task), TASK_ACCESS_PORT, (port)))


#define task_set_task_access_port(task,port) (task_set_special_port((task), TASK_ACCESS_PORT, (port)))


#define task_set_task_debug_control_port(task,port) (task_set_special_port((task), TASK_DEBUG_CONTROL_PORT, (port)))
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_info.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_info.h" 3 4
#define _MACH_THREAD_INFO_H_ 
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_info.h" 3 4
typedef natural_t thread_flavor_t;
typedef integer_t *thread_info_t;

#define THREAD_INFO_MAX (32)
typedef integer_t thread_info_data_t[(32)];




#define THREAD_BASIC_INFO 3

struct thread_basic_info {
 time_value_t user_time;
 time_value_t system_time;
 integer_t cpu_usage;
 policy_t policy;
 integer_t run_state;
 integer_t flags;
 integer_t suspend_count;
 integer_t sleep_time;

};

typedef struct thread_basic_info thread_basic_info_data_t;
typedef struct thread_basic_info *thread_basic_info_t;
#define THREAD_BASIC_INFO_COUNT ((mach_msg_type_number_t) (sizeof(thread_basic_info_data_t) / sizeof(natural_t)))


#define THREAD_IDENTIFIER_INFO 4

struct thread_identifier_info {
 uint64_t thread_id;
 uint64_t thread_handle;
 uint64_t dispatch_qaddr;
};

typedef struct thread_identifier_info thread_identifier_info_data_t;
typedef struct thread_identifier_info *thread_identifier_info_t;
#define THREAD_IDENTIFIER_INFO_COUNT ((mach_msg_type_number_t) (sizeof(thread_identifier_info_data_t) / sizeof(natural_t)))






#define TH_USAGE_SCALE 1000





#define TH_STATE_RUNNING 1
#define TH_STATE_STOPPED 2
#define TH_STATE_WAITING 3
#define TH_STATE_UNINTERRUPTIBLE 4

#define TH_STATE_HALTED 5





#define TH_FLAGS_SWAPPED 0x1
#define TH_FLAGS_IDLE 0x2
#define TH_FLAGS_GLOBAL_FORCED_IDLE 0x4




#define THREAD_EXTENDED_INFO 5
#define MAXTHREADNAMESIZE 64
struct thread_extended_info {
 uint64_t pth_user_time;
 uint64_t pth_system_time;
 int32_t pth_cpu_usage;
 int32_t pth_policy;
 int32_t pth_run_state;
 int32_t pth_flags;
 int32_t pth_sleep_time;
 int32_t pth_curpri;
 int32_t pth_priority;
 int32_t pth_maxpriority;
 char pth_name[64];
};
typedef struct thread_extended_info thread_extended_info_data_t;
typedef struct thread_extended_info * thread_extended_info_t;
#define THREAD_EXTENDED_INFO_COUNT ((mach_msg_type_number_t) (sizeof(thread_extended_info_data_t) / sizeof (natural_t)))


#define THREAD_DEBUG_INFO_INTERNAL 6


#define IO_NUM_PRIORITIES 4

#define UPDATE_IO_STATS(info,size) { info.count++; info.size += size; }





#define UPDATE_IO_STATS_ATOMIC(info,io_size) { OSIncrementAtomic64((SInt64 *)&(info.count)); OSAddAtomic64(io_size, (SInt64 *)&(info.size)); }





struct io_stat_entry {
 uint64_t count;
 uint64_t size;
};

struct io_stat_info {
 struct io_stat_entry disk_reads;
 struct io_stat_entry io_priority[4];
 struct io_stat_entry paging;
 struct io_stat_entry metadata;
 struct io_stat_entry total_io;
};

typedef struct io_stat_info *io_stat_info_t;






#define THREAD_SCHED_TIMESHARE_INFO 10
#define THREAD_SCHED_RR_INFO 11
#define THREAD_SCHED_FIFO_INFO 12
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 3 4
#define _MACH_THREAD_POLICY_H_ 
# 51 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 3 4
typedef natural_t thread_policy_flavor_t;
typedef integer_t *thread_policy_t;
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 3 4
#define THREAD_STANDARD_POLICY 1

struct thread_standard_policy {
 natural_t no_data;
};

typedef struct thread_standard_policy thread_standard_policy_data_t;
typedef struct thread_standard_policy *thread_standard_policy_t;

#define THREAD_STANDARD_POLICY_COUNT 0
# 107 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 3 4
#define THREAD_EXTENDED_POLICY 1

struct thread_extended_policy {
 boolean_t timeshare;
};

typedef struct thread_extended_policy thread_extended_policy_data_t;
typedef struct thread_extended_policy *thread_extended_policy_t;

#define THREAD_EXTENDED_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (thread_extended_policy_data_t) / sizeof (integer_t)))
# 150 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 3 4
#define THREAD_TIME_CONSTRAINT_POLICY 2

struct thread_time_constraint_policy {
 uint32_t period;
 uint32_t computation;
 uint32_t constraint;
 boolean_t preemptible;
};

typedef struct thread_time_constraint_policy
        thread_time_constraint_policy_data_t;
typedef struct thread_time_constraint_policy
        *thread_time_constraint_policy_t;

#define THREAD_TIME_CONSTRAINT_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (thread_time_constraint_policy_data_t) / sizeof (integer_t)))
# 178 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 3 4
#define THREAD_PRECEDENCE_POLICY 3

struct thread_precedence_policy {
 integer_t importance;
};

typedef struct thread_precedence_policy thread_precedence_policy_data_t;
typedef struct thread_precedence_policy *thread_precedence_policy_t;

#define THREAD_PRECEDENCE_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (thread_precedence_policy_data_t) / sizeof (integer_t)))
# 208 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_policy.h" 3 4
#define THREAD_AFFINITY_POLICY 4

struct thread_affinity_policy {
 integer_t affinity_tag;
};

#define THREAD_AFFINITY_TAG_NULL 0

typedef struct thread_affinity_policy thread_affinity_policy_data_t;
typedef struct thread_affinity_policy *thread_affinity_policy_t;

#define THREAD_AFFINITY_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (thread_affinity_policy_data_t) / sizeof (integer_t)))






#define THREAD_BACKGROUND_POLICY 5

struct thread_background_policy {
 integer_t priority;
};

#define THREAD_BACKGROUND_POLICY_DARWIN_BG 0x1000

typedef struct thread_background_policy thread_background_policy_data_t;
typedef struct thread_background_policy *thread_background_policy_t;

#define THREAD_BACKGROUND_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (thread_background_policy_data_t) / sizeof (integer_t)))



#define THREAD_LATENCY_QOS_POLICY 7
typedef integer_t thread_latency_qos_t;

struct thread_latency_qos_policy {
 thread_latency_qos_t thread_latency_qos_tier;
};

typedef struct thread_latency_qos_policy thread_latency_qos_policy_data_t;
typedef struct thread_latency_qos_policy *thread_latency_qos_policy_t;

#define THREAD_LATENCY_QOS_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (thread_latency_qos_policy_data_t) / sizeof (integer_t)))


#define THREAD_THROUGHPUT_QOS_POLICY 8
typedef integer_t thread_throughput_qos_t;

struct thread_throughput_qos_policy {
 thread_throughput_qos_t thread_throughput_qos_tier;
};

typedef struct thread_throughput_qos_policy thread_throughput_qos_policy_data_t;
typedef struct thread_throughput_qos_policy *thread_throughput_qos_policy_t;

#define THREAD_THROUGHPUT_QOS_POLICY_COUNT ((mach_msg_type_number_t) (sizeof (thread_throughput_qos_policy_data_t) / sizeof (integer_t)))
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_special_ports.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/thread_special_ports.h" 3 4
#define _MACH_THREAD_SPECIAL_PORTS_H_ 

#define THREAD_KERNEL_PORT 1

#define THREAD_INSPECT_PORT 2

#define THREAD_READ_PORT 3

#define THREAD_MAX_SPECIAL_PORT THREAD_READ_PORT




#define thread_get_kernel_port(thread,port) (thread_get_special_port((thread), THREAD_KERNEL_PORT, (port)))


#define thread_set_kernel_port(thread,port) (thread_set_special_port((thread), THREAD_KERNEL_PORT, (port)))
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/clock_types.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/clock_types.h" 3 4
#define _MACH_CLOCK_TYPES_H_ 







typedef int alarm_type_t;
typedef int sleep_type_t;
typedef int clock_id_t;
typedef int clock_flavor_t;
typedef int *clock_attr_t;
typedef int clock_res_t;




struct mach_timespec {
 unsigned int tv_sec;
 clock_res_t tv_nsec;
};
typedef struct mach_timespec mach_timespec_t;




#define SYSTEM_CLOCK 0
#define CALENDAR_CLOCK 1

#define REALTIME_CLOCK 0




#define CLOCK_GET_TIME_RES 1

#define CLOCK_ALARM_CURRES 3
#define CLOCK_ALARM_MINRES 4
#define CLOCK_ALARM_MAXRES 5

#define NSEC_PER_USEC 1000ull
#define USEC_PER_SEC 1000000ull
#define NSEC_PER_SEC 1000000000ull
#define NSEC_PER_MSEC 1000000ull

#define BAD_MACH_TIMESPEC(t) ((t)->tv_nsec < 0 || (t)->tv_nsec >= (long)NSEC_PER_SEC)



#define CMP_MACH_TIMESPEC(t1,t2) ((t1)->tv_sec > (t2)->tv_sec ? (long) +NSEC_PER_SEC : ((t1)->tv_sec < (t2)->tv_sec ? (long) -NSEC_PER_SEC : (t1)->tv_nsec - (t2)->tv_nsec))





#define ADD_MACH_TIMESPEC(t1,t2) do { if (((t1)->tv_nsec += (t2)->tv_nsec) >= (long) NSEC_PER_SEC) { (t1)->tv_nsec -= (long) NSEC_PER_SEC; (t1)->tv_sec += 1; } (t1)->tv_sec += (t2)->tv_sec; } while (0)
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/clock_types.h" 3 4
#define SUB_MACH_TIMESPEC(t1,t2) do { if (((t1)->tv_nsec -= (t2)->tv_nsec) < 0) { (t1)->tv_nsec += (long) NSEC_PER_SEC; (t1)->tv_sec -= 1; } (t1)->tv_sec -= (t2)->tv_sec; } while (0)
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/clock_types.h" 3 4
#define ALRMTYPE 0xff
#define TIME_ABSOLUTE 0x00
#define TIME_RELATIVE 0x01

#define BAD_ALRMTYPE(t) (((t) &~ TIME_RELATIVE) != 0)
# 101 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_attributes.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_attributes.h" 3 4
#define _MACH_VM_ATTRIBUTES_H_ 




typedef unsigned int vm_machine_attribute_t;

#define MATTR_CACHE 1
#define MATTR_MIGRATE 2
#define MATTR_REPLICATE 4




typedef int vm_machine_attribute_val_t;

#define MATTR_VAL_OFF 0
#define MATTR_VAL_ON 1
#define MATTR_VAL_GET 2

#define MATTR_VAL_CACHE_FLUSH 6
#define MATTR_VAL_DCACHE_FLUSH 7
#define MATTR_VAL_ICACHE_FLUSH 8
#define MATTR_VAL_CACHE_SYNC 9
#define MATTR_VAL_CACHE_SYNC 9

#define MATTR_VAL_GET_INFO 10
# 102 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_inherit.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_inherit.h" 3 4
#define _MACH_VM_INHERIT_H_ 







typedef unsigned int vm_inherit_t;





#define VM_INHERIT_SHARE ((vm_inherit_t) 0)
#define VM_INHERIT_COPY ((vm_inherit_t) 1)
#define VM_INHERIT_NONE ((vm_inherit_t) 2)
#define VM_INHERIT_DONATE_COPY ((vm_inherit_t) 3)

#define VM_INHERIT_DEFAULT VM_INHERIT_COPY
#define VM_INHERIT_LAST_VALID VM_INHERIT_NONE
# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_purgable.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_purgable.h" 3 4
#define _MACH_VM_PURGABLE_H_ 







typedef int vm_purgable_t;




#define VM_PURGABLE_SET_STATE ((vm_purgable_t) 0)
#define VM_PURGABLE_GET_STATE ((vm_purgable_t) 1)
#define VM_PURGABLE_PURGE_ALL ((vm_purgable_t) 2)
#define VM_PURGABLE_SET_STATE_FROM_KERNEL ((vm_purgable_t) 3)
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_purgable.h" 3 4
#define VM_PURGABLE_NO_AGING_SHIFT 16
#define VM_PURGABLE_NO_AGING_MASK (0x1 << VM_PURGABLE_NO_AGING_SHIFT)
#define VM_PURGABLE_NO_AGING (0x1 << VM_PURGABLE_NO_AGING_SHIFT)

#define VM_PURGABLE_DEBUG_SHIFT 12
#define VM_PURGABLE_DEBUG_MASK (0x3 << VM_PURGABLE_DEBUG_SHIFT)
#define VM_PURGABLE_DEBUG_EMPTY (0x1 << VM_PURGABLE_DEBUG_SHIFT)
#define VM_PURGABLE_DEBUG_FAULT (0x2 << VM_PURGABLE_DEBUG_SHIFT)






#define VM_VOLATILE_GROUP_SHIFT 8
#define VM_VOLATILE_GROUP_MASK (7 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_DEFAULT VM_VOLATILE_GROUP_0

#define VM_VOLATILE_GROUP_0 (0 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_1 (1 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_2 (2 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_3 (3 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_4 (4 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_5 (5 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_6 (6 << VM_VOLATILE_GROUP_SHIFT)
#define VM_VOLATILE_GROUP_7 (7 << VM_VOLATILE_GROUP_SHIFT)







#define VM_PURGABLE_BEHAVIOR_SHIFT 6
#define VM_PURGABLE_BEHAVIOR_MASK (1 << VM_PURGABLE_BEHAVIOR_SHIFT)
#define VM_PURGABLE_BEHAVIOR_FIFO (0 << VM_PURGABLE_BEHAVIOR_SHIFT)
#define VM_PURGABLE_BEHAVIOR_LIFO (1 << VM_PURGABLE_BEHAVIOR_SHIFT)







#define VM_PURGABLE_ORDERING_SHIFT 5
#define VM_PURGABLE_ORDERING_MASK (1 << VM_PURGABLE_ORDERING_SHIFT)
#define VM_PURGABLE_ORDERING_OBSOLETE (1 << VM_PURGABLE_ORDERING_SHIFT)
#define VM_PURGABLE_ORDERING_NORMAL (0 << VM_PURGABLE_ORDERING_SHIFT)





#define VM_VOLATILE_ORDER_SHIFT 4
#define VM_VOLATILE_ORDER_MASK (1 << VM_VOLATILE_ORDER_SHIFT)
#define VM_VOLATILE_MAKE_FIRST_IN_GROUP (1 << VM_VOLATILE_ORDER_SHIFT)
#define VM_VOLATILE_MAKE_LAST_IN_GROUP (0 << VM_VOLATILE_ORDER_SHIFT)




#define VM_PURGABLE_STATE_MIN 0
#define VM_PURGABLE_STATE_MAX 3
#define VM_PURGABLE_STATE_MASK 3

#define VM_PURGABLE_NONVOLATILE 0
#define VM_PURGABLE_VOLATILE 1
#define VM_PURGABLE_EMPTY 2
#define VM_PURGABLE_DENY 3

#define VM_PURGABLE_ALL_MASKS (VM_PURGABLE_STATE_MASK | VM_VOLATILE_ORDER_MASK | VM_PURGABLE_ORDERING_MASK | VM_PURGABLE_BEHAVIOR_MASK | VM_VOLATILE_GROUP_MASK | VM_PURGABLE_DEBUG_MASK | VM_PURGABLE_NO_AGING_MASK)
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_behavior.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_behavior.h" 3 4
#define _MACH_VM_BEHAVIOR_H_ 







typedef int vm_behavior_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_behavior.h" 3 4
#define VM_BEHAVIOR_DEFAULT ((vm_behavior_t) 0)
#define VM_BEHAVIOR_RANDOM ((vm_behavior_t) 1)
#define VM_BEHAVIOR_SEQUENTIAL ((vm_behavior_t) 2)
#define VM_BEHAVIOR_RSEQNTL ((vm_behavior_t) 3)





#define VM_BEHAVIOR_WILLNEED ((vm_behavior_t) 4)
#define VM_BEHAVIOR_DONTNEED ((vm_behavior_t) 5)
#define VM_BEHAVIOR_FREE ((vm_behavior_t) 6)
#define VM_BEHAVIOR_ZERO_WIRED_PAGES ((vm_behavior_t) 7)
#define VM_BEHAVIOR_REUSABLE ((vm_behavior_t) 8)
#define VM_BEHAVIOR_REUSE ((vm_behavior_t) 9)
#define VM_BEHAVIOR_CAN_REUSE ((vm_behavior_t) 10)
#define VM_BEHAVIOR_PAGEOUT ((vm_behavior_t) 11)
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_region.h" 1 3 4
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_region.h" 3 4
#define _MACH_VM_REGION_H_ 







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/vm_param.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/vm_param.h" 3 4
#define _MACH_MACHINE_VM_PARAM_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_param.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_param.h" 3 4
#define _MACH_ARM_VM_PARAM_H_ 





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_page_size.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_page_size.h" 3 4
#define _VM_PAGE_SIZE_H_ 











extern vm_size_t vm_page_size;
extern vm_size_t vm_page_mask;
extern int vm_page_shift;




#define trunc_page(x) ((x) & (~(vm_page_size - 1)))
#define round_page(x) trunc_page((x) + (vm_page_size - 1))




#define mach_vm_trunc_page(x) ((mach_vm_offset_t)(x) & ~((signed)vm_page_mask))
#define mach_vm_round_page(x) (((mach_vm_offset_t)(x) + vm_page_mask) & ~((signed)vm_page_mask))


extern vm_size_t vm_kernel_page_size ;
extern vm_size_t vm_kernel_page_mask ;
extern int vm_kernel_page_shift ;

#define trunc_page_kernel(x) ((x) & (~vm_kernel_page_mask))
#define round_page_kernel(x) trunc_page_kernel((x) + vm_kernel_page_mask)


# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_param.h" 2 3 4


#define BYTE_SIZE 8


#define PAGE_SHIFT vm_page_shift
#define PAGE_SIZE vm_page_size
#define PAGE_MASK vm_page_mask

#define VM_PAGE_SIZE vm_page_size

#define machine_ptob(x) ((x) << PAGE_SHIFT)


#define PAGE_MAX_SHIFT 14
#define PAGE_MAX_SIZE (1 << PAGE_MAX_SHIFT)
#define PAGE_MAX_MASK (PAGE_MAX_SIZE-1)

#define PAGE_MIN_SHIFT 12
#define PAGE_MIN_SIZE (1 << PAGE_MIN_SHIFT)
#define PAGE_MIN_MASK (PAGE_MIN_SIZE-1)

#define VM_MAX_PAGE_ADDRESS MACH_VM_MAX_ADDRESS
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/arm/vm_param.h" 3 4
#define VM_MIN_ADDRESS ((vm_address_t) 0x0000000000000000ULL)
#define VM_MAX_ADDRESS ((vm_address_t) 0x0000000080000000ULL)


#define MACH_VM_MIN_ADDRESS_RAW 0x0ULL
#define MACH_VM_MAX_ADDRESS_RAW 0x00007FFFFE000000ULL

#define MACH_VM_MIN_ADDRESS ((mach_vm_offset_t) MACH_VM_MIN_ADDRESS_RAW)
#define MACH_VM_MAX_ADDRESS ((mach_vm_offset_t) MACH_VM_MAX_ADDRESS_RAW)

#define MACH_VM_MIN_GPU_CARVEOUT_ADDRESS_RAW 0x0000001000000000ULL
#define MACH_VM_MAX_GPU_CARVEOUT_ADDRESS_RAW 0x0000007000000000ULL
#define MACH_VM_MIN_GPU_CARVEOUT_ADDRESS ((mach_vm_offset_t) MACH_VM_MIN_GPU_CARVEOUT_ADDRESS_RAW)
#define MACH_VM_MAX_GPU_CARVEOUT_ADDRESS ((mach_vm_offset_t) MACH_VM_MAX_GPU_CARVEOUT_ADDRESS_RAW)





#define VM_MAP_MIN_ADDRESS VM_MIN_ADDRESS
#define VM_MAP_MAX_ADDRESS VM_MAX_ADDRESS




#define SWI_SYSCALL 0x80
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/machine/vm_param.h" 2 3 4
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_region.h" 2 3 4





#pragma pack(push, 4)




typedef uint32_t vm32_object_id_t;







#define VM_REGION_INFO_MAX (1024)
typedef int *vm_region_info_t;
typedef int *vm_region_info_64_t;
typedef int *vm_region_recurse_info_t;
typedef int *vm_region_recurse_info_64_t;
typedef int vm_region_flavor_t;
typedef int vm_region_info_data_t[(1024)];

#define VM_REGION_BASIC_INFO_64 9
struct vm_region_basic_info_64 {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 boolean_t shared;
 boolean_t reserved;
 memory_object_offset_t offset;
 vm_behavior_t behavior;
 unsigned short user_wired_count;
};
typedef struct vm_region_basic_info_64 *vm_region_basic_info_64_t;
typedef struct vm_region_basic_info_64 vm_region_basic_info_data_64_t;

#define VM_REGION_BASIC_INFO_COUNT_64 ((mach_msg_type_number_t) (sizeof(vm_region_basic_info_data_64_t)/sizeof(int)))







#define VM_REGION_BASIC_INFO 10






struct vm_region_basic_info {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 boolean_t shared;
 boolean_t reserved;
 uint32_t offset;
 vm_behavior_t behavior;
 unsigned short user_wired_count;
};

typedef struct vm_region_basic_info *vm_region_basic_info_t;
typedef struct vm_region_basic_info vm_region_basic_info_data_t;

#define VM_REGION_BASIC_INFO_COUNT ((mach_msg_type_number_t) (sizeof(vm_region_basic_info_data_t)/sizeof(int)))


#define SM_COW 1
#define SM_PRIVATE 2
#define SM_EMPTY 3
#define SM_SHARED 4
#define SM_TRUESHARED 5
#define SM_PRIVATE_ALIASED 6
#define SM_SHARED_ALIASED 7
#define SM_LARGE_PAGE 8
# 140 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_region.h" 3 4
#define VM_REGION_EXTENDED_INFO 13
struct vm_region_extended_info {
 vm_prot_t protection;
 unsigned int user_tag;
 unsigned int pages_resident;
 unsigned int pages_shared_now_private;
 unsigned int pages_swapped_out;
 unsigned int pages_dirtied;
 unsigned int ref_count;
 unsigned short shadow_depth;
 unsigned char external_pager;
 unsigned char share_mode;
 unsigned int pages_reusable;
};
typedef struct vm_region_extended_info *vm_region_extended_info_t;
typedef struct vm_region_extended_info vm_region_extended_info_data_t;
#define VM_REGION_EXTENDED_INFO_COUNT ((mach_msg_type_number_t) (sizeof (vm_region_extended_info_data_t) / sizeof (natural_t)))






#define VM_REGION_TOP_INFO 12

struct vm_region_top_info {
 unsigned int obj_id;
 unsigned int ref_count;
 unsigned int private_pages_resident;
 unsigned int shared_pages_resident;
 unsigned char share_mode;
};

typedef struct vm_region_top_info *vm_region_top_info_t;
typedef struct vm_region_top_info vm_region_top_info_data_t;

#define VM_REGION_TOP_INFO_COUNT ((mach_msg_type_number_t) (sizeof(vm_region_top_info_data_t) / sizeof(natural_t)))
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_region.h" 3 4
struct vm_region_submap_info {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 uint32_t offset;
 unsigned int user_tag;
 unsigned int pages_resident;
 unsigned int pages_shared_now_private;
 unsigned int pages_swapped_out;
 unsigned int pages_dirtied;
 unsigned int ref_count;
 unsigned short shadow_depth;
 unsigned char external_pager;
 unsigned char share_mode;
 boolean_t is_submap;
 vm_behavior_t behavior;
 vm32_object_id_t object_id;
 unsigned short user_wired_count;
};

typedef struct vm_region_submap_info *vm_region_submap_info_t;
typedef struct vm_region_submap_info vm_region_submap_info_data_t;

#define VM_REGION_SUBMAP_INFO_COUNT ((mach_msg_type_number_t) (sizeof(vm_region_submap_info_data_t) / sizeof(natural_t)))



struct vm_region_submap_info_64 {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 memory_object_offset_t offset;
 unsigned int user_tag;
 unsigned int pages_resident;
 unsigned int pages_shared_now_private;
 unsigned int pages_swapped_out;
 unsigned int pages_dirtied;
 unsigned int ref_count;
 unsigned short shadow_depth;
 unsigned char external_pager;
 unsigned char share_mode;
 boolean_t is_submap;
 vm_behavior_t behavior;
 vm32_object_id_t object_id;
 unsigned short user_wired_count;
 unsigned int pages_reusable;
 vm_object_id_t object_id_full;
};

typedef struct vm_region_submap_info_64 *vm_region_submap_info_64_t;
typedef struct vm_region_submap_info_64 vm_region_submap_info_data_64_t;

#define VM_REGION_SUBMAP_INFO_V2_SIZE (sizeof (vm_region_submap_info_data_64_t))

#define VM_REGION_SUBMAP_INFO_V1_SIZE (VM_REGION_SUBMAP_INFO_V2_SIZE - sizeof (vm_object_id_t) )


#define VM_REGION_SUBMAP_INFO_V0_SIZE (VM_REGION_SUBMAP_INFO_V1_SIZE - sizeof (unsigned int) )



#define VM_REGION_SUBMAP_INFO_V2_COUNT_64 ((mach_msg_type_number_t) (VM_REGION_SUBMAP_INFO_V2_SIZE / sizeof (natural_t)))


#define VM_REGION_SUBMAP_INFO_V1_COUNT_64 ((mach_msg_type_number_t) (VM_REGION_SUBMAP_INFO_V1_SIZE / sizeof (natural_t)))


#define VM_REGION_SUBMAP_INFO_V0_COUNT_64 ((mach_msg_type_number_t) (VM_REGION_SUBMAP_INFO_V0_SIZE / sizeof (natural_t)))




#define VM_REGION_SUBMAP_INFO_COUNT_64 VM_REGION_SUBMAP_INFO_V2_COUNT_64

struct vm_region_submap_short_info_64 {
 vm_prot_t protection;
 vm_prot_t max_protection;
 vm_inherit_t inheritance;
 memory_object_offset_t offset;
 unsigned int user_tag;
 unsigned int ref_count;
 unsigned short shadow_depth;
 unsigned char external_pager;
 unsigned char share_mode;
 boolean_t is_submap;
 vm_behavior_t behavior;
 vm32_object_id_t object_id;
 unsigned short user_wired_count;
};

typedef struct vm_region_submap_short_info_64 *vm_region_submap_short_info_64_t;
typedef struct vm_region_submap_short_info_64 vm_region_submap_short_info_data_64_t;

#define VM_REGION_SUBMAP_SHORT_INFO_COUNT_64 ((mach_msg_type_number_t) (sizeof (vm_region_submap_short_info_data_64_t) / sizeof (natural_t)))



struct mach_vm_read_entry {
 mach_vm_address_t address;
 mach_vm_size_t size;
};

struct vm_read_entry {
 vm_address_t address;
 vm_size_t size;
};
# 317 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/vm_region.h" 3 4
#define VM_MAP_ENTRY_MAX (256)

typedef struct mach_vm_read_entry mach_vm_read_entry_t[(256)];
typedef struct vm_read_entry vm_read_entry_t[(256)];




#pragma pack(pop)


#define VM_PAGE_INFO_MAX 
typedef int *vm_page_info_t;
typedef int vm_page_info_data_t[];
typedef int vm_page_info_flavor_t;

#define VM_PAGE_INFO_BASIC 1
struct vm_page_info_basic {
 int disposition;
 int ref_count;
 vm_object_id_t object_id;
 memory_object_offset_t offset;
 int depth;
 int __pad;
};
typedef struct vm_page_info_basic *vm_page_info_basic_t;
typedef struct vm_page_info_basic vm_page_info_basic_data_t;

#define VM_PAGE_INFO_BASIC_COUNT ((mach_msg_type_number_t) (sizeof(vm_page_info_basic_data_t)/sizeof(int)))
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kmod.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kmod.h" 3 4
#define _MACH_KMOD_H_ 














#define KMOD_MAX_NAME 64

#define KMOD_RETURN_SUCCESS KERN_SUCCESS
#define KMOD_RETURN_FAILURE KERN_FAILURE

typedef int kmod_t;

struct kmod_info;
typedef kern_return_t kmod_start_func_t(struct kmod_info * ki, void * data);
typedef kern_return_t kmod_stop_func_t(struct kmod_info * ki, void * data);
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kmod.h" 3 4
#pragma pack(push, 4)


typedef struct kmod_reference {
 struct kmod_reference * next;
 struct kmod_info * info;
} kmod_reference_t;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kmod.h" 3 4
typedef struct kmod_info {
 struct kmod_info * next;
 int32_t info_version;
 uint32_t id;
 char name[64];
 char version[64];
 int32_t reference_count;
 kmod_reference_t * reference_list;
 vm_address_t address;
 vm_size_t size;
 vm_size_t hdr_size;
 kmod_start_func_t * start;
 kmod_stop_func_t * stop;
} kmod_info_t;



typedef struct kmod_info_32_v1 {
 uint32_t next_addr;
 int32_t info_version;
 uint32_t id;
 uint8_t name[64];
 uint8_t version[64];
 int32_t reference_count;
 uint32_t reference_list_addr;
 uint32_t address;
 uint32_t size;
 uint32_t hdr_size;
 uint32_t start_addr;
 uint32_t stop_addr;
} kmod_info_32_v1_t;



typedef struct kmod_info_64_v1 {
 uint64_t next_addr;
 int32_t info_version;
 uint32_t id;
 uint8_t name[64];
 uint8_t version[64];
 int32_t reference_count;
 uint64_t reference_list_addr;
 uint64_t address;
 uint64_t size;
 uint64_t hdr_size;
 uint64_t start_addr;
 uint64_t stop_addr;
} kmod_info_64_v1_t;

#pragma pack(pop)







#define KMOD_INFO_NAME kmod_info
#define KMOD_INFO_VERSION 1

#define KMOD_DECL(name,version) static kmod_start_func_t name ## _module_start; static kmod_stop_func_t name ## _module_stop; kmod_info_t KMOD_INFO_NAME = { 0, KMOD_INFO_VERSION, -1U, { #name }, { version }, -1, 0, 0, 0, 0, name ## _module_start, name ## _module_stop };







#define KMOD_EXPLICIT_DECL(name,version,start,stop) kmod_info_t KMOD_INFO_NAME = { 0, KMOD_INFO_VERSION, -1U, { #name }, { version }, -1, 0, 0, 0, 0, start, stop };
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/kmod.h" 3 4
typedef void * kmod_args_t;
typedef int kmod_control_flavor_t;
typedef kmod_info_t * kmod_info_array_t;


# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/dyld_kernel.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/dyld_kernel.h" 3 4
#define _MACH_DYLIB_INFO_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsid_t.h" 3 4
#define _FSID_T 

typedef struct fsid { int32_t val[2]; } fsid_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/dyld_kernel.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsobj_id_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_fsobj_id_t.h" 3 4
#define _FSOBJ_ID_T 



typedef struct fsobj_id {
 u_int32_t fid_objno;
 u_int32_t fid_generation;
} fsobj_id_t;
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/dyld_kernel.h" 2 3 4






struct dyld_kernel_image_info {
 uuid_t uuid;
 fsobj_id_t fsobjid;
 fsid_t fsid;
 uint64_t load_addr;
};

struct dyld_kernel_process_info {
 struct dyld_kernel_image_info cache_image_info;
 uint64_t timestamp;
 uint32_t imageCount;
 uint32_t initialImageCount;
 uint8_t dyldState;
 boolean_t no_cache;
 boolean_t private_cache;
};



typedef struct dyld_kernel_image_info dyld_kernel_image_info_t;
typedef struct dyld_kernel_process_info dyld_kernel_process_info_t;
typedef dyld_kernel_image_info_t *dyld_kernel_image_info_array_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 2 3 4






typedef mach_port_t task_t;
typedef mach_port_t task_name_t;
typedef mach_port_t task_policy_set_t;
typedef mach_port_t task_policy_get_t;
typedef mach_port_t task_inspect_t;
typedef mach_port_t task_read_t;
typedef mach_port_t task_suspension_token_t;
typedef mach_port_t thread_t;
typedef mach_port_t thread_act_t;
typedef mach_port_t thread_inspect_t;
typedef mach_port_t thread_read_t;
typedef mach_port_t ipc_space_t;
typedef mach_port_t ipc_space_read_t;
typedef mach_port_t ipc_space_inspect_t;
typedef mach_port_t coalition_t;
typedef mach_port_t host_t;
typedef mach_port_t host_priv_t;
typedef mach_port_t host_security_t;
typedef mach_port_t processor_t;
typedef mach_port_t processor_set_t;
typedef mach_port_t processor_set_control_t;
typedef mach_port_t semaphore_t;
typedef mach_port_t lock_set_t;
typedef mach_port_t ledger_t;
typedef mach_port_t alarm_t;
typedef mach_port_t clock_serv_t;
typedef mach_port_t clock_ctrl_t;
typedef mach_port_t arcade_register_t;
typedef mach_port_t ipc_eventlink_t;
typedef mach_port_t eventlink_port_pair_t[2];
typedef mach_port_t suid_cred_t;
typedef mach_port_t task_id_token_t;







typedef processor_set_t processor_set_name_t;




typedef mach_port_t clock_reply_t;
typedef mach_port_t bootstrap_t;
typedef mach_port_t mem_entry_name_port_t;
typedef mach_port_t exception_handler_t;
typedef exception_handler_t *exception_handler_array_t;
typedef mach_port_t vm_task_entry_t;
typedef mach_port_t io_master_t;
typedef mach_port_t UNDServerRef;
typedef mach_port_t mach_eventlink_t;

typedef ipc_info_port_t exception_handler_info_t;
# 181 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/mach/mach_types.h" 3 4
typedef task_t *task_array_t;
typedef thread_t *thread_array_t;
typedef processor_set_t *processor_set_array_t;
typedef processor_set_t *processor_set_name_array_t;
typedef processor_t *processor_array_t;
typedef thread_act_t *thread_act_array_t;
typedef ledger_t *ledger_array_t;







typedef task_t task_port_t;
typedef task_array_t task_port_array_t;
typedef thread_t thread_port_t;
typedef thread_array_t thread_port_array_t;
typedef ipc_space_t ipc_space_port_t;
typedef host_t host_name_t;
typedef host_t host_name_port_t;
typedef processor_set_t processor_set_port_t;
typedef processor_set_t processor_set_name_port_t;
typedef processor_set_array_t processor_set_name_port_array_t;
typedef processor_set_t processor_set_control_port_t;
typedef processor_t processor_port_t;
typedef processor_array_t processor_port_array_t;
typedef thread_act_t thread_act_port_t;
typedef thread_act_array_t thread_act_port_array_t;
typedef semaphore_t semaphore_port_t;
typedef lock_set_t lock_set_port_t;
typedef ledger_t ledger_port_t;
typedef ledger_array_t ledger_port_array_t;
typedef alarm_t alarm_port_t;
typedef clock_serv_t clock_serv_port_t;
typedef clock_ctrl_t clock_ctrl_port_t;
typedef exception_handler_t exception_port_t;
typedef exception_handler_array_t exception_port_arrary_t;
typedef char vfs_path_t[4096];
typedef char nspace_path_t[1024];
typedef char nspace_name_t[1024];
typedef char suid_cred_path_t[1024];
typedef uint32_t suid_cred_uid_t;

#define TASK_NULL ((task_t) 0)
#define TASK_NAME_NULL ((task_name_t) 0)
#define TASK_INSPECT_NULL ((task_inspect_t) 0)
#define TASK_READ_NULL ((task_read_t) 0)
#define THREAD_NULL ((thread_t) 0)
#define THREAD_INSPECT_NULL ((thread_inspect_t) 0)
#define THREAD_READ_NULL ((thread_read_t) 0)
#define TID_NULL ((uint64_t) 0)
#define THR_ACT_NULL ((thread_act_t) 0)
#define IPC_SPACE_NULL ((ipc_space_t) 0)
#define IPC_SPACE_READ_NULL ((ipc_space_read_t) 0)
#define IPC_SPACE_INSPECT_NULL ((ipc_space_inspect_t) 0)
#define COALITION_NULL ((coalition_t) 0)
#define HOST_NULL ((host_t) 0)
#define HOST_PRIV_NULL ((host_priv_t) 0)
#define HOST_SECURITY_NULL ((host_security_t) 0)
#define PROCESSOR_SET_NULL ((processor_set_t) 0)
#define PROCESSOR_NULL ((processor_t) 0)
#define SEMAPHORE_NULL ((semaphore_t) 0)
#define LOCK_SET_NULL ((lock_set_t) 0)
#define LEDGER_NULL ((ledger_t) 0)
#define ALARM_NULL ((alarm_t) 0)
#define CLOCK_NULL ((clock_t) 0)
#define UND_SERVER_NULL ((UNDServerRef) 0)
#define ARCADE_REG_NULL ((arcade_register_t) 0)
#define MACH_EVENTLINK_NULL ((mach_eventlink_t) 0)
#define IPC_EVENTLINK_NULL ((ipc_eventlink_t) 0)
#define SUID_CRED_NULL ((suid_cred_t) 0)
#define TASK_ID_TOKEN_NULL ((task_id_token_t) 0)





typedef unsigned int mach_task_flavor_t;
#define TASK_FLAVOR_CONTROL 0
#define TASK_FLAVOR_READ 1
#define TASK_FLAVOR_INSPECT 2
#define TASK_FLAVOR_NAME 3

#define TASK_FLAVOR_MAX TASK_FLAVOR_NAME


typedef unsigned int mach_thread_flavor_t;
#define THREAD_FLAVOR_CONTROL 0
#define THREAD_FLAVOR_READ 1
#define THREAD_FLAVOR_INSPECT 2

#define THREAD_FLAVOR_MAX THREAD_FLAVOR_INSPECT


typedef natural_t ledger_item_t;
#define LEDGER_ITEM_INFINITY ((ledger_item_t) (~0))

typedef int64_t ledger_amount_t;
#define LEDGER_LIMIT_INFINITY ((ledger_amount_t)((1ULL << 63) - 1))

typedef mach_vm_offset_t *emulation_vector_t;
typedef char *user_subsystem_t;

typedef char *labelstr_t;
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/malloc/malloc.h" 2 3 4
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/malloc/malloc.h" 3 4
#define MALLOC_ZONE_FN_PTR(fn) fn
#define MALLOC_INTROSPECT_FN_PTR(fn) fn
#define MALLOC_INTROSPECT_TBL_PTR(ptr) ptr





typedef struct _malloc_zone_t {


    void *reserved1;
    void *reserved2;
    size_t (* size)(struct _malloc_zone_t *zone, const void *ptr);
    void *(* malloc)(struct _malloc_zone_t *zone, size_t size);
    void *(* calloc)(struct _malloc_zone_t *zone, size_t num_items, size_t size);
    void *(* valloc)(struct _malloc_zone_t *zone, size_t size);
    void (* free)(struct _malloc_zone_t *zone, void *ptr);
    void *(* realloc)(struct _malloc_zone_t *zone, void *ptr, size_t size);
    void (* destroy)(struct _malloc_zone_t *zone);
    const char *zone_name;


    unsigned (* batch_malloc)(struct _malloc_zone_t *zone, size_t size, void **results, unsigned num_requested);
    void (* batch_free)(struct _malloc_zone_t *zone, void **to_be_freed, unsigned num_to_be_freed);

    struct malloc_introspection_t * introspect;
    unsigned version;


    void *(* memalign)(struct _malloc_zone_t *zone, size_t alignment, size_t size);


    void (* free_definite_size)(struct _malloc_zone_t *zone, void *ptr, size_t size);


    size_t (* pressure_relief)(struct _malloc_zone_t *zone, size_t goal);






    boolean_t (* claimed_address)(struct _malloc_zone_t *zone, void *ptr);
} malloc_zone_t;



extern malloc_zone_t *malloc_default_zone(void);


extern malloc_zone_t *malloc_create_zone(vm_size_t start_size, unsigned flags);


extern void malloc_destroy_zone(malloc_zone_t *zone);




extern void *malloc_zone_malloc(malloc_zone_t *zone, size_t size) __attribute__((alloc_size(2)));


extern void *malloc_zone_calloc(malloc_zone_t *zone, size_t num_items, size_t size) __attribute__((alloc_size(2,3)));


extern void *malloc_zone_valloc(malloc_zone_t *zone, size_t size) __attribute__((alloc_size(2)));


extern void malloc_zone_free(malloc_zone_t *zone, void *ptr);


extern void *malloc_zone_realloc(malloc_zone_t *zone, void *ptr, size_t size) __attribute__((alloc_size(3)));


extern malloc_zone_t *malloc_zone_from_ptr(const void *ptr);



extern size_t malloc_size(const void *ptr);


extern size_t malloc_good_size(size_t size);


extern void *malloc_zone_memalign(malloc_zone_t *zone, size_t alignment, size_t size) __attribute__((alloc_size(3))) ;
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/malloc/malloc.h" 3 4
extern unsigned malloc_zone_batch_malloc(malloc_zone_t *zone, size_t size, void **results, unsigned num_requested);


extern void malloc_zone_batch_free(malloc_zone_t *zone, void **to_be_freed, unsigned num);




extern malloc_zone_t *malloc_default_purgeable_zone(void) ;


extern void malloc_make_purgeable(void *ptr) ;


extern int malloc_make_nonpurgeable(void *ptr) ;






extern void malloc_zone_register(malloc_zone_t *zone);





extern void malloc_zone_unregister(malloc_zone_t *zone);



extern void malloc_set_zone_name(malloc_zone_t *zone, const char *name);


extern const char *malloc_get_zone_name(malloc_zone_t *zone);


size_t malloc_zone_pressure_relief(malloc_zone_t *zone, size_t goal) ;







typedef struct {
    vm_address_t address;
    vm_size_t size;
} vm_range_t;

typedef struct malloc_statistics_t {
    unsigned blocks_in_use;
    size_t size_in_use;
    size_t max_size_in_use;
    size_t size_allocated;
} malloc_statistics_t;

typedef kern_return_t memory_reader_t(task_t remote_task, vm_address_t remote_address, vm_size_t size, void **local_memory);



#define MALLOC_PTR_IN_USE_RANGE_TYPE 1
#define MALLOC_PTR_REGION_RANGE_TYPE 2
#define MALLOC_ADMIN_REGION_RANGE_TYPE 4
#define MALLOC_ZONE_SPECIFIC_FLAGS 0xff00

typedef void vm_range_recorder_t(task_t, void *, unsigned type, vm_range_t *, unsigned);



typedef void print_task_printer_t(const char *fmt, ...) __attribute__((__format__ (__printf__, 1, 2)));

typedef struct malloc_introspection_t {
 kern_return_t (* enumerator)(task_t task, void *, unsigned type_mask, vm_address_t zone_address, memory_reader_t reader, vm_range_recorder_t recorder);
 size_t (* good_size)(malloc_zone_t *zone, size_t size);
 boolean_t (* check)(malloc_zone_t *zone);
 void (* print)(malloc_zone_t *zone, boolean_t verbose);
 void (* log)(malloc_zone_t *zone, void *address);
 void (* force_lock)(malloc_zone_t *zone);
 void (* force_unlock)(malloc_zone_t *zone);
 void (* statistics)(malloc_zone_t *zone, malloc_statistics_t *stats);
 boolean_t (* zone_locked)(malloc_zone_t *zone);


 boolean_t (* enable_discharge_checking)(malloc_zone_t *zone);
 void (* disable_discharge_checking)(malloc_zone_t *zone);
 void (* discharge)(malloc_zone_t *zone, void *memory);



    void *enumerate_unavailable_without_blocks;

 void (* reinit_lock)(malloc_zone_t *zone);
 void (* print_task)(task_t task, unsigned level, vm_address_t zone_address, memory_reader_t reader, print_task_printer_t printer);
 void (* task_statistics)(task_t task, vm_address_t zone_address, memory_reader_t reader, malloc_statistics_t *stats);
} malloc_introspection_t;



#define MALLOC_VERBOSE_PRINT_LEVEL 2

extern void malloc_printf(const char *format, ...);







extern kern_return_t malloc_get_all_zones(task_t task, memory_reader_t reader, vm_address_t **addresses, unsigned *count);





extern void malloc_zone_print_ptr_info(void *ptr);


extern boolean_t malloc_zone_check(malloc_zone_t *zone);


extern void malloc_zone_print(malloc_zone_t *zone, boolean_t verbose);


extern void malloc_zone_statistics(malloc_zone_t *zone, malloc_statistics_t *stats);


extern void malloc_zone_log(malloc_zone_t *zone, void *address);





struct mstats {
    size_t bytes_total;
    size_t chunks_used;
    size_t bytes_used;
    size_t chunks_free;
    size_t bytes_free;
};

extern struct mstats mstats(void);

extern boolean_t malloc_zone_enable_discharge_checking(malloc_zone_t *zone) ;


extern void malloc_zone_disable_discharge_checking(malloc_zone_t *zone) ;


extern void malloc_zone_discharge(malloc_zone_t *zone, void *memory) ;
# 309 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/malloc/malloc.h" 3 4
extern void malloc_zone_enumerate_discharged_pointers(malloc_zone_t *zone, void *) ;
# 339 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/malloc/malloc.h" 3 4

# 22975 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2




# 22978 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static malloc_zone_t* _sqliteZone_;
#define SQLITE_MALLOC(x) malloc_zone_malloc(_sqliteZone_, (x))
#define SQLITE_FREE(x) malloc_zone_free(_sqliteZone_, (x));
#define SQLITE_REALLOC(x,y) malloc_zone_realloc(_sqliteZone_, (x), (y))
#define SQLITE_MALLOCSIZE(x) (_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,x) : malloc_size(x))
# 23043 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3MemMalloc(int nByte){

  void *p;
  ;
  p = malloc_zone_malloc(_sqliteZone_, (nByte));
  if( p==0 ){
    ;
    sqlite3_log(7, "failed to allocate %u bytes of memory", nByte);
  }
  return p;
# 23067 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
# 23077 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3MemFree(void *pPrior){

  malloc_zone_free(_sqliteZone_, (pPrior));;






}





static int sqlite3MemSize(void *pPrior){

  ((void)0);
  return (int)(_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,pPrior) : malloc_size(pPrior));







}
# 23115 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3MemRealloc(void *pPrior, int nByte){

  void *p = malloc_zone_realloc(_sqliteZone_, (pPrior), (nByte));
  if( p==0 ){
    ;
    sqlite3_log(7,
      "failed memory resize %u to %u bytes",
      (_sqliteZone_ ? _sqliteZone_->size(_sqliteZone_,pPrior) : malloc_size(pPrior)), nByte);
  }
  return p;
# 23142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}




static int sqlite3MemRoundup(int n){
  return (((n)+7)&~7);
}




static int sqlite3MemInit(void *NotUsed){

  int cpuCount;
  size_t len;
  if( _sqliteZone_ ){
    return 0;
  }
  len = sizeof(cpuCount);

  sysctlbyname("hw.ncpu", &cpuCount, &len, ((void *)0), 0);
  if( cpuCount>1 ){

    _sqliteZone_ = malloc_default_zone();
  }else{


    _sqliteZone_ = malloc_create_zone(4096, 0);
    malloc_set_zone_name(_sqliteZone_, "Sqlite_Heap");
  }

  (void)(NotUsed);
  return 0;
}




static void sqlite3MemShutdown(void *NotUsed){
  (void)(NotUsed);
  return;
}







static void sqlite3MemSetDefault(void){
  static const sqlite3_mem_methods defaultMethods = {
     sqlite3MemMalloc,
     sqlite3MemFree,
     sqlite3MemRealloc,
     sqlite3MemSize,
     sqlite3MemRoundup,
     sqlite3MemInit,
     sqlite3MemShutdown,
     0
  };
  sqlite3_config(4, &defaultMethods);
}
# 25228 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3MutexInit(void){
  int rc = 0;
  if( !sqlite3Config.mutex.xMutexAlloc ){





    sqlite3_mutex_methods const *pFrom;
    sqlite3_mutex_methods *pTo = &sqlite3Config.mutex;

    if( sqlite3Config.bCoreMutex ){



      pFrom = sqlite3DefaultMutex();

    }else{
      pFrom = sqlite3NoopMutex();
    }
    pTo->xMutexInit = pFrom->xMutexInit;
    pTo->xMutexEnd = pFrom->xMutexEnd;
    pTo->xMutexFree = pFrom->xMutexFree;
    pTo->xMutexEnter = pFrom->xMutexEnter;
    pTo->xMutexTry = pFrom->xMutexTry;
    pTo->xMutexLeave = pFrom->xMutexLeave;
    pTo->xMutexHeld = pFrom->xMutexHeld;
    pTo->xMutexNotheld = pFrom->xMutexNotheld;
    sqlite3MemoryBarrier();
    pTo->xMutexAlloc = pFrom->xMutexAlloc;
  }
  ((void)0);
  rc = sqlite3Config.mutex.xMutexInit();





  return rc;
}





static int sqlite3MutexEnd(void){
  int rc = 0;
  if( sqlite3Config.mutex.xMutexEnd ){
    rc = sqlite3Config.mutex.xMutexEnd();
  }





  return rc;
}




 sqlite3_mutex *sqlite3_mutex_alloc(int id){

  if( id<=1 && sqlite3_initialize() ) return 0;
  if( id>1 && sqlite3MutexInit() ) return 0;

  ((void)0);
  return sqlite3Config.mutex.xMutexAlloc(id);
}

static sqlite3_mutex *sqlite3MutexAlloc(int id){
  if( !sqlite3Config.bCoreMutex ){
    return 0;
  }
  ((void)0);
  ((void)0);
  return sqlite3Config.mutex.xMutexAlloc(id);
}




 void sqlite3_mutex_free(sqlite3_mutex *p){
  if( p ){
    ((void)0);
    sqlite3Config.mutex.xMutexFree(p);
  }
}





 void sqlite3_mutex_enter(sqlite3_mutex *p){
  if( p ){
    ((void)0);
    sqlite3Config.mutex.xMutexEnter(p);
  }
}





 int sqlite3_mutex_try(sqlite3_mutex *p){
  int rc = 0;
  if( p ){
    ((void)0);
    return sqlite3Config.mutex.xMutexTry(p);
  }
  return rc;
}







 void sqlite3_mutex_leave(sqlite3_mutex *p){
  if( p ){
    ((void)0);
    sqlite3Config.mutex.xMutexLeave(p);
  }
}
# 25410 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int noopMutexInit(void){ return 0; }
static int noopMutexEnd(void){ return 0; }
static sqlite3_mutex *noopMutexAlloc(int id){
  (void)(id);
  return (sqlite3_mutex*)8;
}
static void noopMutexFree(sqlite3_mutex *p){ (void)(p); return; }
static void noopMutexEnter(sqlite3_mutex *p){ (void)(p); return; }
static int noopMutexTry(sqlite3_mutex *p){
  (void)(p);
  return 0;
}
static void noopMutexLeave(sqlite3_mutex *p){ (void)(p); return; }

static sqlite3_mutex_methods const *sqlite3NoopMutex(void){
  static const sqlite3_mutex_methods sMutex = {
    noopMutexInit,
    noopMutexEnd,
    noopMutexAlloc,
    noopMutexFree,
    noopMutexEnter,
    noopMutexTry,
    noopMutexLeave,

    0,
    0,
  };

  return &sMutex;
}
# 25615 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 1 3 4
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
#define _PTHREAD_H 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_types.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_types.h" 3 4
#define __TYPES_H_ 





#define __strfmonlike(fmtarg,firstvararg) __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))

#define __strftimelike(fmtarg) __attribute__((__format__ (__strftime__, fmtarg, 0)))







# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;





#define __DARWIN_WCHAR_MAX __WCHAR_MAX__





#define __DARWIN_WCHAR_MIN (-0x7fffffff - 1)



#define __DARWIN_WEOF ((__darwin_wint_t)-1)





#define _FORTIFY_SOURCE 2
# 56 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/sched.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/sched.h" 3 4
#define _SCHED_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/pthread_impl.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/pthread_impl.h" 3 4
#define _PTHREAD_IMPL_H_ 
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/pthread_impl.h" 3 4
#define _PTHREAD_MUTEX_SIG_init 0x32AAABA7

#define _PTHREAD_ERRORCHECK_MUTEX_SIG_init 0x32AAABA1
#define _PTHREAD_RECURSIVE_MUTEX_SIG_init 0x32AAABA2
#define _PTHREAD_FIRSTFIT_MUTEX_SIG_init 0x32AAABA3

#define _PTHREAD_COND_SIG_init 0x3CB0B1BB
#define _PTHREAD_ONCE_SIG_init 0x30B1BCBA
#define _PTHREAD_RWLOCK_SIG_init 0x2DA8B3B4




#define SCHED_OTHER 1
#define SCHED_FIFO 4
#define SCHED_RR 2

#define __SCHED_PARAM_SIZE__ 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/sched.h" 2 3 4






struct sched_param { int sched_priority; char __opaque[4]; };




extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);

# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 2 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4
#define _PTHREAD_QOS_H 
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/qos.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/qos.h" 3 4
#define _SYS_QOS_H 
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/qos.h" 3 4
#define __QOS_ENUM(name,type,...) enum { __VA_ARGS__ }; typedef type name ##_t
#define __QOS_CLASS_AVAILABLE(...) 
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/qos.h" 3 4
enum { QOS_CLASS_USER_INTERACTIVE = 0x21, QOS_CLASS_USER_INITIATED = 0x19, QOS_CLASS_DEFAULT = 0x15, QOS_CLASS_UTILITY = 0x11, QOS_CLASS_BACKGROUND = 0x09, QOS_CLASS_UNSPECIFIED = 0x00, }; typedef unsigned int qos_class_t
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/qos.h" 3 4
 ;

#undef __QOS_ENUM







#define QOS_MIN_RELATIVE_PRIORITY (-15)






# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/qos.h" 3 4

qos_class_t
qos_class_self(void);
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/qos.h" 3 4

qos_class_t
qos_class_main(void);


# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 2 3 4







# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_attr_get_qos_class_np(pthread_attr_t * restrict __attr,
  qos_class_t * restrict __qos_class,
  int * restrict __relative_priority);
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * restrict __qos_class,
  int * restrict __relative_priority);
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4
typedef struct pthread_override_s* pthread_override_t;
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4

pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_override_qos_class_end_np(pthread_override_t );


# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 2 3 4
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4

# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
#define pthread_cleanup_push(func,val) { struct __darwin_pthread_handler_rec __handler; pthread_t __self = pthread_self(); __handler.__routine = func; __handler.__arg = val; __handler.__next = __self->__cleanup_stack; __self->__cleanup_stack = &__handler;
# 125 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
#define pthread_cleanup_pop(execute) __self->__cleanup_stack = __handler.__next; if (execute) (__handler.__routine)(__handler.__arg); }
# 135 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
#define PTHREAD_CREATE_JOINABLE 1
#define PTHREAD_CREATE_DETACHED 2

#define PTHREAD_INHERIT_SCHED 1
#define PTHREAD_EXPLICIT_SCHED 2

#define PTHREAD_CANCEL_ENABLE 0x01
#define PTHREAD_CANCEL_DISABLE 0x00
#define PTHREAD_CANCEL_DEFERRED 0x02
#define PTHREAD_CANCEL_ASYNCHRONOUS 0x00


#define PTHREAD_CANCELED ((void *) 1)


#define PTHREAD_SCOPE_SYSTEM 1
#define PTHREAD_SCOPE_PROCESS 2

#define PTHREAD_PROCESS_SHARED 1
#define PTHREAD_PROCESS_PRIVATE 2




#define PTHREAD_PRIO_NONE 0
#define PTHREAD_PRIO_INHERIT 1
#define PTHREAD_PRIO_PROTECT 2




#define PTHREAD_MUTEX_NORMAL 0
#define PTHREAD_MUTEX_ERRORCHECK 1
#define PTHREAD_MUTEX_RECURSIVE 2
#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL




#define PTHREAD_MUTEX_POLICY_FAIRSHARE_NP 1
#define PTHREAD_MUTEX_POLICY_FIRSTFIT_NP 3




#define PTHREAD_RWLOCK_INITIALIZER {_PTHREAD_RWLOCK_SIG_init, {0}}




#define PTHREAD_MUTEX_INITIALIZER {_PTHREAD_MUTEX_SIG_init, {0}}




#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER {_PTHREAD_ERRORCHECK_MUTEX_SIG_init, {0}}
#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER {_PTHREAD_RECURSIVE_MUTEX_SIG_init, {0}}




#define _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT defined(SWIFT_CLASS_EXTRA) && (!defined(SWIFT_SDK_OVERLAY_PTHREAD_EPOCH) || (SWIFT_SDK_OVERLAY_PTHREAD_EPOCH < 1))
# 207 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
#define PTHREAD_COND_INITIALIZER {_PTHREAD_COND_SIG_init, {0}}





#define PTHREAD_ONCE_INIT {_PTHREAD_ONCE_SIG_init, {0}}





int pthread_atfork(void (* )(void), void (* )(void),
  void (* )(void));


int pthread_attr_destroy(pthread_attr_t *);


int pthread_attr_getdetachstate(const pthread_attr_t *, int *);


int pthread_attr_getguardsize(const pthread_attr_t * restrict, size_t * restrict);


int pthread_attr_getinheritsched(const pthread_attr_t * restrict, int * restrict);


int pthread_attr_getschedparam(const pthread_attr_t * restrict,
  struct sched_param * restrict);


int pthread_attr_getschedpolicy(const pthread_attr_t * restrict, int * restrict);


int pthread_attr_getscope(const pthread_attr_t * restrict, int * restrict);


int pthread_attr_getstack(const pthread_attr_t * restrict,
  void * * restrict, size_t * restrict);


int pthread_attr_getstackaddr(const pthread_attr_t * restrict,
  void * * restrict);


int pthread_attr_getstacksize(const pthread_attr_t * restrict, size_t * restrict);


int pthread_attr_init(pthread_attr_t *);


int pthread_attr_setdetachstate(pthread_attr_t *, int);


int pthread_attr_setguardsize(pthread_attr_t *, size_t);


int pthread_attr_setinheritsched(pthread_attr_t *, int);


int pthread_attr_setschedparam(pthread_attr_t * restrict,
  const struct sched_param * restrict);


int pthread_attr_setschedpolicy(pthread_attr_t *, int);


int pthread_attr_setscope(pthread_attr_t *, int);


int pthread_attr_setstack(pthread_attr_t *, void *, size_t);


int pthread_attr_setstackaddr(pthread_attr_t *, void *);


int pthread_attr_setstacksize(pthread_attr_t *, size_t);


int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );


int pthread_cond_broadcast(pthread_cond_t *);


int pthread_cond_destroy(pthread_cond_t *);


int pthread_cond_init(
  pthread_cond_t * restrict,
  const pthread_condattr_t * restrict)
  __asm("_" "pthread_cond_init" );


int pthread_cond_signal(pthread_cond_t *);


int pthread_cond_timedwait(
  pthread_cond_t * restrict, pthread_mutex_t * restrict,
  const struct timespec * restrict)
  __asm("_" "pthread_cond_timedwait" );


int pthread_cond_wait(pthread_cond_t * restrict,
  pthread_mutex_t * restrict) __asm("_" "pthread_cond_wait" );


int pthread_condattr_destroy(pthread_condattr_t *);


int pthread_condattr_init(pthread_condattr_t *);


int pthread_condattr_getpshared(const pthread_condattr_t * restrict,
  int * restrict);


int pthread_condattr_setpshared(pthread_condattr_t *, int);



int pthread_create(pthread_t * restrict,
  const pthread_attr_t * restrict,
  void * (* )(void * ),
  void * restrict);







int pthread_detach(pthread_t);


int pthread_equal(pthread_t , pthread_t );


void pthread_exit(void * ) __attribute__((__noreturn__));


int pthread_getconcurrency(void);


int pthread_getschedparam(pthread_t , int * restrict,
  struct sched_param * restrict);


void* pthread_getspecific(pthread_key_t);


int pthread_join(pthread_t , void * * )
  __asm("_" "pthread_join" );


int pthread_key_create(pthread_key_t *, void (* )(void *));


int pthread_key_delete(pthread_key_t);


int pthread_mutex_destroy(pthread_mutex_t *);


int pthread_mutex_getprioceiling(const pthread_mutex_t * restrict,
  int * restrict);


int pthread_mutex_init(pthread_mutex_t * restrict,
  const pthread_mutexattr_t * restrict);


int pthread_mutex_lock(pthread_mutex_t *);


int pthread_mutex_setprioceiling(pthread_mutex_t * restrict, int,
  int * restrict);


int pthread_mutex_trylock(pthread_mutex_t *);


int pthread_mutex_unlock(pthread_mutex_t *);


int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );


int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_getpshared(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_gettype(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_init(pthread_mutexattr_t *);


int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);


int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);


int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);


int pthread_mutexattr_settype(pthread_mutexattr_t *, int);


int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);



int pthread_once(pthread_once_t *, void (* )(void));


int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );


int pthread_rwlock_init(pthread_rwlock_t * restrict,
  const pthread_rwlockattr_t * restrict)
  __asm("_" "pthread_rwlock_init" );


int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );


int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );


int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );


int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );


int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );


int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);


int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * restrict,
  int * restrict);


int pthread_rwlockattr_init(pthread_rwlockattr_t *);


int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);


pthread_t pthread_self(void);


int pthread_setcancelstate(int , int * )
  __asm("_" "pthread_setcancelstate" );


int pthread_setcanceltype(int , int * )
  __asm("_" "pthread_setcanceltype" );


int pthread_setconcurrency(int);


int pthread_setschedparam(pthread_t, int, const struct sched_param *);


int pthread_setspecific(pthread_key_t , const void * );


void pthread_testcancel(void) __asm("_" "pthread_testcancel" );





int pthread_is_threaded_np(void);


int pthread_threadid_np(pthread_t ,__uint64_t* );



int pthread_getname_np(pthread_t,char*,size_t);


int pthread_setname_np(const char*);



int pthread_main_np(void);



mach_port_t pthread_mach_thread_np(pthread_t);


size_t pthread_get_stacksize_np(pthread_t);


void* pthread_get_stackaddr_np(pthread_t);



int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t );



int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec * );




int pthread_create_suspended_np(
  pthread_t * , const pthread_attr_t * ,
  void * (* )(void * ), void * );






int pthread_kill(pthread_t, int);


 pthread_t pthread_from_mach_thread_np(mach_port_t);


int pthread_sigmask(int, const sigset_t * , sigset_t * )
  __asm("_" "pthread_sigmask" );


void pthread_yield_np(void);



void pthread_jit_write_protect_np(int enabled);



int pthread_jit_write_protect_supported_np(void);
# 581 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
typedef int (*pthread_jit_write_callback_t)(void * ctx);
# 594 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4
#define PTHREAD_JIT_WRITE_ALLOW_CALLBACKS_NP(...) __attribute__((__used__, __section__("__DATA_CONST,__pth_jit_func"))) static const pthread_jit_write_callback_t __pthread_jit_write_callback_allowlist[] = { __VA_ARGS__, NULL }
# 662 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4



int pthread_jit_write_with_callback_np(
  pthread_jit_write_callback_t callback, void * ctx);
# 683 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/pthread.h" 3 4

int
pthread_cpu_number_np(size_t *cpu_number_out);



# 25616 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 25625 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MUTEX_NREF 0






# 25631 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_mutex {
  pthread_mutex_t mutex;
# 25641 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};






#define SQLITE3_MUTEX_INITIALIZER(id) { PTHREAD_MUTEX_INITIALIZER }
# 25681 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3MemoryBarrier(void){



  __sync_synchronize();

}




static int pthreadMutexInit(void){ return 0; }
static int pthreadMutexEnd(void){ return 0; }
# 25743 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_mutex *pthreadMutexAlloc(int iType){
  static sqlite3_mutex staticMutexes[] = {
    { 
# 25745 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25745 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25747 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25747 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25748 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25748 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25749 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25749 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25750 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25750 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25751 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25751 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25752 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25752 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25754 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25754 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25755 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25755 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   },
    { 
# 25756 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
   {0x32AAABA7, {0}} 
# 25756 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
   }
  };
  sqlite3_mutex *p;
  switch( iType ){
    case 1: {
      p = sqlite3MallocZero( sizeof(*p) );
      if( p ){






        pthread_mutexattr_t recursiveAttr;
        pthread_mutexattr_init(&recursiveAttr);
        pthread_mutexattr_settype(&recursiveAttr, 
# 25771 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                 2
# 25771 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                                        );
        pthread_mutex_init(&p->mutex, &recursiveAttr);
        pthread_mutexattr_destroy(&recursiveAttr);




      }
      break;
    }
    case 0: {
      p = sqlite3MallocZero( sizeof(*p) );
      if( p ){
        pthread_mutex_init(&p->mutex, 0);



      }
      break;
    }
    default: {






      p = &staticMutexes[iType-2];
      break;
    }
  }



  return p;
}







static void pthreadMutexFree(sqlite3_mutex *p){
  ((void)0);



  {
    pthread_mutex_destroy(&p->mutex);
    sqlite3_free(p);
  }





}
# 25841 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pthreadMutexEnter(sqlite3_mutex *p){
  ((void)0);
# 25869 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pthread_mutex_lock(&p->mutex);
# 25882 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
static int pthreadMutexTry(sqlite3_mutex *p){
  int rc;
  ((void)0);
# 25915 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pthread_mutex_trylock(&p->mutex)==0 ){




    rc = 0;
  }else{
    rc = 5;
  }







  return rc;
}







static void pthreadMutexLeave(sqlite3_mutex *p){
  ((void)0);




  ((void)0);






  pthread_mutex_unlock(&p->mutex);







}

static sqlite3_mutex_methods const *sqlite3DefaultMutex(void){
  static const sqlite3_mutex_methods sMutex = {
    pthreadMutexInit,
    pthreadMutexEnd,
    pthreadMutexAlloc,
    pthreadMutexFree,
    pthreadMutexEnter,
    pthreadMutexTry,
    pthreadMutexLeave,




    0,
    0

  };

  return &sMutex;
}
# 26702 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_release_memory(int n){






  (void)(n);
  return 0;

}




static struct Mem0Global {
  sqlite3_mutex *mutex;
  sqlite3_int64 alarmThreshold;





  int nearlyFull;
} mem0 = { 0, 0, 0 };

#define mem0 GLOBAL(struct Mem0Global, mem0)




static sqlite3_mutex *sqlite3MallocMutex(void){
  return mem0.mutex;
}







 int sqlite3_memory_alarm(
  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),
  void *pArg,
  sqlite3_int64 iThreshold
){
  (void)xCallback;
  (void)pArg;
  (void)iThreshold;
  return 0;
}






 sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){
  sqlite3_int64 priorLimit;
  sqlite3_int64 excess;
  sqlite3_int64 nUsed;

  int rc = sqlite3_initialize();
  if( rc ) return -1;

  sqlite3_mutex_enter(mem0.mutex);
  priorLimit = mem0.alarmThreshold;
  if( n<0 ){
    sqlite3_mutex_leave(mem0.mutex);
    return priorLimit;
  }
  mem0.alarmThreshold = n;
  nUsed = sqlite3StatusValue(0);
  mem0.nearlyFull = (n>0 && n<=nUsed);
  sqlite3_mutex_leave(mem0.mutex);
  excess = sqlite3_memory_used() - n;
  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));
  return priorLimit;
}
 void sqlite3_soft_heap_limit(int n){
  if( n<0 ) n = 0;
  sqlite3_soft_heap_limit64(n);
}




static int sqlite3MallocInit(void){
  int rc;
  if( sqlite3Config.m.xMalloc==0 ){
    sqlite3MemSetDefault();
  }
  memset(&mem0, 0, sizeof(mem0));
  mem0.mutex = sqlite3MutexAlloc(3);
  if( sqlite3Config.pPage==0 || sqlite3Config.szPage<512
      || sqlite3Config.nPage<=0 ){
    sqlite3Config.pPage = 0;
    sqlite3Config.szPage = 0;
  }
  rc = sqlite3Config.m.xInit(sqlite3Config.m.pAppData);
  if( rc!=0 ) memset(&mem0, 0, sizeof(mem0));
  return rc;
}






static int sqlite3HeapNearlyFull(void){
  return mem0.nearlyFull;
}




static void sqlite3MallocEnd(void){
  if( sqlite3Config.m.xShutdown ){
    sqlite3Config.m.xShutdown(sqlite3Config.m.pAppData);
  }
  memset(&mem0, 0, sizeof(mem0));
}




 sqlite3_int64 sqlite3_memory_used(void){
  sqlite3_int64 res, mx;
  sqlite3_status64(0, &res, &mx, 0);
  return res;
}






 sqlite3_int64 sqlite3_memory_highwater(int resetFlag){
  sqlite3_int64 res, mx;
  sqlite3_status64(0, &res, &mx, resetFlag);
  return mx;
}




static void sqlite3MallocAlarm(int nByte){
  if( mem0.alarmThreshold<=0 ) return;
  sqlite3_mutex_leave(mem0.mutex);
  sqlite3_release_memory(nByte);
  sqlite3_mutex_enter(mem0.mutex);
}





static void mallocWithAlarm(int n, void **pp){
  void *p;
  int nFull;
  ((void)0);
  ((void)0);






  nFull = sqlite3Config.m.xRoundup(n);
# 26879 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3StatusHighwater(5, n);
  if( mem0.alarmThreshold>0 ){
    sqlite3_int64 nUsed = sqlite3StatusValue(0);
    if( nUsed >= mem0.alarmThreshold - nFull ){
      mem0.nearlyFull = 1;
      sqlite3MallocAlarm(nFull);
    }else{
      mem0.nearlyFull = 0;
    }
  }
  p = sqlite3Config.m.xMalloc(nFull);






  if( p ){
    nFull = sqlite3MallocSize(p);
    sqlite3StatusUp(0, nFull);
    sqlite3StatusUp(9, 1);
  }
  *pp = p;
}





static void *sqlite3Malloc(u64 n){
  void *p;
  if( n==0 || n>=0x7fffff00 ){





    p = 0;
  }else if( sqlite3Config.bMemstat ){
    sqlite3_mutex_enter(mem0.mutex);
    mallocWithAlarm((int)n, &p);
    sqlite3_mutex_leave(mem0.mutex);
  }else{
    p = sqlite3Config.m.xMalloc((int)n);
  }
  ((void)0);
  return p;
}






 void *sqlite3_malloc(int n){

  if( sqlite3_initialize() ) return 0;

  return n<=0 ? 0 : sqlite3Malloc(n);
}
 void *sqlite3_malloc64(sqlite3_uint64 n){

  if( sqlite3_initialize() ) return 0;

  return sqlite3Malloc(n);
}





static int isLookaside(sqlite3 *db, void *p){
  return (((uptr)(p)>=(uptr)(db->lookaside.pStart))&&((uptr)(p)<(uptr)(db->lookaside.pEnd)));
}
# 26961 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3MallocSize(void *p){
  ((void)0);
  return sqlite3Config.m.xSize(p);
}
static int sqlite3DbMallocSize(sqlite3 *db, void *p){
  ((void)0);
  if( db==0 || !isLookaside(db,p) ){
# 26977 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    return sqlite3Config.m.xSize(p);
  }else{
    ((void)0);
    return db->lookaside.sz;
  }
}
 sqlite3_uint64 sqlite3_msize(void *p){
  ((void)0);
  ((void)0);
  return p ? sqlite3Config.m.xSize(p) : 0;
}




 void sqlite3_free(void *p){
  if( p==0 ) return;
  ((void)0);
  ((void)0);
  if( sqlite3Config.bMemstat ){
    sqlite3_mutex_enter(mem0.mutex);
    sqlite3StatusDown(0, sqlite3MallocSize(p));
    sqlite3StatusDown(9, 1);
    sqlite3Config.m.xFree(p);
    sqlite3_mutex_leave(mem0.mutex);
  }else{
    sqlite3Config.m.xFree(p);
  }
}





static __attribute__((noinline)) void measureAllocationSize(sqlite3 *db, void *p){
  *db->pnBytesFreed += sqlite3DbMallocSize(db,p);
}






static void sqlite3DbFreeNN(sqlite3 *db, void *p){
  ((void)0);
  ((void)0);
  if( db ){
    if( db->pnBytesFreed ){
      measureAllocationSize(db, p);
      return;
    }
    if( isLookaside(db, p) ){
      LookasideSlot *pBuf = (LookasideSlot*)p;




      pBuf->pNext = db->lookaside.pFree;
      db->lookaside.pFree = pBuf;
      return;
    }
  }
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  sqlite3_free(p);
}
static void sqlite3DbFree(sqlite3 *db, void *p){
  ((void)0);
  if( p ) sqlite3DbFreeNN(db, p);
}




static void *sqlite3Realloc(void *pOld, u64 nBytes){
  int nOld, nNew, nDiff;
  void *pNew;
  ((void)0);
  ((void)0);
  if( pOld==0 ){
    return sqlite3Malloc(nBytes);
  }
  if( nBytes==0 ){
    sqlite3_free(pOld);
    return 0;
  }
  if( nBytes>=0x7fffff00 ){

    return 0;
  }
  nOld = sqlite3MallocSize(pOld);



  nNew = sqlite3Config.m.xRoundup((int)nBytes);
  if( nOld==nNew ){
    pNew = pOld;
  }else if( sqlite3Config.bMemstat ){
    sqlite3_mutex_enter(mem0.mutex);
    sqlite3StatusHighwater(5, (int)nBytes);
    nDiff = nNew - nOld;
    if( nDiff>0 && sqlite3StatusValue(0) >=
          mem0.alarmThreshold-nDiff ){
      sqlite3MallocAlarm(nDiff);
    }
    pNew = sqlite3Config.m.xRealloc(pOld, nNew);
    if( pNew==0 && mem0.alarmThreshold>0 ){
      sqlite3MallocAlarm((int)nBytes);
      pNew = sqlite3Config.m.xRealloc(pOld, nNew);
    }
    if( pNew ){
      nNew = sqlite3MallocSize(pNew);
      sqlite3StatusUp(0, nNew-nOld);
    }
    sqlite3_mutex_leave(mem0.mutex);
  }else{
    pNew = sqlite3Config.m.xRealloc(pOld, nNew);
  }
  ((void)0);
  return pNew;
}





 void *sqlite3_realloc(void *pOld, int n){

  if( sqlite3_initialize() ) return 0;

  if( n<0 ) n = 0;
  return sqlite3Realloc(pOld, n);
}
 void *sqlite3_realloc64(void *pOld, sqlite3_uint64 n){

  if( sqlite3_initialize() ) return 0;

  return sqlite3Realloc(pOld, n);
}





static void *sqlite3MallocZero(u64 n){
  void *p = sqlite3Malloc(n);
  if( p ){
    memset(p, 0, (size_t)n);
  }
  return p;
}





static void *sqlite3DbMallocZero(sqlite3 *db, u64 n){
  void *p;
  ;
  p = sqlite3DbMallocRaw(db, n);
  if( p ) memset(p, 0, (size_t)n);
  return p;
}





static __attribute__((noinline)) void *dbMallocRawFinish(sqlite3 *db, u64 n){
  void *p;
  ((void)0);
  p = sqlite3Malloc(n);
  if( !p ) sqlite3OomFault(db);
 
                                                                        ;
  return p;
}
# 27179 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3DbMallocRaw(sqlite3 *db, u64 n){
  void *p;
  if( db ) return sqlite3DbMallocRawNN(db, n);
  p = sqlite3Malloc(n);
  ;
  return p;
}
static void *sqlite3DbMallocRawNN(sqlite3 *db, u64 n){

  LookasideSlot *pBuf;
  ((void)0);
  ((void)0);
  ((void)0);
  if( db->lookaside.bDisable==0 ){
    ((void)0);
    if( n>db->lookaside.sz ){
      db->lookaside.anStat[1]++;
    }else if( (pBuf = db->lookaside.pFree)!=0 ){
      db->lookaside.pFree = pBuf->pNext;
      db->lookaside.anStat[0]++;
      return (void*)pBuf;
    }else if( (pBuf = db->lookaside.pInit)!=0 ){
      db->lookaside.pInit = pBuf->pNext;
      db->lookaside.anStat[0]++;
      return (void*)pBuf;
    }else{
      db->lookaside.anStat[2]++;
    }
  }else if( db->mallocFailed ){
    return 0;
  }
# 27218 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return dbMallocRawFinish(db, n);
}


static __attribute__((noinline)) void *dbReallocFinish(sqlite3 *db, void *p, u64 n);





static void *sqlite3DbRealloc(sqlite3 *db, void *p, u64 n){
  ((void)0);
  if( p==0 ) return sqlite3DbMallocRawNN(db, n);
  ((void)0);
  if( isLookaside(db,p) && n<=db->lookaside.sz ) return p;
  return dbReallocFinish(db, p, n);
}
static __attribute__((noinline)) void *dbReallocFinish(sqlite3 *db, void *p, u64 n){
  void *pNew = 0;
  ((void)0);
  ((void)0);
  if( db->mallocFailed==0 ){
    if( isLookaside(db, p) ){
      pNew = sqlite3DbMallocRawNN(db, n);
      if( pNew ){
        memcpy(pNew, p, db->lookaside.sz);
        sqlite3DbFree(db, p);
      }
    }else{
      ((void)0);
      ((void)0);
      ;
      pNew = sqlite3_realloc64(p, n);
      if( !pNew ){
        sqlite3OomFault(db);
      }
     
                                                                           ;
    }
  }
  return pNew;
}





static void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, u64 n){
  void *pNew;
  pNew = sqlite3DbRealloc(db, p, n);
  if( !pNew ){
    sqlite3DbFree(db, p);
  }
  return pNew;
}
# 27281 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *sqlite3DbStrDup(sqlite3 *db, const char *z){
  char *zNew;
  size_t n;
  if( z==0 ){
    return 0;
  }
  n = strlen(z) + 1;
  zNew = sqlite3DbMallocRaw(db, n);
  if( zNew ){
    memcpy(zNew, z, n);
  }
  return zNew;
}
static char *sqlite3DbStrNDup(sqlite3 *db, const char *z, u64 n){
  char *zNew;
  ((void)0);
  if( z==0 ){
    return 0;
  }
  ((void)0);
  zNew = sqlite3DbMallocRawNN(db, n+1);
  if( zNew ){
    memcpy(zNew, z, (size_t)n);
    zNew[n] = 0;
  }
  return zNew;
}






static char *sqlite3DbSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){
  int n;
  while( (sqlite3CtypeMap[(unsigned char)(zStart[0])]&0x01) ) zStart++;
  n = (int)(zEnd - zStart);
  while( (n>0) && (sqlite3CtypeMap[(unsigned char)(zStart[n-1])]&0x01) ) n--;
  return sqlite3DbStrNDup(db, zStart, n);
}




static void sqlite3SetString(char **pz, sqlite3 *db, const char *zNew){
  sqlite3DbFree(db, *pz);
  *pz = sqlite3DbStrDup(db, zNew);
}







static void sqlite3OomFault(sqlite3 *db){
  if( db->mallocFailed==0 && db->bBenignMalloc==0 ){
    db->mallocFailed = 1;
    if( db->nVdbeExec>0 ){
      db->u1.isInterrupted = 1;
    }
    db->lookaside.bDisable++;
    if( db->pParse ){
      db->pParse->rc = 7;
    }
  }
}
# 27356 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3OomClear(sqlite3 *db){
  if( db->mallocFailed && db->nVdbeExec==0 ){
    db->mallocFailed = 0;
    db->u1.isInterrupted = 0;
    ((void)0);
    db->lookaside.bDisable--;
  }
}




static __attribute__((noinline)) int apiOomError(sqlite3 *db){
  sqlite3OomClear(db);
  sqlite3Error(db, 7);
  return 7;
}
# 27386 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ApiExit(sqlite3* db, int rc){




  ((void)0);
  ((void)0);
  if( db->mallocFailed || rc==(10 | (12<<8)) ){
    return apiOomError(db);
  }
  return rc & db->errMask;
}
# 27418 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define etRADIX 0
#define etFLOAT 1
#define etEXP 2
#define etGENERIC 3
#define etSIZE 4
#define etSTRING 5
#define etDYNSTRING 6
#define etPERCENT 7
#define etCHARX 8

#define etSQLESCAPE 9
#define etSQLESCAPE2 10

#define etTOKEN 11
#define etSRCLIST 12
#define etPOINTER 13
#define etSQLESCAPE3 14
#define etORDINAL 15
#define etDECIMAL 16

#define etINVALID 17





typedef unsigned char etByte;





typedef struct et_info {
  char fmttype;
  etByte base;
  etByte flags;
  etByte type;
  etByte charset;
  etByte prefix;
} et_info;




#define FLAG_SIGNED 1
#define FLAG_STRING 4






static const char aDigits[] = "0123456789ABCDEF0123456789abcdef";
static const char aPrefix[] = "-x0\000X0";
static const et_info fmtinfo[] = {
  { 'd', 10, 1, 16, 0, 0 },
  { 's', 0, 4, 5, 0, 0 },
  { 'g', 0, 1, 3, 30, 0 },
  { 'z', 0, 4, 6, 0, 0 },
  { 'q', 0, 4, 9, 0, 0 },
  { 'Q', 0, 4, 10, 0, 0 },
  { 'w', 0, 4, 14, 0, 0 },
  { 'c', 0, 0, 8, 0, 0 },
  { 'o', 8, 0, 0, 0, 2 },
  { 'u', 10, 0, 16, 0, 0 },
  { 'x', 16, 0, 0, 16, 1 },
  { 'X', 16, 0, 0, 0, 4 },

  { 'f', 0, 1, 1, 0, 0 },
  { 'e', 0, 1, 2, 30, 0 },
  { 'E', 0, 1, 2, 14, 0 },
  { 'G', 0, 1, 3, 14, 0 },

  { 'i', 10, 1, 16, 0, 0 },
  { 'n', 0, 0, 4, 0, 0 },
  { '%', 0, 0, 7, 0, 0 },
  { 'p', 16, 0, 13, 0, 1 },


  { 'T', 0, 0, 11, 0, 0 },
  { 'S', 0, 0, 12, 0, 0 },
  { 'r', 10, 1, 15, 0, 0 },
};


static const double arRound[] = {
  5.0e-01, 5.0e-02, 5.0e-03, 5.0e-04, 5.0e-05,
  5.0e-06, 5.0e-07, 5.0e-08, 5.0e-09, 5.0e-10,
};
# 27526 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char et_getdigit(long double *val, int *cnt){
  int digit;
  long double d;
  if( (*cnt)<=0 ) return '0';
  (*cnt)--;
  digit = (int)*val;
  d = digit;
  digit += '0';
  *val = (*val - d)*10.0;
  return (char)digit;
}





static void setStrAccumError(StrAccum *p, u8 eError){
  ((void)0);
  p->accError = eError;
  if( p->mxAlloc ) sqlite3_str_reset(p);
  if( eError==18 ) sqlite3ErrorToParser(p->db, eError);
}




static sqlite3_int64 getIntArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0;
  return sqlite3_value_int64(p->apArg[p->nUsed++]);
}
static double getDoubleArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0.0;
  return sqlite3_value_double(p->apArg[p->nUsed++]);
}
static char *getTextArg(PrintfArguments *p){
  if( p->nArg<=p->nUsed ) return 0;
  return (char*)sqlite3_value_text(p->apArg[p->nUsed++]);
}
# 27574 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *printfTempBuf(sqlite3_str *pAccum, sqlite3_int64 n){
  char *z;
  if( pAccum->accError ) return 0;
  if( n>pAccum->nAlloc && n>pAccum->mxAlloc ){
    setStrAccumError(pAccum, 18);
    return 0;
  }
  z = sqlite3DbMallocRaw(pAccum->db, n);
  if( z==0 ){
    setStrAccumError(pAccum, 7);
  }
  return z;
}






#define SQLITE_PRINT_BUF_SIZE 70

#define etBUFSIZE SQLITE_PRINT_BUF_SIZE




 void sqlite3_str_vappendf(
  sqlite3_str *pAccum,
  const char *fmt,
  va_list ap
){
  int c;
  char *bufpt;
  int precision;
  int length;
  int idx;
  int width;
  etByte flag_leftjustify;
  etByte flag_prefix;
  etByte flag_alternateform;
  etByte flag_altform2;
  etByte flag_zeropad;
  etByte flag_long;
  etByte done;
  etByte cThousand;
  etByte xtype = 17;
  u8 bArgList;
  char prefix;
  sqlite_uint64 longvalue;
  long double realvalue;
  const et_info *infop;
  char *zOut;
  int nOut;
  char *zExtra = 0;

  int exp, e2;
  int nsd;
  double rounder;
  etByte flag_dp;
  etByte flag_rtz;

  PrintfArguments *pArgList = 0;
  char buf[70];




  ((void)0);

  bufpt = 0;
  if( (pAccum->printfFlags & 0x02)!=0 ){
    pArgList = ( *(PrintfArguments* *)((ap += ( (sizeof(PrintfArguments*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(PrintfArguments*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
    bArgList = 1;
  }else{
    bArgList = 0;
  }
  for(; (c=(*fmt))!=0; ++fmt){
    if( c!='%' ){
      bufpt = (char *)fmt;



      do{ fmt++; }while( *fmt && *fmt != '%' );

      sqlite3_str_append(pAccum, bufpt, (int)(fmt - bufpt));
      if( *fmt==0 ) break;
    }
    if( (c=(*++fmt))==0 ){
      sqlite3_str_append(pAccum, "%", 1);
      break;
    }

    flag_leftjustify = flag_prefix = cThousand =
     flag_alternateform = flag_altform2 = flag_zeropad = 0;
    done = 0;
    width = 0;
    flag_long = 0;
    precision = -1;
    do{
      switch( c ){
        case '-': flag_leftjustify = 1; break;
        case '+': flag_prefix = '+'; break;
        case ' ': flag_prefix = ' '; break;
        case '#': flag_alternateform = 1; break;
        case '!': flag_altform2 = 1; break;
        case '0': flag_zeropad = 1; break;
        case ',': cThousand = ','; break;
        default: done = 1; break;
        case 'l': {
          flag_long = 1;
          c = *++fmt;
          if( c=='l' ){
            c = *++fmt;
            flag_long = 2;
          }
          done = 1;
          break;
        }
        case '1': case '2': case '3': case '4': case '5':
        case '6': case '7': case '8': case '9': {
          unsigned wx = c - '0';
          while( (c = *++fmt)>='0' && c<='9' ){
            wx = wx*10 + c - '0';
          }
          ;
          width = wx & 0x7fffffff;





          if( c!='.' && c!='l' ){
            done = 1;
          }else{
            fmt--;
          }
          break;
        }
        case '*': {
          if( bArgList ){
            width = (int)getIntArg(pArgList);
          }else{
            width = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
          }
          if( width<0 ){
            flag_leftjustify = 1;
            width = width >= -2147483647 ? -width : 0;
          }





          if( (c = fmt[1])!='.' && c!='l' ){
            c = *++fmt;
            done = 1;
          }
          break;
        }
        case '.': {
          c = *++fmt;
          if( c=='*' ){
            if( bArgList ){
              precision = (int)getIntArg(pArgList);
            }else{
              precision = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
            }
            if( precision<0 ){
              precision = precision >= -2147483647 ? -precision : -1;
            }
            c = *++fmt;
          }else{
            unsigned px = 0;
            while( c>='0' && c<='9' ){
              px = px*10 + c - '0';
              c = *++fmt;
            }
            ;
            precision = px & 0x7fffffff;
          }





          if( c=='l' ){
            --fmt;
          }else{
            done = 1;
          }
          break;
        }
      }
    }while( !done && (c=(*++fmt))!=0 );


    infop = &fmtinfo[0];
    xtype = 17;
    for(idx=0; idx<((int)(sizeof(fmtinfo)/sizeof(fmtinfo[0]))); idx++){
      if( c==fmtinfo[idx].fmttype ){
        infop = &fmtinfo[idx];
        xtype = infop->type;
        break;
      }
    }
# 27797 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    switch( xtype ){
      case 13:
        flag_long = sizeof(char*)==sizeof(i64) ? 2 :
                     sizeof(char*)==sizeof(long int) ? 1 : 0;

      case 15:
      case 0:
        cThousand = 0;

      case 16:
        if( infop->flags & 1 ){
          i64 v;
          if( bArgList ){
            v = getIntArg(pArgList);
          }else if( flag_long ){
            if( flag_long==2 ){
              v = ( *(i64 *)((ap += ( (sizeof(i64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(i64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ) ;
            }else{
              v = ( *(long int *)((ap += ( (sizeof(long int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(long int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
            }
          }else{
            v = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
          }
          if( v<0 ){
            if( v==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){
              longvalue = ((u64)1)<<63;
            }else{
              longvalue = -v;
            }
            prefix = '-';
          }else{
            longvalue = v;
            prefix = flag_prefix;
          }
        }else{
          if( bArgList ){
            longvalue = (u64)getIntArg(pArgList);
          }else if( flag_long ){
            if( flag_long==2 ){
              longvalue = ( *(u64 *)((ap += ( (sizeof(u64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(u64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
            }else{
              longvalue = ( *(unsigned long int *)((ap += ( (sizeof(unsigned long int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(unsigned long int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
            }
          }else{
            longvalue = ( *(unsigned int *)((ap += ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
          }
          prefix = 0;
        }
        if( longvalue==0 ) flag_alternateform = 0;
        if( flag_zeropad && precision<width-(prefix!=0) ){
          precision = width-(prefix!=0);
        }
        if( precision<70 -10-70/3 ){
          nOut = 70;
          zOut = buf;
        }else{
          u64 n;
          n = (u64)precision + 10;
          if( cThousand ) n += precision/3;
          zOut = zExtra = printfTempBuf(pAccum, n);
          if( zOut==0 ) return;
          nOut = (int)n;
        }
        bufpt = &zOut[nOut-1];
        if( xtype==15 ){
          static const char zOrd[] = "thstndrd";
          int x = (int)(longvalue % 10);
          if( x>=4 || (longvalue/10)%10==1 ){
            x = 0;
          }
          *(--bufpt) = zOrd[x*2+1];
          *(--bufpt) = zOrd[x*2];
        }
        {
          const char *cset = &aDigits[infop->charset];
          u8 base = infop->base;
          do{
            *(--bufpt) = cset[longvalue%base];
            longvalue = longvalue/base;
          }while( longvalue>0 );
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        while( precision>length ){
          *(--bufpt) = '0';
          length++;
        }
        if( cThousand ){
          int nn = (length - 1)/3;
          int ix = (length - 1)%3 + 1;
          bufpt -= nn;
          for(idx=0; nn>0; idx++){
            bufpt[idx] = bufpt[idx+nn];
            ix--;
            if( ix==0 ){
              bufpt[++idx] = cThousand;
              nn--;
              ix = 3;
            }
          }
        }
        if( prefix ) *(--bufpt) = prefix;
        if( flag_alternateform && infop->prefix ){
          const char *pre;
          char x;
          pre = &aPrefix[infop->prefix];
          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;
        }
        length = (int)(&zOut[nOut-1]-bufpt);
        break;
      case 1:
      case 2:
      case 3:
        if( bArgList ){
          realvalue = getDoubleArg(pArgList);
        }else{
          realvalue = ( *(double *)((ap += ( (sizeof(double) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(double) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
        }



        if( precision<0 ) precision = 6;
        if( realvalue<0.0 ){
          realvalue = -realvalue;
          prefix = '-';
        }else{
          prefix = flag_prefix;
        }
        if( xtype==3 && precision>0 ) precision--;
        ;
        idx = precision & 0xfff;
        rounder = arRound[idx%10];
        while( idx>=10 ){ rounder *= 1.0e-10; idx -= 10; }
        if( xtype==1 ){
          double rx = (double)realvalue;
          sqlite3_uint64 u;
          int ex;
          memcpy(&u, &rx, sizeof(u));
          ex = -1023 + (int)((u>>52)&0x7ff);
          if( precision+(ex/3) < 15 ) rounder += realvalue*3e-16;
          realvalue += rounder;
        }

        exp = 0;
        if( sqlite3IsNaN((double)realvalue) ){
          bufpt = "NaN";
          length = 3;
          break;
        }
        if( realvalue>0.0 ){
          long double scale = 1.0;
          while( realvalue>=1e100*scale && exp<=350 ){ scale *= 1e100;exp+=100;}
          while( realvalue>=1e10*scale && exp<=350 ){ scale *= 1e10; exp+=10; }
          while( realvalue>=10.0*scale && exp<=350 ){ scale *= 10.0; exp++; }
          realvalue /= scale;
          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }
          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }
          if( exp>350 ){
            bufpt = buf;
            buf[0] = prefix;
            memcpy(buf+(prefix!=0),"Inf",4);
            length = 3+(prefix!=0);
            break;
          }
        }
        bufpt = buf;




        if( xtype!=1 ){
          realvalue += rounder;
          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }
        }
        if( xtype==3 ){
          flag_rtz = !flag_alternateform;
          if( exp<-4 || exp>precision ){
            xtype = 2;
          }else{
            precision = precision - exp;
            xtype = 1;
          }
        }else{
          flag_rtz = flag_altform2;
        }
        if( xtype==2 ){
          e2 = 0;
        }else{
          e2 = exp;
        }
        {
          i64 szBufNeeded;
          szBufNeeded = ((e2)>(0)?(e2):(0))+(i64)precision+(i64)width+15;
          if( szBufNeeded > 70 ){
            bufpt = zExtra = printfTempBuf(pAccum, szBufNeeded);
            if( bufpt==0 ) return;
          }
        }
        zOut = bufpt;
        nsd = 16 + flag_altform2*10;
        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;

        if( prefix ){
          *(bufpt++) = prefix;
        }

        if( e2<0 ){
          *(bufpt++) = '0';
        }else{
          for(; e2>=0; e2--){
            *(bufpt++) = et_getdigit(&realvalue,&nsd);
          }
        }

        if( flag_dp ){
          *(bufpt++) = '.';
        }


        for(e2++; e2<0; precision--, e2++){
          ((void)0);
          *(bufpt++) = '0';
        }

        while( (precision--)>0 ){
          *(bufpt++) = et_getdigit(&realvalue,&nsd);
        }

        if( flag_rtz && flag_dp ){
          while( bufpt[-1]=='0' ) *(--bufpt) = 0;
          ((void)0);
          if( bufpt[-1]=='.' ){
            if( flag_altform2 ){
              *(bufpt++) = '0';
            }else{
              *(--bufpt) = 0;
            }
          }
        }

        if( xtype==2 ){
          *(bufpt++) = aDigits[infop->charset];
          if( exp<0 ){
            *(bufpt++) = '-'; exp = -exp;
          }else{
            *(bufpt++) = '+';
          }
          if( exp>=100 ){
            *(bufpt++) = (char)((exp/100)+'0');
            exp %= 100;
          }
          *(bufpt++) = (char)(exp/10+'0');
          *(bufpt++) = (char)(exp%10+'0');
        }
        *bufpt = 0;




        length = (int)(bufpt-zOut);
        bufpt = zOut;



        if( flag_zeropad && !flag_leftjustify && length < width){
          int i;
          int nPad = width - length;
          for(i=width; i>=nPad; i--){
            bufpt[i] = bufpt[i-nPad];
          }
          i = prefix!=0;
          while( nPad-- ) bufpt[i++] = '0';
          length = width;
        }

        break;
      case 4:
        if( !bArgList ){
          *(( *(int* *)((ap += ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) )) = pAccum->nChar;
        }
        length = width = 0;
        break;
      case 7:
        buf[0] = '%';
        bufpt = buf;
        length = 1;
        break;
      case 8:
        if( bArgList ){
          bufpt = getTextArg(pArgList);
          length = 1;
          if( bufpt ){
            buf[0] = c = *(bufpt++);
            if( (c&0xc0)==0xc0 ){
              while( length<4 && (bufpt[0]&0xc0)==0x80 ){
                buf[length++] = *(bufpt++);
              }
            }
          }else{
            buf[0] = 0;
          }
        }else{
          unsigned int ch = ( *(unsigned int *)((ap += ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
          if( ch<0x00080 ){
            buf[0] = ch & 0xff;
            length = 1;
          }else if( ch<0x00800 ){
            buf[0] = 0xc0 + (u8)((ch>>6)&0x1f);
            buf[1] = 0x80 + (u8)(ch & 0x3f);
            length = 2;
          }else if( ch<0x10000 ){
            buf[0] = 0xe0 + (u8)((ch>>12)&0x0f);
            buf[1] = 0x80 + (u8)((ch>>6) & 0x3f);
            buf[2] = 0x80 + (u8)(ch & 0x3f);
            length = 3;
          }else{
            buf[0] = 0xf0 + (u8)((ch>>18) & 0x07);
            buf[1] = 0x80 + (u8)((ch>>12) & 0x3f);
            buf[2] = 0x80 + (u8)((ch>>6) & 0x3f);
            buf[3] = 0x80 + (u8)(ch & 0x3f);
            length = 4;
          }
        }
        if( precision>1 ){
          width -= precision-1;
          if( width>1 && !flag_leftjustify ){
            sqlite3_str_appendchar(pAccum, width-1, ' ');
            width = 0;
          }
          while( precision-- > 1 ){
            sqlite3_str_append(pAccum, buf, length);
          }
        }
        bufpt = buf;
        flag_altform2 = 1;
        goto adjust_width_for_utf8;
      case 5:
      case 6:
        if( bArgList ){
          bufpt = getTextArg(pArgList);
          xtype = 5;
        }else{
          bufpt = ( *(char* *)((ap += ( (sizeof(char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
        }
        if( bufpt==0 ){
          bufpt = "";
        }else if( xtype==6 ){
          if( pAccum->nChar==0
           && pAccum->mxAlloc
           && width==0
           && precision<0
           && pAccum->accError==0
          ){



            ((void)0);
            pAccum->zText = bufpt;
            pAccum->nAlloc = sqlite3DbMallocSize(pAccum->db, bufpt);
            pAccum->nChar = 0x7fffffff & (int)strlen(bufpt);
            pAccum->printfFlags |= 0x04;
            length = 0;
            break;
          }
          zExtra = bufpt;
        }
        if( precision>=0 ){
          if( flag_altform2 ){


            unsigned char *z = (unsigned char*)bufpt;
            while( precision-- > 0 && z[0] ){
              { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
            }
            length = (int)(z - (unsigned char*)bufpt);
          }else{
            for(length=0; length<precision && bufpt[length]; length++){}
          }
        }else{
          length = 0x7fffffff & (int)strlen(bufpt);
        }
      adjust_width_for_utf8:
        if( flag_altform2 && width>0 ){

          int ii = length - 1;
          while( ii>=0 ) if( (bufpt[ii--] & 0xc0)==0x80 ) width++;
        }
        break;
      case 9:
      case 10:
      case 14: {
        int i, j, k, n, isnull;
        int needQuote;
        char ch;
        char q = ((xtype==14)?'"':'\'');
        char *escarg;

        if( bArgList ){
          escarg = getTextArg(pArgList);
        }else{
          escarg = ( *(char* *)((ap += ( (sizeof(char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
        }
        isnull = escarg==0;
        if( isnull ) escarg = (xtype==10 ? "NULL" : "(NULL)");





        k = precision;
        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){
          if( ch==q ) n++;
          if( flag_altform2 && (ch&0xc0)==0xc0 ){
            while( (escarg[i+1]&0xc0)==0x80 ){ i++; }
          }
        }
        needQuote = !isnull && xtype==10;
        n += i + 3;
        if( n>70 ){
          bufpt = zExtra = printfTempBuf(pAccum, n);
          if( bufpt==0 ) return;
        }else{
          bufpt = buf;
        }
        j = 0;
        if( needQuote ) bufpt[j++] = q;
        k = i;
        for(i=0; i<k; i++){
          bufpt[j++] = ch = escarg[i];
          if( ch==q ) bufpt[j++] = ch;
        }
        if( needQuote ) bufpt[j++] = q;
        bufpt[j] = 0;
        length = j;
        goto adjust_width_for_utf8;
      }
      case 11: {
        Token *pToken;
        if( (pAccum->printfFlags & 0x01)==0 ) return;
        pToken = ( *(Token* *)((ap += ( (sizeof(Token*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(Token*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
        ((void)0);
        if( pToken && pToken->n ){
          sqlite3_str_append(pAccum, (const char*)pToken->z, pToken->n);
        }
        length = width = 0;
        break;
      }
      case 12: {
        SrcList *pSrc;
        int k;
        struct SrcList_item *pItem;
        if( (pAccum->printfFlags & 0x01)==0 ) return;
        pSrc = ( *(SrcList* *)((ap += ( (sizeof(SrcList*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(SrcList*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
        k = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
        pItem = &pSrc->a[k];
        ((void)0);
        ((void)0);
        if( pItem->zDatabase ){
          sqlite3_str_appendall(pAccum, pItem->zDatabase);
          sqlite3_str_append(pAccum, ".", 1);
        }
        sqlite3_str_appendall(pAccum, pItem->zName);
        length = width = 0;
        break;
      }
      default: {
        ((void)0);
        return;
      }
    }
# 28274 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    width -= length;
    if( width>0 ){
      if( !flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');
      sqlite3_str_append(pAccum, bufpt, length);
      if( flag_leftjustify ) sqlite3_str_appendchar(pAccum, width, ' ');
    }else{
      sqlite3_str_append(pAccum, bufpt, length);
    }

    if( zExtra ){
      sqlite3DbFree(pAccum->db, zExtra);
      zExtra = 0;
    }
  }
}
# 28297 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3StrAccumEnlarge(StrAccum *p, int N){
  char *zNew;
  ((void)0);
  if( p->accError ){
    ;
    ;
    return 0;
  }
  if( p->mxAlloc==0 ){
    setStrAccumError(p, 18);
    return p->nAlloc - p->nChar - 1;
  }else{
    char *zOld = (((p)->printfFlags & 0x04)!=0) ? p->zText : 0;
    i64 szNew = p->nChar;
    szNew += N + 1;
    if( szNew+p->nChar<=p->mxAlloc ){


      szNew += p->nChar;
    }
    if( szNew > p->mxAlloc ){
      sqlite3_str_reset(p);
      setStrAccumError(p, 18);
      return 0;
    }else{
      p->nAlloc = (int)szNew;
    }
    if( p->db ){
      zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);
    }else{
      zNew = sqlite3_realloc64(zOld, p->nAlloc);
    }
    if( zNew ){
      ((void)0);
      if( !(((p)->printfFlags & 0x04)!=0) && p->nChar>0 ) memcpy(zNew, p->zText, p->nChar);
      p->zText = zNew;
      p->nAlloc = sqlite3DbMallocSize(p->db, zNew);
      p->printfFlags |= 0x04;
    }else{
      sqlite3_str_reset(p);
      setStrAccumError(p, 7);
      return 0;
    }
  }
  return N;
}




 void sqlite3_str_appendchar(sqlite3_str *p, int N, char c){
  ;
  if( p->nChar+(i64)N >= p->nAlloc && (N = sqlite3StrAccumEnlarge(p, N))<=0 ){
    return;
  }
  while( (N--)>0 ) p->zText[p->nChar++] = c;
}
# 28363 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void __attribute__((noinline)) enlargeAndAppend(StrAccum *p, const char *z, int N){
  N = sqlite3StrAccumEnlarge(p, N);
  if( N>0 ){
    memcpy(&p->zText[p->nChar], z, N);
    p->nChar += N;
  }
}





 void sqlite3_str_append(sqlite3_str *p, const char *z, int N){
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( p->nChar+N >= p->nAlloc ){
    enlargeAndAppend(p,z,N);
  }else if( N ){
    ((void)0);
    p->nChar += N;
    memcpy(&p->zText[p->nChar-N], z, N);
  }
}




 void sqlite3_str_appendall(sqlite3_str *p, const char *z){
  sqlite3_str_append(p, z, sqlite3Strlen30(z));
}







static __attribute__((noinline)) char *strAccumFinishRealloc(StrAccum *p){
  char *zText;
  ((void)0);
  zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );
  if( zText ){
    memcpy(zText, p->zText, p->nChar+1);
    p->printfFlags |= 0x04;
  }else{
    setStrAccumError(p, 7);
  }
  p->zText = zText;
  return zText;
}
static char *sqlite3StrAccumFinish(StrAccum *p){
  if( p->zText ){
    p->zText[p->nChar] = 0;
    if( p->mxAlloc>0 && !(((p)->printfFlags & 0x04)!=0) ){
      return strAccumFinishRealloc(p);
    }
  }
  return p->zText;
}







static sqlite3_str sqlite3OomStr = {
   0, 0, 0, 0, 0, 7, 0
};



 char *sqlite3_str_finish(sqlite3_str *p){
  char *z;
  if( p!=0 && p!=&sqlite3OomStr ){
    z = sqlite3StrAccumFinish(p);
    sqlite3_free(p);
  }else{
    z = 0;
  }
  return z;
}


 int sqlite3_str_errcode(sqlite3_str *p){
  return p ? p->accError : 7;
}


 int sqlite3_str_length(sqlite3_str *p){
  return p ? p->nChar : 0;
}


 char *sqlite3_str_value(sqlite3_str *p){
  if( p==0 || p->nChar==0 ) return 0;
  p->zText[p->nChar] = 0;
  return p->zText;
}




 void sqlite3_str_reset(StrAccum *p){
  if( (((p)->printfFlags & 0x04)!=0) ){
    sqlite3DbFree(p->db, p->zText);
    p->printfFlags &= ~0x04;
  }
  p->nAlloc = 0;
  p->nChar = 0;
  p->zText = 0;
}
# 28492 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3StrAccumInit(StrAccum *p, sqlite3 *db, char *zBase, int n, int mx){
  p->zText = zBase;
  p->db = db;
  p->nAlloc = n;
  p->mxAlloc = mx;
  p->nChar = 0;
  p->accError = 0;
  p->printfFlags = 0;
}


 sqlite3_str *sqlite3_str_new(sqlite3 *db){
  sqlite3_str *p = sqlite3_malloc64(sizeof(*p));
  if( p ){
    sqlite3StrAccumInit(p, 0, 0, 0,
            db ? db->aLimit[0] : 1000000000);
  }else{
    p = &sqlite3OomStr;
  }
  return p;
}





static char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){
  char *z;
  char zBase[70];
  StrAccum acc;
  ((void)0);
  sqlite3StrAccumInit(&acc, db, zBase, sizeof(zBase),
                      db->aLimit[0]);
  acc.printfFlags = 0x01;
  sqlite3_str_vappendf(&acc, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  if( acc.accError==7 ){
    sqlite3OomFault(db);
  }
  return z;
}





static char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){
  va_list ap;
  char *z;
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  z = sqlite3VMPrintf(db, zFormat, ap);
  ( ap = (va_list)0 );
  return z;
}





 char *sqlite3_vmprintf(const char *zFormat, va_list ap){
  char *z;
  char zBase[70];
  StrAccum acc;
# 28563 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( sqlite3_initialize() ) return 0;

  sqlite3StrAccumInit(&acc, 0, zBase, sizeof(zBase), 1000000000);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  z = sqlite3StrAccumFinish(&acc);
  return z;
}





 char *sqlite3_mprintf(const char *zFormat, ...){
  va_list ap;
  char *z;

  if( sqlite3_initialize() ) return 0;

  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  z = sqlite3_vmprintf(zFormat, ap);
  ( ap = (va_list)0 );
  return z;
}
# 28600 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){
  StrAccum acc;
  if( n<=0 ) return zBuf;







  sqlite3StrAccumInit(&acc, 0, zBuf, n, 0);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  zBuf[acc.nChar] = 0;
  return zBuf;
}
 char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){
  char *z;
  va_list ap;
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);
  ( ap = (va_list)0 );
  return z;
}
# 28638 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){
  StrAccum acc;
  char zMsg[70*3];

  sqlite3StrAccumInit(&acc, 0, zMsg, sizeof(zMsg), 0);
  sqlite3_str_vappendf(&acc, zFormat, ap);
  sqlite3Config.xLog(sqlite3Config.pLogArg, iErrCode,
                           sqlite3StrAccumFinish(&acc));
}




 void sqlite3_log(int iErrCode, const char *zFormat, ...){
  va_list ap;
  if( sqlite3Config.xLog ){
    ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    renderLogMsg(iErrCode, zFormat, ap);
    ( ap = (va_list)0 );
  }
}
# 28692 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_str_appendf(StrAccum *p, const char *zFormat, ...){
  va_list ap;
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  sqlite3_str_vappendf(p, zFormat, ap);
  ( ap = (va_list)0 );
}
# 29470 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static struct sqlite3PrngType {
  unsigned char isInit;
  unsigned char i, j;
  unsigned char s[256];
} sqlite3Prng;




 void sqlite3_randomness(int N, void *pBuf){
  unsigned char t;
  unsigned char *zBuf = pBuf;
# 29493 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define wsdPrng sqlite3Prng



  sqlite3_mutex *mutex;



  if( sqlite3_initialize() ) return;



  mutex = sqlite3MutexAlloc(5);


  sqlite3_mutex_enter(mutex);
  if( N<=0 || pBuf==0 ){
    sqlite3Prng.isInit = 0;
    sqlite3_mutex_leave(mutex);
    return;
  }
# 29524 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( !sqlite3Prng.isInit ){
    int i;
    char k[256];
    sqlite3Prng.j = 0;
    sqlite3Prng.i = 0;
    sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);
    for(i=0; i<256; i++){
      sqlite3Prng.s[i] = (u8)i;
    }
    for(i=0; i<256; i++){
      sqlite3Prng.j += sqlite3Prng.s[i] + k[i];
      t = sqlite3Prng.s[sqlite3Prng.j];
      sqlite3Prng.s[sqlite3Prng.j] = sqlite3Prng.s[i];
      sqlite3Prng.s[i] = t;
    }
    sqlite3Prng.isInit = 1;
  }

  ((void)0);
  do{
    sqlite3Prng.i++;
    t = sqlite3Prng.s[sqlite3Prng.i];
    sqlite3Prng.j += t;
    sqlite3Prng.s[sqlite3Prng.i] = sqlite3Prng.s[sqlite3Prng.j];
    sqlite3Prng.s[sqlite3Prng.j] = t;
    t += sqlite3Prng.s[sqlite3Prng.i];
    *(zBuf++) = sqlite3Prng.s[t];
  }while( --N );
  sqlite3_mutex_leave(mutex);
}
# 29565 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static struct sqlite3PrngType sqlite3SavedPrng;
static void sqlite3PrngSaveState(void){
  memcpy(
    &sqlite3SavedPrng,
    &sqlite3Prng,
    sizeof(sqlite3Prng)
  );
}
static void sqlite3PrngRestoreState(void){
  memcpy(
    &sqlite3Prng,
    &sqlite3SavedPrng,
    sizeof(sqlite3Prng)
  );
}
# 29621 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_THREADS_IMPLEMENTED 1



struct SQLiteThread {
  pthread_t tid;
  int done;
  void *pOut;
  void *(*xTask)(void*);
  void *pIn;
};


static int sqlite3ThreadCreate(
  SQLiteThread **ppThread,
  void *(*xTask)(void*),
  void *pIn
){
  SQLiteThread *p;
  int rc;

  ((void)0);
  ((void)0);

  ((void)0);

  *ppThread = 0;
  p = sqlite3Malloc(sizeof(*p));
  if( p==0 ) return 7;
  memset(p, 0, sizeof(*p));
  p->xTask = xTask;
  p->pIn = pIn;




  if( sqlite3FaultSim(200) ){
    rc = 1;
  }else{
    rc = pthread_create(&p->tid, 0, xTask, pIn);
  }
  if( rc ){
    p->done = 1;
    p->pOut = xTask(pIn);
  }
  *ppThread = p;
  return 0;
}


static int sqlite3ThreadJoin(SQLiteThread *p, void **ppOut){
  int rc;

  ((void)0);
  if( (p==0) ) return 7;
  if( p->done ){
    *ppOut = p->pOut;
    rc = 0;
  }else{
    rc = pthread_join(p->tid, ppOut) ? 1 : 0;
  }
  sqlite3_free(p);
  return rc;
}
# 29912 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const unsigned char sqlite3Utf8Trans1[] = {
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,
  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,
};


#define WRITE_UTF8(zOut,c) { if( c<0x00080 ){ *zOut++ = (u8)(c&0xFF); } else if( c<0x00800 ){ *zOut++ = 0xC0 + (u8)((c>>6)&0x1F); *zOut++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 ){ *zOut++ = 0xE0 + (u8)((c>>12)&0x0F); *zOut++ = 0x80 + (u8)((c>>6) & 0x3F); *zOut++ = 0x80 + (u8)(c & 0x3F); }else{ *zOut++ = 0xF0 + (u8)((c>>18) & 0x07); *zOut++ = 0x80 + (u8)((c>>12) & 0x3F); *zOut++ = 0x80 + (u8)((c>>6) & 0x3F); *zOut++ = 0x80 + (u8)(c & 0x3F); } }
# 29944 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WRITE_UTF16LE(zOut,c) { if( c<=0xFFFF ){ *zOut++ = (u8)(c&0x00FF); *zOut++ = (u8)((c>>8)&0x00FF); }else{ *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *zOut++ = (u8)(c&0x00FF); *zOut++ = (u8)(0x00DC + ((c>>8)&0x03)); } }
# 29956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WRITE_UTF16BE(zOut,c) { if( c<=0xFFFF ){ *zOut++ = (u8)((c>>8)&0x00FF); *zOut++ = (u8)(c&0x00FF); }else{ *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *zOut++ = (u8)(0x00DC + ((c>>8)&0x03)); *zOut++ = (u8)(c&0x00FF); } }
# 29968 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define READ_UTF16LE(zIn,TERM,c) { c = (*zIn++); c += ((*zIn++)<<8); if( c>=0xD800 && c<0xE000 && TERM ){ int c2 = (*zIn++); c2 += ((*zIn++)<<8); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } }
# 29978 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define READ_UTF16BE(zIn,TERM,c) { c = ((*zIn++)<<8); c += (*zIn++); if( c>=0xD800 && c<0xE000 && TERM ){ int c2 = ((*zIn++)<<8); c2 += (*zIn++); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } }
# 30015 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define READ_UTF8(zIn,zTerm,c) c = *(zIn++); if( c>=0xc0 ){ c = sqlite3Utf8Trans1[c-0xc0]; while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } }
# 30026 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u32 sqlite3Utf8Read(
  const unsigned char **pz
){
  unsigned int c;




  c = *((*pz)++);
  if( c>=0xc0 ){
    c = sqlite3Utf8Trans1[c-0xc0];
    while( (*(*pz) & 0xc0)==0x80 ){
      c = (c<<6) + (0x3f & *((*pz)++));
    }
    if( c<0x80
        || (c&0xFFFFF800)==0xD800
        || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; }
  }
  return c;
}
# 30062 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){
  sqlite3_int64 len;
  unsigned char *zOut;
  unsigned char *zIn;
  unsigned char *zTerm;
  unsigned char *z;
  unsigned int c;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
# 30088 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pMem->enc!=1 && desiredEnc!=1 ){
    u8 temp;
    int rc;
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    if( rc!=0 ){
      ((void)0);
      return 7;
    }
    zIn = (u8*)pMem->z;
    zTerm = &zIn[pMem->n&~1];
    while( zIn<zTerm ){
      temp = *zIn;
      *zIn = *(zIn+1);
      zIn++;
      *zIn++ = temp;
    }
    pMem->enc = desiredEnc;
    goto translate_out;
  }


  if( desiredEnc==1 ){





    pMem->n &= ~1;
    len = 2 * (sqlite3_int64)pMem->n + 1;
  }else{





    len = 2 * (sqlite3_int64)pMem->n + 2;
  }







  zIn = (u8*)pMem->z;
  zTerm = &zIn[pMem->n];
  zOut = sqlite3DbMallocRaw(pMem->db, len);
  if( !zOut ){
    return 7;
  }
  z = zOut;

  if( pMem->enc==1 ){
    if( desiredEnc==2 ){

      while( zIn<zTerm ){
        c = *(zIn++); if( c>=0xc0 ){ c = sqlite3Utf8Trans1[c-0xc0]; while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } };
        { if( c<=0xFFFF ){ *z++ = (u8)(c&0x00FF); *z++ = (u8)((c>>8)&0x00FF); }else{ *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(c&0x00FF); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); } };
      }
    }else{
      ((void)0);

      while( zIn<zTerm ){
        c = *(zIn++); if( c>=0xc0 ){ c = sqlite3Utf8Trans1[c-0xc0]; while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){ c = (c<<6) + (0x3f & *(zIn++)); } if( c<0x80 || (c&0xFFFFF800)==0xD800 || (c&0xFFFFFFFE)==0xFFFE ){ c = 0xFFFD; } };
        { if( c<=0xFFFF ){ *z++ = (u8)((c>>8)&0x00FF); *z++ = (u8)(c&0x00FF); }else{ *z++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03)); *z++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0)); *z++ = (u8)(0x00DC + ((c>>8)&0x03)); *z++ = (u8)(c&0x00FF); } };
      }
    }
    pMem->n = (int)(z - zOut);
    *z++ = 0;
  }else{
    ((void)0);
    if( pMem->enc==2 ){

      while( zIn<zTerm ){
        { c = (*zIn++); c += ((*zIn++)<<8); if( c>=0xD800 && c<0xE000 && zIn<zTerm ){ int c2 = (*zIn++); c2 += ((*zIn++)<<8); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
        { if( c<0x00080 ){ *z++ = (u8)(c&0xFF); } else if( c<0x00800 ){ *z++ = 0xC0 + (u8)((c>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 ){ *z++ = 0xE0 + (u8)((c>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };
      }
    }else{

      while( zIn<zTerm ){
        { c = ((*zIn++)<<8); c += (*zIn++); if( c>=0xD800 && c<0xE000 && zIn<zTerm ){ int c2 = ((*zIn++)<<8); c2 += (*zIn++); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
        { if( c<0x00080 ){ *z++ = (u8)(c&0xFF); } else if( c<0x00800 ){ *z++ = 0xC0 + (u8)((c>>6)&0x1F); *z++ = 0x80 + (u8)(c & 0x3F); } else if( c<0x10000 ){ *z++ = 0xE0 + (u8)((c>>12)&0x0F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); }else{ *z++ = 0xF0 + (u8)((c>>18) & 0x07); *z++ = 0x80 + (u8)((c>>12) & 0x3F); *z++ = 0x80 + (u8)((c>>6) & 0x3F); *z++ = 0x80 + (u8)(c & 0x3F); } };
      }
    }
    pMem->n = (int)(z - zOut);
  }
  *z = 0;
  ((void)0);

  c = pMem->flags;
  sqlite3VdbeMemRelease(pMem);
  pMem->flags = 0x0002|0x0200|(c&(0x003f|0x8000));
  pMem->enc = desiredEnc;
  pMem->z = (char*)zOut;
  pMem->zMalloc = pMem->z;
  pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->z);

translate_out:







  return 0;
}
# 30207 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemHandleBom(Mem *pMem){
  int rc = 0;
  u8 bom = 0;

  ((void)0);
  if( pMem->n>1 ){
    u8 b1 = *(u8 *)pMem->z;
    u8 b2 = *(((u8 *)pMem->z) + 1);
    if( b1==0xFE && b2==0xFF ){
      bom = 3;
    }
    if( b1==0xFF && b2==0xFE ){
      bom = 2;
    }
  }

  if( bom ){
    rc = sqlite3VdbeMemMakeWriteable(pMem);
    if( rc==0 ){
      pMem->n -= 2;
      memmove(pMem->z, &pMem->z[2], pMem->n);
      pMem->z[pMem->n] = '\0';
      pMem->z[pMem->n+1] = '\0';
      pMem->flags |= 0x0200;
      pMem->enc = bom;
    }
  }
  return rc;
}
# 30245 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Utf8CharLen(const char *zIn, int nByte){
  int r = 0;
  const u8 *z = (const u8*)zIn;
  const u8 *zTerm;
  if( nByte>=0 ){
    zTerm = &z[nByte];
  }else{
    zTerm = (const u8*)(-1);
  }
  ((void)0);
  while( *z!=0 && z<zTerm ){
    { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
    r++;
  }
  return r;
}
# 30299 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){
  Mem m;
  memset(&m, 0, sizeof(m));
  m.db = db;
  sqlite3VdbeMemSetStr(&m, z, nByte, enc, ((sqlite3_destructor_type)0));
  sqlite3VdbeChangeEncoding(&m, 1);
  if( db->mallocFailed ){
    sqlite3VdbeMemRelease(&m);
    m.z = 0;
  }
  ((void)0);
  ((void)0);
  ((void)0);
  return m.z;
}






static int sqlite3Utf16ByteLen(const void *zIn, int nChar){
  int c;
  unsigned char const *z = zIn;
  int n = 0;

  if( 2==3 ){
    while( n<nChar ){
      { c = ((*z++)<<8); c += (*z++); if( c>=0xD800 && c<0xE000 && 1 ){ int c2 = ((*z++)<<8); c2 += (*z++); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
      n++;
    }
  }else{
    while( n<nChar ){
      { c = (*z++); c += ((*z++)<<8); if( c>=0xD800 && c<0xE000 && 1 ){ int c2 = (*z++); c2 += ((*z++)<<8); c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10); } };
      n++;
    }
  }
  return (int)(z-(unsigned char const *)zIn);
}
# 30415 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/math.h" 1
# 11 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/math.h"
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h" 1







       
#define _INC_MATH 



__pragma(pack(push, _CRT_PACKING))

#pragma warning(push)
#pragma warning(disable:4738)
#pragma warning(disable:4820)






    struct _exception
    {
        int type;
        char* name;
        double arg1;
        double arg2;
        double retval;
    };




#define _COMPLEX_DEFINED 

        struct _complex
        {
            double x, y;
        };
# 60 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h"
    typedef float float_t;
    typedef double double_t;





#define _DOMAIN 1
#define _SING 2
#define _OVERFLOW 3
#define _UNDERFLOW 4
#define _TLOSS 5
#define _PLOSS 6






        extern double const _HUGE;






#define _HUGE_ENUF 1e+300


#define INFINITY ((float)(_HUGE_ENUF * _HUGE_ENUF))
#define HUGE_VAL ((double)INFINITY)
#define HUGE_VALF ((float)INFINITY)
#define HUGE_VALL ((long double)INFINITY)
#define NAN ((float)(INFINITY * 0.0F))

#define _DENORM (-2)
#define _FINITE (-1)
#define _INFCODE 1
#define _NANCODE 2

#define FP_INFINITE _INFCODE
#define FP_NAN _NANCODE
#define FP_NORMAL _FINITE
#define FP_SUBNORMAL _DENORM
#define FP_ZERO 0

#define _C2 1
#define FP_ILOGB0 (-0x7fffffff - _C2)
#define FP_ILOGBNAN 0x7fffffff

#define MATH_ERRNO 1
#define MATH_ERREXCEPT 2
#define math_errhandling (MATH_ERRNO | MATH_ERREXCEPT)


#define _FE_DIVBYZERO 0x04
#define _FE_INEXACT 0x20
#define _FE_INVALID 0x01
#define _FE_OVERFLOW 0x08
#define _FE_UNDERFLOW 0x10

#define _D0_C 3
#define _D1_C 2
#define _D2_C 1
#define _D3_C 0

#define _DBIAS 0x3fe
#define _DOFF 4

#define _F0_C 1
#define _F1_C 0

#define _FBIAS 0x7e
#define _FOFF 7
#define _FRND 1

#define _L0_C 3
#define _L1_C 2
#define _L2_C 1
#define _L3_C 0

#define _LBIAS 0x3fe
#define _LOFF 4


#define _DFRAC ((unsigned short)((1 << _DOFF) - 1))
#define _DMASK ((unsigned short)(0x7fff & ~_DFRAC))
#define _DMAX ((unsigned short)((1 << (15 - _DOFF)) - 1))
#define _DSIGN ((unsigned short)0x8000)


#define _FFRAC ((unsigned short)((1 << _FOFF) - 1))
#define _FMASK ((unsigned short)(0x7fff & ~_FFRAC))
#define _FMAX ((unsigned short)((1 << (15 - _FOFF)) - 1))
#define _FSIGN ((unsigned short)0x8000)


#define _LFRAC ((unsigned short)(-1))
#define _LMASK ((unsigned short)0x7fff)
#define _LMAX ((unsigned short)0x7fff)
#define _LSIGN ((unsigned short)0x8000)

#define _DHUGE_EXP (int)(_DMAX * 900L / 1000)
#define _FHUGE_EXP (int)(_FMAX * 900L / 1000)
#define _LHUGE_EXP (int)(_LMAX * 900L / 1000)

#define _DSIGN_C(_Val) (((_double_val *)(char*)&(_Val))->_Sh[_D0_C] & _DSIGN)
#define _FSIGN_C(_Val) (((_float_val *)(char*)&(_Val))->_Sh[_F0_C] & _FSIGN)
#define _LSIGN_C(_Val) (((_ldouble_val*)(char*)&(_Val))->_Sh[_L0_C] & _LSIGN)

void _fperrraise( int _Except);

 short _dclass( double _X);
 short _ldclass( long double _X);
 short _fdclass( float _X);

 int _dsign( double _X);
 int _ldsign( long double _X);
 int _fdsign( float _X);

 int _dpcomp( double _X, double _Y);
 int _ldpcomp( long double _X, long double _Y);
 int _fdpcomp( float _X, float _Y);

 short _dtest( double* _Px);
 short _ldtest( long double* _Px);
 short _fdtest( float* _Px);

 short _d_int( double* _Px, short _Xexp);
 short _ld_int( long double* _Px, short _Xexp);
 short _fd_int( float* _Px, short _Xexp);

 short _dscale( double* _Px, long _Lexp);
 short _ldscale( long double* _Px, long _Lexp);
 short _fdscale( float* _Px, long _Lexp);

 short _dunscale( short* _Pex, double* _Px);
 short _ldunscale( short* _Pex, long double* _Px);
 short _fdunscale( short* _Pex, float* _Px);

 short _dexp( double* _Px, double _Y, long _Eoff);
 short _ldexp( long double* _Px, long double _Y, long _Eoff);
 short _fdexp( float* _Px, float _Y, long _Eoff);

 short _dnorm( unsigned short* _Ps);
 short _fdnorm( unsigned short* _Ps);

 double _dpoly( double _X, double const* _Tab, int _N);
 long double _ldpoly( long double _X, long double const* _Tab, int _N);
 float _fdpoly( float _X, float const* _Tab, int _N);

 double _dlog( double _X, int _Baseflag);
 long double _ldlog( long double _X, int _Baseflag);
 float _fdlog( float _X, int _Baseflag);

 double _dsin( double _X, unsigned int _Qoff);
 long double _ldsin( long double _X, unsigned int _Qoff);
 float _fdsin( float _X, unsigned int _Qoff);


typedef union
{
    unsigned short _Sh[4];
    double _Val;
} _double_val;


typedef union
{
    unsigned short _Sh[2];
    float _Val;
} _float_val;


typedef union
{
    unsigned short _Sh[4];
    long double _Val;
} _ldouble_val;

typedef union
{
    unsigned short _Word[4];
    float _Float;
    double _Double;
    long double _Long_double;
} _float_const;

extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

extern const _float_const _Eps_C, _Rteps_C;
extern const _float_const _FEps_C, _FRteps_C;
extern const _float_const _LEps_C, _LRteps_C;

extern const double _Zero_C, _Xbig_C;
extern const float _FZero_C, _FXbig_C;
extern const long double _LZero_C, _LXbig_C;

#define _FP_LT 1
#define _FP_EQ 2
#define _FP_GT 4



#define _CLASS_ARG(_Val) __pragma(warning(suppress:6334))(sizeof ((_Val) + (float)0) == sizeof (float) ? 'f' : sizeof ((_Val) + (double)0) == sizeof (double) ? 'd' : 'l')
#define _CLASSIFY(_Val,_FFunc,_DFunc,_LDFunc) (_CLASS_ARG(_Val) == 'f' ? _FFunc((float)(_Val)) : _CLASS_ARG(_Val) == 'd' ? _DFunc((double)(_Val)) : _LDFunc((long double)(_Val)))
#define _CLASSIFY2(_Val1,_Val2,_FFunc,_DFunc,_LDFunc) (_CLASS_ARG((_Val1) + (_Val2)) == 'f' ? _FFunc((float)(_Val1), (float)(_Val2)) : _CLASS_ARG((_Val1) + (_Val2)) == 'd' ? _DFunc((double)(_Val1), (double)(_Val2)) : _LDFunc((long double)(_Val1), (long double)(_Val2)))

#define fpclassify(_Val) (_CLASSIFY(_Val, _fdclass, _dclass, _ldclass))
#define _FPCOMPARE(_Val1,_Val2) (_CLASSIFY2(_Val1, _Val2, _fdpcomp, _dpcomp, _ldpcomp))

#define isfinite(_Val) (fpclassify(_Val) <= 0)
#define isinf(_Val) (fpclassify(_Val) == FP_INFINITE)
#define isnan(_Val) (fpclassify(_Val) == FP_NAN)
#define isnormal(_Val) (fpclassify(_Val) == FP_NORMAL)
#define signbit(_Val) (_CLASSIFY(_Val, _fdsign, _dsign, _ldsign))

#define isgreater(x,y) ((_FPCOMPARE(x, y) & _FP_GT) != 0)
#define isgreaterequal(x,y) ((_FPCOMPARE(x, y) & (_FP_EQ | _FP_GT)) != 0)
#define isless(x,y) ((_FPCOMPARE(x, y) & _FP_LT) != 0)
#define islessequal(x,y) ((_FPCOMPARE(x, y) & (_FP_LT | _FP_EQ)) != 0)
#define islessgreater(x,y) ((_FPCOMPARE(x, y) & (_FP_LT | _FP_GT)) != 0)
#define isunordered(x,y) (_FPCOMPARE(x, y) == 0)
# 465 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h"
    int abs( int _X);
    long labs( long _X);
    long long llabs( long long _X);

    double acos( double _X);
    double asin( double _X);
    double atan( double _X);
    double atan2( double _Y, double _X);

    double cos( double _X);
    double cosh( double _X);
    double exp( double _X);
    double fabs( double _X);
    double fmod( double _X, double _Y);
    double log( double _X);
    double log10( double _X);
    double pow( double _X, double _Y);
    double sin( double _X);
    double sinh( double _X);
    double sqrt( double _X);
    double tan( double _X);
    double tanh( double _X);

    double acosh( double _X);
    double asinh( double _X);
    double atanh( double _X);
    double atof( char const* _String);
    double _atof_l( char const* _String, _locale_t _Locale);
    double _cabs( struct _complex _Complex_value);
    double cbrt( double _X);
    double ceil( double _X);
    double _chgsign( double _X);
    double copysign( double _Number, double _Sign);
    double _copysign( double _Number, double _Sign);
    double erf( double _X);
    double erfc( double _X);
    double exp2( double _X);
    double expm1( double _X);
    double fdim( double _X, double _Y);
    double floor( double _X);
    double fma( double _X, double _Y, double _Z);
    double fmax( double _X, double _Y);
    double fmin( double _X, double _Y);
    double frexp( double _X, int* _Y);
    double hypot( double _X, double _Y);
    double _hypot( double _X, double _Y);
    int ilogb( double _X);
    double ldexp( double _X, int _Y);
    double lgamma( double _X);
    long long llrint( double _X);
    long long llround( double _X);
    double log1p( double _X);
    double log2( double _X);
    double logb( double _X);
    long lrint( double _X);
    long lround( double _X);

    int _matherr( struct _exception* _Except);

    double modf( double _X, double* _Y);
    double nan( char const* _X);
    double nearbyint( double _X);
    double nextafter( double _X, double _Y);
    double nexttoward( double _X, long double _Y);
    double remainder( double _X, double _Y);
    double remquo( double _X, double _Y, int* _Z);
    double rint( double _X);
    double round( double _X);
    double scalbln( double _X, long _Y);
    double scalbn( double _X, int _Y);
    double tgamma( double _X);
    double trunc( double _X);
    double _j0( double _X );
    double _j1( double _X );
    double _jn(int _X, double _Y);
    double _y0( double _X);
    double _y1( double _X);
    double _yn( int _X, double _Y);

    float acoshf( float _X);
    float asinhf( float _X);
    float atanhf( float _X);
    float cbrtf( float _X);
    float _chgsignf( float _X);
    float copysignf( float _Number, float _Sign);
    float _copysignf( float _Number, float _Sign);
    float erff( float _X);
    float erfcf( float _X);
    float expm1f( float _X);
    float exp2f( float _X);
    float fdimf( float _X, float _Y);
    float fmaf( float _X, float _Y, float _Z);
    float fmaxf( float _X, float _Y);
    float fminf( float _X, float _Y);
    float _hypotf( float _X, float _Y);
    int ilogbf( float _X);
    float lgammaf( float _X);
    long long llrintf( float _X);
    long long llroundf( float _X);
    float log1pf( float _X);
    float log2f( float _X);
    float logbf( float _X);
    long lrintf( float _X);
    long lroundf( float _X);
    float nanf( char const* _X);
    float nearbyintf( float _X);
    float nextafterf( float _X, float _Y);
    float nexttowardf( float _X, long double _Y);
    float remainderf( float _X, float _Y);
    float remquof( float _X, float _Y, int* _Z);
    float rintf( float _X);
    float roundf( float _X);
    float scalblnf( float _X, long _Y);
    float scalbnf( float _X, int _Y);
    float tgammaf( float _X);
    float truncf( float _X);
# 621 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h"
        __inline float acosf( float _X)
        {
            return (float)acos(_X);
        }

        __inline float asinf( float _X)
        {
            return (float)asin(_X);
        }

        __inline float atan2f( float _Y, float _X)
        {
            return (float)atan2(_Y, _X);
        }

        __inline float atanf( float _X)
        {
            return (float)atan(_X);
        }

        __inline float ceilf( float _X)
        {
            return (float)ceil(_X);
        }

        __inline float cosf( float _X)
        {
            return (float)cos(_X);
        }

        __inline float coshf( float _X)
        {
            return (float)cosh(_X);
        }

        __inline float expf( float _X)
        {
            return (float)exp(_X);
        }
# 669 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h"
        __inline float fabsf( float _X)
        {
            return (float)fabs(_X);
        }
# 683 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h"
        __inline float floorf( float _X)
        {
            return (float)floor(_X);
        }

        __inline float fmodf( float _X, float _Y)
        {
            return (float)fmod(_X, _Y);
        }



    __inline float frexpf( float _X, int *_Y)
    {
        return (float)frexp(_X, _Y);
    }

    __inline float hypotf( float _X, float _Y)
    {
        return _hypotf(_X, _Y);
    }

    __inline float ldexpf( float _X, int _Y)
    {
        return (float)ldexp(_X, _Y);
    }
# 724 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h"
        __inline float log10f( float _X)
        {
            return (float)log10(_X);
        }

        __inline float logf( float _X)
        {
            return (float)log(_X);
        }

        __inline float modff( float _X, float* _Y)
        {
            double _F, _I;
            _F = modf(_X, &_I);
            *_Y = (float)_I;
            return (float)_F;
        }

        __inline float powf( float _X, float _Y)
        {
            return (float)pow(_X, _Y);
        }

        __inline float sinf( float _X)
        {
            return (float)sin(_X);
        }

        __inline float sinhf( float _X)
        {
            return (float)sinh(_X);
        }

        __inline float sqrtf( float _X)
        {
            return (float)sqrt(_X);
        }

        __inline float tanf( float _X)
        {
            return (float)tan(_X);
        }

        __inline float tanhf( float _X)
        {
            return (float)tanh(_X);
        }



    long double acoshl( long double _X);

    __inline long double acosl( long double _X)
    {
        return acos((double)_X);
    }

    long double asinhl( long double _X);

    __inline long double asinl( long double _X)
    {
        return asin((double)_X);
    }

    __inline long double atan2l( long double _Y, long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

    long double atanhl( long double _X);

    __inline long double atanl( long double _X)
    {
        return atan((double)_X);
    }

    long double cbrtl( long double _X);

    __inline long double ceill( long double _X)
    {
        return ceil((double)_X);
    }

    __inline long double _chgsignl( long double _X)
    {
        return _chgsign((double)_X);
    }

    long double copysignl( long double _Number, long double _Sign);

    __inline long double _copysignl( long double _Number, long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

    __inline long double coshl( long double _X)
    {
        return cosh((double)_X);
    }

    __inline long double cosl( long double _X)
    {
        return cos((double)_X);
    }

    long double erfl( long double _X);
    long double erfcl( long double _X);

    __inline long double expl( long double _X)
    {
        return exp((double)_X);
    }

    long double exp2l( long double _X);
    long double expm1l( long double _X);

    __inline long double fabsl( long double _X)
    {
        return fabs((double)_X);
    }

    long double fdiml( long double _X, long double _Y);

    __inline long double floorl( long double _X)
    {
        return floor((double)_X);
    }

    long double fmal( long double _X, long double _Y, long double _Z);
    long double fmaxl( long double _X, long double _Y);
    long double fminl( long double _X, long double _Y);

    __inline long double fmodl( long double _X, long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

    __inline long double frexpl( long double _X, int *_Y)
    {
        return frexp((double)_X, _Y);
    }

    int ilogbl( long double _X);

    __inline long double _hypotl( long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

    __inline long double hypotl( long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

    __inline long double ldexpl( long double _X, int _Y)
    {
        return ldexp((double)_X, _Y);
    }

    long double lgammal( long double _X);
    long long llrintl( long double _X);
    long long llroundl( long double _X);

    __inline long double logl( long double _X)
    {
        return log((double)_X);
    }

    __inline long double log10l( long double _X)
    {
        return log10((double)_X);
    }

    long double log1pl( long double _X);
    long double log2l( long double _X);
    long double logbl( long double _X);
    long lrintl( long double _X);
    long lroundl( long double _X);

    __inline long double modfl( long double _X, long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

    long double nanl( char const* _X);
    long double nearbyintl( long double _X);
    long double nextafterl( long double _X, long double _Y);
    long double nexttowardl( long double _X, long double _Y);

    __inline long double powl( long double _X, long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

    long double remainderl( long double _X, long double _Y);
    long double remquol( long double _X, long double _Y, int* _Z);
    long double rintl( long double _X);
    long double roundl( long double _X);
    long double scalblnl( long double _X, long _Y);
    long double scalbnl( long double _X, int _Y);

    __inline long double sinhl( long double _X)
    {
        return sinh((double)_X);
    }

    __inline long double sinl( long double _X)
    {
        return sin((double)_X);
    }

    __inline long double sqrtl( long double _X)
    {
        return sqrt((double)_X);
    }

    __inline long double tanhl( long double _X)
    {
        return tanh((double)_X);
    }

    __inline long double tanl( long double _X)
    {
        return tan((double)_X);
    }

    long double tgammal( long double _X);
    long double truncl( long double _X);


#define _matherrl _matherr
# 991 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/corecrt_math.h"
#pragma warning(pop)

__pragma(pack(pop))
# 12 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/math.h" 2
# 30416 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 30447 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3FaultSim(int iTest){
  int (*xCallback)(int) = sqlite3Config.xTestCallback;
  return xCallback ? xCallback(iTest) : 0;
}






static int sqlite3IsNaN(double x){
  u64 y;
  memcpy(&y,&x,sizeof(y));
  return (((y)&(((u64)0x7ff)<<52))==(((u64)0x7ff)<<52) && ((y)&((((u64)1)<<52)-1))!=0);
}
# 30472 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Strlen30(const char *z){
  if( z==0 ) return 0;
  return 0x3fffffff & (int)strlen(z);
}
# 30484 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *sqlite3ColumnType(Column *pCol, char *zDflt){
  if( (pCol->colFlags & 0x0004)==0 ) return zDflt;
  return pCol->zName + strlen(pCol->zName) + 1;
}






static __attribute__((noinline)) void sqlite3ErrorFinish(sqlite3 *db, int err_code){
  if( db->pErr ) sqlite3ValueSetNull(db->pErr);
  sqlite3SystemError(db, err_code);
}






static void sqlite3Error(sqlite3 *db, int err_code){
  ((void)0);
  db->errCode = err_code;
  if( err_code || db->pErr ) sqlite3ErrorFinish(db, err_code);
}





static void sqlite3SystemError(sqlite3 *db, int rc){
  if( rc==(10 | (12<<8)) ) return;
  rc &= 0xff;
  if( rc==14 || rc==10 ){
    db->iSysErrno = sqlite3OsGetLastError(db->pVfs);
  }
}
# 30543 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ErrorWithMsg(sqlite3 *db, int err_code, const char *zFormat, ...){
  ((void)0);
  db->errCode = err_code;
  sqlite3SystemError(db, err_code);
  if( zFormat==0 ){
    sqlite3Error(db, err_code);
  }else if( db->pErr || (db->pErr = sqlite3ValueNew(db))!=0 ){
    char *z;
    va_list ap;
    ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    z = sqlite3VMPrintf(db, zFormat, ap);
    ( ap = (va_list)0 );
    sqlite3ValueSetStr(db->pErr, -1, z, 1, ((sqlite3_destructor_type)sqlite3MallocSize));
  }
}
# 30576 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){
  char *zMsg;
  va_list ap;
  sqlite3 *db = pParse->db;
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  zMsg = sqlite3VMPrintf(db, zFormat, ap);
  ( ap = (va_list)0 );
  if( db->suppressErr ){
    sqlite3DbFree(db, zMsg);
  }else{
    pParse->nErr++;
    sqlite3DbFree(db, pParse->zErrMsg);
    pParse->zErrMsg = zMsg;
    pParse->rc = 1;
  }
}






static int sqlite3ErrorToParser(sqlite3 *db, int errCode){
  Parse *pParse;
  if( db==0 || (pParse = db->pParse)==0 ) return errCode;
  pParse->rc = errCode;
  pParse->nErr++;
  return errCode;
}
# 30623 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Dequote(char *z){
  char quote;
  int i, j;
  if( z==0 ) return;
  quote = z[0];
  if( !(sqlite3CtypeMap[(unsigned char)(quote)]&0x80) ) return;
  if( quote=='[' ) quote = ']';
  for(i=1, j=0;; i++){
    ((void)0);
    if( z[i]==quote ){
      if( z[i+1]==quote ){
        z[j++] = quote;
        i++;
      }else{
        break;
      }
    }else{
      z[j++] = z[i];
    }
  }
  z[j] = 0;
}
static void sqlite3DequoteExpr(Expr *p){
  ((void)0);
  p->flags |= p->u.zToken[0]=='"' ? 0x4000000|0x000040 : 0x4000000;
  sqlite3Dequote(p->u.zToken);
}




static void sqlite3TokenInit(Token *p, char *z){
  p->z = z;
  p->n = sqlite3Strlen30(z);
}


#define UpperToLower sqlite3UpperToLower
# 30672 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_stricmp(const char *zLeft, const char *zRight){
  if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else if( zRight==0 ){
    return 1;
  }
  return sqlite3StrICmp(zLeft, zRight);
}
static int sqlite3StrICmp(const char *zLeft, const char *zRight){
  unsigned char *a, *b;
  int c, x;
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  for(;;){
    c = *a;
    x = *b;
    if( c==x ){
      if( c==0 ) break;
    }else{
      c = (int)sqlite3UpperToLower[c] - (int)sqlite3UpperToLower[x];
      if( c ) break;
    }
    a++;
    b++;
  }
  return c;
}
 int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){
  register unsigned char *a, *b;
  if( zLeft==0 ){
    return zRight ? -1 : 0;
  }else if( zRight==0 ){
    return 1;
  }
  a = (unsigned char *)zLeft;
  b = (unsigned char *)zRight;
  while( N-- > 0 && *a!=0 && sqlite3UpperToLower[*a]==sqlite3UpperToLower[*b]){ a++; b++; }
  return N<0 ? 0 : sqlite3UpperToLower[*a] - sqlite3UpperToLower[*b];
}







static long double sqlite3Pow10(int E){
# 30739 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  long double x = 10.0;
  long double r = 1.0;
  while(1){
    if( E & 1 ) r *= x;
    E >>= 1;
    if( E==0 ) break;
    x *= x;
  }
  return r;

}
# 30780 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){

  int incr;
  const char *zEnd = z + length;

  int sign = 1;
  i64 s = 0;
  int d = 0;
  int esign = 1;
  int e = 0;
  int eValid = 1;
  double result;
  int nDigit = 0;
  int eType = 1;

  ((void)0);
  *pResult = 0.0;

  if( enc==1 ){
    incr = 1;
  }else{
    int i;
    incr = 2;
    ((void)0);
    ;
    ;
    for(i=3-enc; i<length && z[i]==0; i+=2){}
    if( i<length ) eType = -100;
    zEnd = &z[i^1];
    z += (enc&1);
  }


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z+=incr;
  if( z>=zEnd ) return 0;


  if( *z=='-' ){
    sign = -1;
    z+=incr;
  }else if( *z=='+' ){
    z+=incr;
  }


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
    s = s*10 + (*z - '0');
    z+=incr; nDigit++;
    if( s>=(((0xffffffff|(((i64)0x7fffffff)<<32))-9)/10) ){


      while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){ z+=incr; d++; }
    }
  }
  if( z>=zEnd ) goto do_atof_calc;


  if( *z=='.' ){
    z+=incr;
    eType++;


    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
      if( s<(((0xffffffff|(((i64)0x7fffffff)<<32))-9)/10) ){
        s = s*10 + (*z - '0');
        d--;
        nDigit++;
      }
      z+=incr;
    }
  }
  if( z>=zEnd ) goto do_atof_calc;


  if( *z=='e' || *z=='E' ){
    z+=incr;
    eValid = 0;
    eType++;




    if( z>=zEnd ) goto do_atof_calc;


    if( *z=='-' ){
      esign = -1;
      z+=incr;
    }else if( *z=='+' ){
      z+=incr;
    }

    while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
      e = e<10000 ? (e*10 + (*z - '0')) : 10000;
      z+=incr;
      eValid = 1;
    }
  }


  while( z<zEnd && (sqlite3CtypeMap[(unsigned char)(*z)]&0x01) ) z+=incr;

do_atof_calc:

  e = (e*esign) + d;
  if( e<0 ) {
    esign = -1;
    e *= -1;
  } else {
    esign = 1;
  }

  if( s==0 ) {

    result = sign<0 ? -(double)0 : (double)0;
  } else {






    while( e>0 ){
      if( esign>0 ){
        if( s>=((0xffffffff|(((i64)0x7fffffff)<<32))/10) ) break;
        s *= 10;
      }else{
        if( s%10!=0 ) break;
        s /= 10;
      }
      e--;
    }


    s = sign<0 ? -s : s;

    if( e==0 ){
      result = (double)s;
    }else{

      if( e>307 ){
        if( e<342 ){
          long double scale = sqlite3Pow10(e-308);
          if( esign<0 ){
            result = s / scale;
            result /= 1.0e+308;
          }else{
            result = s * scale;
            result *= 1.0e+308;
          }
        }else{ ((void)0);
          if( esign<0 ){
            result = 0.0*s;
          }else{

            result = ((float)(1e+300 * 1e+300))*s;



          }
        }
      }else{
        long double scale = sqlite3Pow10(e);
        if( esign<0 ){
          result = s / scale;
        }else{
          result = s * scale;
        }
      }
    }
  }


  *pResult = result;


  if( z==zEnd && nDigit>0 && eValid && eType>0 ){
    return eType;
  }else if( eType>=2 && (eType==3 || eValid) && nDigit>0 ){
    return -1;
  }else{
    return 0;
  }



}
# 30982 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int compare2pow63(const char *zNum, int incr){
  int c = 0;
  int i;

  const char *pow63 = "922337203685477580";
  for(i=0; c==0 && i<18; i++){
    c = (zNum[i*incr]-pow63[i])*10;
  }
  if( c==0 ){
    c = zNum[18*incr] - '8';
    ;
    ;
    ;
  }
  return c;
}
# 31015 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){
  int incr;
  u64 u = 0;
  int neg = 0;
  int i;
  int c = 0;
  int nonNum = 0;
  int rc;
  const char *zStart;
  const char *zEnd = zNum + length;
  ((void)0);
  if( enc==1 ){
    incr = 1;
  }else{
    incr = 2;
    ((void)0);
    for(i=3-enc; i<length && zNum[i]==0; i+=2){}
    nonNum = i<length;
    zEnd = &zNum[i^1];
    zNum += (enc&1);
  }
  while( zNum<zEnd && (sqlite3CtypeMap[(unsigned char)(*zNum)]&0x01) ) zNum+=incr;
  if( zNum<zEnd ){
    if( *zNum=='-' ){
      neg = 1;
      zNum+=incr;
    }else if( *zNum=='+' ){
      zNum+=incr;
    }
  }
  zStart = zNum;
  while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; }
  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){
    u = u*10 + c - '0';
  }
  ;
  ;
  ;
  if( u>(0xffffffff|(((i64)0x7fffffff)<<32)) ){




    *pNum = neg ? (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : (0xffffffff|(((i64)0x7fffffff)<<32));
  }else if( neg ){
    *pNum = -(i64)u;
  }else{
    *pNum = (i64)u;
  }
  rc = 0;
  if( i==0 && zStart==zNum ){
    rc = -1;
  }else if( nonNum ){
    rc = 1;
  }else if( &zNum[i]<zEnd ){
    int jj = i;
    do{
      if( !(sqlite3CtypeMap[(unsigned char)(zNum[jj])]&0x01) ){
        rc = 1;
        break;
      }
      jj += incr;
    }while( &zNum[jj]<zEnd );
  }
  if( i<19*incr ){

    ((void)0);
    return rc;
  }else{

    c = i>19*incr ? 1 : compare2pow63(zNum, incr);
    if( c<0 ){

      ((void)0);
      return rc;
    }else{
      *pNum = neg ? (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : (0xffffffff|(((i64)0x7fffffff)<<32));
      if( c>0 ){

        return 2;
      }else{


        ((void)0);
        return neg ? rc : 3;
      }
    }
  }
}
# 31117 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3DecOrHexToI64(const char *z, i64 *pOut){

  if( z[0]=='0'
   && (z[1]=='x' || z[1]=='X')
  ){
    u64 u = 0;
    int i, k;
    for(i=2; z[i]=='0'; i++){}
    for(k=i; (sqlite3CtypeMap[(unsigned char)(z[k])]&0x08); k++){
      u = u*16 + sqlite3HexToInt(z[k]);
    }
    memcpy(pOut, &u, 8);
    return (z[k]==0 && k-i<=16) ? 0 : 2;
  }else

  {
    return sqlite3Atoi64(z, pOut, sqlite3Strlen30(z), 1);
  }
}
# 31147 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3GetInt32(const char *zNum, int *pValue){
  sqlite_int64 v = 0;
  int i, c;
  int neg = 0;
  if( zNum[0]=='-' ){
    neg = 1;
    zNum++;
  }else if( zNum[0]=='+' ){
    zNum++;
  }

  else if( zNum[0]=='0'
        && (zNum[1]=='x' || zNum[1]=='X')
        && (sqlite3CtypeMap[(unsigned char)(zNum[2])]&0x08)
  ){
    u32 u = 0;
    zNum += 2;
    while( zNum[0]=='0' ) zNum++;
    for(i=0; (sqlite3CtypeMap[(unsigned char)(zNum[i])]&0x08) && i<8; i++){
      u = u*16 + sqlite3HexToInt(zNum[i]);
    }
    if( (u&0x80000000)==0 && (sqlite3CtypeMap[(unsigned char)(zNum[i])]&0x08)==0 ){
      memcpy(pValue, &u, 4);
      return 1;
    }else{
      return 0;
    }
  }

  if( !(sqlite3CtypeMap[(unsigned char)(zNum[0])]&0x04) ) return 0;
  while( zNum[0]=='0' ) zNum++;
  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){
    v = v*10 + c;
  }






  ;
  if( i>10 ){
    return 0;
  }
  ;
  if( v-neg>2147483647 ){
    return 0;
  }
  if( neg ){
    v = -v;
  }
  *pValue = (int)v;
  return 1;
}





static int sqlite3Atoi(const char *z){
  int x = 0;
  if( z ) sqlite3GetInt32(z, &x);
  return x;
}
# 31241 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int __attribute__((noinline)) putVarint64(unsigned char *p, u64 v){
  int i, j, n;
  u8 buf[10];
  if( v & (((u64)0xff000000)<<32) ){
    p[8] = (u8)v;
    v >>= 8;
    for(i=7; i>=0; i--){
      p[i] = (u8)((v & 0x7f) | 0x80);
      v >>= 7;
    }
    return 9;
  }
  n = 0;
  do{
    buf[n++] = (u8)((v & 0x7f) | 0x80);
    v >>= 7;
  }while( v!=0 );
  buf[0] &= 0x7f;
  ((void)0);
  for(i=0, j=n-1; j>=0; j--, i++){
    p[i] = buf[j];
  }
  return n;
}
static int sqlite3PutVarint(unsigned char *p, u64 v){
  if( v<=0x7f ){
    p[0] = v&0x7f;
    return 1;
  }
  if( v<=0x3fff ){
    p[0] = ((v>>7)&0x7f)|0x80;
    p[1] = v&0x7f;
    return 2;
  }
  return putVarint64(p,v);
}
# 31287 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SLOT_2_0 0x001fc07f
#define SLOT_4_2_0 0xf01fc07f






static u8 sqlite3GetVarint(const unsigned char *p, u64 *v){
  u32 a,b,s;

  if( ((signed char*)p)[0]>=0 ){
    *v = *p;
    return 1;
  }
  if( ((signed char*)p)[1]>=0 ){
    *v = ((u32)(p[0]&0x7f)<<7) | p[1];
    return 2;
  }


  ((void)0);
  ((void)0);

  a = ((u32)p[0])<<14;
  b = p[1];
  p += 2;
  a |= *p;

  if (!(a&0x80))
  {
    a &= 0x001fc07f;
    b &= 0x7f;
    b = b<<7;
    a |= b;
    *v = a;
    return 3;
  }


  a &= 0x001fc07f;
  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {
    b &= 0x001fc07f;


    a = a<<7;
    a |= b;
    *v = a;
    return 4;
  }






  b &= 0x001fc07f;
  s = a;


  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {




    b = b<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 5;
  }


  s = s<<7;
  s |= b;


  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {


    a &= 0x001fc07f;
    a = a<<7;
    a |= b;
    s = s>>18;
    *v = ((u64)s)<<32 | a;
    return 6;
  }

  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {
    a &= 0xf01fc07f;
    b &= 0x001fc07f;
    b = b<<7;
    a |= b;
    s = s>>11;
    *v = ((u64)s)<<32 | a;
    return 7;
  }


  a &= 0x001fc07f;
  p++;
  b = b<<14;
  b |= *p;

  if (!(b&0x80))
  {
    b &= 0xf01fc07f;


    a = a<<7;
    a |= b;
    s = s>>4;
    *v = ((u64)s)<<32 | a;
    return 8;
  }

  p++;
  a = a<<15;
  a |= *p;




  b &= 0x001fc07f;
  b = b<<8;
  a |= b;

  s = s<<4;
  b = p[-4];
  b &= 0x7f;
  b = b>>3;
  s |= b;

  *v = ((u64)s)<<32 | a;

  return 9;
}
# 31456 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){
  u32 a,b;



  a = *p;
# 31473 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  p++;
  b = *p;

  if (!(b&0x80))
  {

    a &= 0x7f;
    a = a<<7;
    *v = a | b;
    return 2;
  }


  p++;
  a = a<<14;
  a |= *p;

  if (!(a&0x80))
  {

    a &= (0x7f<<14)|(0x7f);
    b &= 0x7f;
    b = b<<7;
    *v = a | b;
    return 3;
  }
# 31510 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  {
    u64 v64;
    u8 n;

    p -= 2;
    n = sqlite3GetVarint(p, &v64);
    ((void)0);
    if( (v64 & ((((u64)1)<<32)-1))!=v64 ){
      *v = 0xffffffff;
    }else{
      *v = (u32)v64;
    }
    return n;
  }
# 31573 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}





static int sqlite3VarintLen(u64 v){
  int i;
  for(i=1; (v >>= 7)!=0; i++){ ((void)0); }
  return i;
}





static u32 sqlite3Get4byte(const u8 *p){





  u32 x;
  memcpy(&x,p,4);
  return __builtin_bswap32(x);
# 31606 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
static void sqlite3Put4byte(unsigned char *p, u32 v){



  u32 x = __builtin_bswap32(v);
  memcpy(p,&x,4);
# 31622 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
# 31631 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u8 sqlite3HexToInt(int h){
  ((void)0);

  h += 9*(1&(h>>6));




  return (u8)(h & 0xf);
}
# 31649 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){
  char *zBlob;
  int i;

  zBlob = (char *)sqlite3DbMallocRawNN(db, n/2 + 1);
  n--;
  if( zBlob ){
    for(i=0; i<n; i+=2){
      zBlob[i/2] = (sqlite3HexToInt(z[i])<<4) | sqlite3HexToInt(z[i+1]);
    }
    zBlob[i/2] = 0;
  }
  return zBlob;
}







static void logBadConnection(const char *zType){
  sqlite3_log(21,
     "API call with %s database connection pointer",
     zType
  );
}
# 31691 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3SafetyCheckOk(sqlite3 *db){
  u32 magic;
  if( db==0 ){
    logBadConnection("NULL");
    return 0;
  }
  magic = db->magic;
  if( magic!=0xa029a697 ){
    if( sqlite3SafetyCheckSickOrOk(db) ){
      ;
      logBadConnection("unopened");
    }
    return 0;
  }else{
    return 1;
  }
}
static int sqlite3SafetyCheckSickOrOk(sqlite3 *db){
  u32 magic;
  magic = db->magic;
  if( magic!=0x4b771290 &&
      magic!=0xa029a697 &&
      magic!=0xf03b7906 ){
    ;
    logBadConnection("invalid");
    return 0;
  }else{
    return 1;
  }
}







static int sqlite3AddInt64(i64 *pA, i64 iB){

  return __builtin_add_overflow(*pA, iB, pA);
# 31747 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
static int sqlite3SubInt64(i64 *pA, i64 iB){

  return __builtin_sub_overflow(*pA, iB, pA);
# 31762 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
static int sqlite3MulInt64(i64 *pA, i64 iB){

  return __builtin_mul_overflow(*pA, iB, pA);
# 31783 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}





static int sqlite3AbsInt32(int x){
  if( x>=0 ) return x;
  if( x==(int)0x80000000 ) return 0x7fffffff;
  return -x;
}
# 31832 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static LogEst sqlite3LogEstAdd(LogEst a, LogEst b){
  static const unsigned char x[] = {
     10, 10,
      9, 9,
      8, 8,
      7, 7, 7,
      6, 6, 6,
      5, 5, 5,
      4, 4, 4, 4,
      3, 3, 3, 3, 3, 3,
      2, 2, 2, 2, 2, 2, 2,
  };
  if( a>=b ){
    if( a>b+49 ) return a;
    if( a>b+31 ) return a+1;
    return a+x[a-b];
  }else{
    if( b>a+49 ) return b;
    if( b>a+31 ) return b+1;
    return b+x[b-a];
  }
}





static LogEst sqlite3LogEst(u64 x){
  static LogEst a[] = { 0, 2, 3, 5, 6, 7, 8, 9 };
  LogEst y = 40;
  if( x<8 ){
    if( x<2 ) return 0;
    while( x<8 ){ y -= 10; x <<= 1; }
  }else{

    int i = 60 - __builtin_clzll(x);
    y += i*10;
    x >>= i;




  }
  return a[x&7] + y - 10;
}






static LogEst sqlite3LogEstFromDouble(double x){
  u64 a;
  LogEst e;
  ((void)0);
  if( x<=1 ) return 0;
  if( x<=2000000000 ) return sqlite3LogEst((u64)x);
  memcpy(&a, &x, 8);
  e = (a>>52) - 1022;
  return e*10;
}
# 31958 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static VList *sqlite3VListAdd(
  sqlite3 *db,
  VList *pIn,
  const char *zName,
  int nName,
  int iVal
){
  int nInt;
  char *z;
  int i;

  nInt = nName/4 + 3;
  ((void)0);
  if( pIn==0 || pIn[1]+nInt > pIn[0] ){

    sqlite3_int64 nAlloc = (pIn ? 2*(sqlite3_int64)pIn[0] : 10) + nInt;
    VList *pOut = sqlite3DbRealloc(db, pIn, nAlloc*sizeof(int));
    if( pOut==0 ) return pIn;
    if( pIn==0 ) pOut[1] = 2;
    pIn = pOut;
    pIn[0] = nAlloc;
  }
  i = pIn[1];
  pIn[i] = iVal;
  pIn[i+1] = nInt;
  z = (char*)&pIn[i+2];
  pIn[1] = i+nInt;
  ((void)0);
  memcpy(z, zName, nName);
  z[nName] = 0;
  return pIn;
}






static const char *sqlite3VListNumToName(VList *pIn, int iVal){
  int i, mx;
  if( pIn==0 ) return 0;
  mx = pIn[1];
  i = 2;
  do{
    if( pIn[i]==iVal ) return (char*)&pIn[i+2];
    i += pIn[i+1];
  }while( i<mx );
  return 0;
}





static int sqlite3VListNameToNum(VList *pIn, const char *zName, int nName){
  int i, mx;
  if( pIn==0 ) return 0;
  mx = pIn[1];
  i = 2;
  do{
    const char *z = (const char*)&pIn[i+2];
    if( strncmp(z,zName,nName)==0 && z[nName]==0 ) return pIn[i];
    i += pIn[i+1];
  }while( i<mx );
  return 0;
}
# 32049 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3HashInit(Hash *pNew){
  ((void)0);
  pNew->first = 0;
  pNew->count = 0;
  pNew->htsize = 0;
  pNew->ht = 0;
}





static void sqlite3HashClear(Hash *pH){
  HashElem *elem;

  ((void)0);
  elem = pH->first;
  pH->first = 0;
  sqlite3_free(pH->ht);
  pH->ht = 0;
  pH->htsize = 0;
  while( elem ){
    HashElem *next_elem = elem->next;
    sqlite3_free(elem);
    elem = next_elem;
  }
  pH->count = 0;
}




static unsigned int strHash(const char *z){
  unsigned int h = 0;
  unsigned char c;
  while( (c = (unsigned char)*z++)!=0 ){



    h += sqlite3UpperToLower[c];
    h *= 0x9e3779b1;
  }
  return h;
}





static void insertElement(
  Hash *pH,
  struct _ht *pEntry,
  HashElem *pNew
){
  HashElem *pHead;
  if( pEntry ){
    pHead = pEntry->count ? pEntry->chain : 0;
    pEntry->count++;
    pEntry->chain = pNew;
  }else{
    pHead = 0;
  }
  if( pHead ){
    pNew->next = pHead;
    pNew->prev = pHead->prev;
    if( pHead->prev ){ pHead->prev->next = pNew; }
    else { pH->first = pNew; }
    pHead->prev = pNew;
  }else{
    pNew->next = pH->first;
    if( pH->first ){ pH->first->prev = pNew; }
    pNew->prev = 0;
    pH->first = pNew;
  }
}
# 32132 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int rehash(Hash *pH, unsigned int new_size){
  struct _ht *new_ht;
  HashElem *elem, *next_elem;


  if( new_size*sizeof(struct _ht)>1024 ){
    new_size = 1024/sizeof(struct _ht);
  }
  if( new_size==pH->htsize ) return 0;
# 32151 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3BeginBenignMalloc();
  new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );
  sqlite3EndBenignMalloc();

  if( new_ht==0 ) return 0;
  sqlite3_free(pH->ht);
  pH->ht = new_ht;
  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);
  memset(new_ht, 0, new_size*sizeof(struct _ht));
  for(elem=pH->first, pH->first=0; elem; elem = next_elem){
    unsigned int h = strHash(elem->pKey) % new_size;
    next_elem = elem->next;
    insertElement(pH, &new_ht[h], elem);
  }
  return 1;
}






static HashElem *findElementWithHash(
  const Hash *pH,
  const char *pKey,
  unsigned int *pHash
){
  HashElem *elem;
  unsigned int count;
  unsigned int h;
  static HashElem nullElement = { 0, 0, 0, 0 };

  if( pH->ht ){
    struct _ht *pEntry;
    h = strHash(pKey) % pH->htsize;
    pEntry = &pH->ht[h];
    elem = pEntry->chain;
    count = pEntry->count;
  }else{
    h = 0;
    elem = pH->first;
    count = pH->count;
  }
  if( pHash ) *pHash = h;
  while( count-- ){
    ((void)0);
    if( sqlite3StrICmp(elem->pKey,pKey)==0 ){
      return elem;
    }
    elem = elem->next;
  }
  return &nullElement;
}




static void removeElementGivenHash(
  Hash *pH,
  HashElem* elem,
  unsigned int h
){
  struct _ht *pEntry;
  if( elem->prev ){
    elem->prev->next = elem->next;
  }else{
    pH->first = elem->next;
  }
  if( elem->next ){
    elem->next->prev = elem->prev;
  }
  if( pH->ht ){
    pEntry = &pH->ht[h];
    if( pEntry->chain==elem ){
      pEntry->chain = elem->next;
    }
    ((void)0);
    pEntry->count--;
  }
  sqlite3_free( elem );
  pH->count--;
  if( pH->count==0 ){
    ((void)0);
    ((void)0);
    sqlite3HashClear(pH);
  }
}





static void *sqlite3HashFind(const Hash *pH, const char *pKey){
  ((void)0);
  ((void)0);
  return findElementWithHash(pH, pKey, 0)->data;
}
# 32263 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3HashInsert(Hash *pH, const char *pKey, void *data){
  unsigned int h;
  HashElem *elem;
  HashElem *new_elem;

  ((void)0);
  ((void)0);
  elem = findElementWithHash(pH,pKey,&h);
  if( elem->data ){
    void *old_data = elem->data;
    if( data==0 ){
      removeElementGivenHash(pH,elem,h);
    }else{
      elem->data = data;
      elem->pKey = pKey;
    }
    return old_data;
  }
  if( data==0 ) return 0;
  new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) );
  if( new_elem==0 ) return data;
  new_elem->pKey = pKey;
  new_elem->data = data;
  pH->count++;
  if( pH->count>=10 && pH->count > 2*pH->htsize ){
    if( rehash(pH, pH->count*2) ){
      ((void)0);
      h = strHash(pKey) % pH->htsize;
    }
  }
  insertElement(pH, pH->ht ? &pH->ht[h] : 0, new_elem);
  return 0;
}
# 32307 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OpHelp(X) 

static const char *sqlite3OpcodeName(int i){
 static const char *const azName[] = {
              "Savepoint" ,
              "AutoCommit" ,
              "Transaction" ,
              "SorterNext" ,
              "Prev" ,
              "Next" ,
              "Checkpoint" ,
              "JournalMode" ,
              "Vacuum" ,
              "VFilter" ,
              "VUpdate" ,
              "Goto" ,
              "Gosub" ,
              "InitCoroutine" ,
              "Yield" ,
              "MustBeInt" ,
              "Jump" ,
              "Once" ,
              "If" ,
              "Not" ,
              "IfNot" ,
              "IfNullRow" ,
              "SeekLT" ,
              "SeekLE" ,
              "SeekGE" ,
              "SeekGT" ,
              "IfNoHope" ,
              "NoConflict" ,
              "NotFound" ,
              "Found" ,
              "SeekRowid" ,
              "NotExists" ,
              "Last" ,
              "IfSmaller" ,
              "SorterSort" ,
              "Sort" ,
              "Rewind" ,
              "IdxLE" ,
              "IdxGT" ,
              "IdxLT" ,
              "IdxGE" ,
              "RowSetRead" ,
              "RowSetTest" ,
              "Or" ,
              "And" ,
              "Program" ,
              "FkIfZero" ,
              "IfPos" ,
              "IfNotZero" ,
              "DecrJumpZero" ,
              "IsNull" ,
              "NotNull" ,
              "Ne" ,
              "Eq" ,
              "Gt" ,
              "Le" ,
              "Lt" ,
              "Ge" ,
              "ElseNotEq" ,
              "IncrVacuum" ,
              "VNext" ,
              "Init" ,
              "PureFunc0" ,
              "Function0" ,
              "PureFunc" ,
              "Function" ,
              "Return" ,
              "EndCoroutine" ,
              "HaltIfNull" ,
              "Halt" ,
              "Integer" ,
              "Int64" ,
              "String" ,
              "Null" ,
              "SoftNull" ,
              "Blob" ,
              "Variable" ,
              "Move" ,
              "Copy" ,
              "SCopy" ,
              "IntCopy" ,
              "ResultRow" ,
              "CollSeq" ,
              "AddImm" ,
              "RealAffinity" ,
              "Cast" ,
              "Permutation" ,
              "Compare" ,
              "IsTrue" ,
              "Offset" ,
              "Column" ,
              "Affinity" ,
              "MakeRecord" ,
              "Count" ,
              "ReadCookie" ,
              "SetCookie" ,
              "ReopenIdx" ,
              "OpenRead" ,
              "OpenWrite" ,
              "BitAnd" ,
              "BitOr" ,
              "ShiftLeft" ,
              "ShiftRight" ,
              "Add" ,
              "Subtract" ,
              "Multiply" ,
              "Divide" ,
              "Remainder" ,
              "Concat" ,
              "OpenDup" ,
              "BitNot" ,
              "OpenAutoindex" ,
              "OpenEphemeral" ,
              "String8" ,
              "SorterOpen" ,
              "SequenceTest" ,
              "OpenPseudo" ,
              "Close" ,
              "ColumnsUsed" ,
              "SeekHit" ,
              "Sequence" ,
              "NewRowid" ,
              "Insert" ,
              "Delete" ,
              "ResetCount" ,
              "SorterCompare" ,
              "SorterData" ,
              "RowData" ,
              "Rowid" ,
              "NullRow" ,
              "SeekEnd" ,
              "SorterInsert" ,
              "IdxInsert" ,
              "IdxDelete" ,
              "DeferredSeek" ,
              "IdxRowid" ,
              "Destroy" ,
              "Clear" ,
              "ResetSorter" ,
              "CreateBtree" ,
              "SqlExec" ,
              "ParseSchema" ,
              "LoadAnalysis" ,
              "DropTable" ,
              "DropIndex" ,
              "DropTrigger" ,
              "IntegrityCk" ,
              "RowSetAdd" ,
              "Real" ,
              "Param" ,
              "FkCounter" ,
              "MemMax" ,
              "OffsetLimit" ,
              "AggInverse" ,
              "AggStep" ,
              "AggStep1" ,
              "AggValue" ,
              "AggFinal" ,
              "Expire" ,
              "TableLock" ,
              "VBegin" ,
              "VCreate" ,
              "VDestroy" ,
              "VOpen" ,
              "VColumn" ,
              "VRename" ,
              "Pagecount" ,
              "MaxPgcnt" ,
              "Trace" ,
              "CursorHint" ,
              "Noop" ,
              "Explain" ,
              "Abortable" ,
  };
  return azName[i];
}
# 32558 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_ENABLE_LOCKING_STYLE 1







#define HAVE_PREAD 1
#define HAVE_PWRITE 1





#undef USE_PREAD64
#define USE_PREAD 1






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
#define _SYS_STAT_H_ 
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4

# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
struct ostat {
 __uint16_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 __uint16_t st_uid;
 __uint16_t st_gid;
 __uint16_t st_rdev;
 __int32_t st_size;
 struct timespec st_atimespec;
 struct timespec st_mtimespec;
 struct timespec st_ctimespec;
 __int32_t st_blksize;
 __int32_t st_blocks;
 __uint32_t st_flags;
 __uint32_t st_gen;
};

#define __DARWIN_STRUCT_STAT64_TIMES struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec;
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
#define __DARWIN_STRUCT_STAT64 { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; __DARWIN_STRUCT_STAT64_TIMES off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; }
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 231 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
#define st_atime st_atimespec.tv_sec
#define st_mtime st_mtimespec.tv_sec
#define st_ctime st_ctimespec.tv_sec
#define st_birthtime st_birthtimespec.tv_sec






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_s_ifmt.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_s_ifmt.h" 3 4
#define S_IFMT 0170000
#define S_IFIFO 0010000
#define S_IFCHR 0020000
#define S_IFDIR 0040000
#define S_IFBLK 0060000
#define S_IFREG 0100000
#define S_IFLNK 0120000
#define S_IFSOCK 0140000

#define S_IFWHT 0160000




#define S_IRWXU 0000700
#define S_IRUSR 0000400
#define S_IWUSR 0000200
#define S_IXUSR 0000100

#define S_IRWXG 0000070
#define S_IRGRP 0000040
#define S_IWGRP 0000020
#define S_IXGRP 0000010

#define S_IRWXO 0000007
#define S_IROTH 0000004
#define S_IWOTH 0000002
#define S_IXOTH 0000001

#define S_ISUID 0004000
#define S_ISGID 0002000
#define S_ISVTX 0001000


#define S_ISTXT S_ISVTX
#define S_IREAD S_IRUSR
#define S_IWRITE S_IWUSR
#define S_IEXEC S_IXUSR
# 242 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 2 3 4







#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)

#define S_ISWHT(m) (((m) & S_IFMT) == S_IFWHT)
# 275 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
#define S_TYPEISMQ(buf) (0)
#define S_TYPEISSEM(buf) (0)
#define S_TYPEISSHM(buf) (0)
# 293 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
#define S_TYPEISTMO(buf) (0)



#define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO)

#define ALLPERMS (S_ISUID|S_ISGID|S_ISTXT|S_IRWXU|S_IRWXG|S_IRWXO)

#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)

#define S_BLKSIZE 512






#define UF_SETTABLE 0x0000ffff
#define UF_NODUMP 0x00000001
#define UF_IMMUTABLE 0x00000002
#define UF_APPEND 0x00000004
#define UF_OPAQUE 0x00000008





#define UF_COMPRESSED 0x00000020



#define UF_TRACKED 0x00000040

#define UF_DATAVAULT 0x00000080



#define UF_HIDDEN 0x00008000




#define SF_SUPPORTED 0x009f0000
#define SF_SETTABLE 0x3fff0000
#define SF_SYNTHETIC 0xc0000000
#define SF_ARCHIVED 0x00010000
#define SF_IMMUTABLE 0x00020000
#define SF_APPEND 0x00040000
#define SF_RESTRICTED 0x00080000
#define SF_NOUNLINK 0x00100000
# 351 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
#define SF_FIRMLINK 0x00800000







#define SF_DATALESS 0x40000000
# 368 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4
#define EF_MAY_SHARE_BLOCKS 0x00000001
#define EF_NO_XATTRS 0x00000002
#define EF_IS_SYNC_ROOT 0x00000004
#define EF_IS_PURGEABLE 0x00000008
#define EF_IS_SPARSE 0x00000010
#define EF_IS_SYNTHETIC 0x00000020






int chmod(const char *, mode_t) __asm("_" "chmod" );
int fchmod(int, mode_t) __asm("_" "fchmod" );
int fstat(int, struct stat *) __asm("_" "fstat" );
int lstat(const char *, struct stat *) __asm("_" "lstat" );
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int stat(const char *, struct stat *) __asm("_" "stat" );
int mknod(const char *, mode_t, dev_t);
mode_t umask(mode_t);


int fchmodat(int, const char *, mode_t, int) ;
int fstatat(int, const char *, struct stat *, int) __asm("_" "fstatat" ) ;
int mkdirat(int, const char *, mode_t) ;

#define UTIME_NOW -1
#define UTIME_OMIT -2

int futimens(int __fd, const struct timespec __times[2]) ;
int utimensat(int __fd, const char *__path, const struct timespec __times[2],
    int __flag) ;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_filesec_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_filesec_t.h" 3 4
#define _FILESEC_T 
struct _filesec;
typedef struct _filesec *filesec_t;
# 406 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 2 3 4

int chflags(const char *, __uint32_t);
int chmodx_np(const char *, filesec_t);
int fchflags(int, __uint32_t);
int fchmodx_np(int, filesec_t);
int fstatx_np(int, struct stat *, filesec_t) __asm("_" "fstatx_np" );
int lchflags(const char *, __uint32_t) ;
int lchmod(const char *, mode_t) ;
int lstatx_np(const char *, struct stat *, filesec_t) __asm("_" "lstatx_np" );
int mkdirx_np(const char *, filesec_t);
int mkfifox_np(const char *, filesec_t);
int statx_np(const char *, struct stat *, filesec_t) __asm("_" "statx_np" );
int umaskx_np(filesec_t) ;
# 431 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/stat.h" 3 4

# 32582 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/fcntl.h" 1







       
#define _INC_FCNTL 



#define _O_RDONLY 0x0000
#define _O_WRONLY 0x0001
#define _O_RDWR 0x0002
#define _O_APPEND 0x0008

#define _O_CREAT 0x0100
#define _O_TRUNC 0x0200
#define _O_EXCL 0x0400




#define _O_TEXT 0x4000
#define _O_BINARY 0x8000
#define _O_WTEXT 0x10000
#define _O_U16TEXT 0x20000
#define _O_U8TEXT 0x40000


#define _O_RAW _O_BINARY

#define _O_NOINHERIT 0x0080
#define _O_TEMPORARY 0x0040
#define _O_SHORT_LIVED 0x1000
#define _O_OBTAIN_DIR 0x2000
#define _O_SEQUENTIAL 0x0020
#define _O_RANDOM 0x0010
# 32583 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioctl.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioctl.h" 3 4
#define _SYS_IOCTL_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ttycom.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ttycom.h" 3 4
#define _SYS_TTYCOM_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioccom.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioccom.h" 3 4
#define _SYS_IOCCOM_H_ 
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioccom.h" 3 4
#define IOCPARM_MASK 0x1fff
#define IOCPARM_LEN(x) (((x) >> 16) & IOCPARM_MASK)
#define IOCBASECMD(x) ((x) & ~(IOCPARM_MASK << 16))
#define IOCGROUP(x) (((x) >> 8) & 0xff)

#define IOCPARM_MAX (IOCPARM_MASK + 1)

#define IOC_VOID (__uint32_t)0x20000000

#define IOC_OUT (__uint32_t)0x40000000

#define IOC_IN (__uint32_t)0x80000000

#define IOC_INOUT (IOC_IN|IOC_OUT)

#define IOC_DIRMASK (__uint32_t)0xe0000000

#define _IOC(inout,group,num,len) (inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))

#define _IO(g,n) _IOC(IOC_VOID, (g), (n), 0)
#define _IOR(g,n,t) _IOC(IOC_OUT, (g), (n), sizeof(t))
#define _IOW(g,n,t) _IOC(IOC_IN, (g), (n), sizeof(t))

#define _IOWR(g,n,t) _IOC(IOC_INOUT, (g), (n), sizeof(t))
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ttycom.h" 2 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ttycom.h" 3 4
struct winsize {
 unsigned short ws_row;
 unsigned short ws_col;
 unsigned short ws_xpixel;
 unsigned short ws_ypixel;
};

#define TIOCMODG _IOR('t', 3, int)
#define TIOCMODS _IOW('t', 4, int)
#define TIOCM_LE 0001
#define TIOCM_DTR 0002
#define TIOCM_RTS 0004
#define TIOCM_ST 0010
#define TIOCM_SR 0020
#define TIOCM_CTS 0040
#define TIOCM_CAR 0100
#define TIOCM_CD TIOCM_CAR
#define TIOCM_RNG 0200
#define TIOCM_RI TIOCM_RNG
#define TIOCM_DSR 0400

#define TIOCEXCL _IO('t', 13)
#define TIOCNXCL _IO('t', 14)

#define TIOCFLUSH _IOW('t', 16, int)

#define TIOCGETA _IOR('t', 19, struct termios)
#define TIOCSETA _IOW('t', 20, struct termios)
#define TIOCSETAW _IOW('t', 21, struct termios)
#define TIOCSETAF _IOW('t', 22, struct termios)
#define TIOCGETD _IOR('t', 26, int)
#define TIOCSETD _IOW('t', 27, int)
#define TIOCIXON _IO('t', 129)
#define TIOCIXOFF _IO('t', 128)

#define TIOCSBRK _IO('t', 123)
#define TIOCCBRK _IO('t', 122)
#define TIOCSDTR _IO('t', 121)
#define TIOCCDTR _IO('t', 120)
#define TIOCGPGRP _IOR('t', 119, int)
#define TIOCSPGRP _IOW('t', 118, int)

#define TIOCOUTQ _IOR('t', 115, int)
#define TIOCSTI _IOW('t', 114, char)
#define TIOCNOTTY _IO('t', 113)
#define TIOCPKT _IOW('t', 112, int)
#define TIOCPKT_DATA 0x00
#define TIOCPKT_FLUSHREAD 0x01
#define TIOCPKT_FLUSHWRITE 0x02
#define TIOCPKT_STOP 0x04
#define TIOCPKT_START 0x08
#define TIOCPKT_NOSTOP 0x10
#define TIOCPKT_DOSTOP 0x20
#define TIOCPKT_IOCTL 0x40
#define TIOCSTOP _IO('t', 111)
#define TIOCSTART _IO('t', 110)
#define TIOCMSET _IOW('t', 109, int)
#define TIOCMBIS _IOW('t', 108, int)
#define TIOCMBIC _IOW('t', 107, int)
#define TIOCMGET _IOR('t', 106, int)

#define TIOCGWINSZ _IOR('t', 104, struct winsize)
#define TIOCSWINSZ _IOW('t', 103, struct winsize)
#define TIOCUCNTL _IOW('t', 102, int)
#define TIOCSTAT _IO('t', 101)
#define UIOCCMD(n) _IO('u', n)
#define TIOCSCONS _IO('t', 99)
#define TIOCCONS _IOW('t', 98, int)
#define TIOCSCTTY _IO('t', 97)
#define TIOCEXT _IOW('t', 96, int)
#define TIOCSIG _IO('t', 95)
#define TIOCDRAIN _IO('t', 94)
#define TIOCMSDTRWAIT _IOW('t', 91, int)
#define TIOCMGDTRWAIT _IOR('t', 90, int)
#define TIOCTIMESTAMP _IOR('t', 89, struct timeval)

#define TIOCDCDTIMESTAMP _IOR('t', 88, struct timeval)

#define TIOCSDRAINWAIT _IOW('t', 87, int)
#define TIOCGDRAINWAIT _IOR('t', 86, int)
#define TIOCDSIMICROCODE _IO('t', 85)

#define TIOCPTYGRANT _IO('t', 84)
#define TIOCPTYGNAME _IOC(IOC_OUT, 't', 83, 128)
#define TIOCPTYUNLK _IO('t', 82)

#define TTYDISC 0
#define TABLDISC 3
#define SLIPDISC 4
#define PPPDISC 5
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioctl.h" 2 3 4






struct ttysize {
 unsigned short ts_lines;
 unsigned short ts_cols;
 unsigned short ts_xxx;
 unsigned short ts_yyy;
};
#define TIOCGSIZE TIOCGWINSZ
#define TIOCSSIZE TIOCSWINSZ



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/filio.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/filio.h" 3 4
#define _SYS_FILIO_H_ 




#define FIOCLEX _IO('f', 1)
#define FIONCLEX _IO('f', 2)
#define FIONREAD _IOR('f', 127, int)
#define FIONBIO _IOW('f', 126, int)
#define FIOASYNC _IOW('f', 125, int)
#define FIOSETOWN _IOW('f', 124, int)
#define FIOGETOWN _IOR('f', 123, int)
#define FIODTYPE _IOR('f', 122, int)
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioctl.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sockio.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sockio.h" 3 4
#define _SYS_SOCKIO_H_ 






#define SIOCSHIWAT _IOW('s', 0, int)
#define SIOCGHIWAT _IOR('s', 1, int)
#define SIOCSLOWAT _IOW('s', 2, int)
#define SIOCGLOWAT _IOR('s', 3, int)
#define SIOCATMARK _IOR('s', 7, int)
#define SIOCSPGRP _IOW('s', 8, int)
#define SIOCGPGRP _IOR('s', 9, int)




#define SIOCSIFADDR _IOW('i', 12, struct ifreq)
#define SIOCSIFDSTADDR _IOW('i', 14, struct ifreq)
#define SIOCSIFFLAGS _IOW('i', 16, struct ifreq)
#define SIOCGIFFLAGS _IOWR('i', 17, struct ifreq)
#define SIOCSIFBRDADDR _IOW('i', 19, struct ifreq)
#define SIOCSIFNETMASK _IOW('i', 22, struct ifreq)
#define SIOCGIFMETRIC _IOWR('i', 23, struct ifreq)
#define SIOCSIFMETRIC _IOW('i', 24, struct ifreq)
#define SIOCDIFADDR _IOW('i', 25, struct ifreq)
#define SIOCAIFADDR _IOW('i', 26, struct ifaliasreq)

#define SIOCGIFADDR _IOWR('i', 33, struct ifreq)
#define SIOCGIFDSTADDR _IOWR('i', 34, struct ifreq)
#define SIOCGIFBRDADDR _IOWR('i', 35, struct ifreq)
#define SIOCGIFCONF _IOWR('i', 36, struct ifconf)
#define SIOCGIFNETMASK _IOWR('i', 37, struct ifreq)
#define SIOCAUTOADDR _IOWR('i', 38, struct ifreq)
#define SIOCAUTONETMASK _IOW('i', 39, struct ifreq)
#define SIOCARPIPLL _IOWR('i', 40, struct ifreq)

#define SIOCADDMULTI _IOW('i', 49, struct ifreq)
#define SIOCDELMULTI _IOW('i', 50, struct ifreq)
#define SIOCGIFMTU _IOWR('i', 51, struct ifreq)
#define SIOCSIFMTU _IOW('i', 52, struct ifreq)
#define SIOCGIFPHYS _IOWR('i', 53, struct ifreq)
#define SIOCSIFPHYS _IOW('i', 54, struct ifreq)
#define SIOCSIFMEDIA _IOWR('i', 55, struct ifreq)





#define SIOCGIFMEDIA _IOWR('i', 56, struct ifmediareq)

#define SIOCSIFGENERIC _IOW('i', 57, struct ifreq)
#define SIOCGIFGENERIC _IOWR('i', 58, struct ifreq)
#define SIOCRSLVMULTI _IOWR('i', 59, struct rslvmulti_req)

#define SIOCSIFLLADDR _IOW('i', 60, struct ifreq)
#define SIOCGIFSTATUS _IOWR('i', 61, struct ifstat)
#define SIOCSIFPHYADDR _IOW('i', 62, struct ifaliasreq)
#define SIOCGIFPSRCADDR _IOWR('i', 63, struct ifreq)
#define SIOCGIFPDSTADDR _IOWR('i', 64, struct ifreq)
#define SIOCDIFPHYADDR _IOW('i', 65, struct ifreq)

#define SIOCGIFDEVMTU _IOWR('i', 68, struct ifreq)
#define SIOCSIFALTMTU _IOW('i', 69, struct ifreq)
#define SIOCGIFALTMTU _IOWR('i', 72, struct ifreq)
#define SIOCSIFBOND _IOW('i', 70, struct ifreq)
#define SIOCGIFBOND _IOWR('i', 71, struct ifreq)
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/sockio.h" 3 4
#define SIOCGIFXMEDIA _IOWR('i', 72, struct ifmediareq)


#define SIOCSIFCAP _IOW('i', 90, struct ifreq)
#define SIOCGIFCAP _IOWR('i', 91, struct ifreq)

#define SIOCIFCREATE _IOWR('i', 120, struct ifreq)
#define SIOCIFDESTROY _IOW('i', 121, struct ifreq)
#define SIOCIFCREATE2 _IOWR('i', 122, struct ifreq)

#define SIOCSDRVSPEC _IOW('i', 123, struct ifdrv)

#define SIOCGDRVSPEC _IOWR('i', 123, struct ifdrv)

#define SIOCSIFVLAN _IOW('i', 126, struct ifreq)
#define SIOCGIFVLAN _IOWR('i', 127, struct ifreq)
#define SIOCSETVLAN SIOCSIFVLAN
#define SIOCGETVLAN SIOCGIFVLAN

#define SIOCIFGCLONERS _IOWR('i', 129, struct if_clonereq)

#define SIOCGIFASYNCMAP _IOWR('i', 124, struct ifreq)
#define SIOCSIFASYNCMAP _IOW('i', 125, struct ifreq)



#define SIOCGIFMAC _IOWR('i', 130, struct ifreq)
#define SIOCSIFMAC _IOW('i', 131, struct ifreq)
#define SIOCSIFKPI _IOW('i', 134, struct ifreq)
#define SIOCGIFKPI _IOWR('i', 135, struct ifreq)

#define SIOCGIFWAKEFLAGS _IOWR('i', 136, struct ifreq)

#define SIOCGIFFUNCTIONALTYPE _IOWR('i', 173, struct ifreq)

#define SIOCSIF6LOWPAN _IOW('i', 196, struct ifreq)
#define SIOCGIF6LOWPAN _IOWR('i', 197, struct ifreq)
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/ioctl.h" 2 3 4





int ioctl(int, unsigned long, ...);

# 32584 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
#define _UNISTD_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 3 4
#define _SYS_UNISTD_H_ 
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 3 4
#define _POSIX_VERSION 200112L
#define _POSIX2_VERSION 200112L



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_posix_vdisable.h" 3 4
#define _POSIX_VDISABLE ((unsigned char)'\377')
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 2 3 4

#define _POSIX_THREAD_KEYS_MAX 128


#define F_OK 0
#define X_OK (1<<0)
#define W_OK (1<<1)
#define R_OK (1<<2)







#define _READ_OK (1<<9)
#define _WRITE_OK (1<<10)
#define _EXECUTE_OK (1<<11)
#define _DELETE_OK (1<<12)
#define _APPEND_OK (1<<13)
#define _RMFILE_OK (1<<14)
#define _RATTR_OK (1<<15)
#define _WATTR_OK (1<<16)
#define _REXT_OK (1<<17)
#define _WEXT_OK (1<<18)
#define _RPERM_OK (1<<19)
#define _WPERM_OK (1<<20)
#define _CHOWN_OK (1<<21)

#define _ACCESS_EXTENDED_MASK (_READ_OK | _WRITE_OK | _EXECUTE_OK | _DELETE_OK | _APPEND_OK | _RMFILE_OK | _REXT_OK | _WEXT_OK | _RATTR_OK | _WATTR_OK | _RPERM_OK | _WPERM_OK | _CHOWN_OK)







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_seek_set.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_seek_set.h" 3 4
#define SEEK_HOLE 3



#define SEEK_DATA 4
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 2 3 4



#define L_SET SEEK_SET
#define L_INCR SEEK_CUR
#define L_XTND SEEK_END



struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
#define ACCESSX_MAX_DESCRIPTORS 100
#define ACCESSX_MAX_TABLESIZE (16 * 1024)



#define _PC_LINK_MAX 1
#define _PC_MAX_CANON 2
#define _PC_MAX_INPUT 3
#define _PC_NAME_MAX 4
#define _PC_PATH_MAX 5
#define _PC_PIPE_BUF 6
#define _PC_CHOWN_RESTRICTED 7
#define _PC_NO_TRUNC 8
#define _PC_VDISABLE 9


#define _PC_NAME_CHARS_MAX 10
#define _PC_CASE_SENSITIVE 11
#define _PC_CASE_PRESERVING 12
#define _PC_EXTENDED_SECURITY_NP 13
#define _PC_AUTH_OPAQUE_NP 14


#define _PC_2_SYMLINKS 15
#define _PC_ALLOC_SIZE_MIN 16
#define _PC_ASYNC_IO 17
#define _PC_FILESIZEBITS 18
#define _PC_PRIO_IO 19
#define _PC_REC_INCR_XFER_SIZE 20
#define _PC_REC_MAX_XFER_SIZE 21
#define _PC_REC_MIN_XFER_SIZE 22
#define _PC_REC_XFER_ALIGN 23
#define _PC_SYMLINK_MAX 24
#define _PC_SYNC_IO 25
#define _PC_XATTR_SIZE_BITS 26
#define _PC_MIN_HOLE_SIZE 27


#define _CS_PATH 1





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_types/_uint64_t.h" 3 4
#define _UINT64_T 
typedef unsigned long long uint64_t;
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_types/_uint32_t.h" 3 4
#define _UINT32_T 
typedef unsigned int uint32_t;
# 183 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 2 3 4




int getattrlistbulk(int, void *, void *, size_t, uint64_t) ;
int getattrlistat(int, const char *, void *, void *, size_t, unsigned long) ;
int setattrlistat(int, const char *, void *, void *, size_t, uint32_t) ;


# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/unistd.h" 3 4


int faccessat(int, const char *, int, int) ;
int fchownat(int, const char *, uid_t, gid_t, int) ;
int linkat(int, const char *, int, const char *, int) ;
ssize_t readlinkat(int, const char *, char *, size_t) ;
int symlinkat(const char *, int, const char *) ;
int unlinkat(int, const char *, int) ;


# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 2 3 4
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2




#define _XOPEN_VERSION 600
#define _XOPEN_XCU_VERSION 4



#define _POSIX_ADVISORY_INFO (-1)
#define _POSIX_ASYNCHRONOUS_IO (-1)
#define _POSIX_BARRIERS (-1)
#define _POSIX_CHOWN_RESTRICTED 200112L
#define _POSIX_CLOCK_SELECTION (-1)
#define _POSIX_CPUTIME (-1)
#define _POSIX_FSYNC 200112L
#define _POSIX_IPV6 200112L
#define _POSIX_JOB_CONTROL 200112L
#define _POSIX_MAPPED_FILES 200112L
#define _POSIX_MEMLOCK (-1)
#define _POSIX_MEMLOCK_RANGE (-1)
#define _POSIX_MEMORY_PROTECTION 200112L
#define _POSIX_MESSAGE_PASSING (-1)
#define _POSIX_MONOTONIC_CLOCK (-1)
#define _POSIX_NO_TRUNC 200112L
#define _POSIX_PRIORITIZED_IO (-1)
#define _POSIX_PRIORITY_SCHEDULING (-1)
#define _POSIX_RAW_SOCKETS (-1)
#define _POSIX_READER_WRITER_LOCKS 200112L
#define _POSIX_REALTIME_SIGNALS (-1)
#define _POSIX_REGEXP 200112L
#define _POSIX_SAVED_IDS 200112L
#define _POSIX_SEMAPHORES (-1)
#define _POSIX_SHARED_MEMORY_OBJECTS (-1)
#define _POSIX_SHELL 200112L
#define _POSIX_SPAWN (-1)
#define _POSIX_SPIN_LOCKS (-1)
#define _POSIX_SPORADIC_SERVER (-1)
#define _POSIX_SYNCHRONIZED_IO (-1)
#define _POSIX_THREAD_ATTR_STACKADDR 200112L
#define _POSIX_THREAD_ATTR_STACKSIZE 200112L
#define _POSIX_THREAD_CPUTIME (-1)
#define _POSIX_THREAD_PRIO_INHERIT (-1)
#define _POSIX_THREAD_PRIO_PROTECT (-1)
#define _POSIX_THREAD_PRIORITY_SCHEDULING (-1)
#define _POSIX_THREAD_PROCESS_SHARED 200112L
#define _POSIX_THREAD_SAFE_FUNCTIONS 200112L
#define _POSIX_THREAD_SPORADIC_SERVER (-1)
#define _POSIX_THREADS 200112L
#define _POSIX_TIMEOUTS (-1)
#define _POSIX_TIMERS (-1)
#define _POSIX_TRACE (-1)
#define _POSIX_TRACE_EVENT_FILTER (-1)
#define _POSIX_TRACE_INHERIT (-1)
#define _POSIX_TRACE_LOG (-1)
#define _POSIX_TYPED_MEMORY_OBJECTS (-1)





#define _POSIX2_C_BIND 200112L
#define _POSIX2_C_DEV 200112L
#define _POSIX2_CHAR_TERM 200112L
#define _POSIX2_FORT_DEV (-1)
#define _POSIX2_FORT_RUN 200112L
#define _POSIX2_LOCALEDEF 200112L
#define _POSIX2_PBS (-1)
#define _POSIX2_PBS_ACCOUNTING (-1)
#define _POSIX2_PBS_CHECKPOINT (-1)
#define _POSIX2_PBS_LOCATE (-1)
#define _POSIX2_PBS_MESSAGE (-1)
#define _POSIX2_PBS_TRACK (-1)
#define _POSIX2_SW_DEV 200112L
#define _POSIX2_UPE 200112L


#define __ILP32_OFF32 (-1)
#define __ILP32_OFFBIG (-1)

#define __LP64_OFF64 (1)
#define __LPBIG_OFFBIG (1)


#define _POSIX_V6_ILP32_OFF32 __ILP32_OFF32
#define _POSIX_V6_ILP32_OFFBIG __ILP32_OFFBIG
#define _POSIX_V6_LP64_OFF64 __LP64_OFF64
#define _POSIX_V6_LPBIG_OFFBIG __LPBIG_OFFBIG



#define _POSIX_V7_ILP32_OFF32 __ILP32_OFF32
#define _POSIX_V7_ILP32_OFFBIG __ILP32_OFFBIG
#define _POSIX_V7_LP64_OFF64 __LP64_OFF64
#define _POSIX_V7_LPBIG_OFFBIG __LPBIG_OFFBIG



#define _V6_ILP32_OFF32 __ILP32_OFF32
#define _V6_ILP32_OFFBIG __ILP32_OFFBIG
#define _V6_LP64_OFF64 __LP64_OFF64
#define _V6_LPBIG_OFFBIG __LPBIG_OFFBIG




#define _XBS5_ILP32_OFF32 __ILP32_OFF32
#define _XBS5_ILP32_OFFBIG __ILP32_OFFBIG
#define _XBS5_LP64_OFF64 __LP64_OFF64
#define _XBS5_LPBIG_OFFBIG __LPBIG_OFFBIG



#define _XOPEN_CRYPT (1)
#define _XOPEN_ENH_I18N (1)
#define _XOPEN_LEGACY (-1)
#define _XOPEN_REALTIME (-1)
#define _XOPEN_REALTIME_THREADS (-1)
#define _XOPEN_SHM (1)
#define _XOPEN_STREAMS (-1)
#define _XOPEN_UNIX (1)



#define _SC_ARG_MAX 1
#define _SC_CHILD_MAX 2
#define _SC_CLK_TCK 3
#define _SC_NGROUPS_MAX 4
#define _SC_OPEN_MAX 5
#define _SC_JOB_CONTROL 6
#define _SC_SAVED_IDS 7
#define _SC_VERSION 8
#define _SC_BC_BASE_MAX 9
#define _SC_BC_DIM_MAX 10
#define _SC_BC_SCALE_MAX 11
#define _SC_BC_STRING_MAX 12
#define _SC_COLL_WEIGHTS_MAX 13
#define _SC_EXPR_NEST_MAX 14
#define _SC_LINE_MAX 15
#define _SC_RE_DUP_MAX 16
#define _SC_2_VERSION 17
#define _SC_2_C_BIND 18
#define _SC_2_C_DEV 19
#define _SC_2_CHAR_TERM 20
#define _SC_2_FORT_DEV 21
#define _SC_2_FORT_RUN 22
#define _SC_2_LOCALEDEF 23
#define _SC_2_SW_DEV 24
#define _SC_2_UPE 25
#define _SC_STREAM_MAX 26
#define _SC_TZNAME_MAX 27


#define _SC_ASYNCHRONOUS_IO 28
#define _SC_PAGESIZE 29
#define _SC_MEMLOCK 30
#define _SC_MEMLOCK_RANGE 31
#define _SC_MEMORY_PROTECTION 32
#define _SC_MESSAGE_PASSING 33
#define _SC_PRIORITIZED_IO 34
#define _SC_PRIORITY_SCHEDULING 35
#define _SC_REALTIME_SIGNALS 36
#define _SC_SEMAPHORES 37
#define _SC_FSYNC 38
#define _SC_SHARED_MEMORY_OBJECTS 39
#define _SC_SYNCHRONIZED_IO 40
#define _SC_TIMERS 41
#define _SC_AIO_LISTIO_MAX 42
#define _SC_AIO_MAX 43
#define _SC_AIO_PRIO_DELTA_MAX 44
#define _SC_DELAYTIMER_MAX 45
#define _SC_MQ_OPEN_MAX 46
#define _SC_MAPPED_FILES 47
#define _SC_RTSIG_MAX 48
#define _SC_SEM_NSEMS_MAX 49
#define _SC_SEM_VALUE_MAX 50
#define _SC_SIGQUEUE_MAX 51
#define _SC_TIMER_MAX 52



#define _SC_NPROCESSORS_CONF 57
#define _SC_NPROCESSORS_ONLN 58



#define _SC_2_PBS 59
#define _SC_2_PBS_ACCOUNTING 60
#define _SC_2_PBS_CHECKPOINT 61
#define _SC_2_PBS_LOCATE 62
#define _SC_2_PBS_MESSAGE 63
#define _SC_2_PBS_TRACK 64
#define _SC_ADVISORY_INFO 65
#define _SC_BARRIERS 66
#define _SC_CLOCK_SELECTION 67
#define _SC_CPUTIME 68
#define _SC_FILE_LOCKING 69
#define _SC_GETGR_R_SIZE_MAX 70
#define _SC_GETPW_R_SIZE_MAX 71
#define _SC_HOST_NAME_MAX 72
#define _SC_LOGIN_NAME_MAX 73
#define _SC_MONOTONIC_CLOCK 74
#define _SC_MQ_PRIO_MAX 75
#define _SC_READER_WRITER_LOCKS 76
#define _SC_REGEXP 77
#define _SC_SHELL 78
#define _SC_SPAWN 79
#define _SC_SPIN_LOCKS 80
#define _SC_SPORADIC_SERVER 81
#define _SC_THREAD_ATTR_STACKADDR 82
#define _SC_THREAD_ATTR_STACKSIZE 83
#define _SC_THREAD_CPUTIME 84
#define _SC_THREAD_DESTRUCTOR_ITERATIONS 85
#define _SC_THREAD_KEYS_MAX 86
#define _SC_THREAD_PRIO_INHERIT 87
#define _SC_THREAD_PRIO_PROTECT 88
#define _SC_THREAD_PRIORITY_SCHEDULING 89
#define _SC_THREAD_PROCESS_SHARED 90
#define _SC_THREAD_SAFE_FUNCTIONS 91
#define _SC_THREAD_SPORADIC_SERVER 92
#define _SC_THREAD_STACK_MIN 93
#define _SC_THREAD_THREADS_MAX 94
#define _SC_TIMEOUTS 95
#define _SC_THREADS 96
#define _SC_TRACE 97
#define _SC_TRACE_EVENT_FILTER 98
#define _SC_TRACE_INHERIT 99
#define _SC_TRACE_LOG 100
#define _SC_TTY_NAME_MAX 101
#define _SC_TYPED_MEMORY_OBJECTS 102
#define _SC_V6_ILP32_OFF32 103
#define _SC_V6_ILP32_OFFBIG 104
#define _SC_V6_LP64_OFF64 105
#define _SC_V6_LPBIG_OFFBIG 106
#define _SC_IPV6 118
#define _SC_RAW_SOCKETS 119
#define _SC_SYMLOOP_MAX 120



#define _SC_ATEXIT_MAX 107
#define _SC_IOV_MAX 56
#define _SC_PAGE_SIZE _SC_PAGESIZE
#define _SC_XOPEN_CRYPT 108
#define _SC_XOPEN_ENH_I18N 109
#define _SC_XOPEN_LEGACY 110
#define _SC_XOPEN_REALTIME 111
#define _SC_XOPEN_REALTIME_THREADS 112
#define _SC_XOPEN_SHM 113
#define _SC_XOPEN_STREAMS 114
#define _SC_XOPEN_UNIX 115
#define _SC_XOPEN_VERSION 116
#define _SC_XOPEN_XCU_VERSION 121




#define _SC_XBS5_ILP32_OFF32 122
#define _SC_XBS5_ILP32_OFFBIG 123
#define _SC_XBS5_LP64_OFF64 124
#define _SC_XBS5_LPBIG_OFFBIG 125



#define _SC_SS_REPL_MAX 126
#define _SC_TRACE_EVENT_NAME_MAX 127
#define _SC_TRACE_NAME_MAX 128
#define _SC_TRACE_SYS_MAX 129
#define _SC_TRACE_USER_EVENT_MAX 130




#define _SC_PASS_MAX 131




#define _SC_PHYS_PAGES 200
# 377 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS 2
#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS 3
#define _CS_POSIX_V6_ILP32_OFF32_LIBS 4
#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS 5
#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS 6
#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS 7
#define _CS_POSIX_V6_LP64_OFF64_CFLAGS 8
#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS 9
#define _CS_POSIX_V6_LP64_OFF64_LIBS 10
#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS 11
#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS 12
#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS 13
#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 14




#define _CS_XBS5_ILP32_OFF32_CFLAGS 20
#define _CS_XBS5_ILP32_OFF32_LDFLAGS 21
#define _CS_XBS5_ILP32_OFF32_LIBS 22
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS 23
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS 24
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS 25
#define _CS_XBS5_ILP32_OFFBIG_LIBS 26
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS 27
#define _CS_XBS5_LP64_OFF64_CFLAGS 28
#define _CS_XBS5_LP64_OFF64_LDFLAGS 29
#define _CS_XBS5_LP64_OFF64_LIBS 30
#define _CS_XBS5_LP64_OFF64_LINTFLAGS 31
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS 32
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS 33
#define _CS_XBS5_LPBIG_OFFBIG_LIBS 34
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS 35



#define _CS_DARWIN_USER_DIR 65536
#define _CS_DARWIN_USER_TEMP_DIR 65537
#define _CS_DARWIN_USER_CACHE_DIR 65538
# 429 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4

void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char * __path, const char * __arg0, ...) ;
int execle(const char * __path, const char * __arg0, ...) ;
int execlp(const char * __file, const char * __arg0, ...) ;
int execv(const char * __path, char * const * 
# 444 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h"
                                              (*__p___argv())
# 444 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
                                                    ) ;
int execve(const char * __file, char * const * 
# 445 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h"
                                               (*__p___argv())
# 445 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
                                                     , char * const * __envp) ;
int execvp(const char * __file, char * const * 
# 446 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h"
                                               (*__p___argv())
# 446 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
                                                     ) ;
pid_t fork(void) ;
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int __fd, const void * __buf, size_t __nbyte) __asm("_" "write" );

# 506 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4

size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;

# 525 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_ctermid.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/_ctermid.h" 3 4
#define _CTERMID_H_ 





char *ctermid(char *);


# 526 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 2 3 4

#define F_ULOCK 0
#define F_LOCK 1
#define F_TLOCK 2
#define F_TEST 3







__attribute__((__deprecated__))

void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);

void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((__const__)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int __fd, void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pread" );

ssize_t pwrite(int __fd, const void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pwrite" );






__attribute__((__deprecated__))

void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * restrict, void * restrict, ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );


__attribute__((__deprecated__("Use posix_spawn or fork")))

pid_t vfork(void) ;


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);

# 624 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4

int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * restrict, char * restrict, size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);

# 645 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4

void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int) ;
void endusershell(void);
int execvP(const char * __file, const char * __searchpath, char * const * 
# 651 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h"
                                                                          (*__p___argv())
# 651 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
                                                                                ) ;
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/gethostuuid.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/gethostuuid.h" 3 4
#define __GETHOSTUUID_H 
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/gethostuuid.h" 3 4
int gethostuuid(uuid_t, const struct timespec *) ;
# 660 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 2 3 4




mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkpath_np(const char *path, mode_t omode) ;
int mkpathat_np(int dfd, const char *path, mode_t omode)
 
  ;
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int mkostemp(char *path, int oflags)
 
  ;
int mkostemps(char *path, int slen, int oflags)
 
  ;

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
 
  ;
char *mkdtempat_np(int dfd, char *path)
 
  ;
int mkstempsat_np(int dfd, char *path, int slen)
 
  ;
int mkostempsat_np(int dfd, char *path, int slen, int oflags)
 
  ;
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);

__attribute__((__deprecated__("Use of per-thread security contexts is error-prone and discouraged.")))
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);

int reboot(int);
int revoke(const char *);

__attribute__((__deprecated__)) int rcmd(char **, int, const char *, const char *, const char *, int *);
__attribute__((__deprecated__)) int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
__attribute__((__deprecated__)) int rresvport(int *);
__attribute__((__deprecated__)) int rresvport_af(int *, int);
__attribute__((__deprecated__)) int iruserok(unsigned long, int, const char *, const char *);
__attribute__((__deprecated__)) int iruserok_sa(const void *, int, int, const char *, const char *);
__attribute__((__deprecated__)) int ruserok(const char *, int, const char *, const char *);

int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" );



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);






int syscall(int, ...);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) ;
int fsetattrlist(int,void*,void*,size_t,unsigned int) ;
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int) ;
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int) ;
# 773 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *) ;
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) ;

#define SYNC_VOLUME_FULLSYNC 0x01
#define SYNC_VOLUME_WAIT 0x02

int fsync_volume_np(int, int) ;
int sync_volume_np(const char *, int) ;

extern int optreset;


# 32585 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mman.h" 1 3 4
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mman.h" 3 4
#define _SYS_MMAN_H_ 
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mman.h" 3 4
#define PROT_NONE 0x00
#define PROT_READ 0x01
#define PROT_WRITE 0x02
#define PROT_EXEC 0x04





#define MAP_SHARED 0x0001
#define MAP_PRIVATE 0x0002

#define MAP_COPY MAP_PRIVATE





#define MAP_FIXED 0x0010

#define MAP_RENAME 0x0020
#define MAP_NORESERVE 0x0040
#define MAP_RESERVED0080 0x0080
#define MAP_NOEXTEND 0x0100
#define MAP_HASSEMAPHORE 0x0200
#define MAP_NOCACHE 0x0400
#define MAP_JIT 0x0800




#define MAP_FILE 0x0000
#define MAP_ANON 0x1000
#define MAP_ANONYMOUS MAP_ANON
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mman.h" 3 4
#define MAP_RESILIENT_CODESIGN 0x2000
#define MAP_RESILIENT_MEDIA 0x4000


#define MAP_32BIT 0x8000






#define MAP_TRANSLATED_ALLOW_EXECUTE 0x20000

#define MAP_UNIX03 0x40000






#define MCL_CURRENT 0x0001
#define MCL_FUTURE 0x0002




#define MAP_FAILED ((void *)-1)




#define MS_ASYNC 0x0001
#define MS_INVALIDATE 0x0002
#define MS_SYNC 0x0010


#define MS_KILLPAGES 0x0004
#define MS_DEACTIVATE 0x0008







#define POSIX_MADV_NORMAL 0
#define POSIX_MADV_RANDOM 1
#define POSIX_MADV_SEQUENTIAL 2
#define POSIX_MADV_WILLNEED 3
#define POSIX_MADV_DONTNEED 4


#define MADV_NORMAL POSIX_MADV_NORMAL
#define MADV_RANDOM POSIX_MADV_RANDOM
#define MADV_SEQUENTIAL POSIX_MADV_SEQUENTIAL
#define MADV_WILLNEED POSIX_MADV_WILLNEED
#define MADV_DONTNEED POSIX_MADV_DONTNEED
#define MADV_FREE 5
#define MADV_ZERO_WIRED_PAGES 6
#define MADV_FREE_REUSABLE 7
#define MADV_FREE_REUSE 8
#define MADV_CAN_REUSE 9
#define MADV_PAGEOUT 10




#define MINCORE_INCORE 0x1
#define MINCORE_REFERENCED 0x2
#define MINCORE_MODIFIED 0x4
#define MINCORE_REFERENCED_OTHER 0x8
#define MINCORE_MODIFIED_OTHER 0x10
#define MINCORE_PAGED_OUT 0x20
#define MINCORE_COPIED 0x40
#define MINCORE_ANONYMOUS 0x80







int mlockall(int);
int munlockall(void);

int mlock(const void *, size_t);

#define _MMAP 

void * mmap(void *, size_t, int, int, int, off_t) __asm("_" "mmap" );


int mprotect(void *, size_t, int) __asm("_" "mprotect" );

int msync(void *, size_t, int) __asm("_" "msync" );

int munlock(const void *, size_t);

int munmap(void *, size_t) __asm("_" "munmap" );

int shm_open(const char *, int, ...);
int shm_unlink(const char *);

int posix_madvise(void *, size_t, int);


int madvise(void *, size_t, int);
int mincore(const void *, size_t, char *);
int minherit(void *, size_t, int);




# 32590 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/file.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/file.h" 3 4
#define _SYS_FILE_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#define _SYS_FCNTL_H_ 
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#define O_RDONLY 0x0000
#define O_WRONLY 0x0001
#define O_RDWR 0x0002
#define O_ACCMODE 0x0003
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#define FREAD 0x00000001
#define FWRITE 0x00000002

#define O_NONBLOCK 0x00000004
#define O_APPEND 0x00000008

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_o_sync.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_o_sync.h" 3 4
#define O_SYNC 0x0080
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 2 3 4


#define O_SHLOCK 0x00000010
#define O_EXLOCK 0x00000020
#define O_ASYNC 0x00000040
#define O_FSYNC O_SYNC
#define O_NOFOLLOW 0x00000100

#define O_CREAT 0x00000200
#define O_TRUNC 0x00000400
#define O_EXCL 0x00000800


#define O_EVTONLY 0x00008000



#define O_NOCTTY 0x00020000



#define O_DIRECTORY 0x00100000



#define O_SYMLINK 0x00200000



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_o_dsync.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_o_dsync.h" 3 4
#define O_DSYNC 0x400000
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 2 3 4



#define O_CLOEXEC 0x01000000




#define O_NOFOLLOW_ANY 0x20000000







#define AT_FDCWD -2




#define AT_EACCESS 0x0010
#define AT_SYMLINK_NOFOLLOW 0x0020
#define AT_SYMLINK_FOLLOW 0x0040
#define AT_REMOVEDIR 0x0080

#define AT_REALDEV 0x0200
#define AT_FDONLY 0x0400





#define O_DP_GETRAWENCRYPTED 0x0001
#define O_DP_GETRAWUNENCRYPTED 0x0002
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#define FAPPEND O_APPEND
#define FASYNC O_ASYNC
#define FFSYNC O_FSYNC
#define FFDSYNC O_DSYNC
#define FNONBLOCK O_NONBLOCK
#define FNDELAY O_NONBLOCK
#define O_NDELAY O_NONBLOCK







#define CPF_OVERWRITE 0x0001
#define CPF_IGNORE_MODE 0x0002
#define CPF_MASK (CPF_OVERWRITE|CPF_IGNORE_MODE)







#define F_DUPFD 0
#define F_GETFD 1
#define F_SETFD 2
#define F_GETFL 3
#define F_SETFL 4
#define F_GETOWN 5
#define F_SETOWN 6
#define F_GETLK 7
#define F_SETLK 8
#define F_SETLKW 9

#define F_SETLKWTIMEOUT 10


#define F_FLUSH_DATA 40
#define F_CHKCLEAN 41
#define F_PREALLOCATE 42
#define F_SETSIZE 43
#define F_RDADVISE 44
#define F_RDAHEAD 45



#define F_NOCACHE 48
#define F_LOG2PHYS 49
#define F_GETPATH 50
#define F_FULLFSYNC 51
#define F_PATHPKG_CHECK 52
#define F_FREEZE_FS 53
#define F_THAW_FS 54
#define F_GLOBAL_NOCACHE 55


#define F_ADDSIGS 59


#define F_ADDFILESIGS 61

#define F_NODIRECT 62


#define F_GETPROTECTIONCLASS 63
#define F_SETPROTECTIONCLASS 64

#define F_LOG2PHYS_EXT 65

#define F_GETLKPID 66
# 273 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#define F_SETBACKINGSTORE 70
#define F_GETPATH_MTMINFO 71

#define F_GETCODEDIR 72

#define F_SETNOSIGPIPE 73
#define F_GETNOSIGPIPE 74

#define F_TRANSCODEKEY 75

#define F_SINGLE_WRITER 76


#define F_GETPROTECTIONLEVEL 77

#define F_FINDSIGS 78


#define F_ADDFILESIGS_FOR_DYLD_SIM 83


#define F_BARRIERFSYNC 85


#define F_ADDFILESIGS_RETURN 97
#define F_CHECK_LV 98

#define F_PUNCHHOLE 99

#define F_TRIM_ACTIVE_FILE 100

#define F_SPECULATIVE_READ 101

#define F_GETPATH_NOFIRMLINK 102

#define F_ADDFILESIGS_INFO 103
#define F_ADDFILESUPPL 104
#define F_GETSIGSINFO 105


#define FCNTL_FS_SPECIFIC_BASE 0x00010000




#define F_DUPFD_CLOEXEC 67



#define FD_CLOEXEC 1


#define F_RDLCK 1
#define F_UNLCK 2
#define F_WRLCK 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/_types/_seek_set.h" 1 3 4
# 335 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 2 3 4
# 345 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#define F_ALLOCATECONTIG 0x00000002
#define F_ALLOCATEALL 0x00000004



#define F_PEOFPOSMODE 3

#define F_VOLPOSMODE 4






struct flock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
};
# 374 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
struct flocktimeout {
 struct flock fl;
 struct timespec timeout;
};
# 387 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
struct radvisory {
 off_t ra_offset;
 int ra_count;
};
# 399 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#define USER_FSIGNATURES_CDHASH_LEN 20
typedef struct fsignatures {
 off_t fs_file_start;
 void *fs_blob_start;
 size_t fs_blob_size;



 size_t fs_fsignatures_size;
 char fs_cdhash[20];
 int fs_hash_type;
} fsignatures_t;

typedef struct fsupplement {
 off_t fs_file_start;
 off_t fs_blob_start;
 size_t fs_blob_size;
 int fs_orig_fd;
} fsupplement_t;
# 431 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
typedef struct fchecklv {
 off_t lv_file_start;
 size_t lv_error_message_size;
 void *lv_error_message;
} fchecklv_t;






#define GETSIGSINFO_PLATFORM_BINARY 1


typedef struct fgetsigsinfo {
 off_t fg_file_start;
 int fg_info_request;
 int fg_sig_is_platform;
} fgetsigsinfo_t;



#define LOCK_SH 0x01
#define LOCK_EX 0x02
#define LOCK_NB 0x04
#define LOCK_UN 0x08



typedef struct fstore {
 unsigned int fst_flags;
 int fst_posmode;
 off_t fst_offset;
 off_t fst_length;
 off_t fst_bytesalloc;
} fstore_t;


typedef struct fpunchhole {
 unsigned int fp_flags;
 unsigned int reserved;
 off_t fp_offset;
 off_t fp_length;
} fpunchhole_t;


typedef struct ftrimactivefile {
 off_t fta_offset;
 off_t fta_length;
} ftrimactivefile_t;


typedef struct fspecread {
 unsigned int fsr_flags;
 unsigned int reserved;
 off_t fsr_offset;
 off_t fsr_length;
} fspecread_t;



typedef struct fbootstraptransfer {
 off_t fbt_offset;
 size_t fbt_length;
 void *fbt_buffer;
} fbootstraptransfer_t;
# 520 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
#pragma pack(4)

struct log2phys {
 unsigned int l2p_flags;
 off_t l2p_contigbytes;


 off_t l2p_devoffset;


};

#pragma pack()

#define O_POPUP 0x80000000
#define O_ALERT 0x20000000
# 545 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/fcntl.h" 3 4
typedef enum {
 FILESEC_OWNER = 1,
 FILESEC_GROUP = 2,
 FILESEC_UUID = 3,
 FILESEC_MODE = 4,
 FILESEC_ACL = 5,
 FILESEC_GRPUUID = 6,


 FILESEC_ACL_RAW = 100,
 FILESEC_ACL_ALLOCSIZE = 101
} filesec_property_t;


#define FILESEC_GUID FILESEC_UUID



int open(const char *, int, ...) __asm("_" "open" );

int openat(int, const char *, int, ...) __asm("_" "openat" ) ;

int creat(const char *, mode_t) __asm("_" "creat" );
int fcntl(int, int, ...) __asm("_" "fcntl" );


int openx_np(const char *, int, filesec_t);




int open_dprotected_np( const char *, int, int, int, ...);
int flock(int, int);
filesec_t filesec_init(void);
filesec_t filesec_dup(filesec_t);
void filesec_free(filesec_t);
int filesec_get_property(filesec_t, filesec_property_t, void *);
int filesec_query_property(filesec_t, filesec_property_t, int *);
int filesec_set_property(filesec_t, filesec_property_t, const void *);
int filesec_unset_property(filesec_t, filesec_property_t) ;
#define _FILESEC_UNSET_PROPERTY ((void *)0)
#define _FILESEC_REMOVE_ACL ((void *)1)


# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/file.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/file.h" 3 4



# 32595 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 32611 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define HAVE_GETHOSTUUID 0




#undef HAVE_GETHOSTUUID
#define HAVE_GETHOSTUUID 1
# 32632 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 1 3 4
# 72 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 3 4
#define _SYS_MOUNT_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/attr.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/attr.h" 3 4
#define _SYS_ATTR_H_ 
# 46 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/attr.h" 3 4
#define FSOPT_NOFOLLOW 0x00000001
#define FSOPT_NOINMEMUPDATE 0x00000002
#define FSOPT_REPORT_FULLSIZE 0x00000004

#define FSOPT_PACK_INVAL_ATTRS 0x00000008


#define FSOPT_ATTR_CMN_EXTENDED 0x00000020
#define FSOPT_RETURN_REALDEV 0x00000200






#define SEARCHFS_MAX_SEARCHPARMS 4096

typedef u_int32_t text_encoding_t;

typedef u_int32_t fsobj_type_t;

typedef u_int32_t fsobj_tag_t;

typedef u_int32_t fsfile_type_t;

typedef u_int32_t fsvolid_t;



typedef u_int32_t attrgroup_t;

struct attrlist {
 u_short bitmapcount;
 u_int16_t reserved;
 attrgroup_t commonattr;
 attrgroup_t volattr;
 attrgroup_t dirattr;
 attrgroup_t fileattr;
 attrgroup_t forkattr;
};

#define ATTR_BIT_MAP_COUNT 5

typedef struct attribute_set {
 attrgroup_t commonattr;
 attrgroup_t volattr;
 attrgroup_t dirattr;
 attrgroup_t fileattr;
 attrgroup_t forkattr;
} attribute_set_t;

#define ATTRIBUTE_SET_INIT(a) do {(a)->commonattr = (a)->volattr = (a)->dirattr = (a)->fileattr = (a)->forkattr = 0; } while(0)


typedef struct attrreference {
 int32_t attr_dataoffset;
 u_int32_t attr_length;
} attrreference_t;



struct diskextent {
 u_int32_t startblock;
 u_int32_t blockcount;
};

typedef struct diskextent extentrecord[8];

typedef u_int32_t vol_capabilities_set_t[4];

#define VOL_CAPABILITIES_FORMAT 0
#define VOL_CAPABILITIES_INTERFACES 1
#define VOL_CAPABILITIES_RESERVED1 2
#define VOL_CAPABILITIES_RESERVED2 3

typedef struct vol_capabilities_attr {
 vol_capabilities_set_t capabilities;
 vol_capabilities_set_t valid;
} vol_capabilities_attr_t;




#define ATTR_MAX_BUFFER 8192
# 252 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/attr.h" 3 4
#define VOL_CAP_FMT_PERSISTENTOBJECTIDS 0x00000001
#define VOL_CAP_FMT_SYMBOLICLINKS 0x00000002
#define VOL_CAP_FMT_HARDLINKS 0x00000004
#define VOL_CAP_FMT_JOURNAL 0x00000008
#define VOL_CAP_FMT_JOURNAL_ACTIVE 0x00000010
#define VOL_CAP_FMT_NO_ROOT_TIMES 0x00000020
#define VOL_CAP_FMT_SPARSE_FILES 0x00000040
#define VOL_CAP_FMT_ZERO_RUNS 0x00000080
#define VOL_CAP_FMT_CASE_SENSITIVE 0x00000100
#define VOL_CAP_FMT_CASE_PRESERVING 0x00000200
#define VOL_CAP_FMT_FAST_STATFS 0x00000400
#define VOL_CAP_FMT_2TB_FILESIZE 0x00000800
#define VOL_CAP_FMT_OPENDENYMODES 0x00001000
#define VOL_CAP_FMT_HIDDEN_FILES 0x00002000
#define VOL_CAP_FMT_PATH_FROM_ID 0x00004000
#define VOL_CAP_FMT_NO_VOLUME_SIZES 0x00008000
#define VOL_CAP_FMT_DECMPFS_COMPRESSION 0x00010000
#define VOL_CAP_FMT_64BIT_OBJECT_IDS 0x00020000
#define VOL_CAP_FMT_DIR_HARDLINKS 0x00040000
#define VOL_CAP_FMT_DOCUMENT_ID 0x00080000
#define VOL_CAP_FMT_WRITE_GENERATION_COUNT 0x00100000
#define VOL_CAP_FMT_NO_IMMUTABLE_FILES 0x00200000
#define VOL_CAP_FMT_NO_PERMISSIONS 0x00400000
#define VOL_CAP_FMT_SHARED_SPACE 0x00800000
#define VOL_CAP_FMT_VOL_GROUPS 0x01000000
#define VOL_CAP_FMT_SEALED 0x02000000
# 349 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/attr.h" 3 4
#define VOL_CAP_INT_SEARCHFS 0x00000001
#define VOL_CAP_INT_ATTRLIST 0x00000002
#define VOL_CAP_INT_NFSEXPORT 0x00000004
#define VOL_CAP_INT_READDIRATTR 0x00000008
#define VOL_CAP_INT_EXCHANGEDATA 0x00000010
#define VOL_CAP_INT_COPYFILE 0x00000020
#define VOL_CAP_INT_ALLOCATE 0x00000040
#define VOL_CAP_INT_VOL_RENAME 0x00000080
#define VOL_CAP_INT_ADVLOCK 0x00000100
#define VOL_CAP_INT_FLOCK 0x00000200
#define VOL_CAP_INT_EXTENDED_SECURITY 0x00000400
#define VOL_CAP_INT_USERACCESS 0x00000800
#define VOL_CAP_INT_MANLOCK 0x00001000
#define VOL_CAP_INT_NAMEDSTREAMS 0x00002000
#define VOL_CAP_INT_EXTENDED_ATTR 0x00004000
#define VOL_CAP_INT_CLONE 0x00010000
#define VOL_CAP_INT_SNAPSHOT 0x00020000
#define VOL_CAP_INT_RENAME_SWAP 0x00040000
#define VOL_CAP_INT_RENAME_EXCL 0x00080000
#define VOL_CAP_INT_RENAME_OPENFAIL 0x00100000

typedef struct vol_attributes_attr {
 attribute_set_t validattr;
 attribute_set_t nativeattr;
} vol_attributes_attr_t;

#define ATTR_CMN_NAME 0x00000001
#define ATTR_CMN_DEVID 0x00000002
#define ATTR_CMN_FSID 0x00000004
#define ATTR_CMN_OBJTYPE 0x00000008
#define ATTR_CMN_OBJTAG 0x00000010
#define ATTR_CMN_OBJID 0x00000020
#define ATTR_CMN_OBJPERMANENTID 0x00000040
#define ATTR_CMN_PAROBJID 0x00000080
#define ATTR_CMN_SCRIPT 0x00000100
#define ATTR_CMN_CRTIME 0x00000200
#define ATTR_CMN_MODTIME 0x00000400
#define ATTR_CMN_CHGTIME 0x00000800
#define ATTR_CMN_ACCTIME 0x00001000
#define ATTR_CMN_BKUPTIME 0x00002000
#define ATTR_CMN_FNDRINFO 0x00004000
#define ATTR_CMN_OWNERID 0x00008000
#define ATTR_CMN_GRPID 0x00010000
#define ATTR_CMN_ACCESSMASK 0x00020000
#define ATTR_CMN_FLAGS 0x00040000
# 404 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/attr.h" 3 4
#define ATTR_CMN_GEN_COUNT 0x00080000
#define ATTR_CMN_DOCUMENT_ID 0x00100000

#define ATTR_CMN_USERACCESS 0x00200000
#define ATTR_CMN_EXTENDED_SECURITY 0x00400000
#define ATTR_CMN_UUID 0x00800000
#define ATTR_CMN_GRPUUID 0x01000000
#define ATTR_CMN_FILEID 0x02000000
#define ATTR_CMN_PARENTID 0x04000000
#define ATTR_CMN_FULLPATH 0x08000000
#define ATTR_CMN_ADDEDTIME 0x10000000
#define ATTR_CMN_ERROR 0x20000000
#define ATTR_CMN_DATA_PROTECT_FLAGS 0x40000000





#define ATTR_CMN_RETURNED_ATTRS 0x80000000

#define ATTR_CMN_VALIDMASK 0xFFFFFFFF
# 448 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/attr.h" 3 4
#define ATTR_CMN_SETMASK 0x51C7FF00
#define ATTR_CMN_VOLSETMASK 0x00006700

#define ATTR_VOL_FSTYPE 0x00000001
#define ATTR_VOL_SIGNATURE 0x00000002
#define ATTR_VOL_SIZE 0x00000004
#define ATTR_VOL_SPACEFREE 0x00000008
#define ATTR_VOL_SPACEAVAIL 0x00000010
#define ATTR_VOL_MINALLOCATION 0x00000020
#define ATTR_VOL_ALLOCATIONCLUMP 0x00000040
#define ATTR_VOL_IOBLOCKSIZE 0x00000080
#define ATTR_VOL_OBJCOUNT 0x00000100
#define ATTR_VOL_FILECOUNT 0x00000200
#define ATTR_VOL_DIRCOUNT 0x00000400
#define ATTR_VOL_MAXOBJCOUNT 0x00000800
#define ATTR_VOL_MOUNTPOINT 0x00001000
#define ATTR_VOL_NAME 0x00002000
#define ATTR_VOL_MOUNTFLAGS 0x00004000
#define ATTR_VOL_MOUNTEDDEVICE 0x00008000
#define ATTR_VOL_ENCODINGSUSED 0x00010000
#define ATTR_VOL_CAPABILITIES 0x00020000
#define ATTR_VOL_UUID 0x00040000
#define ATTR_VOL_SPACEUSED 0x00800000
#define ATTR_VOL_QUOTA_SIZE 0x10000000
#define ATTR_VOL_RESERVED_SIZE 0x20000000
#define ATTR_VOL_ATTRIBUTES 0x40000000
#define ATTR_VOL_INFO 0x80000000

#define ATTR_VOL_VALIDMASK 0xF087FFFF






#define ATTR_VOL_SETMASK 0x80002000



#define ATTR_DIR_LINKCOUNT 0x00000001
#define ATTR_DIR_ENTRYCOUNT 0x00000002
#define ATTR_DIR_MOUNTSTATUS 0x00000004
#define ATTR_DIR_ALLOCSIZE 0x00000008
#define ATTR_DIR_IOBLOCKSIZE 0x00000010
#define ATTR_DIR_DATALENGTH 0x00000020


#define DIR_MNTSTATUS_MNTPOINT 0x00000001
#define DIR_MNTSTATUS_TRIGGER 0x00000002

#define ATTR_DIR_VALIDMASK 0x0000003f
#define ATTR_DIR_SETMASK 0x00000000

#define ATTR_FILE_LINKCOUNT 0x00000001
#define ATTR_FILE_TOTALSIZE 0x00000002
#define ATTR_FILE_ALLOCSIZE 0x00000004
#define ATTR_FILE_IOBLOCKSIZE 0x00000008
#define ATTR_FILE_DEVTYPE 0x00000020
#define ATTR_FILE_FORKCOUNT 0x00000080
#define ATTR_FILE_FORKLIST 0x00000100
#define ATTR_FILE_DATALENGTH 0x00000200
#define ATTR_FILE_DATAALLOCSIZE 0x00000400
#define ATTR_FILE_RSRCLENGTH 0x00001000
#define ATTR_FILE_RSRCALLOCSIZE 0x00002000

#define ATTR_FILE_VALIDMASK 0x000037FF




#define ATTR_FILE_SETMASK 0x00000020


#define ATTR_CMNEXT_RELPATH 0x00000004
#define ATTR_CMNEXT_PRIVATESIZE 0x00000008
#define ATTR_CMNEXT_LINKID 0x00000010
#define ATTR_CMNEXT_NOFIRMLINKPATH 0x00000020
#define ATTR_CMNEXT_REALDEVID 0x00000040
#define ATTR_CMNEXT_REALFSID 0x00000080
#define ATTR_CMNEXT_CLONEID 0x00000100
#define ATTR_CMNEXT_EXT_FLAGS 0x00000200
#define ATTR_CMNEXT_RECURSIVE_GENCOUNT 0x00000400

#define ATTR_CMNEXT_VALIDMASK 0x000007fc
#define ATTR_CMNEXT_SETMASK 0x00000000


#define ATTR_FORK_TOTALSIZE 0x00000001
#define ATTR_FORK_ALLOCSIZE 0x00000002
#define ATTR_FORK_RESERVED 0xffffffff

#define ATTR_FORK_VALIDMASK 0x00000003
#define ATTR_FORK_SETMASK 0x00000000


#define ATTR_CMN_NAMEDATTRCOUNT 0x00080000
#define ATTR_CMN_NAMEDATTRLIST 0x00100000
#define ATTR_FILE_CLUMPSIZE 0x00000010
#define ATTR_FILE_FILETYPE 0x00000040
#define ATTR_FILE_DATAEXTENTS 0x00000800
#define ATTR_FILE_RSRCEXTENTS 0x00004000


#define ATTR_BULK_REQUIRED (ATTR_CMN_NAME | ATTR_CMN_RETURNED_ATTRS)




#define SRCHFS_START 0x00000001
#define SRCHFS_MATCHPARTIALNAMES 0x00000002
#define SRCHFS_MATCHDIRS 0x00000004
#define SRCHFS_MATCHFILES 0x00000008
#define SRCHFS_SKIPLINKS 0x00000010
#define SRCHFS_SKIPINVISIBLE 0x00000020
#define SRCHFS_SKIPPACKAGES 0x00000040
#define SRCHFS_SKIPINAPPROPRIATE 0x00000080

#define SRCHFS_NEGATEPARAMS 0x80000000
#define SRCHFS_VALIDOPTIONSMASK 0x800000FF

struct fssearchblock {
 struct attrlist *returnattrs;
 void *returnbuffer;
 size_t returnbuffersize;
 u_long maxmatches;
 struct timeval timelimit;
 void *searchparams1;
 size_t sizeofsearchparams1;
 void *searchparams2;
 size_t sizeofsearchparams2;
 struct attrlist searchattrs;
};


struct searchstate {
 uint32_t ss_union_flags;
 uint32_t ss_union_layer;
 u_char ss_fsstate[548];
} __attribute__((packed));

#define FST_EOF (-1)
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 2 3 4
# 1 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 1 3 4
# 31 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#define __OS_BASE__ 
# 55 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#undef OS_INLINE

#define OS_NORETURN __attribute__((__noreturn__))
#define OS_NOTHROW __attribute__((__nothrow__))
#define OS_NONNULL1 __attribute__((__nonnull__(1)))
#define OS_NONNULL2 __attribute__((__nonnull__(2)))
#define OS_NONNULL3 __attribute__((__nonnull__(3)))
#define OS_NONNULL4 __attribute__((__nonnull__(4)))
#define OS_NONNULL5 __attribute__((__nonnull__(5)))
#define OS_NONNULL6 __attribute__((__nonnull__(6)))
#define OS_NONNULL7 __attribute__((__nonnull__(7)))
#define OS_NONNULL8 __attribute__((__nonnull__(8)))
#define OS_NONNULL9 __attribute__((__nonnull__(9)))
#define OS_NONNULL10 __attribute__((__nonnull__(10)))
#define OS_NONNULL11 __attribute__((__nonnull__(11)))
#define OS_NONNULL12 __attribute__((__nonnull__(12)))
#define OS_NONNULL13 __attribute__((__nonnull__(13)))
#define OS_NONNULL14 __attribute__((__nonnull__(14)))
#define OS_NONNULL15 __attribute__((__nonnull__(15)))
#define OS_NONNULL_ALL __attribute__((__nonnull__))
#define OS_SENTINEL __attribute__((__sentinel__))
#define OS_PURE __attribute__((__pure__))
#define OS_CONST __attribute__((__const__))
#define OS_WARN_RESULT __attribute__((__warn_unused_result__))
#define OS_MALLOC __attribute__((__malloc__))
#define OS_USED __attribute__((__used__))
#define OS_UNUSED __attribute__((__unused__))
#define OS_COLD __attribute__((__cold__))
#define OS_WEAK __attribute__((__weak__))
#define OS_WEAK_IMPORT __attribute__((__weak_import__))
#define OS_NOINLINE __attribute__((__noinline__))
#define OS_ALWAYS_INLINE __attribute__((__always_inline__))
#define OS_TRANSPARENT_UNION __attribute__((__transparent_union__))
#define OS_ALIGNED(n) __attribute__((__aligned__((n))))
#define OS_FORMAT_PRINTF(x,y) __attribute__((__format__(printf,x,y)))
#define OS_EXPORT extern __attribute__((__visibility__("default")))
#define OS_INLINE static __inline__
#define OS_EXPECT(x,v) __builtin_expect((x), (v))
# 135 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#define OS_NOESCAPE 





#define OS_FALLTHROUGH __attribute__((__fallthrough__))
# 150 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#define OS_ASSUME_NONNULL_BEGIN 
#define OS_ASSUME_NONNULL_END 





#define OS_COMPILER_CAN_ASSUME(expr) ((void)(expr))





#define OS_OVERLOADABLE 





#define OS_ANALYZER_SUPPRESS(RADAR) 






#define __OS_ENUM_ATTR 
#define __OS_ENUM_ATTR_CLOSED 
# 190 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#define __OS_OPTIONS_ATTR 
# 234 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#define __OS_ENUM_C_FALLBACK(_name,_type,...) typedef _type _name ##_t; enum _name { __VA_ARGS__ }


#define OS_ENUM(_name,_type,...) typedef _type _name ##_t; enum { __VA_ARGS__ }

#define OS_CLOSED_ENUM(_name,_type,...) __OS_ENUM_C_FALLBACK(_name, _type, ## __VA_ARGS__) __OS_ENUM_ATTR_CLOSED


#define OS_OPTIONS(_name,_type,...) __OS_ENUM_C_FALLBACK(_name, _type, ## __VA_ARGS__) __OS_ENUM_ATTR __OS_OPTIONS_ATTR


#define OS_CLOSED_OPTIONS(_name,_type,...) __OS_ENUM_C_FALLBACK(_name, _type, ## __VA_ARGS__) __OS_ENUM_ATTR_CLOSED __OS_OPTIONS_ATTR
# 255 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#define OS_SWIFT_UNAVAILABLE(_msg) 





#define OS_REFINED_FOR_SWIFT 





#define OS_SWIFT_NAME(_name) 


#define __OS_STRINGIFY(s) #s
#define OS_STRINGIFY(s) __OS_STRINGIFY(s)
#define __OS_CONCAT(x,y) x ## y
#define OS_CONCAT(x,y) __OS_CONCAT(x, y)


#define os_prevent_tail_call_optimization() __asm__("")
#define os_is_compile_time_constant(expr) __builtin_constant_p(expr)
#define os_compiler_barrier() __asm__ __volatile__("" ::: "memory")
# 288 "/opt/homebrew/Cellar/gcc/12.2.0/lib/gcc/current/gcc/aarch64-apple-darwin21/12/include-fixed/os/base.h" 3 4
#define OS_NOT_TAIL_CALLED 



typedef void (*os_function_t)(void *);
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 2 3 4
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 3 4
#define MFSNAMELEN 15
#define MFSTYPENAMELEN 16


#define MNAMELEN MAXPATHLEN




#define MNT_EXT_ROOT_DATA_VOL 0x00000001

#define __DARWIN_STRUCT_STATFS64 { uint32_t f_bsize; int32_t f_iosize; uint64_t f_blocks; uint64_t f_bfree; uint64_t f_bavail; uint64_t f_files; uint64_t f_ffree; fsid_t f_fsid; uid_t f_owner; uint32_t f_type; uint32_t f_flags; uint32_t f_fssubtype; char f_fstypename[MFSTYPENAMELEN]; char f_mntonname[MAXPATHLEN]; char f_mntfromname[MAXPATHLEN]; uint32_t f_flags_ext; uint32_t f_reserved[7]; }
# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 3 4
struct statfs { uint32_t f_bsize; int32_t f_iosize; uint64_t f_blocks; uint64_t f_bfree; uint64_t f_bavail; uint64_t f_files; uint64_t f_ffree; fsid_t f_fsid; uid_t f_owner; uint32_t f_type; uint32_t f_flags; uint32_t f_fssubtype; char f_fstypename[16]; char f_mntonname[1024]; char f_mntfromname[1024]; uint32_t f_flags_ext; uint32_t f_reserved[7]; };
# 161 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 3 4
#pragma pack(4)

struct vfsstatfs {
 uint32_t f_bsize;
 size_t f_iosize;
 uint64_t f_blocks;
 uint64_t f_bfree;
 uint64_t f_bavail;
 uint64_t f_bused;
 uint64_t f_files;
 uint64_t f_ffree;
 fsid_t f_fsid;
 uid_t f_owner;
 uint64_t f_flags;
 char f_fstypename[16];
 char f_mntonname[1024];
 char f_mntfromname[1024];
 uint32_t f_fssubtype;
 void *f_reserved[2];
};

#pragma pack()







#define MNT_RDONLY 0x00000001
#define MNT_SYNCHRONOUS 0x00000002
#define MNT_NOEXEC 0x00000004
#define MNT_NOSUID 0x00000008
#define MNT_NODEV 0x00000010
#define MNT_UNION 0x00000020
#define MNT_ASYNC 0x00000040
#define MNT_CPROTECT 0x00000080




#define MNT_EXPORTED 0x00000100





#define MNT_REMOVABLE 0x00000200




#define MNT_QUARANTINE 0x00000400




#define MNT_LOCAL 0x00001000
#define MNT_QUOTA 0x00002000
#define MNT_ROOTFS 0x00004000
#define MNT_DOVOLFS 0x00008000


#define MNT_DONTBROWSE 0x00100000
#define MNT_IGNORE_OWNERSHIP 0x00200000
#define MNT_AUTOMOUNTED 0x00400000
#define MNT_JOURNALED 0x00800000
#define MNT_NOUSERXATTR 0x01000000
#define MNT_DEFWRITE 0x02000000
#define MNT_MULTILABEL 0x04000000
#define MNT_NOATIME 0x10000000
#define MNT_SNAPSHOT 0x40000000
#define MNT_STRICTATIME 0x80000000


#define MNT_UNKNOWNPERMISSIONS MNT_IGNORE_OWNERSHIP






#define MNT_VISFLAGMASK (MNT_RDONLY | MNT_SYNCHRONOUS | MNT_NOEXEC | MNT_NOSUID | MNT_NODEV | MNT_UNION | MNT_ASYNC | MNT_EXPORTED | MNT_QUARANTINE | MNT_LOCAL | MNT_QUOTA | MNT_REMOVABLE | MNT_ROOTFS | MNT_DOVOLFS | MNT_DONTBROWSE | MNT_IGNORE_OWNERSHIP | MNT_AUTOMOUNTED | MNT_JOURNALED | MNT_NOUSERXATTR | MNT_DEFWRITE | MNT_MULTILABEL | MNT_NOATIME | MNT_STRICTATIME | MNT_SNAPSHOT | MNT_CPROTECT)
# 257 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 3 4
#define MNT_UPDATE 0x00010000
#define MNT_NOBLOCK 0x00020000
#define MNT_RELOAD 0x00040000
#define MNT_FORCE 0x00080000
#define MNT_CMDFLAGS (MNT_UPDATE|MNT_NOBLOCK|MNT_RELOAD|MNT_FORCE)
# 271 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/sys/mount.h" 3 4
#define VFS_GENERIC 0
#define VFS_NUMMNTOPS 1





#define VFS_MAXTYPENUM 1
#define VFS_CONF 2







#define MNT_WAIT 1
#define MNT_NOWAIT 2
#define MNT_DWAIT 4



struct mount;
typedef struct mount * mount_t;
struct vnode;
typedef struct vnode * vnode_t;



struct vfsconf {
 uint32_t vfc_reserved1;
 char vfc_name[15];
 int vfc_typenum;
 int vfc_refcount;
 int vfc_flags;
 uint32_t vfc_reserved2;
 uint32_t vfc_reserved3;
};

struct vfsidctl {
 int vc_vers;
 fsid_t vc_fsid;
 void *vc_ptr;
 size_t vc_len;
 u_int32_t vc_spare[12];
};



#define VFS_CTL_VERS1 0x01






#define VFS_CTL_OSTATFS 0x00010001
#define VFS_CTL_UMOUNT 0x00010002
#define VFS_CTL_QUERY 0x00010003
#define VFS_CTL_NEWADDR 0x00010004
#define VFS_CTL_TIMEO 0x00010005
#define VFS_CTL_NOLOCKS 0x00010006
#define VFS_CTL_SADDR 0x00010007
#define VFS_CTL_DISC 0x00010008
#define VFS_CTL_SERVERINFO 0x00010009
#define VFS_CTL_NSTATUS 0x0001000A
#define VFS_CTL_STATFS64 0x0001000B






#define VFS_CTL_STATFS VFS_CTL_STATFS64




struct vfsquery {
 u_int32_t vq_flags;
 u_int32_t vq_spare[31];
};

struct vfs_server {
 int32_t vs_minutes;
 u_int8_t vs_server_name[256 * 3];
};




struct netfs_status {
 u_int32_t ns_status;
 char ns_mountopts[512];
 uint32_t ns_waittime;
 uint32_t ns_threadcount;
 uint64_t ns_threadids[0];
};


#define VQ_NOTRESP 0x0001
#define VQ_NEEDAUTH 0x0002
#define VQ_LOWDISK 0x0004
#define VQ_MOUNT 0x0008
#define VQ_UNMOUNT 0x0010
#define VQ_DEAD 0x0020
#define VQ_ASSIST 0x0040
#define VQ_NOTRESPLOCK 0x0080
#define VQ_UPDATE 0x0100
#define VQ_VERYLOWDISK 0x0200
#define VQ_SYNCEVENT 0x0400
#define VQ_SERVEREVENT 0x0800
#define VQ_QUOTA 0x1000
#define VQ_NEARLOWDISK 0x2000
#define VQ_DESIRED_DISK 0x4000
#define VQ_FREE_SPACE_CHANGE 0x8000
#define VQ_FLAG10000 0x10000






#define NFS_MAX_FH_SIZE NFSV4_MAX_FH_SIZE
#define NFSV4_MAX_FH_SIZE 128
#define NFSV3_MAX_FH_SIZE 64
#define NFSV2_MAX_FH_SIZE 32
struct fhandle {
 unsigned int fh_len;
 unsigned char fh_data[128];
};
typedef struct fhandle fhandle_t;




int fhopen(const struct fhandle *, int);
int fstatfs(int, struct statfs *) __asm("_" "fstatfs" );



int getfh(const char *, fhandle_t *);
int getfsstat(struct statfs *, int, int) __asm("_" "getfsstat" );



int getmntinfo(struct statfs **, int) __asm("_" "getmntinfo" );
int getmntinfo_r_np(struct statfs **, int) __asm("_" "getmntinfo_r_np" )

 ;



int mount(const char *, const char *, int, void *);
int fmount(const char *, int, int, void *) ;
int statfs(const char *, struct statfs *) __asm("_" "statfs" );



int unmount(const char *, int);
int getvfsbyname(const char *, struct vfsconf *);

# 32633 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2
# 32642 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_FSFLAGS_IS_MSDOS 0x1
# 32655 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DEFAULT_FILE_PERMISSIONS 0644






#define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755





#define MAX_PATHNAME 512




#define SQLITE_MAX_SYMLINKS 100



#define osGetpid(X) (pid_t)getpid()





#define IS_LOCK_ERROR(x) ((x != SQLITE_OK) && (x != SQLITE_BUSY))



# 32686 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct unixShm unixShm;
typedef struct unixShmNode unixShmNode;
typedef struct unixInodeInfo unixInodeInfo;
typedef struct UnixUnusedFd UnixUnusedFd;







struct UnixUnusedFd {
  int fd;
  int flags;
  UnixUnusedFd *pNext;
};





typedef struct unixFile unixFile;
struct unixFile {
  sqlite3_io_methods const *pMethod;
  sqlite3_vfs *pVfs;
  unixInodeInfo *pInode;
  int h;
  unsigned char eFileLock;
  unsigned short int ctrlFlags;
  int lastErrno;
  void *lockingContext;
  UnixUnusedFd *pPreallocatedUnused;
  const char *zPath;
  unixShm *pShm;
  int szChunk;

  int nFetchOut;
  sqlite3_int64 mmapSize;
  sqlite3_int64 mmapSizeActual;
  sqlite3_int64 mmapSizeMax;
  void *pMapRegion;

  int sectorSize;
  int deviceCharacteristics;

  int openFlags;


  unsigned fsFlags;
# 32762 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};





static pid_t randomnessPid = 0;




#define UNIXFILE_EXCL 0x01
#define UNIXFILE_RDONLY 0x02
#define UNIXFILE_PERSIST_WAL 0x04

#define UNIXFILE_DIRSYNC 0x08



#define UNIXFILE_PSOW 0x10
#define UNIXFILE_DELETE 0x20
#define UNIXFILE_URI 0x40
#define UNIXFILE_NOLOCK 0x80
# 32811 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define _OS_COMMON_H_ 
# 32929 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TIMER_START 
#define TIMER_END 
#define TIMER_ELAPSED ((sqlite_uint64)0)
# 32969 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SimulateIOErrorBenign(X) 
#define SimulateIOError(A) 
#define SimulateDiskfullError(A) 
# 32981 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OpenCounter(X) 
# 32993 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define O_LARGEFILE 0
# 33003 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define O_BINARY 0







#define threadid pthread_self()
# 33023 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define HAVE_MREMAP 0
# 33057 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int posixOpen(const char *zFile, int flags, int mode){
  return open(zFile, flags, mode);
}


static int openDirectory(const char*, int*);
static int unixGetpagesize(void);







static struct unix_syscall {
  const char *zName;
  sqlite3_syscall_ptr pCurrent;
  sqlite3_syscall_ptr pDefault;
} aSyscall[] = {
  { "open", (sqlite3_syscall_ptr)posixOpen, 0 },
#define osOpen ((int(*)(const char*,int,int))aSyscall[0].pCurrent)

  { "close", (sqlite3_syscall_ptr)close, 0 },
#define osClose ((int(*)(int))aSyscall[1].pCurrent)

  { "access", (sqlite3_syscall_ptr)access, 0 },
#define osAccess ((int(*)(const char*,int))aSyscall[2].pCurrent)

  { "getcwd", (sqlite3_syscall_ptr)getcwd, 0 },
#define osGetcwd ((char*(*)(char*,size_t))aSyscall[3].pCurrent)

  { "stat", (sqlite3_syscall_ptr)stat, 0 },
#define osStat ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)
# 33101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  { "fstat", (sqlite3_syscall_ptr)fstat, 0 },
#define osFstat ((int(*)(int,struct stat*))aSyscall[5].pCurrent)


  { "ftruncate", (sqlite3_syscall_ptr)ftruncate, 0 },
#define osFtruncate ((int(*)(int,off_t))aSyscall[6].pCurrent)

  { "fcntl", (sqlite3_syscall_ptr)fcntl, 0 },
#define osFcntl ((int(*)(int,int,...))aSyscall[7].pCurrent)

  { "read", (sqlite3_syscall_ptr)read, 0 },
#define osRead ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)


  { "pread", (sqlite3_syscall_ptr)pread, 0 },



#define osPread ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)




  { "pread64", (sqlite3_syscall_ptr)0, 0 },

#define osPread64 ((ssize_t(*)(int,void*,size_t,off64_t))aSyscall[10].pCurrent)

  { "write", (sqlite3_syscall_ptr)write, 0 },
#define osWrite ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)


  { "pwrite", (sqlite3_syscall_ptr)pwrite, 0 },



#define osPwrite ((ssize_t(*)(int,const void*,size_t,off_t)) aSyscall[12].pCurrent)





  { "pwrite64", (sqlite3_syscall_ptr)0, 0 },

#define osPwrite64 ((ssize_t(*)(int,const void*,size_t,off64_t)) aSyscall[13].pCurrent)


  { "fchmod", (sqlite3_syscall_ptr)fchmod, 0 },
#define osFchmod ((int(*)(int,mode_t))aSyscall[14].pCurrent)




  { "fallocate", (sqlite3_syscall_ptr)0, 0 },

#define osFallocate ((int(*)(int,off_t,off_t))aSyscall[15].pCurrent)

  { "unlink", (sqlite3_syscall_ptr)unlink, 0 },
#define osUnlink ((int(*)(const char*))aSyscall[16].pCurrent)

  { "openDirectory", (sqlite3_syscall_ptr)openDirectory, 0 },
#define osOpenDirectory ((int(*)(const char*,int*))aSyscall[17].pCurrent)

  { "mkdir", (sqlite3_syscall_ptr)mkdir, 0 },
#define osMkdir ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)

  { "rmdir", (sqlite3_syscall_ptr)rmdir, 0 },
#define osRmdir ((int(*)(const char*))aSyscall[19].pCurrent)


  { "fchown", (sqlite3_syscall_ptr)fchown, 0 },



#define osFchown ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)


  { "geteuid", (sqlite3_syscall_ptr)geteuid, 0 },



#define osGeteuid ((uid_t(*)(void))aSyscall[21].pCurrent)


  { "mmap", (sqlite3_syscall_ptr)mmap, 0 },



#define osMmap ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)


  { "munmap", (sqlite3_syscall_ptr)munmap, 0 },



#define osMunmap ((int(*)(void*,size_t))aSyscall[23].pCurrent)




  { "mremap", (sqlite3_syscall_ptr)0, 0 },

#define osMremap ((void*(*)(void*,size_t,size_t,int,...))aSyscall[24].pCurrent)


  { "getpagesize", (sqlite3_syscall_ptr)unixGetpagesize, 0 },



#define osGetpagesize ((int(*)(void))aSyscall[25].pCurrent)


  { "readlink", (sqlite3_syscall_ptr)readlink, 0 },



#define osReadlink ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)


  { "lstat", (sqlite3_syscall_ptr)lstat, 0 },



#define osLstat ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)
# 33234 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  { "ioctl", (sqlite3_syscall_ptr)0, 0 },


};







static int robustFchown(int fd, uid_t uid, gid_t gid){

  return ((uid_t(*)(void))aSyscall[21].pCurrent)() ? 0 : ((int(*)(int,uid_t,gid_t))aSyscall[20].pCurrent)(fd,uid,gid);



}







static int unixSetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName,
  sqlite3_syscall_ptr pNewFunc
){
  unsigned int i;
  int rc = 12;

  (void)(pNotUsed);
  if( zName==0 ){



    rc = 0;
    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( aSyscall[i].pDefault ){
        aSyscall[i].pCurrent = aSyscall[i].pDefault;
      }
    }
  }else{



    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ){
        if( aSyscall[i].pDefault==0 ){
          aSyscall[i].pDefault = aSyscall[i].pCurrent;
        }
        rc = 0;
        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;
        aSyscall[i].pCurrent = pNewFunc;
        break;
      }
    }
  }
  return rc;
}






static sqlite3_syscall_ptr unixGetSystemCall(
  sqlite3_vfs *pNotUsed,
  const char *zName
){
  unsigned int i;

  (void)(pNotUsed);
  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){
    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;
  }
  return 0;
}







static const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){
  int i = -1;

  (void)(p);
  if( zName ){
    for(i=0; i<((int)(sizeof(aSyscall)/sizeof(aSyscall[0])))-1; i++){
      if( strcmp(zName, aSyscall[i].zName)==0 ) break;
    }
  }
  for(i++; i<((int)(sizeof(aSyscall)/sizeof(aSyscall[0]))); i++){
    if( aSyscall[i].pCurrent!=0 ) return aSyscall[i].zName;
  }
  return 0;
}







#define SQLITE_MINIMUM_FILE_DESCRIPTOR 3
# 33362 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int robust_open(const char *z, int f, mode_t m){
  int fd;
  mode_t m2 = m ? m : 0644;
  while(1){

    fd = ((int(*)(const char*,int,int))aSyscall[0].pCurrent)(z,f|
# 33367 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   0x01000000
# 33367 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            ,m2);



    if( fd<0 ){
      if( (*_errno())==4 ) continue;
      break;
    }
    if( fd>=3 ) break;
    ((int(*)(int))aSyscall[1].pCurrent)(fd);
    sqlite3_log(28,
                "attempt to open \"%s\" as file descriptor %d", z, fd);
    fd = -1;
    if( ((int(*)(const char*,int,int))aSyscall[0].pCurrent)("/dev/null", f, m)<0 ) break;
  }
  if( fd>=0 ){
    if( m!=0 ){
      struct stat statbuf;
      if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(fd, &statbuf)==0
       && statbuf.st_size==0
       && (statbuf.st_mode&0777)!=m
      ){
        ((int(*)(int,mode_t))aSyscall[14].pCurrent)(fd, m);
      }
    }



  }
  return fd;
}
# 33424 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_mutex *unixBigLock = 0;
static void unixEnterMutex(void){
  ((void)0);
  sqlite3_mutex_enter(unixBigLock);
}
static void unixLeaveMutex(void){
  ((void)0);
  sqlite3_mutex_leave(unixBigLock);
}
# 33525 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int robust_ftruncate(int h, sqlite3_int64 sz){
  int rc;
# 33536 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  do{ rc = ((int(*)(int,off_t))aSyscall[6].pCurrent)(h,sz); }while( rc<0 && (*_errno())==4 );
  return rc;
}
# 33550 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {
  ((void)0)


                                                           ;
  switch (posixError) {
  case 13:
  case 11:
  case 138:
  case 16:
  case 4:
  case 39:


    return 5;

  case 1:
    return 3;

  default:
    return sqliteIOErr;
  }
}
# 33592 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct vxworksFileId {
  struct vxworksFileId *pNext;
  int nRef;
  int nName;
  char *zCanonicalName;
};
# 33807 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct unixFileId {
  dev_t dev;
# 33819 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  u64 ino;

};
# 33848 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct unixInodeInfo {
  struct unixFileId fileId;
  sqlite3_mutex *pLockMutex;
  int nShared;
  int nLock;
  unsigned char eFileLock;
  unsigned char bProcessLock;
  UnixUnusedFd *pUnused;
  int nRef;
  unixShmNode *pShmNode;
  unixInodeInfo *pNext;
  unixInodeInfo *pPrev;

  unsigned long long sharedByte;





};






static unixInodeInfo *inodeList = 0;
# 33908 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define unixLogError(a,b,c) unixLogErrorAtLine(a,b,c,__LINE__)
static int unixLogErrorAtLine(
  int errcode,
  const char *zFunc,
  const char *zPath,
  int iLine
){
  char *zErr;
  int iErrno = (*_errno());
# 33946 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  zErr = "";





  if( zPath==0 ) zPath = "";
  sqlite3_log(errcode,
      "os_unix.c:%d: (%d) %s(%s) - %s",
      iLine, iErrno, zFunc, zPath, zErr
  );

  return errcode;
}
# 33974 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void robust_close(unixFile *pFile, int h, int lineno){
  if( ((int(*)(int))aSyscall[1].pCurrent)(h) ){
    unixLogErrorAtLine((10 | (16<<8)), "close",
                       pFile ? pFile->zPath : 0, lineno);
  }
}





static void storeLastErrno(unixFile *pFile, int error){
  pFile->lastErrno = error;
}




static void closePendingFds(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  UnixUnusedFd *p;
  UnixUnusedFd *pNext;
  ((void)0);
  for(p=pInode->pUnused; p; p=pNext){
    pNext = p->pNext;
    robust_close(pFile, p->fd, 33999);
    sqlite3_free(p);
  }
  pInode->pUnused = 0;
}







static void releaseInodeInfo(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  ((void)0);
  ((void)0);
  if( (pInode) ){
    pInode->nRef--;
    if( pInode->nRef==0 ){
      ((void)0);
      sqlite3_mutex_enter(pInode->pLockMutex);
      closePendingFds(pFile);
      sqlite3_mutex_leave(pInode->pLockMutex);
      if( pInode->pPrev ){
        ((void)0);
        pInode->pPrev->pNext = pInode->pNext;
      }else{
        ((void)0);
        inodeList = pInode->pNext;
      }
      if( pInode->pNext ){
        ((void)0);
        pInode->pNext->pPrev = pInode->pPrev;
      }
      sqlite3_mutex_free(pInode->pLockMutex);
      sqlite3_free(pInode);
    }
  }
}
# 34048 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int findInodeInfo(
  unixFile *pFile,
  unixInodeInfo **ppInode
){
  int rc;
  int fd;
  struct unixFileId fileId;
  struct stat statbuf;
  unixInodeInfo *pInode = 0;

  ((void)0);




  fd = pFile->h;
  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(fd, &statbuf);
  if( rc!=0 ){
    storeLastErrno(pFile, (*_errno()));



    return 10;
  }
# 34084 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( statbuf.st_size==0 && (pFile->fsFlags & 0x1)!=0 ){
    do{ rc = ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)(fd, "S", 1); }while( rc<0 && (*_errno())==4 );
    if( rc!=1 ){
      storeLastErrno(pFile, (*_errno()));
      return 10;
    }
    rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(fd, &statbuf);
    if( rc!=0 ){
      storeLastErrno(pFile, (*_errno()));
      return 10;
    }
  }


  memset(&fileId, 0, sizeof(fileId));
  fileId.dev = statbuf.st_dev;



  fileId.ino = (u64)statbuf.st_ino;

  ((void)0);
  pInode = inodeList;
  while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){
    pInode = pInode->pNext;
  }
  if( pInode==0 ){
    pInode = sqlite3_malloc64( sizeof(*pInode) );
    if( pInode==0 ){
      return 7;
    }
    memset(pInode, 0, sizeof(*pInode));
    memcpy(&pInode->fileId, &fileId, sizeof(fileId));
    if( sqlite3Config.bCoreMutex ){
      pInode->pLockMutex = sqlite3_mutex_alloc(0);
      if( pInode->pLockMutex==0 ){
        sqlite3_free(pInode);
        return 7;
      }
    }
    pInode->nRef = 1;
    ((void)0);
    pInode->pNext = inodeList;
    pInode->pPrev = 0;
    if( inodeList ) inodeList->pPrev = pInode;
    inodeList = pInode;
  }else{
    pInode->nRef++;
  }
  *ppInode = pInode;
  return 0;
}




static int fileHasMoved(unixFile *pFile){



  struct stat buf;
  return pFile->pInode!=0 &&
      (((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(pFile->zPath, &buf)!=0
         || (u64)buf.st_ino!=pFile->pInode->fileId.ino);

}
# 34161 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void verifyDbFile(unixFile *pFile){
  struct stat buf;
  int rc;


  if( pFile->ctrlFlags & 0x80 ) return;

  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFile->h, &buf);
  if( rc!=0 ){
    sqlite3_log(28, "cannot fstat db file %s", pFile->zPath);
    return;
  }
  if( buf.st_nlink==0 ){
    sqlite3_log(28, "file unlinked while open: %s", pFile->zPath);
    return;
  }
  if( buf.st_nlink>1 ){
    sqlite3_log(28, "multiple links to file: %s", pFile->zPath);
    return;
  }
  if( fileHasMoved(pFile) ){
    sqlite3_log(28, "file renamed while open: %s", pFile->zPath);
    return;
  }
}
# 34194 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = 0;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

  ;

  ((void)0);
  ((void)0);
  sqlite3_mutex_enter(pFile->pInode->pLockMutex);


  if( pFile->pInode->eFileLock>1 ){
    reserved = 1;
  }




  if( !reserved && !pFile->pInode->bProcessLock ){
    struct flock lock;
    lock.l_whence = 0;
    lock.l_start = (sqlite3PendingByte+1);
    lock.l_len = 1;
    lock.l_type = 
# 34218 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 3
# 34218 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        ;
    if( ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h, 
# 34219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                         7
# 34219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                , &lock) ){
      rc = (10 | (14<<8));
      storeLastErrno(pFile, (*_errno()));
    } else if( lock.l_type!=
# 34222 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                           2 
# 34222 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                   ){
      reserved = 1;
    }
  }


  sqlite3_mutex_leave(pFile->pInode->pLockMutex);
  ;

  *pResOut = reserved;
  return rc;
}
# 34249 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define osSetPosixAdvisoryLock(h,x,t) osFcntl(h,F_SETLK,x)
# 34291 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixFileLock(unixFile *pFile, struct flock *pLock){
  int rc;
  unixInodeInfo *pInode = pFile->pInode;
  ((void)0);
  ((void)0);
  if( (pFile->ctrlFlags & (0x01|0x02))==0x01 ){
    if( pInode->bProcessLock==0 ){
      struct flock lock;
      ((void)0);
      lock.l_whence = 0;
      lock.l_start = (sqlite3PendingByte+2);
      lock.l_len = 510;
      lock.l_type = 
# 34303 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   3
# 34303 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                          ;
      rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h,
# 34304 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
          8
# 34304 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          ,&lock);
      if( rc<0 ) return rc;
      pInode->bProcessLock = 1;
      pInode->nLock++;
    }else{
      rc = 0;
    }
  }else{
    rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pFile->h,
# 34312 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
        8
# 34312 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        ,pLock);
  }
  return rc;
}
# 34341 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixLock(sqlite3_file *id, int eFileLock){
# 34381 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  int rc = 0;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  struct flock lock;
  int tErrno = 0;

  ((void)0);
 


                   ;





  if( pFile->eFileLock>=eFileLock ){
   
                                   ;
    return 0;
  }






  ((void)0);
  ((void)0);
  ((void)0);



  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);




  if( (pFile->eFileLock!=pInode->eFileLock &&
          (pInode->eFileLock>=3 || eFileLock>1))
  ){
    rc = 5;
    goto end_lock;
  }





  if( eFileLock==1 &&
      (pInode->eFileLock==1 || pInode->eFileLock==2) ){
    ((void)0);
    ((void)0);
    ((void)0);
    pFile->eFileLock = 1;
    pInode->nShared++;
    pInode->nLock++;
    goto end_lock;
  }






  lock.l_len = 1L;
  lock.l_whence = 0;
  if( eFileLock==1
      || (eFileLock==4 && pFile->eFileLock<3)
  ){
    lock.l_type = (eFileLock==1?
# 34452 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                         1
# 34452 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                :
# 34452 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                 3
# 34452 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                        );
    lock.l_start = sqlite3PendingByte;
    if( unixFileLock(pFile, &lock) ){
      tErrno = (*_errno());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
      goto end_lock;
    }
  }





  if( eFileLock==1 ){
    ((void)0);
    ((void)0);
    ((void)0);


    lock.l_start = (sqlite3PendingByte+2);
    lock.l_len = 510;
    if( unixFileLock(pFile, &lock) ){
      tErrno = (*_errno());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
    }


    lock.l_start = sqlite3PendingByte;
    lock.l_len = 1L;
    lock.l_type = 
# 34484 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 2
# 34484 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        ;
    if( unixFileLock(pFile, &lock) && rc==0 ){

      tErrno = (*_errno());
      rc = (10 | (8<<8));
    }

    if( rc ){
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
      goto end_lock;
    }else{
      pFile->eFileLock = 1;
      pInode->nLock++;
      pInode->nShared = 1;
    }
  }else if( eFileLock==4 && pInode->nShared>1 ){


    rc = 5;
  }else{




    ((void)0);
    lock.l_type = 
# 34511 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 3
# 34511 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        ;

    ((void)0);
    if( eFileLock==2 ){
      lock.l_start = (sqlite3PendingByte+1);
      lock.l_len = 1L;
    }else{
      lock.l_start = (sqlite3PendingByte+2);
      lock.l_len = 510;
    }

    if( unixFileLock(pFile, &lock) ){
      tErrno = (*_errno());
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
    }
  }
# 34549 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rc==0 ){
    pFile->eFileLock = eFileLock;
    pInode->eFileLock = eFileLock;
  }else if( eFileLock==4 ){
    pFile->eFileLock = 3;
    pInode->eFileLock = 3;
  }

end_lock:
  sqlite3_mutex_leave(pInode->pLockMutex);
 
                                       ;
  return rc;
}





static void setPendingFd(unixFile *pFile){
  unixInodeInfo *pInode = pFile->pInode;
  UnixUnusedFd *p = pFile->pPreallocatedUnused;
  ((void)0);
  p->pNext = pInode->pUnused;
  pInode->pUnused = p;
  pFile->h = -1;
  pFile->pPreallocatedUnused = 0;
}
# 34591 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  struct flock lock;
  int rc = 0;

  ((void)0);
 

                   ;

  ((void)0);
  if( pFile->eFileLock<=eFileLock ){
    return 0;
  }
  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);
  ((void)0);
  if( pFile->eFileLock>1 ){
    ((void)0);
# 34633 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( eFileLock==1 ){





      if( handleNFSUnlock ){
        int tErrno;
        off_t divSize = 510 - 1;

        lock.l_type = 
# 34643 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                     2
# 34643 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            ;
        lock.l_whence = 0;
        lock.l_start = (sqlite3PendingByte+2);
        lock.l_len = divSize;
        if( unixFileLock(pFile, &lock)==(-1) ){
          tErrno = (*_errno());
          rc = (10 | (8<<8));
          storeLastErrno(pFile, tErrno);
          goto end_unlock;
        }
        lock.l_type = 
# 34653 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                     1
# 34653 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            ;
        lock.l_whence = 0;
        lock.l_start = (sqlite3PendingByte+2);
        lock.l_len = divSize;
        if( unixFileLock(pFile, &lock)==(-1) ){
          tErrno = (*_errno());
          rc = sqliteErrorFromPosixError(tErrno, (10 | (9<<8)));
          if( ((rc != 0) && (rc != 5)) ){
            storeLastErrno(pFile, tErrno);
          }
          goto end_unlock;
        }
        lock.l_type = 
# 34665 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                     2
# 34665 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            ;
        lock.l_whence = 0;
        lock.l_start = (sqlite3PendingByte+2)+divSize;
        lock.l_len = 510 -divSize;
        if( unixFileLock(pFile, &lock)==(-1) ){
          tErrno = (*_errno());
          rc = (10 | (8<<8));
          storeLastErrno(pFile, tErrno);
          goto end_unlock;
        }
      }else

      {
        lock.l_type = 
# 34678 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                     1
# 34678 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            ;
        lock.l_whence = 0;
        lock.l_start = (sqlite3PendingByte+2);
        lock.l_len = 510;
        if( unixFileLock(pFile, &lock) ){






          rc = (10 | (9<<8));
          storeLastErrno(pFile, (*_errno()));
          goto end_unlock;
        }
      }
    }
    lock.l_type = 
# 34695 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 2
# 34695 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        ;
    lock.l_whence = 0;
    lock.l_start = sqlite3PendingByte;
    lock.l_len = 2L; ((void)0);
    if( unixFileLock(pFile, &lock)==0 ){
      pInode->eFileLock = 1;
    }else{
      rc = (10 | (8<<8));
      storeLastErrno(pFile, (*_errno()));
      goto end_unlock;
    }
  }
  if( eFileLock==0 ){




    pInode->nShared--;
    if( pInode->nShared==0 ){
      lock.l_type = 
# 34714 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   2
# 34714 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                          ;
      lock.l_whence = 0;
      lock.l_start = lock.l_len = 0L;
      if( unixFileLock(pFile, &lock)==0 ){
        pInode->eFileLock = 0;
      }else{
        rc = (10 | (8<<8));
        storeLastErrno(pFile, (*_errno()));
        pInode->eFileLock = 0;
        pFile->eFileLock = 0;
      }
    }





    pInode->nLock--;
    ((void)0);
    if( pInode->nLock==0 ) closePendingFds(pFile);
  }

end_unlock:
  sqlite3_mutex_leave(pInode->pLockMutex);
  if( rc==0 ){
    pFile->eFileLock = eFileLock;
  }
  return rc;
}
# 34751 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixUnlock(sqlite3_file *id, int eFileLock){

  ((void)0);

  return posixUnlock(id, eFileLock, 0);
}


static int unixMapfile(unixFile *pFd, i64 nByte);
static void unixUnmapfile(unixFile *pFd);
# 34773 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int closeUnixFile(sqlite3_file *id){
  unixFile *pFile = (unixFile*)id;

  unixUnmapfile(pFile);

  if( pFile->h>=0 ){
    robust_close(pFile, pFile->h, 34779);
    pFile->h = -1;
  }
# 34798 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ;
  ;
  sqlite3_free(pFile->pPreallocatedUnused);
  memset(pFile, 0, sizeof(unixFile));
  return 0;
}




static int unixClose(sqlite3_file *id){
  int rc = 0;
  unixFile *pFile = (unixFile *)id;
  unixInodeInfo *pInode = pFile->pInode;

  ((void)0);
  verifyDbFile(pFile);
  unixUnlock(id, 0);
  ((void)0);
  unixEnterMutex();




  ((void)0);
  sqlite3_mutex_enter(pInode->pLockMutex);
  if( pInode->nLock ){





    setPendingFd(pFile);
  }
  sqlite3_mutex_leave(pInode->pLockMutex);
  releaseInodeInfo(pFile);
  rc = closeUnixFile(id);
  unixLeaveMutex();
  return rc;
}
# 34859 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){
  (void)(NotUsed);
  *pResOut = 0;
  return 0;
}
static int nolockLock(sqlite3_file *NotUsed, int NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}
static int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}




static int nolockClose(sqlite3_file *id) {
  return closeUnixFile(id);
}
# 34909 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define DOTLOCK_SUFFIX ".lock"
# 34921 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {
  int rc = 0;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

  ;

  ((void)0);
  reserved = ((int(*)(const char*,int))aSyscall[2].pCurrent)((const char*)pFile->lockingContext, 0)==0;
  ;
  *pResOut = reserved;
  return rc;
}
# 34962 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int dotlockLock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  char *zLockFile = (char *)pFile->lockingContext;
  int rc = 0;





  if( pFile->eFileLock > 0 ){
    pFile->eFileLock = eFileLock;




    utimes(zLockFile, ((void *)0));

    return 0;
  }


  rc = ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)(zLockFile, 0777);
  if( rc<0 ){

    int tErrno = (*_errno());
    if( 17 == tErrno ){
      rc = 5;
    } else {
      rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( rc!=5 ){
        storeLastErrno(pFile, tErrno);
      }
    }
    return rc;
  }


  pFile->eFileLock = eFileLock;
  return rc;
}
# 35012 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int dotlockUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  char *zLockFile = (char *)pFile->lockingContext;
  int rc;

  ((void)0);
 
                                          ;
  ((void)0);


  if( pFile->eFileLock==eFileLock ){
    return 0;
  }




  if( eFileLock==1 ){
    pFile->eFileLock = 1;
    return 0;
  }


  ((void)0);
  rc = ((int(*)(const char*))aSyscall[19].pCurrent)(zLockFile);
  if( rc<0 ){
    int tErrno = (*_errno());
    if( tErrno==2 ){
      rc = 0;
    }else{
      rc = (10 | (8<<8));
      storeLastErrno(pFile, tErrno);
    }
    return rc;
  }
  pFile->eFileLock = 0;
  return 0;
}




static int dotlockClose(sqlite3_file *id) {
  unixFile *pFile = (unixFile*)id;
  ((void)0);
  dotlockUnlock(id, 0);
  sqlite3_free(pFile->lockingContext);
  return closeUnixFile(id);
}
# 35085 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int robust_flock(int fd, int op){
  int rc;
  do{ rc = flock(fd,op); }while( rc<0 && (*_errno())==4 );
  return rc;
}
# 35101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int flockCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = 0;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;

  ;

  ((void)0);


  if( pFile->eFileLock>1 ){
    reserved = 1;
  }


  if( !reserved ){

    int lrc = robust_flock(pFile->h, 
# 35118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                    0x02 
# 35118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                            | 
# 35118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                              0x04
# 35118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                     );
    if( !lrc ){

      lrc = robust_flock(pFile->h, 
# 35121 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                  0x08
# 35121 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                         );
      if ( lrc ) {
        int tErrno = (*_errno());

        lrc = (10 | (8<<8));
        storeLastErrno(pFile, tErrno);
        rc = lrc;
      }
    } else {
      int tErrno = (*_errno());
      reserved = 1;

      lrc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
      if( ((lrc != 0) && (lrc != 5)) ){
        storeLastErrno(pFile, tErrno);
        rc = lrc;
      }
    }
  }
  ;







  *pResOut = reserved;
  return rc;
}
# 35181 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int flockLock(sqlite3_file *id, int eFileLock) {
  int rc = 0;
  unixFile *pFile = (unixFile*)id;

  ((void)0);



  if (pFile->eFileLock > 0) {
    pFile->eFileLock = eFileLock;
    return 0;
  }



  if (robust_flock(pFile->h, 
# 35196 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                            0x02 
# 35196 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                    | 
# 35196 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                      0x04
# 35196 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                             )) {
    int tErrno = (*_errno());

    rc = sqliteErrorFromPosixError(tErrno, (10 | (15<<8)));
    if( ((rc != 0) && (rc != 5)) ){
      storeLastErrno(pFile, tErrno);
    }
  } else {

    pFile->eFileLock = eFileLock;
  }
 
                                            ;





  return rc;
}
# 35225 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int flockUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;

  ((void)0);
 
                                          ;
  ((void)0);


  if( pFile->eFileLock==eFileLock ){
    return 0;
  }


  if (eFileLock==1) {
    pFile->eFileLock = eFileLock;
    return 0;
  }


  if( robust_flock(pFile->h, 
# 35245 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                            0x08
# 35245 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                   ) ){



    return (10 | (8<<8));
  }else{
    pFile->eFileLock = 0;
    return 0;
  }
}




static int flockClose(sqlite3_file *id) {
  ((void)0);
  flockUnlock(id, 0);
  return closeUnixFile(id);
}
# 35461 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct afpLockingContext afpLockingContext;
struct afpLockingContext {
  int reserved;
  const char *dbPath;
};

struct ByteRangeLockPB2
{
  unsigned long long offset;
  unsigned long long length;
  unsigned long long retRangeStart;
  unsigned char unLockFlag;
  unsigned char startEndFlag;
  int fd;
};

#define afpfsByteRangeLock2FSCTL _IOWR('z', 23, struct ByteRangeLockPB2)







static int afpSetLock(
  const char *path,
  unixFile *pFile,
  unsigned long long offset,
  unsigned long long length,
  int setLockFlag
){
  struct ByteRangeLockPB2 pb;
  int err;

  pb.unLockFlag = setLockFlag ? 0 : 1;
  pb.startEndFlag = 0;
  pb.offset = offset;
  pb.length = length;
  pb.fd = pFile->h;

 

                    ;
  err = fsctl(path, 
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   (((__uint32_t)0x80000000|(__uint32_t)0x40000000) | ((sizeof(
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                   struct ByteRangeLockPB2
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   ) & 0x1fff) << 16) | (((
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                   'z'
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   )) << 8) | ((
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                   23
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   )))
# 35504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                           , &pb, 0);
  if ( err==-1 ) {
    int rc;
    int tErrno = (*_errno());
   
                                             ;



    rc = sqliteErrorFromPosixError(tErrno,
                    setLockFlag ? (10 | (15<<8)) : (10 | (8<<8)));

    if( ((rc != 0) && (rc != 5)) ){
      storeLastErrno(pFile, tErrno);
    }
    return rc;
  } else {
    return 0;
  }
}







static int afpCheckReservedLock(sqlite3_file *id, int *pResOut){
  int rc = 0;
  int reserved = 0;
  unixFile *pFile = (unixFile*)id;
  afpLockingContext *context;

  ;

  ((void)0);
  context = (afpLockingContext *) pFile->lockingContext;
  if( context->reserved ){
    *pResOut = 1;
    return 0;
  }
  sqlite3_mutex_enter(pFile->pInode->pLockMutex);

  if( pFile->pInode->eFileLock>1 ){
    reserved = 1;
  }



  if( !reserved ){

    int lrc = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte+1), 1,1);
    if( 0==lrc ){


      lrc = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte+1), 1, 0);
    } else {

      reserved = 1;
    }
    if( ((lrc != 0) && (lrc != 5)) ){
      rc=lrc;
    }
  }

  sqlite3_mutex_leave(pFile->pInode->pLockMutex);
  ;

  *pResOut = reserved;
  return rc;
}
# 35600 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int afpLock(sqlite3_file *id, int eFileLock){
  int rc = 0;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode = pFile->pInode;
  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;

  ((void)0);
 

                                                                         ;





  if( pFile->eFileLock>=eFileLock ){
   
                                  ;
    return 0;
  }






  ((void)0);
  ((void)0);
  ((void)0);



  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);




  if( (pFile->eFileLock!=pInode->eFileLock &&
       (pInode->eFileLock>=3 || eFileLock>1))
     ){
    rc = 5;
    goto afp_end_lock;
  }





  if( eFileLock==1 &&
     (pInode->eFileLock==1 || pInode->eFileLock==2) ){
    ((void)0);
    ((void)0);
    ((void)0);
    pFile->eFileLock = 1;
    pInode->nShared++;
    pInode->nLock++;
    goto afp_end_lock;
  }





  if( eFileLock==1
      || (eFileLock==4 && pFile->eFileLock<3)
  ){
    int failed;
    failed = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 1);
    if (failed) {
      rc = failed;
      goto afp_end_lock;
    }
  }




  if( eFileLock==1 ){
    int lrc1, lrc2, lrc1Errno = 0;
    long lk, mask;

    ((void)0);
    ((void)0);

    mask = (sizeof(long)==8) ? (0xffffffff|(((i64)0x7fffffff)<<32)) : 0x7fffffff;


    lk = random();
    pInode->sharedByte = (lk & mask)%(510 - 1);
    lrc1 = afpSetLock(context->dbPath, pFile,
          (sqlite3PendingByte+2)+pInode->sharedByte, 1, 1);
    if( ((lrc1 != 0) && (lrc1 != 5)) ){
      lrc1Errno = pFile->lastErrno;
    }

    lrc2 = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 0);

    if( ((lrc1 != 0) && (lrc1 != 5)) ) {
      storeLastErrno(pFile, lrc1Errno);
      rc = lrc1;
      goto afp_end_lock;
    } else if( ((lrc2 != 0) && (lrc2 != 5)) ){
      rc = lrc2;
      goto afp_end_lock;
    } else if( lrc1 != 0 ) {
      rc = lrc1;
    } else {
      pFile->eFileLock = 1;
      pInode->nLock++;
      pInode->nShared = 1;
    }
  }else if( eFileLock==4 && pInode->nShared>1 ){


    rc = 5;
  }else{




    int failed = 0;
    ((void)0);
    if (eFileLock >= 2 && pFile->eFileLock < 2) {

        failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte+1), 1,1);
      if( !failed ){
        context->reserved = 1;
      }
    }
    if (!failed && eFileLock == 4) {





      if( !(failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte+2) +
                         pInode->sharedByte, 1, 0)) ){
        int failed2 = 0;

        failed = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte+2),
                               510, 1);
        if( failed && (failed2 = afpSetLock(context->dbPath, pFile,
                       (sqlite3PendingByte+2) + pInode->sharedByte, 1, 1)) ){



          rc = ((failed & 0xff) == 10) ? failed2 :
               (10 | (15<<8));
          goto afp_end_lock;
        }
      }else{
        rc = failed;
      }
    }
    if( failed ){
      rc = failed;
    }
  }

  if( rc==0 ){
    pFile->eFileLock = eFileLock;
    pInode->eFileLock = eFileLock;
  }else if( eFileLock==4 ){
    pFile->eFileLock = 3;
    pInode->eFileLock = 3;
  }

afp_end_lock:
  sqlite3_mutex_leave(pInode->pLockMutex);
 
                                          ;
  return rc;
}
# 35782 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int afpUnlock(sqlite3_file *id, int eFileLock) {
  int rc = 0;
  unixFile *pFile = (unixFile*)id;
  unixInodeInfo *pInode;
  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;
  int skipShared = 0;




  ((void)0);
 

                        ;

  ((void)0);
  if( pFile->eFileLock<=eFileLock ){
    return 0;
  }
  pInode = pFile->pInode;
  sqlite3_mutex_enter(pInode->pLockMutex);
  ((void)0);
  if( pFile->eFileLock>1 ){
    ((void)0);
    ;
   
    ;
# 35825 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pFile->eFileLock==4 ){
      rc = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte+2), 510, 0);
      if( rc==0 && (eFileLock==1 || pInode->nShared>1) ){

        int sharedLockByte = (sqlite3PendingByte+2)+pInode->sharedByte;
        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 1);
      } else {
        skipShared = 1;
      }
    }
    if( rc==0 && pFile->eFileLock>=3 ){
      rc = afpSetLock(context->dbPath, pFile, sqlite3PendingByte, 1, 0);
    }
    if( rc==0 && pFile->eFileLock>=2 && context->reserved ){
      rc = afpSetLock(context->dbPath, pFile, (sqlite3PendingByte+1), 1, 0);
      if( !rc ){
        context->reserved = 0;
      }
    }
    if( rc==0 && (eFileLock==1 || pInode->nShared>1)){
      pInode->eFileLock = 1;
    }
  }
  if( rc==0 && eFileLock==0 ){





    unsigned long long sharedLockByte = (sqlite3PendingByte+2)+pInode->sharedByte;
    pInode->nShared--;
    if( pInode->nShared==0 ){
      ;
     
      ;
      if( !skipShared ){
        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 0);
      }
      if( !rc ){
        pInode->eFileLock = 0;
        pFile->eFileLock = 0;
      }
    }
    if( rc==0 ){
      pInode->nLock--;
      ((void)0);
      if( pInode->nLock==0 ) closePendingFds(pFile);
    }
  }

  sqlite3_mutex_leave(pInode->pLockMutex);
  if( rc==0 ){
    pFile->eFileLock = eFileLock;
  }
  return rc;
}




static int afpClose(sqlite3_file *id) {
  int rc = 0;
  unixFile *pFile = (unixFile*)id;
  ((void)0);
  afpUnlock(id, 0);
  ((void)0);
  unixEnterMutex();
  if( pFile->pInode ){
    unixInodeInfo *pInode = pFile->pInode;
    sqlite3_mutex_enter(pInode->pLockMutex);
    if( pInode->nLock ){





      setPendingFd(pFile);
    }
    sqlite3_mutex_leave(pInode->pLockMutex);
  }
  releaseInodeInfo(pFile);
  sqlite3_free(pFile->lockingContext);
  rc = closeUnixFile(id);
  unixLeaveMutex();
  return rc;
}
# 35933 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int nfsUnlock(sqlite3_file *id, int eFileLock){
  return posixUnlock(id, eFileLock, 1);
}
# 35969 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){
  int got;
  int prior = 0;



  ;
  ((void)0);
  ((void)0);
  do{

    got = ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)(id->h, pBuf, cnt, offset);
    ;
# 35994 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( got==cnt ) break;
    if( got<0 ){
      if( (*_errno())==4 ){ got = 1; continue; }
      prior = 0;
      storeLastErrno((unixFile*)id, (*_errno()));
      break;
    }else if( got>0 ){
      cnt -= got;
      offset += got;
      prior += got;
      pBuf = (void*)(got + (char*)pBuf);
    }
  }while( got>0 );
  ;
 
                                                           ;
  return got+prior;
}






static int unixRead(
  sqlite3_file *id,
  void *pBuf,
  int amt,
  sqlite3_int64 offset
){
  unixFile *pFile = (unixFile *)id;
  int got;
  ((void)0);
  ((void)0);
  ((void)0);
# 36042 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( offset<pFile->mmapSize ){
    if( offset+amt <= pFile->mmapSize ){
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], amt);
      return 0;
    }else{
      int nCopy = pFile->mmapSize - offset;
      memcpy(pBuf, &((u8 *)(pFile->pMapRegion))[offset], nCopy);
      pBuf = &((u8 *)pBuf)[nCopy];
      amt -= nCopy;
      offset += nCopy;
    }
  }


  got = seekAndRead(pFile, offset, pBuf, amt);
  if( got==amt ){
    return 0;
  }else if( got<0 ){

    return (10 | (1<<8));
  }else{
    storeLastErrno(pFile, 0);

    memset(&((char*)pBuf)[got], 0, amt-got);
    return (10 | (2<<8));
  }
}
# 36077 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int seekAndWriteFd(
  int fd,
  i64 iOff,
  const void *pBuf,
  int nBuf,
  int *piErrno
){
  int rc = 0;

  ((void)0);
  ((void)0);
  ((void)0);
  nBuf &= 0x1ffff;
  ;


  do{ rc = (int)((ssize_t(*)(int,const void*,size_t,off_t)) aSyscall[12].pCurrent)(fd, pBuf, nBuf, iOff); }while( rc<0 && (*_errno())==4 );
# 36108 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ;
  ;

  if( rc<0 ) *piErrno = (*_errno());
  return rc;
}
# 36123 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){
  return seekAndWriteFd(id->h, offset, pBuf, cnt, &id->lastErrno);
}






static int unixWrite(
  sqlite3_file *id,
  const void *pBuf,
  int amt,
  sqlite3_int64 offset
){
  unixFile *pFile = (unixFile*)id;
  int wrote = 0;
  ((void)0);
  ((void)0);
# 36191 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  while( (wrote = seekAndWrite(pFile, offset, pBuf, amt))<amt && wrote>0 ){
    amt -= wrote;
    offset += wrote;
    pBuf = &((char*)pBuf)[wrote];
  }
  ;
  ;

  if( amt>wrote ){
    if( wrote<0 && pFile->lastErrno!=28 ){

      return (10 | (3<<8));
    }else{
      storeLastErrno(pFile, 0);
      return 13;
    }
  }

  return 0;
}
# 36228 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define fdatasync fsync
# 36237 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define HAVE_FULLFSYNC 1
# 36267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int full_fsync(int fd, int fullSync, int dataOnly){
  int rc;
# 36279 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(dataOnly);
# 36305 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( fullSync ){
    rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(fd, 
# 36306 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                    51
# 36306 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                               , 0);
  }else{
    rc = 1;
  }
# 36318 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rc ) rc = fsync(fd);
# 36334 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( 0 && rc!= -1 ){
    rc = 0;
  }
  return rc;
}
# 36363 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int openDirectory(const char *zFilename, int *pFd){
  int ii;
  int fd = -1;
  char zDirname[512 +1];

  sqlite3_snprintf(512, zDirname, "%s", zFilename);
  for(ii=(int)strlen(zDirname); ii>0 && zDirname[ii]!='/'; ii--);
  if( ii>0 ){
    zDirname[ii] = '\0';
  }else{
    if( zDirname[0]!='/' ) zDirname[0] = '.';
    zDirname[1] = 0;
  }
  fd = robust_open(zDirname, 
# 36376 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                            0x0000
# 36376 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                    |0, 0);
  if( fd>=0 ){
    ;
  }
  *pFd = fd;
  if( fd>=0 ) return 0;
  return unixLogErrorAtLine(sqlite3CantopenError(36382),"openDirectory",zDirname,36382);
}
# 36400 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixSync(sqlite3_file *id, int flags){
  int rc;
  unixFile *pFile = (unixFile*)id;

  int isDataOnly = (flags&0x00010);
  int isFullsync = (flags&0x0F)==0x00003;


  ((void)0)

   ;




  ;

  ((void)0);
  ;
  rc = full_fsync(pFile->h, isFullsync, isDataOnly);
  ;
  if( rc ){
    storeLastErrno(pFile, (*_errno()));
    return unixLogErrorAtLine((10 | (4<<8)),"full_fsync",pFile->zPath,36423);
  }





  if( pFile->ctrlFlags & 0x08 ){
    int dirfd;
   
                                        ;
    rc = ((int(*)(const char*,int*))aSyscall[17].pCurrent)(pFile->zPath, &dirfd);
    if( rc==0 ){
      full_fsync(dirfd, 0, 0);
      robust_close(pFile, dirfd, 36437);
    }else{
      ((void)0);
      rc = 0;
    }
    pFile->ctrlFlags &= ~0x08;
  }
  return rc;
}




static int unixTruncate(sqlite3_file *id, i64 nByte){
  unixFile *pFile = (unixFile *)id;
  int rc;
  ((void)0);
  ;






  if( pFile->szChunk>0 ){
    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;
  }

  rc = robust_ftruncate(pFile->h, nByte);
  if( rc ){
    storeLastErrno(pFile, (*_errno()));
    return unixLogErrorAtLine((10 | (6<<8)),"ftruncate",pFile->zPath,36468);
  }else{
# 36488 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( nByte<pFile->mmapSize ){
      pFile->mmapSize = nByte;
    }


    return 0;
  }
}




static int unixFileSize(sqlite3_file *id, i64 *pSize){
  int rc;
  struct stat buf;
  ((void)0);
  rc = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(((unixFile*)id)->h, &buf);
  ;
  if( rc!=0 ){
    storeLastErrno((unixFile*)id, (*_errno()));
    return (10 | (7<<8));
  }
  *pSize = buf.st_size;







  if( *pSize==1 ) *pSize = 0;


  return 0;
}






static int proxyFileControl(sqlite3_file*,int,void*);
# 36538 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int fcntlSizeHint(unixFile *pFile, i64 nByte){
  if( pFile->szChunk>0 ){
    i64 nSize;
    struct stat buf;

    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFile->h, &buf) ){
      return (10 | (7<<8));
    }

    nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;
    if( nSize>(i64)buf.st_size ){
# 36567 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      int nBlk = buf.st_blksize;
      int nWrite = 0;
      i64 iWrite;

      iWrite = (buf.st_size/nBlk)*nBlk + nBlk - 1;
      ((void)0);
      ((void)0);
      for( ; iWrite<nSize+nBlk-1; iWrite+=nBlk ){
        if( iWrite>=nSize ) iWrite = nSize - 1;
        nWrite = seekAndWrite(pFile, iWrite, "", 1);
        if( nWrite!=1 ) return (10 | (3<<8));
      }

    }
  }


  if( pFile->mmapSizeMax>0 && nByte>pFile->mmapSize ){
    int rc;
    if( pFile->szChunk<=0 ){
      if( robust_ftruncate(pFile->h, nByte) ){
        storeLastErrno(pFile, (*_errno()));
        return unixLogErrorAtLine((10 | (6<<8)),"ftruncate",pFile->zPath,36589);
      }
    }

    rc = unixMapfile(pFile, nByte);
    return rc;
  }


  return 0;
}







static void unixModeBit(unixFile *pFile, unsigned char mask, int *pArg){
  if( *pArg<0 ){
    *pArg = (pFile->ctrlFlags & mask)!=0;
  }else if( (*pArg)==0 ){
    pFile->ctrlFlags &= ~mask;
  }else{
    pFile->ctrlFlags |= mask;
  }
}


static int unixGetTempname(int nBuf, char *zBuf);




static int unixFileControl(sqlite3_file *id, int op, void *pArg){
  unixFile *pFile = (unixFile*)id;
  switch( op ){
# 36641 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 1: {
      *(int*)pArg = pFile->eFileLock;
      return 0;
    }
    case 4: {
      *(int*)pArg = pFile->lastErrno;
      return 0;
    }
    case 6: {
      pFile->szChunk = *(int *)pArg;
      return 0;
    }
    case 5: {
      int rc;
      ;
      rc = fcntlSizeHint(pFile, *(i64 *)pArg);
      ;
      return rc;
    }
    case 10: {
      unixModeBit(pFile, 0x04, (int*)pArg);
      return 0;
    }
    case 13: {
      unixModeBit(pFile, 0x10, (int*)pArg);
      return 0;
    }
    case 12: {
      *(char**)pArg = sqlite3_mprintf("%s", pFile->pVfs->zName);
      return 0;
    }
    case 16: {
      char *zTFile = sqlite3_malloc64( pFile->pVfs->mxPathname );
      if( zTFile ){
        unixGetTempname(pFile->pVfs->mxPathname, zTFile);
        *(char**)pArg = zTFile;
      }
      return 0;
    }
    case 20: {
      *(int*)pArg = fileHasMoved(pFile);
      return 0;
    }







    case 18: {
      i64 newLimit = *(i64*)pArg;
      int rc = 0;
      if( newLimit>sqlite3Config.mxMmap ){
        newLimit = sqlite3Config.mxMmap;
      }




      if( newLimit>0 && sizeof(size_t)<8 ){
        newLimit = (newLimit & 0x7FFFFFFF);
      }

      *(i64*)pArg = pFile->mmapSizeMax;
      if( newLimit>=0 && newLimit!=pFile->mmapSizeMax && pFile->nFetchOut==0 ){
        pFile->mmapSizeMax = newLimit;
        if( pFile->mmapSize>0 ){
          unixUnmapfile(pFile);
          rc = unixMapfile(pFile, -1);
        }
      }
      return rc;
    }
# 36728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 3:
    case 2: {
      return proxyFileControl(id,op,pArg);
    }

  }
  return 12;
}
# 36747 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void setDeviceCharacteristics(unixFile *pFd){
  ((void)0);
  if( pFd->sectorSize==0 ){
# 36762 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pFd->ctrlFlags & 0x10 ){
      pFd->deviceCharacteristics |= 0x00001000;
    }

    pFd->sectorSize = 4096;
  }
}
# 36854 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixSectorSize(sqlite3_file *id){
  unixFile *pFd = (unixFile*)id;
  setDeviceCharacteristics(pFd);
  return pFd->sectorSize;
}
# 36873 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixDeviceCharacteristics(sqlite3_file *id){
  unixFile *pFd = (unixFile*)id;
  setDeviceCharacteristics(pFd);
  return pFd->deviceCharacteristics;
}
# 36887 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixGetpagesize(void){





  return (int)sysconf(
# 36893 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                     29
# 36893 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                 );

}
# 36930 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct unixShmNode {
  unixInodeInfo *pInode;
  sqlite3_mutex *pShmMutex;
  char *zFilename;
  int hShm;
  int szRegion;
  u16 nRegion;
  u8 isReadonly;
  u8 isUnlocked;
  char **apRegion;
  int nRef;
  unixShm *pFirst;





};
# 36962 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct unixShm {
  unixShmNode *pShmNode;
  unixShm *pNext;
  u8 hasMutex;
  u8 id;
  u16 sharedMask;
  u16 exclMask;
};




#define UNIX_SHM_BASE ((22+SQLITE_SHM_NLOCK)*4)
#define UNIX_SHM_DMS (UNIX_SHM_BASE+SQLITE_SHM_NLOCK)







static int unixShmSystemLock(
  unixFile *pFile,
  int lockType,
  int ofst,
  int n
){
  unixShmNode *pShmNode;
  struct flock f;
  int rc = 0;


  pShmNode = pFile->pInode->pShmNode;
  ((void)0);
  ((void)0);


  ((void)0);


  ((void)0);

  if( pShmNode->hShm>=0 ){

    f.l_type = lockType;
    f.l_whence = 0;
    f.l_start = ofst;
    f.l_len = n;
    rc = ((int(*)(int,int,...))aSyscall[7].pCurrent)(pShmNode->hShm,
# 37010 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
        8
# 37010 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        ,&f);
    rc = (rc!=(-1)) ? 0 : 5;
  }
# 37049 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return rc;
}
# 37061 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixShmRegionPerMap(void){
  int shmsz = 32*1024;
  int pgsz = ((int(*)(void))aSyscall[25].pCurrent)();
  ((void)0);
  if( pgsz<shmsz ) return 1;
  return pgsz/shmsz;
}







static void unixShmPurge(unixFile *pFd){
  unixShmNode *p = pFd->pInode->pShmNode;
  ((void)0);
  if( p && (p->nRef==0) ){
    int nShmPerMap = unixShmRegionPerMap();
    int i;
    ((void)0);
    sqlite3_mutex_free(p->pShmMutex);
    for(i=0; i<p->nRegion; i+=nShmPerMap){
      if( p->hShm>=0 ){
        ((int(*)(void*,size_t))aSyscall[23].pCurrent)(p->apRegion[i], p->szRegion);
      }else{
        sqlite3_free(p->apRegion[i]);
      }
    }
    sqlite3_free(p->apRegion);
    if( p->hShm>=0 ){
      robust_close(pFd, p->hShm, 37092);
      p->hShm = -1;
    }
    p->pInode->pShmNode = 0;
    sqlite3_free(p);
  }
}
# 37109 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixLockSharedMemory(unixFile *pDbFd, unixShmNode *pShmNode){
  struct flock lock;
  int rc = 0;
# 37131 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  lock.l_whence = 0;
  lock.l_start = (((22+8)*4)+8);
  lock.l_len = 1;
  lock.l_type = 
# 37134 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
               3
# 37134 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                      ;
  if( ((int(*)(int,int,...))aSyscall[7].pCurrent)(pShmNode->hShm, 
# 37135 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                             7
# 37135 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                    , &lock)!=0 ) {
    rc = (10 | (15<<8));
  }else if( lock.l_type==
# 37137 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                        2 
# 37137 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                ){
    if( pShmNode->isReadonly ){
      pShmNode->isUnlocked = 1;
      rc = (8 | (5<<8));
    }else{
      rc = unixShmSystemLock(pDbFd, 
# 37142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                   3
# 37142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                          , (((22+8)*4)+8), 1);





      if( rc==0 && robust_ftruncate(pShmNode->hShm, 3) ){
        rc = unixLogErrorAtLine((10 | (18<<8)),"ftruncate",pShmNode->zFilename,37149);
      }
    }
  }else if( lock.l_type==
# 37152 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                        3 
# 37152 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                ){
    rc = 5;
  }

  if( rc==0 ){
    ((void)0);
    rc = unixShmSystemLock(pDbFd, 
# 37158 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                 1
# 37158 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                        , (((22+8)*4)+8), 1);
  }
  return rc;
}
# 37198 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixOpenSharedMemory(unixFile *pDbFd){
  struct unixShm *p = 0;
  struct unixShmNode *pShmNode;
  int rc = 0;
  unixInodeInfo *pInode;
  char *zShm;
  int nShmFilename;


  p = sqlite3_malloc64( sizeof(*p) );
  if( p==0 ) return 7;
  memset(p, 0, sizeof(*p));
  ((void)0);




  ((void)0);
  unixEnterMutex();
  pInode = pDbFd->pInode;
  pShmNode = pInode->pShmNode;
  if( pShmNode==0 ){
    struct stat sStat;

    const char *zBasePath = pDbFd->zPath;






    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pDbFd->h, &sStat) ){
      rc = (10 | (7<<8));
      goto shm_open_err;
    }




    nShmFilename = 6 + (int)strlen(zBasePath);

    pShmNode = sqlite3_malloc64( sizeof(*pShmNode) + nShmFilename );
    if( pShmNode==0 ){
      rc = 7;
      goto shm_open_err;
    }
    memset(pShmNode, 0, sizeof(*pShmNode)+nShmFilename);
    zShm = pShmNode->zFilename = (char*)&pShmNode[1];





    sqlite3_snprintf(nShmFilename, zShm, "%s-shm", zBasePath);
    ;

    pShmNode->hShm = -1;
    pDbFd->pInode->pShmNode = pShmNode;
    pShmNode->pInode = pDbFd->pInode;
    if( sqlite3Config.bCoreMutex ){
      pShmNode->pShmMutex = sqlite3_mutex_alloc(0);
      if( pShmNode->pShmMutex==0 ){
        rc = 7;
        goto shm_open_err;
      }
    }

    if( pInode->bProcessLock==0 ){
      if( 0==sqlite3_uri_boolean(pDbFd->zPath, "readonly_shm", 0) ){
        pShmNode->hShm = robust_open(zShm, 
# 37267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                          0x0002
# 37267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                |
# 37267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                 0x00000200
# 37267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                        ,(sStat.st_mode&0777));
      }
      if( pShmNode->hShm<0 ){
        pShmNode->hShm = robust_open(zShm, 
# 37270 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                          0x0000
# 37270 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                  , (sStat.st_mode&0777));
        if( pShmNode->hShm<0 ){
          rc = unixLogErrorAtLine(sqlite3CantopenError(37272),"open",zShm,37272);
          goto shm_open_err;
        }
        pShmNode->isReadonly = 1;
      }





      robustFchown(pShmNode->hShm, sStat.st_uid, sStat.st_gid);

      rc = unixLockSharedMemory(pDbFd, pShmNode);
      if( rc!=0 && rc!=(8 | (5<<8)) ) goto shm_open_err;
    }
  }


  p->pShmNode = pShmNode;



  pShmNode->nRef++;
  pDbFd->pShm = p;
  unixLeaveMutex();
# 37305 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_mutex_enter(pShmNode->pShmMutex);
  p->pNext = pShmNode->pFirst;
  pShmNode->pFirst = p;
  sqlite3_mutex_leave(pShmNode->pShmMutex);
  return rc;


shm_open_err:
  unixShmPurge(pDbFd);
  sqlite3_free(p);
  unixLeaveMutex();
  return rc;
}
# 37338 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixShmMap(
  sqlite3_file *fd,
  int iRegion,
  int szRegion,
  int bExtend,
  void volatile **pp
){
  unixFile *pDbFd = (unixFile*)fd;
  unixShm *p;
  unixShmNode *pShmNode;
  int rc = 0;
  int nShmPerMap = unixShmRegionPerMap();
  int nReqRegion;


  if( pDbFd->pShm==0 ){
    rc = unixOpenSharedMemory(pDbFd);
    if( rc!=0 ) return rc;
  }

  p = pDbFd->pShm;
  pShmNode = p->pShmNode;
  sqlite3_mutex_enter(pShmNode->pShmMutex);
  if( pShmNode->isUnlocked ){
    rc = unixLockSharedMemory(pDbFd, pShmNode);
    if( rc!=0 ) goto shmpage_out;
    pShmNode->isUnlocked = 0;
  }
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  nReqRegion = ((iRegion+nShmPerMap) / nShmPerMap) * nShmPerMap;

  if( pShmNode->nRegion<nReqRegion ){
    char **apNew;
    int nByte = nReqRegion*szRegion;
    struct stat sStat;

    pShmNode->szRegion = szRegion;

    if( pShmNode->hShm>=0 ){




      if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pShmNode->hShm, &sStat) ){
        rc = (10 | (19<<8));
        goto shmpage_out;
      }

      if( sStat.st_size<nByte ){



        if( !bExtend ){
          goto shmpage_out;
        }
# 37406 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        else{
          static const int pgsz = 4096;
          int iPg;


          ((void)0);
          for(iPg=(sStat.st_size/pgsz); iPg<(nByte/pgsz); iPg++){
            int x = 0;
            if( seekAndWriteFd(pShmNode->hShm, iPg*pgsz + pgsz-1,"",1,&x)!=1 ){
              const char *zFile = pShmNode->zFilename;
              rc = unixLogErrorAtLine((10 | (19<<8)),"write",zFile,37416);
              goto shmpage_out;
            }
          }
        }
      }
    }


    apNew = (char **)sqlite3_realloc(
        pShmNode->apRegion, nReqRegion*sizeof(char *)
    );
    if( !apNew ){
      rc = (10 | (12<<8));
      goto shmpage_out;
    }
    pShmNode->apRegion = apNew;
    while( pShmNode->nRegion<nReqRegion ){
      int nMap = szRegion*nShmPerMap;
      int i;
      void *pMem;
      if( pShmNode->hShm>=0 ){
        pMem = ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)(0, nMap,
            pShmNode->isReadonly ? 
# 37439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                  0x01 
# 37439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                            : 
# 37439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                              0x01
# 37439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                       |
# 37439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                        0x02
# 37439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                                  ,
            
# 37440 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
           0x0001
# 37440 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                     , pShmNode->hShm, szRegion*(i64)pShmNode->nRegion
        );
        if( pMem==
# 37442 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 ((void *)-1) 
# 37442 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            ){
          rc = unixLogErrorAtLine((10 | (21<<8)),"mmap",pShmNode->zFilename,37443);
          goto shmpage_out;
        }
      }else{
        pMem = sqlite3_malloc64(nMap);
        if( pMem==0 ){
          rc = 7;
          goto shmpage_out;
        }
        memset(pMem, 0, nMap);
      }

      for(i=0; i<nShmPerMap; i++){
        pShmNode->apRegion[pShmNode->nRegion+i] = &((char*)pMem)[szRegion*i];
      }
      pShmNode->nRegion += nShmPerMap;
    }
  }

shmpage_out:
  if( pShmNode->nRegion>iRegion ){
    *pp = pShmNode->apRegion[iRegion];
  }else{
    *pp = 0;
  }
  if( pShmNode->isReadonly && rc==0 ) rc = 8;
  sqlite3_mutex_leave(pShmNode->pShmMutex);
  return rc;
}
# 37481 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixShmLock(
  sqlite3_file *fd,
  int ofst,
  int n,
  int flags
){
  unixFile *pDbFd = (unixFile*)fd;
  unixShm *p = pDbFd->pShm;
  unixShm *pX;
  unixShmNode *pShmNode = p->pShmNode;
  int rc = 0;
  u16 mask;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0)


                                                             ;
  ((void)0);
  ((void)0);
  ((void)0);

  mask = (1<<(ofst+n)) - (1<<ofst);
  ((void)0);
  sqlite3_mutex_enter(pShmNode->pShmMutex);
  if( flags & 1 ){
    u16 allMask = 0;


    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
      if( pX==p ) continue;
      ((void)0);
      allMask |= pX->sharedMask;
    }


    if( (mask & allMask)==0 ){
      rc = unixShmSystemLock(pDbFd, 
# 37521 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                   2
# 37521 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                          , ofst+((22+8)*4), n);
    }else{
      rc = 0;
    }


    if( rc==0 ){
      p->exclMask &= ~mask;
      p->sharedMask &= ~mask;
    }
  }else if( flags & 4 ){
    u16 allShared = 0;





    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
      if( (pX->exclMask & mask)!=0 ){
        rc = 5;
        break;
      }
      allShared |= pX->sharedMask;
    }


    if( rc==0 ){
      if( (allShared & mask)==0 ){
        rc = unixShmSystemLock(pDbFd, 
# 37549 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                     1
# 37549 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                            , ofst+((22+8)*4), n);
      }else{
        rc = 0;
      }
    }


    if( rc==0 ){
      p->sharedMask |= mask;
    }
  }else{



    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){
      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){
        rc = 5;
        break;
      }
    }




    if( rc==0 ){
      rc = unixShmSystemLock(pDbFd, 
# 37574 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                   3
# 37574 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                          , ofst+((22+8)*4), n);
      if( rc==0 ){
        ((void)0);
        p->exclMask |= mask;
      }
    }
  }
  sqlite3_mutex_leave(pShmNode->pShmMutex);
 
                                                           ;
  return rc;
}







static void unixShmBarrier(
  sqlite3_file *fd
){
  (void)(fd);
  sqlite3MemoryBarrier();
  ((void)0)

   ;
  unixEnterMutex();
  unixLeaveMutex();
}
# 37612 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixShmUnmap(
  sqlite3_file *fd,
  int deleteFlag
){
  unixShm *p;
  unixShmNode *pShmNode;
  unixShm **pp;
  unixFile *pDbFd;

  pDbFd = (unixFile*)fd;
  p = pDbFd->pShm;
  if( p==0 ) return 0;
  pShmNode = p->pShmNode;

  ((void)0);
  ((void)0);



  sqlite3_mutex_enter(pShmNode->pShmMutex);
  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}
  *pp = p->pNext;


  sqlite3_free(p);
  pDbFd->pShm = 0;
  sqlite3_mutex_leave(pShmNode->pShmMutex);



  ((void)0);
  unixEnterMutex();
  ((void)0);
  pShmNode->nRef--;
  if( pShmNode->nRef==0 ){
    if( deleteFlag && pShmNode->hShm>=0 ){
      ((int(*)(const char*))aSyscall[16].pCurrent)(pShmNode->zFilename);
    }
    unixShmPurge(pDbFd);
  }
  unixLeaveMutex();

  return 0;
}
# 37669 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void unixUnmapfile(unixFile *pFd){
  ((void)0);
  if( pFd->pMapRegion ){
    ((int(*)(void*,size_t))aSyscall[23].pCurrent)(pFd->pMapRegion, pFd->mmapSizeActual);
    pFd->pMapRegion = 0;
    pFd->mmapSize = 0;
    pFd->mmapSizeActual = 0;
  }
}
# 37694 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void unixRemapfile(
  unixFile *pFd,
  i64 nNew
){
  const char *zErr = "mmap";
  int h = pFd->h;
  u8 *pOrig = (u8 *)pFd->pMapRegion;
  i64 nOrig = pFd->mmapSizeActual;
  u8 *pNew = 0;
  int flags = 
# 37703 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
             0x01
# 37703 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                      ;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);





  if( pOrig ){



    const int szSyspage = ((int(*)(void))aSyscall[25].pCurrent)();
    i64 nReuse = (pFd->mmapSize & ~(szSyspage-1));

    u8 *pReq = &pOrig[nReuse];


    if( nReuse!=nOrig ){
      ((int(*)(void*,size_t))aSyscall[23].pCurrent)(pReq, nOrig-nReuse);
    }





    pNew = ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)(pReq, nNew-nReuse, flags, 
# 37734 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                           0x0001
# 37734 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                     , h, nReuse);
    if( pNew!=
# 37735 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
             ((void *)-1) 
# 37735 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        ){
      if( pNew!=pReq ){
        ((int(*)(void*,size_t))aSyscall[23].pCurrent)(pNew, nNew - nReuse);
        pNew = 0;
      }else{
        pNew = pOrig;
      }
    }



    if( pNew==
# 37746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
             ((void *)-1) 
# 37746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        || pNew==0 ){
      ((int(*)(void*,size_t))aSyscall[23].pCurrent)(pOrig, nReuse);
    }
  }


  if( pNew==0 ){
    pNew = ((void*(*)(void*,size_t,int,int,int,off_t))aSyscall[22].pCurrent)(0, nNew, flags, 
# 37753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                 0x0001
# 37753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                           , h, 0);
  }

  if( pNew==
# 37756 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
           ((void *)-1) 
# 37756 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                      ){
    pNew = 0;
    nNew = 0;
    unixLogErrorAtLine(0,zErr,pFd->zPath,37759);




    pFd->mmapSizeMax = 0;
  }
  pFd->pMapRegion = (void *)pNew;
  pFd->mmapSize = pFd->mmapSizeActual = nNew;
}
# 37786 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixMapfile(unixFile *pFd, i64 nMap){
  ((void)0);
  ((void)0);
  if( pFd->nFetchOut>0 ) return 0;

  if( nMap<0 ){
    struct stat statbuf;
    if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFd->h, &statbuf) ){
      return (10 | (7<<8));
    }
    nMap = statbuf.st_size;
  }
  if( nMap>pFd->mmapSizeMax ){
    nMap = pFd->mmapSizeMax;
  }

  ((void)0);
  if( nMap!=pFd->mmapSize ){
    unixRemapfile(pFd, nMap);
  }

  return 0;
}
# 37823 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixFetch(sqlite3_file *fd, i64 iOff, int nAmt, void **pp){

  unixFile *pFd = (unixFile *)fd;

  *pp = 0;


  if( pFd->mmapSizeMax>0 ){
    if( pFd->pMapRegion==0 ){
      int rc = unixMapfile(pFd, -1);
      if( rc!=0 ) return rc;
    }
    if( pFd->mmapSize >= iOff+nAmt ){
      *pp = &((u8 *)pFd->pMapRegion)[iOff];
      pFd->nFetchOut++;
    }
  }

  return 0;
}
# 37854 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixUnfetch(sqlite3_file *fd, i64 iOff, void *p){

  unixFile *pFd = (unixFile *)fd;
  (void)(iOff);




  ((void)0);


  ((void)0);

  if( p ){
    pFd->nFetchOut--;
  }else{
    unixUnmapfile(pFd);
  }

  ((void)0);





  return 0;
}
# 37922 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IOMETHODS(FINDER,METHOD,VERSION,CLOSE,LOCK,UNLOCK,CKLOCK,SHMMAP) static const sqlite3_io_methods METHOD = { VERSION, CLOSE, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, LOCK, UNLOCK, CKLOCK, unixFileControl, unixSectorSize, unixDeviceCharacteristics, SHMMAP, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *FINDER ##Impl(const char *z, unixFile *p){ UNUSED_PARAMETER(z); UNUSED_PARAMETER(p); return &METHOD; } static const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p) = FINDER ##Impl;
# 37956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_io_methods posixIoMethods = { 3, unixClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, unixLock, unixUnlock, unixCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, unixShmMap, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *posixIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &posixIoMethods; } static const sqlite3_io_methods *(*const posixIoFinder)(const char*,unixFile *p) = posixIoFinderImpl;
# 37966 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_io_methods nolockIoMethods = { 3, nolockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, nolockLock, nolockUnlock, nolockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *nolockIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &nolockIoMethods; } static const sqlite3_io_methods *(*const nolockIoFinder)(const char*,unixFile *p) = nolockIoFinderImpl;
# 37976 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_io_methods dotlockIoMethods = { 1, dotlockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, dotlockLock, dotlockUnlock, dotlockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *dotlockIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &dotlockIoMethods; } static const sqlite3_io_methods *(*const dotlockIoFinder)(const char*,unixFile *p) = dotlockIoFinderImpl;
# 37988 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_io_methods flockIoMethods = { 1, flockClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, flockLock, flockUnlock, flockCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *flockIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &flockIoMethods; } static const sqlite3_io_methods *(*const flockIoFinder)(const char*,unixFile *p) = flockIoFinderImpl;
# 38014 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_io_methods afpIoMethods = { 1, afpClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, afpLock, afpUnlock, afpCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *afpIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &afpIoMethods; } static const sqlite3_io_methods *(*const afpIoFinder)(const char*,unixFile *p) = afpIoFinderImpl;
# 38036 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyClose(sqlite3_file*);
static int proxyLock(sqlite3_file*, int);
static int proxyUnlock(sqlite3_file*, int);
static int proxyCheckReservedLock(sqlite3_file*, int*);
static const sqlite3_io_methods proxyIoMethods = { 1, proxyClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, proxyLock, proxyUnlock, proxyCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *proxyIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &proxyIoMethods; } static const sqlite3_io_methods *(*const proxyIoFinder)(const char*,unixFile *p) = proxyIoFinderImpl;
# 38054 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_io_methods nfsIoMethods = { 1, unixClose, unixRead, unixWrite, unixTruncate, unixSync, unixFileSize, unixLock, nfsUnlock, unixCheckReservedLock, unixFileControl, unixSectorSize, unixDeviceCharacteristics, 0, unixShmLock, unixShmBarrier, unixShmUnmap, unixFetch, unixUnfetch, }; static const sqlite3_io_methods *nfsIoFinderImpl(const char *z, unixFile *p){ (void)(z); (void)(p); return &nfsIoMethods; } static const sqlite3_io_methods *(*const nfsIoFinder)(const char*,unixFile *p) = nfsIoFinderImpl;
# 38074 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_io_methods *autolockIoFinderImpl(
  const char *filePath,
  unixFile *pNew
){
  static const struct Mapping {
    const char *zFilesystem;
    const sqlite3_io_methods *pMethods;
  } aMap[] = {
    { "hfs", &posixIoMethods },
    { "ufs", &posixIoMethods },
    { "afpfs", &afpIoMethods },
    { "smbfs", &afpIoMethods },
    { "webdav", &nolockIoMethods },
    { 0, 0 }
  };
  int i;
  struct statfs fsInfo;
  struct flock lockInfo;

  if( !filePath ){


    return &nolockIoMethods;
  }
  if( statfs(filePath, &fsInfo) != -1 ){
    if( fsInfo.f_flags & 
# 38099 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                        0x00000001 
# 38099 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                   ){
      return &nolockIoMethods;
    }
    for(i=0; aMap[i].zFilesystem; i++){
      if( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){
        return aMap[i].pMethods;
      }
    }
  }





  lockInfo.l_len = 1;
  lockInfo.l_start = 0;
  lockInfo.l_whence = 0;
  lockInfo.l_type = 
# 38116 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                   1
# 38116 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                          ;
  if( ((int(*)(int,int,...))aSyscall[7].pCurrent)(pNew->h, 
# 38117 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                      7
# 38117 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                             , &lockInfo)!=-1 ) {
    if( strcmp(fsInfo.f_fstypename, "nfs")==0 ){
      return &nfsIoMethods;
    } else {
      return &posixIoMethods;
    }
  }else{
    return &dotlockIoMethods;
  }
}
static const sqlite3_io_methods
  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;
# 38171 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);
# 38184 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int fillInUnixFile(
  sqlite3_vfs *pVfs,
  int h,
  sqlite3_file *pId,
  const char *zFilename,
  int ctrlFlags
){
  const sqlite3_io_methods *pLockingStyle;
  unixFile *pNew = (unixFile *)pId;
  int rc = 0;

  ((void)0);


  ((void)0);

  ;
  pNew->h = h;
  pNew->pVfs = pVfs;
  pNew->zPath = zFilename;
  pNew->ctrlFlags = (u8)ctrlFlags;

  pNew->mmapSizeMax = sqlite3Config.szMmap;

  if( sqlite3_uri_boolean(((ctrlFlags & 0x40) ? zFilename : 0),
                           "psow", 1) ){
    pNew->ctrlFlags |= 0x10;
  }
  if( strcmp(pVfs->zName,"unix-excl")==0 ){
    pNew->ctrlFlags |= 0x01;
  }
# 38224 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( ctrlFlags & 0x80 ){
    pLockingStyle = &nolockIoMethods;
  }else{
    pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);




    pNew->lockingContext = (void*)zFilename;

  }

  if( pLockingStyle == &posixIoMethods

    || pLockingStyle == &nfsIoMethods

  ){
    unixEnterMutex();
    rc = findInodeInfo(pNew, &pNew->pInode);
    if( rc!=0 ){
# 38262 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      robust_close(pNew, h, 38262);
      h = -1;
    }
    unixLeaveMutex();
  }


  else if( pLockingStyle == &afpIoMethods ){



    afpLockingContext *pCtx;
    pNew->lockingContext = pCtx = sqlite3_malloc64( sizeof(*pCtx) );
    if( pCtx==0 ){
      rc = 7;
    }else{



      pCtx->dbPath = zFilename;
      pCtx->reserved = 0;
      srandomdev();
      unixEnterMutex();
      rc = findInodeInfo(pNew, &pNew->pInode);
      if( rc!=0 ){
        sqlite3_free(pNew->lockingContext);
        robust_close(pNew, h, 38288);
        h = -1;
      }
      unixLeaveMutex();
    }
  }


  else if( pLockingStyle == &dotlockIoMethods ){



    char *zLockFile;
    int nFilename;
    ((void)0);
    nFilename = (int)strlen(zFilename) + 6;
    zLockFile = (char *)sqlite3_malloc64(nFilename);
    if( zLockFile==0 ){
      rc = 7;
    }else{
      sqlite3_snprintf(nFilename, zLockFile, "%s" ".lock", zFilename);
    }
    pNew->lockingContext = zLockFile;
  }
# 38337 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  storeLastErrno(pNew, 0);
# 38346 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rc!=0 ){
    if( h>=0 ) robust_close(pNew, h, 38347);
  }else{
    pNew->pMethod = pLockingStyle;
    ;
    verifyDbFile(pNew);
  }
  return rc;
}





static const char *unixTempFileDir(void){
  static const char *azDirs[] = {
     0,
     0,
     "/var/tmp",
     "/usr/tmp",
     "/tmp",
     "."
  };
  unsigned int i = 0;
  struct stat buf;
  const char *zDir = sqlite3_temp_directory;

  if( !azDirs[0] ) azDirs[0] = getenv("SQLITE_TMPDIR");
  if( !azDirs[1] ) azDirs[1] = getenv("TMPDIR");
  while(1){
    if( zDir!=0
     && ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zDir, &buf)==0
     && 
# 38378 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
       (((
# 38378 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
       buf.st_mode
# 38378 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
       ) & 0170000) == 0040000)
     
# 38379 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    && ((int(*)(const char*,int))aSyscall[2].pCurrent)(zDir, 03)==0
    ){
      return zDir;
    }
    if( i>=sizeof(azDirs)/sizeof(azDirs[0]) ) break;
    zDir = azDirs[i++];
  }
  return 0;
}






static int unixGetTempname(int nBuf, char *zBuf){
  const char *zDir;
  int iLimit = 0;





  zBuf[0] = 0;
  ;

  zDir = unixTempFileDir();
  if( zDir==0 ) return (10 | (25<<8));
  do{
    u64 r;
    sqlite3_randomness(sizeof(r), &r);
    ((void)0);
    zBuf[nBuf-2] = 0;
    sqlite3_snprintf(nBuf, zBuf, "%s/""etilqs_""%llx%c",
                     zDir, r, 0);
    if( zBuf[nBuf-2]!=0 || (iLimit++)>10 ) return 1;
  }while( ((int(*)(const char*,int))aSyscall[2].pCurrent)(zBuf,0)==0 );
  return 0;
}







static int proxyTransformUnixFile(unixFile*, const char*);
# 38444 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static UnixUnusedFd *findReusableFd(const char *zPath, int flags){
  UnixUnusedFd *pUnused = 0;







  struct stat sStat;

  unixEnterMutex();
# 38465 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( inodeList!=0 && 0==((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zPath, &sStat) ){
    unixInodeInfo *pInode;

    pInode = inodeList;
    while( pInode && (pInode->fileId.dev!=sStat.st_dev
                     || pInode->fileId.ino!=(u64)sStat.st_ino) ){
       pInode = pInode->pNext;
    }
    if( pInode ){
      UnixUnusedFd **pp;
      ((void)0);
      sqlite3_mutex_enter(pInode->pLockMutex);
      flags &= (0x00000001|0x00000002);
      for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));
      pUnused = *pp;
      if( pUnused ){
        *pp = pUnused->pNext;
      }
      sqlite3_mutex_leave(pInode->pLockMutex);
    }
  }
  unixLeaveMutex();

  return pUnused;
}




static int getFileMode(
  const char *zFile,
  mode_t *pMode,
  uid_t *pUid,
  gid_t *pGid
){
  struct stat sStat;
  int rc = 0;
  if( 0==((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zFile, &sStat) ){
    *pMode = sStat.st_mode & 0777;
    *pUid = sStat.st_uid;
    *pGid = sStat.st_gid;
  }else{
    rc = (10 | (7<<8));
  }
  return rc;
}
# 38533 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int findCreateFileMode(
  const char *zPath,
  int flags,
  mode_t *pMode,
  uid_t *pUid,
  gid_t *pGid
){
  int rc = 0;
  *pMode = 0;
  *pUid = 0;
  *pGid = 0;
  if( flags & (0x00080000|0x00000800) ){
    char zDb[512 +1];
    int nDb;
# 38560 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    nDb = sqlite3Strlen30(zPath) - 1;
    while( zPath[nDb]!='-' ){




      if( nDb==0 || zPath[nDb]=='.' ) return 0;
      nDb--;
    }
    memcpy(zDb, zPath, nDb);
    zDb[nDb] = '\0';

    rc = getFileMode(zDb, pMode, pUid, pGid);
  }else if( flags & 0x00000008 ){
    *pMode = 0600;
  }else if( flags & 0x00000040 ){




    const char *z = sqlite3_uri_parameter(zPath, "modeof");
    if( z ){
      rc = getFileMode(z, pMode, pUid, pGid);
    }
  }
  return rc;
}
# 38610 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixOpen(
  sqlite3_vfs *pVfs,
  const char *zPath,
  sqlite3_file *pFile,
  int flags,
  int *pOutFlags
){
  unixFile *p = (unixFile *)pFile;
  int fd = -1;
  int openFlags = 0;
  int eType = flags&0xFFFFFF00;
  int noLock;
  int rc = 0;
  int ctrlFlags = 0;

  int isExclusive = (flags & 0x00000010);
  int isDelete = (flags & 0x00000008);
  int isCreate = (flags & 0x00000004);
  int isReadonly = (flags & 0x00000001);
  int isReadWrite = (flags & 0x00000002);

  int isAutoProxy = (flags & 0x00000020);


  struct statfs fsInfo;






  int isNewJrnl = (isCreate && (
        eType==0x00004000
     || eType==0x00000800
     || eType==0x00080000
  ));




  char zTmpname[512 +2];
  const char *zName = zPath;
# 38660 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);



  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  ((void)0)



   ;






  if( randomnessPid!=(pid_t)getpid() ){
    randomnessPid = (pid_t)getpid();
    sqlite3_randomness(0,0);
  }
  memset(p, 0, sizeof(unixFile));

  if( eType==0x00000100 ){
    UnixUnusedFd *pUnused;
    pUnused = findReusableFd(zName, flags);
    if( pUnused ){
      fd = pUnused->fd;
    }else{
      pUnused = sqlite3_malloc64(sizeof(*pUnused));
      if( !pUnused ){
        return 7;
      }
    }
    p->pPreallocatedUnused = pUnused;




    ((void)0);

  }else if( !zName ){

    ((void)0);
    rc = unixGetTempname(pVfs->mxPathname, zTmpname);
    if( rc!=0 ){
      return rc;
    }
    zName = zTmpname;



    ((void)0);
  }





  if( isReadonly ) openFlags |= 
# 38726 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                0x0000
# 38726 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                        ;
  if( isReadWrite ) openFlags |= 
# 38727 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                0x0002
# 38727 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                      ;
  if( isCreate ) openFlags |= 
# 38728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                0x00000200
# 38728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                       ;
  if( isExclusive ) openFlags |= (
# 38729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                 0x00000800
# 38729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                       |
# 38729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                        0x00000100
# 38729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                  );
  openFlags |= (0|0);

  if( fd<0 ){
    mode_t openMode;
    uid_t uid;
    gid_t gid;
    rc = findCreateFileMode(zName, flags, &openMode, &uid, &gid);
    if( rc!=0 ){
      ((void)0);
      ((void)0);
      return rc;
    }
    fd = robust_open(zName, openFlags, openMode);
    ;
    ((void)0);
    if( fd<0 ){
      if( isNewJrnl && (*_errno())==13 && ((int(*)(const char*,int))aSyscall[2].pCurrent)(zName, 
# 38746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                       0
# 38746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                           ) ){


        rc = (8 | (6<<8));
      }else if( (*_errno())!=21 && isReadWrite ){

        flags &= ~(0x00000002|0x00000004);
        openFlags &= ~(
# 38753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                      0x0002
# 38753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            |
# 38753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                             0x00000200
# 38753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                    );
        flags |= 0x00000001;
        openFlags |= 
# 38755 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                    0x0000
# 38755 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                            ;
        isReadonly = 1;
        fd = robust_open(zName, openFlags, openMode);
      }
    }
    if( fd<0 ){
      int rc2 = unixLogErrorAtLine(sqlite3CantopenError(38761),"open",zName,38761);
      if( rc==0 ) rc = rc2;
      goto open_finished;
    }
# 38778 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( openMode && (flags & (0x00080000|0x00000800))!=0 ){
      robustFchown(fd, uid, gid);
    }
  }
  ((void)0);
  if( pOutFlags ){
    *pOutFlags = flags;
  }

  if( p->pPreallocatedUnused ){
    p->pPreallocatedUnused->fd = fd;
    p->pPreallocatedUnused->flags =
                          flags & (0x00000001|0x00000002);
  }

  if( isDelete ){
# 38803 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((int(*)(const char*))aSyscall[16].pCurrent)(zName);

  }

  else{
    p->openFlags = openFlags;
  }



  if( fstatfs(fd, &fsInfo) == -1 ){
    storeLastErrno(p, (*_errno()));
    robust_close(p, fd, 38815);
    return (10 | (13<<8));
  }
  if (0 == strncmp("msdos", fsInfo.f_fstypename, 5)) {
    ((unixFile*)pFile)->fsFlags |= 0x1;
  }
  if (0 == strncmp("exfat", fsInfo.f_fstypename, 5)) {
    ((unixFile*)pFile)->fsFlags |= 0x1;
  }



  if( isDelete ) ctrlFlags |= 0x20;
  if( isReadonly ) ctrlFlags |= 0x02;
  noLock = eType!=0x00000100;
  if( noLock ) ctrlFlags |= 0x80;
  if( isNewJrnl ) ctrlFlags |= 0x08;
  if( flags & 0x00000040 ) ctrlFlags |= 0x40;





  if( isAutoProxy && (zPath!=((void *)0)) && (!noLock) && pVfs->xOpen ){
    char *envforce = getenv("SQLITE_FORCE_PROXY_LOCKING");
    int useProxy = 0;



    if( envforce!=((void *)0) ){
      useProxy = atoi(envforce)>0;
    }else{
      useProxy = !(fsInfo.f_flags&
# 38847 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                 0x00001000
# 38847 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                          );
    }
    if( useProxy ){
      rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);
      if( rc==0 ){
        rc = proxyTransformUnixFile((unixFile*)pFile, ":auto:");
        if( rc!=0 ){




          unixClose(pFile);
          return rc;
        }
      }
      goto open_finished;
    }
  }


  ((void)0)

   ;
  rc = fillInUnixFile(pVfs, fd, pFile, zPath, ctrlFlags);

open_finished:
  if( rc!=0 ){
    sqlite3_free(p->pPreallocatedUnused);
  }
  return rc;
}






static int unixDelete(
  sqlite3_vfs *NotUsed,
  const char *zPath,
  int dirSync
){
  int rc = 0;
  (void)(NotUsed);
  ;
  if( ((int(*)(const char*))aSyscall[16].pCurrent)(zPath)==(-1) ){
    if( (*_errno())==2



    ){
      rc = (10 | (23<<8));
    }else{
      rc = unixLogErrorAtLine((10 | (10<<8)),"unlink",zPath,38900);
    }
    return rc;
  }

  if( (dirSync & 1)!=0 ){
    int fd;
    rc = ((int(*)(const char*,int*))aSyscall[17].pCurrent)(zPath, &fd);
    if( rc==0 ){
      if( full_fsync(fd,0,0) ){
        rc = unixLogErrorAtLine((10 | (5<<8)),"fsync",zPath,38910);
      }
      robust_close(0, fd, 38912);
    }else{
      ((void)0);
      rc = 0;
    }
  }

  return rc;
}
# 38932 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixAccess(
  sqlite3_vfs *NotUsed,
  const char *zPath,
  int flags,
  int *pResOut
){
  (void)(NotUsed);
  ;
  ((void)0);



  ((void)0);

  if( flags==0 ){
    struct stat buf;
    *pResOut = (0==((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(zPath, &buf) && buf.st_size>0);
  }else{
    *pResOut = ((int(*)(const char*,int))aSyscall[2].pCurrent)(zPath, 
# 38950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                              (1<<1)
# 38950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                  |
# 38950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                   (1<<2)
# 38950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                       )==0;
  }
  return 0;
}




static int mkFullPathname(
  const char *zPath,
  char *zOut,
  int nOut
){
  int nPath = sqlite3Strlen30(zPath);
  int iOff = 0;
  if( zPath[0]!='/' ){
    if( ((char*(*)(char*,size_t))aSyscall[3].pCurrent)(zOut, nOut-2)==0 ){
      return unixLogErrorAtLine(sqlite3CantopenError(38967),"getcwd",zPath,38967);
    }
    iOff = sqlite3Strlen30(zOut);
    zOut[iOff++] = '/';
  }
  if( (iOff+nPath+1)>nOut ){


    zOut[iOff] = '\0';
    return sqlite3CantopenError(38976);
  }
  sqlite3_snprintf(nOut-iOff, &zOut[iOff], "%s", zPath);
  return 0;
}
# 38991 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixFullPathname(
  sqlite3_vfs *pVfs,
  const char *zPath,
  int nOut,
  char *zOut
){



  int rc = 0;
  int nByte;
  int nLink = 1;
  const char *zIn = zPath;
  char *zDel = 0;

  ((void)0);
  (void)(pVfs);






  ;

  do {



    int bLink = 0;
    struct stat buf;
    if( ((int(*)(const char*,struct stat*))aSyscall[27].pCurrent)(zIn, &buf)!=0 ){
      if( (*_errno())!=2 ){
        rc = unixLogErrorAtLine(sqlite3CantopenError(39024),"lstat",zIn,39024);
      }
    }else{
      bLink = 
# 39027 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
             (((
# 39027 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
             buf.st_mode
# 39027 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
             ) & 0170000) == 0120000)
# 39027 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                 ;
    }

    if( bLink ){
      if( zDel==0 ){
        zDel = sqlite3_malloc(nOut);
        if( zDel==0 ) rc = 7;
      }else if( ++nLink>100 ){
        rc = sqlite3CantopenError(39035);
      }

      if( rc==0 ){
        nByte = ((ssize_t(*)(const char*,char*,size_t))aSyscall[26].pCurrent)(zIn, zDel, nOut-1);
        if( nByte<0 ){
          rc = unixLogErrorAtLine(sqlite3CantopenError(39041),"readlink",zIn,39041);
        }else{
          if( zDel[0]!='/' ){
            int n;
            for(n = sqlite3Strlen30(zIn); n>0 && zIn[n-1]!='/'; n--);
            if( nByte+n+1>nOut ){
              rc = sqlite3CantopenError(39047);
            }else{
              memmove(&zDel[n], zDel, nByte+1);
              memcpy(zDel, zIn, n);
              nByte += n;
            }
          }
          zDel[nByte] = '\0';
        }
      }

      zIn = zDel;
    }

    ((void)0);
    if( rc==0 && zIn!=zOut ){
      rc = mkFullPathname(zIn, zOut, nOut);
    }
    if( bLink==0 ) break;
    zIn = zOut;
  }while( rc==0 );

  sqlite3_free(zDel);
  return rc;

}







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/dlfcn.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/dlfcn.h" 3 4
#define _DLFCN_H_ 
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/dlfcn.h" 3 4
# 1 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdbool.h" 1 3 4
# 9 "/Users/tamofplease/Workspace/research/docker-exp/workspace/includes/stdbool.h" 3 4
#define _STDBOOL 

#define __bool_true_false_are_defined 1



#define bool _Bool
#define false 0
#define true 1
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/dlfcn.h" 2 3 4



#define __DYLDDL_DRIVERKIT_UNAVAILABLE __API_UNAVAILABLE(driverkit)








# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX12.sdk/usr/include/dlfcn.h" 3 4
typedef struct dl_info {
        const char *dli_fname;
        void *dli_fbase;
        const char *dli_sname;
        void *dli_saddr;
} Dl_info;

extern int dladdr(const void *, Dl_info *);




extern int dlclose(void * __handle) ;
extern char * dlerror(void) ;
extern void * dlopen(const char * __path, int __mode) ;
extern void * dlsym(void * __handle, const char * __symbol) ;


extern _Bool dlopen_preflight(const char* __path) ;



#define RTLD_LAZY 0x1
#define RTLD_NOW 0x2
#define RTLD_LOCAL 0x4
#define RTLD_GLOBAL 0x8


#define RTLD_NOLOAD 0x10
#define RTLD_NODELETE 0x80
#define RTLD_FIRST 0x100




#define RTLD_NEXT ((void *) -1)
#define RTLD_DEFAULT ((void *) -2)
#define RTLD_SELF ((void *) -3)
#define RTLD_MAIN_ONLY ((void *) -5)
# 39081 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 2

# 39081 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){
  (void)(NotUsed);
  return dlopen(zFilename, 
# 39083 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                          0x2 
# 39083 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                   | 
# 39083 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                     0x8
# 39083 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                );
}
# 39093 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){
  const char *zErr;
  (void)(NotUsed);
  unixEnterMutex();
  zErr = dlerror();
  if( zErr ){
    sqlite3_snprintf(nBuf, zBufOut, "%s", zErr);
  }
  unixLeaveMutex();
}
static void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){
# 39121 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  void (*(*x)(void*,const char*))(void);
  (void)(NotUsed);
  x = (void(*(*)(void*,const char*))(void))dlsym;
  return (*x)(p, zSym);
}
static void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){
  (void)(NotUsed);
  dlclose(pHandle);
}
# 39140 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){
  (void)(NotUsed);
  ((void)0);
# 39156 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  memset(zBuf, 0, nBuf);
  randomnessPid = (pid_t)getpid();

  {
    int fd, got;
    fd = robust_open("/dev/urandom", 
# 39161 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                    0x0000
# 39161 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                            , 0);
    if( fd<0 ){
      time_t t;
      time(&t);
      memcpy(zBuf, &t, sizeof(t));
      memcpy(&zBuf[sizeof(t)], &randomnessPid, sizeof(randomnessPid));
      ((void)0);
      nBuf = sizeof(t) + sizeof(randomnessPid);
    }else{
      do{ got = ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)(fd, zBuf, nBuf); }while( got<0 && (*_errno())==4 );
      robust_close(0, fd, 39171);
    }
  }

  return nBuf;
}
# 39187 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixSleep(sqlite3_vfs *NotUsed, int microseconds){
# 39201 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  int seconds = (microseconds+999999)/1000000;
  sleep(seconds);
  (void)(NotUsed);
  return seconds*1000000;

}
# 39227 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){
  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;
  int rc = 0;
# 39239 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  struct timeval sNow;
  (void)gettimeofday(&sNow, 0);
  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;







  (void)(NotUsed);
  return rc;
}







static int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){
  sqlite3_int64 i = 0;
  int rc;
  (void)(NotUsed);
  rc = unixCurrentTimeInt64(0, &i);
  *prNow = i/86400000.0;
  return rc;
}
# 39277 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){
  (void)(NotUsed);
  (void)(NotUsed2);
  (void)(NotUsed3);
  return (*_errno());
}
# 39448 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct proxyLockingContext proxyLockingContext;
struct proxyLockingContext {
  unixFile *conchFile;
  char *conchFilePath;
  unixFile *lockProxy;
  char *lockProxyPath;
  char *dbPath;
  int conchHeld;
  int nFails;
  void *oldLockingContext;
  sqlite3_io_methods const *pOldMethod;
};






static int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){
  int len;
  int dbLen;
  int i;





  {
    if( !confstr(
# 39476 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                65537
# 39476 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                        , lPath, maxLen) ){
     
                                          ;
      return (10 | (15<<8));
    }
    len = strlcat(lPath, "sqliteplocks", maxLen);
  }





  if( lPath[len-1]!='/' ){
    len = strlcat(lPath, "/", maxLen);
  }


  dbLen = (int)strlen(dbPath);
  for( i=0; i<dbLen && (i+len+7)<(int)maxLen; i++){
    char c = dbPath[i];
    lPath[i+len] = (c=='/')?'_':c;
  }
  lPath[i+len]='\0';
  strlcat(lPath, ":auto:", maxLen);
  ;
  return 0;
}




static int proxyCreateLockPath(const char *lockPath){
  int i, len;
  char buf[
# 39509 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
          1024
# 39509 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                    ];
  int start = 0;

  ((void)0);

  len = (int)strlen(lockPath);
  buf[0] = lockPath[0];
  for( i=1; i<len; i++ ){
    if( lockPath[i] == '/' && (i - start > 0) ){

      if( i-start>2 || (i-start==1 && buf[start] != '.' && buf[start] != '/')
         || (i-start==2 && buf[start] != '.' && buf[start+1] != '.') ){
        buf[i]='\0';
        if( ((int(*)(const char*,mode_t))aSyscall[18].pCurrent)(buf, 0755) ){
          int err=(*_errno());
          if( err!=17 ) {
           

                                                                ;
            return err;
          }
        }
      }
      start=i+1;
    }
    buf[i] = lockPath[i];
  }
  ;
  return 0;
}
# 39547 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyCreateUnixFile(
    const char *path,
    unixFile **ppFile,
    int islockfile
) {
  int fd = -1;
  unixFile *pNew;
  int rc = 0;
  int openFlags = 
# 39555 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 0x0002 
# 39555 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        | 
# 39555 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                          0x00000200
# 39555 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                 ;
  sqlite3_vfs dummyVfs;
  int terrno = 0;
  UnixUnusedFd *pUnused = ((void *)0);







  pUnused = findReusableFd(path, openFlags);
  if( pUnused ){
    fd = pUnused->fd;
  }else{
    pUnused = sqlite3_malloc64(sizeof(*pUnused));
    if( !pUnused ){
      return 7;
    }
  }
  if( fd<0 ){
    fd = robust_open(path, openFlags, 0);
    terrno = (*_errno());
    if( fd<0 && (*_errno())==2 && islockfile ){
      if( proxyCreateLockPath(path) == 0 ){
        fd = robust_open(path, openFlags, 0);
      }
    }
  }
  if( fd<0 ){
    openFlags = 
# 39585 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
               0x0000
# 39585 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                       ;
    fd = robust_open(path, openFlags, 0);
    terrno = (*_errno());
  }
  if( fd<0 ){
    if( islockfile ){
      return 5;
    }
    switch (terrno) {
      case 13:
        return 3;
      case 5:
        return (10 | (15<<8));
      default:
        return sqlite3CantopenError(39599);
    }
  }

  pNew = (unixFile *)sqlite3_malloc64(sizeof(*pNew));
  if( pNew==((void *)0) ){
    rc = 7;
    goto end_create_proxy;
  }
  memset(pNew, 0, sizeof(unixFile));
  pNew->openFlags = openFlags;
  memset(&dummyVfs, 0, sizeof(dummyVfs));
  dummyVfs.pAppData = (void*)&autolockIoFinder;
  dummyVfs.zName = "dummy";
  pUnused->fd = fd;
  pUnused->flags = openFlags;
  pNew->pPreallocatedUnused = pUnused;

  rc = fillInUnixFile(&dummyVfs, fd, (sqlite3_file*)pNew, path, 0);
  if( rc==0 ){
    *ppFile = pNew;
    return 0;
  }
end_create_proxy:
  robust_close(pNew, fd, 39623);
  sqlite3_free(pNew);
  sqlite3_free(pUnused);
  return rc;
}






#define PROXY_HOSTIDLEN 16



extern int gethostuuid(uuid_t id, const struct timespec *wait);





static int proxyGetHostID(unsigned char *pHostID, int *pError){
  ((void)0);
  memset(pHostID, 0, 16);

  {
    struct timespec timeout = {1, 0};
    if( gethostuuid(pHostID, &timeout) ){
      int err = (*_errno());
      if( pError ){
        *pError = err;
      }
      return 10;
    }
  }
# 39668 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return 0;
}



#define PROXY_CONCHVERSION 2
#define PROXY_HEADERLEN 1
#define PROXY_PATHINDEX (PROXY_HEADERLEN+PROXY_HOSTIDLEN)
#define PROXY_MAXCONCHLEN (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)







static int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){
  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
  unixFile *conchFile = pCtx->conchFile;
  char tPath[
# 39687 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
            1024
# 39687 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                      ];
  char buf[(1 +16 +
# 39688 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
          1024
# 39688 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          )];
  char *cPath = pCtx->conchFilePath;
  size_t readLen = 0;
  size_t pathLen = 0;
  char errmsg[64] = "";
  int fd = -1;
  int rc = -1;
  (void)(myHostID);


  pathLen = strlcpy(tPath, cPath, 
# 39698 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                 1024
# 39698 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                           );
  if( pathLen>
# 39699 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
             1024 
# 39699 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        || pathLen<6 ||
     (strlcpy(&tPath[pathLen-5], "break", 6) != 5) ){
    sqlite3_snprintf(sizeof(errmsg),errmsg,"path error (len %d)",(int)pathLen);
    goto end_breaklock;
  }

  readLen = ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)(conchFile->h, buf, (1 +16 +
# 39705 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                      1024
# 39705 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                      ), 0);
  if( readLen<(1 +16) ){
    sqlite3_snprintf(sizeof(errmsg),errmsg,"read error (len %d)",(int)readLen);
    goto end_breaklock;
  }

  fd = robust_open(tPath, (
# 39711 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                          0x0002
# 39711 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                |
# 39711 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                 0x00000200
# 39711 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                        |
# 39711 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                         0x00000800
# 39711 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                               ), 0);
  if( fd<0 ){
    sqlite3_snprintf(sizeof(errmsg), errmsg, "create failed (%d)", (*_errno()));
    goto end_breaklock;
  }
  if( ((ssize_t(*)(int,const void*,size_t,off_t)) aSyscall[12].pCurrent)(fd, buf, readLen, 0) != (ssize_t)readLen ){
    sqlite3_snprintf(sizeof(errmsg), errmsg, "write failed (%d)", (*_errno()));
    goto end_breaklock;
  }
  if( rename(tPath, cPath) ){
    sqlite3_snprintf(sizeof(errmsg), errmsg, "rename failed (%d)", (*_errno()));
    goto end_breaklock;
  }
  rc = 0;
  fprintf((__acrt_iob_func(2)), "broke stale lock on %s\n", cPath);
  robust_close(pFile, conchFile->h, 39726);
  conchFile->h = fd;
  conchFile->openFlags = 
# 39728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                        0x0002 
# 39728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                               | 
# 39728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                 0x00000200
# 39728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                        ;

end_breaklock:
  if( rc ){
    if( fd>=0 ){
      ((int(*)(const char*))aSyscall[16].pCurrent)(tPath);
      robust_close(pFile, fd, 39734);
    }
    fprintf((__acrt_iob_func(2)), "failed to break stale lock on %s, %s\n", cPath, errmsg);
  }
  return rc;
}




static int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){
  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
  unixFile *conchFile = pCtx->conchFile;
  int rc = 0;
  int nTries = 0;
  struct timespec conchModTime;

  memset(&conchModTime, 0, sizeof(conchModTime));
  do {
    rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
    nTries ++;
    if( rc==5 ){






      struct stat buf;
      if( ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(conchFile->h, &buf) ){
        storeLastErrno(pFile, (*_errno()));
        return (10 | (15<<8));
      }

      if( nTries==1 ){
        conchModTime = buf.st_mtimespec;
        usleep(500000);
        continue;
      }

      ((void)0);
      if( conchModTime.tv_sec != buf.st_mtimespec.tv_sec ||
         conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec ){
        return 5;
      }

      if( nTries==2 ){
        char tBuf[(1 +16 +
# 39781 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 1024
# 39781 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                 )];
        int len = ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)(conchFile->h, tBuf, (1 +16 +
# 39782 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                             1024
# 39782 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                             ), 0);
        if( len<0 ){
          storeLastErrno(pFile, (*_errno()));
          return (10 | (15<<8));
        }
        if( len>(1 +16) && tBuf[0]==(char)2){

          if( 0!=memcmp(&tBuf[1], myHostID, 16) ){
            return 5;
          }
        }else{

          return 5;
        }
        usleep(10000000);
        continue;
      }

      ((void)0);
      if( 0==proxyBreakConchLock(pFile, myHostID) ){
        rc = 0;
        if( lockType==4 ){
          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, 1);
        }
        if( !rc ){
          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);
        }
      }
    }
  } while( rc==5 && nTries<3 );

  return rc;
}







static int proxyTakeConch(unixFile *pFile){
  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;

  if( pCtx->conchHeld!=0 ){
    return 0;
  }else{
    unixFile *conchFile = pCtx->conchFile;
    uuid_t myHostID;
    int pError = 0;
    char readBuf[(1 +16 +
# 39831 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                1024
# 39831 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                )];
    char lockPath[
# 39832 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 1024
# 39832 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                           ];
    char *tempLockPath = ((void *)0);
    int rc = 0;
    int createConch = 0;
    int hostIdMatch = 0;
    int readLen = 0;
    int tryOldLockPath = 0;
    int forceNewLockPath = 0;

   

                          ;

    rc = proxyGetHostID(myHostID, &pError);
    if( (rc&0xff)==10 ){
      storeLastErrno(pFile, pError);
      goto end_takeconch;
    }
    rc = proxyConchLock(pFile, myHostID, 1);
    if( rc!=0 ){
      goto end_takeconch;
    }

    readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, (1 +16 +
# 39855 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                           1024
# 39855 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                           ));
    if( readLen<0 ){

      storeLastErrno(pFile, conchFile->lastErrno);
      rc = (10 | (1<<8));
      goto end_takeconch;
    }else if( readLen<=(1 +16) ||
             readBuf[0]!=(char)2 ){



      createConch = 1;
    }




    do {

      if( !createConch && !forceNewLockPath ){
        hostIdMatch = !memcmp(&readBuf[1], myHostID,
                                  16);

        if( !pCtx->lockProxyPath ){



          if( hostIdMatch ){
            size_t pathLen = (readLen - (1 +16));

            if( pathLen>=
# 39885 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                        1024 
# 39885 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                   ){
              pathLen=
# 39886 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                     1024
# 39886 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                               -1;
            }
            memcpy(lockPath, &readBuf[(1 +16)], pathLen);
            lockPath[pathLen] = 0;
            tempLockPath = lockPath;
            tryOldLockPath = 1;

            goto end_takeconch;
          }
        }else if( hostIdMatch
               && !strncmp(pCtx->lockProxyPath, &readBuf[(1 +16)],
                           readLen-(1 +16))
        ){

          goto end_takeconch;
        }
      }


      if( (conchFile->openFlags&
# 39905 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                               0x0002
# 39905 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                     ) == 0 ){
        rc = 5;
        goto end_takeconch;
      }


      if( !pCtx->lockProxyPath ){
        proxyGetLockPath(pCtx->dbPath, lockPath, 
# 39912 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                1024
# 39912 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                          );
        tempLockPath = lockPath;

      }





      futimes(conchFile->h, ((void *)0));
      if( hostIdMatch && !createConch ){
        if( conchFile->pInode && conchFile->pInode->nShared>1 ){


          rc = 5;
        } else {
          rc = proxyConchLock(pFile, myHostID, 4);
        }
      }else{
        rc = proxyConchLock(pFile, myHostID, 4);
      }
      if( rc==0 ){
        char writeBuffer[(1 +16 +
# 39934 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                        1024
# 39934 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                        )];
        int writeSize = 0;

        writeBuffer[0] = (char)2;
        memcpy(&writeBuffer[1], myHostID, 16);
        if( pCtx->lockProxyPath!=((void *)0) ){
          strlcpy(&writeBuffer[(1 +16)], pCtx->lockProxyPath,
                  
# 39941 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                 1024
# 39941 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                           );
        }else{
          strlcpy(&writeBuffer[(1 +16)], tempLockPath, 
# 39943 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                              1024
# 39943 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                                        );
        }
        writeSize = (1 +16) + strlen(&writeBuffer[(1 +16)]);
        robust_ftruncate(conchFile->h, writeSize);
        rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);
        full_fsync(conchFile->h,0,0);



        if( rc==0 && createConch ){
          struct stat buf;
          int err = ((int(*)(int,struct stat*))aSyscall[5].pCurrent)(pFile->h, &buf);
          if( err==0 ){
            mode_t cmode = buf.st_mode&(
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                       0000400
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                              |
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                               0000200 
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                       | 
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                         0000040
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                                |
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                                 0000020 
# 39956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                                         |
                                        
# 39957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                       0000004
# 39957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                              |
# 39957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                               0000002
# 39957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                      );


            ((int(*)(int,mode_t))aSyscall[14].pCurrent)(conchFile->h, cmode);
# 39977 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          }
        }
      }
      conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, 1);

    end_takeconch:
      ;
      if( rc==0 && pFile->openFlags ){
        int fd;
        if( pFile->h>=0 ){
          robust_close(pFile, pFile->h, 39987);
        }
        pFile->h = -1;
        fd = robust_open(pCtx->dbPath, pFile->openFlags, 0);
        ;
        if( fd>=0 ){
          pFile->h = fd;
        }else{
          rc=sqlite3CantopenError(39995);

        }
      }
      if( rc==0 && !pCtx->lockProxy ){
        char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;
        rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);
        if( rc!=0 && rc!=7 && tryOldLockPath ){



          forceNewLockPath = 1;
          tryOldLockPath = 0;
          continue;
        }
      }
      if( rc==0 ){



        if( tempLockPath ){
          pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);
          if( !pCtx->lockProxyPath ){
            rc = 7;
          }
        }
      }
      if( rc==0 ){
        pCtx->conchHeld = 1;

        if( pCtx->lockProxy->pMethod == &afpIoMethods ){
          afpLockingContext *afpCtx;
          afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;
          afpCtx->dbPath = pCtx->lockProxyPath;
        }
      } else {
        conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, 0);
      }
     
                                            ;
      return rc;
    } while (1);

  }
}




static int proxyReleaseConch(unixFile *pFile){
  int rc = 0;
  proxyLockingContext *pCtx;
  unixFile *conchFile;

  pCtx = (proxyLockingContext *)pFile->lockingContext;
  conchFile = pCtx->conchFile;
 

                        ;
  if( pCtx->conchHeld>0 ){
    rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, 0);
  }
  pCtx->conchHeld = 0;
 
                                              ;
  return rc;
}
# 40074 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyCreateConchPathname(char *dbPath, char **pConchPath){
  int i;
  int len = (int)strlen(dbPath);
  char *conchPath;



  *pConchPath = conchPath = (char *)sqlite3_malloc64(len + 8);
  if( conchPath==0 ){
    return 7;
  }
  memcpy(conchPath, dbPath, len+1);


  for( i=(len-1); i>=0; i-- ){
    if( conchPath[i]=='/' ){
      i++;
      break;
    }
  }
  conchPath[i]='.';
  while ( i<len ){
    conchPath[i+1]=dbPath[i];
    i++;
  }


  memcpy(&conchPath[i+1], "-conch", 7);
  ((void)0);

  return 0;
}





static int switchLockProxyPath(unixFile *pFile, const char *path) {
  proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;
  char *oldPath = pCtx->lockProxyPath;
  int rc = 0;

  if( pFile->eFileLock!=0 ){
    return 5;
  }


  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ||
    (oldPath && !strncmp(oldPath, path, 
# 40122 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                       1024
# 40122 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                 )) ){
    return 0;
  }else{
    unixFile *lockProxy = pCtx->lockProxy;
    pCtx->lockProxy=((void *)0);
    pCtx->conchHeld = 0;
    if( lockProxy!=((void *)0) ){
      rc=lockProxy->pMethod->xClose((sqlite3_file *)lockProxy);
      if( rc ) return rc;
      sqlite3_free(lockProxy);
    }
    sqlite3_free(oldPath);
    pCtx->lockProxyPath = sqlite3DbStrDup(0, path);
  }

  return rc;
}
# 40147 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){

  if( pFile->pMethod == &afpIoMethods ){


    ((void)0);
    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath,
            
# 40154 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
           1024
# 40154 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                     );
  } else

  if( pFile->pMethod == &dotlockIoMethods ){


    int len = strlen((char *)pFile->lockingContext) - strlen(".lock");
    memcpy(dbPath, (char *)pFile->lockingContext, len + 1);
  }else{

    ((void)0);
    strlcpy(dbPath, (char *)pFile->lockingContext, 
# 40165 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                  1024
# 40165 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                            );
  }
  return 0;
}
# 40178 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyTransformUnixFile(unixFile *pFile, const char *path) {
  proxyLockingContext *pCtx;
  char dbPath[
# 40180 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
             1024
# 40180 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                       +1];
  char *lockPath=((void *)0);
  int rc = 0;

  if( pFile->eFileLock!=0 ){
    return 5;
  }
  proxyGetDbPathForUnixFile(pFile, dbPath);
  if( !path || path[0]=='\0' || !strcmp(path, ":auto:") ){
    lockPath=((void *)0);
  }else{
    lockPath=(char *)path;
  }

 
                                                          ;

  pCtx = sqlite3_malloc64( sizeof(*pCtx) );
  if( pCtx==0 ){
    return 7;
  }
  memset(pCtx, 0, sizeof(*pCtx));

  rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);
  if( rc==0 ){
    rc = proxyCreateUnixFile(pCtx->conchFilePath, &pCtx->conchFile, 0);
    if( rc==14 && ((pFile->openFlags&
# 40206 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                 0x0002
# 40206 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                       ) == 0) ){





      struct statfs fsInfo;
      struct stat conchInfo;
      int goLockless = 0;

      if( ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)(pCtx->conchFilePath, &conchInfo) == -1 ) {
        int err = (*_errno());
        if( (err==2) && (statfs(dbPath, &fsInfo) != -1) ){
          goLockless = (fsInfo.f_flags&
# 40219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                      0x00000001
# 40219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                ) == 
# 40219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                     0x00000001
# 40219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                               ;
        }
      }
      if( goLockless ){
        pCtx->conchHeld = -1;
        rc = 0;
      }
    }
  }
  if( rc==0 && lockPath ){
    pCtx->lockProxyPath = sqlite3DbStrDup(0, lockPath);
  }

  if( rc==0 ){
    pCtx->dbPath = sqlite3DbStrDup(0, dbPath);
    if( pCtx->dbPath==((void *)0) ){
      rc = 7;
    }
  }
  if( rc==0 ){



    pCtx->oldLockingContext = pFile->lockingContext;
    pFile->lockingContext = pCtx;
    pCtx->pOldMethod = pFile->pMethod;
    pFile->pMethod = &proxyIoMethods;
  }else{
    if( pCtx->conchFile ){
      pCtx->conchFile->pMethod->xClose((sqlite3_file *)pCtx->conchFile);
      sqlite3_free(pCtx->conchFile);
    }
    sqlite3DbFree(0, pCtx->lockProxyPath);
    sqlite3_free(pCtx->conchFilePath);
    sqlite3_free(pCtx);
  }
 
                                              ;
  return rc;
}






static int proxyFileControl(sqlite3_file *id, int op, void *pArg){
  switch( op ){
    case 2: {
      unixFile *pFile = (unixFile*)id;
      if( pFile->pMethod == &proxyIoMethods ){
        proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;
        proxyTakeConch(pFile);
        if( pCtx->lockProxyPath ){
          *(const char **)pArg = pCtx->lockProxyPath;
        }else{
          *(const char **)pArg = ":auto: (not held)";
        }
      } else {
        *(const char **)pArg = ((void *)0);
      }
      return 0;
    }
    case 3: {
      unixFile *pFile = (unixFile*)id;
      int rc = 0;
      int isProxyStyle = (pFile->pMethod == &proxyIoMethods);
      if( pArg==((void *)0) || (const char *)pArg==0 ){
        if( isProxyStyle ){




          rc = 1 ;
        }else{

          rc = 0;
        }
      }else{
        const char *proxyPath = (const char *)pArg;
        if( isProxyStyle ){
          proxyLockingContext *pCtx =
            (proxyLockingContext*)pFile->lockingContext;
          if( !strcmp(pArg, ":auto:")
           || (pCtx->lockProxyPath &&
               !strncmp(pCtx->lockProxyPath, proxyPath, 
# 40304 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c" 3 4
                                                       1024
# 40304 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                                                 ))
          ){
            rc = 0;
          }else{
            rc = switchLockProxyPath(pFile, proxyPath);
          }
        }else{

          rc = proxyTransformUnixFile(pFile, proxyPath);
        }
      }
      return rc;
    }
    default: {
      ((void)0);
    }
  }
                 ((void)0);
  return 1;
}
# 40338 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {
  unixFile *pFile = (unixFile*)id;
  int rc = proxyTakeConch(pFile);
  if( rc==0 ){
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    if( pCtx->conchHeld>0 ){
      unixFile *proxy = pCtx->lockProxy;
      return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);
    }else{
      pResOut=0;
    }
  }
  return rc;
}
# 40377 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyLock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  int rc = proxyTakeConch(pFile);
  if( rc==0 ){
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    if( pCtx->conchHeld>0 ){
      unixFile *proxy = pCtx->lockProxy;
      rc = proxy->pMethod->xLock((sqlite3_file*)proxy, eFileLock);
      pFile->eFileLock = proxy->eFileLock;
    }else{

    }
  }
  return rc;
}
# 40401 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int proxyUnlock(sqlite3_file *id, int eFileLock) {
  unixFile *pFile = (unixFile*)id;
  int rc = proxyTakeConch(pFile);
  if( rc==0 ){
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    if( pCtx->conchHeld>0 ){
      unixFile *proxy = pCtx->lockProxy;
      rc = proxy->pMethod->xUnlock((sqlite3_file*)proxy, eFileLock);
      pFile->eFileLock = proxy->eFileLock;
    }else{

    }
  }
  return rc;
}




static int proxyClose(sqlite3_file *id) {
  if( (id) ){
    unixFile *pFile = (unixFile*)id;
    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;
    unixFile *lockProxy = pCtx->lockProxy;
    unixFile *conchFile = pCtx->conchFile;
    int rc = 0;

    if( lockProxy ){
      rc = lockProxy->pMethod->xUnlock((sqlite3_file*)lockProxy, 0);
      if( rc ) return rc;
      rc = lockProxy->pMethod->xClose((sqlite3_file*)lockProxy);
      if( rc ) return rc;
      sqlite3_free(lockProxy);
      pCtx->lockProxy = 0;
    }
    if( conchFile ){
      if( pCtx->conchHeld ){
        rc = proxyReleaseConch(pFile);
        if( rc ) return rc;
      }
      rc = conchFile->pMethod->xClose((sqlite3_file*)conchFile);
      if( rc ) return rc;
      sqlite3_free(conchFile);
    }
    sqlite3DbFree(0, pCtx->lockProxyPath);
    sqlite3_free(pCtx->conchFilePath);
    sqlite3DbFree(0, pCtx->dbPath);

    pFile->lockingContext = pCtx->oldLockingContext;
    pFile->pMethod = pCtx->pOldMethod;
    sqlite3_free(pCtx);
    return pFile->pMethod->xClose(id);
  }
  return 0;
}
# 40482 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_os_init(void){
# 40503 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define UNIXVFS(VFSNAME,FINDER) { 3, sizeof(unixFile), MAX_PATHNAME, 0, VFSNAME, (void*)&FINDER, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, }
# 40535 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  static sqlite3_vfs aVfs[] = {

    { 3, sizeof(unixFile), 512, 0, "unix", (void*)&autolockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },





    { 3, sizeof(unixFile), 512, 0, "unix-none", (void*)&nolockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-dotfile", (void*)&dotlockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-excl", (void*)&posixIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },




    { 3, sizeof(unixFile), 512, 0, "unix-posix", (void*)&posixIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },


    { 3, sizeof(unixFile), 512, 0, "unix-flock", (void*)&flockIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },


    { 3, sizeof(unixFile), 512, 0, "unix-afp", (void*)&afpIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-nfs", (void*)&nfsIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },
    { 3, sizeof(unixFile), 512, 0, "unix-proxy", (void*)&proxyIoFinder, unixOpen, unixDelete, unixAccess, unixFullPathname, unixDlOpen, unixDlError, unixDlSym, unixDlClose, unixRandomness, unixSleep, unixCurrentTime, unixGetLastError, unixCurrentTimeInt64, unixSetSystemCall, unixGetSystemCall, unixNextSystemCall, },

  };
  unsigned int i;



  ((void)0);


  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){
    sqlite3_vfs_register(&aVfs[i], i==0);
  }
  unixBigLock = sqlite3MutexAlloc(11);
  return 0;
}
# 40582 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_os_end(void){
  unixBigLock = 0;
  return 0;
}
# 47592 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BITVEC_SZ 512



#define BITVEC_USIZE (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))






#define BITVEC_TELEM u8

#define BITVEC_SZELEM 8

#define BITVEC_NELEM (BITVEC_USIZE/sizeof(BITVEC_TELEM))

#define BITVEC_NBIT (BITVEC_NELEM*BITVEC_SZELEM)


#define BITVEC_NINT (BITVEC_USIZE/sizeof(u32))


#define BITVEC_MXHASH (BITVEC_NINT/2)




#define BITVEC_HASH(X) (((X)*1)%BITVEC_NINT)

#define BITVEC_NPTR (BITVEC_USIZE/sizeof(Bitvec *))
# 47646 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Bitvec {
  u32 iSize;
  u32 nSet;


  u32 iDivisor;



  union {
    u8 aBitmap[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))];
    u32 aHash[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))];
    Bitvec *apSub[((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *))];
  } u;
};






static Bitvec *sqlite3BitvecCreate(u32 iSize){
  Bitvec *p;
  ((void)0);
  p = sqlite3MallocZero( sizeof(*p) );
  if( p ){
    p->iSize = iSize;
  }
  return p;
}






static int sqlite3BitvecTestNotNull(Bitvec *p, u32 i){
  ((void)0);
  i--;
  if( i>=p->iSize ) return 0;
  while( p->iDivisor ){
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return 0;
    }
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    return (p->u.aBitmap[i/8] & (1<<(i&(8 -1))))!=0;
  } else{
    u32 h = (((i++)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));
    while( p->u.aHash[h] ){
      if( p->u.aHash[h]==i ) return 1;
      h = (h+1) % ((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32));
    }
    return 0;
  }
}
static int sqlite3BitvecTest(Bitvec *p, u32 i){
  return p!=0 && sqlite3BitvecTestNotNull(p,i);
}
# 47721 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BitvecSet(Bitvec *p, u32 i){
  u32 h;
  if( p==0 ) return 0;
  ((void)0);
  ((void)0);
  i--;
  while((p->iSize > (((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8)) && p->iDivisor) {
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    if( p->u.apSub[bin]==0 ){
      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );
      if( p->u.apSub[bin]==0 ) return 7;
    }
    p = p->u.apSub[bin];
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    p->u.aBitmap[i/8] |= 1 << (i&(8 -1));
    return 0;
  }
  h = (((i++)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));



  if( !p->u.aHash[h] ){
    if (p->nSet<(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))-1)) {
      goto bitvec_set_end;
    } else {
      goto bitvec_set_rehash;
    }
  }


  do {
    if( p->u.aHash[h]==i ) return 0;
    h++;
    if( h>=((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;
  } while( p->u.aHash[h] );



bitvec_set_rehash:
  if( p->nSet>=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32))/2) ){
    unsigned int j;
    int rc;
    u32 *aiValues = sqlite3DbMallocRaw(0,sizeof(p->u.aHash));
    if( aiValues==0 ){
      return 7;
    }else{
      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
      memset(p->u.apSub, 0, sizeof(p->u.apSub));
      p->iDivisor = (p->iSize + ((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *)) - 1)/((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *));
      rc = sqlite3BitvecSet(p, i);
      for(j=0; j<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)); j++){
        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);
      }
      sqlite3DbFree(0,aiValues);
      return rc;
    }
  }
bitvec_set_end:
  p->nSet++;
  p->u.aHash[h] = i;
  return 0;
}







static void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){
  if( p==0 ) return;
  ((void)0);
  i--;
  while( p->iDivisor ){
    u32 bin = i/p->iDivisor;
    i = i%p->iDivisor;
    p = p->u.apSub[bin];
    if (!p) {
      return;
    }
  }
  if( p->iSize<=(((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u8))*8) ){
    p->u.aBitmap[i/8] &= ~(1 << (i&(8 -1)));
  }else{
    unsigned int j;
    u32 *aiValues = pBuf;
    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));
    memset(p->u.aHash, 0, sizeof(p->u.aHash));
    p->nSet = 0;
    for(j=0; j<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)); j++){
      if( aiValues[j] && aiValues[j]!=(i+1) ){
        u32 h = (((aiValues[j]-1)*1)%((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)));
        p->nSet++;
        while( p->u.aHash[h] ){
          h++;
          if( h>=((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(u32)) ) h = 0;
        }
        p->u.aHash[h] = aiValues[j];
      }
    }
  }
}




static void sqlite3BitvecDestroy(Bitvec *p){
  if( p==0 ) return;
  if( p->iDivisor ){
    unsigned int i;
    for(i=0; i<((((512 -(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))/sizeof(Bitvec *)); i++){
      sqlite3BitvecDestroy(p->u.apSub[i]);
    }
  }
  sqlite3_free(p);
}





static u32 sqlite3BitvecSize(Bitvec *p){
  return p->iSize;
}
# 47855 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SETBIT(V,I) V[I>>3] |= (1<<(I&7))
#define CLEARBIT(V,I) V[I>>3] &= ~(1<<(I&7))
#define TESTBIT(V,I) (V[I>>3]&(1<<(I&7)))!=0
# 47889 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BitvecBuiltinTest(int sz, int *aOp){
  Bitvec *pBitvec = 0;
  unsigned char *pV = 0;
  int rc = -1;
  int i, nx, pc, op;
  void *pTmpSpace;



  pBitvec = sqlite3BitvecCreate( sz );
  pV = sqlite3MallocZero( (sz+7)/8 + 1 );
  pTmpSpace = sqlite3_malloc64(512);
  if( pBitvec==0 || pV==0 || pTmpSpace==0 ) goto bitvec_end;


  sqlite3BitvecSet(0, 1);
  sqlite3BitvecClear(0, 1, pTmpSpace);


  pc = 0;
  while( (op = aOp[pc])!=0 ){
    switch( op ){
      case 1:
      case 2:
      case 5: {
        nx = 4;
        i = aOp[pc+2] - 1;
        aOp[pc+2] += aOp[pc+3];
        break;
      }
      case 3:
      case 4:
      default: {
        nx = 2;
        sqlite3_randomness(sizeof(i), &i);
        break;
      }
    }
    if( (--aOp[pc+1]) > 0 ) nx = 0;
    pc += nx;
    i = (i & 0x7fffffff)%sz;
    if( (op & 1)!=0 ){
      pV[(i+1)>>3] |= (1<<((i+1)&7));
      if( op!=5 ){
        if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;
      }
    }else{
      pV[(i+1)>>3] &= ~(1<<((i+1)&7));
      sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);
    }
  }






  rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)
          + sqlite3BitvecTest(pBitvec, 0)
          + (sqlite3BitvecSize(pBitvec) - sz);
  for(i=1; i<=sz; i++){
    if( ((pV[i>>3]&(1<<(i&7)))!=0)!=sqlite3BitvecTest(pBitvec,i) ){
      rc = i;
      break;
    }
  }


bitvec_end:
  sqlite3_free(pTmpSpace);
  sqlite3_free(pV);
  sqlite3BitvecDestroy(pBitvec);
  return rc;
}
# 48007 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct PCache {
  PgHdr *pDirty, *pDirtyTail;
  PgHdr *pSynced;
  int nRefSum;
  int szCache;
  int szSpill;
  int szPage;
  int szExtra;
  u8 bPurgeable;
  u8 eCreate;
  int (*xStress)(void*,PgHdr*);
  void *pStress;
  sqlite3_pcache *pCache;
};
# 48060 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define pcacheTrace(X) 
#define pcacheDump(X) 
# 48114 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PCACHE_DIRTYLIST_REMOVE 1
#define PCACHE_DIRTYLIST_ADD 2
#define PCACHE_DIRTYLIST_FRONT 3







static void pcacheManageDirtyList(PgHdr *pPage, u8 addRemove){
  PCache *p = pPage->pCache;

 

                             ;
  if( addRemove & 1 ){
    ((void)0);
    ((void)0);


    if( p->pSynced==pPage ){
      p->pSynced = pPage->pDirtyPrev;
    }

    if( pPage->pDirtyNext ){
      pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;
    }else{
      ((void)0);
      p->pDirtyTail = pPage->pDirtyPrev;
    }
    if( pPage->pDirtyPrev ){
      pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;
    }else{




      ((void)0);
      p->pDirty = pPage->pDirtyNext;
      ((void)0);
      if( p->pDirty==0 ){
        ((void)0);
        p->eCreate = 2;
      }
    }
  }
  if( addRemove & 2 ){
    pPage->pDirtyPrev = 0;
    pPage->pDirtyNext = p->pDirty;
    if( pPage->pDirtyNext ){
      ((void)0);
      pPage->pDirtyNext->pDirtyPrev = pPage;
    }else{
      p->pDirtyTail = pPage;
      if( p->bPurgeable ){
        ((void)0);
        p->eCreate = 1;
      }
    }
    p->pDirty = pPage;






    if( !p->pSynced
     && 0==(pPage->flags&0x008)
    ){
      p->pSynced = pPage;
    }
  }
  ;
}





static void pcacheUnpin(PgHdr *p){
  if( p->pCache->bPurgeable ){
    ;
    sqlite3Config.pcache2.xUnpin(p->pCache->pCache, p->pPage, 0);
    ;
  }
}





static int numberOfCachePages(PCache *p){
  if( p->szCache>=0 ){


    return p->szCache;
  }else{




    return (int)((-1024*(i64)p->szCache)/(p->szPage+p->szExtra));
  }
}






static int sqlite3PcacheInitialize(void){
  if( sqlite3Config.pcache2.xInit==0 ){



    sqlite3PCacheSetDefault();
    ((void)0);
  }
  return sqlite3Config.pcache2.xInit(sqlite3Config.pcache2.pArg);
}
static void sqlite3PcacheShutdown(void){
  if( sqlite3Config.pcache2.xShutdown ){

    sqlite3Config.pcache2.xShutdown(sqlite3Config.pcache2.pArg);
  }
}




static int sqlite3PcacheSize(void){ return sizeof(PCache); }
# 48259 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PcacheOpen(
  int szPage,
  int szExtra,
  int bPurgeable,
  int (*xStress)(void*,PgHdr*),
  void *pStress,
  PCache *p
){
  memset(p, 0, sizeof(PCache));
  p->szPage = 1;
  p->szExtra = szExtra;
  ((void)0);
  p->bPurgeable = bPurgeable;
  p->eCreate = 2;
  p->xStress = xStress;
  p->pStress = pStress;
  p->szCache = 100;
  p->szSpill = 1;
  ;
  return sqlite3PcacheSetPageSize(p, szPage);
}





static int sqlite3PcacheSetPageSize(PCache *pCache, int szPage){
  ((void)0);
  if( pCache->szPage ){
    sqlite3_pcache *pNew;
    pNew = sqlite3Config.pcache2.xCreate(
                szPage, pCache->szExtra + (((sizeof(PgHdr))+7)&~7),
                pCache->bPurgeable
    );
    if( pNew==0 ) return 7;
    sqlite3Config.pcache2.xCachesize(pNew, numberOfCachePages(pCache));
    if( pCache->pCache ){
      sqlite3Config.pcache2.xDestroy(pCache->pCache);
    }
    pCache->pCache = pNew;
    pCache->szPage = szPage;
    ;
  }
  return 0;
}
# 48329 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_pcache_page *sqlite3PcacheFetch(
  PCache *pCache,
  Pgno pgno,
  int createFlag
){
  int eCreate;
  sqlite3_pcache_page *pRes;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
# 48349 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  eCreate = createFlag & pCache->eCreate;
  ((void)0);
  ((void)0);
  ((void)0);
  pRes = sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, eCreate);
 
                                             ;
  return pRes;
}
# 48370 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PcacheFetchStress(
  PCache *pCache,
  Pgno pgno,
  sqlite3_pcache_page **ppPage
){
  PgHdr *pPg;
  if( pCache->eCreate==2 ) return 0;

  if( sqlite3PcachePagecount(pCache)>pCache->szSpill ){
# 48388 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    for(pPg=pCache->pSynced;
        pPg && (pPg->nRef || (pPg->flags&0x008));
        pPg=pPg->pDirtyPrev
    );
    pCache->pSynced = pPg;
    if( !pPg ){
      for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);
    }
    if( pPg ){
      int rc;







      ;
      rc = pCache->xStress(pCache->pStress, pPg);
      ;
      if( rc!=0 && rc!=5 ){
        return rc;
      }
    }
  }
  *ppPage = sqlite3Config.pcache2.xFetch(pCache->pCache, pgno, 2);
  return *ppPage==0 ? 7 : 0;
}
# 48426 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) PgHdr *pcacheFetchFinishWithInit(
  PCache *pCache,
  Pgno pgno,
  sqlite3_pcache_page *pPage
){
  PgHdr *pPgHdr;
  ((void)0);
  pPgHdr = (PgHdr*)pPage->pExtra;
  ((void)0);
  memset(&pPgHdr->pDirty, 0, sizeof(PgHdr) - __builtin_offsetof(PgHdr,pDirty));
  pPgHdr->pPage = pPage;
  pPgHdr->pData = pPage->pBuf;
  pPgHdr->pExtra = (void *)&pPgHdr[1];
  memset(pPgHdr->pExtra, 0, 8);
  pPgHdr->pCache = pCache;
  pPgHdr->pgno = pgno;
  pPgHdr->flags = 0x001;
  return sqlite3PcacheFetchFinish(pCache,pgno,pPage);
}







static PgHdr *sqlite3PcacheFetchFinish(
  PCache *pCache,
  Pgno pgno,
  sqlite3_pcache_page *pPage
){
  PgHdr *pPgHdr;

  ((void)0);
  pPgHdr = (PgHdr *)pPage->pExtra;

  if( !pPgHdr->pPage ){
    return pcacheFetchFinishWithInit(pCache, pgno, pPage);
  }
  pCache->nRefSum++;
  pPgHdr->nRef++;
  ((void)0);
  return pPgHdr;
}





static void __attribute__((noinline)) sqlite3PcacheRelease(PgHdr *p){
  ((void)0);
  p->pCache->nRefSum--;
  if( (--p->nRef)==0 ){
    if( p->flags&0x001 ){
      pcacheUnpin(p);
    }else{
      pcacheManageDirtyList(p, 3);
    }
  }
}




static void sqlite3PcacheRef(PgHdr *p){
  ((void)0);
  ((void)0);
  p->nRef++;
  p->pCache->nRefSum++;
}






static void sqlite3PcacheDrop(PgHdr *p){
  ((void)0);
  ((void)0);
  if( p->flags&0x002 ){
    pcacheManageDirtyList(p, 1);
  }
  p->pCache->nRefSum--;
  sqlite3Config.pcache2.xUnpin(p->pCache->pCache, p->pPage, 1);
}





static void sqlite3PcacheMakeDirty(PgHdr *p){
  ((void)0);
  ((void)0);
  if( p->flags & (0x001|0x010) ){
    p->flags &= ~0x010;
    if( p->flags & 0x001 ){
      p->flags ^= (0x002|0x001);
      ;
      ((void)0);
      pcacheManageDirtyList(p, 2);
    }
    ((void)0);
  }
}





static void sqlite3PcacheMakeClean(PgHdr *p){
  ((void)0);
  ((void)0);
  ((void)0);
  pcacheManageDirtyList(p, 1);
  p->flags &= ~(0x002|0x008|0x004);
  p->flags |= 0x001;
  ;
  ((void)0);
  if( p->nRef==0 ){
    pcacheUnpin(p);
  }
}




static void sqlite3PcacheCleanAll(PCache *pCache){
  PgHdr *p;
  ;
  while( (p = pCache->pDirty)!=0 ){
    sqlite3PcacheMakeClean(p);
  }
}




static void sqlite3PcacheClearWritable(PCache *pCache){
  PgHdr *p;
  ;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->flags &= ~(0x008|0x004);
  }
  pCache->pSynced = pCache->pDirtyTail;
}




static void sqlite3PcacheClearSyncFlags(PCache *pCache){
  PgHdr *p;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->flags &= ~0x008;
  }
  pCache->pSynced = pCache->pDirtyTail;
}




static void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){
  PCache *pCache = p->pCache;
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  sqlite3Config.pcache2.xRekey(pCache->pCache, p->pPage, p->pgno,newPgno);
  p->pgno = newPgno;
  if( (p->flags&0x002) && (p->flags&0x008) ){
    pcacheManageDirtyList(p, 3);
  }
}
# 48608 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){
  if( pCache->pCache ){
    PgHdr *p;
    PgHdr *pNext;
    ;
    for(p=pCache->pDirty; p; p=pNext){
      pNext = p->pDirtyNext;




      ((void)0);
      if( p->pgno>pgno ){
        ((void)0);
        sqlite3PcacheMakeClean(p);
      }
    }
    if( pgno==0 && pCache->nRefSum ){
      sqlite3_pcache_page *pPage1;
      pPage1 = sqlite3Config.pcache2.xFetch(pCache->pCache,1,0);
      if( (pPage1) ){

        memset(pPage1->pBuf, 0, pCache->szPage);
        pgno = 1;
      }
    }
    sqlite3Config.pcache2.xTruncate(pCache->pCache, pgno+1);
  }
}




static void sqlite3PcacheClose(PCache *pCache){
  ((void)0);
  ;
  sqlite3Config.pcache2.xDestroy(pCache->pCache);
}




static void sqlite3PcacheClear(PCache *pCache){
  sqlite3PcacheTruncate(pCache, 0);
}





static PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){
  PgHdr result, *pTail;
  pTail = &result;
  ((void)0);
  for(;;){
    if( pA->pgno<pB->pgno ){
      pTail->pDirty = pA;
      pTail = pA;
      pA = pA->pDirty;
      if( pA==0 ){
        pTail->pDirty = pB;
        break;
      }
    }else{
      pTail->pDirty = pB;
      pTail = pB;
      pB = pB->pDirty;
      if( pB==0 ){
        pTail->pDirty = pA;
        break;
      }
    }
  }
  return result.pDirty;
}
# 48694 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define N_SORT_BUCKET 32
static PgHdr *pcacheSortDirtyList(PgHdr *pIn){
  PgHdr *a[32], *p;
  int i;
  memset(a, 0, sizeof(a));
  while( pIn ){
    p = pIn;
    pIn = p->pDirty;
    p->pDirty = 0;
    for(i=0; (i<32 -1); i++){
      if( a[i]==0 ){
        a[i] = p;
        break;
      }else{
        p = pcacheMergeDirtyList(a[i], p);
        a[i] = 0;
      }
    }
    if( (i==32 -1) ){



      a[i] = pcacheMergeDirtyList(a[i], p);
    }
  }
  p = a[0];
  for(i=1; i<32; i++){
    if( a[i]==0 ) continue;
    p = p ? pcacheMergeDirtyList(p, a[i]) : a[i];
  }
  return p;
}




static PgHdr *sqlite3PcacheDirtyList(PCache *pCache){
  PgHdr *p;
  for(p=pCache->pDirty; p; p=p->pDirtyNext){
    p->pDirty = p->pDirtyNext;
  }
  return pcacheSortDirtyList(pCache->pDirty);
}







static int sqlite3PcacheRefCount(PCache *pCache){
  return pCache->nRefSum;
}




static int sqlite3PcachePageRefcount(PgHdr *p){
  return p->nRef;
}




static int sqlite3PcachePagecount(PCache *pCache){
  ((void)0);
  return sqlite3Config.pcache2.xPagecount(pCache->pCache);
}
# 48775 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){
  ((void)0);
  pCache->szCache = mxPage;
  sqlite3Config.pcache2.xCachesize(pCache->pCache,
                                         numberOfCachePages(pCache));
}






static int sqlite3PcacheSetSpillsize(PCache *p, int mxPage){
  int res;
  ((void)0);
  if( mxPage ){
    if( mxPage<0 ){
      mxPage = (int)((-1024*(i64)mxPage)/(p->szPage+p->szExtra));
    }
    p->szSpill = mxPage;
  }
  res = numberOfCachePages(p);
  if( res<p->szSpill ) res = p->szSpill;
  return res;
}




static void sqlite3PcacheShrink(PCache *pCache){
  ((void)0);
  sqlite3Config.pcache2.xShrink(pCache->pCache);
}





static int sqlite3HeaderSizePcache(void){ return (((sizeof(PgHdr))+7)&~7); }





static int sqlite3PCachePercentDirty(PCache *pCache){
  PgHdr *pDirty;
  int nDirty = 0;
  int nCache = numberOfCachePages(pCache);
  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext) nDirty++;
  return nCache ? (int)(((i64)nDirty * 100) / nCache) : 0;
}
# 48936 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct PCache1 PCache1;
typedef struct PgHdr1 PgHdr1;
typedef struct PgFreeslot PgFreeslot;
typedef struct PGroup PGroup;
# 48957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct PgHdr1 {
  sqlite3_pcache_page page;
  unsigned int iKey;
  u16 isBulkLocal;
  u16 isAnchor;
  PgHdr1 *pNext;
  PCache1 *pCache;
  PgHdr1 *pLruNext;
  PgHdr1 *pLruPrev;

};





#define PAGE_IS_PINNED(p) ((p)->pLruNext==0)
#define PAGE_IS_UNPINNED(p) ((p)->pLruNext!=0)
# 48998 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct PGroup {
  sqlite3_mutex *mutex;
  unsigned int nMaxPage;
  unsigned int nMinPage;
  unsigned int mxPinned;
  unsigned int nPurgeable;
  PgHdr1 lru;
};
# 49015 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct PCache1 {






  PGroup *pGroup;
  unsigned int *pnPurgeable;
  int szPage;
  int szExtra;
  int szAlloc;
  int bPurgeable;
  unsigned int nMin;
  unsigned int nMax;
  unsigned int n90pct;
  unsigned int iMaxKey;
  unsigned int nPurgeableDummy;




  unsigned int nRecyclable;
  unsigned int nPage;
  unsigned int nHash;
  PgHdr1 **apHash;
  PgHdr1 *pFree;
  void *pBulk;
};





struct PgFreeslot {
  PgFreeslot *pNext;
};




static struct PCacheGlobal {
  PGroup grp;






  int isInit;
  int separateCache;
  int nInitPage;
  int szSlot;
  int nSlot;
  int nReserve;
  void *pStart, *pEnd;

  sqlite3_mutex *mutex;
  PgFreeslot *pFree;
  int nFreeSlot;




  int bUnderPressure;
} pcache1_g;






#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))





#define pcache1EnterMutex(X) assert((X)->mutex==0)
#define pcache1LeaveMutex(X) assert((X)->mutex==0)
#define PCACHE1_MIGHT_USE_GROUP_MUTEX 0
# 49115 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){
  if( (pcache1_g).isInit ){
    PgFreeslot *p;
    if( pBuf==0 ) sz = n = 0;
    if( n==0 ) sz = 0;
    sz = ((sz)&~7);
    (pcache1_g).szSlot = sz;
    (pcache1_g).nSlot = (pcache1_g).nFreeSlot = n;
    (pcache1_g).nReserve = n>90 ? 10 : (n/10 + 1);
    (pcache1_g).pStart = pBuf;
    (pcache1_g).pFree = 0;
    (pcache1_g).bUnderPressure = 0;
    while( n-- ){
      p = (PgFreeslot*)pBuf;
      p->pNext = (pcache1_g).pFree;
      (pcache1_g).pFree = p;
      pBuf = (void*)&((char*)pBuf)[sz];
    }
    (pcache1_g).pEnd = pBuf;
  }
}





static int pcache1InitBulk(PCache1 *pCache){
  i64 szBulk;
  char *zBulk;
  if( (pcache1_g).nInitPage==0 ) return 0;

  if( pCache->nMax<3 ) return 0;
  sqlite3BeginBenignMalloc();
  if( (pcache1_g).nInitPage>0 ){
    szBulk = pCache->szAlloc * (i64)(pcache1_g).nInitPage;
  }else{
    szBulk = -1024 * (i64)(pcache1_g).nInitPage;
  }
  if( szBulk > pCache->szAlloc*(i64)pCache->nMax ){
    szBulk = pCache->szAlloc*(i64)pCache->nMax;
  }
  zBulk = pCache->pBulk = sqlite3Malloc( szBulk );
  sqlite3EndBenignMalloc();
  if( zBulk ){
    int nBulk = sqlite3MallocSize(zBulk)/pCache->szAlloc;
    do{
      PgHdr1 *pX = (PgHdr1*)&zBulk[pCache->szPage];
      pX->page.pBuf = zBulk;
      pX->page.pExtra = &pX[1];
      pX->isBulkLocal = 1;
      pX->isAnchor = 0;
      pX->pNext = pCache->pFree;
      pX->pLruPrev = 0;
      pCache->pFree = pX;
      zBulk += pCache->szAlloc;
    }while( --nBulk );
  }
  return pCache->pFree!=0;
}
# 49184 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *pcache1Alloc(int nByte){
  void *p = 0;
  ((void)0);
  if( nByte<=(pcache1_g).szSlot ){
    sqlite3_mutex_enter((pcache1_g).mutex);
    p = (PgHdr1 *)(pcache1_g).pFree;
    if( p ){
      (pcache1_g).pFree = (pcache1_g).pFree->pNext;
      (pcache1_g).nFreeSlot--;
      (pcache1_g).bUnderPressure = (pcache1_g).nFreeSlot<(pcache1_g).nReserve;
      ((void)0);
      sqlite3StatusHighwater(7, nByte);
      sqlite3StatusUp(1, 1);
    }
    sqlite3_mutex_leave((pcache1_g).mutex);
  }
  if( p==0 ){



    p = sqlite3Malloc(nByte);

    if( p ){
      int sz = sqlite3MallocSize(p);
      sqlite3_mutex_enter((pcache1_g).mutex);
      sqlite3StatusHighwater(7, nByte);
      sqlite3StatusUp(2, sz);
      sqlite3_mutex_leave((pcache1_g).mutex);
    }

    ;
  }
  return p;
}




static void pcache1Free(void *p){
  if( p==0 ) return;
  if( (((uptr)(p)>=(uptr)((pcache1_g).pStart))&&((uptr)(p)<(uptr)((pcache1_g).pEnd))) ){
    PgFreeslot *pSlot;
    sqlite3_mutex_enter((pcache1_g).mutex);
    sqlite3StatusDown(1, 1);
    pSlot = (PgFreeslot*)p;
    pSlot->pNext = (pcache1_g).pFree;
    (pcache1_g).pFree = pSlot;
    (pcache1_g).nFreeSlot++;
    (pcache1_g).bUnderPressure = (pcache1_g).nFreeSlot<(pcache1_g).nReserve;
    ((void)0);
    sqlite3_mutex_leave((pcache1_g).mutex);
  }else{
    ((void)0);
    ;

    {
      int nFreed = 0;
      nFreed = sqlite3MallocSize(p);
      sqlite3_mutex_enter((pcache1_g).mutex);
      sqlite3StatusDown(2, nFreed);
      sqlite3_mutex_leave((pcache1_g).mutex);
    }

    sqlite3_free(p);
  }
}
# 49272 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static PgHdr1 *pcache1AllocPage(PCache1 *pCache, int benignMalloc){
  PgHdr1 *p = 0;
  void *pPg;

  ((void)0);
  if( pCache->pFree || (pCache->nPage==0 && pcache1InitBulk(pCache)) ){
    ((void)0);
    p = pCache->pFree;
    pCache->pFree = p->pNext;
    p->pNext = 0;
  }else{
# 49291 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( benignMalloc ){ sqlite3BeginBenignMalloc(); }
# 49301 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pPg = pcache1Alloc(pCache->szAlloc);
    p = (PgHdr1 *)&((u8 *)pPg)[pCache->szPage];

    if( benignMalloc ){ sqlite3EndBenignMalloc(); }



    if( pPg==0 ) return 0;
    p->page.pBuf = pPg;
    p->page.pExtra = &p[1];
    p->isBulkLocal = 0;
    p->isAnchor = 0;
  }
  (*pCache->pnPurgeable)++;
  return p;
}




static void pcache1FreePage(PgHdr1 *p){
  PCache1 *pCache;
  ((void)0);
  pCache = p->pCache;
  ((void)0);
  if( p->isBulkLocal ){
    p->pNext = pCache->pFree;
    pCache->pFree = p;
  }else{
    pcache1Free(p->page.pBuf);



  }
  (*pCache->pnPurgeable)--;
}






static void *sqlite3PageMalloc(int sz){
  ((void)0);
  return pcache1Alloc(sz);
}




static void sqlite3PageFree(void *p){
  pcache1Free(p);
}
# 49372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pcache1UnderMemoryPressure(PCache1 *pCache){
  if( (pcache1_g).nSlot && (pCache->szPage+pCache->szExtra)<=(pcache1_g).szSlot ){
    return (pcache1_g).bUnderPressure;
  }else{
    return sqlite3HeapNearlyFull();
  }
}
# 49389 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pcache1ResizeHash(PCache1 *p){
  PgHdr1 **apNew;
  unsigned int nNew;
  unsigned int i;

  ((void)0);

  nNew = p->nHash*2;
  if( nNew<256 ){
    nNew = 256;
  }

  ((void)0);
  if( p->nHash ){ sqlite3BeginBenignMalloc(); }
  apNew = (PgHdr1 **)sqlite3MallocZero(sizeof(PgHdr1 *)*nNew);
  if( p->nHash ){ sqlite3EndBenignMalloc(); }
  ((void)0);
  if( apNew ){
    for(i=0; i<p->nHash; i++){
      PgHdr1 *pPage;
      PgHdr1 *pNext = p->apHash[i];
      while( (pPage = pNext)!=0 ){
        unsigned int h = pPage->iKey % nNew;
        pNext = pPage->pNext;
        pPage->pNext = apNew[h];
        apNew[h] = pPage;
      }
    }
    sqlite3_free(p->apHash);
    p->apHash = apNew;
    p->nHash = nNew;
  }
}
# 49430 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static PgHdr1 *pcache1PinPage(PgHdr1 *pPage){
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  pPage->pLruPrev->pLruNext = pPage->pLruNext;
  pPage->pLruNext->pLruPrev = pPage->pLruPrev;
  pPage->pLruNext = 0;


  ((void)0);
  ((void)0);
  pPage->pCache->nRecyclable--;
  return pPage;
}
# 49455 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pcache1RemoveFromHash(PgHdr1 *pPage, int freeFlag){
  unsigned int h;
  PCache1 *pCache = pPage->pCache;
  PgHdr1 **pp;

  ((void)0);
  h = pPage->iKey % pCache->nHash;
  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);
  *pp = (*pp)->pNext;

  pCache->nPage--;
  if( freeFlag ) pcache1FreePage(pPage);
}





static void pcache1EnforceMaxPage(PCache1 *pCache){
  PGroup *pGroup = pCache->pGroup;
  PgHdr1 *p;
  ((void)0);
  while( pGroup->nPurgeable>pGroup->nMaxPage
      && (p=pGroup->lru.pLruPrev)->isAnchor==0
  ){
    ((void)0);
    ((void)0);
    pcache1PinPage(p);
    pcache1RemoveFromHash(p, 1);
  }
  if( pCache->nPage==0 && pCache->pBulk ){
    sqlite3_free(pCache->pBulk);
    pCache->pBulk = pCache->pFree = 0;
  }
}
# 49498 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pcache1TruncateUnsafe(
  PCache1 *pCache,
  unsigned int iLimit
){
 
  unsigned int h, iStop;
  ((void)0);
  ((void)0);
  ((void)0);
  if( pCache->iMaxKey - iLimit < pCache->nHash ){




    h = iLimit % pCache->nHash;
    iStop = pCache->iMaxKey % pCache->nHash;
   
  }else{


    h = pCache->nHash/2;
    iStop = h - 1;
  }
  for(;;){
    PgHdr1 **pp;
    PgHdr1 *pPage;
    ((void)0);
    pp = &pCache->apHash[h];
    while( (pPage = *pp)!=0 ){
      if( pPage->iKey>=iLimit ){
        pCache->nPage--;
        *pp = pPage->pNext;
        if( ((pPage)->pLruNext!=0) ) pcache1PinPage(pPage);
        pcache1FreePage(pPage);
      }else{
        pp = &pPage->pNext;
       
      }
    }
    if( h==iStop ) break;
    h = (h+1) % pCache->nHash;
  }
  ((void)0);
}







static int pcache1Init(void *NotUsed){
  (void)(NotUsed);
  ((void)0);
  memset(&(pcache1_g), 0, sizeof((pcache1_g)));
# 49572 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (pcache1_g).separateCache = sqlite3Config.pPage==0
                          || sqlite3Config.bCoreMutex>0;





  if( sqlite3Config.bCoreMutex ){
    (pcache1_g).grp.mutex = sqlite3MutexAlloc(6);
    (pcache1_g).mutex = sqlite3MutexAlloc(7);
  }

  if( (pcache1_g).separateCache
   && sqlite3Config.nPage!=0
   && sqlite3Config.pPage==0
  ){
    (pcache1_g).nInitPage = sqlite3Config.nPage;
  }else{
    (pcache1_g).nInitPage = 0;
  }
  (pcache1_g).grp.mxPinned = 10;
  (pcache1_g).isInit = 1;
  return 0;
}






static void pcache1Shutdown(void *NotUsed){
  (void)(NotUsed);
  ((void)0);
  memset(&(pcache1_g), 0, sizeof((pcache1_g)));
}


static void pcache1Destroy(sqlite3_pcache *p);






static sqlite3_pcache *pcache1Create(int szPage, int szExtra, int bPurgeable){
  PCache1 *pCache;
  PGroup *pGroup;
  int sz;

  ((void)0);
  ((void)0);

  sz = sizeof(PCache1) + sizeof(PGroup)*(pcache1_g).separateCache;
  pCache = (PCache1 *)sqlite3MallocZero(sz);
  if( pCache ){
    if( (pcache1_g).separateCache ){
      pGroup = (PGroup*)&pCache[1];
      pGroup->mxPinned = 10;
    }else{
      pGroup = &(pcache1_g).grp;
    }
    ((void)0);
    if( pGroup->lru.isAnchor==0 ){
      pGroup->lru.isAnchor = 1;
      pGroup->lru.pLruPrev = pGroup->lru.pLruNext = &pGroup->lru;
    }
    pCache->pGroup = pGroup;
    pCache->szPage = szPage;
    pCache->szExtra = szExtra;
    pCache->szAlloc = szPage + szExtra + (((sizeof(PgHdr1))+7)&~7);
    pCache->bPurgeable = (bPurgeable ? 1 : 0);
    pcache1ResizeHash(pCache);
    if( bPurgeable ){
      pCache->nMin = 10;
      pGroup->nMinPage += pCache->nMin;
      pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
      pCache->pnPurgeable = &pGroup->nPurgeable;
    }else{
      pCache->pnPurgeable = &pCache->nPurgeableDummy;
    }
    ((void)0);
    if( pCache->nHash==0 ){
      pcache1Destroy((sqlite3_pcache*)pCache);
      pCache = 0;
    }
  }
  return (sqlite3_pcache *)pCache;
}






static void pcache1Cachesize(sqlite3_pcache *p, int nMax){
  PCache1 *pCache = (PCache1 *)p;
  if( pCache->bPurgeable ){
    PGroup *pGroup = pCache->pGroup;
    ((void)0);
    pGroup->nMaxPage += (nMax - pCache->nMax);
    pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
    pCache->nMax = nMax;
    pCache->n90pct = pCache->nMax*9/10;
    pcache1EnforceMaxPage(pCache);
    ((void)0);
  }
}






static void pcache1Shrink(sqlite3_pcache *p){
  PCache1 *pCache = (PCache1*)p;
  if( pCache->bPurgeable ){
    PGroup *pGroup = pCache->pGroup;
    int savedMaxPage;
    ((void)0);
    savedMaxPage = pGroup->nMaxPage;
    pGroup->nMaxPage = 0;
    pcache1EnforceMaxPage(pCache);
    pGroup->nMaxPage = savedMaxPage;
    ((void)0);
  }
}




static int pcache1Pagecount(sqlite3_pcache *p){
  int n;
  PCache1 *pCache = (PCache1*)p;
  ((void)0);
  n = pCache->nPage;
  ((void)0);
  return n;
}
# 49720 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) PgHdr1 *pcache1FetchStage2(
  PCache1 *pCache,
  unsigned int iKey,
  int createFlag
){
  unsigned int nPinned;
  PGroup *pGroup = pCache->pGroup;
  PgHdr1 *pPage = 0;


  ((void)0);
  nPinned = pCache->nPage - pCache->nRecyclable;
  ((void)0);
  ((void)0);
  if( createFlag==1 && (
        nPinned>=pGroup->mxPinned
     || nPinned>=pCache->n90pct
     || (pcache1UnderMemoryPressure(pCache) && pCache->nRecyclable<nPinned)
  )){
    return 0;
  }

  if( pCache->nPage>=pCache->nHash ) pcache1ResizeHash(pCache);
  ((void)0);


  if( pCache->bPurgeable
   && !pGroup->lru.pLruPrev->isAnchor
   && ((pCache->nPage+1>=pCache->nMax) || pcache1UnderMemoryPressure(pCache))
  ){
    PCache1 *pOther;
    pPage = pGroup->lru.pLruPrev;
    ((void)0);
    pcache1RemoveFromHash(pPage, 0);
    pcache1PinPage(pPage);
    pOther = pPage->pCache;
    if( pOther->szAlloc != pCache->szAlloc ){
      pcache1FreePage(pPage);
      pPage = 0;
    }else{
      pGroup->nPurgeable -= (pOther->bPurgeable - pCache->bPurgeable);
    }
  }




  if( !pPage ){
    pPage = pcache1AllocPage(pCache, createFlag==1);
  }

  if( pPage ){
    unsigned int h = iKey % pCache->nHash;
    pCache->nPage++;
    pPage->iKey = iKey;
    pPage->pNext = pCache->apHash[h];
    pPage->pCache = pCache;
    pPage->pLruNext = 0;


    *(void **)pPage->page.pExtra = 0;
    pCache->apHash[h] = pPage;
    if( iKey>pCache->iMaxKey ){
      pCache->iMaxKey = iKey;
    }
  }
  return pPage;
}
# 49848 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static PgHdr1 *pcache1FetchNoMutex(
  sqlite3_pcache *p,
  unsigned int iKey,
  int createFlag
){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = 0;


  pPage = pCache->apHash[iKey % pCache->nHash];
  while( pPage && pPage->iKey!=iKey ){ pPage = pPage->pNext; }





  if( pPage ){
    if( ((pPage)->pLruNext!=0) ){
      return pcache1PinPage(pPage);
    }else{
      return pPage;
    }
  }else if( createFlag ){

    return pcache1FetchStage2(pCache, iKey, createFlag);
  }else{
    return 0;
  }
}
# 49893 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_pcache_page *pcache1Fetch(
  sqlite3_pcache *p,
  unsigned int iKey,
  int createFlag
){




  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);





  {
    return (sqlite3_pcache_page*)pcache1FetchNoMutex(p, iKey, createFlag);
  }
}







static void pcache1Unpin(
  sqlite3_pcache *p,
  sqlite3_pcache_page *pPg,
  int reuseUnlikely
){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = (PgHdr1 *)pPg;
  PGroup *pGroup = pCache->pGroup;

  ((void)0);
  ((void)0);




  ((void)0);
  ((void)0);

  if( reuseUnlikely || pGroup->nPurgeable>pGroup->nMaxPage ){
    pcache1RemoveFromHash(pPage, 1);
  }else{

    PgHdr1 **ppFirst = &pGroup->lru.pLruNext;
    pPage->pLruPrev = &pGroup->lru;
    (pPage->pLruNext = *ppFirst)->pLruPrev = pPage;
    *ppFirst = pPage;
    pCache->nRecyclable++;
  }

  ((void)0);
}




static void pcache1Rekey(
  sqlite3_pcache *p,
  sqlite3_pcache_page *pPg,
  unsigned int iOld,
  unsigned int iNew
){
  PCache1 *pCache = (PCache1 *)p;
  PgHdr1 *pPage = (PgHdr1 *)pPg;
  PgHdr1 **pp;
  unsigned int h;
  ((void)0);
  ((void)0);

  ((void)0);

  h = iOld%pCache->nHash;
  pp = &pCache->apHash[h];
  while( (*pp)!=pPage ){
    pp = &(*pp)->pNext;
  }
  *pp = pPage->pNext;

  h = iNew%pCache->nHash;
  pPage->iKey = iNew;
  pPage->pNext = pCache->apHash[h];
  pCache->apHash[h] = pPage;
  if( iNew>pCache->iMaxKey ){
    pCache->iMaxKey = iNew;
  }

  ((void)0);
}
# 49999 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){
  PCache1 *pCache = (PCache1 *)p;
  ((void)0);
  if( iLimit<=pCache->iMaxKey ){
    pcache1TruncateUnsafe(pCache, iLimit);
    pCache->iMaxKey = iLimit-1;
  }
  ((void)0);
}






static void pcache1Destroy(sqlite3_pcache *p){
  PCache1 *pCache = (PCache1 *)p;
  PGroup *pGroup = pCache->pGroup;
  ((void)0);
  ((void)0);
  if( pCache->nPage ) pcache1TruncateUnsafe(pCache, 0);
  ((void)0);
  pGroup->nMaxPage -= pCache->nMax;
  ((void)0);
  pGroup->nMinPage -= pCache->nMin;
  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;
  pcache1EnforceMaxPage(pCache);
  ((void)0);
  sqlite3_free(pCache->pBulk);
  sqlite3_free(pCache->apHash);
  sqlite3_free(pCache);
}






static void sqlite3PCacheSetDefault(void){
  static const sqlite3_pcache_methods2 defaultMethods = {
    1,
    0,
    pcache1Init,
    pcache1Shutdown,
    pcache1Create,
    pcache1Cachesize,
    pcache1Pagecount,
    pcache1Fetch,
    pcache1Unpin,
    pcache1Rekey,
    pcache1Truncate,
    pcache1Destroy,
    pcache1Shrink
  };
  sqlite3_config(18, &defaultMethods);
}




static int sqlite3HeaderSizePcache1(void){ return (((sizeof(PgHdr1))+7)&~7); }





static sqlite3_mutex *sqlite3Pcache1Mutex(void){
  return (pcache1_g).mutex;
}
# 50199 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ROWSET_ALLOCATION_SIZE 1024




#define ROWSET_ENTRY_PER_CHUNK ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))
# 50215 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct RowSetEntry {
  i64 v;
  struct RowSetEntry *pRight;
  struct RowSetEntry *pLeft;
};







struct RowSetChunk {
  struct RowSetChunk *pNextChunk;
  struct RowSetEntry aEntry[((1024 -8)/sizeof(struct RowSetEntry))];
};






struct RowSet {
  struct RowSetChunk *pChunk;
  sqlite3 *db;
  struct RowSetEntry *pEntry;
  struct RowSetEntry *pLast;
  struct RowSetEntry *pFresh;
  struct RowSetEntry *pForest;
  u16 nFresh;
  u16 rsFlags;
  int iBatch;
};




#define ROWSET_SORTED 0x01
#define ROWSET_NEXT 0x02





static RowSet *sqlite3RowSetInit(sqlite3 *db){
  RowSet *p = sqlite3DbMallocRawNN(db, sizeof(*p));
  if( p ){
    int N = sqlite3DbMallocSize(db, p);
    p->pChunk = 0;
    p->db = db;
    p->pEntry = 0;
    p->pLast = 0;
    p->pForest = 0;
    p->pFresh = (struct RowSetEntry*)((((sizeof(*p))+7)&~7) + (char*)p);
    p->nFresh = (u16)((N - (((sizeof(*p))+7)&~7))/sizeof(struct RowSetEntry));
    p->rsFlags = 0x01;
    p->iBatch = 0;
  }
  return p;
}






static void sqlite3RowSetClear(void *pArg){
  RowSet *p = (RowSet*)pArg;
  struct RowSetChunk *pChunk, *pNextChunk;
  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){
    pNextChunk = pChunk->pNextChunk;
    sqlite3DbFree(p->db, pChunk);
  }
  p->pChunk = 0;
  p->nFresh = 0;
  p->pEntry = 0;
  p->pLast = 0;
  p->pForest = 0;
  p->rsFlags = 0x01;
}






static void sqlite3RowSetDelete(void *pArg){
  sqlite3RowSetClear(pArg);
  sqlite3DbFree(((RowSet*)pArg)->db, pArg);
}
# 50314 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static struct RowSetEntry *rowSetEntryAlloc(RowSet *p){
  ((void)0);
  if( p->nFresh==0 ){


    struct RowSetChunk *pNew;
    pNew = sqlite3DbMallocRawNN(p->db, sizeof(*pNew));
    if( pNew==0 ){
      return 0;
    }
    pNew->pNextChunk = p->pChunk;
    p->pChunk = pNew;
    p->pFresh = pNew->aEntry;
    p->nFresh = ((1024 -8)/sizeof(struct RowSetEntry));
  }
  p->nFresh--;
  return p->pFresh++;
}







static void sqlite3RowSetInsert(RowSet *p, i64 rowid){
  struct RowSetEntry *pEntry;
  struct RowSetEntry *pLast;


  ((void)0);

  pEntry = rowSetEntryAlloc(p);
  if( pEntry==0 ) return;
  pEntry->v = rowid;
  pEntry->pRight = 0;
  pLast = p->pLast;
  if( pLast ){
    if( rowid<=pLast->v ){


      p->rsFlags &= ~0x01;
    }
    pLast->pRight = pEntry;
  }else{
    p->pEntry = pEntry;
  }
  p->pLast = pEntry;
}







static struct RowSetEntry *rowSetEntryMerge(
  struct RowSetEntry *pA,
  struct RowSetEntry *pB
){
  struct RowSetEntry head;
  struct RowSetEntry *pTail;

  pTail = &head;
  ((void)0);
  for(;;){
    ((void)0);
    ((void)0);
    if( pA->v<=pB->v ){
      if( pA->v<pB->v ) pTail = pTail->pRight = pA;
      pA = pA->pRight;
      if( pA==0 ){
        pTail->pRight = pB;
        break;
      }
    }else{
      pTail = pTail->pRight = pB;
      pB = pB->pRight;
      if( pB==0 ){
        pTail->pRight = pA;
        break;
      }
    }
  }
  return head.pRight;
}





static struct RowSetEntry *rowSetEntrySort(struct RowSetEntry *pIn){
  unsigned int i;
  struct RowSetEntry *pNext, *aBucket[40];

  memset(aBucket, 0, sizeof(aBucket));
  while( pIn ){
    pNext = pIn->pRight;
    pIn->pRight = 0;
    for(i=0; aBucket[i]; i++){
      pIn = rowSetEntryMerge(aBucket[i], pIn);
      aBucket[i] = 0;
    }
    aBucket[i] = pIn;
    pIn = pNext;
  }
  pIn = aBucket[0];
  for(i=1; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){
    if( aBucket[i]==0 ) continue;
    pIn = pIn ? rowSetEntryMerge(pIn, aBucket[i]) : aBucket[i];
  }
  return pIn;
}







static void rowSetTreeToList(
  struct RowSetEntry *pIn,
  struct RowSetEntry **ppFirst,
  struct RowSetEntry **ppLast
){
  ((void)0);
  if( pIn->pLeft ){
    struct RowSetEntry *p;
    rowSetTreeToList(pIn->pLeft, ppFirst, &p);
    p->pRight = pIn;
  }else{
    *ppFirst = pIn;
  }
  if( pIn->pRight ){
    rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);
  }else{
    *ppLast = pIn;
  }
  ((void)0);
}
# 50469 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static struct RowSetEntry *rowSetNDeepTree(
  struct RowSetEntry **ppList,
  int iDepth
){
  struct RowSetEntry *p;
  struct RowSetEntry *pLeft;
  if( *ppList==0 ){

    return 0;
  }
  if( iDepth>1 ){



    pLeft = rowSetNDeepTree(ppList, iDepth-1);
    p = *ppList;
    if( p==0 ){


      return pLeft;
    }
    p->pLeft = pLeft;
    *ppList = p->pRight;
    p->pRight = rowSetNDeepTree(ppList, iDepth-1);
  }else{
    p = *ppList;
    *ppList = p->pRight;
    p->pLeft = p->pRight = 0;
  }
  return p;
}





static struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){
  int iDepth;
  struct RowSetEntry *p;
  struct RowSetEntry *pLeft;

  ((void)0);
  p = pList;
  pList = p->pRight;
  p->pLeft = p->pRight = 0;
  for(iDepth=1; pList; iDepth++){
    pLeft = p;
    p = pList;
    pList = p->pRight;
    p->pLeft = pLeft;
    p->pRight = rowSetNDeepTree(&pList, iDepth);
  }
  return p;
}
# 50537 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3RowSetNext(RowSet *p, i64 *pRowid){
  ((void)0);
  ((void)0);


  if( (p->rsFlags & 0x02)==0 ){
    if( (p->rsFlags & 0x01)==0 ){
      p->pEntry = rowSetEntrySort(p->pEntry);
    }
    p->rsFlags |= 0x01|0x02;
  }


  if( p->pEntry ){
    *pRowid = p->pEntry->v;
    p->pEntry = p->pEntry->pRight;
    if( p->pEntry==0 ){

      sqlite3RowSetClear(p);
    }
    return 1;
  }else{
    return 0;
  }
}
# 50571 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3RowSetTest(RowSet *pRowSet, int iBatch, sqlite3_int64 iRowid){
  struct RowSetEntry *p, *pTree;


  ((void)0);




  if( iBatch!=pRowSet->iBatch ){
    p = pRowSet->pEntry;
    if( p ){
      struct RowSetEntry **ppPrevTree = &pRowSet->pForest;
      if( (pRowSet->rsFlags & 0x01)==0 ){

        p = rowSetEntrySort(p);
      }
      for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){
        ppPrevTree = &pTree->pRight;
        if( pTree->pLeft==0 ){
          pTree->pLeft = rowSetListToTree(p);
          break;
        }else{
          struct RowSetEntry *pAux, *pTail;
          rowSetTreeToList(pTree->pLeft, &pAux, &pTail);
          pTree->pLeft = 0;
          p = rowSetEntryMerge(pAux, p);
        }
      }
      if( pTree==0 ){
        *ppPrevTree = pTree = rowSetEntryAlloc(pRowSet);
        if( pTree ){
          pTree->v = 0;
          pTree->pRight = 0;
          pTree->pLeft = rowSetListToTree(p);
        }
      }
      pRowSet->pEntry = 0;
      pRowSet->pLast = 0;
      pRowSet->rsFlags |= 0x01;
    }
    pRowSet->iBatch = iBatch;
  }




  for(pTree = pRowSet->pForest; pTree; pTree=pTree->pRight){
    p = pTree->pLeft;
    while( p ){
      if( p->v<iRowid ){
        p = p->pRight;
      }else if( p->v>iRowid ){
        p = p->pLeft;
      }else{
        return 1;
      }
    }
  }
  return 0;
}
# 50676 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_WAL_H 






#define WAL_SYNC_FLAGS(X) ((X)&0x03)
#define CKPT_SYNC_FLAGS(X) (((X)>>2)&0x03)
# 50708 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WAL_SAVEPOINT_NDATA 4




typedef struct Wal Wal;


static int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *, int, i64, Wal**);
static int sqlite3WalClose(Wal *pWal, sqlite3*, int sync_flags, int, u8 *);


static void sqlite3WalLimit(Wal*, i64);
# 50729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalBeginReadTransaction(Wal *pWal, int *);
static void sqlite3WalEndReadTransaction(Wal *pWal);


static int sqlite3WalFindFrame(Wal *, Pgno, u32 *);
static int sqlite3WalReadFrame(Wal *, u32, int, u8 *);


static Pgno sqlite3WalDbsize(Wal *pWal);


static int sqlite3WalBeginWriteTransaction(Wal *pWal);
static int sqlite3WalEndWriteTransaction(Wal *pWal);


static int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx);



static void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData);



static int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData);


static int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int);


static int sqlite3WalCheckpoint(
  Wal *pWal,
  sqlite3 *db,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  int nBuf,
  u8 *zBuf,
  int *pnLog,
  int *pnCkpt
);






static int sqlite3WalCallback(Wal *pWal);




static int sqlite3WalExclusiveMode(Wal *pWal, int op);





static int sqlite3WalHeapMemory(Wal *pWal);
# 50805 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_file *sqlite3WalFile(Wal *pWal);
# 50908 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PAGERTRACE(X) 
# 50919 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PAGERID(p) (SQLITE_PTR_TO_INT(p->fd))
#define FILEHANDLEID(fd) (SQLITE_PTR_TO_INT(fd))
# 51139 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PAGER_OPEN 0
#define PAGER_READER 1
#define PAGER_WRITER_LOCKED 2
#define PAGER_WRITER_CACHEMOD 3
#define PAGER_WRITER_DBMOD 4
#define PAGER_WRITER_FINISHED 5
#define PAGER_ERROR 6
# 51195 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define UNKNOWN_LOCK (EXCLUSIVE_LOCK+1)
# 51207 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define CODEC1(P,D,N,X,E) 
#define CODEC2(P,D,N,X,E,O) O=(char*)D
# 51217 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define MAX_SECTOR_SIZE 0x10000
# 51233 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct PagerSavepoint PagerSavepoint;
struct PagerSavepoint {
  i64 iOffset;
  i64 iHdrOffset;
  Bitvec *pInSavepoint;
  Pgno nOrig;
  Pgno iSubRec;

  u32 aWalData[4];

};




#define SPILLFLAG_OFF 0x01
#define SPILLFLAG_ROLLBACK 0x02
#define SPILLFLAG_NOSYNC 0x04
# 51420 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Pager {
  sqlite3_vfs *pVfs;
  u8 exclusiveMode;
  u8 journalMode;
  u8 useJournal;
  u8 noSync;
  u8 fullSync;
  u8 extraSync;
  u8 syncFlags;
  u8 walSyncFlags;
  u8 tempFile;
  u8 noLock;
  u8 readOnly;
  u8 memDb;
# 51444 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  u8 eState;
  u8 eLock;
  u8 changeCountDone;
  u8 setMaster;
  u8 doNotSpill;
  u8 subjInMemory;
  u8 bUseFetch;
  u8 hasHeldSharedLock;
  Pgno dbSize;
  Pgno dbOrigSize;
  Pgno dbFileSize;
  Pgno dbHintSize;
  int errCode;
  int nRec;
  u32 cksumInit;
  u32 nSubRec;
  Bitvec *pInJournal;
  sqlite3_file *fd;
  sqlite3_file *jfd;
  sqlite3_file *sjfd;
  i64 journalOff;
  i64 journalHdr;
  sqlite3_backup *pBackup;
  PagerSavepoint *aSavepoint;
  int nSavepoint;
  u32 iDataVersion;
  char dbFileVers[16];

  int nMmapOut;
  sqlite3_int64 szMmap;
  PgHdr *pMmapFreelist;




  u16 nExtra;
  i16 nReserve;
  u32 vfsFlags;
  u32 sectorSize;
  int pageSize;
  Pgno mxPgno;
  i64 journalSizeLimit;
  char *zFilename;
  char *zJournal;
  int (*xBusyHandler)(void*);
  void *pBusyHandlerArg;
  int aStat[4];



  void (*xReiniter)(DbPage*);
  int (*xGet)(Pager*,Pgno,DbPage**,int);






  char *pTmpSpace;
  PCache *pPCache;

  Wal *pWal;
  char *zWal;

};






#define PAGER_STAT_HIT 0
#define PAGER_STAT_MISS 1
#define PAGER_STAT_WRITE 2
#define PAGER_STAT_SPILL 3
# 51531 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PAGER_INCR(v) 
# 51559 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const unsigned char aJournalMagic[] = {
  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,
};





#define JOURNAL_PG_SZ(pPager) ((pPager->pageSize) + 8)





#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)
# 51584 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define MEMDB pPager->memDb







#define USEFETCH(x) ((x)->bUseFetch)







#define PAGER_MAX_PGNO 2147483647
# 51614 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define isOpen(pFd) ((pFd)->pMethods!=0)
# 51644 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define pagerUseWal(x) ((x)->pWal!=0)
# 51850 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getPageNormal(Pager*,Pgno,DbPage**,int);
static int getPageError(Pager*,Pgno,DbPage**,int);

static int getPageMMap(Pager*,Pgno,DbPage**,int);






static void setGetterMethod(Pager *pPager){
  if( pPager->errCode ){
    pPager->xGet = getPageError;

  }else if( ((pPager)->bUseFetch)



  ){
    pPager->xGet = getPageMMap;

  }else{
    pPager->xGet = getPageNormal;
  }
}
# 51885 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int subjRequiresPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  PagerSavepoint *p;
  Pgno pgno = pPg->pgno;
  int i;
  for(i=0; i<pPager->nSavepoint; i++){
    p = &pPager->aSavepoint[i];
    if( p->nOrig>=pgno && 0==sqlite3BitvecTestNotNull(p->pInSavepoint, pgno) ){
      return 1;
    }
  }
  return 0;
}
# 51915 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){
  unsigned char ac[4];
  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);
  if( rc==0 ){
    *pRes = sqlite3Get4byte(ac);
  }
  return rc;
}




#define put32bits(A,B) sqlite3Put4byte((u8*)A,B)






static int write32bits(sqlite3_file *fd, i64 offset, u32 val){
  char ac[4];
  sqlite3Put4byte((u8*)ac,val);
  return sqlite3OsWrite(fd, ac, 4, offset);
}
# 51949 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerUnlockDb(Pager *pPager, int eLock){
  int rc = 0;

  ((void)0);
  ((void)0);
  ((void)0);
  if( ((pPager->fd)->pMethods!=0) ){
    ((void)0);
    rc = pPager->noLock ? 0 : sqlite3OsUnlock(pPager->fd, eLock);
    if( pPager->eLock!=(4 +1) ){
      pPager->eLock = (u8)eLock;
    }
   
  }
  return rc;
}
# 51976 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerLockDb(Pager *pPager, int eLock){
  int rc = 0;

  ((void)0);
  if( pPager->eLock<eLock || pPager->eLock==(4 +1) ){
    rc = pPager->noLock ? 0 : sqlite3OsLock(pPager->fd, eLock);
    if( rc==0 && (pPager->eLock!=(4 +1)||eLock==4) ){
      pPager->eLock = (u8)eLock;
     
    }
  }
  return rc;
}
# 52009 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int jrnlBufferSize(Pager *pPager){
  ((void)0);
# 52019 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(pPager);
# 52043 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return 0;
}
# 52083 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define pager_datahash(X,Y) 0
#define pager_pagehash(X) 0
#define pager_set_pagehash(X) 
#define CHECK_PAGE(x) 
# 52114 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){
  int rc;
  u32 len;
  i64 szJ;
  u32 cksum;
  u32 u;
  unsigned char aMagic[8];
  zMaster[0] = '\0';

  if( 0!=(rc = sqlite3OsFileSize(pJrnl, &szJ))
   || szJ<16
   || 0!=(rc = read32bits(pJrnl, szJ-16, &len))
   || len>=nMaster
   || len>szJ-16
   || len==0
   || 0!=(rc = read32bits(pJrnl, szJ-12, &cksum))
   || 0!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))
   || memcmp(aMagic, aJournalMagic, 8)
   || 0!=(rc = sqlite3OsRead(pJrnl, zMaster, len, szJ-16-len))
  ){
    return rc;
  }


  for(u=0; u<len; u++){
    cksum -= zMaster[u];
  }
  if( cksum ){





    len = 0;
  }
  zMaster[len] = '\0';

  return 0;
}
# 52169 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static i64 journalHdrOffset(Pager *pPager){
  i64 offset = 0;
  i64 c = pPager->journalOff;
  if( c ){
    offset = ((c-1)/(pPager->sectorSize) + 1) * (pPager->sectorSize);
  }
  ((void)0);
  ((void)0);
  ((void)0);
  return offset;
}
# 52202 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int zeroJournalHdr(Pager *pPager, int doTruncate){
  int rc = 0;
  ((void)0);
  ((void)0);
  if( pPager->journalOff ){
    const i64 iLimit = pPager->journalSizeLimit;

   
    if( doTruncate || iLimit==0 ){
      rc = sqlite3OsTruncate(pPager->jfd, 0);
    }else{
      static const char zeroHdr[28] = {0};
      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);
    }
    if( rc==0 && !pPager->noSync ){
      rc = sqlite3OsSync(pPager->jfd, 0x00010|pPager->syncFlags);
    }







    if( rc==0 && iLimit>0 ){
      i64 sz;
      rc = sqlite3OsFileSize(pPager->jfd, &sz);
      if( rc==0 && sz>iLimit ){
        rc = sqlite3OsTruncate(pPager->jfd, iLimit);
      }
    }
  }
  return rc;
}
# 52252 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int writeJournalHdr(Pager *pPager){
  int rc = 0;
  char *zHeader = pPager->pTmpSpace;
  u32 nHeader = (u32)pPager->pageSize;
  u32 nWrite;
  int ii;

  ((void)0);

  if( nHeader>(pPager->sectorSize) ){
    nHeader = (pPager->sectorSize);
  }





  for(ii=0; ii<pPager->nSavepoint; ii++){
    if( pPager->aSavepoint[ii].iHdrOffset==0 ){
      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;
    }
  }

  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);
# 52297 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( pPager->noSync || (pPager->journalMode==4)
   || (sqlite3OsDeviceCharacteristics(pPager->fd)&0x00000200)
  ){
    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
    sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)],0xffffffff);
  }else{
    memset(zHeader, 0, sizeof(aJournalMagic)+4);
  }


  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);
  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+4],pPager->cksumInit);

  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+8],pPager->dbOrigSize);

  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+12],pPager->sectorSize);


  sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)+16],pPager->pageSize);






  memset(&zHeader[sizeof(aJournalMagic)+20], 0,
         nHeader-(sizeof(aJournalMagic)+20));
# 52343 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(nWrite=0; rc==0&&nWrite<(pPager->sectorSize); nWrite+=nHeader){
   
    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);
    ((void)0);
    pPager->journalOff += nHeader;
  }

  return rc;
}
# 52370 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int readJournalHdr(
  Pager *pPager,
  int isHot,
  i64 journalSize,
  u32 *pNRec,
  u32 *pDbSize
){
  int rc;
  unsigned char aMagic[8];
  i64 iHdrOff;

  ((void)0);





  pPager->journalOff = journalHdrOffset(pPager);
  if( pPager->journalOff+(pPager->sectorSize) > journalSize ){
    return 101;
  }
  iHdrOff = pPager->journalOff;






  if( isHot || iHdrOff!=pPager->journalHdr ){
    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);
    if( rc ){
      return rc;
    }
    if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){
      return 101;
    }
  }





  if( 0!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))
   || 0!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))
   || 0!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))
  ){
    return rc;
  }

  if( pPager->journalOff==0 ){
    u32 iPageSize;
    u32 iSectorSize;


    if( 0!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))
     || 0!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))
    ){
      return rc;
    }





    if( iPageSize==0 ){
      iPageSize = pPager->pageSize;
    }






    if( iPageSize<512 || iSectorSize<32
     || iPageSize>65536 || iSectorSize>0x10000
     || ((iPageSize-1)&iPageSize)!=0 || ((iSectorSize-1)&iSectorSize)!=0
    ){





      return 101;
    }





    rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);
    ;







    pPager->sectorSize = iSectorSize;
  }

  pPager->journalOff += (pPager->sectorSize);
  return rc;
}
# 52495 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int writeMasterJournal(Pager *pPager, const char *zMaster){
  int rc;
  int nMaster;
  i64 iHdrOff;
  i64 jrnlSize;
  u32 cksum = 0;

  ((void)0);
  ((void)0);

  if( !zMaster
   || pPager->journalMode==4
   || !((pPager->jfd)->pMethods!=0)
  ){
    return 0;
  }
  pPager->setMaster = 1;
  ((void)0);


  for(nMaster=0; zMaster[nMaster]; nMaster++){
    cksum += zMaster[nMaster];
  }





  if( pPager->fullSync ){
    pPager->journalOff = journalHdrOffset(pPager);
  }
  iHdrOff = pPager->journalOff;




  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, ((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)))))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff+4)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster, nMaster)))
   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster+4, cksum)))
   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8,
                                 iHdrOff+4+nMaster+8)))
  ){
    return rc;
  }
  pPager->journalOff += (nMaster+20);
# 52552 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( 0==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))
   && jrnlSize>pPager->journalOff
  ){
    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);
  }
  return rc;
}




static void pager_reset(Pager *pPager){
  pPager->iDataVersion++;
  sqlite3BackupRestart(pPager->pBackup);
  sqlite3PcacheClear(pPager->pPCache);
}




static u32 sqlite3PagerDataVersion(Pager *pPager){
  return pPager->iDataVersion;
}






static void releaseAllSavepoints(Pager *pPager){
  int ii;
  for(ii=0; ii<pPager->nSavepoint; ii++){
    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
  }
  if( !pPager->exclusiveMode || sqlite3JournalIsInMemory(pPager->sjfd) ){
    sqlite3OsClose(pPager->sjfd);
  }
  sqlite3_free(pPager->aSavepoint);
  pPager->aSavepoint = 0;
  pPager->nSavepoint = 0;
  pPager->nSubRec = 0;
}






static int addToSavepointBitvecs(Pager *pPager, Pgno pgno){
  int ii;
  int rc = 0;

  for(ii=0; ii<pPager->nSavepoint; ii++){
    PagerSavepoint *p = &pPager->aSavepoint[ii];
    if( pgno<=p->nOrig ){
      rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);
      ;
      ((void)0);
    }
  }
  return rc;
}
# 52632 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pager_unlock(Pager *pPager){

  ((void)0)


   ;

  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  releaseAllSavepoints(pPager);

  if( ((pPager)->pWal!=0) ){
    ((void)0);
    sqlite3WalEndReadTransaction(pPager->pWal);
    pPager->eState = 0;
  }else if( !pPager->exclusiveMode ){
    int rc;
    int iDc = ((pPager->fd)->pMethods!=0)?sqlite3OsDeviceCharacteristics(pPager->fd):0;






    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    if( 0==(iDc & 0x00000800)
     || 1!=(pPager->journalMode & 5)
    ){
      sqlite3OsClose(pPager->jfd);
    }






    rc = pagerUnlockDb(pPager, 0);
    if( rc!=0 && pPager->eState==6 ){
      pPager->eLock = (4 +1);
    }





    ((void)0);
    pPager->changeCountDone = 0;
    pPager->eState = 0;
  }






  ((void)0);
  if( pPager->errCode ){
    if( pPager->tempFile==0 ){
      pager_reset(pPager);
      pPager->changeCountDone = 0;
      pPager->eState = 0;
    }else{
      pPager->eState = (((pPager->jfd)->pMethods!=0) ? 0 : 1);
    }
    if( ((pPager)->bUseFetch) ) sqlite3OsUnfetch(pPager->fd, 0, 0);
    pPager->errCode = 0;
    setGetterMethod(pPager);
  }

  pPager->journalOff = 0;
  pPager->journalHdr = 0;
  pPager->setMaster = 0;
}
# 52730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_error(Pager *pPager, int rc){
  int rc2 = rc & 0xff;
  ((void)0);
  ((void)0)



   ;
  if( rc2==13 || rc2==10 ){
    pPager->errCode = rc;
    pPager->eState = 6;
    setGetterMethod(pPager);
  }
  return rc;
}

static int pager_truncate(Pager *pPager, Pgno nPage);
# 52764 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerFlushOnCommit(Pager *pPager, int bCommit){
  if( pPager->tempFile==0 ) return 1;
  if( !bCommit ) return 0;
  if( !((pPager->fd)->pMethods!=0) ) return 0;
  return (sqlite3PCachePercentDirty(pPager->pPCache)>=25);
}
# 52824 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_end_transaction(Pager *pPager, int hasMaster, int bCommit){
  int rc = 0;
  int rc2 = 0;
# 52841 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  ((void)0);
  if( pPager->eState<2 && pPager->eLock<2 ){
    return 0;
  }

  releaseAllSavepoints(pPager);
  ((void)0)

   ;
  if( ((pPager->jfd)->pMethods!=0) ){
    ((void)0);


    if( sqlite3JournalIsInMemory(pPager->jfd) ){

      sqlite3OsClose(pPager->jfd);
    }else if( pPager->journalMode==3 ){
      if( pPager->journalOff==0 ){
        rc = 0;
      }else{
        rc = sqlite3OsTruncate(pPager->jfd, 0);
        if( rc==0 && pPager->fullSync ){





          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
        }
      }
      pPager->journalOff = 0;
    }else if( pPager->journalMode==1
      || (pPager->exclusiveMode && pPager->journalMode!=5)
    ){
      rc = zeroJournalHdr(pPager, hasMaster||pPager->tempFile);
      pPager->journalOff = 0;
    }else{





      int bDelete = !pPager->tempFile;
      ((void)0);
      ((void)0)


       ;
      sqlite3OsClose(pPager->jfd);
      if( bDelete ){
        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, pPager->extraSync);
      }
    }
  }
# 52908 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3BitvecDestroy(pPager->pInJournal);
  pPager->pInJournal = 0;
  pPager->nRec = 0;
  if( rc==0 ){
    if( pPager->memDb || pagerFlushOnCommit(pPager, bCommit) ){
      sqlite3PcacheCleanAll(pPager->pPCache);
    }else{
      sqlite3PcacheClearWritable(pPager->pPCache);
    }
    sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);
  }

  if( ((pPager)->pWal!=0) ){




    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);
    ((void)0);
  }else if( rc==0 && bCommit && pPager->dbFileSize>pPager->dbSize ){






    ((void)0);
    rc = pager_truncate(pPager, pPager->dbSize);
  }

  if( rc==0 && bCommit ){
    rc = sqlite3OsFileControl(pPager->fd, 22, 0);
    if( rc==12 ) rc = 0;
  }

  if( !pPager->exclusiveMode
   && (!((pPager)->pWal!=0) || sqlite3WalExclusiveMode(pPager->pWal, 0))
  ){
    rc2 = pagerUnlockDb(pPager, 1);
    pPager->changeCountDone = 0;
  }
  pPager->eState = 1;
  pPager->setMaster = 0;

  return (rc==0?rc2:rc);
}
# 52972 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pagerUnlockAndRollback(Pager *pPager){
  if( pPager->eState!=6 && pPager->eState!=0 ){
    ((void)0);
    if( pPager->eState>=2 ){
      sqlite3BeginBenignMalloc();
      sqlite3PagerRollback(pPager);
      sqlite3EndBenignMalloc();
    }else if( !pPager->exclusiveMode ){
      ((void)0);
      pager_end_transaction(pPager, 0, 0);
    }
  }
  pager_unlock(pPager);
}
# 53006 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u32 pager_cksum(Pager *pPager, const u8 *aData){
  u32 cksum = pPager->cksumInit;
  int i = pPager->pageSize-200;
  while( i>0 ){
    cksum += aData[i];
    i -= 200;
  }
  return cksum;
}
# 53028 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define pagerReportSize(X) 
# 53082 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_playback_one_page(
  Pager *pPager,
  i64 *pOffset,
  Bitvec *pDone,
  int isMainJrnl,
  int isSavepnt
){
  int rc;
  PgHdr *pPg;
  Pgno pgno;
  u32 cksum;
  char *aData;
  sqlite3_file *jfd;
  int isSynced;






  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  aData = pPager->pTmpSpace;
  ((void)0);
  ((void)0);







  ((void)0)

   ;
  ((void)0);




  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;
  rc = read32bits(jfd, *pOffset, &pgno);
  if( rc!=0 ) return rc;
  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);
  if( rc!=0 ) return rc;
  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;






  if( pgno==0 || pgno==((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)) ){
    ((void)0);
    return 101;
  }
  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){
    return 0;
  }
  if( isMainJrnl ){
    rc = read32bits(jfd, (*pOffset)-4, &cksum);
    if( rc ) return rc;
    if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){
      return 101;
    }
  }




  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=0 ){
    return rc;
  }



  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){
    pPager->nReserve = ((u8*)aData)[20];
    ;
  }
# 53201 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( ((pPager)->pWal!=0) ){
    pPg = 0;
  }else{
    pPg = sqlite3PagerLookup(pPager, pgno);
  }
  ((void)0);
  ((void)0);
 


    ;
  if( isMainJrnl ){
    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);
  }else{
    isSynced = (pPg==0 || 0==(pPg->flags & 0x008));
  }
  if( ((pPager->fd)->pMethods!=0)
   && (pPager->eState>=4 || pPager->eState==0)
   && isSynced
  ){
    i64 ofst = (pgno-1)*(i64)pPager->pageSize;
    ;
    ((void)0);
# 53238 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    rc = sqlite3OsWrite(pPager->fd, (u8 *)aData, pPager->pageSize, ofst);

    if( pgno>pPager->dbFileSize ){
      pPager->dbFileSize = pgno;
    }
    if( pPager->pBackup ){







      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);
    }
  }else if( !isMainJrnl && pPg==0 ){
# 53270 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    ((void)0);
    pPager->doNotSpill |= 0x02;
    rc = sqlite3PagerGet(pPager, pgno, &pPg, 1);
    ((void)0);
    pPager->doNotSpill &= ~0x02;
    if( rc!=0 ) return rc;
    sqlite3PcacheMakeDirty(pPg);
  }
  if( pPg ){






    void *pData;
    pData = pPg->pData;
    memcpy(pData, (u8*)aData, pPager->pageSize);
    pPager->xReiniter(pPg);




    ;



    if( pgno==1 ){
      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));
    }





    sqlite3PcacheRelease(pPg);
  }
  return rc;
}
# 53354 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_delmaster(Pager *pPager, const char *zMaster){
  sqlite3_vfs *pVfs = pPager->pVfs;
  int rc;
  sqlite3_file *pMaster;
  sqlite3_file *pJournal;
  char *zMasterJournal = 0;
  i64 nMasterJournal;
  char *zJournal;
  char *zMasterPtr;
  int nMasterPtr;




  pMaster = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);
  pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile);
  if( !pMaster ){
    rc = 7;
  }else{
    const int flags = (0x00000001|0x00004000);
    rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0);
  }
  if( rc!=0 ) goto delmaster_out;






  rc = sqlite3OsFileSize(pMaster, &nMasterJournal);
  if( rc!=0 ) goto delmaster_out;
  nMasterPtr = pVfs->mxPathname+1;
  zMasterJournal = sqlite3Malloc(nMasterJournal + nMasterPtr + 1);
  if( !zMasterJournal ){
    rc = 7;
    goto delmaster_out;
  }
  zMasterPtr = &zMasterJournal[nMasterJournal+1];
  rc = sqlite3OsRead(pMaster, zMasterJournal, (int)nMasterJournal, 0);
  if( rc!=0 ) goto delmaster_out;
  zMasterJournal[nMasterJournal] = 0;

  zJournal = zMasterJournal;
  while( (zJournal-zMasterJournal)<nMasterJournal ){
    int exists;
    rc = sqlite3OsAccess(pVfs, zJournal, 0, &exists);
    if( rc!=0 ){
      goto delmaster_out;
    }
    if( exists ){




      int c;
      int flags = (0x00000001|0x00000800);
      rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);
      if( rc!=0 ){
        goto delmaster_out;
      }

      rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr);
      sqlite3OsClose(pJournal);
      if( rc!=0 ){
        goto delmaster_out;
      }

      c = zMasterPtr[0]!=0 && strcmp(zMasterPtr, zMaster)==0;
      if( c ){

        goto delmaster_out;
      }
    }
    zJournal += (sqlite3Strlen30(zJournal)+1);
  }

  sqlite3OsClose(pMaster);
  rc = sqlite3OsDelete(pVfs, zMaster, 0);

delmaster_out:
  sqlite3_free(zMasterJournal);
  if( pMaster ){
    sqlite3OsClose(pMaster);
    ((void)0);
    sqlite3_free(pMaster);
  }
  return rc;
}
# 53464 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_truncate(Pager *pPager, Pgno nPage){
  int rc = 0;
  ((void)0);
  ((void)0);

  if( ((pPager->fd)->pMethods!=0)
   && (pPager->eState>=4 || pPager->eState==0)
  ){
    i64 currentSize, newSize;
    int szPage = pPager->pageSize;
    ((void)0);

    rc = sqlite3OsFileSize(pPager->fd, &currentSize);
    newSize = szPage*(i64)nPage;
    if( rc==0 && currentSize!=newSize ){
      if( currentSize>newSize ){
        rc = sqlite3OsTruncate(pPager->fd, newSize);
      }else if( (currentSize+szPage)<=newSize ){
        char *pTmp = pPager->pTmpSpace;
        memset(pTmp, 0, szPage);
        ;
        ;
        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);
      }
      if( rc==0 ){
        pPager->dbFileSize = nPage;
      }
    }
  }
  return rc;
}





static int sqlite3SectorSize(sqlite3_file *pFile){
  int iRet = sqlite3OsSectorSize(pFile);
  if( iRet<32 ){
    iRet = 512;
  }else if( iRet>0x10000 ){
    ((void)0);
    iRet = 0x10000;
  }
  return iRet;
}
# 53534 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void setSectorSize(Pager *pPager){
  ((void)0);

  if( pPager->tempFile
   || (sqlite3OsDeviceCharacteristics(pPager->fd) &
              0x00001000)!=0
  ){



    pPager->sectorSize = 512;
  }else{
    pPager->sectorSize = sqlite3SectorSize(pPager->fd);
  }
}
# 53607 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_playback(Pager *pPager, int isHot){
  sqlite3_vfs *pVfs = pPager->pVfs;
  i64 szJ;
  u32 nRec;
  u32 u;
  Pgno mxPg = 0;
  int rc;
  int res = 1;
  char *zMaster = 0;
  int needPagerReset;
  int nPlayback = 0;
  u32 savedPageSize = pPager->pageSize;




  ((void)0);
  rc = sqlite3OsFileSize(pPager->jfd, &szJ);
  if( rc!=0 ){
    goto end_playback;
  }
# 53640 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  zMaster = pPager->pTmpSpace;
  rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);
  if( rc==0 && zMaster[0] ){
    rc = sqlite3OsAccess(pVfs, zMaster, 0, &res);
  }
  zMaster = 0;
  if( rc!=0 || !res ){
    goto end_playback;
  }
  pPager->journalOff = 0;
  needPagerReset = isHot;





  while( 1 ){





    rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);
    if( rc!=0 ){
      if( rc==101 ){
        rc = 0;
      }
      goto end_playback;
    }






    if( nRec==0xffffffff ){
      ((void)0);
      nRec = (int)((szJ - (pPager->sectorSize))/((pPager->pageSize) + 8));
    }
# 53694 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( nRec==0 && !isHot &&
        pPager->journalHdr+(pPager->sectorSize)==pPager->journalOff ){
      nRec = (int)((szJ - pPager->journalOff) / ((pPager->pageSize) + 8));
    }




    if( pPager->journalOff==(pPager->sectorSize) ){
      rc = pager_truncate(pPager, mxPg);
      if( rc!=0 ){
        goto end_playback;
      }
      pPager->dbSize = mxPg;
    }




    for(u=0; u<nRec; u++){
      if( needPagerReset ){
        pager_reset(pPager);
        needPagerReset = 0;
      }
      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);
      if( rc==0 ){
        nPlayback++;
      }else{
        if( rc==101 ){
          pPager->journalOff = szJ;
          break;
        }else if( rc==(10 | (2<<8)) ){





          rc = 0;
          goto end_playback;
        }else{





          goto end_playback;
        }
      }
    }
  }

  ((void)0);

end_playback:
  if( rc==0 ){
    rc = sqlite3PagerSetPagesize(pPager, &savedPageSize, -1);
  }
# 53769 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pPager->changeCountDone = pPager->tempFile;

  if( rc==0 ){
    zMaster = pPager->pTmpSpace;
    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);
    ;
  }
  if( rc==0
   && (pPager->eState>=4 || pPager->eState==0)
  ){
    rc = sqlite3PagerSync(pPager, 0);
  }
  if( rc==0 ){
    rc = pager_end_transaction(pPager, zMaster[0]!='\0', 0);
    ;
  }
  if( rc==0 && zMaster[0] && res ){



    rc = pager_delmaster(pPager, zMaster);
    ;
  }
  if( isHot && nPlayback ){
    sqlite3_log((27 | (2<<8)), "recovered %d pages from %s",
                nPlayback, pPager->zJournal);
  }





  setSectorSize(pPager);
  return rc;
}
# 53818 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int readDbPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  int rc = 0;


  u32 iFrame = 0;

  ((void)0);
  ((void)0);

  if( ((pPager)->pWal!=0) ){
    rc = sqlite3WalFindFrame(pPager->pWal, pPg->pgno, &iFrame);
    if( rc ) return rc;
  }
  if( iFrame ){
    rc = sqlite3WalReadFrame(pPager->pWal, iFrame,pPager->pageSize,pPg->pData);
  }else

  {
    i64 iOffset = (pPg->pgno-1)*(i64)pPager->pageSize;
    rc = sqlite3OsRead(pPager->fd, pPg->pData, pPager->pageSize, iOffset);
    if( rc==(10 | (2<<8)) ){
      rc = 0;
    }
  }

  if( pPg->pgno==1 ){
    if( rc ){
# 53858 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));
    }else{
      u8 *dbFileVers = &((u8*)pPg->pData)[24];
      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));
    }
  }
  ;

  ;
  ;
  ;
 
                                                                ;

  return rc;
}
# 53883 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pager_write_changecounter(PgHdr *pPg){
  u32 change_counter;


  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;
  sqlite3Put4byte((u8*)((char*)pPg->pData)+24,change_counter);




  sqlite3Put4byte((u8*)((char*)pPg->pData)+92,change_counter);
  sqlite3Put4byte((u8*)((char*)pPg->pData)+96,3030001);
}
# 53910 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerUndoCallback(void *pCtx, Pgno iPg){
  int rc = 0;
  Pager *pPager = (Pager *)pCtx;
  PgHdr *pPg;

  ((void)0);
  pPg = sqlite3PagerLookup(pPager, iPg);
  if( pPg ){
    if( sqlite3PcachePageRefcount(pPg)==1 ){
      sqlite3PcacheDrop(pPg);
    }else{
      rc = readDbPage(pPg);
      if( rc==0 ){
        pPager->xReiniter(pPg);
      }
      sqlite3PagerUnrefNotNull(pPg);
    }
  }
# 53937 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3BackupRestart(pPager->pBackup);

  return rc;
}




static int pagerRollbackWal(Pager *pPager){
  int rc;
  PgHdr *pList;
# 53956 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pPager->dbSize = pPager->dbOrigSize;
  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);
  pList = sqlite3PcacheDirtyList(pPager->pPCache);
  while( pList && rc==0 ){
    PgHdr *pNext = pList->pDirty;
    rc = pagerUndoCallback((void *)pPager, pList->pgno);
    pList = pNext;
  }

  return rc;
}
# 53977 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerWalFrames(
  Pager *pPager,
  PgHdr *pList,
  Pgno nTruncate,
  int isCommit
){
  int rc;
  int nList;
  PgHdr *p;

  ((void)0);
  ((void)0);







  ((void)0);
  if( isCommit ){




    PgHdr **ppNext = &pList;
    nList = 0;
    for(p=pList; (*ppNext = p)!=0; p=p->pDirty){
      if( p->pgno<=nTruncate ){
        ppNext = &p->pDirty;
        nList++;
      }
    }
    ((void)0);
  }else{
    nList = 1;
  }
  pPager->aStat[2] += nList;

  if( pList->pgno==1 ) pager_write_changecounter(pList);
  rc = sqlite3WalFrames(pPager->pWal,
      pPager->pageSize, pList, nTruncate, isCommit, pPager->walSyncFlags
  );
  if( rc==0 && pPager->pBackup ){
    for(p=pList; p; p=p->pDirty){
      sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);
    }
  }
# 54033 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return rc;
}
# 54044 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerBeginReadTransaction(Pager *pPager){
  int rc;
  int changed = 0;

  ((void)0);
  ((void)0);






  sqlite3WalEndReadTransaction(pPager->pWal);

  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);
  if( rc!=0 || changed ){
    pager_reset(pPager);
    if( ((pPager)->bUseFetch) ) sqlite3OsUnfetch(pPager->fd, 0, 0);
  }

  return rc;
}
# 54077 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerPagecount(Pager *pPager, Pgno *pnPage){
  Pgno nPage;







  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  nPage = sqlite3WalDbsize(pPager->pWal);






  if( nPage==0 && (((pPager->fd)->pMethods!=0)) ){
    i64 n = 0;
    int rc = sqlite3OsFileSize(pPager->fd, &n);
    if( rc!=0 ){
      return rc;
    }
    nPage = (Pgno)((n+pPager->pageSize-1) / pPager->pageSize);
  }





  if( nPage>pPager->mxPgno ){
    pPager->mxPgno = (Pgno)nPage;
  }

  *pnPage = nPage;
  return 0;
}
# 54137 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerOpenWalIfPresent(Pager *pPager){
  int rc = 0;
  ((void)0);
  ((void)0);

  if( !pPager->tempFile ){
    int isWal;
    rc = sqlite3OsAccess(
        pPager->pVfs, pPager->zWal, 0, &isWal
    );
    if( rc==0 ){
      if( isWal ){
        Pgno nPage;

        rc = pagerPagecount(pPager, &nPage);
        if( rc ) return rc;
        if( nPage==0 ){
          rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);
        }else{
          ;
          rc = sqlite3PagerOpenWal(pPager, 0);
        }
      }else if( pPager->journalMode==5 ){
        pPager->journalMode = 0;
      }
    }
  }
  return rc;
}
# 54204 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){
  i64 szJ;
  i64 iHdrOff;
  int rc = 0;
  Bitvec *pDone = 0;

  ((void)0);
  ((void)0);


  if( pSavepoint ){
    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);
    if( !pDone ){
      return 7;
    }
  }




  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;
  pPager->changeCountDone = pPager->tempFile;

  if( !pSavepoint && ((pPager)->pWal!=0) ){
    return pagerRollbackWal(pPager);
  }






  szJ = pPager->journalOff;
  ((void)0);
# 54246 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pSavepoint && !((pPager)->pWal!=0) ){
    iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;
    pPager->journalOff = pSavepoint->iOffset;
    while( rc==0 && pPager->journalOff<iHdrOff ){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    }
    ((void)0);
  }else{
    pPager->journalOff = 0;
  }






  while( rc==0 && pPager->journalOff<szJ ){
    u32 ii;
    u32 nJRec = 0;
    u32 dummy;
    rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);
    ((void)0);






    if( nJRec==0
     && pPager->journalHdr+(pPager->sectorSize)==pPager->journalOff
    ){
      nJRec = (u32)((szJ - pPager->journalOff)/((pPager->pageSize) + 8));
    }
    for(ii=0; rc==0 && ii<nJRec && pPager->journalOff<szJ; ii++){
      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);
    }
    ((void)0);
  }
  ((void)0);





  if( pSavepoint ){
    u32 ii;
    i64 offset = (i64)pSavepoint->iSubRec*(4+pPager->pageSize);

    if( ((pPager)->pWal!=0) ){
      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);
    }
    for(ii=pSavepoint->iSubRec; rc==0 && ii<pPager->nSubRec; ii++){
      ((void)0);
      rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);
    }
    ((void)0);
  }

  sqlite3BitvecDestroy(pDone);
  if( rc==0 ){
    pPager->journalOff = szJ;
  }

  return rc;
}





static void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){
  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);
}





static int sqlite3PagerSetSpillsize(Pager *pPager, int mxPage){
  return sqlite3PcacheSetSpillsize(pPager->pPCache, mxPage);
}




static void pagerFixMaplimit(Pager *pPager){

  sqlite3_file *fd = pPager->fd;
  if( ((fd)->pMethods!=0) && fd->pMethods->iVersion>=3 ){
    sqlite3_int64 sz;
    sz = pPager->szMmap;
    pPager->bUseFetch = (sz>0);
    setGetterMethod(pPager);
    sqlite3OsFileControlHint(pPager->fd, 18, &sz);
  }

}




static void sqlite3PagerSetMmapLimit(Pager *pPager, sqlite3_int64 szMmap){
  pPager->szMmap = szMmap;
  pagerFixMaplimit(pPager);
}




static void sqlite3PagerShrink(Pager *pPager){
  sqlite3PcacheShrink(pPager->pPCache);
}
# 54411 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerSetFlags(
  Pager *pPager,
  unsigned pgFlags
){
  unsigned level = pgFlags & 0x07;
  if( pPager->tempFile ){
    pPager->noSync = 1;
    pPager->fullSync = 0;
    pPager->extraSync = 0;
  }else{
    pPager->noSync = level==0x01 ?1:0;
    pPager->fullSync = level>=0x03 ?1:0;
    pPager->extraSync = level==0x04 ?1:0;
  }
  if( pPager->noSync ){
    pPager->syncFlags = 0;
  }else if( pgFlags & 0x08 ){
    pPager->syncFlags = 0x00003;
  }else{
    pPager->syncFlags = 0x00002;
  }
  pPager->walSyncFlags = (pPager->syncFlags<<2);
  if( pPager->fullSync ){
    pPager->walSyncFlags |= pPager->syncFlags;
  }
  if( (pgFlags & 0x10) && !pPager->noSync ){
    pPager->walSyncFlags |= (0x00003<<2);
  }
  if( pgFlags & 0x20 ){
    pPager->doNotSpill &= ~0x01;
  }else{
    pPager->doNotSpill |= 0x01;
  }
}
# 54471 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerOpentemp(
  Pager *pPager,
  sqlite3_file *pFile,
  int vfsFlags
){
  int rc;





  vfsFlags |= 0x00000002 | 0x00000004 |
            0x00000010 | 0x00000008;
  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);
  ((void)0);
  return rc;
}
# 54510 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerSetBusyHandler(
  Pager *pPager,
  int (*xBusyHandler)(void *),
  void *pBusyHandlerArg
){
  void **ap;
  pPager->xBusyHandler = xBusyHandler;
  pPager->pBusyHandlerArg = pBusyHandlerArg;
  ap = (void **)&pPager->xBusyHandler;
  ((void)0);
  ((void)0);
  sqlite3OsFileControlHint(pPager->fd, 15, (void *)ap);
}
# 54554 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){
  int rc = 0;
# 54567 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  u32 pageSize = *pPageSize;
  ((void)0);
  if( (pPager->memDb==0 || pPager->dbSize==0)
   && sqlite3PcacheRefCount(pPager->pPCache)==0
   && pageSize && pageSize!=(u32)pPager->pageSize
  ){
    char *pNew = ((void *)0);
    i64 nByte = 0;

    if( pPager->eState>0 && ((pPager->fd)->pMethods!=0) ){
      rc = sqlite3OsFileSize(pPager->fd, &nByte);
    }
    if( rc==0 ){


      pNew = (char *)sqlite3PageMalloc(pageSize+8);
      if( !pNew ){
        rc = 7;
      }else{
        memset(pNew+pageSize, 0, 8);
      }
    }

    if( rc==0 ){
      pager_reset(pPager);
      rc = sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);
    }
    if( rc==0 ){
      sqlite3PageFree(pPager->pTmpSpace);
      pPager->pTmpSpace = pNew;
      pPager->dbSize = (Pgno)((nByte+pageSize-1)/pageSize);
      pPager->pageSize = pageSize;
    }else{
      sqlite3PageFree(pNew);
    }
  }

  *pPageSize = pPager->pageSize;
  if( rc==0 ){
    if( nReserve<0 ) nReserve = pPager->nReserve;
    ((void)0);
    pPager->nReserve = (i16)nReserve;
    ;
    pagerFixMaplimit(pPager);
  }
  return rc;
}
# 54623 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3PagerTempSpace(Pager *pPager){
  return pPager->pTmpSpace;
}
# 54634 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){
  if( mxPage>0 ){
    pPager->mxPgno = mxPage;
  }
  ((void)0);




  return pPager->mxPgno;
}
# 54666 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define disable_simulated_io_errors() 
#define enable_simulated_io_errors() 
# 54684 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){
  int rc = 0;
  memset(pDest, 0, N);
  ((void)0);





  ((void)0);

  if( ((pPager->fd)->pMethods!=0) ){
   
    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);
    if( rc==(10 | (2<<8)) ){
      rc = 0;
    }
  }
  return rc;
}
# 54712 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerPagecount(Pager *pPager, int *pnPage){
  ((void)0);
  ((void)0);
  *pnPage = (int)pPager->dbSize;
}
# 54733 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_wait_on_lock(Pager *pPager, int locktype){
  int rc;






  ((void)0)


   ;

  do {
    rc = pagerLockDb(pPager, locktype);
  }while( rc==5 && pPager->xBusyHandler(pPager->pBusyHandlerArg) );
  return rc;
}
# 54783 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define assertTruncateConstraint(pPager) 
# 54797 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){
  ((void)0);
  ((void)0);
  pPager->dbSize = nPage;
# 54811 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
# 54828 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerSyncHotJournal(Pager *pPager){
  int rc = 0;
  if( !pPager->noSync ){
    rc = sqlite3OsSync(pPager->jfd, 0x00002);
  }
  if( rc==0 ){
    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);
  }
  return rc;
}
# 54850 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerAcquireMapPage(
  Pager *pPager,
  Pgno pgno,
  void *pData,
  PgHdr **ppPage
){
  PgHdr *p;

  if( pPager->pMmapFreelist ){
    *ppPage = p = pPager->pMmapFreelist;
    pPager->pMmapFreelist = p->pDirty;
    p->pDirty = 0;
    ((void)0);
    memset(p->pExtra, 0, 8);
  }else{
    *ppPage = p = (PgHdr *)sqlite3MallocZero(sizeof(PgHdr) + pPager->nExtra);
    if( p==0 ){
      sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1) * pPager->pageSize, pData);
      return 7;
    }
    p->pExtra = (void *)&p[1];
    p->flags = 0x020;
    p->nRef = 1;
    p->pPager = pPager;
  }

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  p->pgno = pgno;
  p->pData = pData;
  pPager->nMmapOut++;

  return 0;
}






static void pagerReleaseMapPage(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  pPager->nMmapOut--;
  pPg->pDirty = pPager->pMmapFreelist;
  pPager->pMmapFreelist = pPg;

  ((void)0);
  sqlite3OsUnfetch(pPager->fd, (i64)(pPg->pgno-1)*pPager->pageSize, pPg->pData);
}




static void pagerFreeMapHdrs(Pager *pPager){
  PgHdr *p;
  PgHdr *pNext;
  for(p=pPager->pMmapFreelist; p; p=pNext){
    pNext = p->pDirty;
    sqlite3_free(p);
  }
}






static int databaseIsUnmoved(Pager *pPager){
  int bHasMoved = 0;
  int rc;

  if( pPager->tempFile ) return 0;
  if( pPager->dbSize==0 ) return 0;
  ((void)0);
  rc = sqlite3OsFileControl(pPager->fd, 20, &bHasMoved);
  if( rc==12 ){



    rc = 0;
  }else if( rc==0 && bHasMoved ){
    rc = (8 | (4<<8));
  }
  return rc;
}
# 54955 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerClose(Pager *pPager, sqlite3 *db){
  u8 *pTmp = (u8*)pPager->pTmpSpace;
  ((void)0);
  ((void)0);
  ;
  sqlite3BeginBenignMalloc();
  pagerFreeMapHdrs(pPager);

  pPager->exclusiveMode = 0;

  {
    u8 *a = 0;
    ((void)0);
    if( db && 0==(db->flags & 0x00000800)
     && 0==databaseIsUnmoved(pPager)
    ){
      a = pTmp;
    }
    sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags, pPager->pageSize,a);
    pPager->pWal = 0;
  }

  pager_reset(pPager);
  if( pPager->memDb ){
    pager_unlock(pPager);
  }else{
# 54992 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( ((pPager->jfd)->pMethods!=0) ){
      pager_error(pPager, pagerSyncHotJournal(pPager));
    }
    pagerUnlockAndRollback(pPager);
  }
  sqlite3EndBenignMalloc();
  ;
  ;
 
  sqlite3OsClose(pPager->jfd);
  sqlite3OsClose(pPager->fd);
  sqlite3PageFree(pTmp);
  sqlite3PcacheClose(pPager->pPCache);





  ((void)0);
  ((void)0);

  sqlite3_free(pPager);
  return 0;
}
# 55029 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerRef(DbPage *pPg){
  sqlite3PcacheRef(pPg);
}
# 55068 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int syncJournal(Pager *pPager, int newHdr){
  int rc;

  ((void)0)

   ;
  ((void)0);
  ((void)0);

  rc = sqlite3PagerExclusiveLock(pPager);
  if( rc!=0 ) return rc;

  if( !pPager->noSync ){
    ((void)0);
    if( ((pPager->jfd)->pMethods!=0) && pPager->journalMode!=4 ){
      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
      ((void)0);

      if( 0==(iDc&0x00000200) ){
# 55109 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        i64 iNextHdrOffset;
        u8 aMagic[8];
        u8 zHeader[sizeof(aJournalMagic)+4];

        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));
        sqlite3Put4byte((u8*)&zHeader[sizeof(aJournalMagic)],pPager->nRec);

        iNextHdrOffset = journalHdrOffset(pPager);
        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);
        if( rc==0 && 0==memcmp(aMagic, aJournalMagic, 8) ){
          static const u8 zerobyte = 0;
          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);
        }
        if( rc!=0 && rc!=(10 | (2<<8)) ){
          return rc;
        }
# 55137 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        if( pPager->fullSync && 0==(iDc&0x00000400) ){
          ;
         
          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);
          if( rc!=0 ) return rc;
        }
        ;
        rc = sqlite3OsWrite(
            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr
        );
        if( rc!=0 ) return rc;
      }
      if( 0==(iDc&0x00000400) ){
        ;
       
        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags|
          (pPager->syncFlags==0x00003?0x00010:0)
        );
        if( rc!=0 ) return rc;
      }

      pPager->journalHdr = pPager->journalOff;
      if( newHdr && 0==(iDc&0x00000200) ){
        pPager->nRec = 0;
        rc = writeJournalHdr(pPager);
        if( rc!=0 ) return rc;
      }
    }else{
      pPager->journalHdr = pPager->journalOff;
    }
  }





  sqlite3PcacheClearSyncFlags(pPager->pPCache);
  pPager->eState = 4;
  ((void)0);
  return 0;
}
# 55211 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_write_pagelist(Pager *pPager, PgHdr *pList){
  int rc = 0;


  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);





  if( !((pPager->fd)->pMethods!=0) ){
    ((void)0);
    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);
  }




  ((void)0);
  if( rc==0
   && pPager->dbHintSize<pPager->dbSize
   && (pList->pDirty || pList->pgno>pPager->dbHintSize)
  ){
    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;
    sqlite3OsFileControlHint(pPager->fd, 5, &szFile);
    pPager->dbHintSize = pPager->dbSize;
  }

  while( rc==0 && pList ){
    Pgno pgno = pList->pgno;
# 55253 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pgno<=pPager->dbSize && 0==(pList->flags&0x010) ){
      i64 offset = (pgno-1)*(i64)pPager->pageSize;
      char *pData;

      ((void)0);
      if( pList->pgno==1 ) pager_write_changecounter(pList);


      pData=(char*)pList->pData;


      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);





      if( pgno==1 ){
        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));
      }
      if( pgno>pPager->dbFileSize ){
        pPager->dbFileSize = pgno;
      }
      pPager->aStat[2]++;


      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);

     
                                                                 ;
      ;
      ;
    }else{
      ;
    }
    ;
    pList = pList->pDirty;
  }

  return rc;
}
# 55303 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int openSubJournal(Pager *pPager){
  int rc = 0;
  if( !((pPager->sjfd)->pMethods!=0) ){
    const int flags = 0x00002000 | 0x00000002
      | 0x00000004 | 0x00000010
      | 0x00000008;
    int nStmtSpill = sqlite3Config.nStmtSpill;
    if( pPager->journalMode==4 || pPager->subjInMemory ){
      nStmtSpill = -1;
    }
    rc = sqlite3JournalOpen(pPager->pVfs, 0, pPager->sjfd, flags, nStmtSpill);
  }
  return rc;
}
# 55329 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int subjournalPage(PgHdr *pPg){
  int rc = 0;
  Pager *pPager = pPg->pPager;
  if( pPager->journalMode!=2 ){


    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0)


     ;
    rc = openSubJournal(pPager);



    if( rc==0 ){
      void *pData = pPg->pData;
      i64 offset = (i64)pPager->nSubRec*(4+pPager->pageSize);
      char *pData2;






      pData2 = pData;
      ;
      rc = write32bits(pPager->sjfd, offset, pPg->pgno);
      if( rc==0 ){
        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);
      }
    }
  }
  if( rc==0 ){
    pPager->nSubRec++;
    ((void)0);
    rc = addToSavepointBitvecs(pPager, pPg->pgno);
  }
  return rc;
}
static int subjournalPageIfRequired(PgHdr *pPg){
  if( subjRequiresPage(pPg) ){
    return subjournalPage(pPg);
  }else{
    return 0;
  }
}
# 55398 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pagerStress(void *p, PgHdr *pPg){
  Pager *pPager = (Pager *)p;
  int rc = 0;

  ((void)0);
  ((void)0);
# 55421 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (pPager->errCode) ) return 0;
  ;
  ;
  ;
  if( pPager->doNotSpill
   && ((pPager->doNotSpill & (0x02|0x01))!=0
      || (pPg->flags & 0x008)!=0)
  ){
    return 0;
  }

  pPager->aStat[3]++;
  pPg->pDirty = 0;
  if( ((pPager)->pWal!=0) ){

    rc = subjournalPageIfRequired(pPg);
    if( rc==0 ){
      rc = pagerWalFrames(pPager, pPg, 0, 0);
    }
  }else{
# 55450 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pPg->flags&0x008
     || pPager->eState==3
    ){
      rc = syncJournal(pPager, 1);
    }


    if( rc==0 ){
      ((void)0);
      rc = pager_write_pagelist(pPager, pPg);
    }
  }


  if( rc==0 ){
    ;
    sqlite3PcacheMakeClean(pPg);
  }

  return pager_error(pPager, rc);
}




static int sqlite3PagerFlush(Pager *pPager){
  int rc = pPager->errCode;
  if( !pPager->memDb ){
    PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);
    ((void)0);
    while( rc==0 && pList ){
      PgHdr *pNext = pList->pDirty;
      if( pList->nRef==0 ){
        rc = pagerStress((void*)pPager, pList);
      }
      pList = pNext;
    }
  }

  return rc;
}
# 55524 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerOpen(
  sqlite3_vfs *pVfs,
  Pager **ppPager,
  const char *zFilename,
  int nExtra,
  int flags,
  int vfsFlags,
  void (*xReinit)(DbPage*)
){
  u8 *pPtr;
  Pager *pPager = 0;
  int rc = 0;
  int tempFile = 0;
  int memDb = 0;



#define memJM 0

  int readOnly = 0;
  int journalFileSize;
  char *zPathname = 0;
  int nPathname = 0;
  int useJournal = (flags & 0x0001)==0;
  int pcacheSize = sqlite3PcacheSize();
  u32 szPageDflt = 4096;
  const char *zUri = 0;
  int nUri = 0;



  journalFileSize = (((sqlite3JournalSize(pVfs))+7)&~7);


  *ppPager = 0;


  if( flags & 0x0002 ){
    memDb = 1;
    if( zFilename && zFilename[0] ){
      zPathname = sqlite3DbStrDup(0, zFilename);
      if( zPathname==0 ) return 7;
      nPathname = sqlite3Strlen30(zPathname);
      zFilename = 0;
    }
  }






  if( zFilename && zFilename[0] ){
    const char *z;
    nPathname = pVfs->mxPathname+1;
    zPathname = sqlite3DbMallocRaw(0, nPathname*2);
    if( zPathname==0 ){
      return 7;
    }
    zPathname[0] = 0;
    rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);
    nPathname = sqlite3Strlen30(zPathname);
    z = zUri = &zFilename[sqlite3Strlen30(zFilename)+1];
    while( *z ){
      z += sqlite3Strlen30(z)+1;
      z += sqlite3Strlen30(z)+1;
    }
    nUri = (int)(&z[1] - zUri);
    ((void)0);
    if( rc==0 && nPathname+8>pVfs->mxPathname ){






      rc = sqlite3CantopenError(55600);
    }
    if( rc!=0 ){
      sqlite3DbFree(0, zPathname);
      return rc;
    }
  }
# 55620 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pPtr = (u8 *)sqlite3MallocZero(
    (((sizeof(*pPager))+7)&~7) +
    (((pcacheSize)+7)&~7) +
    (((pVfs->szOsFile)+7)&~7) +
    journalFileSize * 2 +
    nPathname + 1 + nUri +
    nPathname + 8 + 2

    + nPathname + 4 + 2

  );
  ((void)0);
  if( !pPtr ){
    sqlite3DbFree(0, zPathname);
    return 7;
  }
  pPager = (Pager*)(pPtr);
  pPager->pPCache = (PCache*)(pPtr += (((sizeof(*pPager))+7)&~7));
  pPager->fd = (sqlite3_file*)(pPtr += (((pcacheSize)+7)&~7));
  pPager->sjfd = (sqlite3_file*)(pPtr += (((pVfs->szOsFile)+7)&~7));
  pPager->jfd = (sqlite3_file*)(pPtr += journalFileSize);
  pPager->zFilename = (char*)(pPtr += journalFileSize);
  ((void)0);


  if( zPathname ){
    ((void)0);
    pPager->zJournal = (char*)(pPtr += nPathname + 1 + nUri);
    memcpy(pPager->zFilename, zPathname, nPathname);
    if( nUri ) memcpy(&pPager->zFilename[nPathname+1], zUri, nUri);
    memcpy(pPager->zJournal, zPathname, nPathname);
    memcpy(&pPager->zJournal[nPathname], "-journal\000", 8+2);
    ;

    pPager->zWal = &pPager->zJournal[nPathname+8+1];
    memcpy(pPager->zWal, zPathname, nPathname);
    memcpy(&pPager->zWal[nPathname], "-wal\000", 4+1);
    ;

    sqlite3DbFree(0, zPathname);
  }
  pPager->pVfs = pVfs;
  pPager->vfsFlags = vfsFlags;



  if( zFilename && zFilename[0] ){
    int fout = 0;
    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);
    ((void)0);



    readOnly = (fout&0x00000001)!=0;
# 55683 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( rc==0 ){
      int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);
      if( !readOnly ){
        setSectorSize(pPager);
        ((void)0);
        if( szPageDflt<pPager->sectorSize ){
          if( pPager->sectorSize>8192 ){
            szPageDflt = 8192;
          }else{
            szPageDflt = (u32)pPager->sectorSize;
          }
        }
# 55708 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      }
      pPager->noLock = sqlite3_uri_boolean(zFilename, "nolock", 0);
      if( (iDc & 0x00002000)!=0
       || sqlite3_uri_boolean(zFilename, "immutable", 0) ){
          vfsFlags |= 0x00000001;
          goto act_like_temp_file;
      }
    }
  }else{
# 55727 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
act_like_temp_file:
    tempFile = 1;
    pPager->eState = 1;
    pPager->eLock = 4;
    pPager->noLock = 1;
    readOnly = (vfsFlags&0x00000001);
  }




  if( rc==0 ){
    ((void)0);
    rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);
    ;
  }


  if( rc==0 ){
    nExtra = (((nExtra)+7)&~7);
    ((void)0);
    rc = sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,
                       !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);
  }



  if( rc!=0 ){
    sqlite3OsClose(pPager->fd);
    sqlite3PageFree(pPager->pTmpSpace);
    sqlite3_free(pPager);
    return rc;
  }

  ;
 

  pPager->useJournal = (u8)useJournal;






  pPager->mxPgno = 1073741823;


  pPager->tempFile = (u8)tempFile;
  ((void)0)
                                                    ;
  ((void)0);
  pPager->exclusiveMode = (u8)tempFile;
  pPager->changeCountDone = pPager->tempFile;
  pPager->memDb = (u8)memDb;
  pPager->readOnly = (u8)readOnly;
  ((void)0);
  pPager->noSync = pPager->tempFile;
  if( pPager->noSync ){
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
  }else{
    pPager->fullSync = 1;
    pPager->extraSync = 0;
    pPager->syncFlags = 0x00002;
    pPager->walSyncFlags = 0x00002 | (0x00002<<2);
  }



  pPager->nExtra = (u16)nExtra;
  pPager->journalSizeLimit = -1;
  ((void)0);
  setSectorSize(pPager);
  if( !useJournal ){
    pPager->journalMode = 2;
  }else if( memDb || 0 ){
    pPager->journalMode = 4;
  }


  pPager->xReiniter = xReinit;
  setGetterMethod(pPager);



  *ppPager = pPager;
  return 0;
}
# 55851 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int hasHotJournal(Pager *pPager, int *pExists){
  sqlite3_vfs * const pVfs = pPager->pVfs;
  int rc = 0;
  int exists = 1;
  int jrnlOpen = !!((pPager->jfd)->pMethods!=0);

  ((void)0);
  ((void)0);
  ((void)0);

  ((void)0)

    ;

  *pExists = 0;
  if( !jrnlOpen ){
    rc = sqlite3OsAccess(pVfs, pPager->zJournal, 0, &exists);
  }
  if( rc==0 && exists ){
    int locked = 0;
# 55880 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);
    if( rc==0 && !locked ){
      Pgno nPage;

      ((void)0);
      rc = pagerPagecount(pPager, &nPage);
      if( rc==0 ){
# 55895 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        if( nPage==0 && !jrnlOpen ){
          sqlite3BeginBenignMalloc();
          if( pagerLockDb(pPager, 2)==0 ){
            sqlite3OsDelete(pVfs, pPager->zJournal, 0);
            if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, 1);
          }
          sqlite3EndBenignMalloc();
        }else{






          if( !jrnlOpen ){
            int f = 0x00000001|0x00000800;
            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);
          }
          if( rc==0 ){
            u8 first = 0;
            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);
            if( rc==(10 | (2<<8)) ){
              rc = 0;
            }
            if( !jrnlOpen ){
              sqlite3OsClose(pPager->jfd);
            }
            *pExists = (first!=0);
          }else if( rc==14 ){
# 55933 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
            *pExists = 1;
            rc = 0;
          }
        }
      }
    }
  }

  return rc;
}
# 55971 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerSharedLock(Pager *pPager){
  int rc = 0;





  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( !((pPager)->pWal!=0) && pPager->eState==0 ){
    int bHotJournal = 1;

    ((void)0);
    ((void)0);

    rc = pager_wait_on_lock(pPager, 1);
    if( rc!=0 ){
      ((void)0);
      goto failed;
    }




    if( pPager->eLock<=1 ){
      rc = hasHotJournal(pPager, &bHotJournal);
    }
    if( rc!=0 ){
      goto failed;
    }
    if( bHotJournal ){
      if( pPager->readOnly ){
        rc = (8 | (3<<8));
        goto failed;
      }
# 56025 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      rc = pagerLockDb(pPager, 4);
      if( rc!=0 ){
        goto failed;
      }
# 56043 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( !((pPager->jfd)->pMethods!=0) ){
        sqlite3_vfs * const pVfs = pPager->pVfs;
        int bExists;
        rc = sqlite3OsAccess(
            pVfs, pPager->zJournal, 0, &bExists);
        if( rc==0 && bExists ){
          int fout = 0;
          int f = 0x00000002|0x00000800;
          ((void)0);
          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);
          ((void)0);
          if( rc==0 && fout&0x00000001 ){
            rc = sqlite3CantopenError(56055);
            sqlite3OsClose(pPager->jfd);
          }
        }
      }
# 56069 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( ((pPager->jfd)->pMethods!=0) ){
        ((void)0);
        rc = pagerSyncHotJournal(pPager);
        if( rc==0 ){
          rc = pager_playback(pPager, !pPager->tempFile);
          pPager->eState = 0;
        }
      }else if( !pPager->exclusiveMode ){
        pagerUnlockDb(pPager, 1);
      }

      if( rc!=0 ){
# 56097 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        pager_error(pPager, rc);
        goto failed;
      }

      ((void)0);
      ((void)0)

       ;
    }

    if( !pPager->tempFile && pPager->hasHeldSharedLock ){
# 56124 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      char dbFileVers[sizeof(pPager->dbFileVers)];

      ;
      rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);
      if( rc!=0 ){
        if( rc!=(10 | (2<<8)) ){
          goto failed;
        }
        memset(dbFileVers, 0, sizeof(dbFileVers));
      }

      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){
        pager_reset(pPager);







        if( ((pPager)->bUseFetch) ){
          sqlite3OsUnfetch(pPager->fd, 0, 0);
        }
      }
    }




    rc = pagerOpenWalIfPresent(pPager);

    ((void)0);

  }

  if( ((pPager)->pWal!=0) ){
    ((void)0);
    rc = pagerBeginReadTransaction(pPager);
  }

  if( pPager->tempFile==0 && pPager->eState==0 && rc==0 ){
    rc = pagerPagecount(pPager, &pPager->dbSize);
  }

 failed:
  if( rc!=0 ){
    ((void)0);
    pager_unlock(pPager);
    ((void)0);
  }else{
    pPager->eState = 1;
    pPager->hasHeldSharedLock = 1;
  }
  return rc;
}
# 56188 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pagerUnlockIfUnused(Pager *pPager){
  if( sqlite3PcacheRefCount(pPager->pPCache)==0 ){
    ((void)0);
    pagerUnlockAndRollback(pPager);
  }
}
# 56252 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getPageNormal(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
  int rc = 0;
  PgHdr *pPg;
  u8 noContent;
  sqlite3_pcache_page *pBase;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( pgno==0 ) return sqlite3CorruptError(56268);
  pBase = sqlite3PcacheFetch(pPager->pPCache, pgno, 3);
  if( pBase==0 ){
    pPg = 0;
    rc = sqlite3PcacheFetchStress(pPager->pPCache, pgno, &pBase);
    if( rc!=0 ) goto pager_acquire_err;
    if( pBase==0 ){
      rc = 7;
      goto pager_acquire_err;
    }
  }
  pPg = *ppPage = sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pBase);
  ((void)0);
  ((void)0);
  ((void)0);

  noContent = (flags & 0x01)!=0;
  if( pPg->pPager && !noContent ){


    ((void)0);
    pPager->aStat[0]++;
    return 0;

  }else{






    if( pgno>2147483647 || pgno==((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)) ){
      rc = sqlite3CorruptError(56300);
      goto pager_acquire_err;
    }

    pPg->pPager = pPager;

    ((void)0);
    if( !((pPager->fd)->pMethods!=0) || pPager->dbSize<pgno || noContent ){
      if( pgno>pPager->mxPgno ){
        rc = 13;
        goto pager_acquire_err;
      }
      if( noContent ){






        sqlite3BeginBenignMalloc();
        if( pgno<=pPager->dbOrigSize ){
          sqlite3BitvecSet(pPager->pInJournal, pgno);
          ;
        }
        addToSavepointBitvecs(pPager, pgno);
        ;
        sqlite3EndBenignMalloc();
      }
      memset(pPg->pData, 0, pPager->pageSize);
      ;
    }else{
      ((void)0);
      pPager->aStat[1]++;
      rc = readDbPage(pPg);
      if( rc!=0 ){
        goto pager_acquire_err;
      }
    }
    ;
  }
  return 0;

pager_acquire_err:
  ((void)0);
  if( pPg ){
    sqlite3PcacheDrop(pPg);
  }
  pagerUnlockIfUnused(pPager);
  *ppPage = 0;
  return rc;
}



static int getPageMMap(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
  int rc = 0;
  PgHdr *pPg = 0;
  u32 iFrame = 0;





  const int bMmapOk = (pgno>1
   && (pPager->eState==1 || (flags & 0x02))
  );

  ((void)0);
# 56381 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pgno<=1 && pgno==0 ){
    return sqlite3CorruptError(56382);
  }
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( bMmapOk && ((pPager)->pWal!=0) ){
    rc = sqlite3WalFindFrame(pPager->pWal, pgno, &iFrame);
    if( rc!=0 ){
      *ppPage = 0;
      return rc;
    }
  }
  if( bMmapOk && iFrame==0 ){
    void *pData = 0;
    rc = sqlite3OsFetch(pPager->fd,
        (i64)(pgno-1) * pPager->pageSize, pPager->pageSize, &pData
    );
    if( rc==0 && pData ){
      if( pPager->eState>1 || pPager->tempFile ){
        pPg = sqlite3PagerLookup(pPager, pgno);
      }
      if( pPg==0 ){
        rc = pagerAcquireMapPage(pPager, pgno, pData, &pPg);
      }else{
        sqlite3OsUnfetch(pPager->fd, (i64)(pgno-1)*pPager->pageSize, pData);
      }
      if( pPg ){
        ((void)0);
        *ppPage = pPg;
        return 0;
      }
    }
    if( rc!=0 ){
      *ppPage = 0;
      return rc;
    }
  }
  return getPageNormal(pPager, pgno, ppPage, flags);
}



static int getPageError(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
  (void)(pgno);
  (void)(flags);
  ((void)0);
  *ppPage = 0;
  return pPager->errCode;
}




static int sqlite3PagerGet(
  Pager *pPager,
  Pgno pgno,
  DbPage **ppPage,
  int flags
){
  return pPager->xGet(pPager, pgno, ppPage, flags);
}
# 56462 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){
  sqlite3_pcache_page *pPage;
  ((void)0);
  ((void)0);
  ((void)0);
  pPage = sqlite3PcacheFetch(pPager->pPCache, pgno, 0);
  ((void)0);
  if( pPage==0 ) return 0;
  return sqlite3PcacheFetchFinish(pPager->pPCache, pgno, pPage);
}
# 56485 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerUnrefNotNull(DbPage *pPg){
 
  ((void)0);
  if( pPg->flags & 0x020 ){
    ((void)0);
    pagerReleaseMapPage(pPg);
  }else{
    sqlite3PcacheRelease(pPg);
  }

  ((void)0);
}
static void sqlite3PagerUnref(DbPage *pPg){
  if( pPg ) sqlite3PagerUnrefNotNull(pPg);
}
static void sqlite3PagerUnrefPageOne(DbPage *pPg){
  Pager *pPager;
  ((void)0);
  ((void)0);
  ((void)0);
  pPager = pPg->pPager;
  ;
  sqlite3PcacheRelease(pPg);
  pagerUnlockIfUnused(pPager);
}
# 56533 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_open_journal(Pager *pPager){
  int rc = 0;
  sqlite3_vfs * const pVfs = pPager->pVfs;

  ((void)0);
  ((void)0);
  ((void)0);




  if( (pPager->errCode) ) return pPager->errCode;

  if( !((pPager)->pWal!=0) && pPager->journalMode!=2 ){
    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);
    if( pPager->pInJournal==0 ){
      return 7;
    }


    if( !((pPager->jfd)->pMethods!=0) ){
      if( pPager->journalMode==4 ){
        sqlite3MemJournalOpen(pPager->jfd);
      }else{
        int flags = 0x00000002|0x00000004;
        int nSpill;

        if( pPager->tempFile ){
          flags |= (0x00000008|0x00001000);
          nSpill = sqlite3Config.nStmtSpill;
        }else{
          flags |= 0x00000800;
          nSpill = jrnlBufferSize(pPager);
        }



        rc = databaseIsUnmoved(pPager);
        if( rc==0 ){
          rc = sqlite3JournalOpen (
              pVfs, pPager->zJournal, pPager->jfd, flags, nSpill
          );
        }
      }
      ((void)0);
    }





    if( rc==0 ){

      pPager->nRec = 0;
      pPager->journalOff = 0;
      pPager->setMaster = 0;
      pPager->journalHdr = 0;
      rc = writeJournalHdr(pPager);
    }
  }

  if( rc!=0 ){
    sqlite3BitvecDestroy(pPager->pInJournal);
    pPager->pInJournal = 0;
  }else{
    ((void)0);
    pPager->eState = 3;
  }

  return rc;
}
# 56622 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){
  int rc = 0;

  if( pPager->errCode ) return pPager->errCode;
  ((void)0);
  pPager->subjInMemory = (u8)subjInMemory;

  if( (pPager->eState==1) ){
    ((void)0);

    if( ((pPager)->pWal!=0) ){



      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){
        rc = pagerLockDb(pPager, 4);
        if( rc!=0 ){
          return rc;
        }
        (void)sqlite3WalExclusiveMode(pPager->pWal, 1);
      }






      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);
    }else{





      rc = pagerLockDb(pPager, 2);
      if( rc==0 && exFlag ){
        rc = pager_wait_on_lock(pPager, 4);
      }
    }

    if( rc==0 ){
# 56672 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      pPager->eState = 2;
      pPager->dbHintSize = pPager->dbSize;
      pPager->dbFileSize = pPager->dbSize;
      pPager->dbOrigSize = pPager->dbSize;
      pPager->journalOff = 0;
    }

    ((void)0);
    ((void)0);
    ((void)0);
  }

  ;
  return rc;
}




static __attribute__((noinline)) int pagerAddPageToRollbackJournal(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  int rc;
  u32 cksum;
  char *pData2;
  i64 iOff = pPager->journalOff;




  ((void)0);

  ((void)0);
  pData2=(char*)pPg->pData;
  cksum = pager_cksum(pPager, (u8*)pData2);
# 56714 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pPg->flags |= 0x008;

  rc = write32bits(pPager->jfd, iOff, pPg->pgno);
  if( rc!=0 ) return rc;
  rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);
  if( rc!=0 ) return rc;
  rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);
  if( rc!=0 ) return rc;

 
                                                 ;
  ;
 

                                                                ;

  pPager->journalOff += 8 + pPager->pageSize;
  pPager->nRec++;
  ((void)0);
  rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);
  ;
  ((void)0);
  rc |= addToSavepointBitvecs(pPager, pPg->pgno);
  ((void)0);
  return rc;
}
# 56748 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_write(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  int rc = 0;





  ((void)0)


   ;
  ((void)0);
  ((void)0);
  ((void)0);
  ;
# 56774 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pPager->eState==2 ){
    rc = pager_open_journal(pPager);
    if( rc!=0 ) return rc;
  }
  ((void)0);
  ((void)0);


  sqlite3PcacheMakeDirty(pPg);





  ((void)0);
  if( pPager->pInJournal!=0
   && sqlite3BitvecTestNotNull(pPager->pInJournal, pPg->pgno)==0
  ){
    ((void)0);
    if( pPg->pgno<=pPager->dbOrigSize ){
      rc = pagerAddPageToRollbackJournal(pPg);
      if( rc!=0 ){
        return rc;
      }
    }else{
      if( pPager->eState!=4 ){
        pPg->flags |= 0x008;
      }
     

                                                 ;
    }
  }






  pPg->flags |= 0x004;




  if( pPager->nSavepoint>0 ){
    rc = subjournalPageIfRequired(pPg);
  }


  if( pPager->dbSize<pPg->pgno ){
    pPager->dbSize = pPg->pgno;
  }
  return rc;
}
# 56840 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int pagerWriteLargeSector(PgHdr *pPg){
  int rc = 0;
  Pgno nPageCount;
  Pgno pg1;
  int nPage = 0;
  int ii;
  int needSync = 0;
  Pager *pPager = pPg->pPager;
  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);





  ((void)0);
  ((void)0);
  pPager->doNotSpill |= 0x04;





  pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;

  nPageCount = pPager->dbSize;
  if( pPg->pgno>nPageCount ){
    nPage = (pPg->pgno - pg1)+1;
  }else if( (pg1+nPagePerSector-1)>nPageCount ){
    nPage = nPageCount+1-pg1;
  }else{
    nPage = nPagePerSector;
  }
  ((void)0);
  ((void)0);
  ((void)0);

  for(ii=0; ii<nPage && rc==0; ii++){
    Pgno pg = pg1+ii;
    PgHdr *pPage;
    if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){
      if( pg!=((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)) ){
        rc = sqlite3PagerGet(pPager, pg, &pPage, 0);
        if( rc==0 ){
          rc = pager_write(pPage);
          if( pPage->flags&0x008 ){
            needSync = 1;
          }
          sqlite3PagerUnrefNotNull(pPage);
        }
      }
    }else if( (pPage = sqlite3PagerLookup(pPager, pg))!=0 ){
      if( pPage->flags&0x008 ){
        needSync = 1;
      }
      sqlite3PagerUnrefNotNull(pPage);
    }
  }







  if( rc==0 && needSync ){
    ((void)0);
    for(ii=0; ii<nPage; ii++){
      PgHdr *pPage = sqlite3PagerLookup(pPager, pg1+ii);
      if( pPage ){
        pPage->flags |= 0x008;
        sqlite3PagerUnrefNotNull(pPage);
      }
    }
  }

  ((void)0);
  pPager->doNotSpill &= ~0x04;
  return rc;
}
# 56934 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerWrite(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  ((void)0);
  ((void)0);
  ((void)0);
  if( (pPg->flags & 0x004)!=0 && pPager->dbSize>=pPg->pgno ){
    if( pPager->nSavepoint ) return subjournalPageIfRequired(pPg);
    return 0;
  }else if( pPager->errCode ){
    return pPager->errCode;
  }else if( pPager->sectorSize > (u32)pPager->pageSize ){
    ((void)0);
    return pagerWriteLargeSector(pPg);
  }else{
    return pager_write(pPg);
  }
}
# 56983 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerDontWrite(PgHdr *pPg){
  Pager *pPager = pPg->pPager;
  if( !pPager->tempFile && (pPg->flags&0x002) && pPager->nSavepoint==0 ){
    ;
   
    pPg->flags |= 0x010;
    pPg->flags &= ~0x004;
    ;
    ;
  }
}
# 57017 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pager_incr_changecounter(Pager *pPager, int isDirectMode){
  int rc = 0;

  ((void)0)

   ;
  ((void)0);
# 57036 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define DIRECT_MODE 0
  ((void)0);
  (void)(isDirectMode);




  if( !pPager->changeCountDone && (pPager->dbSize>0) ){
    PgHdr *pPgHdr;

    ((void)0);


    rc = sqlite3PagerGet(pPager, 1, &pPgHdr, 0);
    ((void)0);






    if( !0 && (rc==0) ){
      rc = sqlite3PagerWrite(pPgHdr);
    }

    if( rc==0 ){

      pager_write_changecounter(pPgHdr);


      if( 0 ){
        const void *zBuf;
        ((void)0);
        zBuf=(char*)pPgHdr->pData;
        if( rc==0 ){
          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);
          pPager->aStat[2]++;
        }
        if( rc==0 ){



          const void *pCopy = (const void *)&((const char *)zBuf)[24];
          memcpy(&pPager->dbFileVers, pCopy, sizeof(pPager->dbFileVers));
          pPager->changeCountDone = 1;
        }
      }else{
        pPager->changeCountDone = 1;
      }
    }


    sqlite3PagerUnref(pPgHdr);
  }
  return rc;
}
# 57100 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerSync(Pager *pPager, const char *zMaster){
  int rc = 0;
  void *pArg = (void*)zMaster;
  rc = sqlite3OsFileControl(pPager->fd, 21, pArg);
  if( rc==12 ) rc = 0;
  if( rc==0 && !pPager->noSync ){
    ((void)0);
    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);
  }
  return rc;
}
# 57123 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerExclusiveLock(Pager *pPager){
  int rc = pPager->errCode;
  ((void)0);
  if( rc==0 ){
    ((void)0)


     ;
    ((void)0);
    if( 0==((pPager)->pWal!=0) ){
      rc = pager_wait_on_lock(pPager, 4);
    }
  }
  return rc;
}
# 57165 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerCommitPhaseOne(
  Pager *pPager,
  const char *zMaster,
  int noSync
){
  int rc = 0;

  ((void)0)



   ;
  ((void)0);


  if( (pPager->errCode) ) return pPager->errCode;


  if( sqlite3FaultSim(400) ) return 10;

 
                                                  ;


  if( pPager->eState<3 ) return 0;

  ((void)0);
  ((void)0);
  if( 0==pagerFlushOnCommit(pPager, 1) ){



    sqlite3BackupRestart(pPager->pBackup);
  }else{
    PgHdr *pList;
    if( ((pPager)->pWal!=0) ){
      PgHdr *pPageOne = 0;
      pList = sqlite3PcacheDirtyList(pPager->pPCache);
      if( pList==0 ){


        rc = sqlite3PagerGet(pPager, 1, &pPageOne, 0);
        pList = pPageOne;
        pList->pDirty = 0;
      }
      ((void)0);
      if( (pList) ){
        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1);
      }
      sqlite3PagerUnref(pPageOne);
      if( rc==0 ){
        sqlite3PcacheCleanAll(pPager->pPCache);
      }
    }else{
# 57230 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define bBatch 0
# 57290 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      rc = pager_incr_changecounter(pPager, 0);

      if( rc!=0 ) goto commit_phase_one_exit;





      rc = writeMasterJournal(pPager, zMaster);
      if( rc!=0 ) goto commit_phase_one_exit;
# 57312 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      rc = syncJournal(pPager, 0);
      if( rc!=0 ) goto commit_phase_one_exit;

      pList = sqlite3PcacheDirtyList(pPager->pPCache);
# 57342 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( 0==0 ){
        rc = pager_write_pagelist(pPager, pList);
      }
      if( rc!=0 ){
        ((void)0);
        goto commit_phase_one_exit;
      }
      sqlite3PcacheCleanAll(pPager->pPCache);







      if( pPager->dbSize>pPager->dbFileSize ){
        Pgno nNew = pPager->dbSize - (pPager->dbSize==((Pgno)((sqlite3PendingByte/((pPager)->pageSize))+1)));
        ((void)0);
        rc = pager_truncate(pPager, nNew);
        if( rc!=0 ) goto commit_phase_one_exit;
      }


      if( !noSync ){
        rc = sqlite3PagerSync(pPager, zMaster);
      }
     
    }
  }

commit_phase_one_exit:
  if( rc==0 && !((pPager)->pWal!=0) ){
    pPager->eState = 5;
  }
  return rc;
}
# 57395 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerCommitPhaseTwo(Pager *pPager){
  int rc = 0;




  if( (pPager->errCode) ) return pPager->errCode;

  ((void)0)


   ;
  ((void)0);
# 57420 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pPager->eState==2
   && pPager->exclusiveMode
   && pPager->journalMode==1
  ){
    ((void)0);
    pPager->eState = 1;
    return 0;
  }

  ;
  pPager->iDataVersion++;
  rc = pager_end_transaction(pPager, pPager->setMaster, 1);
  return pager_error(pPager, rc);
}
# 57461 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerRollback(Pager *pPager){
  int rc = 0;
  ;





  ((void)0);
  if( pPager->eState==6 ) return pPager->errCode;
  if( pPager->eState<=1 ) return 0;

  if( ((pPager)->pWal!=0) ){
    int rc2;
    rc = sqlite3PagerSavepoint(pPager, 2, -1);
    rc2 = pager_end_transaction(pPager, pPager->setMaster, 0);
    if( rc==0 ) rc = rc2;
  }else if( !((pPager->jfd)->pMethods!=0) || pPager->eState==2 ){
    int eState = pPager->eState;
    rc = pager_end_transaction(pPager, 0, 0);
    if( !pPager->memDb && eState>2 ){




      pPager->errCode = 4;
      pPager->eState = 6;
      setGetterMethod(pPager);
      return rc;
    }
  }else{
    rc = pager_playback(pPager, 0);
  }

  ((void)0);
  ((void)0)


   ;




  return pager_error(pPager, rc);
}





static u8 sqlite3PagerIsreadonly(Pager *pPager){
  return pPager->readOnly;
}
# 57528 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerMemUsed(Pager *pPager){
  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)
                                     + 5*sizeof(void*);
  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)
           + sqlite3MallocSize(pPager)
           + pPager->pageSize;
}




static int sqlite3PagerPageRefcount(DbPage *pPage){
  return sqlite3PcachePageRefcount(pPage);
}
# 57575 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerCacheStat(Pager *pPager, int eStat, int reset, int *pnVal){

  ((void)0)



   ;

  ((void)0);
  ((void)0);
  ((void)0)
                                                          ;

  eStat -= 7;
  *pnVal += pPager->aStat[eStat];
  if( reset ){
    pPager->aStat[eStat] = 0;
  }
}




static int sqlite3PagerIsMemdb(Pager *pPager){
  return pPager->tempFile;
}
# 57612 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int pagerOpenSavepoint(Pager *pPager, int nSavepoint){
  int rc = 0;
  int nCurrent = pPager->nSavepoint;
  int ii;
  PagerSavepoint *aNew;

  ((void)0);
  ((void)0);
  ((void)0);





  aNew = (PagerSavepoint *)sqlite3Realloc(
      pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint
  );
  if( !aNew ){
    return 7;
  }
  memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));
  pPager->aSavepoint = aNew;


  for(ii=nCurrent; ii<nSavepoint; ii++){
    aNew[ii].nOrig = pPager->dbSize;
    if( ((pPager->jfd)->pMethods!=0) && pPager->journalOff>0 ){
      aNew[ii].iOffset = pPager->journalOff;
    }else{
      aNew[ii].iOffset = (pPager->sectorSize);
    }
    aNew[ii].iSubRec = pPager->nSubRec;
    aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);
    if( !aNew[ii].pInSavepoint ){
      return 7;
    }
    if( ((pPager)->pWal!=0) ){
      sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);
    }
    pPager->nSavepoint = ii+1;
  }
  ((void)0);
  ;
  return rc;
}
static int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){
  ((void)0);
  ((void)0);

  if( nSavepoint>pPager->nSavepoint && pPager->useJournal ){
    return pagerOpenSavepoint(pPager, nSavepoint);
  }else{
    return 0;
  }
}
# 57699 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){
  int rc = pPager->errCode;





  ((void)0);
  ((void)0);

  if( rc==0 && iSavepoint<pPager->nSavepoint ){
    int ii;
    int nNew;





    nNew = iSavepoint + (( op==1 ) ? 0 : 1);
    for(ii=nNew; ii<pPager->nSavepoint; ii++){
      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);
    }
    pPager->nSavepoint = nNew;



    if( op==1 ){
      if( nNew==0 && ((pPager->sjfd)->pMethods!=0) ){

        if( sqlite3JournalIsInMemory(pPager->sjfd) ){
          rc = sqlite3OsTruncate(pPager->sjfd, 0);
          ((void)0);
        }
        pPager->nSubRec = 0;
      }
    }





    else if( ((pPager)->pWal!=0) || ((pPager->jfd)->pMethods!=0) ){
      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];
      rc = pagerPlaybackSavepoint(pPager, pSavepoint);
      ((void)0);
    }
# 57760 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }

  return rc;
}
# 57775 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *sqlite3PagerFilename(Pager *pPager, int nullIfMemDb){
  return (nullIfMemDb && pPager->memDb) ? "" : pPager->zFilename;
}




static sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){
  return pPager->pVfs;
}






static sqlite3_file *sqlite3PagerFile(Pager *pPager){
  return pPager->fd;
}
# 57809 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_file *sqlite3PagerJrnlFile(Pager *pPager){



  return pPager->pWal ? sqlite3WalFile(pPager->pWal) : pPager->jfd;

}




static const char *sqlite3PagerJournalname(Pager *pPager){
  return pPager->zJournal;
}
# 57898 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){
  PgHdr *pPgOld;
  Pgno needSyncPgno = 0;
  int rc;
  Pgno origPgno;

  ((void)0);
  ((void)0)

   ;
  ((void)0);




  ((void)0);
  if( pPager->tempFile ){
    rc = sqlite3PagerWrite(pPg);
    if( rc ) return rc;
  }
# 57937 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (pPg->flags & 0x002)!=0
   && 0!=(rc = subjournalPageIfRequired(pPg))
  ){
    return rc;
  }

 
                                                                          ;
 
# 57954 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (pPg->flags&0x008) && !isCommit ){
    needSyncPgno = pPg->pgno;
    ((void)0)
                                                                        ;
    ((void)0);
  }






  pPg->flags &= ~0x008;
  pPgOld = sqlite3PagerLookup(pPager, pgno);
  ((void)0);
  if( pPgOld ){
    if( pPgOld->nRef>1 ){
      sqlite3PagerUnrefNotNull(pPgOld);
      return sqlite3CorruptError(57972);
    }
    pPg->flags |= (pPgOld->flags&0x008);
    if( pPager->tempFile ){


      sqlite3PcacheMove(pPgOld, pPager->dbSize+1);
    }else{
      sqlite3PcacheDrop(pPgOld);
    }
  }

  origPgno = pPg->pgno;
  sqlite3PcacheMove(pPg, pgno);
  sqlite3PcacheMakeDirty(pPg);





  if( pPager->tempFile && pPgOld ){
    sqlite3PcacheMove(pPgOld, origPgno);
    sqlite3PagerUnrefNotNull(pPgOld);
  }

  if( needSyncPgno ){
# 58012 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    PgHdr *pPgHdr;
    rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr, 0);
    if( rc!=0 ){
      if( needSyncPgno<=pPager->dbOrigSize ){
        ((void)0);
        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);
      }
      return rc;
    }
    pPgHdr->flags |= 0x008;
    sqlite3PcacheMakeDirty(pPgHdr);
    sqlite3PagerUnrefNotNull(pPgHdr);
  }

  return 0;
}
# 58036 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3PagerRekey(DbPage *pPg, Pgno iNew, u16 flags){
  ((void)0);
  pPg->flags = flags;
  sqlite3PcacheMove(pPg, iNew);
}




static void *sqlite3PagerGetData(DbPage *pPg){
  ((void)0);
  return pPg->pData;
}





static void *sqlite3PagerGetExtra(DbPage *pPg){
  return pPg->pExtra;
}
# 58068 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerLockingMode(Pager *pPager, int eMode){
  ((void)0)

                                                   ;
  ((void)0);
  ((void)0);
  ((void)0);
  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){
    pPager->exclusiveMode = (u8)eMode;
  }
  return (int)pPager->exclusiveMode;
}
# 58101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){
  u8 eOld = pPager->journalMode;


  ((void)0)




                                                ;





  ((void)0);




  if( pPager->memDb ){
    ((void)0);
    if( eMode!=4 && eMode!=2 ){
      eMode = eOld;
    }
  }

  if( eMode!=eOld ){


    ((void)0);
    pPager->journalMode = (u8)eMode;





    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);

    ((void)0);
    if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){
# 58156 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      sqlite3OsClose(pPager->jfd);
      if( pPager->eLock>=2 ){
        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
      }else{
        int rc = 0;
        int state = pPager->eState;
        ((void)0);
        if( state==0 ){
          rc = sqlite3PagerSharedLock(pPager);
        }
        if( pPager->eState==1 ){
          ((void)0);
          rc = pagerLockDb(pPager, 2);
        }
        if( rc==0 ){
          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);
        }
        if( rc==0 && state==1 ){
          pagerUnlockDb(pPager, 1);
        }else if( state==0 ){
          pager_unlock(pPager);
        }
        ((void)0);
      }
    }else if( eMode==2 ){
      sqlite3OsClose(pPager->jfd);
    }
  }


  return (int)pPager->journalMode;
}




static int sqlite3PagerGetJournalMode(Pager *pPager){
  return (int)pPager->journalMode;
}






static int sqlite3PagerOkToChangeJournalMode(Pager *pPager){
  ((void)0);
  if( pPager->eState>=3 ) return 0;
  if( (((pPager->jfd)->pMethods!=0) && pPager->journalOff>0) ) return 0;
  return 1;
}







static i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){
  if( iLimit>=-1 ){
    pPager->journalSizeLimit = iLimit;
    sqlite3WalLimit(pPager->pWal, iLimit);
  }
  return pPager->journalSizeLimit;
}







static sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){
  return &pPager->pBackup;
}





static void sqlite3PagerClearCache(Pager *pPager){
  ((void)0);
  if( pPager->tempFile==0 ) pager_reset(pPager);
}
# 58251 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerCheckpoint(
  Pager *pPager,
  sqlite3 *db,
  int eMode,
  int *pnLog,
  int *pnCkpt
){
  int rc = 0;
  if( pPager->pWal ){
    rc = sqlite3WalCheckpoint(pPager->pWal, db, eMode,
        (eMode==0 ? 0 : pPager->xBusyHandler),
        pPager->pBusyHandlerArg,
        pPager->walSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,
        pnLog, pnCkpt
    );
    ;
  }
  return rc;
}

static int sqlite3PagerWalCallback(Pager *pPager){
  return sqlite3WalCallback(pPager->pWal);
}





static int sqlite3PagerWalSupported(Pager *pPager){
  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;
  if( pPager->noLock ) return 0;
  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);
}





static int pagerExclusiveLock(Pager *pPager){
  int rc;

  ((void)0);
  rc = pagerLockDb(pPager, 4);
  if( rc!=0 ){


    pagerUnlockDb(pPager, 1);
  }

  return rc;
}







static int pagerOpenWal(Pager *pPager){
  int rc = 0;

  ((void)0);
  ((void)0);






  if( pPager->exclusiveMode ){
    rc = pagerExclusiveLock(pPager);
  }




  if( rc==0 ){
    rc = sqlite3WalOpen(pPager->pVfs,
        pPager->fd, pPager->zWal, pPager->exclusiveMode,
        pPager->journalSizeLimit, &pPager->pWal
    );
  }
  pagerFixMaplimit(pPager);

  return rc;
}
# 58354 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerOpenWal(
  Pager *pPager,
  int *pbOpen
){
  int rc = 0;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( !pPager->tempFile && !pPager->pWal ){
    if( !sqlite3PagerWalSupported(pPager) ) return 14;


    sqlite3OsClose(pPager->jfd);

    rc = pagerOpenWal(pPager);
    if( rc==0 ){
      pPager->journalMode = 5;
      pPager->eState = 0;
    }
  }else{
    *pbOpen = 1;
  }

  return rc;
}
# 58393 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3PagerCloseWal(Pager *pPager, sqlite3 *db){
  int rc = 0;

  ((void)0);





  if( !pPager->pWal ){
    int logexists = 0;
    rc = pagerLockDb(pPager, 1);
    if( rc==0 ){
      rc = sqlite3OsAccess(
          pPager->pVfs, pPager->zWal, 0, &logexists
      );
    }
    if( rc==0 && logexists ){
      rc = pagerOpenWal(pPager);
    }
  }




  if( rc==0 && pPager->pWal ){
    rc = pagerExclusiveLock(pPager);
    if( rc==0 ){
      rc = sqlite3WalClose(pPager->pWal, db, pPager->walSyncFlags,
                           pPager->pageSize, (u8*)pPager->pTmpSpace);
      pPager->pWal = 0;
      pagerFixMaplimit(pPager);
      if( rc && !pPager->exclusiveMode ) pagerUnlockDb(pPager, 1);
    }
  }
  return rc;
}
# 58782 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WALTRACE(X) 
# 58793 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define AtomicLoad(PTR) (*(PTR))
#define AtomicStore(PTR,VAL) (*(PTR) = (VAL))
# 58810 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WAL_MAX_VERSION 3007000
#define WALINDEX_MAX_VERSION 3007000
# 58827 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WAL_WRITE_LOCK 0
#define WAL_ALL_BUT_WRITE 1
#define WAL_CKPT_LOCK 1
#define WAL_RECOVER_LOCK 2
#define WAL_READ_LOCK(I) (3+(I))
#define WAL_NREADER (SQLITE_SHM_NLOCK-3)



typedef struct WalIndexHdr WalIndexHdr;
typedef struct WalIterator WalIterator;
typedef struct WalCkptInfo WalCkptInfo;
# 58854 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WalIndexHdr {
  u32 iVersion;
  u32 unused;
  u32 iChange;
  u8 isInit;
  u8 bigEndCksum;
  u16 szPage;
  u32 mxFrame;
  u32 nPage;
  u32 aFrameCksum[2];
  u32 aSalt[2];
  u32 aCksum[2];
};
# 58927 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WalCkptInfo {
  u32 nBackfill;
  u32 aReadMark[(8 -3)];
  u8 aLock[8];
  u32 nBackfillAttempted;
  u32 notUsed0;
};
#define READMARK_NOT_USED 0xffffffff







#define WALINDEX_LOCK_OFFSET (sizeof(WalIndexHdr)*2+offsetof(WalCkptInfo,aLock))
#define WALINDEX_HDR_SIZE (sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))


#define WAL_FRAME_HDRSIZE 24


#define WAL_HDRSIZE 32
# 58960 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WAL_MAGIC 0x377f0682






#define walFrameOffset(iFrame,szPage) ( WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE) )







struct Wal {
  sqlite3_vfs *pVfs;
  sqlite3_file *pDbFd;
  sqlite3_file *pWalFd;
  u32 iCallback;
  i64 mxWalSize;
  int nWiData;
  int szFirstBlock;
  volatile u32 **apWiData;
  u32 szPage;
  i16 readLock;
  u8 syncFlags;
  u8 exclusiveMode;
  u8 writeLock;
  u8 ckptLock;
  u8 readOnly;
  u8 truncateOnCommit;
  u8 syncHeader;
  u8 padToSectorBoundary;
  u8 bShmUnreliable;
  WalIndexHdr hdr;
  u32 minFrame;
  u32 iReCksum;
  const char *zWalName;
  u32 nCkpt;






};




#define WAL_NORMAL_MODE 0
#define WAL_EXCLUSIVE_MODE 1
#define WAL_HEAPMEMORY_MODE 2




#define WAL_RDWR 0
#define WAL_RDONLY 1
#define WAL_SHM_RDONLY 2





typedef u16 ht_slot;
# 59043 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WalIterator {
  int iPrior;
  int nSegment;
  struct WalSegment {
    int iNext;
    ht_slot *aIndex;
    u32 *aPgno;
    int nEntry;
    int iZero;
  } aSegment[1];
};
# 59063 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define HASHTABLE_NPAGE 4096
#define HASHTABLE_HASH_1 383
#define HASHTABLE_NSLOT (HASHTABLE_NPAGE*2)






#define HASHTABLE_NPAGE_ONE (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))


#define WALINDEX_PGSZ ( sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) )
# 59093 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int walIndexPageRealloc(
  Wal *pWal,
  int iPage,
  volatile u32 **ppPage
){
  int rc = 0;


  if( pWal->nWiData<=iPage ){
    sqlite3_int64 nByte = sizeof(u32*)*(iPage+1);
    volatile u32 **apNew;
    apNew = (volatile u32 **)sqlite3_realloc64((void *)pWal->apWiData, nByte);
    if( !apNew ){
      *ppPage = 0;
      return 7;
    }
    memset((void*)&apNew[pWal->nWiData], 0,
           sizeof(u32*)*(iPage+1-pWal->nWiData));
    pWal->apWiData = apNew;
    pWal->nWiData = iPage+1;
  }


  ((void)0);
  if( pWal->exclusiveMode==2 ){
    pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ));
    if( !pWal->apWiData[iPage] ) rc = 7;
  }else{
    rc = sqlite3OsShmMap(pWal->pDbFd, iPage, ( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ),
        pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]
    );
    ((void)0);
    ;
    if( (rc&0xff)==8 ){
      pWal->readOnly |= 2;
      if( rc==8 ){
        rc = 0;
      }
    }
  }

  *ppPage = pWal->apWiData[iPage];
  ((void)0);
  return rc;
}
static int walIndexPage(
  Wal *pWal,
  int iPage,
  volatile u32 **ppPage
){
  if( pWal->nWiData<=iPage || (*ppPage = pWal->apWiData[iPage])==0 ){
    return walIndexPageRealloc(pWal, iPage, ppPage);
  }
  return 0;
}




static volatile WalCkptInfo *walCkptInfo(Wal *pWal){
  ((void)0);
  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);
}




static volatile WalIndexHdr *walIndexHdr(Wal *pWal){
  ((void)0);
  return (volatile WalIndexHdr*)pWal->apWiData[0];
}
# 59172 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BYTESWAP32(x) ( (((x)&0x000000FF)<<24) + (((x)&0x0000FF00)<<8) + (((x)&0x00FF0000)>>8) + (((x)&0xFF000000)>>24) )
# 59186 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void walChecksumBytes(
  int nativeCksum,
  u8 *a,
  int nByte,
  const u32 *aIn,
  u32 *aOut
){
  u32 s1, s2;
  u32 *aData = (u32 *)a;
  u32 *aEnd = (u32 *)&a[nByte];

  if( aIn ){
    s1 = aIn[0];
    s2 = aIn[1];
  }else{
    s1 = s2 = 0;
  }

  ((void)0);
  ((void)0);
  ((void)0);

  if( nativeCksum ){
    do {
      s1 += *aData++ + s2;
      s2 += *aData++ + s1;
    }while( aData<aEnd );
  }else{
    do {
      s1 += ( (((aData[0])&0x000000FF)<<24) + (((aData[0])&0x0000FF00)<<8) + (((aData[0])&0x00FF0000)>>8) + (((aData[0])&0xFF000000)>>24) ) + s2;
      s2 += ( (((aData[1])&0x000000FF)<<24) + (((aData[1])&0x0000FF00)<<8) + (((aData[1])&0x00FF0000)>>8) + (((aData[1])&0xFF000000)>>24) ) + s1;
      aData += 2;
    }while( aData<aEnd );
  }

  aOut[0] = s1;
  aOut[1] = s2;
}

static void walShmBarrier(Wal *pWal){
  if( pWal->exclusiveMode!=2 ){
    sqlite3OsShmBarrier(pWal->pDbFd);
  }
}






static void walIndexWriteHdr(Wal *pWal){
  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);
  const int nCksum = __builtin_offsetof(WalIndexHdr,aCksum);

  ((void)0);
  pWal->hdr.isInit = 1;
  pWal->hdr.iVersion = 3007000;
  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);
  memcpy((void*)&aHdr[1], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
  walShmBarrier(pWal);
  memcpy((void*)&aHdr[0], (const void*)&pWal->hdr, sizeof(WalIndexHdr));
}
# 59262 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void walEncodeFrame(
  Wal *pWal,
  u32 iPage,
  u32 nTruncate,
  u8 *aData,
  u8 *aFrame
){
  int nativeCksum;
  u32 *aCksum = pWal->hdr.aFrameCksum;
  ((void)0);
  sqlite3Put4byte(&aFrame[0], iPage);
  sqlite3Put4byte(&aFrame[4], nTruncate);
  if( pWal->iReCksum==0 ){
    memcpy(&aFrame[8], pWal->hdr.aSalt, 8);

    nativeCksum = (pWal->hdr.bigEndCksum==0);
    walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
    walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);

    sqlite3Put4byte(&aFrame[16], aCksum[0]);
    sqlite3Put4byte(&aFrame[20], aCksum[1]);
  }else{
    memset(&aFrame[8], 0, 16);
  }
}






static int walDecodeFrame(
  Wal *pWal,
  u32 *piPage,
  u32 *pnTruncate,
  u8 *aData,
  u8 *aFrame
){
  int nativeCksum;
  u32 *aCksum = pWal->hdr.aFrameCksum;
  u32 pgno;
  ((void)0);




  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){
    return 0;
  }



  pgno = sqlite3Get4byte(&aFrame[0]);
  if( pgno==0 ){
    return 0;
  }






  nativeCksum = (pWal->hdr.bigEndCksum==0);
  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);
  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);
  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16])
   || aCksum[1]!=sqlite3Get4byte(&aFrame[20])
  ){

    return 0;
  }




  *piPage = pgno;
  *pnTruncate = sqlite3Get4byte(&aFrame[4]);
  return 1;
}
# 59372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walLockShared(Wal *pWal, int lockIdx){
  int rc;
  if( pWal->exclusiveMode ) return 0;
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
                        2 | 4);
 
                                                        ;
 
  return rc;
}
static void walUnlockShared(Wal *pWal, int lockIdx){
  if( pWal->exclusiveMode ) return;
  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,
                         1 | 4);
  ;
}
static int walLockExclusive(Wal *pWal, int lockIdx, int n){
  int rc;
  if( pWal->exclusiveMode ) return 0;
  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                        2 | 8);
 
                                                           ;
 
  return rc;
}
static void walUnlockExclusive(Wal *pWal, int lockIdx, int n){
  if( pWal->exclusiveMode ) return;
  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,
                         1 | 8);
 
                                      ;
}






static int walHash(u32 iPage){
  ((void)0);
  ((void)0);
  return (iPage*383) & ((4096*2)-1);
}
static int walNextHash(int iPriorHash){
  return (iPriorHash+1)&((4096*2)-1);
}






typedef struct WalHashLoc WalHashLoc;
struct WalHashLoc {
  volatile ht_slot *aHash;
  volatile u32 *aPgno;
  u32 iZero;
};
# 59446 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walHashGet(
  Wal *pWal,
  int iHash,
  WalHashLoc *pLoc
){
  int rc;

  rc = walIndexPage(pWal, iHash, &pLoc->aPgno);
  ((void)0);

  if( rc==0 ){
    pLoc->aHash = (volatile ht_slot *)&pLoc->aPgno[4096];
    if( iHash==0 ){
      pLoc->aPgno = &pLoc->aPgno[(sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32)];
      pLoc->iZero = 0;
    }else{
      pLoc->iZero = (4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32))) + (iHash-1)*4096;
    }
    pLoc->aPgno = &pLoc->aPgno[-1];
  }
  return rc;
}







static int walFramePage(u32 iFrame){
  int iHash = (iFrame+4096 -(4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32)))-1) / 4096;
  ((void)0)




   ;
  return iHash;
}




static u32 walFramePgno(Wal *pWal, u32 iFrame){
  int iHash = walFramePage(iFrame);
  if( iHash==0 ){
    return pWal->apWiData[0][(sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32) + iFrame - 1];
  }
  return pWal->apWiData[iHash][(iFrame-1-(4096 - ((sizeof(WalIndexHdr)*2+sizeof(WalCkptInfo))/sizeof(u32))))%4096];
}
# 59509 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void walCleanupHash(Wal *pWal){
  WalHashLoc sLoc;
  int iLimit = 0;
  int nByte;
  int i;
  int rc;

  ((void)0);
  ;
  ;
  ;

  if( pWal->hdr.mxFrame==0 ) return;





  ((void)0);
  ((void)0);
  rc = walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &sLoc);
  if( (rc) ) return;




  iLimit = pWal->hdr.mxFrame - sLoc.iZero;
  ((void)0);
  for(i=0; i<(4096*2); i++){
    if( sLoc.aHash[i]>iLimit ){
      sLoc.aHash[i] = 0;
    }
  }




  nByte = (int)((char *)sLoc.aHash - (char *)&sLoc.aPgno[iLimit+1]);
  memset((void *)&sLoc.aPgno[iLimit+1], 0, nByte);
# 59564 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}






static int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){
  int rc;
  WalHashLoc sLoc;

  rc = walHashGet(pWal, walFramePage(iFrame), &sLoc);




  if( rc==0 ){
    int iKey;
    int idx;
    int nCollide;

    idx = iFrame - sLoc.iZero;
    ((void)0);




    if( idx==1 ){
      int nByte = (int)((u8 *)&sLoc.aHash[(4096*2)]
                               - (u8 *)&sLoc.aPgno[1]);
      memset((void*)&sLoc.aPgno[1], 0, nByte);
    }







    if( sLoc.aPgno[idx] ){
      walCleanupHash(pWal);
      ((void)0);
    }


    nCollide = idx;
    for(iKey=walHash(iPage); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){
      if( (nCollide--)==0 ) return sqlite3CorruptError(59611);
    }
    sLoc.aPgno[idx] = iPage;
    sLoc.aHash[iKey] = (ht_slot)idx;
# 59644 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }


  return rc;
}
# 59661 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walIndexRecover(Wal *pWal){
  int rc;
  i64 nSize;
  u32 aFrameCksum[2] = {0, 0};
  int iLock;







  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  iLock = 1 + pWal->ckptLock;
  rc = walLockExclusive(pWal, iLock, (3+(0))-iLock);
  if( rc==0 ){
    rc = walLockExclusive(pWal, (3+(1)), (8 -3)-1);
    if( rc!=0 ){
      walUnlockExclusive(pWal, iLock, (3+(0))-iLock);
    }
  }
  if( rc ){
    return rc;
  }

  ;

  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));

  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);
  if( rc!=0 ){
    goto recovery_error;
  }

  if( nSize>32 ){
    u8 aBuf[32];
    u8 *aFrame = 0;
    int szFrame;
    u8 *aData;
    int iFrame;
    i64 iOffset;
    int szPage;
    u32 magic;
    u32 version;
    int isValid;


    rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);
    if( rc!=0 ){
      goto recovery_error;
    }






    magic = sqlite3Get4byte(&aBuf[0]);
    szPage = sqlite3Get4byte(&aBuf[8]);
    if( (magic&0xFFFFFFFE)!=0x377f0682
     || szPage&(szPage-1)
     || szPage>65536
     || szPage<512
    ){
      goto finished;
    }
    pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);
    pWal->szPage = szPage;
    pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);
    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);


    walChecksumBytes(pWal->hdr.bigEndCksum==0,
        aBuf, 32 -2*4, 0, pWal->hdr.aFrameCksum
    );
    if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])
     || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])
    ){
      goto finished;
    }



    version = sqlite3Get4byte(&aBuf[4]);
    if( version!=3007000 ){
      rc = sqlite3CantopenError(59749);
      goto finished;
    }


    szFrame = szPage + 24;
    aFrame = (u8 *)sqlite3_malloc64(szFrame);
    if( !aFrame ){
      rc = 7;
      goto recovery_error;
    }
    aData = &aFrame[24];


    iFrame = 0;
    for(iOffset=32; (iOffset+szFrame)<=nSize; iOffset+=szFrame){
      u32 pgno;
      u32 nTruncate;


      iFrame++;
      rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
      if( rc!=0 ) break;
      isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);
      if( !isValid ) break;
      rc = walIndexAppend(pWal, iFrame, pgno);
      if( rc!=0 ) break;


      if( nTruncate ){
        pWal->hdr.mxFrame = iFrame;
        pWal->hdr.nPage = nTruncate;
        pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));
        ;
        ;
        aFrameCksum[0] = pWal->hdr.aFrameCksum[0];
        aFrameCksum[1] = pWal->hdr.aFrameCksum[1];
      }
    }

    sqlite3_free(aFrame);
  }

finished:
  if( rc==0 ){
    volatile WalCkptInfo *pInfo;
    int i;
    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];
    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];
    walIndexWriteHdr(pWal);





    pInfo = walCkptInfo(pWal);
    pInfo->nBackfill = 0;
    pInfo->nBackfillAttempted = pWal->hdr.mxFrame;
    pInfo->aReadMark[0] = 0;
    for(i=1; i<(8 -3); i++) pInfo->aReadMark[i] = 0xffffffff;
    if( pWal->hdr.mxFrame ) pInfo->aReadMark[1] = pWal->hdr.mxFrame;






    if( pWal->hdr.nPage ){
      sqlite3_log((27 | (1<<8)),
          "recovered %d frames from WAL file %s",
          pWal->hdr.mxFrame, pWal->zWalName
      );
    }
  }

recovery_error:
  ;
  walUnlockExclusive(pWal, iLock, (3+(0))-iLock);
  walUnlockExclusive(pWal, (3+(1)), (8 -3)-1);
  return rc;
}




static void walIndexClose(Wal *pWal, int isDelete){
  if( pWal->exclusiveMode==2 || pWal->bShmUnreliable ){
    int i;
    for(i=0; i<pWal->nWiData; i++){
      sqlite3_free((void *)pWal->apWiData[i]);
      pWal->apWiData[i] = 0;
    }
  }
  if( pWal->exclusiveMode!=2 ){
    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);
  }
}
# 59862 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalOpen(
  sqlite3_vfs *pVfs,
  sqlite3_file *pDbFd,
  const char *zWalName,
  int bNoShm,
  i64 mxWalSize,
  Wal **ppWal
){
  int rc;
  Wal *pRet;
  int flags;

  ((void)0);
  ((void)0);







  ((void)0);
  ((void)0);




  ((void)0);




  *ppWal = 0;
  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);
  if( !pRet ){
    return 7;
  }

  pRet->pVfs = pVfs;
  pRet->pWalFd = (sqlite3_file *)&pRet[1];
  pRet->pDbFd = pDbFd;
  pRet->readLock = -1;
  pRet->mxWalSize = mxWalSize;
  pRet->zWalName = zWalName;
  pRet->syncHeader = 1;
  pRet->padToSectorBoundary = 1;
  pRet->exclusiveMode = (bNoShm ? 2: 0);


  flags = (0x00000002|0x00000004|0x00080000);
  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);
  if( rc==0 && flags&0x00000001 ){
    pRet->readOnly = 1;
  }

  if( rc!=0 ){
    walIndexClose(pRet, 0);
    sqlite3OsClose(pRet->pWalFd);
    sqlite3_free(pRet);
  }else{
    int iDC = sqlite3OsDeviceCharacteristics(pDbFd);
    if( iDC & 0x00000400 ){ pRet->syncHeader = 0; }
    if( iDC & 0x00001000 ){
      pRet->padToSectorBoundary = 0;
    }
    *ppWal = pRet;
    ;
  }
  return rc;
}




static void sqlite3WalLimit(Wal *pWal, i64 iLimit){
  if( pWal ) pWal->mxWalSize = iLimit;
}
# 59950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walIteratorNext(
  WalIterator *p,
  u32 *piPage,
  u32 *piFrame
){
  u32 iMin;
  u32 iRet = 0xFFFFFFFF;
  int i;

  iMin = p->iPrior;
  ((void)0);
  for(i=p->nSegment-1; i>=0; i--){
    struct WalSegment *pSegment = &p->aSegment[i];
    while( pSegment->iNext<pSegment->nEntry ){
      u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];
      if( iPg>iMin ){
        if( iPg<iRet ){
          iRet = iPg;
          *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];
        }
        break;
      }
      pSegment->iNext++;
    }
  }

  *piPage = p->iPrior = iRet;
  return (iRet==0xFFFFFFFF);
}
# 60003 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void walMerge(
  const u32 *aContent,
  ht_slot *aLeft,
  int nLeft,
  ht_slot **paRight,
  int *pnRight,
  ht_slot *aTmp
){
  int iLeft = 0;
  int iRight = 0;
  int iOut = 0;
  int nRight = *pnRight;
  ht_slot *aRight = *paRight;

  ((void)0);
  while( iRight<nRight || iLeft<nLeft ){
    ht_slot logpage;
    Pgno dbpage;

    if( (iLeft<nLeft)
     && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])
    ){
      logpage = aLeft[iLeft++];
    }else{
      logpage = aRight[iRight++];
    }
    dbpage = aContent[logpage];

    aTmp[iOut++] = logpage;
    if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;

    ((void)0);
    ((void)0);
  }

  *paRight = aLeft;
  *pnRight = iOut;
  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);
}
# 60060 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void walMergesort(
  const u32 *aContent,
  ht_slot *aBuffer,
  ht_slot *aList,
  int *pnList
){
  struct Sublist {
    int nList;
    ht_slot *aList;
  };

  const int nList = *pnList;
  int nMerge = 0;
  ht_slot *aMerge = 0;
  int iList;
  u32 iSub = 0;
  struct Sublist aSub[13];

  memset(aSub, 0, sizeof(aSub));
  ((void)0);
  ((void)0);

  for(iList=0; iList<nList; iList++){
    nMerge = 1;
    aMerge = &aList[iList];
    for(iSub=0; iList & (1<<iSub); iSub++){
      struct Sublist *p;
      ((void)0);
      p = &aSub[iSub];
      ((void)0);
      ((void)0);
      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
    }
    aSub[iSub].aList = aMerge;
    aSub[iSub].nList = nMerge;
  }

  for(iSub++; iSub<((int)(sizeof(aSub)/sizeof(aSub[0]))); iSub++){
    if( nList & (1<<iSub) ){
      struct Sublist *p;
      ((void)0);
      p = &aSub[iSub];
      ((void)0);
      ((void)0);
      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);
    }
  }
  ((void)0);
  *pnList = nMerge;
# 60118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}




static void walIteratorFree(WalIterator *p){
  sqlite3_free(p);
}
# 60140 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walIteratorInit(Wal *pWal, u32 nBackfill, WalIterator **pp){
  WalIterator *p;
  int nSegment;
  u32 iLast;
  sqlite3_int64 nByte;
  int i;
  ht_slot *aTmp;
  int rc = 0;




  ((void)0);
  iLast = pWal->hdr.mxFrame;


  nSegment = walFramePage(iLast) + 1;
  nByte = sizeof(WalIterator)
        + (nSegment-1)*sizeof(struct WalSegment)
        + iLast*sizeof(ht_slot);
  p = (WalIterator *)sqlite3_malloc64(nByte);
  if( !p ){
    return 7;
  }
  memset(p, 0, nByte);
  p->nSegment = nSegment;




  aTmp = (ht_slot *)sqlite3_malloc64(
      sizeof(ht_slot) * (iLast>4096?4096:iLast)
  );
  if( !aTmp ){
    rc = 7;
  }

  for(i=walFramePage(nBackfill+1); rc==0 && i<nSegment; i++){
    WalHashLoc sLoc;

    rc = walHashGet(pWal, i, &sLoc);
    if( rc==0 ){
      int j;
      int nEntry;
      ht_slot *aIndex;

      sLoc.aPgno++;
      if( (i+1)==nSegment ){
        nEntry = (int)(iLast - sLoc.iZero);
      }else{
        nEntry = (int)((u32*)sLoc.aHash - (u32*)sLoc.aPgno);
      }
      aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[sLoc.iZero];
      sLoc.iZero++;

      for(j=0; j<nEntry; j++){
        aIndex[j] = (ht_slot)j;
      }
      walMergesort((u32 *)sLoc.aPgno, aTmp, aIndex, &nEntry);
      p->aSegment[i].iZero = sLoc.iZero;
      p->aSegment[i].nEntry = nEntry;
      p->aSegment[i].aIndex = aIndex;
      p->aSegment[i].aPgno = (u32 *)sLoc.aPgno;
    }
  }
  sqlite3_free(aTmp);

  if( rc!=0 ){
    walIteratorFree(p);
    p = 0;
  }
  *pp = p;
  return rc;
}







static int walBusyLock(
  Wal *pWal,
  int (*xBusy)(void*),
  void *pBusyArg,
  int lockIdx,
  int n
){
  int rc;
  do {
    rc = walLockExclusive(pWal, lockIdx, n);
  }while( xBusy && rc==5 && xBusy(pBusyArg) );
  return rc;
}





static int walPagesize(Wal *pWal){
  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
}
# 60260 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void walRestartHdr(Wal *pWal, u32 salt1){
  volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
  int i;
  u32 *aSalt = pWal->hdr.aSalt;
  pWal->nCkpt++;
  pWal->hdr.mxFrame = 0;
  sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));
  memcpy(&pWal->hdr.aSalt[1], &salt1, 4);
  walIndexWriteHdr(pWal);
  pInfo->nBackfill = 0;
  pInfo->nBackfillAttempted = 0;
  pInfo->aReadMark[1] = 0;
  for(i=2; i<(8 -3); i++) pInfo->aReadMark[i] = 0xffffffff;
  ((void)0);
}
# 60307 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walCheckpoint(
  Wal *pWal,
  sqlite3 *db,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  u8 *zBuf
){
  int rc = 0;
  int szPage;
  WalIterator *pIter = 0;
  u32 iDbpage = 0;
  u32 iFrame = 0;
  u32 mxSafeFrame;
  u32 mxPage;
  int i;
  volatile WalCkptInfo *pInfo;

  szPage = walPagesize(pWal);
  ;
  ;
  pInfo = walCkptInfo(pWal);
  if( pInfo->nBackfill<pWal->hdr.mxFrame ){



    ((void)0);






    mxSafeFrame = pWal->hdr.mxFrame;
    mxPage = pWal->hdr.nPage;
    for(i=1; i<(8 -3); i++){
# 60352 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      u32 y = pInfo->aReadMark[i];
      if( mxSafeFrame>y ){
        ((void)0);
        rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(i)), 1);
        if( rc==0 ){
          pInfo->aReadMark[i] = (i==1 ? mxSafeFrame : 0xffffffff);
          walUnlockExclusive(pWal, (3+(i)), 1);
        }else if( rc==5 ){
          mxSafeFrame = y;
          xBusy = 0;
        }else{
          goto walcheckpoint_out;
        }
      }
    }


    if( pInfo->nBackfill<mxSafeFrame ){
      rc = walIteratorInit(pWal, pInfo->nBackfill, &pIter);
      ((void)0);
    }

    if( pIter
     && (rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(0)),1))==0
    ){
      u32 nBackfill = pInfo->nBackfill;

      pInfo->nBackfillAttempted = mxSafeFrame;


      rc = sqlite3OsSync(pWal->pWalFd, (((sync_flags)>>2)&0x03));




      if( rc==0 ){
        i64 nReq = ((i64)mxPage * szPage);
        i64 nSize;
        rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);
        if( rc==0 && nSize<nReq ){
          sqlite3OsFileControlHint(pWal->pDbFd, 5, &nReq);
        }
      }



      while( rc==0 && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){
        i64 iOffset;
        ((void)0);
        if( db->u1.isInterrupted ){
          rc = db->mallocFailed ? 7 : 9;
          break;
        }
        if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ){
          continue;
        }
        iOffset = ( 32 + ((iFrame)-1)*(i64)((szPage)+24) ) + 24;

        rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);
        if( rc!=0 ) break;
        iOffset = (iDbpage-1)*(i64)szPage;
        ;
        rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);
        if( rc!=0 ) break;
      }


      if( rc==0 ){
        if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){
          i64 szDb = pWal->hdr.nPage*(i64)szPage;
          ;
          rc = sqlite3OsTruncate(pWal->pDbFd, szDb);
          if( rc==0 ){
            rc = sqlite3OsSync(pWal->pDbFd, (((sync_flags)>>2)&0x03));
          }
        }
        if( rc==0 ){
          pInfo->nBackfill = mxSafeFrame;
        }
      }


      walUnlockExclusive(pWal, (3+(0)), 1);
    }

    if( rc==5 ){


      rc = 0;
    }
  }






  if( rc==0 && eMode!=0 ){
    ((void)0);
    if( pInfo->nBackfill<pWal->hdr.mxFrame ){
      rc = 5;
    }else if( eMode>=2 ){
      u32 salt1;
      sqlite3_randomness(4, &salt1);
      ((void)0);
      rc = walBusyLock(pWal, xBusy, pBusyArg, (3+(1)), (8 -3)-1);
      if( rc==0 ){
        if( eMode==3 ){
# 60473 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          walRestartHdr(pWal, salt1);
          rc = sqlite3OsTruncate(pWal->pWalFd, 0);
        }
        walUnlockExclusive(pWal, (3+(1)), (8 -3)-1);
      }
    }
  }

 walcheckpoint_out:
  walIteratorFree(pIter);
  return rc;
}





static void walLimitSize(Wal *pWal, i64 nMax){
  i64 sz;
  int rx;
  sqlite3BeginBenignMalloc();
  rx = sqlite3OsFileSize(pWal->pWalFd, &sz);
  if( rx==0 && (sz > nMax ) ){
    rx = sqlite3OsTruncate(pWal->pWalFd, nMax);
  }
  sqlite3EndBenignMalloc();
  if( rx ){
    sqlite3_log(rx, "cannot limit WAL size: %s", pWal->zWalName);
  }
}




static int sqlite3WalClose(
  Wal *pWal,
  sqlite3 *db,
  int sync_flags,
  int nBuf,
  u8 *zBuf
){
  int rc = 0;
  if( pWal ){
    int isDelete = 0;
# 60526 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( zBuf!=0
     && 0==(rc = sqlite3OsLock(pWal->pDbFd, 4))
    ){
      if( pWal->exclusiveMode==0 ){
        pWal->exclusiveMode = 1;
      }
      rc = sqlite3WalCheckpoint(pWal, db,
          0, 0, 0, sync_flags, nBuf, zBuf, 0, 0
      );
      if( rc==0 ){
        int bPersist = -1;
        sqlite3OsFileControlHint(
            pWal->pDbFd, 10, &bPersist
        );
        if( bPersist!=1 ){



          isDelete = 1;
        }else if( pWal->mxWalSize>=0 ){






          walLimitSize(pWal, 0);
        }
      }
    }

    walIndexClose(pWal, isDelete);
    sqlite3OsClose(pWal->pWalFd);
    if( isDelete ){
      sqlite3BeginBenignMalloc();
      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);
      sqlite3EndBenignMalloc();
    }
    ;
    sqlite3_free((void *)pWal->apWiData);
    sqlite3_free(pWal);
  }
  return rc;
}
# 60588 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walIndexTryHdr(Wal *pWal, int *pChanged){
  u32 aCksum[2];
  WalIndexHdr h1, h2;
  WalIndexHdr volatile *aHdr;


  ((void)0);
# 60606 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  aHdr = walIndexHdr(pWal);
  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));
  walShmBarrier(pWal);
  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));

  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){
    return 1;
  }
  if( h1.isInit==0 ){
    return 1;
  }
  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);
  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){
    return 1;
  }

  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){
    *pChanged = 1;
    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));
    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);
    ;
    ;
  }


  return 0;
}





#define WAL_RETRY (-1)
# 60652 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walIndexReadHdr(Wal *pWal, int *pChanged){
  int rc;
  int badHdr;
  volatile u32 *page0;




  ((void)0);
  rc = walIndexPage(pWal, 0, &page0);
  if( rc!=0 ){
    ((void)0);
    if( rc==(8 | (5<<8)) ){






      ((void)0);
      ((void)0);
      ((void)0);
      pWal->bShmUnreliable = 1;
      pWal->exclusiveMode = 2;
      *pChanged = 1;
    }else{
      return rc;
    }
  }else{


    ;
  }
  ((void)0);






  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);




  ((void)0);
  if( badHdr ){
    if( pWal->bShmUnreliable==0 && (pWal->readOnly & 2) ){
      if( 0==(rc = walLockShared(pWal, 0)) ){
        walUnlockShared(pWal, 0);
        rc = (8 | (1<<8));
      }
    }else if( 0==(rc = walLockExclusive(pWal, 0, 1)) ){
      pWal->writeLock = 1;
      if( 0==(rc = walIndexPage(pWal, 0, &page0)) ){
        badHdr = walIndexTryHdr(pWal, pChanged);
        if( badHdr ){




          rc = walIndexRecover(pWal);
          *pChanged = 1;
        }
      }
      pWal->writeLock = 0;
      walUnlockExclusive(pWal, 0, 1);
    }
  }





  if( badHdr==0 && pWal->hdr.iVersion!=3007000 ){
    rc = sqlite3CantopenError(60727);
  }
  if( pWal->bShmUnreliable ){
    if( rc!=0 ){
      walIndexClose(pWal, 0);
      pWal->bShmUnreliable = 0;
      ((void)0);



      if( rc==(10 | (2<<8)) ) rc = (-1);
    }
    pWal->exclusiveMode = 0;
  }

  return rc;
}
# 60772 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walBeginShmUnreliable(Wal *pWal, int *pChanged){
  i64 szWal;
  i64 iOffset;
  u8 aBuf[32];
  u8 *aFrame = 0;
  int szFrame;
  u8 *aData;
  volatile void *pDummy;
  int rc;
  u32 aSaveCksum[2];

  ((void)0);
  ((void)0);
  ((void)0);




  rc = walLockShared(pWal, (3+(0)));
  if( rc!=0 ){
    if( rc==5 ) rc = (-1);
    goto begin_unreliable_shm_out;
  }
  pWal->readLock = 0;
# 60819 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  rc = sqlite3OsShmMap(pWal->pDbFd, 0, ( sizeof(ht_slot)*(4096*2) + 4096*sizeof(u32) ), 0, &pDummy);
  ((void)0);
  if( rc!=(8 | (5<<8)) ){
    rc = (rc==8 ? (-1) : rc);
    goto begin_unreliable_shm_out;
  }





  memcpy(&pWal->hdr, (void*)walIndexHdr(pWal), sizeof(WalIndexHdr));




  rc = sqlite3OsFileSize(pWal->pWalFd, &szWal);
  if( rc!=0 ){
    goto begin_unreliable_shm_out;
  }
  if( szWal<32 ){






    *pChanged = 1;
    rc = (pWal->hdr.mxFrame==0 ? 0 : (-1));
    goto begin_unreliable_shm_out;
  }


  rc = sqlite3OsRead(pWal->pWalFd, aBuf, 32, 0);
  if( rc!=0 ){
    goto begin_unreliable_shm_out;
  }
  if( memcmp(&pWal->hdr.aSalt, &aBuf[16], 8) ){



    rc = (-1);
    goto begin_unreliable_shm_out;
  }


  szFrame = pWal->hdr.szPage + 24;
  aFrame = (u8 *)sqlite3_malloc64(szFrame);
  if( aFrame==0 ){
    rc = 7;
    goto begin_unreliable_shm_out;
  }
  aData = &aFrame[24];





  aSaveCksum[0] = pWal->hdr.aFrameCksum[0];
  aSaveCksum[1] = pWal->hdr.aFrameCksum[1];
  for(iOffset=( 32 + ((pWal->hdr.mxFrame+1)-1)*(i64)((pWal->hdr.szPage)+24) );
      iOffset+szFrame<=szWal;
      iOffset+=szFrame
  ){
    u32 pgno;
    u32 nTruncate;


    rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);
    if( rc!=0 ) break;
    if( !walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame) ) break;




    if( nTruncate ){
      rc = (-1);
      break;
    }
  }
  pWal->hdr.aFrameCksum[0] = aSaveCksum[0];
  pWal->hdr.aFrameCksum[1] = aSaveCksum[1];

 begin_unreliable_shm_out:
  sqlite3_free(aFrame);
  if( rc!=0 ){
    int i;
    for(i=0; i<pWal->nWiData; i++){
      sqlite3_free((void*)pWal->apWiData[i]);
      pWal->apWiData[i] = 0;
    }
    pWal->bShmUnreliable = 0;
    sqlite3WalEndReadTransaction(pWal);
    *pChanged = 1;
  }
  return rc;
}
# 60967 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){
  volatile WalCkptInfo *pInfo;
  u32 mxReadMark;
  int mxI;
  int i;
  int rc = 0;
  u32 mxFrame;

  ((void)0);


  ((void)0);
# 60997 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( cnt>5 ){
    int nDelay = 1;
    if( cnt>100 ){
     
      return 15;
    }
    if( cnt>=10 ) nDelay = (cnt-9)*(cnt-9)*39;
    sqlite3OsSleep(pWal->pVfs, nDelay);
  }

  if( !useWal ){
    ((void)0);
    if( pWal->bShmUnreliable==0 ){
      rc = walIndexReadHdr(pWal, pChanged);
    }
    if( rc==5 ){
# 61021 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( pWal->apWiData[0]==0 ){







        rc = (-1);
      }else if( 0==(rc = walLockShared(pWal, 2)) ){
        walUnlockShared(pWal, 2);
        rc = (-1);
      }else if( rc==5 ){
        rc = (5 | (1<<8));
      }
    }
    if( rc!=0 ){
      return rc;
    }
    else if( pWal->bShmUnreliable ){
      return walBeginShmUnreliable(pWal, pChanged);
    }
  }

  ((void)0);
  ((void)0);
  pInfo = walCkptInfo(pWal);
  if( !useWal && pInfo->nBackfill==pWal->hdr.mxFrame



  ){



    rc = walLockShared(pWal, (3+(0)));
    walShmBarrier(pWal);
    if( rc==0 ){
      if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr)) ){
# 61073 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        walUnlockShared(pWal, (3+(0)));
        return (-1);
      }
      pWal->readLock = 0;
      return 0;
    }else if( rc!=5 ){
      return rc;
    }
  }






  mxReadMark = 0;
  mxI = 0;
  mxFrame = pWal->hdr.mxFrame;





  for(i=1; i<(8 -3); i++){
    u32 thisMark = (*(pInfo->aReadMark+i));
    if( mxReadMark<=thisMark && thisMark<=mxFrame ){
      ((void)0);
      mxReadMark = thisMark;
      mxI = i;
    }
  }
  if( (pWal->readOnly & 2)==0
   && (mxReadMark<mxFrame || mxI==0)
  ){
    for(i=1; i<(8 -3); i++){
      rc = walLockExclusive(pWal, (3+(i)), 1);
      if( rc==0 ){
        mxReadMark = (*(pInfo->aReadMark+i) = (mxFrame));
        mxI = i;
        walUnlockExclusive(pWal, (3+(i)), 1);
        break;
      }else if( rc!=5 ){
        return rc;
      }
    }
  }
  if( mxI==0 ){
    ((void)0);
    return rc==5 ? (-1) : (8 | (5<<8));
  }

  rc = walLockShared(pWal, (3+(mxI)));
  if( rc ){
    return rc==5 ? (-1) : rc;
  }
# 61162 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pWal->minFrame = (*(&pInfo->nBackfill))+1;
  walShmBarrier(pWal);
  if( (*(pInfo->aReadMark+mxI))!=mxReadMark
   || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))
  ){
    walUnlockShared(pWal, (3+(mxI)));
    return (-1);
  }else{
    ((void)0);
    pWal->readLock = (i16)mxI;
  }
  return rc;
}
# 61266 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){
  int rc;
  int cnt = 0;
# 61278 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  do{
    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);
  }while( rc==(-1) );
  ;
  ;
  ;
  ;
# 61350 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return rc;
}





static void sqlite3WalEndReadTransaction(Wal *pWal){
  sqlite3WalEndWriteTransaction(pWal);
  if( pWal->readLock>=0 ){
    walUnlockShared(pWal, (3+(pWal->readLock)));
    pWal->readLock = -1;
  }
}
# 61373 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalFindFrame(
  Wal *pWal,
  Pgno pgno,
  u32 *piRead
){
  u32 iRead = 0;
  u32 iLast = pWal->hdr.mxFrame;
  int iHash;
  int iMinHash;


  ((void)0);







  if( iLast==0 || (pWal->readLock==0 && pWal->bShmUnreliable==0) ){
    *piRead = 0;
    return 0;
  }
# 61422 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  iMinHash = walFramePage(pWal->minFrame);
  for(iHash=walFramePage(iLast); iHash>=iMinHash; iHash--){
    WalHashLoc sLoc;
    int iKey;
    int nCollide;
    int rc;

    rc = walHashGet(pWal, iHash, &sLoc);
    if( rc!=0 ){
      return rc;
    }
    nCollide = (4096*2);
    for(iKey=walHash(pgno); sLoc.aHash[iKey]; iKey=walNextHash(iKey)){
      u32 iH = sLoc.aHash[iKey];
      u32 iFrame = iH + sLoc.iZero;
      if( iFrame<=iLast && iFrame>=pWal->minFrame && sLoc.aPgno[iH]==pgno ){
        ((void)0);
        iRead = iFrame;
      }
      if( (nCollide--)==0 ){
        return sqlite3CorruptError(61442);
      }
    }
    if( iRead ) break;
  }
# 61466 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  *piRead = iRead;
  return 0;
}






static int sqlite3WalReadFrame(
  Wal *pWal,
  u32 iRead,
  int nOut,
  u8 *pOut
){
  int sz;
  i64 iOffset;
  sz = pWal->hdr.szPage;
  sz = (sz&0xfe00) + ((sz&0x0001)<<16);
  ;
  ;
  iOffset = ( 32 + ((iRead)-1)*(i64)((sz)+24) ) + 24;

  return sqlite3OsRead(pWal->pWalFd, pOut, (nOut>sz ? sz : nOut), iOffset);
}




static Pgno sqlite3WalDbsize(Wal *pWal){
  if( pWal && (pWal->readLock>=0) ){
    return pWal->hdr.nPage;
  }
  return 0;
}
# 61516 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalBeginWriteTransaction(Wal *pWal){
  int rc;



  ((void)0);
  ((void)0);

  if( pWal->readOnly ){
    return 8;
  }




  rc = walLockExclusive(pWal, 0, 1);
  if( rc ){
    return rc;
  }
  pWal->writeLock = 1;





  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = 0;
    rc = (5 | (2<<8));
  }

  return rc;
}





static int sqlite3WalEndWriteTransaction(Wal *pWal){
  if( pWal->writeLock ){
    walUnlockExclusive(pWal, 0, 1);
    pWal->writeLock = 0;
    pWal->iReCksum = 0;
    pWal->truncateOnCommit = 0;
  }
  return 0;
}
# 61576 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){
  int rc = 0;
  if( (pWal->writeLock) ){
    Pgno iMax = pWal->hdr.mxFrame;
    Pgno iFrame;




    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));

    for(iFrame=pWal->hdr.mxFrame+1;
        (rc==0) && iFrame<=iMax;
        iFrame++
    ){
# 61602 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      ((void)0);
      rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));
    }
    if( iMax!=pWal->hdr.mxFrame ) walCleanupHash(pWal);
  }
  return rc;
}







static void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){
  ((void)0);
  aWalData[0] = pWal->hdr.mxFrame;
  aWalData[1] = pWal->hdr.aFrameCksum[0];
  aWalData[2] = pWal->hdr.aFrameCksum[1];
  aWalData[3] = pWal->nCkpt;
}







static int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){
  int rc = 0;

  ((void)0);
  ((void)0);

  if( aWalData[3]!=pWal->nCkpt ){




    aWalData[0] = 0;
    aWalData[3] = pWal->nCkpt;
  }

  if( aWalData[0]<pWal->hdr.mxFrame ){
    pWal->hdr.mxFrame = aWalData[0];
    pWal->hdr.aFrameCksum[0] = aWalData[1];
    pWal->hdr.aFrameCksum[1] = aWalData[2];
    walCleanupHash(pWal);
  }

  return rc;
}
# 61667 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walRestartLog(Wal *pWal){
  int rc = 0;
  int cnt;

  if( pWal->readLock==0 ){
    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);
    ((void)0);
    if( pInfo->nBackfill>0 ){
      u32 salt1;
      sqlite3_randomness(4, &salt1);
      rc = walLockExclusive(pWal, (3+(1)), (8 -3)-1);
      if( rc==0 ){
# 61688 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        walRestartHdr(pWal, salt1);
        walUnlockExclusive(pWal, (3+(1)), (8 -3)-1);
      }else if( rc!=5 ){
        return rc;
      }
    }
    walUnlockShared(pWal, (3+(0)));
    pWal->readLock = -1;
    cnt = 0;
    do{
      int notUsed;
      rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);
    }while( rc==(-1) );
    ((void)0);
    ;
    ;
    ;
  }
  return rc;
}






typedef struct WalWriter {
  Wal *pWal;
  sqlite3_file *pFd;
  sqlite3_int64 iSyncPoint;
  int syncFlags;
  int szPage;
} WalWriter;
# 61730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walWriteToLog(
  WalWriter *p,
  void *pContent,
  int iAmt,
  sqlite3_int64 iOffset
){
  int rc;
  if( iOffset<p->iSyncPoint && iOffset+iAmt>=p->iSyncPoint ){
    int iFirstAmt = (int)(p->iSyncPoint - iOffset);
    rc = sqlite3OsWrite(p->pFd, pContent, iFirstAmt, iOffset);
    if( rc ) return rc;
    iOffset += iFirstAmt;
    iAmt -= iFirstAmt;
    pContent = (void*)(iFirstAmt + (char*)pContent);
    ((void)0);
    rc = sqlite3OsSync(p->pFd, ((p->syncFlags)&0x03));
    if( iAmt==0 || rc ) return rc;
  }
  rc = sqlite3OsWrite(p->pFd, pContent, iAmt, iOffset);
  return rc;
}




static int walWriteOneFrame(
  WalWriter *p,
  PgHdr *pPage,
  int nTruncate,
  sqlite3_int64 iOffset
){
  int rc;
  void *pData;
  u8 aFrame[24];



  pData = pPage->pData;

  walEncodeFrame(p->pWal, pPage->pgno, nTruncate, pData, aFrame);
  rc = walWriteToLog(p, aFrame, sizeof(aFrame), iOffset);
  if( rc ) return rc;

  rc = walWriteToLog(p, pData, p->szPage, iOffset+sizeof(aFrame));
  return rc;
}
# 61785 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walRewriteChecksums(Wal *pWal, u32 iLast){
  const int szPage = pWal->szPage;
  int rc = 0;
  u8 *aBuf;
  u8 aFrame[24];
  u32 iRead;
  i64 iCksumOff;

  aBuf = sqlite3_malloc(szPage + 24);
  if( aBuf==0 ) return 7;






  ((void)0);
  if( pWal->iReCksum==1 ){
    iCksumOff = 24;
  }else{
    iCksumOff = ( 32 + ((pWal->iReCksum-1)-1)*(i64)((szPage)+24) ) + 16;
  }
  rc = sqlite3OsRead(pWal->pWalFd, aBuf, sizeof(u32)*2, iCksumOff);
  pWal->hdr.aFrameCksum[0] = sqlite3Get4byte(aBuf);
  pWal->hdr.aFrameCksum[1] = sqlite3Get4byte(&aBuf[sizeof(u32)]);

  iRead = pWal->iReCksum;
  pWal->iReCksum = 0;
  for(; rc==0 && iRead<=iLast; iRead++){
    i64 iOff = ( 32 + ((iRead)-1)*(i64)((szPage)+24) );
    rc = sqlite3OsRead(pWal->pWalFd, aBuf, szPage+24, iOff);
    if( rc==0 ){
      u32 iPgno, nDbSize;
      iPgno = sqlite3Get4byte(aBuf);
      nDbSize = sqlite3Get4byte(&aBuf[4]);

      walEncodeFrame(pWal, iPgno, nDbSize, &aBuf[24], aFrame);
      rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOff);
    }
  }

  sqlite3_free(aBuf);
  return rc;
}





static int sqlite3WalFrames(
  Wal *pWal,
  int szPage,
  PgHdr *pList,
  Pgno nTruncate,
  int isCommit,
  int sync_flags
){
  int rc;
  u32 iFrame;
  PgHdr *p;
  PgHdr *pLast = 0;
  int nExtra = 0;
  int szFrame;
  i64 iOffset;
  WalWriter w;
  u32 iFirst = 0;
  WalIndexHdr *pLive;

  ((void)0);
  ((void)0);



  ((void)0);
# 61867 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pLive = (WalIndexHdr*)walIndexHdr(pWal);
  if( memcmp(&pWal->hdr, (void *)pLive, sizeof(WalIndexHdr))!=0 ){
    iFirst = pLive->mxFrame+1;
  }




  if( 0!=(rc = walRestartLog(pWal)) ){
    return rc;
  }





  iFrame = pWal->hdr.mxFrame;
  if( iFrame==0 ){
    u8 aWalHdr[32];
    u32 aCksum[2];

    sqlite3Put4byte(&aWalHdr[0], (0x377f0682 | 0));
    sqlite3Put4byte(&aWalHdr[4], 3007000);
    sqlite3Put4byte(&aWalHdr[8], szPage);
    sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);
    if( pWal->nCkpt==0 ) sqlite3_randomness(8, pWal->hdr.aSalt);
    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);
    walChecksumBytes(1, aWalHdr, 32 -2*4, 0, aCksum);
    sqlite3Put4byte(&aWalHdr[24], aCksum[0]);
    sqlite3Put4byte(&aWalHdr[28], aCksum[1]);

    pWal->szPage = szPage;
    pWal->hdr.bigEndCksum = 0;
    pWal->hdr.aFrameCksum[0] = aCksum[0];
    pWal->hdr.aFrameCksum[1] = aCksum[1];
    pWal->truncateOnCommit = 1;

    rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);
    ;
    if( rc!=0 ){
      return rc;
    }
# 61917 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pWal->syncHeader ){
      rc = sqlite3OsSync(pWal->pWalFd, (((sync_flags)>>2)&0x03));
      if( rc ) return rc;
    }
  }
  ((void)0);


  w.pWal = pWal;
  w.pFd = pWal->pWalFd;
  w.iSyncPoint = 0;
  w.syncFlags = sync_flags;
  w.szPage = szPage;
  iOffset = ( 32 + ((iFrame+1)-1)*(i64)((szPage)+24) );
  szFrame = szPage + 24;


  for(p=pList; p; p=p->pDirty){
    int nDbSize;





    if( iFirst && (p->pDirty || isCommit==0) ){
      u32 iWrite = 0;
      sqlite3WalFindFrame(pWal, p->pgno, &iWrite);
      ((void)0);
      if( iWrite>=iFirst ){
        i64 iOff = ( 32 + ((iWrite)-1)*(i64)((szPage)+24) ) + 24;
        void *pData;
        if( pWal->iReCksum==0 || iWrite<pWal->iReCksum ){
          pWal->iReCksum = iWrite;
        }



        pData = p->pData;

        rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOff);
        if( rc ) return rc;
        p->flags &= ~0x040;
        continue;
      }
    }

    iFrame++;
    ((void)0);
    nDbSize = (isCommit && p->pDirty==0) ? nTruncate : 0;
    rc = walWriteOneFrame(&w, p, nDbSize, iOffset);
    if( rc ) return rc;
    pLast = p;
    iOffset += szFrame;
    p->flags |= 0x040;
  }


  if( isCommit && pWal->iReCksum ){
    rc = walRewriteChecksums(pWal, iFrame);
    if( rc ) return rc;
  }
# 61993 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( isCommit && ((sync_flags)&0x03)!=0 ){
    int bSync = 1;
    if( pWal->padToSectorBoundary ){
      int sectorSize = sqlite3SectorSize(pWal->pWalFd);
      w.iSyncPoint = ((iOffset+sectorSize-1)/sectorSize)*sectorSize;
      bSync = (w.iSyncPoint==iOffset);
      ;
      while( iOffset<w.iSyncPoint ){
        rc = walWriteOneFrame(&w, pLast, nTruncate, iOffset);
        if( rc ) return rc;
        iOffset += szFrame;
        nExtra++;
        ((void)0);
      }
    }
    if( bSync ){
      ((void)0);
      rc = sqlite3OsSync(w.pFd, ((sync_flags)&0x03));
    }
  }





  if( isCommit && pWal->truncateOnCommit && pWal->mxWalSize>=0 ){
    i64 sz = pWal->mxWalSize;
    if( ( 32 + ((iFrame+nExtra+1)-1)*(i64)((szPage)+24) )>pWal->mxWalSize ){
      sz = ( 32 + ((iFrame+nExtra+1)-1)*(i64)((szPage)+24) );
    }
    walLimitSize(pWal, sz);
    pWal->truncateOnCommit = 0;
  }






  iFrame = pWal->hdr.mxFrame;
  for(p=pList; p && rc==0; p=p->pDirty){
    if( (p->flags & 0x040)==0 ) continue;
    iFrame++;
    rc = walIndexAppend(pWal, iFrame, p->pgno);
  }
  ((void)0);
  while( rc==0 && nExtra>0 ){
    iFrame++;
    nExtra--;
    rc = walIndexAppend(pWal, iFrame, pLast->pgno);
  }

  if( rc==0 ){

    pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));
    ;
    ;
    pWal->hdr.mxFrame = iFrame;
    if( isCommit ){
      pWal->hdr.iChange++;
      pWal->hdr.nPage = nTruncate;
    }

    if( isCommit ){
      walIndexWriteHdr(pWal);
      pWal->iCallback = iFrame;
    }
  }

  ;
  return rc;
}
# 62076 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalCheckpoint(
  Wal *pWal,
  sqlite3 *db,
  int eMode,
  int (*xBusy)(void*),
  void *pBusyArg,
  int sync_flags,
  int nBuf,
  u8 *zBuf,
  int *pnLog,
  int *pnCkpt
){
  int rc;
  int isChanged = 0;
  int eMode2 = eMode;
  int (*xBusy2)(void*) = xBusy;

  ((void)0);
  ((void)0);



  ((void)0);

  if( pWal->readOnly ) return 8;
  ;



  rc = walLockExclusive(pWal, 1, 1);
  if( rc ){






    ;
    ;
    return rc;
  }
  pWal->ckptLock = 1;
# 62128 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( eMode!=0 ){
    rc = walBusyLock(pWal, xBusy, pBusyArg, 0, 1);
    if( rc==0 ){
      pWal->writeLock = 1;
    }else if( rc==5 ){
      eMode2 = 0;
      xBusy2 = 0;
      rc = 0;
    }
  }


  if( rc==0 ){
    rc = walIndexReadHdr(pWal, &isChanged);
    if( isChanged && pWal->pDbFd->pMethods->iVersion>=3 ){
      sqlite3OsUnfetch(pWal->pDbFd, 0, 0);
    }
  }


  if( rc==0 ){

    if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){
      rc = sqlite3CorruptError(62151);
    }else{
      rc = walCheckpoint(pWal, db, eMode2, xBusy2, pBusyArg, sync_flags, zBuf);
    }


    if( rc==0 || rc==5 ){
      if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;
      if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);
    }
  }

  if( isChanged ){






    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));
  }


  sqlite3WalEndWriteTransaction(pWal);
  walUnlockExclusive(pWal, 1, 1);
  pWal->ckptLock = 0;
  ;
  return (rc==0 && eMode!=eMode2 ? 5 : rc);
}






static int sqlite3WalCallback(Wal *pWal){
  u32 ret = 0;
  if( pWal ){
    ret = pWal->iCallback;
    pWal->iCallback = 0;
  }
  return (int)ret;
}
# 62219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalExclusiveMode(Wal *pWal, int op){
  int rc;
  ((void)0);
  ((void)0);







  ((void)0);
  ((void)0);

  if( op==0 ){
    if( pWal->exclusiveMode!=0 ){
      pWal->exclusiveMode = 0;
      if( walLockShared(pWal, (3+(pWal->readLock)))!=0 ){
        pWal->exclusiveMode = 1;
      }
      rc = pWal->exclusiveMode==0;
    }else{

      rc = 0;
    }
  }else if( op>0 ){
    ((void)0);
    ((void)0);
    walUnlockShared(pWal, (3+(pWal->readLock)));
    pWal->exclusiveMode = 1;
    rc = 1;
  }else{
    rc = pWal->exclusiveMode==0;
  }
  return rc;
}






static int sqlite3WalHeapMemory(Wal *pWal){
  return (pWal && pWal->exclusiveMode==2 );
}
# 62367 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_file *sqlite3WalFile(Wal *pWal){
  return pWal->pWalFd;
}
# 62615 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define MX_CELL_SIZE(pBt) ((int)(pBt->pageSize-8))






#define MX_CELL(pBt) ((pBt->pageSize-8)/6)


typedef struct MemPage MemPage;
typedef struct BtLock BtLock;
typedef struct CellInfo CellInfo;
# 62642 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_FILE_HEADER "SQLite format 3"






#define PTF_INTKEY 0x01
#define PTF_ZERODATA 0x02
#define PTF_LEAFDATA 0x04
#define PTF_LEAF 0x08
# 62666 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct MemPage {
  u8 isInit;
  u8 bBusy;
  u8 intKey;
  u8 intKeyLeaf;
  Pgno pgno;


  u8 leaf;
  u8 hdrOffset;
  u8 childPtrSize;
  u8 max1bytePayload;
  u8 nOverflow;
  u16 maxLocal;
  u16 minLocal;
  u16 cellOffset;
  int nFree;
  u16 nCell;
  u16 maskPage;
  u16 aiOvfl[4];

  u8 *apOvfl[4];
  BtShared *pBt;
  u8 *aData;
  u8 *aDataEnd;
  u8 *aCellIdx;
  u8 *aDataOfst;
  DbPage *pDbPage;
  u16 (*xCellSize)(MemPage*,u8*);
  void (*xParseCell)(MemPage*,u8*,CellInfo*);
};
# 62705 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct BtLock {
  Btree *pBtree;
  Pgno iTable;
  u8 eLock;
  BtLock *pNext;
};


#define READ_LOCK 1
#define WRITE_LOCK 2
# 62737 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct Btree {
  sqlite3 *db;
  BtShared *pBt;
  u8 inTrans;
  u8 sharable;
  u8 locked;
  u8 hasIncrblobCur;
  int wantToLock;
  int nBackup;
  u32 iDataVersion;
  Btree *pNext;
  Btree *pPrev;

  BtLock lock;

};
# 62761 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TRANS_NONE 0
#define TRANS_READ 1
#define TRANS_WRITE 2
# 62800 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct BtShared {
  Pager *pPager;
  sqlite3 *db;
  BtCursor *pCursor;
  MemPage *pPage1;
  u8 openFlags;

  u8 autoVacuum;
  u8 incrVacuum;
  u8 bDoTruncate;

  u8 inTransaction;
  u8 max1bytePayload;



  u16 btsFlags;
  u16 maxLocal;
  u16 minLocal;
  u16 maxLeaf;
  u16 minLeaf;
  u32 pageSize;
  u32 usableSize;
  int nTransaction;
  u32 nPage;
  void *pSchema;
  void (*xFreeSchema)(void*);
  sqlite3_mutex *mutex;
  Bitvec *pHasContent;

  int nRef;
  BtShared *pNext;
  BtLock *pLock;
  Btree *pWriter;

  u8 *pTmpSpace;
};




#define BTS_READ_ONLY 0x0001
#define BTS_PAGESIZE_FIXED 0x0002
#define BTS_SECURE_DELETE 0x0004
#define BTS_OVERWRITE 0x0008
#define BTS_FAST_SECURE 0x000c
#define BTS_INITIALLY_EMPTY 0x0010
#define BTS_NO_WAL 0x0020
#define BTS_EXCLUSIVE 0x0040
#define BTS_PENDING 0x0080






struct CellInfo {
  i64 nKey;
  u8 *pPayload;
  u32 nPayload;
  u16 nLocal;
  u16 nSize;
};
# 62873 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define BTCURSOR_MAX_DEPTH 20
# 62901 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct BtCursor {
  u8 eState;
  u8 curFlags;
  u8 curPagerFlags;
  u8 hints;
  int skipNext;

  Btree *pBtree;
  Pgno *aOverflow;
  void *pKey;



#define BTCURSOR_FIRST_UNINIT pBt
  BtShared *pBt;
  BtCursor *pNext;
  CellInfo info;
  i64 nKey;
  Pgno pgnoRoot;
  i8 iPage;
  u8 curIntKey;
  u16 ix;
  u16 aiIdx[20 -1];
  struct KeyInfo *pKeyInfo;
  MemPage *pPage;
  MemPage *apPage[20 -1];
};




#define BTCF_WriteFlag 0x01
#define BTCF_ValidNKey 0x02
#define BTCF_ValidOvfl 0x04
#define BTCF_AtLast 0x08
#define BTCF_Incrblob 0x10
#define BTCF_Multiple 0x20
# 62969 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define CURSOR_VALID 0
#define CURSOR_INVALID 1
#define CURSOR_SKIPNEXT 2
#define CURSOR_REQUIRESEEK 3
#define CURSOR_FAULT 4




#define PENDING_BYTE_PAGE(pBt) PAGER_MJ_PGNO(pBt)
# 62995 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PTRMAP_PAGENO(pBt,pgno) ptrmapPageno(pBt, pgno)
#define PTRMAP_PTROFFSET(pgptrmap,pgno) (5*(pgno-pgptrmap-1))
#define PTRMAP_ISPAGE(pBt,pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))
# 63030 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PTRMAP_ROOTPAGE 1
#define PTRMAP_FREEPAGE 2
#define PTRMAP_OVERFLOW1 3
#define PTRMAP_OVERFLOW2 4
#define PTRMAP_BTREE 5




#define btreeIntegrity(p) assert( p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 ); assert( p->pBt->inTransaction>=p->inTrans );
# 63052 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ISAUTOVACUUM (pBt->autoVacuum)
# 63068 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct IntegrityCk IntegrityCk;
struct IntegrityCk {
  BtShared *pBt;
  Pager *pPager;
  u8 *aPgRef;
  Pgno nPage;
  int mxErr;
  int nErr;
  int mallocFailed;
  const char *zPfx;
  int v1, v2;
  StrAccum errMsg;
  u32 *heap;
};




#define get2byte(x) ((x)[0]<<8 | (x)[1])
#define put2byte(p,v) ((p)[0] = (u8)((v)>>8), (p)[1] = (u8)(v))
#define get4byte sqlite3Get4byte
#define put4byte sqlite3Put4byte
# 63099 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define get2byteAligned(x) __builtin_bswap16(*(u16*)(x))
# 63116 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void lockBtreeMutex(Btree *p){
  ((void)0);
  ((void)0);
  ((void)0);

  sqlite3_mutex_enter(p->pBt->mutex);
  p->pBt->db = p->db;
  p->locked = 1;
}





static void __attribute__((noinline)) unlockBtreeMutex(Btree *p){
  BtShared *pBt = p->pBt;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  sqlite3_mutex_leave(pBt->mutex);
  p->locked = 0;
}


static void __attribute__((noinline)) btreeLockCarefully(Btree *p);
# 63160 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BtreeEnter(Btree *p){




  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  ((void)0);
  ((void)0);


  ((void)0);



  ((void)0);

  if( !p->sharable ) return;
  p->wantToLock++;
  if( p->locked ) return;
  btreeLockCarefully(p);
}







static void __attribute__((noinline)) btreeLockCarefully(Btree *p){
  Btree *pLater;





  if( sqlite3_mutex_try(p->pBt->mutex)==0 ){
    p->pBt->db = p->db;
    p->locked = 1;
    return;
  }






  for(pLater=p->pNext; pLater; pLater=pLater->pNext){
    ((void)0);
    ((void)0);
    ((void)0);
    if( pLater->locked ){
      unlockBtreeMutex(pLater);
    }
  }
  lockBtreeMutex(p);
  for(pLater=p->pNext; pLater; pLater=pLater->pNext){
    if( pLater->wantToLock ){
      lockBtreeMutex(pLater);
    }
  }
}





static void sqlite3BtreeLeave(Btree *p){
  ((void)0);
  if( p->sharable ){
    ((void)0);
    p->wantToLock--;
    if( p->wantToLock==0 ){
      unlockBtreeMutex(p);
    }
  }
}
# 63275 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void __attribute__((noinline)) btreeEnterAll(sqlite3 *db){
  int i;
  int skipOk = 1;
  Btree *p;
  ((void)0);
  for(i=0; i<db->nDb; i++){
    p = db->aDb[i].pBt;
    if( p && p->sharable ){
      sqlite3BtreeEnter(p);
      skipOk = 0;
    }
  }
  db->noSharedCache = skipOk;
}
static void sqlite3BtreeEnterAll(sqlite3 *db){
  if( db->noSharedCache==0 ) btreeEnterAll(db);
}
static void __attribute__((noinline)) btreeLeaveAll(sqlite3 *db){
  int i;
  Btree *p;
  ((void)0);
  for(i=0; i<db->nDb; i++){
    p = db->aDb[i].pBt;
    if( p ) sqlite3BtreeLeave(p);
  }
}
static void sqlite3BtreeLeaveAll(sqlite3 *db){
  if( db->noSharedCache==0 ) btreeLeaveAll(db);
}
# 63387 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BtreeEnterCursor(BtCursor *pCur){
  sqlite3BtreeEnter(pCur->pBtree);
}

static void sqlite3BtreeLeaveCursor(BtCursor *pCur){
  sqlite3BtreeLeave(pCur->pBtree);
}
# 63422 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char zMagicHeader[] = "SQLite format 3";
# 63432 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TRACE(X) 
# 63444 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define get2byteNotZero(X) (((((int)get2byte(X))-1)&0xffff)+1)




#define BTALLOC_ANY 0
#define BTALLOC_EXACT 1
#define BTALLOC_LE 2
# 63460 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IfNotOmitAV(expr) (expr)
# 63477 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static BtShared * sqlite3SharedCacheList = 0;
# 63489 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_enable_shared_cache(int enable){
  sqlite3Config.sharedCacheEnabled = enable;
  return 0;
}
# 63540 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_CORRUPT_PAGE(pMemPage) SQLITE_CORRUPT_PGNO(pMemPage->pgno)
# 63675 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int querySharedCacheTableLock(Btree *p, Pgno iTab, u8 eLock){
  BtShared *pBt = p->pBt;
  BtLock *pIter;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);





  ((void)0);
  ((void)0);


  if( !p->sharable ){
    return 0;
  }




  if( pBt->pWriter!=p && (pBt->btsFlags & 0x0040)!=0 ){
    ;
    return (6 | (1<<8));
  }

  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
# 63714 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    ((void)0);
    if( pIter->pBtree!=p && pIter->iTable==iTab && pIter->eLock!=eLock ){
      ;
      if( eLock==2 ){
        ((void)0);
        pBt->btsFlags |= 0x0080;
      }
      return (6 | (1<<8));
    }
  }
  return 0;
}
# 63747 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int setSharedCacheTableLock(Btree *p, Pgno iTable, u8 eLock){
  BtShared *pBt = p->pBt;
  BtLock *pLock = 0;
  BtLock *pIter;

  ((void)0);
  ((void)0);
  ((void)0);





  ((void)0);



  ((void)0);
  ((void)0);


  for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
    if( pIter->iTable==iTable && pIter->pBtree==p ){
      pLock = pIter;
      break;
    }
  }




  if( !pLock ){
    pLock = (BtLock *)sqlite3MallocZero(sizeof(BtLock));
    if( !pLock ){
      return 7;
    }
    pLock->iTable = iTable;
    pLock->pBtree = p;
    pLock->pNext = pBt->pLock;
    pBt->pLock = pLock;
  }





  ((void)0);
  if( eLock>pLock->eLock ){
    pLock->eLock = eLock;
  }

  return 0;
}
# 63811 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void clearAllSharedCacheTableLocks(Btree *p){
  BtShared *pBt = p->pBt;
  BtLock **ppIter = &pBt->pLock;

  ((void)0);
  ((void)0);
  ((void)0);

  while( *ppIter ){
    BtLock *pLock = *ppIter;
    ((void)0);
    ((void)0);
    if( pLock->pBtree==p ){
      *ppIter = pLock->pNext;
      ((void)0);
      if( pLock->iTable!=1 ){
        sqlite3_free(pLock);
      }
    }else{
      ppIter = &pLock->pNext;
    }
  }

  ((void)0);
  if( pBt->pWriter==p ){
    pBt->pWriter = 0;
    pBt->btsFlags &= ~(0x0040|0x0080);
  }else if( pBt->nTransaction==2 ){
# 63848 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pBt->btsFlags &= ~0x0080;
  }
}




static void downgradeAllSharedCacheTableLocks(Btree *p){
  BtShared *pBt = p->pBt;
  if( pBt->pWriter==p ){
    BtLock *pLock;
    pBt->pWriter = 0;
    pBt->btsFlags &= ~(0x0040|0x0080);
    for(pLock=pBt->pLock; pLock; pLock=pLock->pNext){
      ((void)0);
      pLock->eLock = 1;
    }
  }
}



static void releasePage(MemPage *pPage);
static void releasePageOne(MemPage *pPage);
static void releasePageNotNull(MemPage *pPage);
# 63902 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define invalidateOverflowCache(pCur) (pCur->curFlags &= ~BTCF_ValidOvfl)





static void invalidateAllOverflowCache(BtShared *pBt){
  BtCursor *p;
  ((void)0);
  for(p=pBt->pCursor; p; p=p->pNext){
    (p->curFlags &= ~0x04);
  }
}
# 63930 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void invalidateIncrblobCursors(
  Btree *pBtree,
  Pgno pgnoRoot,
  i64 iRow,
  int isClearTable
){
  BtCursor *p;
  if( pBtree->hasIncrblobCur==0 ) return;
  ((void)0);
  pBtree->hasIncrblobCur = 0;
  for(p=pBtree->pBt->pCursor; p; p=p->pNext){
    if( (p->curFlags & 0x10)!=0 ){
      pBtree->hasIncrblobCur = 1;
      if( p->pgnoRoot==pgnoRoot && (isClearTable || p->info.nKey==iRow) ){
        p->eState = 1;
      }
    }
  }
}
# 63990 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeSetHasContent(BtShared *pBt, Pgno pgno){
  int rc = 0;
  if( !pBt->pHasContent ){
    ((void)0);
    pBt->pHasContent = sqlite3BitvecCreate(pBt->nPage);
    if( !pBt->pHasContent ){
      rc = 7;
    }
  }
  if( rc==0 && pgno<=sqlite3BitvecSize(pBt->pHasContent) ){
    rc = sqlite3BitvecSet(pBt->pHasContent, pgno);
  }
  return rc;
}
# 64012 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeGetHasContent(BtShared *pBt, Pgno pgno){
  Bitvec *p = pBt->pHasContent;
  return (p && (pgno>sqlite3BitvecSize(p) || sqlite3BitvecTest(p, pgno)));
}





static void btreeClearHasContent(BtShared *pBt){
  sqlite3BitvecDestroy(pBt->pHasContent);
  pBt->pHasContent = 0;
}




static void btreeReleaseAllCursorPages(BtCursor *pCur){
  int i;
  if( pCur->iPage>=0 ){
    for(i=0; i<pCur->iPage; i++){
      releasePageNotNull(pCur->apPage[i]);
    }
    releasePageNotNull(pCur->pPage);
    pCur->iPage = -1;
  }
}
# 64053 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int saveCursorKey(BtCursor *pCur){
  int rc = 0;
  ((void)0);
  ((void)0);
  ((void)0);

  if( pCur->curIntKey ){

    pCur->nKey = sqlite3BtreeIntegerKey(pCur);
  }else{






    void *pKey;
    pCur->nKey = sqlite3BtreePayloadSize(pCur);
    pKey = sqlite3Malloc( pCur->nKey + 9 + 8 );
    if( pKey ){
      rc = sqlite3BtreePayload(pCur, 0, (int)pCur->nKey, pKey);
      if( rc==0 ){
        memset(((u8*)pKey)+pCur->nKey, 0, 9+8);
        pCur->pKey = pKey;
      }else{
        sqlite3_free(pKey);
      }
    }else{
      rc = 7;
    }
  }
  ((void)0);
  return rc;
}
# 64095 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int saveCursorPosition(BtCursor *pCur){
  int rc;

  ((void)0);
  ((void)0);
  ((void)0);

  if( pCur->eState==2 ){
    pCur->eState = 0;
  }else{
    pCur->skipNext = 0;
  }

  rc = saveCursorKey(pCur);
  if( rc==0 ){
    btreeReleaseAllCursorPages(pCur);
    pCur->eState = 3;
  }

  pCur->curFlags &= ~(0x02|0x04|0x08);
  return rc;
}


static int __attribute__((noinline)) saveCursorsOnList(BtCursor*,Pgno,BtCursor*);
# 64142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int saveAllCursors(BtShared *pBt, Pgno iRoot, BtCursor *pExcept){
  BtCursor *p;
  ((void)0);
  ((void)0);
  for(p=pBt->pCursor; p; p=p->pNext){
    if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ) break;
  }
  if( p ) return saveCursorsOnList(p, iRoot, pExcept);
  if( pExcept ) pExcept->curFlags &= ~0x20;
  return 0;
}






static int __attribute__((noinline)) saveCursorsOnList(
  BtCursor *p,
  Pgno iRoot,
  BtCursor *pExcept
){
  do{
    if( p!=pExcept && (0==iRoot || p->pgnoRoot==iRoot) ){
      if( p->eState==0 || p->eState==2 ){
        int rc = saveCursorPosition(p);
        if( 0!=rc ){
          return rc;
        }
      }else{
        ;
        btreeReleaseAllCursorPages(p);
      }
    }
    p = p->pNext;
  }while( p );
  return 0;
}




static void sqlite3BtreeClearCursor(BtCursor *pCur){
  ((void)0);
  sqlite3_free(pCur->pKey);
  pCur->pKey = 0;
  pCur->eState = 1;
}






static int btreeMoveto(
  BtCursor *pCur,
  const void *pKey,
  i64 nKey,
  int bias,
  int *pRes
){
  int rc;
  UnpackedRecord *pIdxKey;

  if( pKey ){
    KeyInfo *pKeyInfo = pCur->pKeyInfo;
    ((void)0);
    pIdxKey = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
    if( pIdxKey==0 ) return 7;
    sqlite3VdbeRecordUnpack(pKeyInfo, (int)nKey, pKey, pIdxKey);
    if( pIdxKey->nField==0 || pIdxKey->nField>pKeyInfo->nAllField ){
      rc = sqlite3CorruptError(64213);
      goto moveto_done;
    }
  }else{
    pIdxKey = 0;
  }
  rc = sqlite3BtreeMovetoUnpacked(pCur, pIdxKey, nKey, bias, pRes);
moveto_done:
  if( pIdxKey ){
    sqlite3DbFree(pCur->pKeyInfo->db, pIdxKey);
  }
  return rc;
}
# 64234 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeRestoreCursorPosition(BtCursor *pCur){
  int rc;
  int skipNext = 0;
  ((void)0);
  ((void)0);
  if( pCur->eState==4 ){
    return pCur->skipNext;
  }
  pCur->eState = 1;
  if( sqlite3FaultSim(410) ){
    rc = 10;
  }else{
    rc = btreeMoveto(pCur, pCur->pKey, pCur->nKey, 0, &skipNext);
  }
  if( rc==0 ){
    sqlite3_free(pCur->pKey);
    pCur->pKey = 0;
    ((void)0);
    if( skipNext ) pCur->skipNext = skipNext;
    if( pCur->skipNext && pCur->eState==0 ){
      pCur->eState = 2;
    }
  }
  return rc;
}

#define restoreCursorPosition(p) (p->eState>=CURSOR_REQUIRESEEK ? btreeRestoreCursorPosition(p) : SQLITE_OK)
# 64277 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCursorHasMoved(BtCursor *pCur){
  ((void)0)
                                               ;
  ((void)0);
  ((void)0);
  return 0 != *(u8*)pCur;
}






static BtCursor *sqlite3BtreeFakeValidCursor(void){
  static u8 fakeCursor = 0;
  ((void)0);
  return (BtCursor*)&fakeCursor;
}
# 64309 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCursorRestore(BtCursor *pCur, int *pDifferentRow){
  int rc;

  ((void)0);
  ((void)0);
  rc = (pCur->eState>=3 ? btreeRestoreCursorPosition(pCur) : 0);
  if( rc ){
    *pDifferentRow = 1;
    return rc;
  }
  if( pCur->eState!=0 ){
    *pDifferentRow = 1;
  }else{
    *pDifferentRow = 0;
  }
  return 0;
}
# 64341 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BtreeCursorHintFlags(BtCursor *pCur, unsigned x){
  ((void)0);
  pCur->hints = x;
}
# 64357 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Pgno ptrmapPageno(BtShared *pBt, Pgno pgno){
  int nPagesPerMapPage;
  Pgno iPtrMap, ret;
  ((void)0);
  if( pgno<2 ) return 0;
  nPagesPerMapPage = (pBt->usableSize/5)+1;
  iPtrMap = (pgno-2)/nPagesPerMapPage;
  ret = (iPtrMap*nPagesPerMapPage) + 2;
  if( ret==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    ret++;
  }
  return ret;
}
# 64381 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void ptrmapPut(BtShared *pBt, Pgno key, u8 eType, Pgno parent, int *pRC){
  DbPage *pDbPage;
  u8 *pPtrmap;
  Pgno iPtrmap;
  int offset;
  int rc;

  if( *pRC ) return;

  ((void)0);

  ((void)0);

  ((void)0);
  if( key==0 ){
    *pRC = sqlite3CorruptError(64396);
    return;
  }
  iPtrmap = ptrmapPageno(pBt, key);
  rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);
  if( rc!=0 ){
    *pRC = rc;
    return;
  }
  if( ((char*)sqlite3PagerGetExtra(pDbPage))[0]!=0 ){



    *pRC = sqlite3CorruptError(64409);
    goto ptrmap_exit;
  }
  offset = (5*(key-iPtrmap-1));
  if( offset<0 ){
    *pRC = sqlite3CorruptError(64414);
    goto ptrmap_exit;
  }
  ((void)0);
  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

  if( eType!=pPtrmap[offset] || sqlite3Get4byte(&pPtrmap[offset+1])!=parent ){
    ;
    *pRC= rc = sqlite3PagerWrite(pDbPage);
    if( rc==0 ){
      pPtrmap[offset] = eType;
      sqlite3Put4byte(&pPtrmap[offset+1], parent);
    }
  }

ptrmap_exit:
  sqlite3PagerUnref(pDbPage);
}
# 64440 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int ptrmapGet(BtShared *pBt, Pgno key, u8 *pEType, Pgno *pPgno){
  DbPage *pDbPage;
  int iPtrmap;
  u8 *pPtrmap;
  int offset;
  int rc;

  ((void)0);

  iPtrmap = ptrmapPageno(pBt, key);
  rc = sqlite3PagerGet(pBt->pPager, iPtrmap, &pDbPage, 0);
  if( rc!=0 ){
    return rc;
  }
  pPtrmap = (u8 *)sqlite3PagerGetData(pDbPage);

  offset = (5*(key-iPtrmap-1));
  if( offset<0 ){
    sqlite3PagerUnref(pDbPage);
    return sqlite3CorruptError(64459);
  }
  ((void)0);
  ((void)0);
  *pEType = pPtrmap[offset];
  if( pPgno ) *pPgno = sqlite3Get4byte(&pPtrmap[offset+1]);

  sqlite3PagerUnref(pDbPage);
  if( *pEType<1 || *pEType>5 ) return sqlite3CorruptError(64467);
  return 0;
}
# 64487 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define findCell(P,I) ((P)->aData + ((P)->maskPage & get2byteAligned(&(P)->aCellIdx[2*(I)])))

#define findCellPastPtr(P,I) ((P)->aDataOfst + ((P)->maskPage & get2byteAligned(&(P)->aCellIdx[2*(I)])))
# 64499 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) void btreeParseCellAdjustSizeForOverflow(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
# 64513 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  int minLocal;
  int maxLocal;
  int surplus;

  minLocal = pPage->minLocal;
  maxLocal = pPage->maxLocal;
  surplus = minLocal + (pInfo->nPayload - minLocal)%(pPage->pBt->usableSize-4);
  ;
  ;
  if( surplus <= maxLocal ){
    pInfo->nLocal = (u16)surplus;
  }else{
    pInfo->nLocal = (u16)minLocal;
  }
  pInfo->nSize = (u16)(&pInfo->pPayload[pInfo->nLocal] - pCell) + 4;
}
# 64544 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void btreeParseCellPtrNoPayload(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
  ((void)0);
  ((void)0);
  ((void)0);

  (void)(pPage);

  pInfo->nSize = 4 + sqlite3GetVarint(&pCell[4], (u64*)&pInfo->nKey);
  pInfo->nPayload = 0;
  pInfo->nLocal = 0;
  pInfo->pPayload = 0;
  return;
}
static void btreeParseCellPtr(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
  u8 *pIter;
  u32 nPayload;
  u64 iKey;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  pIter = pCell;







  nPayload = *pIter;
  if( nPayload>=0x80 ){
    u8 *pEnd = &pIter[8];
    nPayload &= 0x7f;
    do{
      nPayload = (nPayload<<7) | (*++pIter & 0x7f);
    }while( (*pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;







  iKey = *pIter;
  if( iKey>=0x80 ){
    u8 *pEnd = &pIter[7];
    iKey &= 0x7f;
    while(1){
      iKey = (iKey<<7) | (*++pIter & 0x7f);
      if( (*pIter)<0x80 ) break;
      if( pIter>=pEnd ){
        iKey = (iKey<<8) | *++pIter;
        break;
      }
    }
  }
  pIter++;

  pInfo->nKey = *(i64*)&iKey;
  pInfo->nPayload = nPayload;
  pInfo->pPayload = pIter;
  ;
  ;
  if( nPayload<=pPage->maxLocal ){



    pInfo->nSize = nPayload + (u16)(pIter - pCell);
    if( pInfo->nSize<4 ) pInfo->nSize = 4;
    pInfo->nLocal = (u16)nPayload;
  }else{
    btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
  }
}
static void btreeParseCellPtrIndex(
  MemPage *pPage,
  u8 *pCell,
  CellInfo *pInfo
){
  u8 *pIter;
  u32 nPayload;

  ((void)0);
  ((void)0);
  ((void)0);
  pIter = pCell + pPage->childPtrSize;
  nPayload = *pIter;
  if( nPayload>=0x80 ){
    u8 *pEnd = &pIter[8];
    nPayload &= 0x7f;
    do{
      nPayload = (nPayload<<7) | (*++pIter & 0x7f);
    }while( *(pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;
  pInfo->nKey = nPayload;
  pInfo->nPayload = nPayload;
  pInfo->pPayload = pIter;
  ;
  ;
  if( nPayload<=pPage->maxLocal ){



    pInfo->nSize = nPayload + (u16)(pIter - pCell);
    if( pInfo->nSize<4 ) pInfo->nSize = 4;
    pInfo->nLocal = (u16)nPayload;
  }else{
    btreeParseCellAdjustSizeForOverflow(pPage, pCell, pInfo);
  }
}
static void btreeParseCell(
  MemPage *pPage,
  int iCell,
  CellInfo *pInfo
){
  pPage->xParseCell(pPage, ((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(iCell)])))), pInfo);
}
# 64686 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u16 cellSizePtr(MemPage *pPage, u8 *pCell){
  u8 *pIter = pCell + pPage->childPtrSize;
  u8 *pEnd;
  u32 nSize;
# 64700 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  nSize = *pIter;
  if( nSize>=0x80 ){
    pEnd = &pIter[8];
    nSize &= 0x7f;
    do{
      nSize = (nSize<<7) | (*++pIter & 0x7f);
    }while( *(pIter)>=0x80 && pIter<pEnd );
  }
  pIter++;
  if( pPage->intKey ){



    pEnd = &pIter[9];
    while( (*pIter++)&0x80 && pIter<pEnd );
  }
  ;
  ;
  if( nSize<=pPage->maxLocal ){
    nSize += (u32)(pIter - pCell);
    if( nSize<4 ) nSize = 4;
  }else{
    int minLocal = pPage->minLocal;
    nSize = minLocal + (nSize - minLocal) % (pPage->pBt->usableSize - 4);
    ;
    ;
    if( nSize>pPage->maxLocal ){
      nSize = minLocal;
    }
    nSize += 4 + (u16)(pIter - pCell);
  }
  ((void)0);
  return (u16)nSize;
}
static u16 cellSizePtrNoPayload(MemPage *pPage, u8 *pCell){
  u8 *pIter = pCell + 4;
  u8 *pEnd;
# 64746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(pPage);


  ((void)0);
  pEnd = pIter + 9;
  while( (*pIter++)&0x80 && pIter<pEnd );
  ((void)0);
  return (u16)(pIter - pCell);
}
# 64772 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void ptrmapPutOvflPtr(MemPage *pPage, MemPage *pSrc, u8 *pCell,int *pRC){
  CellInfo info;
  if( *pRC ) return;
  ((void)0);
  pPage->xParseCell(pPage, pCell, &info);
  if( info.nLocal<info.nPayload ){
    Pgno ovfl;
    if( (((uptr)(pSrc->aDataEnd)>=(uptr)(pCell))&&((uptr)(pSrc->aDataEnd)<(uptr)(pCell+info.nLocal))) ){
      ;
      *pRC = sqlite3CorruptError(64781);
      return;
    }
    ovfl = sqlite3Get4byte(&pCell[info.nSize-4]);
    ptrmapPut(pPage->pBt, ovfl, 3, pPage->pgno, pRC);
  }
}
# 64803 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int defragmentPage(MemPage *pPage, int nMaxFrag){
  int i;
  int pc;
  int hdr;
  int size;
  int usableSize;
  int cellOffset;
  int cbrk;
  int nCell;
  unsigned char *data;
  unsigned char *temp;
  unsigned char *src;
  int iCellFirst;
  int iCellLast;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  temp = 0;
  src = data = pPage->aData;
  hdr = pPage->hdrOffset;
  cellOffset = pPage->cellOffset;
  nCell = pPage->nCell;
  ((void)0);
  iCellFirst = cellOffset + 2*nCell;
  usableSize = pPage->pBt->usableSize;






  if( (int)data[hdr+7]<=nMaxFrag ){
    int iFree = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
    if( iFree>usableSize-4 ) return sqlite3CorruptError(64839);
    if( iFree ){
      int iFree2 = ((&data[iFree])[0]<<8 | (&data[iFree])[1]);
      if( iFree2>usableSize-4 ) return sqlite3CorruptError(64842);
      if( 0==iFree2 || (data[iFree2]==0 && data[iFree2+1]==0) ){
        u8 *pEnd = &data[cellOffset + nCell*2];
        u8 *pAddr;
        int sz2 = 0;
        int sz = ((&data[iFree+2])[0]<<8 | (&data[iFree+2])[1]);
        int top = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]);
        if( top>=iFree ){
          return sqlite3CorruptError(64850);
        }
        if( iFree2 ){
          if( iFree+sz>iFree2 ) return sqlite3CorruptError(64853);
          sz2 = ((&data[iFree2+2])[0]<<8 | (&data[iFree2+2])[1]);
          if( iFree2+sz2 > usableSize ) return sqlite3CorruptError(64855);
          memmove(&data[iFree+sz+sz2], &data[iFree+sz], iFree2-(iFree+sz));
          sz += sz2;
        }else if( iFree+sz>usableSize ){
          return sqlite3CorruptError(64859);
        }

        cbrk = top+sz;
        ((void)0);
        memmove(&data[cbrk], &data[top], iFree-top);
        for(pAddr=&data[cellOffset]; pAddr<pEnd; pAddr+=2){
          pc = ((pAddr)[0]<<8 | (pAddr)[1]);
          if( pc<iFree ){ ((pAddr)[0] = (u8)((pc+sz)>>8), (pAddr)[1] = (u8)(pc+sz)); }
          else if( pc<iFree2 ){ ((pAddr)[0] = (u8)((pc+sz2)>>8), (pAddr)[1] = (u8)(pc+sz2)); }
        }
        goto defragment_out;
      }
    }
  }

  cbrk = usableSize;
  iCellLast = usableSize - 4;
  for(i=0; i<nCell; i++){
    u8 *pAddr;
    pAddr = &data[cellOffset + i*2];
    pc = ((pAddr)[0]<<8 | (pAddr)[1]);
    ;
    ;



    if( pc<iCellFirst || pc>iCellLast ){
      return sqlite3CorruptError(64887);
    }
    ((void)0);
    size = pPage->xCellSize(pPage, &src[pc]);
    cbrk -= size;
    if( cbrk<iCellFirst || pc+size>usableSize ){
      return sqlite3CorruptError(64893);
    }
    ((void)0);
    ;
    ;
    ((pAddr)[0] = (u8)((cbrk)>>8), (pAddr)[1] = (u8)(cbrk));
    if( temp==0 ){
      int x;
      if( cbrk==pc ) continue;
      temp = sqlite3PagerTempSpace(pPage->pBt->pPager);
      x = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]);
      memcpy(&temp[x], &data[x], (cbrk+size) - x);
      src = temp;
    }
    memcpy(&data[cbrk], &src[pc], size);
  }
  data[hdr+7] = 0;

 defragment_out:
  ((void)0);
  if( data[hdr+7]+cbrk-iCellFirst!=pPage->nFree ){
    return sqlite3CorruptError(64914);
  }
  ((void)0);
  ((&data[hdr+5])[0] = (u8)((cbrk)>>8), (&data[hdr+5])[1] = (u8)(cbrk));
  data[hdr+1] = 0;
  data[hdr+2] = 0;
  memset(&data[iCellFirst], 0, cbrk-iCellFirst);
  ((void)0);
  return 0;
}
# 64939 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u8 *pageFindSlot(MemPage *pPg, int nByte, int *pRc){
  const int hdr = pPg->hdrOffset;
  u8 * const aData = pPg->aData;
  int iAddr = hdr + 1;
  int pc = ((&aData[iAddr])[0]<<8 | (&aData[iAddr])[1]);
  int x;
  int maxPC = pPg->pBt->usableSize - nByte;
  int size;

  ((void)0);
  while( pc<=maxPC ){



    size = ((&aData[pc+2])[0]<<8 | (&aData[pc+2])[1]);
    if( (x = size - nByte)>=0 ){
      ;
      ;
      if( x<4 ){


        if( aData[hdr+7]>57 ) return 0;



        memcpy(&aData[iAddr], &aData[pc], 2);
        aData[hdr+7] += (u8)x;
      }else if( x+pc > maxPC ){

        *pRc = sqlite3CorruptError(64968);
        return 0;
      }else{


        ((&aData[pc+2])[0] = (u8)((x)>>8), (&aData[pc+2])[1] = (u8)(x));
      }
      return &aData[pc + x];
    }
    iAddr = pc;
    pc = ((&aData[pc])[0]<<8 | (&aData[pc])[1]);
    if( pc<=iAddr+size ){
      if( pc ){

        *pRc = sqlite3CorruptError(64982);
      }
      return 0;
    }
  }
  if( pc>maxPC+nByte-4 ){

    *pRc = sqlite3CorruptError(64989);
  }
  return 0;
}
# 65007 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int allocateSpace(MemPage *pPage, int nByte, int *pIdx){
  const int hdr = pPage->hdrOffset;
  u8 * const data = pPage->aData;
  int top;
  int rc = 0;
  int gap;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  ((void)0);
  gap = pPage->cellOffset + 2*pPage->nCell;
  ((void)0);





  top = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]);
  ((void)0);
  if( gap>top ){
    if( top==0 && pPage->pBt->usableSize==65536 ){
      top = 65536;
    }else{
      return sqlite3CorruptError(65036);
    }
  }





  ;
  ;
  ;
  if( (data[hdr+2] || data[hdr+1]) && gap+2<=top ){
    u8 *pSpace = pageFindSlot(pPage, nByte, &rc);
    if( pSpace ){
      ((void)0);
      if( (*pIdx = (int)(pSpace-data))<=gap ){
        return sqlite3CorruptError(65052);
      }else{
        return 0;
      }
    }else if( rc ){
      return rc;
    }
  }




  ;
  if( gap+2+nByte>top ){
    ((void)0);
    ((void)0);
    rc = defragmentPage(pPage, ((4)<(pPage->nFree - (2+nByte))?(4):(pPage->nFree - (2+nByte))));
    if( rc ) return rc;
    top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
    ((void)0);
  }
# 65081 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  top -= nByte;
  ((&data[hdr+5])[0] = (u8)((top)>>8), (&data[hdr+5])[1] = (u8)(top));
  ((void)0);
  *pIdx = top;
  return 0;
}
# 65101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int freeSpace(MemPage *pPage, u16 iStart, u16 iSize){
  u16 iPtr;
  u16 iFreeBlk;
  u8 hdr;
  u8 nFrag = 0;
  u16 iOrigSize = iSize;
  u16 x;
  u32 iEnd = iStart + iSize;
  unsigned char *data = pPage->aData;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);




  hdr = pPage->hdrOffset;
  iPtr = hdr + 1;
  if( data[iPtr+1]==0 && data[iPtr]==0 ){
    iFreeBlk = 0;
  }else{
    while( (iFreeBlk = ((&data[iPtr])[0]<<8 | (&data[iPtr])[1]))<iStart ){
      if( iFreeBlk<iPtr+4 ){
        if( iFreeBlk==0 ) break;
        return sqlite3CorruptError(65130);
      }
      iPtr = iFreeBlk;
    }
    if( iFreeBlk>pPage->pBt->usableSize-4 ){
      return sqlite3CorruptError(65135);
    }
    ((void)0);







    if( iFreeBlk && iEnd+3>=iFreeBlk ){
      nFrag = iFreeBlk - iEnd;
      if( iEnd>iFreeBlk ) return sqlite3CorruptError(65147);
      iEnd = iFreeBlk + ((&data[iFreeBlk+2])[0]<<8 | (&data[iFreeBlk+2])[1]);
      if( iEnd > pPage->pBt->usableSize ){
        return sqlite3CorruptError(65150);
      }
      iSize = iEnd - iStart;
      iFreeBlk = ((&data[iFreeBlk])[0]<<8 | (&data[iFreeBlk])[1]);
    }





    if( iPtr>hdr+1 ){
      int iPtrEnd = iPtr + ((&data[iPtr+2])[0]<<8 | (&data[iPtr+2])[1]);
      if( iPtrEnd+3>=iStart ){
        if( iPtrEnd>iStart ) return sqlite3CorruptError(65163);
        nFrag += iStart - iPtrEnd;
        iSize = iEnd - iPtr;
        iStart = iPtr;
      }
    }
    if( nFrag>data[hdr+7] ) return sqlite3CorruptError(65169);
    data[hdr+7] -= nFrag;
  }
  x = ((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]);
  if( iStart<=x ){



    if( iStart<x || iPtr!=hdr+1 ) return sqlite3CorruptError(65177);
    ((&data[hdr+1])[0] = (u8)((iFreeBlk)>>8), (&data[hdr+1])[1] = (u8)(iFreeBlk));
    ((&data[hdr+5])[0] = (u8)((iEnd)>>8), (&data[hdr+5])[1] = (u8)(iEnd));
  }else{

    ((&data[iPtr])[0] = (u8)((iStart)>>8), (&data[iPtr])[1] = (u8)(iStart));
  }
  if( pPage->pBt->btsFlags & 0x000c ){


    memset(&data[iStart], 0, iSize);
  }
  ((&data[iStart])[0] = (u8)((iFreeBlk)>>8), (&data[iStart])[1] = (u8)(iFreeBlk));
  ((&data[iStart+2])[0] = (u8)((iSize)>>8), (&data[iStart+2])[1] = (u8)(iSize));
  pPage->nFree += iOrigSize;
  return 0;
}
# 65207 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int decodeFlags(MemPage *pPage, int flagByte){
  BtShared *pBt;

  ((void)0);
  ((void)0);
  pPage->leaf = (u8)(flagByte>>3); ((void)0);
  flagByte &= ~0x08;
  pPage->childPtrSize = 4-4*pPage->leaf;
  pPage->xCellSize = cellSizePtr;
  pBt = pPage->pBt;
  if( flagByte==(0x04 | 0x01) ){


    ((void)0);


    ((void)0);
    pPage->intKey = 1;
    if( pPage->leaf ){
      pPage->intKeyLeaf = 1;
      pPage->xParseCell = btreeParseCellPtr;
    }else{
      pPage->intKeyLeaf = 0;
      pPage->xCellSize = cellSizePtrNoPayload;
      pPage->xParseCell = btreeParseCellPtrNoPayload;
    }
    pPage->maxLocal = pBt->maxLeaf;
    pPage->minLocal = pBt->minLeaf;
  }else if( flagByte==0x02 ){


    ((void)0);


    ((void)0);
    pPage->intKey = 0;
    pPage->intKeyLeaf = 0;
    pPage->xParseCell = btreeParseCellPtrIndex;
    pPage->maxLocal = pBt->maxLocal;
    pPage->minLocal = pBt->minLocal;
  }else{


    return sqlite3CorruptError(65250);
  }
  pPage->max1bytePayload = pBt->max1bytePayload;
  return 0;
}





static int btreeComputeFreeSpace(MemPage *pPage){
  int pc;
  u8 hdr;
  u8 *data;
  int usableSize;
  int nFree;
  int top;
  int iCellFirst;
  int iCellLast;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  usableSize = pPage->pBt->usableSize;
  hdr = pPage->hdrOffset;
  data = pPage->aData;



  top = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
  iCellFirst = hdr + 8 + pPage->childPtrSize + 2*pPage->nCell;
  iCellLast = usableSize - 4;





  pc = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
  nFree = data[hdr+7] + top;
  if( pc>0 ){
    u32 next, size;
    if( pc<iCellFirst ){



      return sqlite3CorruptError(65301);
    }
    while( 1 ){
      if( pc>iCellLast ){

        return sqlite3CorruptError(65306);
      }
      next = ((&data[pc])[0]<<8 | (&data[pc])[1]);
      size = ((&data[pc+2])[0]<<8 | (&data[pc+2])[1]);
      nFree = nFree + size;
      if( next<=pc+size+3 ) break;
      pc = next;
    }
    if( next>0 ){

      return sqlite3CorruptError(65316);
    }
    if( pc+size>(unsigned int)usableSize ){

      return sqlite3CorruptError(65320);
    }
  }
# 65331 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( nFree>usableSize || nFree<iCellFirst ){
    return sqlite3CorruptError(65332);
  }
  pPage->nFree = (u16)(nFree - iCellFirst);
  return 0;
}





static __attribute__((noinline)) int btreeCellSizeCheck(MemPage *pPage){
  int iCellFirst;
  int iCellLast;
  int i;
  int sz;
  int pc;
  u8 *data;
  int usableSize;
  int cellOffset;

  iCellFirst = pPage->cellOffset + 2*pPage->nCell;
  usableSize = pPage->pBt->usableSize;
  iCellLast = usableSize - 4;
  data = pPage->aData;
  cellOffset = pPage->cellOffset;
  if( !pPage->leaf ) iCellLast--;
  for(i=0; i<pPage->nCell; i++){
    pc = __builtin_bswap16(*(u16*)(&data[cellOffset+i*2]));
    ;
    ;
    if( pc<iCellFirst || pc>iCellLast ){
      return sqlite3CorruptError(65363);
    }
    sz = pPage->xCellSize(pPage, &data[pc]);
    ;
    if( pc+sz>usableSize ){
      return sqlite3CorruptError(65368);
    }
  }
  return 0;
}
# 65383 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeInitPage(MemPage *pPage){
  u8 *data;
  BtShared *pBt;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  pBt = pPage->pBt;
  data = pPage->aData + pPage->hdrOffset;


  if( decodeFlags(pPage, data[0]) ){
    return sqlite3CorruptError(65400);
  }
  ((void)0);
  pPage->maskPage = (u16)(pBt->pageSize - 1);
  pPage->nOverflow = 0;
  pPage->cellOffset = pPage->hdrOffset + 8 + pPage->childPtrSize;
  pPage->aCellIdx = data + pPage->childPtrSize + 8;
  pPage->aDataEnd = pPage->aData + pBt->usableSize;
  pPage->aDataOfst = pPage->aData + pPage->childPtrSize;


  pPage->nCell = ((&data[3])[0]<<8 | (&data[3])[1]);
  if( pPage->nCell>((pBt->pageSize-8)/6) ){

    return sqlite3CorruptError(65414);
  }
  ;




  ((void)0)

                      ;
  pPage->nFree = -1;
  pPage->isInit = 1;
  if( pBt->db->flags & 0x00200000 ){
    return btreeCellSizeCheck(pPage);
  }
  return 0;
}





static void zeroPage(MemPage *pPage, int flags){
  unsigned char *data = pPage->aData;
  BtShared *pBt = pPage->pBt;
  u8 hdr = pPage->hdrOffset;
  u16 first;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( pBt->btsFlags & 0x000c ){
    memset(&data[hdr], 0, pBt->usableSize - hdr);
  }
  data[hdr] = (char)flags;
  first = hdr + ((flags&0x08)==0 ? 12 : 8);
  memset(&data[hdr+1], 0, 4);
  data[hdr+7] = 0;
  ((&data[hdr+5])[0] = (u8)((pBt->usableSize)>>8), (&data[hdr+5])[1] = (u8)(pBt->usableSize));
  pPage->nFree = (u16)(pBt->usableSize - first);
  decodeFlags(pPage, flags);
  pPage->cellOffset = first;
  pPage->aDataEnd = &data[pBt->usableSize];
  pPage->aCellIdx = &data[first];
  pPage->aDataOfst = &data[pPage->childPtrSize];
  pPage->nOverflow = 0;
  ((void)0);
  pPage->maskPage = (u16)(pBt->pageSize - 1);
  pPage->nCell = 0;
  pPage->isInit = 1;
}






static MemPage *btreePageFromDbPage(DbPage *pDbPage, Pgno pgno, BtShared *pBt){
  MemPage *pPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
  if( pgno!=pPage->pgno ){
    pPage->aData = sqlite3PagerGetData(pDbPage);
    pPage->pDbPage = pDbPage;
    pPage->pBt = pBt;
    pPage->pgno = pgno;
    pPage->hdrOffset = pgno==1 ? 100 : 0;
  }
  ((void)0);
  return pPage;
}
# 65497 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeGetPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage,
  int flags
){
  int rc;
  DbPage *pDbPage;

  ((void)0);
  ((void)0);
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, flags);
  if( rc ) return rc;
  *ppPage = btreePageFromDbPage(pDbPage, pgno, pBt);
  return 0;
}






static MemPage *btreePageLookup(BtShared *pBt, Pgno pgno){
  DbPage *pDbPage;
  ((void)0);
  pDbPage = sqlite3PagerLookup(pBt->pPager, pgno);
  if( pDbPage ){
    return btreePageFromDbPage(pDbPage, pgno, pBt);
  }
  return 0;
}





static Pgno btreePagecount(BtShared *pBt){
  return pBt->nPage;
}
static u32 sqlite3BtreeLastPage(Btree *p){
  ((void)0);
  ((void)0);
  return btreePagecount(p->pBt);
}
# 65555 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getAndInitPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage,
  BtCursor *pCur,
  int bReadOnly
){
  int rc;
  DbPage *pDbPage;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( pgno>btreePagecount(pBt) ){
    rc = sqlite3CorruptError(65570);
    goto getAndInitPage_error1;
  }
  rc = sqlite3PagerGet(pBt->pPager, pgno, (DbPage**)&pDbPage, bReadOnly);
  if( rc ){
    goto getAndInitPage_error1;
  }
  *ppPage = (MemPage*)sqlite3PagerGetExtra(pDbPage);
  if( (*ppPage)->isInit==0 ){
    btreePageFromDbPage(pDbPage, pgno, pBt);
    rc = btreeInitPage(*ppPage);
    if( rc!=0 ){
      goto getAndInitPage_error2;
    }
  }
  ((void)0);
  ((void)0);



  if( pCur && ((*ppPage)->nCell<1 || (*ppPage)->intKey!=pCur->curIntKey) ){
    rc = sqlite3CorruptError(65591);
    goto getAndInitPage_error2;
  }
  return 0;

getAndInitPage_error2:
  releasePage(*ppPage);
getAndInitPage_error1:
  if( pCur ){
    pCur->iPage--;
    pCur->pPage = pCur->apPage[pCur->iPage];
  }
  ;
  ((void)0);
  return rc;
}







static void releasePageNotNull(MemPage *pPage){
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  sqlite3PagerUnrefNotNull(pPage->pDbPage);
}
static void releasePage(MemPage *pPage){
  if( pPage ) releasePageNotNull(pPage);
}
static void releasePageOne(MemPage *pPage){
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  sqlite3PagerUnrefPageOne(pPage->pDbPage);
}
# 65646 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeGetUnusedPage(
  BtShared *pBt,
  Pgno pgno,
  MemPage **ppPage,
  int flags
){
  int rc = btreeGetPage(pBt, pgno, ppPage, flags);
  if( rc==0 ){
    if( sqlite3PagerPageRefcount((*ppPage)->pDbPage)>1 ){
      releasePage(*ppPage);
      *ppPage = 0;
      return sqlite3CorruptError(65657);
    }
    (*ppPage)->isInit = 0;
  }else{
    *ppPage = 0;
  }
  return rc;
}
# 65675 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void pageReinit(DbPage *pData){
  MemPage *pPage;
  pPage = (MemPage *)sqlite3PagerGetExtra(pData);
  ((void)0);
  if( pPage->isInit ){
    ((void)0);
    pPage->isInit = 0;
    if( sqlite3PagerPageRefcount(pData)>1 ){






      btreeInitPage(pPage);
    }
  }
}




static int btreeInvokeBusyHandler(void *pArg){
  BtShared *pBt = (BtShared*)pArg;
  ((void)0);
  ((void)0);
  return sqlite3InvokeBusyHandler(&pBt->db->busyHandler,
                                  sqlite3PagerFile(pBt->pPager));
}
# 65726 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeOpen(
  sqlite3_vfs *pVfs,
  const char *zFilename,
  sqlite3 *db,
  Btree **ppBtree,
  int flags,
  int vfsFlags
){
  BtShared *pBt = 0;
  Btree *p;
  sqlite3_mutex *mutexOpen = 0;
  int rc = 0;
  u8 nReserve;
  unsigned char zDbHeader[100];


  const int isTempDb = zFilename==0 || zFilename[0]==0;







  const int isMemdb = (zFilename && strcmp(zFilename, ":memory:")==0)
                       || (isTempDb && sqlite3TempInMemory(db))
                       || (vfsFlags & 0x00000080)!=0;


  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  ((void)0);


  ((void)0);

  if( isMemdb ){
    flags |= 2;
  }
  if( (vfsFlags & 0x00000100)!=0 && (isMemdb || isTempDb) ){
    vfsFlags = (vfsFlags & ~0x00000100) | 0x00000200;
  }
  p = sqlite3MallocZero(sizeof(Btree));
  if( !p ){
    return 7;
  }
  p->inTrans = 0;
  p->db = db;

  p->lock.pBtree = p;
  p->lock.iTable = 1;







  if( isTempDb==0 && (isMemdb==0 || (vfsFlags&0x00000040)!=0) ){
    if( vfsFlags & 0x00020000 ){
      int nFilename = sqlite3Strlen30(zFilename)+1;
      int nFullPathname = pVfs->mxPathname+1;
      char *zFullPathname = sqlite3Malloc(((nFullPathname)>(nFilename)?(nFullPathname):(nFilename)));
      sqlite3_mutex *mutexShared;

      p->sharable = 1;
      if( !zFullPathname ){
        sqlite3_free(p);
        return 7;
      }
      if( isMemdb ){
        memcpy(zFullPathname, zFilename, nFilename);
      }else{
        rc = sqlite3OsFullPathname(pVfs, zFilename,
                                   nFullPathname, zFullPathname);
        if( rc ){
          sqlite3_free(zFullPathname);
          sqlite3_free(p);
          return rc;
        }
      }

      mutexOpen = sqlite3MutexAlloc(4);
      sqlite3_mutex_enter(mutexOpen);
      mutexShared = sqlite3MutexAlloc(2);
      sqlite3_mutex_enter(mutexShared);

      for(pBt=sqlite3SharedCacheList; pBt; pBt=pBt->pNext){
        ((void)0);
        if( 0==strcmp(zFullPathname, sqlite3PagerFilename(pBt->pPager, 0))
                 && sqlite3PagerVfs(pBt->pPager)==pVfs ){
          int iDb;
          for(iDb=db->nDb-1; iDb>=0; iDb--){
            Btree *pExisting = db->aDb[iDb].pBt;
            if( pExisting && pExisting->pBt==pBt ){
              sqlite3_mutex_leave(mutexShared);
              sqlite3_mutex_leave(mutexOpen);
              sqlite3_free(zFullPathname);
              sqlite3_free(p);
              return 19;
            }
          }
          p->pBt = pBt;
          pBt->nRef++;
          break;
        }
      }
      sqlite3_mutex_leave(mutexShared);
      sqlite3_free(zFullPathname);
    }
# 65850 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }

  if( pBt==0 ){





    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);

    pBt = sqlite3MallocZero( sizeof(*pBt) );
    if( pBt==0 ){
      rc = 7;
      goto btree_open_out;
    }
    rc = sqlite3PagerOpen(pVfs, &pBt->pPager, zFilename,
                          sizeof(MemPage), flags, vfsFlags, pageReinit);
    if( rc==0 ){
      sqlite3PagerSetMmapLimit(pBt->pPager, db->szMmap);
      rc = sqlite3PagerReadFileheader(pBt->pPager,sizeof(zDbHeader),zDbHeader);
    }
    if( rc!=0 ){
      goto btree_open_out;
    }
    pBt->openFlags = (u8)flags;
    pBt->db = db;
    sqlite3PagerSetBusyHandler(pBt->pPager, btreeInvokeBusyHandler, pBt);
    p->pBt = pBt;

    pBt->pCursor = 0;
    pBt->pPage1 = 0;
    if( sqlite3PagerIsreadonly(pBt->pPager) ) pBt->btsFlags |= 0x0001;
# 65894 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pBt->pageSize = (zDbHeader[16]<<8) | (zDbHeader[17]<<16);
    if( pBt->pageSize<512 || pBt->pageSize>65536
         || ((pBt->pageSize-1)&pBt->pageSize)!=0 ){
      pBt->pageSize = 0;







      if( zFilename && !isMemdb ){
        pBt->autoVacuum = (0 ? 1 : 0);
        pBt->incrVacuum = (0==2 ? 1 : 0);
      }

      nReserve = 0;
    }else{



      nReserve = zDbHeader[20];
      pBt->btsFlags |= 0x0002;

      pBt->autoVacuum = (sqlite3Get4byte(&zDbHeader[36 + 4*4])?1:0);
      pBt->incrVacuum = (sqlite3Get4byte(&zDbHeader[36 + 7*4])?1:0);

    }
    rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
    if( rc ) goto btree_open_out;
    pBt->usableSize = pBt->pageSize - nReserve;
    ((void)0);




    pBt->nRef = 1;
    if( p->sharable ){
      sqlite3_mutex *mutexShared;
      mutexShared = sqlite3MutexAlloc(2);
      if( 1 && sqlite3Config.bCoreMutex ){
        pBt->mutex = sqlite3MutexAlloc(0);
        if( pBt->mutex==0 ){
          rc = 7;
          goto btree_open_out;
        }
      }
      sqlite3_mutex_enter(mutexShared);
      pBt->pNext = sqlite3SharedCacheList;
      sqlite3SharedCacheList = pBt;
      sqlite3_mutex_leave(mutexShared);
    }

  }






  if( p->sharable ){
    int i;
    Btree *pSib;
    for(i=0; i<db->nDb; i++){
      if( (pSib = db->aDb[i].pBt)!=0 && pSib->sharable ){
        while( pSib->pPrev ){ pSib = pSib->pPrev; }
        if( (uptr)p->pBt<(uptr)pSib->pBt ){
          p->pNext = pSib;
          p->pPrev = 0;
          pSib->pPrev = p;
        }else{
          while( pSib->pNext && (uptr)pSib->pNext->pBt<(uptr)p->pBt ){
            pSib = pSib->pNext;
          }
          p->pNext = pSib->pNext;
          p->pPrev = pSib;
          if( p->pNext ){
            p->pNext->pPrev = p;
          }
          pSib->pNext = p;
        }
        break;
      }
    }
  }

  *ppBtree = p;

btree_open_out:
  if( rc!=0 ){
    if( pBt && pBt->pPager ){
      sqlite3PagerClose(pBt->pPager, 0);
    }
    sqlite3_free(pBt);
    sqlite3_free(p);
    *ppBtree = 0;
  }else{
    sqlite3_file *pFile;





    if( sqlite3BtreeSchema(p, 0, 0)==0 ){
      sqlite3PagerSetCachesize(p->pBt->pPager, -2000);
    }

    pFile = sqlite3PagerFile(pBt->pPager);
    if( pFile->pMethods ){
      sqlite3OsFileControlHint(pFile, 30, (void*)&pBt->db);
    }
  }
  if( mutexOpen ){
    ((void)0);
    sqlite3_mutex_leave(mutexOpen);
  }
  ((void)0);
  return rc;
}







static int removeFromSharingList(BtShared *pBt){

  sqlite3_mutex *pMaster;
  BtShared *pList;
  int removed = 0;

  ((void)0);
  pMaster = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(pMaster);
  pBt->nRef--;
  if( pBt->nRef<=0 ){
    if( sqlite3SharedCacheList==pBt ){
      sqlite3SharedCacheList = pBt->pNext;
    }else{
      pList = sqlite3SharedCacheList;
      while( (pList) && pList->pNext!=pBt ){
        pList=pList->pNext;
      }
      if( (pList) ){
        pList->pNext = pBt->pNext;
      }
    }
    if( 1 ){
      sqlite3_mutex_free(pBt->mutex);
    }
    removed = 1;
  }
  sqlite3_mutex_leave(pMaster);
  return removed;



}






static void allocateTempSpace(BtShared *pBt){
  if( !pBt->pTmpSpace ){
    pBt->pTmpSpace = sqlite3PageMalloc( pBt->pageSize );
# 66078 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pBt->pTmpSpace ){
      memset(pBt->pTmpSpace, 0, 8);
      pBt->pTmpSpace += 4;
    }
  }
}




static void freeTempSpace(BtShared *pBt){
  if( pBt->pTmpSpace ){
    pBt->pTmpSpace -= 4;
    sqlite3PageFree(pBt->pTmpSpace);
    pBt->pTmpSpace = 0;
  }
}




static int sqlite3BtreeClose(Btree *p){
  BtShared *pBt = p->pBt;
  BtCursor *pCur;


  ((void)0);
  sqlite3BtreeEnter(p);
  pCur = pBt->pCursor;
  while( pCur ){
    BtCursor *pTmp = pCur;
    pCur = pCur->pNext;
    if( pTmp->pBtree==p ){
      sqlite3BtreeCloseCursor(pTmp);
    }
  }





  sqlite3BtreeRollback(p, 0, 0);
  sqlite3BtreeLeave(p);





  ((void)0);
  if( !p->sharable || removeFromSharingList(pBt) ){





    ((void)0);
    sqlite3PagerClose(pBt->pPager, p->db);
    if( pBt->xFreeSchema && pBt->pSchema ){
      pBt->xFreeSchema(pBt->pSchema);
    }
    sqlite3DbFree(0, pBt->pSchema);
    freeTempSpace(pBt);
    sqlite3_free(pBt);
  }


  ((void)0);
  ((void)0);
  if( p->pPrev ) p->pPrev->pNext = p->pNext;
  if( p->pNext ) p->pNext->pPrev = p->pPrev;


  sqlite3_free(p);
  return 0;
}
# 66161 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeSetCacheSize(Btree *p, int mxPage){
  BtShared *pBt = p->pBt;
  ((void)0);
  sqlite3BtreeEnter(p);
  sqlite3PagerSetCachesize(pBt->pPager, mxPage);
  sqlite3BtreeLeave(p);
  return 0;
}
# 66180 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeSetSpillSize(Btree *p, int mxPage){
  BtShared *pBt = p->pBt;
  int res;
  ((void)0);
  sqlite3BtreeEnter(p);
  res = sqlite3PagerSetSpillsize(pBt->pPager, mxPage);
  sqlite3BtreeLeave(p);
  return res;
}






static int sqlite3BtreeSetMmapLimit(Btree *p, sqlite3_int64 szMmap){
  BtShared *pBt = p->pBt;
  ((void)0);
  sqlite3BtreeEnter(p);
  sqlite3PagerSetMmapLimit(pBt->pPager, szMmap);
  sqlite3BtreeLeave(p);
  return 0;
}
# 66214 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeSetPagerFlags(
  Btree *p,
  unsigned pgFlags
){
  BtShared *pBt = p->pBt;
  ((void)0);
  sqlite3BtreeEnter(p);
  sqlite3PagerSetFlags(pBt->pPager, pgFlags);
  sqlite3BtreeLeave(p);
  return 0;
}
# 66247 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeSetPageSize(Btree *p, int pageSize, int nReserve, int iFix){
  int rc = 0;
  BtShared *pBt = p->pBt;
  ((void)0);
  sqlite3BtreeEnter(p);



  if( pBt->btsFlags & 0x0002 ){
    sqlite3BtreeLeave(p);
    return 8;
  }
  if( nReserve<0 ){
    nReserve = pBt->pageSize - pBt->usableSize;
  }
  ((void)0);
  if( pageSize>=512 && pageSize<=65536 &&
        ((pageSize-1)&pageSize)==0 ){
    ((void)0);
    ((void)0);
    pBt->pageSize = (u32)pageSize;
    freeTempSpace(pBt);
  }
  rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize, nReserve);
  pBt->usableSize = pBt->pageSize - (u16)nReserve;
  if( iFix ) pBt->btsFlags |= 0x0002;
  sqlite3BtreeLeave(p);
  return rc;
}




static int sqlite3BtreeGetPageSize(Btree *p){
  return p->pBt->pageSize;
}
# 66295 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeGetReserveNoMutex(Btree *p){
  int n;
  ((void)0);
  n = p->pBt->pageSize - p->pBt->usableSize;
  return n;
}
# 66311 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeGetOptimalReserve(Btree *p){
  int n;
  sqlite3BtreeEnter(p);
  n = sqlite3BtreeGetReserveNoMutex(p);



  sqlite3BtreeLeave(p);
  return n;
}







static int sqlite3BtreeMaxPageCount(Btree *p, int mxPage){
  int n;
  sqlite3BtreeEnter(p);
  n = sqlite3PagerMaxPageCount(p->pBt->pPager, mxPage);
  sqlite3BtreeLeave(p);
  return n;
}
# 66354 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeSecureDelete(Btree *p, int newFlag){
  int b;
  if( p==0 ) return 0;
  sqlite3BtreeEnter(p);
  ((void)0);
  ((void)0);
  if( newFlag>=0 ){
    p->pBt->btsFlags &= ~0x000c;
    p->pBt->btsFlags |= 0x0004*newFlag;
  }
  b = (p->pBt->btsFlags & 0x000c)/0x0004;
  sqlite3BtreeLeave(p);
  return b;
}







static int sqlite3BtreeSetAutoVacuum(Btree *p, int autoVacuum){



  BtShared *pBt = p->pBt;
  int rc = 0;
  u8 av = (u8)autoVacuum;

  sqlite3BtreeEnter(p);
  if( (pBt->btsFlags & 0x0002)!=0 && (av ?1:0)!=pBt->autoVacuum ){
    rc = 8;
  }else{
    pBt->autoVacuum = av ?1:0;
    pBt->incrVacuum = av==2 ?1:0;
  }
  sqlite3BtreeLeave(p);
  return rc;

}





static int sqlite3BtreeGetAutoVacuum(Btree *p){



  int rc;
  sqlite3BtreeEnter(p);
  rc = (
    (!p->pBt->autoVacuum)?0:
    (!p->pBt->incrVacuum)?1:
    2
  );
  sqlite3BtreeLeave(p);
  return rc;

}
# 66439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define setDefaultSyncFlag(pBt,safety_level) 



static int newDatabase(BtShared*);
# 66455 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int lockBtree(BtShared *pBt){
  int rc;
  MemPage *pPage1;
  u32 nPage;
  u32 nPageFile = 0;
  u32 nPageHeader;

  ((void)0);
  ((void)0);
  rc = sqlite3PagerSharedLock(pBt->pPager);
  if( rc!=0 ) return rc;
  rc = btreeGetPage(pBt, 1, &pPage1, 0);
  if( rc!=0 ) return rc;




  nPage = nPageHeader = sqlite3Get4byte(28+(u8*)pPage1->aData);
  sqlite3PagerPagecount(pBt->pPager, (int*)&nPageFile);
  if( nPage==0 || memcmp(24+(u8*)pPage1->aData, 92+(u8*)pPage1->aData,4)!=0 ){
    nPage = nPageFile;
  }
  if( (pBt->db->flags & 0x02000000)!=0 ){
    nPage = 0;
  }
  if( nPage>0 ){
    u32 pageSize;
    u32 usableSize;
    u8 *page1 = pPage1->aData;
    rc = 26;



    if( memcmp(page1, zMagicHeader, 16)!=0 ){
      goto page1_init_failed;
    }
# 66500 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( page1[18]>2 ){
      pBt->btsFlags |= 0x0001;
    }
    if( page1[19]>2 ){
      goto page1_init_failed;
    }
# 66515 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( page1[19]==2 && (pBt->btsFlags & 0x0020)==0 ){
      int isOpen = 0;
      rc = sqlite3PagerOpenWal(pBt->pPager, &isOpen);
      if( rc!=0 ){
        goto page1_init_failed;
      }else{
        ;
        if( isOpen==0 ){
          releasePageOne(pPage1);
          return 0;
        }
      }
      rc = 26;
    }else{
      ;
    }
# 66539 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( memcmp(&page1[21], "\100\040\040",3)!=0 ){
      goto page1_init_failed;
    }



    pageSize = (page1[16]<<8) | (page1[17]<<16);


    if( ((pageSize-1)&pageSize)!=0
     || pageSize>65536
     || pageSize<=256
    ){
      goto page1_init_failed;
    }
    pBt->btsFlags |= 0x0002;
    ((void)0);







    usableSize = pageSize - page1[20];
    if( (u32)pageSize!=pBt->pageSize ){






      releasePageOne(pPage1);
      pBt->usableSize = usableSize;
      pBt->pageSize = pageSize;
      freeTempSpace(pBt);
      rc = sqlite3PagerSetPagesize(pBt->pPager, &pBt->pageSize,
                                   pageSize-usableSize);
      return rc;
    }
    if( sqlite3WritableSchema(pBt->db)==0 && nPage>nPageFile ){
      rc = sqlite3CorruptError(66580);
      goto page1_init_failed;
    }



    if( usableSize<480 ){
      goto page1_init_failed;
    }
    pBt->pageSize = pageSize;
    pBt->usableSize = usableSize;

    pBt->autoVacuum = (sqlite3Get4byte(&page1[36 + 4*4])?1:0);
    pBt->incrVacuum = (sqlite3Get4byte(&page1[36 + 7*4])?1:0);

  }
# 66610 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pBt->maxLocal = (u16)((pBt->usableSize-12)*64/255 - 23);
  pBt->minLocal = (u16)((pBt->usableSize-12)*32/255 - 23);
  pBt->maxLeaf = (u16)(pBt->usableSize - 35);
  pBt->minLeaf = (u16)((pBt->usableSize-12)*32/255 - 23);
  if( pBt->maxLocal>127 ){
    pBt->max1bytePayload = 127;
  }else{
    pBt->max1bytePayload = (u8)pBt->maxLocal;
  }
  ((void)0);
  pBt->pPage1 = pPage1;
  pBt->nPage = nPage;
  return 0;

page1_init_failed:
  releasePageOne(pPage1);
  pBt->pPage1 = 0;
  return rc;
}
# 66662 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void unlockBtreeIfUnused(BtShared *pBt){
  ((void)0);
  ((void)0);
  if( pBt->inTransaction==0 && pBt->pPage1!=0 ){
    MemPage *pPage1 = pBt->pPage1;
    ((void)0);
    ((void)0);
    pBt->pPage1 = 0;
    releasePageOne(pPage1);
  }
}






static int newDatabase(BtShared *pBt){
  MemPage *pP1;
  unsigned char *data;
  int rc;

  ((void)0);
  if( pBt->nPage>0 ){
    return 0;
  }
  pP1 = pBt->pPage1;
  ((void)0);
  data = pP1->aData;
  rc = sqlite3PagerWrite(pP1->pDbPage);
  if( rc ) return rc;
  memcpy(data, zMagicHeader, sizeof(zMagicHeader));
  ((void)0);
  data[16] = (u8)((pBt->pageSize>>8)&0xff);
  data[17] = (u8)((pBt->pageSize>>16)&0xff);
  data[18] = 1;
  data[19] = 1;
  ((void)0);
  data[20] = (u8)(pBt->pageSize - pBt->usableSize);
  data[21] = 64;
  data[22] = 32;
  data[23] = 32;
  memset(&data[24], 0, 100-24);
  zeroPage(pP1, 0x01|0x08|0x04 );
  pBt->btsFlags |= 0x0002;

  ((void)0);
  ((void)0);
  sqlite3Put4byte(&data[36 + 4*4], pBt->autoVacuum);
  sqlite3Put4byte(&data[36 + 7*4], pBt->incrVacuum);

  pBt->nPage = 1;
  data[31] = 1;
  return 0;
}






static int sqlite3BtreeNewDb(Btree *p){
  int rc;
  sqlite3BtreeEnter(p);
  p->pBt->nPage = 0;
  rc = newDatabase(p->pBt);
  sqlite3BtreeLeave(p);
  return rc;
}
# 66767 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeBeginTrans(Btree *p, int wrflag, int *pSchemaVersion){
  BtShared *pBt = p->pBt;
  int rc = 0;

  sqlite3BtreeEnter(p);
  ((void)0); ((void)0);;





  if( p->inTrans==2 || (p->inTrans==1 && !wrflag) ){
    goto trans_begun;
  }
  ((void)0);

  if( (p->db->flags & 0x02000000)
   && sqlite3PagerIsreadonly(pBt->pPager)==0
  ){
    pBt->btsFlags &= ~0x0001;
  }


  if( (pBt->btsFlags & 0x0001)!=0 && wrflag ){
    rc = 8;
    goto trans_begun;
  }


  {
    sqlite3 *pBlock = 0;




    if( (wrflag && pBt->inTransaction==2)
     || (pBt->btsFlags & 0x0080)!=0
    ){
      pBlock = pBt->pWriter->db;
    }else if( wrflag>1 ){
      BtLock *pIter;
      for(pIter=pBt->pLock; pIter; pIter=pIter->pNext){
        if( pIter->pBtree!=p ){
          pBlock = pIter->pBtree->db;
          break;
        }
      }
    }
    if( pBlock ){
      ;
      rc = (6 | (1<<8));
      goto trans_begun;
    }
  }





  rc = querySharedCacheTableLock(p, 1, 1);
  if( 0!=rc ) goto trans_begun;

  pBt->btsFlags &= ~0x0010;
  if( pBt->nPage==0 ) pBt->btsFlags |= 0x0010;
  do {







    while( pBt->pPage1==0 && 0==(rc = lockBtree(pBt)) );

    if( rc==0 && wrflag ){
      if( (pBt->btsFlags & 0x0001)!=0 ){
        rc = 8;
      }else{
        rc = sqlite3PagerBegin(pBt->pPager,wrflag>1,sqlite3TempInMemory(p->db));
        if( rc==0 ){
          rc = newDatabase(pBt);
        }else if( rc==(5 | (2<<8)) && pBt->inTransaction==0 ){



          rc = 5;
        }
      }
    }

    if( rc!=0 ){
      unlockBtreeIfUnused(pBt);
    }
  }while( (rc&0xFF)==5 && pBt->inTransaction==0 &&
          btreeInvokeBusyHandler(pBt) );
  ;

  if( rc==0 ){
    if( p->inTrans==0 ){
      pBt->nTransaction++;

      if( p->sharable ){
        ((void)0);
        p->lock.eLock = 1;
        p->lock.pNext = pBt->pLock;
        pBt->pLock = &p->lock;
      }

    }
    p->inTrans = (wrflag?2:1);
    if( p->inTrans>pBt->inTransaction ){
      pBt->inTransaction = p->inTrans;
    }
    if( wrflag ){
      MemPage *pPage1 = pBt->pPage1;

      ((void)0);
      pBt->pWriter = p;
      pBt->btsFlags &= ~0x0040;
      if( wrflag>1 ) pBt->btsFlags |= 0x0040;
# 66895 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( pBt->nPage!=sqlite3Get4byte(&pPage1->aData[28]) ){
        rc = sqlite3PagerWrite(pPage1->pDbPage);
        if( rc==0 ){
          sqlite3Put4byte(&pPage1->aData[28], pBt->nPage);
        }
      }
    }
  }

trans_begun:
  if( rc==0 ){
    if( pSchemaVersion ){
      *pSchemaVersion = sqlite3Get4byte(&pBt->pPage1->aData[40]);
    }
    if( wrflag ){




      rc = sqlite3PagerOpenSavepoint(pBt->pPager, p->db->nSavepoint);
    }
  }

  ((void)0); ((void)0);;
  sqlite3BtreeLeave(p);
  return rc;
}
# 66930 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int setChildPtrmaps(MemPage *pPage){
  int i;
  int nCell;
  int rc;
  BtShared *pBt = pPage->pBt;
  Pgno pgno = pPage->pgno;

  ((void)0);
  rc = pPage->isInit ? 0 : btreeInitPage(pPage);
  if( rc!=0 ) return rc;
  nCell = pPage->nCell;

  for(i=0; i<nCell; i++){
    u8 *pCell = ((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(i)]))));

    ptrmapPutOvflPtr(pPage, pPage, pCell, &rc);

    if( !pPage->leaf ){
      Pgno childPgno = sqlite3Get4byte(pCell);
      ptrmapPut(pBt, childPgno, 5, pgno, &rc);
    }
  }

  if( !pPage->leaf ){
    Pgno childPgno = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    ptrmapPut(pBt, childPgno, 5, pgno, &rc);
  }

  return rc;
}
# 66975 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int modifyPagePointer(MemPage *pPage, Pgno iFrom, Pgno iTo, u8 eType){
  ((void)0);
  ((void)0);
  if( eType==4 ){

    if( sqlite3Get4byte(pPage->aData)!=iFrom ){
      return sqlite3CorruptError(66981);
    }
    sqlite3Put4byte(pPage->aData, iTo);
  }else{
    int i;
    int nCell;
    int rc;

    rc = pPage->isInit ? 0 : btreeInitPage(pPage);
    if( rc ) return rc;
    nCell = pPage->nCell;

    for(i=0; i<nCell; i++){
      u8 *pCell = ((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(i)]))));
      if( eType==3 ){
        CellInfo info;
        pPage->xParseCell(pPage, pCell, &info);
        if( info.nLocal<info.nPayload ){
          if( pCell+info.nSize > pPage->aData+pPage->pBt->usableSize ){
            return sqlite3CorruptError(67000);
          }
          if( iFrom==sqlite3Get4byte(pCell+info.nSize-4) ){
            sqlite3Put4byte(pCell+info.nSize-4, iTo);
            break;
          }
        }
      }else{
        if( sqlite3Get4byte(pCell)==iFrom ){
          sqlite3Put4byte(pCell, iTo);
          break;
        }
      }
    }

    if( i==nCell ){
      if( eType!=5 ||
          sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8])!=iFrom ){
        return sqlite3CorruptError(67018);
      }
      sqlite3Put4byte(&pPage->aData[pPage->hdrOffset+8], iTo);
    }
  }
  return 0;
}
# 67036 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int relocatePage(
  BtShared *pBt,
  MemPage *pDbPage,
  u8 eType,
  Pgno iPtrPage,
  Pgno iFreePage,
  int isCommit
){
  MemPage *pPtrPage;
  Pgno iDbPage = pDbPage->pgno;
  Pager *pPager = pBt->pPager;
  int rc;

  ((void)0)
                                                     ;
  ((void)0);
  ((void)0);
  if( iDbPage<3 ) return sqlite3CorruptError(67053);


 
                                           ;
  rc = sqlite3PagerMovepage(pPager, pDbPage->pDbPage, iFreePage, isCommit);
  if( rc!=0 ){
    return rc;
  }
  pDbPage->pgno = iFreePage;
# 67072 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( eType==5 || eType==1 ){
    rc = setChildPtrmaps(pDbPage);
    if( rc!=0 ){
      return rc;
    }
  }else{
    Pgno nextOvfl = sqlite3Get4byte(pDbPage->aData);
    if( nextOvfl!=0 ){
      ptrmapPut(pBt, nextOvfl, 4, iFreePage, &rc);
      if( rc!=0 ){
        return rc;
      }
    }
  }





  if( eType!=1 ){
    rc = btreeGetPage(pBt, iPtrPage, &pPtrPage, 0);
    if( rc!=0 ){
      return rc;
    }
    rc = sqlite3PagerWrite(pPtrPage->pDbPage);
    if( rc!=0 ){
      releasePage(pPtrPage);
      return rc;
    }
    rc = modifyPagePointer(pPtrPage, iDbPage, iFreePage, eType);
    releasePage(pPtrPage);
    if( rc==0 ){
      ptrmapPut(pBt, iFreePage, eType, iPtrPage, &rc);
    }
  }
  return rc;
}


static int allocateBtreePage(BtShared *, MemPage **, Pgno *, Pgno, u8);
# 67130 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int incrVacuumStep(BtShared *pBt, Pgno nFin, Pgno iLastPg, int bCommit){
  Pgno nFreeList;
  int rc;

  ((void)0);
  ((void)0);

  if( !(ptrmapPageno((pBt), (iLastPg))==(iLastPg)) && iLastPg!=((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    u8 eType;
    Pgno iPtrPage;

    nFreeList = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    if( nFreeList==0 ){
      return 101;
    }

    rc = ptrmapGet(pBt, iLastPg, &eType, &iPtrPage);
    if( rc!=0 ){
      return rc;
    }
    if( eType==1 ){
      return sqlite3CorruptError(67151);
    }

    if( eType==2 ){
      if( bCommit==0 ){





        Pgno iFreePg;
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iLastPg, 1);
        if( rc!=0 ){
          return rc;
        }
        ((void)0);
        releasePage(pFreePg);
      }
    } else {
      Pgno iFreePg;
      MemPage *pLastPg;
      u8 eMode = 0;
      Pgno iNear = 0;

      rc = btreeGetPage(pBt, iLastPg, &pLastPg, 0);
      if( rc!=0 ){
        return rc;
      }
# 67188 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( bCommit==0 ){
        eMode = 2;
        iNear = nFin;
      }
      do {
        MemPage *pFreePg;
        rc = allocateBtreePage(pBt, &pFreePg, &iFreePg, iNear, eMode);
        if( rc!=0 ){
          releasePage(pLastPg);
          return rc;
        }
        releasePage(pFreePg);
      }while( bCommit && iFreePg>nFin );
      ((void)0);

      rc = relocatePage(pBt, pLastPg, eType, iPtrPage, iFreePg, bCommit);
      releasePage(pLastPg);
      if( rc!=0 ){
        return rc;
      }
    }
  }

  if( bCommit==0 ){
    do {
      iLastPg--;
    }while( iLastPg==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) || (ptrmapPageno((pBt), (iLastPg))==(iLastPg)) );
    pBt->bDoTruncate = 1;
    pBt->nPage = iLastPg;
  }
  return 0;
}






static Pgno finalDbSize(BtShared *pBt, Pgno nOrig, Pgno nFree){
  int nEntry;
  Pgno nPtrmap;
  Pgno nFin;

  nEntry = pBt->usableSize/5;
  nPtrmap = (nFree-nOrig+ptrmapPageno(pBt, nOrig)+nEntry)/nEntry;
  nFin = nOrig - nFree - nPtrmap;
  if( nOrig>((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) && nFin<((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    nFin--;
  }
  while( (ptrmapPageno((pBt), (nFin))==(nFin)) || nFin==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
    nFin--;
  }

  return nFin;
}
# 67252 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeIncrVacuum(Btree *p){
  int rc;
  BtShared *pBt = p->pBt;

  sqlite3BtreeEnter(p);
  ((void)0);
  if( !pBt->autoVacuum ){
    rc = 101;
  }else{
    Pgno nOrig = btreePagecount(pBt);
    Pgno nFree = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    Pgno nFin = finalDbSize(pBt, nOrig, nFree);

    if( nOrig<nFin ){
      rc = sqlite3CorruptError(67266);
    }else if( nFree>0 ){
      rc = saveAllCursors(pBt, 0, 0);
      if( rc==0 ){
        invalidateAllOverflowCache(pBt);
        rc = incrVacuumStep(pBt, nFin, nOrig, 0);
      }
      if( rc==0 ){
        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
        sqlite3Put4byte(&pBt->pPage1->aData[28], pBt->nPage);
      }
    }else{
      rc = 101;
    }
  }
  sqlite3BtreeLeave(p);
  return rc;
}
# 67294 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int autoVacuumCommit(BtShared *pBt){
  int rc = 0;
  Pager *pPager = pBt->pPager;
 

  ((void)0);
  invalidateAllOverflowCache(pBt);
  ((void)0);
  if( !pBt->incrVacuum ){
    Pgno nFin;
    Pgno nFree;
    Pgno iFree;
    Pgno nOrig;

    nOrig = btreePagecount(pBt);
    if( (ptrmapPageno((pBt), (nOrig))==(nOrig)) || nOrig==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){




      return sqlite3CorruptError(67314);
    }

    nFree = sqlite3Get4byte(&pBt->pPage1->aData[36]);
    nFin = finalDbSize(pBt, nOrig, nFree);
    if( nFin>nOrig ) return sqlite3CorruptError(67319);
    if( nFin<nOrig ){
      rc = saveAllCursors(pBt, 0, 0);
    }
    for(iFree=nOrig; iFree>nFin && rc==0; iFree--){
      rc = incrVacuumStep(pBt, nFin, iFree, 1);
    }
    if( (rc==101 || rc==0) && nFree>0 ){
      rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
      sqlite3Put4byte(&pBt->pPage1->aData[32], 0);
      sqlite3Put4byte(&pBt->pPage1->aData[36], 0);
      sqlite3Put4byte(&pBt->pPage1->aData[28], nFin);
      pBt->bDoTruncate = 1;
      pBt->nPage = nFin;
    }
    if( rc!=0 ){
      sqlite3PagerRollback(pPager);
    }
  }

  ((void)0);
  return rc;
}
# 67373 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCommitPhaseOne(Btree *p, const char *zMaster){
  int rc = 0;
  if( p->inTrans==2 ){
    BtShared *pBt = p->pBt;
    sqlite3BtreeEnter(p);

    if( pBt->autoVacuum ){
      rc = autoVacuumCommit(pBt);
      if( rc!=0 ){
        sqlite3BtreeLeave(p);
        return rc;
      }
    }
    if( pBt->bDoTruncate ){
      sqlite3PagerTruncateImage(pBt->pPager, pBt->nPage);
    }

    rc = sqlite3PagerCommitPhaseOne(pBt->pPager, zMaster, 0);
    sqlite3BtreeLeave(p);
  }
  return rc;
}





static void btreeEndTransaction(Btree *p){
  BtShared *pBt = p->pBt;
  sqlite3 *db = p->db;
  ((void)0);


  pBt->bDoTruncate = 0;

  if( p->inTrans>0 && db->nVdbeRead>1 ){



    downgradeAllSharedCacheTableLocks(p);
    p->inTrans = 1;
  }else{




    if( p->inTrans!=0 ){
      clearAllSharedCacheTableLocks(p);
      pBt->nTransaction--;
      if( 0==pBt->nTransaction ){
        pBt->inTransaction = 0;
      }
    }



    p->inTrans = 0;
    unlockBtreeIfUnused(pBt);
  }

  ((void)0); ((void)0);;
}
# 67462 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCommitPhaseTwo(Btree *p, int bCleanup){

  if( p->inTrans==0 ) return 0;
  sqlite3BtreeEnter(p);
  ((void)0); ((void)0);;




  if( p->inTrans==2 ){
    int rc;
    BtShared *pBt = p->pBt;
    ((void)0);
    ((void)0);
    rc = sqlite3PagerCommitPhaseTwo(pBt->pPager);
    if( rc!=0 && bCleanup==0 ){
      sqlite3BtreeLeave(p);
      return rc;
    }
    p->iDataVersion--;
    pBt->inTransaction = 1;
    btreeClearHasContent(pBt);
  }

  btreeEndTransaction(p);
  sqlite3BtreeLeave(p);
  return 0;
}




static int sqlite3BtreeCommit(Btree *p){
  int rc;
  sqlite3BtreeEnter(p);
  rc = sqlite3BtreeCommitPhaseOne(p, 0);
  if( rc==0 ){
    rc = sqlite3BtreeCommitPhaseTwo(p, 0);
  }
  sqlite3BtreeLeave(p);
  return rc;
}
# 67531 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeTripAllCursors(Btree *pBtree, int errCode, int writeOnly){
  BtCursor *p;
  int rc = 0;

  ((void)0);
  if( pBtree ){
    sqlite3BtreeEnter(pBtree);
    for(p=pBtree->pBt->pCursor; p; p=p->pNext){
      if( writeOnly && (p->curFlags & 0x01)==0 ){
        if( p->eState==0 || p->eState==2 ){
          rc = saveCursorPosition(p);
          if( rc!=0 ){
            (void)sqlite3BtreeTripAllCursors(pBtree, rc, 0);
            break;
          }
        }
      }else{
        sqlite3BtreeClearCursor(p);
        p->eState = 4;
        p->skipNext = errCode;
      }
      btreeReleaseAllCursorPages(p);
    }
    sqlite3BtreeLeave(pBtree);
  }
  return rc;
}





static void btreeSetNPage(BtShared *pBt, MemPage *pPage1){
  int nPage = sqlite3Get4byte(&pPage1->aData[28]);
  ;
  if( nPage==0 ) sqlite3PagerPagecount(pBt->pPager, &nPage);
  ;
  pBt->nPage = nPage;
}
# 67582 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeRollback(Btree *p, int tripCode, int writeOnly){
  int rc;
  BtShared *pBt = p->pBt;
  MemPage *pPage1;

  ((void)0);
  ((void)0);
  sqlite3BtreeEnter(p);
  if( tripCode==0 ){
    rc = tripCode = saveAllCursors(pBt, 0, 0);
    if( rc ) writeOnly = 0;
  }else{
    rc = 0;
  }
  if( tripCode ){
    int rc2 = sqlite3BtreeTripAllCursors(p, tripCode, writeOnly);
    ((void)0);
    if( rc2!=0 ) rc = rc2;
  }
  ((void)0); ((void)0);;

  if( p->inTrans==2 ){
    int rc2;

    ((void)0);
    rc2 = sqlite3PagerRollback(pBt->pPager);
    if( rc2!=0 ){
      rc = rc2;
    }




    if( btreeGetPage(pBt, 1, &pPage1, 0)==0 ){
      btreeSetNPage(pBt, pPage1);
      releasePageOne(pPage1);
    }
    ((void)0);
    pBt->inTransaction = 1;
    btreeClearHasContent(pBt);
  }

  btreeEndTransaction(p);
  sqlite3BtreeLeave(p);
  return rc;
}
# 67647 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeBeginStmt(Btree *p, int iStatement){
  int rc;
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);





  rc = sqlite3PagerOpenSavepoint(pBt->pPager, iStatement);
  sqlite3BtreeLeave(p);
  return rc;
}
# 67678 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeSavepoint(Btree *p, int op, int iSavepoint){
  int rc = 0;
  if( p && p->inTrans==2 ){
    BtShared *pBt = p->pBt;
    ((void)0);
    ((void)0);
    sqlite3BtreeEnter(p);
    if( op==2 ){
      rc = saveAllCursors(pBt, 0, 0);
    }
    if( rc==0 ){
      rc = sqlite3PagerSavepoint(pBt->pPager, op, iSavepoint);
    }
    if( rc==0 ){
      if( iSavepoint<0 && (pBt->btsFlags & 0x0010)!=0 ){
        pBt->nPage = 0;
      }
      rc = newDatabase(pBt);
      btreeSetNPage(pBt, pBt->pPage1);



      ((void)0);
    }
    sqlite3BtreeLeave(p);
  }
  return rc;
}
# 67749 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeCursor(
  Btree *p,
  int iTable,
  int wrFlag,
  struct KeyInfo *pKeyInfo,
  BtCursor *pCur
){
  BtShared *pBt = p->pBt;
  BtCursor *pX;

  ((void)0);
  ((void)0)


   ;





  ((void)0);
  ((void)0);


  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( wrFlag ){
    allocateTempSpace(pBt);
    if( pBt->pTmpSpace==0 ) return 7;
  }
  if( iTable==1 && btreePagecount(pBt)==0 ){
    ((void)0);
    iTable = 0;
  }



  pCur->pgnoRoot = (Pgno)iTable;
  pCur->iPage = -1;
  pCur->pKeyInfo = pKeyInfo;
  pCur->pBtree = p;
  pCur->pBt = pBt;
  pCur->curFlags = wrFlag ? 0x01 : 0;
  pCur->curPagerFlags = wrFlag ? 0 : 0x02;


  for(pX=pBt->pCursor; pX; pX=pX->pNext){
    if( pX->pgnoRoot==(Pgno)iTable ){
      pX->curFlags |= 0x20;
      pCur->curFlags |= 0x20;
    }
  }
  pCur->pNext = pBt->pCursor;
  pBt->pCursor = pCur;
  pCur->eState = 1;
  return 0;
}
static int sqlite3BtreeCursor(
  Btree *p,
  int iTable,
  int wrFlag,
  struct KeyInfo *pKeyInfo,
  BtCursor *pCur
){
  int rc;
  if( iTable<1 ){
    rc = sqlite3CorruptError(67818);
  }else{
    sqlite3BtreeEnter(p);
    rc = btreeCursor(p, iTable, wrFlag, pKeyInfo, pCur);
    sqlite3BtreeLeave(p);
  }
  return rc;
}
# 67835 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCursorSize(void){
  return (((sizeof(BtCursor))+7)&~7);
}
# 67847 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BtreeCursorZero(BtCursor *p){
  memset(p, 0, __builtin_offsetof(BtCursor,pBt));
}





static int sqlite3BtreeCloseCursor(BtCursor *pCur){
  Btree *pBtree = pCur->pBtree;
  if( pBtree ){
    BtShared *pBt = pCur->pBt;
    sqlite3BtreeEnter(pBtree);
    ((void)0);
    if( pBt->pCursor==pCur ){
      pBt->pCursor = pCur->pNext;
    }else{
      BtCursor *pPrev = pBt->pCursor;
      do{
        if( pPrev->pNext==pCur ){
          pPrev->pNext = pCur->pNext;
          break;
        }
        pPrev = pPrev->pNext;
      }while( (pPrev) );
    }
    btreeReleaseAllCursorPages(pCur);
    unlockBtreeIfUnused(pBt);
    sqlite3_free(pCur->aOverflow);
    sqlite3_free(pCur->pKey);
    sqlite3BtreeLeave(pBtree);
    pCur->pBtree = 0;
  }
  return 0;
}
# 67907 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define assertCellInfo(x) 

static __attribute__((noinline)) void getCellInfo(BtCursor *pCur){
  if( pCur->info.nSize==0 ){
    pCur->curFlags |= 0x02;
    btreeParseCell(pCur->pPage,pCur->ix,&pCur->info);
  }else{
    ;
  }
}
# 67928 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCursorIsValidNN(BtCursor *pCur){
  ((void)0);
  return pCur->eState==0;
}







static i64 sqlite3BtreeIntegerKey(BtCursor *pCur){
  ((void)0);
  ((void)0);
  ((void)0);
  getCellInfo(pCur);
  return pCur->info.nKey;
}
# 67970 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u32 sqlite3BtreePayloadSize(BtCursor *pCur){
  ((void)0);
  ((void)0);
  getCellInfo(pCur);
  return pCur->info.nPayload;
}
# 67990 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_int64 sqlite3BtreeMaxRecordSize(BtCursor *pCur){
  ((void)0);
  ((void)0);
  return pCur->pBt->pageSize * (sqlite3_int64)pCur->pBt->nPage;
}
# 68015 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getOverflowPage(
  BtShared *pBt,
  Pgno ovfl,
  MemPage **ppPage,
  Pgno *pPgnoNext
){
  Pgno next = 0;
  MemPage *pPage = 0;
  int rc = 0;

  ((void)0);
  ((void)0);
# 68035 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pBt->autoVacuum ){
    Pgno pgno;
    Pgno iGuess = ovfl+1;
    u8 eType;

    while( (ptrmapPageno((pBt), (iGuess))==(iGuess)) || iGuess==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      iGuess++;
    }

    if( iGuess<=btreePagecount(pBt) ){
      rc = ptrmapGet(pBt, iGuess, &eType, &pgno);
      if( rc==0 && eType==4 && pgno==ovfl ){
        next = iGuess;
        rc = 101;
      }
    }
  }


  ((void)0);
  if( rc==0 ){
    rc = btreeGetPage(pBt, ovfl, &pPage, (ppPage==0) ? 0x02 : 0);
    ((void)0);
    if( rc==0 ){
      next = sqlite3Get4byte(pPage->aData);
    }
  }

  *pPgnoNext = next;
  if( ppPage ){
    *ppPage = pPage;
  }else{
    releasePage(pPage);
  }
  return (rc==101 ? 0 : rc);
}
# 68083 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int copyPayload(
  void *pPayload,
  void *pBuf,
  int nByte,
  int eOp,
  DbPage *pDbPage
){
  if( eOp ){

    int rc = sqlite3PagerWrite(pDbPage);
    if( rc!=0 ){
      return rc;
    }
    memcpy(pPayload, pBuf, nByte);
  }else{

    memcpy(pBuf, pPayload, nByte);
  }
  return 0;
}
# 68133 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int accessPayload(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  unsigned char *pBuf,
  int eOp
){
  unsigned char *aPayload;
  int rc = 0;
  int iIdx = 0;
  MemPage *pPage = pCur->pPage;
  BtShared *pBt = pCur->pBt;




  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  getCellInfo(pCur);
  aPayload = pCur->info.pPayload;
  ((void)0);

  ((void)0);
  if( (uptr)(aPayload - pPage->aData) > (pBt->usableSize - pCur->info.nLocal) ){





    return sqlite3CorruptError(68166);
  }


  if( offset<pCur->info.nLocal ){
    int a = amt;
    if( a+offset>pCur->info.nLocal ){
      a = pCur->info.nLocal - offset;
    }
    rc = copyPayload(&aPayload[offset], pBuf, a, eOp, pPage->pDbPage);
    offset = 0;
    pBuf += a;
    amt -= a;
  }else{
    offset -= pCur->info.nLocal;
  }


  if( rc==0 && amt>0 ){
    const u32 ovflSize = pBt->usableSize - 4;
    Pgno nextPage;

    nextPage = sqlite3Get4byte(&aPayload[pCur->info.nLocal]);
# 68197 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (pCur->curFlags & 0x04)==0 ){
      int nOvfl = (pCur->info.nPayload-pCur->info.nLocal+ovflSize-1)/ovflSize;
      if( pCur->aOverflow==0
       || nOvfl*(int)sizeof(Pgno) > sqlite3MallocSize(pCur->aOverflow)
      ){
        Pgno *aNew = (Pgno*)sqlite3Realloc(
            pCur->aOverflow, nOvfl*2*sizeof(Pgno)
        );
        if( aNew==0 ){
          return 7;
        }else{
          pCur->aOverflow = aNew;
        }
      }
      memset(pCur->aOverflow, 0, nOvfl*sizeof(Pgno));
      pCur->curFlags |= 0x04;
    }else{




      if( pCur->aOverflow[offset/ovflSize] ){
        iIdx = (offset/ovflSize);
        nextPage = pCur->aOverflow[iIdx];
        offset = (offset%ovflSize);
      }
    }

    ((void)0);
    while( nextPage ){

      ((void)0)

                             ;
      pCur->aOverflow[iIdx] = nextPage;

      if( offset>=ovflSize ){






        ((void)0);
        ((void)0);
        if( pCur->aOverflow[iIdx+1] ){
          nextPage = pCur->aOverflow[iIdx+1];
        }else{
          rc = getOverflowPage(pBt, nextPage, 0, &nextPage);
        }
        offset -= ovflSize;
      }else{



        int a = amt;
        if( a + offset > ovflSize ){
          a = ovflSize - offset;
        }
# 68288 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        {
          DbPage *pDbPage;
          rc = sqlite3PagerGet(pBt->pPager, nextPage, &pDbPage,
              (eOp==0 ? 0x02 : 0)
          );
          if( rc==0 ){
            aPayload = sqlite3PagerGetData(pDbPage);
            nextPage = sqlite3Get4byte(aPayload);
            rc = copyPayload(&aPayload[offset+4], pBuf, a, eOp, pDbPage);
            sqlite3PagerUnref(pDbPage);
            offset = 0;
          }
        }
        amt -= a;
        if( amt==0 ) return rc;
        pBuf += a;
      }
      if( rc ) break;
      iIdx++;
    }
  }

  if( rc==0 && amt>0 ){

    return sqlite3CorruptError(68312);
  }
  return rc;
}
# 68334 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreePayload(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  return accessPayload(pCur, offset, amt, (unsigned char*)pBuf, 0);
}







static __attribute__((noinline)) int accessPayloadChecked(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  void *pBuf
){
  int rc;
  if ( pCur->eState==1 ){
    return 4;
  }
  ((void)0);
  rc = btreeRestoreCursorPosition(pCur);
  return rc ? rc : accessPayload(pCur, offset, amt, pBuf, 0);
}
static int sqlite3BtreePayloadChecked(BtCursor *pCur, u32 offset, u32 amt, void *pBuf){
  if( pCur->eState==0 ){
    ((void)0);
    return accessPayload(pCur, offset, amt, pBuf, 0);
  }else{
    return accessPayloadChecked(pCur, offset, amt, pBuf);
  }
}
# 68391 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const void *fetchPayload(
  BtCursor *pCur,
  u32 *pAmt
){
  int amt;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  amt = pCur->info.nLocal;
  if( amt>(int)(pCur->pPage->aDataEnd - pCur->info.pPayload) ){


    ((void)0);
    amt = ((0)>((int)(pCur->pPage->aDataEnd - pCur->info.pPayload))?(0):((int)(pCur->pPage->aDataEnd - pCur->info.pPayload)));
  }
  *pAmt = (u32)amt;
  return (void*)pCur->info.pPayload;
}
# 68430 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const void *sqlite3BtreePayloadFetch(BtCursor *pCur, u32 *pAmt){
  return fetchPayload(pCur, pAmt);
}
# 68444 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int moveToChild(BtCursor *pCur, u32 newPgno){
  BtShared *pBt = pCur->pBt;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( pCur->iPage>=(20 -1) ){
    return sqlite3CorruptError(68452);
  }
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x02|0x04);
  pCur->aiIdx[pCur->iPage] = pCur->ix;
  pCur->apPage[pCur->iPage] = pCur->pPage;
  pCur->ix = 0;
  pCur->iPage++;
  return getAndInitPage(pBt, newPgno, &pCur->pPage, pCur, pCur->curPagerFlags);
}
# 68482 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define assertParentIndex(x,y,z) 
# 68493 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void moveToParent(BtCursor *pCur){
  MemPage *pLeaf;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
 



   ;
  ;
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x02|0x04);
  pCur->ix = pCur->aiIdx[pCur->iPage-1];
  pLeaf = pCur->pPage;
  pCur->pPage = pCur->apPage[--pCur->iPage];
  releasePageNotNull(pLeaf);
}
# 68534 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int moveToRoot(BtCursor *pCur){
  MemPage *pRoot;
  int rc = 0;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( pCur->iPage>=0 ){
    if( pCur->iPage ){
      releasePageNotNull(pCur->pPage);
      while( --pCur->iPage ){
        releasePageNotNull(pCur->apPage[pCur->iPage]);
      }
      pCur->pPage = pCur->apPage[0];
      goto skip_init;
    }
  }else if( pCur->pgnoRoot==0 ){
    pCur->eState = 1;
    return 16;
  }else{
    ((void)0);
    if( pCur->eState>=3 ){
      if( pCur->eState==4 ){
        ((void)0);
        return pCur->skipNext;
      }
      sqlite3BtreeClearCursor(pCur);
    }
    rc = getAndInitPage(pCur->pBtree->pBt, pCur->pgnoRoot, &pCur->pPage,
                        0, pCur->curPagerFlags);
    if( rc!=0 ){
      pCur->eState = 1;
      return rc;
    }
    pCur->iPage = 0;
    pCur->curIntKey = pCur->pPage->intKey;
  }
  pRoot = pCur->pPage;
  ((void)0);
# 68588 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( pRoot->isInit==0 || (pCur->pKeyInfo==0)!=pRoot->intKey ){
    return sqlite3CorruptError(68590);
  }

skip_init:
  pCur->ix = 0;
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x08|0x02|0x04);

  pRoot = pCur->pPage;
  if( pRoot->nCell>0 ){
    pCur->eState = 0;
  }else if( !pRoot->leaf ){
    Pgno subpage;
    if( pRoot->pgno!=1 ) return sqlite3CorruptError(68603);
    subpage = sqlite3Get4byte(&pRoot->aData[pRoot->hdrOffset+8]);
    pCur->eState = 0;
    rc = moveToChild(pCur, subpage);
  }else{
    pCur->eState = 1;
    rc = 16;
  }
  return rc;
}
# 68621 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int moveToLeftmost(BtCursor *pCur){
  Pgno pgno;
  int rc = 0;
  MemPage *pPage;

  ((void)0);
  ((void)0);
  while( rc==0 && !(pPage = pCur->pPage)->leaf ){
    ((void)0);
    pgno = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(pCur->ix)])))));
    rc = moveToChild(pCur, pgno);
  }
  return rc;
}
# 68646 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int moveToRightmost(BtCursor *pCur){
  Pgno pgno;
  int rc = 0;
  MemPage *pPage = 0;

  ((void)0);
  ((void)0);
  while( !(pPage = pCur->pPage)->leaf ){
    pgno = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    pCur->ix = pPage->nCell;
    rc = moveToChild(pCur, pgno);
    if( rc ) return rc;
  }
  pCur->ix = pPage->nCell-1;
  ((void)0);
  ((void)0);
  return 0;
}





static int sqlite3BtreeFirst(BtCursor *pCur, int *pRes){
  int rc;

  ((void)0);
  ((void)0);
  rc = moveToRoot(pCur);
  if( rc==0 ){
    ((void)0);
    *pRes = 0;
    rc = moveToLeftmost(pCur);
  }else if( rc==16 ){
    ((void)0);
    *pRes = 1;
    rc = 0;
  }
  return rc;
}





static int sqlite3BtreeLast(BtCursor *pCur, int *pRes){
  int rc;

  ((void)0);
  ((void)0);


  if( 0==pCur->eState && (pCur->curFlags & 0x08)!=0 ){
# 68709 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    *pRes = 0;
    return 0;
  }

  rc = moveToRoot(pCur);
  if( rc==0 ){
    ((void)0);
    *pRes = 0;
    rc = moveToRightmost(pCur);
    if( rc==0 ){
      pCur->curFlags |= 0x08;
    }else{
      pCur->curFlags &= ~0x08;
    }
  }else if( rc==16 ){
    ((void)0);
    *pRes = 1;
    rc = 0;
  }
  return rc;
}
# 68761 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeMovetoUnpacked(
  BtCursor *pCur,
  UnpackedRecord *pIdxKey,
  i64 intKey,
  int biasRight,
  int *pRes
){
  int rc;
  RecordCompare xRecordCompare;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);



  if( pIdxKey==0
   && pCur->eState==0 && (pCur->curFlags & 0x02)!=0
  ){
    if( pCur->info.nKey==intKey ){
      *pRes = 0;
      return 0;
    }
    if( pCur->info.nKey<intKey ){
      if( (pCur->curFlags & 0x08)!=0 ){
        *pRes = -1;
        return 0;
      }




      if( pCur->info.nKey+1==intKey ){
        *pRes = 0;
        rc = sqlite3BtreeNext(pCur, 0);
        if( rc==0 ){
          getCellInfo(pCur);
          if( pCur->info.nKey==intKey ){
            return 0;
          }
        }else if( rc==101 ){
          rc = 0;
        }else{
          return rc;
        }
      }
    }
  }

  if( pIdxKey ){
    xRecordCompare = sqlite3VdbeFindCompare(pIdxKey);
    pIdxKey->errCode = 0;
    ((void)0)


     ;
  }else{
    xRecordCompare = 0;
  }

  rc = moveToRoot(pCur);
  if( rc ){
    if( rc==16 ){
      ((void)0);
      *pRes = -1;
      return 0;
    }
    return rc;
  }
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  for(;;){
    int lwr, upr, idx, c;
    Pgno chldPg;
    MemPage *pPage = pCur->pPage;
    u8 *pCell;







    ((void)0);
    ((void)0);
    lwr = 0;
    upr = pPage->nCell-1;
    ((void)0);
    idx = upr>>(1-biasRight);
    pCur->ix = (u16)idx;
    if( xRecordCompare==0 ){
      for(;;){
        i64 nCellKey;
        pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(idx)]))));
        if( pPage->intKeyLeaf ){
          while( 0x80 <= *(pCell++) ){
            if( pCell>=pPage->aDataEnd ){
              return sqlite3CorruptError(68864);
            }
          }
        }
        sqlite3GetVarint(pCell, (u64*)&nCellKey);
        if( nCellKey<intKey ){
          lwr = idx+1;
          if( lwr>upr ){ c = -1; break; }
        }else if( nCellKey>intKey ){
          upr = idx-1;
          if( lwr>upr ){ c = +1; break; }
        }else{
          ((void)0);
          pCur->ix = (u16)idx;
          if( !pPage->leaf ){
            lwr = idx;
            goto moveto_next_layer;
          }else{
            pCur->curFlags |= 0x02;
            pCur->info.nKey = nCellKey;
            pCur->info.nSize = 0;
            *pRes = 0;
            return 0;
          }
        }
        ((void)0);
        idx = (lwr+upr)>>1;
      }
    }else{
      for(;;){
        int nCell;
        pCell = ((pPage)->aDataOfst + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(idx)]))));
# 68905 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        nCell = pCell[0];
        if( nCell<=pPage->max1bytePayload ){



          ;
          c = xRecordCompare(nCell, (void*)&pCell[1], pIdxKey);
        }else if( !(pCell[1] & 0x80)
          && (nCell = ((nCell&0x7f)<<7) + pCell[1])<=pPage->maxLocal
        ){


          ;
          c = xRecordCompare(nCell, (void*)&pCell[2], pIdxKey);
        }else{
# 68929 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          void *pCellKey;
          u8 * const pCellBody = pCell - pPage->childPtrSize;
          const int nOverrun = 18;
          pPage->xParseCell(pPage, pCellBody, &pCur->info);
          nCell = (int)pCur->info.nKey;
          ;
          ;
          ;
          ;
          if( nCell<2 || nCell/pCur->pBt->usableSize>pCur->pBt->nPage ){
            rc = sqlite3CorruptError(68939);
            goto moveto_finish;
          }
          pCellKey = sqlite3Malloc( nCell+nOverrun );
          if( pCellKey==0 ){
            rc = 7;
            goto moveto_finish;
          }
          pCur->ix = (u16)idx;
          rc = accessPayload(pCur, 0, nCell, (unsigned char*)pCellKey, 0);
          memset(((u8*)pCellKey)+nCell,0,nOverrun);
          pCur->curFlags &= ~0x04;
          if( rc ){
            sqlite3_free(pCellKey);
            goto moveto_finish;
          }
          c = sqlite3VdbeRecordCompare(nCell, pCellKey, pIdxKey);
          sqlite3_free(pCellKey);
        }
        ((void)0)


         ;
        if( c<0 ){
          lwr = idx+1;
        }else if( c>0 ){
          upr = idx-1;
        }else{
          ((void)0);
          *pRes = 0;
          rc = 0;
          pCur->ix = (u16)idx;
          if( pIdxKey->errCode ) rc = sqlite3CorruptError(68971);
          goto moveto_finish;
        }
        if( lwr>upr ) break;
        ((void)0);
        idx = (lwr+upr)>>1;
      }
    }
    ((void)0);
    ((void)0);
    if( pPage->leaf ){
      ((void)0);
      pCur->ix = (u16)idx;
      *pRes = c;
      rc = 0;
      goto moveto_finish;
    }
moveto_next_layer:
    if( lwr>=pPage->nCell ){
      chldPg = sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]);
    }else{
      chldPg = sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(lwr)])))));
    }
    pCur->ix = (u16)lwr;
    rc = moveToChild(pCur, chldPg);
    if( rc ) break;
  }
moveto_finish:
  pCur->info.nSize = 0;
  ((void)0);
  return rc;
}
# 69012 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeEof(BtCursor *pCur){




  return (0!=pCur->eState);
}






static i64 sqlite3BtreeRowCountEst(BtCursor *pCur){
  i64 n;
  u8 i;

  ((void)0);
  ((void)0);




  if( (pCur->eState!=0) ) return -1;
  if( (pCur->pPage->leaf==0) ) return -1;

  n = pCur->pPage->nCell;
  for(i=0; i<pCur->iPage; i++){
    n *= pCur->apPage[i]->nCell;
  }
  return n;
}
# 69065 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int btreeNext(BtCursor *pCur){
  int rc;
  int idx;
  MemPage *pPage;

  ((void)0);
  if( pCur->eState!=0 ){
    ((void)0);
    rc = (pCur->eState>=3 ? btreeRestoreCursorPosition(pCur) : 0);
    if( rc!=0 ){
      return rc;
    }
    if( 1==pCur->eState ){
      return 101;
    }
    if( pCur->eState==2 ){
      pCur->eState = 0;
      if( pCur->skipNext>0 ) return 0;
    }
  }

  pPage = pCur->pPage;
  idx = ++pCur->ix;
  if( !pPage->isInit ){







    return sqlite3CorruptError(69096);
  }






  ;

  if( idx>=pPage->nCell ){
    if( !pPage->leaf ){
      rc = moveToChild(pCur, sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]));
      if( rc ) return rc;
      return moveToLeftmost(pCur);
    }
    do{
      if( pCur->iPage==0 ){
        pCur->eState = 1;
        return 101;
      }
      moveToParent(pCur);
      pPage = pCur->pPage;
    }while( pCur->ix>=pPage->nCell );
    if( pPage->intKey ){
      return sqlite3BtreeNext(pCur, 0);
    }else{
      return 0;
    }
  }
  if( pPage->leaf ){
    return 0;
  }else{
    return moveToLeftmost(pCur);
  }
}
static int sqlite3BtreeNext(BtCursor *pCur, int flags){
  MemPage *pPage;
  (void)(flags);
  ((void)0);
  ((void)0);
  pCur->info.nSize = 0;
  pCur->curFlags &= ~(0x02|0x04);
  if( pCur->eState!=0 ) return btreeNext(pCur);
  pPage = pCur->pPage;
  if( (++pCur->ix)>=pPage->nCell ){
    pCur->ix--;
    return btreeNext(pCur);
  }
  if( pPage->leaf ){
    return 0;
  }else{
    return moveToLeftmost(pCur);
  }
}
# 69172 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int btreePrevious(BtCursor *pCur){
  int rc;
  MemPage *pPage;

  ((void)0);
  ((void)0);
  ((void)0);
  if( pCur->eState!=0 ){
    rc = (pCur->eState>=3 ? btreeRestoreCursorPosition(pCur) : 0);
    if( rc!=0 ){
      return rc;
    }
    if( 1==pCur->eState ){
      return 101;
    }
    if( 2==pCur->eState ){
      pCur->eState = 0;
      if( pCur->skipNext<0 ) return 0;
    }
  }

  pPage = pCur->pPage;
  ((void)0);
  if( !pPage->leaf ){
    int idx = pCur->ix;
    rc = moveToChild(pCur, sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(idx)]))))));
    if( rc ) return rc;
    rc = moveToRightmost(pCur);
  }else{
    while( pCur->ix==0 ){
      if( pCur->iPage==0 ){
        pCur->eState = 1;
        return 101;
      }
      moveToParent(pCur);
    }
    ((void)0);
    ((void)0);

    pCur->ix--;
    pPage = pCur->pPage;
    if( pPage->intKey && !pPage->leaf ){
      rc = sqlite3BtreePrevious(pCur, 0);
    }else{
      rc = 0;
    }
  }
  return rc;
}
static int sqlite3BtreePrevious(BtCursor *pCur, int flags){
  ((void)0);
  ((void)0);
  (void)(flags);
  pCur->curFlags &= ~(0x08|0x04|0x02);
  pCur->info.nSize = 0;
  if( pCur->eState!=0
   || pCur->ix==0
   || pCur->pPage->leaf==0
  ){
    return btreePrevious(pCur);
  }
  pCur->ix--;
  return 0;
}
# 69259 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int allocateBtreePage(
  BtShared *pBt,
  MemPage **ppPage,
  Pgno *pPgno,
  Pgno nearby,
  u8 eMode
){
  MemPage *pPage1;
  int rc;
  u32 n;
  u32 k;
  MemPage *pTrunk = 0;
  MemPage *pPrevTrunk = 0;
  Pgno mxPage;

  ((void)0);
  ((void)0);
  pPage1 = pBt->pPage1;
  mxPage = btreePagecount(pBt);


  n = sqlite3Get4byte(&pPage1->aData[36]);
  ;
  if( n>=mxPage ){
    return sqlite3CorruptError(69283);
  }
  if( n>0 ){

    Pgno iTrunk;
    u8 searchList = 0;
    u32 nSearch = 0;






    if( eMode==1 ){
      if( nearby<=mxPage ){
        u8 eType;
        ((void)0);
        ((void)0);
        rc = ptrmapGet(pBt, nearby, &eType, 0);
        if( rc ) return rc;
        if( eType==2 ){
          searchList = 1;
        }
      }
    }else if( eMode==2 ){
      searchList = 1;
    }





    rc = sqlite3PagerWrite(pPage1->pDbPage);
    if( rc ) return rc;
    sqlite3Put4byte(&pPage1->aData[36], n-1);






    do {
      pPrevTrunk = pTrunk;
      if( pPrevTrunk ){



        iTrunk = sqlite3Get4byte(&pPrevTrunk->aData[0]);
      }else{



        iTrunk = sqlite3Get4byte(&pPage1->aData[32]);
      }
      ;
      if( iTrunk>mxPage || nSearch++ > n ){
        rc = sqlite3CorruptError(69339);
      }else{
        rc = btreeGetUnusedPage(pBt, iTrunk, &pTrunk, 0);
      }
      if( rc ){
        pTrunk = 0;
        goto end_allocate_page;
      }
      ((void)0);
      ((void)0);


      k = sqlite3Get4byte(&pTrunk->aData[4]);
      if( k==0 && !searchList ){



        ((void)0);
        rc = sqlite3PagerWrite(pTrunk->pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        *pPgno = iTrunk;
        memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
        *ppPage = pTrunk;
        pTrunk = 0;
        ;
      }else if( k>(u32)(pBt->usableSize/4 - 2) ){

        rc = sqlite3CorruptError(69368);
        goto end_allocate_page;

      }else if( searchList
            && (nearby==iTrunk || (iTrunk<nearby && eMode==2))
      ){



        *pPgno = iTrunk;
        *ppPage = pTrunk;
        searchList = 0;
        rc = sqlite3PagerWrite(pTrunk->pDbPage);
        if( rc ){
          goto end_allocate_page;
        }
        if( k==0 ){
          if( !pPrevTrunk ){
            memcpy(&pPage1->aData[32], &pTrunk->aData[0], 4);
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
            if( rc!=0 ){
              goto end_allocate_page;
            }
            memcpy(&pPrevTrunk->aData[0], &pTrunk->aData[0], 4);
          }
        }else{




          MemPage *pNewTrunk;
          Pgno iNewTrunk = sqlite3Get4byte(&pTrunk->aData[8]);
          if( iNewTrunk>mxPage ){
            rc = sqlite3CorruptError(69402);
            goto end_allocate_page;
          }
          ;
          rc = btreeGetUnusedPage(pBt, iNewTrunk, &pNewTrunk, 0);
          if( rc!=0 ){
            goto end_allocate_page;
          }
          rc = sqlite3PagerWrite(pNewTrunk->pDbPage);
          if( rc!=0 ){
            releasePage(pNewTrunk);
            goto end_allocate_page;
          }
          memcpy(&pNewTrunk->aData[0], &pTrunk->aData[0], 4);
          sqlite3Put4byte(&pNewTrunk->aData[4], k-1);
          memcpy(&pNewTrunk->aData[8], &pTrunk->aData[12], (k-1)*4);
          releasePage(pNewTrunk);
          if( !pPrevTrunk ){
            ((void)0);
            sqlite3Put4byte(&pPage1->aData[32], iNewTrunk);
          }else{
            rc = sqlite3PagerWrite(pPrevTrunk->pDbPage);
            if( rc ){
              goto end_allocate_page;
            }
            sqlite3Put4byte(&pPrevTrunk->aData[0], iNewTrunk);
          }
        }
        pTrunk = 0;
        ;

      }else if( k>0 ){

        u32 closest;
        Pgno iPage;
        unsigned char *aData = pTrunk->aData;
        if( nearby>0 ){
          u32 i;
          closest = 0;
          if( eMode==2 ){
            for(i=0; i<k; i++){
              iPage = sqlite3Get4byte(&aData[8+i*4]);
              if( iPage<=nearby ){
                closest = i;
                break;
              }
            }
          }else{
            int dist;
            dist = sqlite3AbsInt32(sqlite3Get4byte(&aData[8]) - nearby);
            for(i=1; i<k; i++){
              int d2 = sqlite3AbsInt32(sqlite3Get4byte(&aData[8+i*4]) - nearby);
              if( d2<dist ){
                closest = i;
                dist = d2;
              }
            }
          }
        }else{
          closest = 0;
        }

        iPage = sqlite3Get4byte(&aData[8+closest*4]);
        ;
        if( iPage>mxPage ){
          rc = sqlite3CorruptError(69467);
          goto end_allocate_page;
        }
        ;
        if( !searchList
         || (iPage==nearby || (iPage<nearby && eMode==2))
        ){
          int noContent;
          *pPgno = iPage;
         

                                                          ;
          rc = sqlite3PagerWrite(pTrunk->pDbPage);
          if( rc ) goto end_allocate_page;
          if( closest<k-1 ){
            memcpy(&aData[8+closest*4], &aData[4+k*4], 4);
          }
          sqlite3Put4byte(&aData[4], k-1);
          noContent = !btreeGetHasContent(pBt, *pPgno)? 0x01 : 0;
          rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, noContent);
          if( rc==0 ){
            rc = sqlite3PagerWrite((*ppPage)->pDbPage);
            if( rc!=0 ){
              releasePage(*ppPage);
              *ppPage = 0;
            }
          }
          searchList = 0;
        }
      }
      releasePage(pPrevTrunk);
      pPrevTrunk = 0;
    }while( searchList );
  }else{
# 69519 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    int bNoContent = (0==(pBt->bDoTruncate))? 0x01:0;

    rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
    if( rc ) return rc;
    pBt->nPage++;
    if( pBt->nPage==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ) pBt->nPage++;


    if( pBt->autoVacuum && (ptrmapPageno((pBt), (pBt->nPage))==(pBt->nPage)) ){




      MemPage *pPg = 0;
      ;
      ((void)0);
      rc = btreeGetUnusedPage(pBt, pBt->nPage, &pPg, bNoContent);
      if( rc==0 ){
        rc = sqlite3PagerWrite(pPg->pDbPage);
        releasePage(pPg);
      }
      if( rc ) return rc;
      pBt->nPage++;
      if( pBt->nPage==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){ pBt->nPage++; }
    }

    sqlite3Put4byte(28 + (u8*)pBt->pPage1->aData, pBt->nPage);
    *pPgno = pBt->nPage;

    ((void)0);
    rc = btreeGetUnusedPage(pBt, *pPgno, ppPage, bNoContent);
    if( rc ) return rc;
    rc = sqlite3PagerWrite((*ppPage)->pDbPage);
    if( rc!=0 ){
      releasePage(*ppPage);
      *ppPage = 0;
    }
    ;
  }

  ((void)0);

end_allocate_page:
  releasePage(pTrunk);
  releasePage(pPrevTrunk);
  ((void)0);
  ((void)0);
  return rc;
}
# 69581 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int freePage2(BtShared *pBt, MemPage *pMemPage, Pgno iPage){
  MemPage *pTrunk = 0;
  Pgno iTrunk = 0;
  MemPage *pPage1 = pBt->pPage1;
  MemPage *pPage;
  int rc;
  u32 nFree;

  ((void)0);
  ((void)0);
  ((void)0);

  if( iPage<2 || iPage>pBt->nPage ){
    return sqlite3CorruptError(69594);
  }
  if( pMemPage ){
    pPage = pMemPage;
    sqlite3PagerRef(pPage->pDbPage);
  }else{
    pPage = btreePageLookup(pBt, iPage);
  }


  rc = sqlite3PagerWrite(pPage1->pDbPage);
  if( rc ) goto freepage_out;
  nFree = sqlite3Get4byte(&pPage1->aData[36]);
  sqlite3Put4byte(&pPage1->aData[36], nFree+1);

  if( pBt->btsFlags & 0x0004 ){



    if( (!pPage && ((rc = btreeGetPage(pBt, iPage, &pPage, 0))!=0) )
     || ((rc = sqlite3PagerWrite(pPage->pDbPage))!=0)
    ){
      goto freepage_out;
    }
    memset(pPage->aData, 0, pPage->pBt->pageSize);
  }




  if( (pBt->autoVacuum) ){
    ptrmapPut(pBt, iPage, 2, 0, &rc);
    if( rc ) goto freepage_out;
  }
# 69636 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( nFree!=0 ){
    u32 nLeaf;

    iTrunk = sqlite3Get4byte(&pPage1->aData[32]);
    rc = btreeGetPage(pBt, iTrunk, &pTrunk, 0);
    if( rc!=0 ){
      goto freepage_out;
    }

    nLeaf = sqlite3Get4byte(&pTrunk->aData[4]);
    ((void)0);
    if( nLeaf > (u32)pBt->usableSize/4 - 2 ){
      rc = sqlite3CorruptError(69648);
      goto freepage_out;
    }
    if( nLeaf < (u32)pBt->usableSize/4 - 8 ){
# 69671 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      rc = sqlite3PagerWrite(pTrunk->pDbPage);
      if( rc==0 ){
        sqlite3Put4byte(&pTrunk->aData[4], nLeaf+1);
        sqlite3Put4byte(&pTrunk->aData[8+nLeaf*4], iPage);
        if( pPage && (pBt->btsFlags & 0x0004)==0 ){
          sqlite3PagerDontWrite(pPage->pDbPage);
        }
        rc = btreeSetHasContent(pBt, iPage);
      }
      ;
      goto freepage_out;
    }
  }







  if( pPage==0 && 0!=(rc = btreeGetPage(pBt, iPage, &pPage, 0)) ){
    goto freepage_out;
  }
  rc = sqlite3PagerWrite(pPage->pDbPage);
  if( rc!=0 ){
    goto freepage_out;
  }
  sqlite3Put4byte(pPage->aData, iTrunk);
  sqlite3Put4byte(&pPage->aData[4], 0);
  sqlite3Put4byte(&pPage1->aData[32], iPage);
  ;

freepage_out:
  if( pPage ){
    pPage->isInit = 0;
  }
  releasePage(pPage);
  releasePage(pTrunk);
  return rc;
}
static void freePage(MemPage *pPage, int *pRC){
  if( (*pRC)==0 ){
    *pRC = freePage2(pPage->pBt, pPage, pPage->pgno);
  }
}





static int clearCell(
  MemPage *pPage,
  unsigned char *pCell,
  CellInfo *pInfo
){
  BtShared *pBt;
  Pgno ovflPgno;
  int rc;
  int nOvfl;
  u32 ovflPageSize;

  ((void)0);
  pPage->xParseCell(pPage, pCell, pInfo);
  if( pInfo->nLocal==pInfo->nPayload ){
    return 0;
  }
  ;
  ;
  if( pCell + pInfo->nSize > pPage->aDataEnd ){

    return sqlite3CorruptError(69741);
  }
  ovflPgno = sqlite3Get4byte(pCell + pInfo->nSize - 4);
  pBt = pPage->pBt;
  ((void)0);
  ovflPageSize = pBt->usableSize - 4;
  nOvfl = (pInfo->nPayload - pInfo->nLocal + ovflPageSize - 1)/ovflPageSize;
  ((void)0)

   ;
  while( nOvfl-- ){
    Pgno iNext = 0;
    MemPage *pOvfl = 0;
    if( ovflPgno<2 || ovflPgno>btreePagecount(pBt) ){



      return sqlite3CorruptError(69758);
    }
    if( nOvfl ){
      rc = getOverflowPage(pBt, ovflPgno, &pOvfl, &iNext);
      if( rc ) return rc;
    }

    if( ( pOvfl || ((pOvfl = btreePageLookup(pBt, ovflPgno))!=0) )
     && sqlite3PagerPageRefcount(pOvfl->pDbPage)!=1
    ){
# 69778 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      rc = sqlite3CorruptError(69778);
    }else{
      rc = freePage2(pBt, pOvfl, ovflPgno);
    }

    if( pOvfl ){
      sqlite3PagerUnref(pOvfl->pDbPage);
    }
    if( rc ) return rc;
    ovflPgno = iNext;
  }
  return 0;
}
# 69804 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int fillInCell(
  MemPage *pPage,
  unsigned char *pCell,
  const BtreePayload *pX,
  int *pnSize
){
  int nPayload;
  const u8 *pSrc;
  int nSrc, n, rc, mn;
  int spaceLeft;
  MemPage *pToRelease;
  unsigned char *pPrior;
  unsigned char *pPayload;
  BtShared *pBt;
  Pgno pgnoOvfl;
  int nHeader;

  ((void)0);



  ((void)0)
                                                        ;


  nHeader = pPage->childPtrSize;
  if( pPage->intKey ){
    nPayload = pX->nData + pX->nZero;
    pSrc = pX->pData;
    nSrc = pX->nData;
    ((void)0);
    nHeader += (u8)(((u32)(nPayload)<(u32)0x80)?(*(&pCell[nHeader])=(unsigned char)(nPayload)),1: sqlite3PutVarint((&pCell[nHeader]),(nPayload)));
    nHeader += sqlite3PutVarint(&pCell[nHeader], *(u64*)&pX->nKey);
  }else{
    ((void)0);
    nSrc = nPayload = (int)pX->nKey;
    pSrc = pX->pKey;
    nHeader += (u8)(((u32)(nPayload)<(u32)0x80)?(*(&pCell[nHeader])=(unsigned char)(nPayload)),1: sqlite3PutVarint((&pCell[nHeader]),(nPayload)));
  }


  pPayload = &pCell[nHeader];
  if( nPayload<=pPage->maxLocal ){


    n = nHeader + nPayload;
    ;
    ;
    if( n<4 ) n = 4;
    *pnSize = n;
    ((void)0);
    ;
    memcpy(pPayload, pSrc, nSrc);
    memset(pPayload+nSrc, 0, nPayload-nSrc);
    return 0;
  }




  mn = pPage->minLocal;
  n = mn + (nPayload - mn) % (pPage->pBt->usableSize - 4);
  ;
  ;
  if( n > pPage->maxLocal ) n = mn;
  spaceLeft = n;
  *pnSize = n + nHeader + 4;
  pPrior = &pCell[nHeader+n];
  pToRelease = 0;
  pgnoOvfl = 0;
  pBt = pPage->pBt;
# 69900 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  while( 1 ){
    n = nPayload;
    if( n>spaceLeft ) n = spaceLeft;



    ((void)0);



    ((void)0)
                                                        ;

    if( nSrc>=n ){
      memcpy(pPayload, pSrc, n);
    }else if( nSrc>0 ){
      n = nSrc;
      memcpy(pPayload, pSrc, n);
    }else{
      memset(pPayload, 0, n);
    }
    nPayload -= n;
    if( nPayload<=0 ) break;
    pPayload += n;
    pSrc += n;
    nSrc -= n;
    spaceLeft -= n;
    if( spaceLeft==0 ){
      MemPage *pOvfl = 0;

      Pgno pgnoPtrmap = pgnoOvfl;
      if( pBt->autoVacuum ){
        do{
          pgnoOvfl++;
        } while(
          (ptrmapPageno((pBt), (pgnoOvfl))==(pgnoOvfl)) || pgnoOvfl==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1))
        );
      }

      rc = allocateBtreePage(pBt, &pOvfl, &pgnoOvfl, pgnoOvfl, 0);
# 69951 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( pBt->autoVacuum && rc==0 ){
        u8 eType = (pgnoPtrmap?4:3);
        ptrmapPut(pBt, pgnoOvfl, eType, pgnoPtrmap, &rc);
        if( rc ){
          releasePage(pOvfl);
        }
      }

      if( rc ){
        releasePage(pToRelease);
        return rc;
      }



      ((void)0);



      ((void)0)
                                                        ;

      sqlite3Put4byte(pPrior, pgnoOvfl);
      releasePage(pToRelease);
      pToRelease = pOvfl;
      pPrior = pOvfl->aData;
      sqlite3Put4byte(pPrior, 0);
      pPayload = &pOvfl->aData[4];
      spaceLeft = pBt->usableSize - 4;
    }
  }
  releasePage(pToRelease);
  return 0;
}
# 69994 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void dropCell(MemPage *pPage, int idx, int sz, int *pRC){
  u32 pc;
  u8 *data;
  u8 *ptr;
  int rc;
  int hdr;

  if( *pRC ) return;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  data = pPage->aData;
  ptr = &pPage->aCellIdx[2*idx];
  pc = ((ptr)[0]<<8 | (ptr)[1]);
  hdr = pPage->hdrOffset;
  ;
  ;
  if( pc+sz > pPage->pBt->usableSize ){
    *pRC = sqlite3CorruptError(70014);
    return;
  }
  rc = freeSpace(pPage, pc, sz);
  if( rc ){
    *pRC = rc;
    return;
  }
  pPage->nCell--;
  if( pPage->nCell==0 ){
    memset(&data[hdr+1], 0, 4);
    data[hdr+7] = 0;
    ((&data[hdr+5])[0] = (u8)((pPage->pBt->usableSize)>>8), (&data[hdr+5])[1] = (u8)(pPage->pBt->usableSize));
    pPage->nFree = pPage->pBt->usableSize - pPage->hdrOffset
                       - pPage->childPtrSize - 8;
  }else{
    memmove(ptr, ptr+2, 2*(pPage->nCell - idx));
    ((&data[hdr+3])[0] = (u8)((pPage->nCell)>>8), (&data[hdr+3])[1] = (u8)(pPage->nCell));
    pPage->nFree += 2;
  }
}
# 70050 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void insertCell(
  MemPage *pPage,
  int i,
  u8 *pCell,
  int sz,
  u8 *pTemp,
  Pgno iChild,
  int *pRC
){
  int idx = 0;
  int j;
  u8 *data;
  u8 *pIns;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( pPage->nOverflow || sz+2>pPage->nFree ){
    if( pTemp ){
      memcpy(pTemp, pCell, sz);
      pCell = pTemp;
    }
    if( iChild ){
      sqlite3Put4byte(pCell, iChild);
    }
    j = pPage->nOverflow++;



    ((void)0);
    pPage->apOvfl[j] = pCell;
    pPage->aiOvfl[j] = (u16)i;






    ((void)0);
    ((void)0);
  }else{
    int rc = sqlite3PagerWrite(pPage->pDbPage);
    if( rc!=0 ){
      *pRC = rc;
      return;
    }
    ((void)0);
    data = pPage->aData;
    ((void)0);
    rc = allocateSpace(pPage, sz, &idx);
    if( rc ){ *pRC = rc; return; }


    ((void)0);
    ((void)0);
    ((void)0);
    pPage->nFree -= (u16)(2 + sz);
    if( iChild ){





      memcpy(&data[idx+4], pCell+4, sz-4);
      sqlite3Put4byte(&data[idx], iChild);
    }else{
      memcpy(&data[idx], pCell, sz);
    }
    pIns = pPage->aCellIdx + i*2;
    memmove(pIns+2, pIns, 2*(pPage->nCell - i));
    ((pIns)[0] = (u8)((idx)>>8), (pIns)[1] = (u8)(idx));
    pPage->nCell++;

    if( (++data[pPage->hdrOffset+4])==0 ) data[pPage->hdrOffset+3]++;
    ((void)0);

    if( pPage->pBt->autoVacuum ){



      ptrmapPutOvflPtr(pPage, pPage, pCell, pRC);
    }

  }
}
# 70159 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define NN 1
#define NB 3
# 70225 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct CellArray CellArray;
struct CellArray {
  int nCell;
  MemPage *pRef;
  u8 **apCell;
  u16 *szCell;
  u8 *apEnd[3*2];
  int ixNx[3*2];
};





static void populateCellCache(CellArray *p, int idx, int N){
  ((void)0);
  while( N>0 ){
    ((void)0);
    if( p->szCell[idx]==0 ){
      p->szCell[idx] = p->pRef->xCellSize(p->pRef, p->apCell[idx]);
    }else{
      ((void)0)
                                                                           ;
    }
    idx++;
    N--;
  }
}




static __attribute__((noinline)) u16 computeCellSize(CellArray *p, int N){
  ((void)0);
  ((void)0);
  p->szCell[N] = p->pRef->xCellSize(p->pRef, p->apCell[N]);
  return p->szCell[N];
}
static u16 cachedCellSize(CellArray *p, int N){
  ((void)0);
  if( p->szCell[N] ) return p->szCell[N];
  return computeCellSize(p, N);
}
# 70282 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int rebuildPage(
  CellArray *pCArray,
  int iFirst,
  int nCell,
  MemPage *pPg
){
  const int hdr = pPg->hdrOffset;
  u8 * const aData = pPg->aData;
  const int usableSize = pPg->pBt->usableSize;
  u8 * const pEnd = &aData[usableSize];
  int i = iFirst;
  u32 j;
  int iEnd = i+nCell;
  u8 *pCellptr = pPg->aCellIdx;
  u8 *pTmp = sqlite3PagerTempSpace(pPg->pBt->pPager);
  u8 *pData;
  int k;
  u8 *pSrcEnd;

  ((void)0);
  j = ((&aData[hdr+5])[0]<<8 | (&aData[hdr+5])[1]);
  if( j>(u32)usableSize ){ j = 0; }
  memcpy(&pTmp[j], &aData[j], usableSize - j);

  for(k=0; pCArray->ixNx[k]<=i && (k<3*2); k++){}
  pSrcEnd = pCArray->apEnd[k];

  pData = pEnd;
  while( 1 ){
    u8 *pCell = pCArray->apCell[i];
    u16 sz = pCArray->szCell[i];
    ((void)0);
    if( (((uptr)(pCell)>=(uptr)(aData))&&((uptr)(pCell)<(uptr)(pEnd))) ){
      if( ((uptr)(pCell+sz))>(uptr)pEnd ) return sqlite3CorruptError(70315);
      pCell = &pTmp[pCell - aData];
    }else if( (uptr)(pCell+sz)>(uptr)pSrcEnd
           && (uptr)(pCell)<(uptr)pSrcEnd
    ){
      return sqlite3CorruptError(70320);
    }

    pData -= sz;
    ((pCellptr)[0] = (u8)(((pData - aData))>>8), (pCellptr)[1] = (u8)((pData - aData)));
    pCellptr += 2;
    if( pData < pCellptr ) return sqlite3CorruptError(70326);
    memcpy(pData, pCell, sz);
    ((void)0);
    ;
    i++;
    if( i>=iEnd ) break;
    if( pCArray->ixNx[k]<=i ){
      k++;
      pSrcEnd = pCArray->apEnd[k];
    }
  }


  pPg->nCell = nCell;
  pPg->nOverflow = 0;

  ((&aData[hdr+1])[0] = (u8)((0)>>8), (&aData[hdr+1])[1] = (u8)(0));
  ((&aData[hdr+3])[0] = (u8)((pPg->nCell)>>8), (&aData[hdr+3])[1] = (u8)(pPg->nCell));
  ((&aData[hdr+5])[0] = (u8)((pData - aData)>>8), (&aData[hdr+5])[1] = (u8)(pData - aData));
  aData[hdr+7] = 0x00;
  return 0;
}
# 70373 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pageInsertArray(
  MemPage *pPg,
  u8 *pBegin,
  u8 **ppData,
  u8 *pCellptr,
  int iFirst,
  int nCell,
  CellArray *pCArray
){
  int i = iFirst;
  u8 *aData = pPg->aData;
  u8 *pData = *ppData;
  int iEnd = iFirst + nCell;
  int k;
  u8 *pEnd;
  ((void)0);
  if( iEnd<=iFirst ) return 0;
  for(k=0; pCArray->ixNx[k]<=i && (k<3*2); k++){}
  pEnd = pCArray->apEnd[k];
  while( 1 ){
    int sz, rc;
    u8 *pSlot;
    ((void)0);
    sz = pCArray->szCell[i];
    if( (aData[1]==0 && aData[2]==0) || (pSlot = pageFindSlot(pPg,sz,&rc))==0 ){
      if( (pData - pBegin)<sz ) return 1;
      pData -= sz;
      pSlot = pData;
    }



    ((void)0)

                        ;
    if( (uptr)(pCArray->apCell[i]+sz)>(uptr)pEnd
     && (uptr)(pCArray->apCell[i])<(uptr)pEnd
    ){
      ((void)0);
      (void)sqlite3CorruptError(70412);
      return 1;
    }
    memmove(pSlot, pCArray->apCell[i], sz);
    ((pCellptr)[0] = (u8)(((pSlot - aData))>>8), (pCellptr)[1] = (u8)((pSlot - aData)));
    pCellptr += 2;
    i++;
    if( i>=iEnd ) break;
    if( pCArray->ixNx[k]<=i ){
      k++;
      pEnd = pCArray->apEnd[k];
    }
  }
  *ppData = pData;
  return 0;
}
# 70438 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pageFreeArray(
  MemPage *pPg,
  int iFirst,
  int nCell,
  CellArray *pCArray
){
  u8 * const aData = pPg->aData;
  u8 * const pEnd = &aData[pPg->pBt->usableSize];
  u8 * const pStart = &aData[pPg->hdrOffset + 8 + pPg->childPtrSize];
  int nRet = 0;
  int i;
  int iEnd = iFirst + nCell;
  u8 *pFree = 0;
  int szFree = 0;

  for(i=iFirst; i<iEnd; i++){
    u8 *pCell = pCArray->apCell[i];
    if( (((uptr)(pCell)>=(uptr)(pStart))&&((uptr)(pCell)<(uptr)(pEnd))) ){
      int sz;



      sz = pCArray->szCell[i]; ((void)0);
      if( pFree!=(pCell + sz) ){
        if( pFree ){
          ((void)0);
          freeSpace(pPg, (u16)(pFree - aData), szFree);
        }
        pFree = pCell;
        szFree = sz;
        if( pFree+sz>pEnd ) return 0;
      }else{
        pFree = pCell;
        szFree += sz;
      }
      nRet++;
    }
  }
  if( pFree ){
    ((void)0);
    freeSpace(pPg, (u16)(pFree - aData), szFree);
  }
  return nRet;
}
# 70495 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int editPage(
  MemPage *pPg,
  int iOld,
  int iNew,
  int nNew,
  CellArray *pCArray
){
  u8 * const aData = pPg->aData;
  const int hdr = pPg->hdrOffset;
  u8 *pBegin = &pPg->aCellIdx[nNew * 2];
  int nCell = pPg->nCell;
  u8 *pData;
  u8 *pCellptr;
  int i;
  int iOldEnd = iOld + pPg->nCell + pPg->nOverflow;
  int iNewEnd = iNew + nNew;







  ((void)0);
  if( iOld<iNew ){
    int nShift = pageFreeArray(pPg, iOld, iNew-iOld, pCArray);
    if( nShift>nCell ) return sqlite3CorruptError(70521);
    memmove(pPg->aCellIdx, &pPg->aCellIdx[nShift*2], nCell*2);
    nCell -= nShift;
  }
  if( iNewEnd < iOldEnd ){
    int nTail = pageFreeArray(pPg, iNewEnd, iOldEnd - iNewEnd, pCArray);
    ((void)0);
    nCell -= nTail;
  }

  pData = &aData[(((((int)((&aData[hdr+5])[0]<<8 | (&aData[hdr+5])[1]))-1)&0xffff)+1)];
  if( pData<pBegin ) goto editpage_fail;


  if( iNew<iOld ){
    int nAdd = ((nNew)<(iOld-iNew)?(nNew):(iOld-iNew));
    ((void)0);
    ((void)0);
    pCellptr = pPg->aCellIdx;
    memmove(&pCellptr[nAdd*2], pCellptr, nCell*2);
    if( pageInsertArray(
          pPg, pBegin, &pData, pCellptr,
          iNew, nAdd, pCArray
    ) ) goto editpage_fail;
    nCell += nAdd;
  }


  for(i=0; i<pPg->nOverflow; i++){
    int iCell = (iOld + pPg->aiOvfl[i]) - iNew;
    if( iCell>=0 && iCell<nNew ){
      pCellptr = &pPg->aCellIdx[iCell * 2];
      if( nCell>iCell ){
        memmove(&pCellptr[2], pCellptr, (nCell - iCell) * 2);
      }
      nCell++;
      cachedCellSize(pCArray, iCell+iNew);
      if( pageInsertArray(
            pPg, pBegin, &pData, pCellptr,
            iCell+iNew, 1, pCArray
      ) ) goto editpage_fail;
    }
  }


  ((void)0);
  pCellptr = &pPg->aCellIdx[nCell*2];
  if( pageInsertArray(
        pPg, pBegin, &pData, pCellptr,
        iNew+nCell, nNew-nCell, pCArray
  ) ) goto editpage_fail;

  pPg->nCell = nNew;
  pPg->nOverflow = 0;

  ((&aData[hdr+3])[0] = (u8)((pPg->nCell)>>8), (&aData[hdr+3])[1] = (u8)(pPg->nCell));
  ((&aData[hdr+5])[0] = (u8)((pData - aData)>>8), (&aData[hdr+5])[1] = (u8)(pData - aData));
# 70591 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return 0;
 editpage_fail:

  populateCellCache(pCArray, iNew, nNew);
  return rebuildPage(pCArray, iNew, nNew, pPg);
}
# 70623 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int balance_quick(MemPage *pParent, MemPage *pPage, u8 *pSpace){
  BtShared *const pBt = pPage->pBt;
  MemPage *pNew;
  int rc;
  Pgno pgnoNew;

  ((void)0);
  ((void)0);
  ((void)0);

  if( pPage->nCell==0 ) return sqlite3CorruptError(70633);
  ((void)0);
  ((void)0);





  rc = allocateBtreePage(pBt, &pNew, &pgnoNew, 0, 0);

  if( rc==0 ){

    u8 *pOut = &pSpace[4];
    u8 *pCell = pPage->apOvfl[0];
    u16 szCell = pPage->xCellSize(pPage, pCell);
    u8 *pStop;
    CellArray b;

    ((void)0);
    ((void)0);
    zeroPage(pNew, 0x01|0x04|0x08);
    b.nCell = 1;
    b.pRef = pPage;
    b.apCell = &pCell;
    b.szCell = &szCell;
    b.apEnd[0] = pPage->aDataEnd;
    b.ixNx[0] = 2;
    rc = rebuildPage(&b, 0, 1, pNew);
    if( (rc) ){
      releasePage(pNew);
      return rc;
    }
    pNew->nFree = pBt->usableSize - pNew->cellOffset - 2 - szCell;
# 70676 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (pBt->autoVacuum) ){
      ptrmapPut(pBt, pgnoNew, 5, pParent->pgno, &rc);
      if( szCell>pNew->minLocal ){
        ptrmapPutOvflPtr(pNew, pNew, pCell, &rc);
      }
    }
# 70696 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pCell = ((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(pPage->nCell-1)]))));
    pStop = &pCell[9];
    while( (*(pCell++)&0x80) && pCell<pStop );
    pStop = &pCell[9];
    while( ((*(pOut++) = *(pCell++))&0x80) && pCell<pStop );


    if( rc==0 ){
      insertCell(pParent, pParent->nCell, pSpace, (int)(pOut-pSpace),
                   0, pPage->pgno, &rc);
    }


    sqlite3Put4byte(&pParent->aData[pParent->hdrOffset+8], pgnoNew);


    releasePage(pNew);
  }

  return rc;
}
# 70778 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void copyNodeContent(MemPage *pFrom, MemPage *pTo, int *pRC){
  if( (*pRC)==0 ){
    BtShared * const pBt = pFrom->pBt;
    u8 * const aFrom = pFrom->aData;
    u8 * const aTo = pTo->aData;
    int const iFromHdr = pFrom->hdrOffset;
    int const iToHdr = ((pTo->pgno==1) ? 100 : 0);
    int rc;
    int iData;


    ((void)0);
    ((void)0);
    ((void)0);


    iData = ((&aFrom[iFromHdr+5])[0]<<8 | (&aFrom[iFromHdr+5])[1]);
    memcpy(&aTo[iData], &aFrom[iData], pBt->usableSize-iData);
    memcpy(&aTo[iToHdr], &aFrom[iFromHdr], pFrom->cellOffset + 2*pFrom->nCell);






    pTo->isInit = 0;
    rc = btreeInitPage(pTo);
    if( rc==0 ) rc = btreeComputeFreeSpace(pTo);
    if( rc!=0 ){
      *pRC = rc;
      return;
    }




    if( (pBt->autoVacuum) ){
      *pRC = setChildPtrmaps(pTo);
    }
  }
}
# 70860 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int balance_nonroot(
  MemPage *pParent,
  int iParentIdx,
  u8 *aOvflSpace,
  int isRoot,
  int bBulk
){
  BtShared *pBt;
  int nMaxCells = 0;
  int nNew = 0;
  int nOld;
  int i, j, k;
  int nxDiv;
  int rc = 0;
  u16 leafCorrection;
  int leafData;
  int usableSpace;
  int pageFlags;
  int iSpace1 = 0;
  int iOvflSpace = 0;
  int szScratch;
  MemPage *apOld[3];
  MemPage *apNew[3 +2];
  u8 *pRight;
  u8 *apDiv[3 -1];
  int cntNew[3 +2];
  int cntOld[3 +2];
  int szNew[3 +2];
  u8 *aSpace1;
  Pgno pgno;
  u8 abDone[3 +2];
  Pgno aPgno[3 +2];
  Pgno aPgOrder[3 +2];
  u16 aPgFlags[3 +2];
  CellArray b;

  memset(abDone, 0, sizeof(abDone));
  b.nCell = 0;
  b.apCell = 0;
  pBt = pParent->pBt;
  ((void)0);
  ((void)0);






  ((void)0);
  ((void)0);

  if( !aOvflSpace ){
    return 7;
  }
  ((void)0);
# 70927 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  i = pParent->nOverflow + pParent->nCell;
  if( i<2 ){
    nxDiv = 0;
  }else{
    ((void)0);
    if( iParentIdx==0 ){
      nxDiv = 0;
    }else if( iParentIdx==i ){
      nxDiv = i-2+bBulk;
    }else{
      nxDiv = iParentIdx-1;
    }
    i = 2-bBulk;
  }
  nOld = i+1;
  if( (i+nxDiv-pParent->nOverflow)==pParent->nCell ){
    pRight = &pParent->aData[pParent->hdrOffset+8];
  }else{
    pRight = ((pParent)->aData + ((pParent)->maskPage & __builtin_bswap16(*(u16*)(&(pParent)->aCellIdx[2*(i+nxDiv-pParent->nOverflow)]))));
  }
  pgno = sqlite3Get4byte(pRight);
  while( 1 ){
    rc = getAndInitPage(pBt, pgno, &apOld[i], 0, 0);
    if( rc ){
      memset(apOld, 0, (i+1)*sizeof(MemPage*));
      goto balance_cleanup;
    }
    if( apOld[i]->nFree<0 ){
      rc = btreeComputeFreeSpace(apOld[i]);
      if( rc ){
        memset(apOld, 0, (i)*sizeof(MemPage*));
        goto balance_cleanup;
      }
    }
    if( (i--)==0 ) break;

    if( pParent->nOverflow && i+nxDiv==pParent->aiOvfl[0] ){
      apDiv[i] = pParent->apOvfl[0];
      pgno = sqlite3Get4byte(apDiv[i]);
      szNew[i] = pParent->xCellSize(pParent, apDiv[i]);
      pParent->nOverflow = 0;
    }else{
      apDiv[i] = ((pParent)->aData + ((pParent)->maskPage & __builtin_bswap16(*(u16*)(&(pParent)->aCellIdx[2*(i+nxDiv-pParent->nOverflow)]))));
      pgno = sqlite3Get4byte(apDiv[i]);
      szNew[i] = pParent->xCellSize(pParent, apDiv[i]);
# 70985 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( pBt->btsFlags & 0x000c ){
        int iOff;

        iOff = ((int)(long int)(apDiv[i])) - ((int)(long int)(pParent->aData));
        if( (iOff+szNew[i])>(int)pBt->usableSize ){
          rc = sqlite3CorruptError(70990);
          memset(apOld, 0, (i+1)*sizeof(MemPage*));
          goto balance_cleanup;
        }else{
          memcpy(&aOvflSpace[iOff], apDiv[i], szNew[i]);
          apDiv[i] = &aOvflSpace[apDiv[i]-pParent->aData];
        }
      }
      dropCell(pParent, i+nxDiv-pParent->nOverflow, szNew[i], &rc);
    }
  }



  nMaxCells = nOld*(((pBt->pageSize-8)/6) + ((int)(sizeof(pParent->apOvfl)/sizeof(pParent->apOvfl[0]))));
  nMaxCells = (nMaxCells + 3)&~3;




  szScratch =
       nMaxCells*sizeof(u8*)
     + nMaxCells*sizeof(u16)
     + pBt->pageSize;

  ((void)0);
  b.apCell = sqlite3DbMallocRaw(0,szScratch);
  if( b.apCell==0 ){
    rc = 7;
    goto balance_cleanup;
  }
  b.szCell = (u16*)&b.apCell[nMaxCells];
  aSpace1 = (u8*)&b.szCell[nMaxCells];
  ((void)0);
# 71041 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  b.pRef = apOld[0];
  leafCorrection = b.pRef->leaf*4;
  leafData = b.pRef->intKeyLeaf;
  for(i=0; i<nOld; i++){
    MemPage *pOld = apOld[i];
    int limit = pOld->nCell;
    u8 *aData = pOld->aData;
    u16 maskPage = pOld->maskPage;
    u8 *piCell = aData + pOld->cellOffset;
    u8 *piEnd;
   




    if( pOld->aData[0]!=apOld[0]->aData[0] ){
      rc = sqlite3CorruptError(71057);
      goto balance_cleanup;
    }
# 71078 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    memset(&b.szCell[b.nCell], 0, sizeof(b.szCell[0])*(limit+pOld->nOverflow));
    if( pOld->nOverflow>0 ){
      if( (limit<pOld->aiOvfl[0]) ){
        rc = sqlite3CorruptError(71081);
        goto balance_cleanup;
      }
      limit = pOld->aiOvfl[0];
      for(j=0; j<limit; j++){
        b.apCell[b.nCell] = aData + (maskPage & __builtin_bswap16(*(u16*)(piCell)));
        piCell += 2;
        b.nCell++;
      }
      for(k=0; k<pOld->nOverflow; k++){
        ((void)0);
        b.apCell[b.nCell] = pOld->apOvfl[k];
        b.nCell++;
      }
    }
    piEnd = aData + pOld->cellOffset + 2*pOld->nCell;
    while( piCell<piEnd ){
      ((void)0);
      b.apCell[b.nCell] = aData + (maskPage & __builtin_bswap16(*(u16*)(piCell)));
      piCell += 2;
      b.nCell++;
    }
    ((void)0);

    cntOld[i] = b.nCell;
    if( i<nOld-1 && !leafData){
      u16 sz = (u16)szNew[i];
      u8 *pTemp;
      ((void)0);
      b.szCell[b.nCell] = sz;
      pTemp = &aSpace1[iSpace1];
      iSpace1 += sz;
      ((void)0);
      ((void)0);
      memcpy(pTemp, apDiv[i], sz);
      b.apCell[b.nCell] = pTemp+leafCorrection;
      ((void)0);
      b.szCell[b.nCell] = b.szCell[b.nCell] - leafCorrection;
      if( !pOld->leaf ){
        ((void)0);
        ((void)0);


        memcpy(b.apCell[b.nCell], &pOld->aData[8], 4);
      }else{
        ((void)0);
        while( b.szCell[b.nCell]<4 ){


          ((void)0);
          ((void)0);
          aSpace1[iSpace1++] = 0x00;
          b.szCell[b.nCell]++;
        }
      }
      b.nCell++;
    }
  }
# 71156 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  usableSpace = pBt->usableSize - 12 + leafCorrection;
  for(i=k=0; i<nOld; i++, k++){
    MemPage *p = apOld[i];
    b.apEnd[k] = p->aDataEnd;
    b.ixNx[k] = cntOld[i];
    if( k && b.ixNx[k]==b.ixNx[k-1] ){
      k--;
    }
    if( !leafData ){
      k++;
      b.apEnd[k] = pParent->aDataEnd;
      b.ixNx[k] = cntOld[i]+1;
    }
    ((void)0);
    szNew[i] = usableSpace - p->nFree;
    for(j=0; j<p->nOverflow; j++){
      szNew[i] += 2 + p->xCellSize(p, p->apOvfl[j]);
    }
    cntNew[i] = cntOld[i];
  }
  k = nOld;
  for(i=0; i<k; i++){
    int sz;
    while( szNew[i]>usableSpace ){
      if( i+1>=k ){
        k = i+2;
        if( k>3 +2 ){ rc = sqlite3CorruptError(71182); goto balance_cleanup; }
        szNew[k-1] = 0;
        cntNew[k-1] = b.nCell;
      }
      sz = 2 + cachedCellSize(&b, cntNew[i]-1);
      szNew[i] -= sz;
      if( !leafData ){
        if( cntNew[i]<b.nCell ){
          sz = 2 + cachedCellSize(&b, cntNew[i]);
        }else{
          sz = 0;
        }
      }
      szNew[i+1] += sz;
      cntNew[i]--;
    }
    while( cntNew[i]<b.nCell ){
      sz = 2 + cachedCellSize(&b, cntNew[i]);
      if( szNew[i]+sz>usableSpace ) break;
      szNew[i] += sz;
      cntNew[i]++;
      if( !leafData ){
        if( cntNew[i]<b.nCell ){
          sz = 2 + cachedCellSize(&b, cntNew[i]);
        }else{
          sz = 0;
        }
      }
      szNew[i+1] -= sz;
    }
    if( cntNew[i]>=b.nCell ){
      k = i+1;
    }else if( cntNew[i] <= (i>0 ? cntNew[i-1] : 0) ){
      rc = sqlite3CorruptError(71215);
      goto balance_cleanup;
    }
  }
# 71231 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=k-1; i>0; i--){
    int szRight = szNew[i];
    int szLeft = szNew[i-1];
    int r;
    int d;

    r = cntNew[i-1] - 1;
    d = r + 1 - leafData;
    (void)cachedCellSize(&b, d);
    do{
      ((void)0);
      ((void)0);
      (void)cachedCellSize(&b, r);
      if( szRight!=0
       && (bBulk || szRight+b.szCell[d]+2 > szLeft-(b.szCell[r]+(i==k-1?0:2)))){
        break;
      }
      szRight += b.szCell[d] + 2;
      szLeft -= b.szCell[r] + 2;
      cntNew[i-1] = r;
      r--;
      d--;
    }while( r>=0 );
    szNew[i] = szRight;
    szNew[i-1] = szLeft;
    if( cntNew[i-1] <= (i>1 ? cntNew[i-2] : 0) ){
      rc = sqlite3CorruptError(71257);
      goto balance_cleanup;
    }
  }
# 71269 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
 



    ;




  pageFlags = apOld[0]->aData[0];
  for(i=0; i<k; i++){
    MemPage *pNew;
    if( i<nOld ){
      pNew = apNew[i] = apOld[i];
      apOld[i] = 0;
      rc = sqlite3PagerWrite(pNew->pDbPage);
      nNew++;
      if( rc ) goto balance_cleanup;
    }else{
      ((void)0);
      rc = allocateBtreePage(pBt, &pNew, &pgno, (bBulk ? 1 : pgno), 0);
      if( rc ) goto balance_cleanup;
      zeroPage(pNew, pageFlags);
      apNew[i] = pNew;
      nNew++;
      cntOld[i] = b.nCell;


      if( (pBt->autoVacuum) ){
        ptrmapPut(pBt, pNew->pgno, 5, pParent->pgno, &rc);
        if( rc!=0 ){
          goto balance_cleanup;
        }
      }
    }
  }
# 71319 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=0; i<nNew; i++){
    aPgOrder[i] = aPgno[i] = apNew[i]->pgno;
    aPgFlags[i] = apNew[i]->pDbPage->flags;
    for(j=0; j<i; j++){
      if( aPgno[j]==aPgno[i] ){






        ((void)0);
        rc = sqlite3CorruptError(71331);
        goto balance_cleanup;
      }
    }
  }
  for(i=0; i<nNew; i++){
    int iBest = 0;
    for(j=1; j<nNew; j++){
      if( aPgOrder[j]<aPgOrder[iBest] ) iBest = j;
    }
    pgno = aPgOrder[iBest];
    aPgOrder[iBest] = 0xffffffff;
    if( iBest!=i ){
      if( iBest>i ){
        sqlite3PagerRekey(apNew[iBest]->pDbPage, pBt->nPage+iBest+1, 0);
      }
      sqlite3PagerRekey(apNew[i]->pDbPage, pgno, aPgFlags[iBest]);
      apNew[i]->pgno = pgno;
    }
  }

 
# 71363 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ;

  ((void)0);
  ((void)0);
  ((void)0);
  sqlite3Put4byte(pRight, apNew[nNew-1]->pgno);




  if( (pageFlags & 0x08)==0 && nOld!=nNew ){
    MemPage *pOld = (nNew>nOld ? apNew : apOld)[nOld-1];
    memcpy(&apNew[nNew-1]->aData[8], &pOld->aData[8], 4);
  }
# 71394 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (pBt->autoVacuum) ){
    MemPage *pOld;
    MemPage *pNew = pOld = apNew[0];
    int cntOldNext = pNew->nCell + pNew->nOverflow;
    int iNew = 0;
    int iOld = 0;

    for(i=0; i<b.nCell; i++){
      u8 *pCell = b.apCell[i];
      while( i==cntOldNext ){
        iOld++;
        ((void)0);
        ((void)0);
        pOld = iOld<nNew ? apNew[iOld] : apOld[iOld];
        cntOldNext += pOld->nCell + pOld->nOverflow + !leafData;
      }
      if( i==cntNew[iNew] ){
        pNew = apNew[++iNew];
        if( !leafData ) continue;
      }







      if( iOld>=nNew
       || pNew->pgno!=aPgno[iOld]
       || !(((uptr)(pCell)>=(uptr)(pOld->aData))&&((uptr)(pCell)<(uptr)(pOld->aDataEnd)))
      ){
        if( !leafCorrection ){
          ptrmapPut(pBt, sqlite3Get4byte(pCell), 5, pNew->pgno, &rc);
        }
        if( cachedCellSize(&b,i)>pNew->minLocal ){
          ptrmapPutOvflPtr(pNew, pOld, pCell, &rc);
        }
        if( rc ) goto balance_cleanup;
      }
    }
  }


  for(i=0; i<nNew-1; i++){
    u8 *pCell;
    u8 *pTemp;
    int sz;
    MemPage *pNew = apNew[i];
    j = cntNew[i];

    ((void)0);
    ((void)0);
    pCell = b.apCell[j];
    sz = b.szCell[j] + leafCorrection;
    pTemp = &aOvflSpace[iOvflSpace];
    if( !pNew->leaf ){
      memcpy(&pNew->aData[8], pCell, 4);
    }else if( leafData ){





      CellInfo info;
      j--;
      pNew->xParseCell(pNew, b.apCell[j], &info);
      pCell = pTemp;
      sz = 4 + sqlite3PutVarint(&pCell[4], info.nKey);
      pTemp = 0;
    }else{
      pCell -= 4;
# 71476 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( b.szCell[j]==4 ){
        ((void)0);
        sz = pParent->xCellSize(pParent, pCell);
      }
    }
    iOvflSpace += sz;
    ((void)0);
    ((void)0);
    insertCell(pParent, nxDiv+i, pCell, sz, pTemp, pNew->pgno, &rc);
    if( rc!=0 ) goto balance_cleanup;
    ((void)0);
  }
# 71511 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=1-nNew; i<nNew; i++){
    int iPg = i<0 ? -i : i;
    ((void)0);
    if( abDone[iPg] ) continue;
    if( i>=0
     || cntOld[iPg-1]>=cntNew[iPg-1]
    ){
      int iNew;
      int iOld;
      int nNewCell;



      ((void)0);



      ((void)0);

      if( iPg==0 ){
        iNew = iOld = 0;
        nNewCell = cntNew[0];
      }else{
        iOld = iPg<nOld ? (cntOld[iPg-1] + !leafData) : b.nCell;
        iNew = cntNew[iPg-1] + !leafData;
        nNewCell = cntNew[iPg] - iNew;
      }

      rc = editPage(apNew[iPg], iOld, iNew, nNewCell, &b);
      if( rc ) goto balance_cleanup;
      abDone[iPg]++;
      apNew[iPg]->nFree = usableSpace-szNew[iPg];
      ((void)0);
      ((void)0);
    }
  }


  ((void)0);

  ((void)0);
  ((void)0);

  if( isRoot && pParent->nCell==0 && pParent->hdrOffset<=apNew[0]->nFree ){
# 71570 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    rc = defragmentPage(apNew[0], -1);
    ;
    ((void)0)



     ;
    copyNodeContent(apNew[0], pParent, &rc);
    freePage(apNew[0], &rc);
  }else if( (pBt->autoVacuum) && !leafCorrection ){



    for(i=0; i<nNew; i++){
      u32 key = sqlite3Get4byte(&apNew[i]->aData[8]);
      ptrmapPut(pBt, key, 5, apNew[i]->pgno, &rc);
    }
  }

  ((void)0);
 
                               ;



  for(i=nNew; i<nOld; i++){
    freePage(apOld[i], &rc);
  }
# 71614 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
balance_cleanup:
  sqlite3DbFree(0,b.apCell);
  for(i=0; i<nOld; i++){
    releasePage(apOld[i]);
  }
  for(i=0; i<nNew; i++){
    releasePage(apNew[i]);
  }

  return rc;
}
# 71646 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int balance_deeper(MemPage *pRoot, MemPage **ppChild){
  int rc;
  MemPage *pChild = 0;
  Pgno pgnoChild = 0;
  BtShared *pBt = pRoot->pBt;

  ((void)0);
  ((void)0);





  rc = sqlite3PagerWrite(pRoot->pDbPage);
  if( rc==0 ){
    rc = allocateBtreePage(pBt,&pChild,&pgnoChild,pRoot->pgno,0);
    copyNodeContent(pRoot, pChild, &rc);
    if( (pBt->autoVacuum) ){
      ptrmapPut(pBt, pgnoChild, 5, pRoot->pgno, &rc);
    }
  }
  if( rc ){
    *ppChild = 0;
    releasePage(pChild);
    return rc;
  }
  ((void)0);
  ((void)0);
  ((void)0);

  ;


  memcpy(pChild->aiOvfl, pRoot->aiOvfl,
         pRoot->nOverflow*sizeof(pRoot->aiOvfl[0]));
  memcpy(pChild->apOvfl, pRoot->apOvfl,
         pRoot->nOverflow*sizeof(pRoot->apOvfl[0]));
  pChild->nOverflow = pRoot->nOverflow;


  zeroPage(pRoot, pChild->aData[0] & ~0x08);
  sqlite3Put4byte(&pRoot->aData[pRoot->hdrOffset+8], pgnoChild);

  *ppChild = pChild;
  return 0;
}
# 71703 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int balance(BtCursor *pCur){
  int rc = 0;
  const int nMin = pCur->pBt->usableSize * 2 / 3;
  u8 aBalanceQuickSpace[13];
  u8 *pFree = 0;

  ;
  ;

  do {
    int iPage;
    MemPage *pPage = pCur->pPage;

    if( (pPage->nFree<0) && btreeComputeFreeSpace(pPage) ) break;
    if( pPage->nOverflow==0 && pPage->nFree<=nMin ){
      break;
    }else if( (iPage = pCur->iPage)==0 ){
      if( pPage->nOverflow ){





        ((void)0);
        ;
        rc = balance_deeper(pPage, &pCur->apPage[1]);
        if( rc==0 ){
          pCur->iPage = 1;
          pCur->ix = 0;
          pCur->aiIdx[0] = 0;
          pCur->apPage[0] = pPage;
          pCur->pPage = pCur->apPage[1];
          ((void)0);
        }
      }else{
        break;
      }
    }else{
      MemPage * const pParent = pCur->apPage[iPage-1];
      int const iIdx = pCur->aiIdx[iPage-1];

      rc = sqlite3PagerWrite(pParent->pDbPage);
      if( rc==0 && pParent->nFree<0 ){
        rc = btreeComputeFreeSpace(pParent);
      }
      if( rc==0 ){

        if( pPage->intKeyLeaf
         && pPage->nOverflow==1
         && pPage->aiOvfl[0]==pPage->nCell
         && pParent->pgno!=1
         && pParent->nCell==iIdx
        ){
# 71769 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          ((void)0);
          ;
          rc = balance_quick(pParent, pPage, aBalanceQuickSpace);
        }else

        {
# 71792 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          u8 *pSpace = sqlite3PageMalloc(pCur->pBt->pageSize);
          rc = balance_nonroot(pParent, iIdx, pSpace, iPage==1,
                               pCur->hints&0x00000001);
          if( pFree ){




            sqlite3PageFree(pFree);
          }




          pFree = pSpace;
        }
      }

      pPage->nOverflow = 0;


      releasePage(pPage);
      pCur->iPage--;
      ((void)0);
      pCur->pPage = pCur->apPage[pCur->iPage];
    }
  }while( rc==0 );

  if( pFree ){
    sqlite3PageFree(pFree);
  }
  return rc;
}




static int btreeOverwriteContent(
  MemPage *pPage,
  u8 *pDest,
  const BtreePayload *pX,
  int iOffset,
  int iAmt
){
  int nData = pX->nData - iOffset;
  if( nData<=0 ){

    int i;
    for(i=0; i<iAmt && pDest[i]==0; i++){}
    if( i<iAmt ){
      int rc = sqlite3PagerWrite(pPage->pDbPage);
      if( rc ) return rc;
      memset(pDest + i, 0, iAmt - i);
    }
  }else{
    if( nData<iAmt ){


      int rc = btreeOverwriteContent(pPage, pDest+nData, pX, iOffset+nData,
                                 iAmt-nData);
      if( rc ) return rc;
      iAmt = nData;
    }
    if( memcmp(pDest, ((u8*)pX->pData) + iOffset, iAmt)!=0 ){
      int rc = sqlite3PagerWrite(pPage->pDbPage);
      if( rc ) return rc;




      memmove(pDest, ((u8*)pX->pData) + iOffset, iAmt);
    }
  }
  return 0;
}





static int btreeOverwriteCell(BtCursor *pCur, const BtreePayload *pX){
  int iOffset;
  int nTotal = pX->nData + pX->nZero;
  int rc;
  MemPage *pPage = pCur->pPage;
  BtShared *pBt;
  Pgno ovflPgno;
  u32 ovflPageSize;

  if( pCur->info.pPayload + pCur->info.nLocal > pPage->aDataEnd
   || pCur->info.pPayload < pPage->aData + pPage->cellOffset
  ){
    return sqlite3CorruptError(71884);
  }

  rc = btreeOverwriteContent(pPage, pCur->info.pPayload, pX,
                             0, pCur->info.nLocal);
  if( rc ) return rc;
  if( pCur->info.nLocal==nTotal ) return 0;


  iOffset = pCur->info.nLocal;
  ((void)0);
  ((void)0);
  ovflPgno = sqlite3Get4byte(pCur->info.pPayload + iOffset);
  pBt = pPage->pBt;
  ovflPageSize = pBt->usableSize - 4;
  do{
    rc = btreeGetPage(pBt, ovflPgno, &pPage, 0);
    if( rc ) return rc;
    if( sqlite3PagerPageRefcount(pPage->pDbPage)!=1 ){
      rc = sqlite3CorruptError(71903);
    }else{
      if( iOffset+ovflPageSize<(u32)nTotal ){
        ovflPgno = sqlite3Get4byte(pPage->aData);
      }else{
        ovflPageSize = nTotal - iOffset;
      }
      rc = btreeOverwriteContent(pPage, pPage->aData+4, pX,
                                 iOffset, ovflPageSize);
    }
    sqlite3PagerUnref(pPage->pDbPage);
    if( rc ) return rc;
    iOffset += ovflPageSize;
  }while( iOffset<nTotal );
  return 0;
}
# 71951 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeInsert(
  BtCursor *pCur,
  const BtreePayload *pX,
  int flags,
  int seekResult
){
  int rc;
  int loc = seekResult;
  int szNew = 0;
  int idx;
  MemPage *pPage;
  Btree *p = pCur->pBtree;
  BtShared *pBt = p->pBt;
  unsigned char *oldCell;
  unsigned char *newCell = 0;

  ((void)0);

  if( pCur->eState==4 ){
    ((void)0);
    return pCur->skipNext;
  }

  ((void)0);
  ((void)0)

                                                     ;
  ((void)0);






  ((void)0);
# 71998 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pCur->curFlags & 0x20 ){
    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
    if( rc ) return rc;
  }

  if( pCur->pKeyInfo==0 ){
    ((void)0);


    invalidateIncrblobCursors(p, pCur->pgnoRoot, pX->nKey, 0);
# 72025 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (pCur->curFlags&0x02)!=0 && pX->nKey==pCur->info.nKey ){


      ((void)0);
      if( pCur->info.nSize!=0
       && pCur->info.nPayload==(u32)pX->nData+pX->nZero
      ){

        return btreeOverwriteCell(pCur, pX);
      }
      ((void)0);
    }else if( loc==0 ){




      rc = sqlite3BtreeMovetoUnpacked(pCur, 0, pX->nKey, flags!=0, &loc);
      if( rc ) return rc;
    }
  }else{





    ((void)0);






    if( loc==0 && (flags & 0x02)==0 ){
      if( pX->nMem ){
        UnpackedRecord r;
        r.pKeyInfo = pCur->pKeyInfo;
        r.aMem = pX->aMem;
        r.nField = pX->nMem;
        r.default_rc = 0;
        r.errCode = 0;
        r.r1 = 0;
        r.r2 = 0;
        r.eqSeen = 0;
        rc = sqlite3BtreeMovetoUnpacked(pCur, &r, 0, flags!=0, &loc);
      }else{
        rc = btreeMoveto(pCur, pX->pKey, pX->nKey, flags!=0, &loc);
      }
      if( rc ) return rc;
    }





    if( loc==0 ){
      getCellInfo(pCur);
      if( pCur->info.nKey==pX->nKey ){
        BtreePayload x2;
        x2.pData = pX->pKey;
        x2.nData = pX->nKey;
        x2.nZero = 0;
        return btreeOverwriteCell(pCur, &x2);
      }
    }

  }
  ((void)0);

  pPage = pCur->pPage;
  ((void)0);
  ((void)0);
  if( pPage->nFree<0 ){
    rc = btreeComputeFreeSpace(pPage);
    if( rc ) return rc;
  }

 

                                              ;
  ((void)0);
  newCell = pBt->pTmpSpace;
  ((void)0);
  rc = fillInCell(pPage, newCell, pX, &szNew);
  if( rc ) goto end_insert;
  ((void)0);
  ((void)0);
  idx = pCur->ix;
  if( loc==0 ){
    CellInfo info;
    ((void)0);
    rc = sqlite3PagerWrite(pPage->pDbPage);
    if( rc ){
      goto end_insert;
    }
    oldCell = ((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(idx)]))));
    if( !pPage->leaf ){
      memcpy(newCell, oldCell, 4);
    }
    rc = clearCell(pPage, oldCell, &info);
    ;
    (pCur->curFlags &= ~0x04);
    if( info.nSize==szNew && info.nLocal==info.nPayload
     && (!(pBt->autoVacuum) || szNew<pPage->minLocal)
    ){
# 72138 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      ((void)0);
      if( oldCell < pPage->aData+pPage->hdrOffset+10 ){
        return sqlite3CorruptError(72140);
      }
      if( oldCell+szNew > pPage->aDataEnd ){
        return sqlite3CorruptError(72143);
      }
      memcpy(oldCell, newCell, szNew);
      return 0;
    }
    dropCell(pPage, idx, info.nSize, &rc);
    if( rc ) goto end_insert;
  }else if( loc<0 && pPage->nCell>0 ){
    ((void)0);
    idx = ++pCur->ix;
    pCur->curFlags &= ~0x02;
  }else{
    ((void)0);
  }
  insertCell(pPage, idx, newCell, szNew, 0, 0, &rc);
  ((void)0);
  ((void)0);
# 72181 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pCur->info.nSize = 0;
  if( pPage->nOverflow ){
    ((void)0);
    pCur->curFlags &= ~(0x02);
    rc = balance(pCur);





    pCur->pPage->nOverflow = 0;
    pCur->eState = 1;
    if( (flags & 0x02) && rc==0 ){
      btreeReleaseAllCursorPages(pCur);
      if( pCur->pKeyInfo ){
        ((void)0);
        pCur->pKey = sqlite3Malloc( pX->nKey );
        if( pCur->pKey==0 ){
          rc = 7;
        }else{
          memcpy(pCur->pKey, pX->pKey, pX->nKey);
        }
      }
      pCur->eState = 3;
      pCur->nKey = pX->nKey;
    }
  }
  ((void)0);

end_insert:
  return rc;
}
# 72231 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeDelete(BtCursor *pCur, u8 flags){
  Btree *p = pCur->pBtree;
  BtShared *pBt = p->pBt;
  int rc;
  MemPage *pPage;
  unsigned char *pCell;
  int iCellIdx;
  int iCellDepth;
  CellInfo info;
  int bSkipnext = 0;
  u8 bPreserve = flags & 0x02;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( pCur->eState==3 ){
    rc = btreeRestoreCursorPosition(pCur);
    if( rc ) return rc;
  }
  ((void)0);

  iCellDepth = pCur->iPage;
  iCellIdx = pCur->ix;
  pPage = pCur->pPage;
  pCell = ((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(iCellIdx)]))));
  if( pPage->nFree<0 && btreeComputeFreeSpace(pPage) ) return 11;
# 72271 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( bPreserve ){
    if( !pPage->leaf
     || (pPage->nFree+cellSizePtr(pPage,pCell)+2)>(int)(pBt->usableSize*2/3)
     || pPage->nCell==1
    ){


      rc = saveCursorKey(pCur);
      if( rc ) return rc;
    }else{
      bSkipnext = 1;
    }
  }
# 72292 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( !pPage->leaf ){
    rc = sqlite3BtreePrevious(pCur, 0);
    ((void)0);
    if( rc ) return rc;
  }



  if( pCur->curFlags & 0x20 ){
    rc = saveAllCursors(pBt, pCur->pgnoRoot, pCur);
    if( rc ) return rc;
  }



  if( pCur->pKeyInfo==0 ){
    invalidateIncrblobCursors(p, pCur->pgnoRoot, pCur->info.nKey, 0);
  }




  rc = sqlite3PagerWrite(pPage->pDbPage);
  if( rc ) return rc;
  rc = clearCell(pPage, pCell, &info);
  dropCell(pPage, iCellIdx, info.nSize, &rc);
  if( rc ) return rc;






  if( !pPage->leaf ){
    MemPage *pLeaf = pCur->pPage;
    int nCell;
    Pgno n;
    unsigned char *pTmp;

    if( pLeaf->nFree<0 ){
      rc = btreeComputeFreeSpace(pLeaf);
      if( rc ) return rc;
    }
    if( iCellDepth<pCur->iPage-1 ){
      n = pCur->apPage[iCellDepth+1]->pgno;
    }else{
      n = pCur->pPage->pgno;
    }
    pCell = ((pLeaf)->aData + ((pLeaf)->maskPage & __builtin_bswap16(*(u16*)(&(pLeaf)->aCellIdx[2*(pLeaf->nCell-1)]))));
    if( pCell<&pLeaf->aData[4] ) return sqlite3CorruptError(72341);
    nCell = pLeaf->xCellSize(pLeaf, pCell);
    ((void)0);
    pTmp = pBt->pTmpSpace;
    ((void)0);
    rc = sqlite3PagerWrite(pLeaf->pDbPage);
    if( rc==0 ){
      insertCell(pPage, iCellIdx, pCell-4, nCell+4, pTmp, n, &rc);
    }
    dropCell(pLeaf, pLeaf->nCell-1, nCell, &rc);
    if( rc ) return rc;
  }
# 72369 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  rc = balance(pCur);
  if( rc==0 && pCur->iPage>iCellDepth ){
    releasePageNotNull(pCur->pPage);
    pCur->iPage--;
    while( pCur->iPage>iCellDepth ){
      releasePage(pCur->apPage[pCur->iPage--]);
    }
    pCur->pPage = pCur->apPage[pCur->iPage];
    rc = balance(pCur);
  }

  if( rc==0 ){
    if( bSkipnext ){
      ((void)0);
      ((void)0);
      ((void)0);
      pCur->eState = 2;
      if( iCellIdx>=pPage->nCell ){
        pCur->skipNext = -1;
        pCur->ix = pPage->nCell-1;
      }else{
        pCur->skipNext = 1;
      }
    }else{
      rc = moveToRoot(pCur);
      if( bPreserve ){
        btreeReleaseAllCursorPages(pCur);
        pCur->eState = 3;
      }
      if( rc==16 ) rc = 0;
    }
  }
  return rc;
}
# 72415 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeCreateTable(Btree *p, int *piTable, int createTabFlags){
  BtShared *pBt = p->pBt;
  MemPage *pRoot;
  Pgno pgnoRoot;
  int rc;
  int ptfFlags;

  ((void)0);
  ((void)0);
  ((void)0);







  if( pBt->autoVacuum ){
    Pgno pgnoMove;
    MemPage *pPageMove;






    invalidateAllOverflowCache(pBt);





    sqlite3BtreeGetMeta(p, 4, &pgnoRoot);
    pgnoRoot++;




    while( pgnoRoot==ptrmapPageno(pBt, pgnoRoot) ||
        pgnoRoot==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1)) ){
      pgnoRoot++;
    }
    ((void)0);
    ;





    rc = allocateBtreePage(pBt, &pPageMove, &pgnoMove, pgnoRoot, 1);
    if( rc!=0 ){
      return rc;
    }

    if( pgnoMove!=pgnoRoot ){






      u8 eType = 0;
      Pgno iPtrPage = 0;




      rc = saveAllCursors(pBt, 0, 0);
      releasePage(pPageMove);
      if( rc!=0 ){
        return rc;
      }


      rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = ptrmapGet(pBt, pgnoRoot, &eType, &iPtrPage);
      if( eType==1 || eType==2 ){
        rc = sqlite3CorruptError(72495);
      }
      if( rc!=0 ){
        releasePage(pRoot);
        return rc;
      }
      ((void)0);
      ((void)0);
      rc = relocatePage(pBt, pRoot, eType, iPtrPage, pgnoMove, 0);
      releasePage(pRoot);


      if( rc!=0 ){
        return rc;
      }
      rc = btreeGetPage(pBt, pgnoRoot, &pRoot, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = sqlite3PagerWrite(pRoot->pDbPage);
      if( rc!=0 ){
        releasePage(pRoot);
        return rc;
      }
    }else{
      pRoot = pPageMove;
    }


    ptrmapPut(pBt, pgnoRoot, 1, 0, &rc);
    if( rc ){
      releasePage(pRoot);
      return rc;
    }





    ((void)0);
    rc = sqlite3BtreeUpdateMeta(p, 4, pgnoRoot);
    if( (rc) ){
      releasePage(pRoot);
      return rc;
    }

  }else{
    rc = allocateBtreePage(pBt, &pRoot, &pgnoRoot, 1, 0);
    if( rc ) return rc;
  }

  ((void)0);
  if( createTabFlags & 1 ){
    ptfFlags = 0x01 | 0x04 | 0x08;
  }else{
    ptfFlags = 0x02 | 0x08;
  }
  zeroPage(pRoot, ptfFlags);
  sqlite3PagerUnref(pRoot->pDbPage);
  ((void)0);
  *piTable = (int)pgnoRoot;
  return 0;
}
static int sqlite3BtreeCreateTable(Btree *p, int *piTable, int flags){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeCreateTable(p, piTable, flags);
  sqlite3BtreeLeave(p);
  return rc;
}





static int clearDatabasePage(
  BtShared *pBt,
  Pgno pgno,
  int freePageFlag,
  int *pnChange
){
  MemPage *pPage;
  int rc;
  unsigned char *pCell;
  int i;
  int hdr;
  CellInfo info;

  ((void)0);
  if( pgno>btreePagecount(pBt) ){
    return sqlite3CorruptError(72585);
  }
  rc = getAndInitPage(pBt, pgno, &pPage, 0, 0);
  if( rc ) return rc;
  if( pPage->bBusy ){
    rc = sqlite3CorruptError(72590);
    goto cleardatabasepage_out;
  }
  pPage->bBusy = 1;
  hdr = pPage->hdrOffset;
  for(i=0; i<pPage->nCell; i++){
    pCell = ((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(i)]))));
    if( !pPage->leaf ){
      rc = clearDatabasePage(pBt, sqlite3Get4byte(pCell), 1, pnChange);
      if( rc ) goto cleardatabasepage_out;
    }
    rc = clearCell(pPage, pCell, &info);
    if( rc ) goto cleardatabasepage_out;
  }
  if( !pPage->leaf ){
    rc = clearDatabasePage(pBt, sqlite3Get4byte(&pPage->aData[hdr+8]), 1, pnChange);
    if( rc ) goto cleardatabasepage_out;
  }else if( pnChange ){
    ((void)0);
    ;
    *pnChange += pPage->nCell;
  }
  if( freePageFlag ){
    freePage(pPage, &rc);
  }else if( (rc = sqlite3PagerWrite(pPage->pDbPage))==0 ){
    zeroPage(pPage, pPage->aData[hdr] | 0x08);
  }

cleardatabasepage_out:
  pPage->bBusy = 0;
  releasePage(pPage);
  return rc;
}
# 72637 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeClearTable(Btree *p, int iTable, int *pnChange){
  int rc;
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  ((void)0);

  rc = saveAllCursors(pBt, (Pgno)iTable, 0);

  if( 0==rc ){



    invalidateIncrblobCursors(p, (Pgno)iTable, 0, 1);
    rc = clearDatabasePage(pBt, (Pgno)iTable, 0, pnChange);
  }
  sqlite3BtreeLeave(p);
  return rc;
}






static int sqlite3BtreeClearTableOfCursor(BtCursor *pCur){
  return sqlite3BtreeClearTable(pCur->pBtree, pCur->pgnoRoot, 0);
}
# 72685 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int btreeDropTable(Btree *p, Pgno iTable, int *piMoved){
  int rc;
  MemPage *pPage = 0;
  BtShared *pBt = p->pBt;

  ((void)0);
  ((void)0);
  ((void)0);
  if( iTable>btreePagecount(pBt) ){
    return sqlite3CorruptError(72694);
  }

  rc = btreeGetPage(pBt, (Pgno)iTable, &pPage, 0);
  if( rc ) return rc;
  rc = sqlite3BtreeClearTable(p, iTable, 0);
  if( rc ){
    releasePage(pPage);
    return rc;
  }

  *piMoved = 0;





  if( pBt->autoVacuum ){
    Pgno maxRootPgno;
    sqlite3BtreeGetMeta(p, 4, &maxRootPgno);

    if( iTable==maxRootPgno ){



      freePage(pPage, &rc);
      releasePage(pPage);
      if( rc!=0 ){
        return rc;
      }
    }else{




      MemPage *pMove;
      releasePage(pPage);
      rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
      if( rc!=0 ){
        return rc;
      }
      rc = relocatePage(pBt, pMove, 1, 0, iTable, 0);
      releasePage(pMove);
      if( rc!=0 ){
        return rc;
      }
      pMove = 0;
      rc = btreeGetPage(pBt, maxRootPgno, &pMove, 0);
      freePage(pMove, &rc);
      releasePage(pMove);
      if( rc!=0 ){
        return rc;
      }
      *piMoved = maxRootPgno;
    }






    maxRootPgno--;
    while( maxRootPgno==((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1))
           || (ptrmapPageno((pBt), (maxRootPgno))==(maxRootPgno)) ){
      maxRootPgno--;
    }
    ((void)0);

    rc = sqlite3BtreeUpdateMeta(p, 4, maxRootPgno);
  }else{
    freePage(pPage, &rc);
    releasePage(pPage);
  }

  return rc;
}
static int sqlite3BtreeDropTable(Btree *p, int iTable, int *piMoved){
  int rc;
  sqlite3BtreeEnter(p);
  rc = btreeDropTable(p, iTable, piMoved);
  sqlite3BtreeLeave(p);
  return rc;
}
# 72799 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BtreeGetMeta(Btree *p, int idx, u32 *pMeta){
  BtShared *pBt = p->pBt;

  sqlite3BtreeEnter(p);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( idx==15 ){
    *pMeta = sqlite3PagerDataVersion(pBt->pPager) + p->iDataVersion;
  }else{
    *pMeta = sqlite3Get4byte(&pBt->pPage1->aData[36 + idx*4]);
  }
# 72822 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3BtreeLeave(p);
}





static int sqlite3BtreeUpdateMeta(Btree *p, int idx, u32 iMeta){
  BtShared *pBt = p->pBt;
  unsigned char *pP1;
  int rc;
  ((void)0);
  sqlite3BtreeEnter(p);
  ((void)0);
  ((void)0);
  pP1 = pBt->pPage1->aData;
  rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
  if( rc==0 ){
    sqlite3Put4byte(&pP1[36 + idx*4], iMeta);

    if( idx==7 ){
      ((void)0);
      ((void)0);
      pBt->incrVacuum = (u8)iMeta;
    }

  }
  sqlite3BtreeLeave(p);
  return rc;
}
# 72862 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCount(BtCursor *pCur, i64 *pnEntry){
  i64 nEntry = 0;
  int rc;

  rc = moveToRoot(pCur);
  if( rc==16 ){
    *pnEntry = 0;
    return 0;
  }




  while( rc==0 ){
    int iIdx;
    MemPage *pPage;





    pPage = pCur->pPage;
    if( pPage->leaf || !pPage->intKey ){
      nEntry += pPage->nCell;
    }
# 72898 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pPage->leaf ){
      do {
        if( pCur->iPage==0 ){

          *pnEntry = nEntry;
          return moveToRoot(pCur);
        }
        moveToParent(pCur);
      }while ( pCur->ix>=pCur->pPage->nCell );

      pCur->ix++;
      pPage = pCur->pPage;
    }




    iIdx = pCur->ix;
    if( iIdx==pPage->nCell ){
      rc = moveToChild(pCur, sqlite3Get4byte(&pPage->aData[pPage->hdrOffset+8]));
    }else{
      rc = moveToChild(pCur, sqlite3Get4byte(((pPage)->aData + ((pPage)->maskPage & __builtin_bswap16(*(u16*)(&(pPage)->aCellIdx[2*(iIdx)]))))));
    }
  }


  return rc;
}






static Pager *sqlite3BtreePager(Btree *p){
  return p->pBt->pPager;
}





static void checkAppendMsg(
  IntegrityCk *pCheck,
  const char *zFormat,
  ...
){
  va_list ap;
  if( !pCheck->mxErr ) return;
  pCheck->mxErr--;
  pCheck->nErr++;
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  if( pCheck->errMsg.nChar ){
    sqlite3_str_append(&pCheck->errMsg, "\n", 1);
  }
  if( pCheck->zPfx ){
    sqlite3_str_appendf(&pCheck->errMsg, pCheck->zPfx, pCheck->v1, pCheck->v2);
  }
  sqlite3_str_vappendf(&pCheck->errMsg, zFormat, ap);
  ( ap = (va_list)0 );
  if( pCheck->errMsg.accError==7 ){
    pCheck->mallocFailed = 1;
  }
}
# 72970 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getPageReferenced(IntegrityCk *pCheck, Pgno iPg){
  ((void)0);
  return (pCheck->aPgRef[iPg/8] & (1 << (iPg & 0x07)));
}




static void setPageReferenced(IntegrityCk *pCheck, Pgno iPg){
  ((void)0);
  pCheck->aPgRef[iPg/8] |= (1 << (iPg & 0x07));
}
# 72992 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int checkRef(IntegrityCk *pCheck, Pgno iPage){
  if( iPage>pCheck->nPage || iPage==0 ){
    checkAppendMsg(pCheck, "invalid page number %d", iPage);
    return 1;
  }
  if( getPageReferenced(pCheck, iPage) ){
    checkAppendMsg(pCheck, "2nd reference to page %d", iPage);
    return 1;
  }
  setPageReferenced(pCheck, iPage);
  return 0;
}







static void checkPtrmap(
  IntegrityCk *pCheck,
  Pgno iChild,
  u8 eType,
  Pgno iParent
){
  int rc;
  u8 ePtrmapType;
  Pgno iPtrmapParent;

  rc = ptrmapGet(pCheck->pBt, iChild, &ePtrmapType, &iPtrmapParent);
  if( rc!=0 ){
    if( rc==7 || rc==(10 | (12<<8)) ) pCheck->mallocFailed = 1;
    checkAppendMsg(pCheck, "Failed to read ptrmap key=%d", iChild);
    return;
  }

  if( ePtrmapType!=eType || iPtrmapParent!=iParent ){
    checkAppendMsg(pCheck,
      "Bad ptr map entry key=%d expected=(%d,%d) got=(%d,%d)",
      iChild, eType, iParent, ePtrmapType, iPtrmapParent);
  }
}






static void checkList(
  IntegrityCk *pCheck,
  int isFreeList,
  int iPage,
  u32 N
){
  int i;
  u32 expected = N;
  int nErrAtStart = pCheck->nErr;
  while( iPage!=0 && pCheck->mxErr ){
    DbPage *pOvflPage;
    unsigned char *pOvflData;
    if( checkRef(pCheck, iPage) ) break;
    N--;
    if( sqlite3PagerGet(pCheck->pPager, (Pgno)iPage, &pOvflPage, 0) ){
      checkAppendMsg(pCheck, "failed to get page %d", iPage);
      break;
    }
    pOvflData = (unsigned char *)sqlite3PagerGetData(pOvflPage);
    if( isFreeList ){
      u32 n = (u32)sqlite3Get4byte(&pOvflData[4]);

      if( pCheck->pBt->autoVacuum ){
        checkPtrmap(pCheck, iPage, 2, 0);
      }

      if( n>pCheck->pBt->usableSize/4-2 ){
        checkAppendMsg(pCheck,
           "freelist leaf count too big on page %d", iPage);
        N--;
      }else{
        for(i=0; i<(int)n; i++){
          Pgno iFreePage = sqlite3Get4byte(&pOvflData[8+i*4]);

          if( pCheck->pBt->autoVacuum ){
            checkPtrmap(pCheck, iFreePage, 2, 0);
          }

          checkRef(pCheck, iFreePage);
        }
        N -= n;
      }
    }

    else{




      if( pCheck->pBt->autoVacuum && N>0 ){
        i = sqlite3Get4byte(pOvflData);
        checkPtrmap(pCheck, i, 4, iPage);
      }
    }

    iPage = sqlite3Get4byte(pOvflData);
    sqlite3PagerUnref(pOvflPage);
  }
  if( N && nErrAtStart==pCheck->nErr ){
    checkAppendMsg(pCheck,
      "%s is %d but should be %d",
      isFreeList ? "size" : "overflow list length",
      expected-N, expected);
  }
}
# 73129 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void btreeHeapInsert(u32 *aHeap, u32 x){
  u32 j, i = ++aHeap[0];
  aHeap[i] = x;
  while( (j = i/2)>0 && aHeap[j]>aHeap[i] ){
    x = aHeap[j];
    aHeap[j] = aHeap[i];
    aHeap[i] = x;
    i = j;
  }
}
static int btreeHeapPull(u32 *aHeap, u32 *pOut){
  u32 j, i, x;
  if( (x = aHeap[0])==0 ) return 0;
  *pOut = aHeap[1];
  aHeap[1] = aHeap[x];
  aHeap[x] = 0xffffffff;
  aHeap[0]--;
  i = 1;
  while( (j = i*2)<=aHeap[0] ){
    if( aHeap[j]>aHeap[j+1] ) j++;
    if( aHeap[i]<aHeap[j] ) break;
    x = aHeap[i];
    aHeap[i] = aHeap[j];
    aHeap[j] = x;
    i = j;
  }
  return 1;
}
# 73173 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int checkTreePage(
  IntegrityCk *pCheck,
  int iPage,
  i64 *piMinKey,
  i64 maxKey
){
  MemPage *pPage = 0;
  int i;
  int rc;
  int depth = -1, d2;
  int pgno;
  int nFrag;
  int hdr;
  int cellStart;
  int nCell;
  int doCoverageCheck = 1;
  int keyCanBeEqual = 1;

  u8 *data;
  u8 *pCell;
  u8 *pCellIdx;
  BtShared *pBt;
  u32 pc;
  u32 usableSize;
  u32 contentOffset;
  u32 *heap = 0;
  u32 x, prev = 0;
  const char *saved_zPfx = pCheck->zPfx;
  int saved_v1 = pCheck->v1;
  int saved_v2 = pCheck->v2;
  u8 savedIsInit = 0;



  pBt = pCheck->pBt;
  usableSize = pBt->usableSize;
  if( iPage==0 ) return 0;
  if( checkRef(pCheck, iPage) ) return 0;
  pCheck->zPfx = "Page %d: ";
  pCheck->v1 = iPage;
  if( (rc = btreeGetPage(pBt, (Pgno)iPage, &pPage, 0))!=0 ){
    checkAppendMsg(pCheck,
       "unable to get the page. error code=%d", rc);
    goto end_of_check;
  }



  savedIsInit = pPage->isInit;
  pPage->isInit = 0;
  if( (rc = btreeInitPage(pPage))!=0 ){
    ((void)0);
    checkAppendMsg(pCheck,
                   "btreeInitPage() returns error code %d", rc);
    goto end_of_check;
  }
  if( (rc = btreeComputeFreeSpace(pPage))!=0 ){
    ((void)0);
    checkAppendMsg(pCheck, "free space corruption", rc);
    goto end_of_check;
  }
  data = pPage->aData;
  hdr = pPage->hdrOffset;


  pCheck->zPfx = "On tree page %d cell %d: ";
  contentOffset = (((((int)((&data[hdr+5])[0]<<8 | (&data[hdr+5])[1]))-1)&0xffff)+1);
  ((void)0);



  nCell = ((&data[hdr+3])[0]<<8 | (&data[hdr+3])[1]);
  ((void)0);



  cellStart = hdr + 12 - 4*pPage->leaf;
  ((void)0);
  pCellIdx = &data[cellStart + 2*(nCell-1)];

  if( !pPage->leaf ){

    pgno = sqlite3Get4byte(&data[hdr+8]);

    if( pBt->autoVacuum ){
      pCheck->zPfx = "On page %d at right child: ";
      checkPtrmap(pCheck, pgno, 5, iPage);
    }

    depth = checkTreePage(pCheck, pgno, &maxKey, maxKey);
    keyCanBeEqual = 0;
  }else{


    heap = pCheck->heap;
    heap[0] = 0;
  }



  for(i=nCell-1; i>=0 && pCheck->mxErr; i--){
    CellInfo info;


    pCheck->v2 = i;
    ((void)0);
    pc = __builtin_bswap16(*(u16*)(pCellIdx));
    pCellIdx -= 2;
    if( pc<contentOffset || pc>usableSize-4 ){
      checkAppendMsg(pCheck, "Offset %d out of range %d..%d",
                             pc, contentOffset, usableSize-4);
      doCoverageCheck = 0;
      continue;
    }
    pCell = &data[pc];
    pPage->xParseCell(pPage, pCell, &info);
    if( pc+info.nSize>usableSize ){
      checkAppendMsg(pCheck, "Extends off end of page");
      doCoverageCheck = 0;
      continue;
    }


    if( pPage->intKey ){
      if( keyCanBeEqual ? (info.nKey > maxKey) : (info.nKey >= maxKey) ){
        checkAppendMsg(pCheck, "Rowid %lld out of order", info.nKey);
      }
      maxKey = info.nKey;
      keyCanBeEqual = 0;
    }


    if( info.nPayload>info.nLocal ){
      u32 nPage;
      Pgno pgnoOvfl;
      ((void)0);
      nPage = (info.nPayload - info.nLocal + usableSize - 5)/(usableSize - 4);
      pgnoOvfl = sqlite3Get4byte(&pCell[info.nSize - 4]);

      if( pBt->autoVacuum ){
        checkPtrmap(pCheck, pgnoOvfl, 3, iPage);
      }

      checkList(pCheck, 0, pgnoOvfl, nPage);
    }

    if( !pPage->leaf ){

      pgno = sqlite3Get4byte(pCell);

      if( pBt->autoVacuum ){
        checkPtrmap(pCheck, pgno, 5, iPage);
      }

      d2 = checkTreePage(pCheck, pgno, &maxKey, maxKey);
      keyCanBeEqual = 0;
      if( d2!=depth ){
        checkAppendMsg(pCheck, "Child page depth differs");
        depth = d2;
      }
    }else{

      btreeHeapInsert(heap, (pc<<16)|(pc+info.nSize-1));
    }
  }
  *piMinKey = maxKey;



  pCheck->zPfx = 0;
  if( doCoverageCheck && pCheck->mxErr>0 ){



    if( !pPage->leaf ){
      heap = pCheck->heap;
      heap[0] = 0;
      for(i=nCell-1; i>=0; i--){
        u32 size;
        pc = __builtin_bswap16(*(u16*)(&data[cellStart+i*2]));
        size = pPage->xCellSize(pPage, &data[pc]);
        btreeHeapInsert(heap, (pc<<16)|(pc+size-1));
      }
    }






    i = ((&data[hdr+1])[0]<<8 | (&data[hdr+1])[1]);
    while( i>0 ){
      int size, j;
      ((void)0);
      size = ((&data[i+2])[0]<<8 | (&data[i+2])[1]);
      ((void)0);
      btreeHeapInsert(heap, (((u32)i)<<16)|(i+size-1));




      j = ((&data[i])[0]<<8 | (&data[i])[1]);


      ((void)0);
      ((void)0);
      i = j;
    }
# 73394 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    nFrag = 0;
    prev = contentOffset - 1;
    while( btreeHeapPull(heap,&x) ){
      if( (prev&0xffff)>=(x>>16) ){
        checkAppendMsg(pCheck,
          "Multiple uses for byte %u of page %d", x>>16, iPage);
        break;
      }else{
        nFrag += (x>>16) - (prev&0xffff) - 1;
        prev = x;
      }
    }
    nFrag += usableSize - (prev&0xffff) - 1;





    if( heap[0]==0 && nFrag!=data[hdr+7] ){
      checkAppendMsg(pCheck,
          "Fragmentation of %d bytes reported as %d on page %d",
          nFrag, data[hdr+7], iPage);
    }
  }

end_of_check:
  if( !doCoverageCheck ) pPage->isInit = savedIsInit;
  releasePage(pPage);
  pCheck->zPfx = saved_zPfx;
  pCheck->v1 = saved_v1;
  pCheck->v2 = saved_v2;
  return depth+1;
}
# 73443 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *sqlite3BtreeIntegrityCheck(
  Btree *p,
  int *aRoot,
  int nRoot,
  int mxErr,
  int *pnErr
){
  Pgno i;
  IntegrityCk sCheck;
  BtShared *pBt = p->pBt;
  u64 savedDbFlags = pBt->db->flags;
  char zErr[100];
  ;

  sqlite3BtreeEnter(p);
  ((void)0);
  ;
  ((void)0);
  sCheck.pBt = pBt;
  sCheck.pPager = pBt->pPager;
  sCheck.nPage = btreePagecount(sCheck.pBt);
  sCheck.mxErr = mxErr;
  sCheck.nErr = 0;
  sCheck.mallocFailed = 0;
  sCheck.zPfx = 0;
  sCheck.v1 = 0;
  sCheck.v2 = 0;
  sCheck.aPgRef = 0;
  sCheck.heap = 0;
  sqlite3StrAccumInit(&sCheck.errMsg, 0, zErr, sizeof(zErr), 1000000000);
  sCheck.errMsg.printfFlags = 0x01;
  if( sCheck.nPage==0 ){
    goto integrity_ck_cleanup;
  }

  sCheck.aPgRef = sqlite3MallocZero((sCheck.nPage / 8)+ 1);
  if( !sCheck.aPgRef ){
    sCheck.mallocFailed = 1;
    goto integrity_ck_cleanup;
  }
  sCheck.heap = (u32*)sqlite3PageMalloc( pBt->pageSize );
  if( sCheck.heap==0 ){
    sCheck.mallocFailed = 1;
    goto integrity_ck_cleanup;
  }

  i = ((Pgno)((sqlite3PendingByte/((pBt)->pageSize))+1));
  if( i<=sCheck.nPage ) setPageReferenced(&sCheck, i);



  sCheck.zPfx = "Main freelist: ";
  checkList(&sCheck, 1, sqlite3Get4byte(&pBt->pPage1->aData[32]),
            sqlite3Get4byte(&pBt->pPage1->aData[36]));
  sCheck.zPfx = 0;




  if( pBt->autoVacuum ){
    int mx = 0;
    int mxInHdr;
    for(i=0; (int)i<nRoot; i++) if( mx<aRoot[i] ) mx = aRoot[i];
    mxInHdr = sqlite3Get4byte(&pBt->pPage1->aData[52]);
    if( mx!=mxInHdr ){
      checkAppendMsg(&sCheck,
        "max rootpage (%d) disagrees with header (%d)",
        mx, mxInHdr
      );
    }
  }else if( sqlite3Get4byte(&pBt->pPage1->aData[64])!=0 ){
    checkAppendMsg(&sCheck,
      "incremental_vacuum enabled with a max rootpage of zero"
    );
  }

  ;
  pBt->db->flags &= ~(u64)0x00200000;
  for(i=0; (int)i<nRoot && sCheck.mxErr; i++){
    i64 notUsed;
    if( aRoot[i]==0 ) continue;

    if( pBt->autoVacuum && aRoot[i]>1 ){
      checkPtrmap(&sCheck, aRoot[i], 1, 0);
    }

    checkTreePage(&sCheck, aRoot[i], &notUsed, (0xffffffff|(((i64)0x7fffffff)<<32)));
  }
  pBt->db->flags = savedDbFlags;



  for(i=1; i<=sCheck.nPage && sCheck.mxErr; i++){
# 73544 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( getPageReferenced(&sCheck, i)==0 &&
       (ptrmapPageno(pBt, i)!=i || !pBt->autoVacuum) ){
      checkAppendMsg(&sCheck, "Page %d is never used", i);
    }
    if( getPageReferenced(&sCheck, i)!=0 &&
       (ptrmapPageno(pBt, i)==i && pBt->autoVacuum) ){
      checkAppendMsg(&sCheck, "Pointer map page %d is referenced", i);
    }

  }



integrity_ck_cleanup:
  sqlite3PageFree(sCheck.heap);
  sqlite3_free(sCheck.aPgRef);
  if( sCheck.mallocFailed ){
    sqlite3_str_reset(&sCheck.errMsg);
    sCheck.nErr++;
  }
  *pnErr = sCheck.nErr;
  if( sCheck.nErr==0 ) sqlite3_str_reset(&sCheck.errMsg);

  ((void)0);
  sqlite3BtreeLeave(p);
  return sqlite3StrAccumFinish(&sCheck.errMsg);
}
# 73580 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *sqlite3BtreeGetFilename(Btree *p){
  ((void)0);
  return sqlite3PagerFilename(p->pBt->pPager, 1);
}
# 73593 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *sqlite3BtreeGetJournalname(Btree *p){
  ((void)0);
  return sqlite3PagerJournalname(p->pBt->pPager);
}




static int sqlite3BtreeIsInTrans(Btree *p){
  ((void)0);
  return (p && (p->inTrans==2));
}
# 73615 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCheckpoint(Btree *p, int eMode, int *pnLog, int *pnCkpt){
  int rc = 0;
  if( p ){
    BtShared *pBt = p->pBt;
    sqlite3BtreeEnter(p);
    if( pBt->inTransaction!=0 ){
      rc = 6;
    }else{
      rc = sqlite3PagerCheckpoint(pBt->pPager, p->db, eMode, pnLog, pnCkpt);
    }
    sqlite3BtreeLeave(p);
  }
  return rc;
}





static int sqlite3BtreeIsInReadTrans(Btree *p){
  ((void)0);
  ((void)0);
  return p->inTrans!=0;
}

static int sqlite3BtreeIsInBackup(Btree *p){
  ((void)0);
  ((void)0);
  return p->nBackup!=0;
}
# 73666 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3BtreeSchema(Btree *p, int nBytes, void(*xFree)(void *)){
  BtShared *pBt = p->pBt;
  sqlite3BtreeEnter(p);
  if( !pBt->pSchema && nBytes ){
    pBt->pSchema = sqlite3DbMallocZero(0, nBytes);
    pBt->xFreeSchema = xFree;
  }
  sqlite3BtreeLeave(p);
  return pBt->pSchema;
}






static int sqlite3BtreeSchemaLocked(Btree *p){
  int rc;
  ((void)0);
  sqlite3BtreeEnter(p);
  rc = querySharedCacheTableLock(p, 1, 1);
  ((void)0);
  sqlite3BtreeLeave(p);
  return rc;
}
# 73699 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeLockTable(Btree *p, int iTab, u8 isWriteLock){
  int rc = 0;
  ((void)0);
  if( p->sharable ){
    u8 lockType = 1 + isWriteLock;
    ((void)0);
    ((void)0);

    sqlite3BtreeEnter(p);
    rc = querySharedCacheTableLock(p, iTab, lockType);
    if( rc==0 ){
      rc = setSharedCacheTableLock(p, iTab, lockType);
    }
    sqlite3BtreeLeave(p);
  }
  return rc;
}
# 73729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreePutData(BtCursor *pCsr, u32 offset, u32 amt, void *z){
  int rc;
  ((void)0);
  ((void)0);
  ((void)0);

  rc = (pCsr->eState>=3 ? btreeRestoreCursorPosition(pCsr) : 0);
  if( rc!=0 ){
    return rc;
  }
  ((void)0);
  if( pCsr->eState!=0 ){
    return 4;
  }
# 73752 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  saveAllCursors(pCsr->pBt, pCsr->pgnoRoot, pCsr);
  ((void)0);
# 73762 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (pCsr->curFlags & 0x01)==0 ){
    return 8;
  }
  ((void)0)
                                                        ;
  ((void)0);
  ((void)0);
  ((void)0);

  return accessPayload(pCsr, offset, amt, (unsigned char *)z, 1);
}




static void sqlite3BtreeIncrblobCursor(BtCursor *pCur){
  pCur->curFlags |= 0x10;
  pCur->pBtree->hasIncrblobCur = 1;
}







static int sqlite3BtreeSetVersion(Btree *pBtree, int iVersion){
  BtShared *pBt = pBtree->pBt;
  int rc;

  ((void)0);




  pBt->btsFlags &= ~0x0020;
  if( iVersion==1 ) pBt->btsFlags |= 0x0020;

  rc = sqlite3BtreeBeginTrans(pBtree, 0, 0);
  if( rc==0 ){
    u8 *aData = pBt->pPage1->aData;
    if( aData[18]!=(u8)iVersion || aData[19]!=(u8)iVersion ){
      rc = sqlite3BtreeBeginTrans(pBtree, 2, 0);
      if( rc==0 ){
        rc = sqlite3PagerWrite(pBt->pPage1->pDbPage);
        if( rc==0 ){
          aData[18] = (u8)iVersion;
          aData[19] = (u8)iVersion;
        }
      }
    }
  }

  pBt->btsFlags &= ~0x0020;
  return rc;
}





static int sqlite3BtreeCursorHasHint(BtCursor *pCsr, unsigned int mask){
  return (pCsr->hints & mask)!=0;
}




static int sqlite3BtreeIsReadonly(Btree *p){
  return (p->pBt->btsFlags & 0x0001)!=0;
}




static int sqlite3HeaderSizeBtree(void){ return (((sizeof(MemPage))+7)&~7); }





static int sqlite3BtreeSharable(Btree *p){
  return p->sharable;
}






static int sqlite3BtreeConnectionCount(Btree *p){
  ;
  return p->pBt->nRef;
}
# 73880 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_backup {
  sqlite3* pDestDb;
  Btree *pDest;
  u32 iDestSchema;
  int bDestLocked;

  Pgno iNext;
  sqlite3* pSrcDb;
  Btree *pSrc;

  int rc;




  Pgno nRemaining;
  Pgno nPagecount;

  int isAttached;
  sqlite3_backup *pNext;
};
# 73941 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){
  int i = sqlite3FindDbName(pDb, zDb);

  if( i==1 ){
    Parse sParse;
    int rc = 0;
    memset(&sParse, 0, sizeof(sParse));
    sParse.db = pDb;
    if( sqlite3OpenTempDatabase(&sParse) ){
      sqlite3ErrorWithMsg(pErrorDb, sParse.rc, "%s", sParse.zErrMsg);
      rc = 1;
    }
    sqlite3DbFree(pErrorDb, sParse.zErrMsg);
    sqlite3ParserReset(&sParse);
    if( rc ){
      return 0;
    }
  }

  if( i<0 ){
    sqlite3ErrorWithMsg(pErrorDb, 1, "unknown database %s", zDb);
    return 0;
  }

  return pDb->aDb[i].pBt;
}





static int setDestPgsz(sqlite3_backup *p){
  int rc;
  rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),-1,0);
  return rc;
}







static int checkReadTransaction(sqlite3 *db, Btree *p){
  if( sqlite3BtreeIsInReadTrans(p) ){
    sqlite3ErrorWithMsg(db, 1, "destination database is in use");
    return 1;
  }
  return 0;
}
# 74000 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3_backup *sqlite3_backup_init(
  sqlite3* pDestDb,
  const char *zDestDb,
  sqlite3* pSrcDb,
  const char *zSrcDb
){
  sqlite3_backup *p;
# 74023 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_mutex_enter(pSrcDb->mutex);
  sqlite3_mutex_enter(pDestDb->mutex);

  if( pSrcDb==pDestDb ){
    sqlite3ErrorWithMsg(
        pDestDb, 1, "source and destination must be distinct"
    );
    p = 0;
  }else {




    p = (sqlite3_backup *)sqlite3MallocZero(sizeof(sqlite3_backup));
    if( !p ){
      sqlite3Error(pDestDb, 7);
    }
  }


  if( p ){
    p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);
    p->pDest = findBtree(pDestDb, pDestDb, zDestDb);
    p->pDestDb = pDestDb;
    p->pSrcDb = pSrcDb;
    p->iNext = 1;
    p->isAttached = 0;

    if( 0==p->pSrc || 0==p->pDest
     || checkReadTransaction(pDestDb, p->pDest)!=0
     ){





      sqlite3_free(p);
      p = 0;
    }
  }
  if( p ){
    p->pSrc->nBackup++;
  }

  sqlite3_mutex_leave(pDestDb->mutex);
  sqlite3_mutex_leave(pSrcDb->mutex);
  return p;
}






static int isFatalError(int rc){
  return (rc!=0 && rc!=5 && (rc!=6));
}






static int backupOnePage(
  sqlite3_backup *p,
  Pgno iSrcPg,
  const u8 *zSrcData,
  int bUpdate
){
  Pager * const pDestPager = sqlite3BtreePager(p->pDest);
  const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);
  int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);
  const int nCopy = ((nSrcPgsz)<(nDestPgsz)?(nSrcPgsz):(nDestPgsz));
  const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;







  int rc = 0;
  i64 iOff;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);




  if( nSrcPgsz!=nDestPgsz && sqlite3PagerIsMemdb(pDestPager) ){
    rc = 8;
  }
# 74144 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(iOff=iEnd-(i64)nSrcPgsz; rc==0 && iOff<iEnd; iOff+=nDestPgsz){
    DbPage *pDestPg = 0;
    Pgno iDest = (Pgno)(iOff/nDestPgsz)+1;
    if( iDest==((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ) continue;
    if( 0==(rc = sqlite3PagerGet(pDestPager, iDest, &pDestPg, 0))
     && 0==(rc = sqlite3PagerWrite(pDestPg))
    ){
      const u8 *zIn = &zSrcData[iOff%nSrcPgsz];
      u8 *zDestData = sqlite3PagerGetData(pDestPg);
      u8 *zOut = &zDestData[iOff%nDestPgsz];
# 74162 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      memcpy(zOut, zIn, nCopy);
      ((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;
      if( iOff==0 && bUpdate==0 ){
        sqlite3Put4byte(&zOut[28], sqlite3BtreeLastPage(p->pSrc));
      }
    }
    sqlite3PagerUnref(pDestPg);
  }

  return rc;
}
# 74182 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int backupTruncateFile(sqlite3_file *pFile, i64 iSize){
  i64 iCurrent;
  int rc = sqlite3OsFileSize(pFile, &iCurrent);
  if( rc==0 && iCurrent>iSize ){
    rc = sqlite3OsTruncate(pFile, iSize);
  }
  return rc;
}





static void attachBackupObject(sqlite3_backup *p){
  sqlite3_backup **pp;
  ((void)0);
  pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
  p->pNext = *pp;
  *pp = p;
  p->isAttached = 1;
}




 int sqlite3_backup_step(sqlite3_backup *p, int nPage){
  int rc;
  int destMode;
  int pgszSrc = 0;
  int pgszDest = 0;




  sqlite3_mutex_enter(p->pSrcDb->mutex);
  sqlite3BtreeEnter(p->pSrc);
  if( p->pDestDb ){
    sqlite3_mutex_enter(p->pDestDb->mutex);
  }

  rc = p->rc;
  if( !isFatalError(rc) ){
    Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);
    Pager * const pDestPager = sqlite3BtreePager(p->pDest);
    int ii;
    int nSrcPage = -1;
    int bCloseTrans = 0;




    if( p->pDestDb && p->pSrc->pBt->inTransaction==2 ){
      rc = 5;
    }else{
      rc = 0;
    }





    if( rc==0 && 0==sqlite3BtreeIsInReadTrans(p->pSrc) ){
      rc = sqlite3BtreeBeginTrans(p->pSrc, 0, 0);
      bCloseTrans = 1;
    }







    if( p->bDestLocked==0 && rc==0 && setDestPgsz(p)==7 ){
      rc = 7;
    }


    if( 0==rc && p->bDestLocked==0
     && 0==(rc = sqlite3BtreeBeginTrans(p->pDest, 2,
                                                (int*)&p->iDestSchema))
    ){
      p->bDestLocked = 1;
    }



    pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);
    pgszDest = sqlite3BtreeGetPageSize(p->pDest);
    destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));
    if( 0==rc && destMode==5 && pgszSrc!=pgszDest ){
      rc = 8;
    }




    nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);
    ((void)0);
    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){
      const Pgno iSrcPg = p->iNext;
      if( iSrcPg!=((Pgno)((sqlite3PendingByte/((p->pSrc->pBt)->pageSize))+1)) ){
        DbPage *pSrcPg;
        rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg,0x02);
        if( rc==0 ){
          rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg), 0);
          sqlite3PagerUnref(pSrcPg);
        }
      }
      p->iNext++;
    }
    if( rc==0 ){
      p->nPagecount = nSrcPage;
      p->nRemaining = nSrcPage+1-p->iNext;
      if( p->iNext>(Pgno)nSrcPage ){
        rc = 101;
      }else if( !p->isAttached ){
        attachBackupObject(p);
      }
    }






    if( rc==101 ){
      if( nSrcPage==0 ){
        rc = sqlite3BtreeNewDb(p->pDest);
        nSrcPage = 1;
      }
      if( rc==0 || rc==101 ){
        rc = sqlite3BtreeUpdateMeta(p->pDest,1,p->iDestSchema+1);
      }
      if( rc==0 ){
        if( p->pDestDb ){
          sqlite3ResetAllSchemasOfConnection(p->pDestDb);
        }
        if( destMode==5 ){
          rc = sqlite3BtreeSetVersion(p->pDest, 2);
        }
      }
      if( rc==0 ){
        int nDestTruncate;
# 74337 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        ((void)0);
        ((void)0);
        if( pgszSrc<pgszDest ){
          int ratio = pgszDest/pgszSrc;
          nDestTruncate = (nSrcPage+ratio-1)/ratio;
          if( nDestTruncate==(int)((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ){
            nDestTruncate--;
          }
        }else{
          nDestTruncate = nSrcPage * (pgszSrc/pgszDest);
        }
        ((void)0);

        if( pgszSrc<pgszDest ){
# 74360 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;
          sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);
          Pgno iPg;
          int nDstPage;
          i64 iOff;
          i64 iEnd;

          ((void)0);
          ((void)0)



            ;







          sqlite3PagerPagecount(pDestPager, &nDstPage);
          for(iPg=nDestTruncate; rc==0 && iPg<=(Pgno)nDstPage; iPg++){
            if( iPg!=((Pgno)((sqlite3PendingByte/((p->pDest->pBt)->pageSize))+1)) ){
              DbPage *pPg;
              rc = sqlite3PagerGet(pDestPager, iPg, &pPg, 0);
              if( rc==0 ){
                rc = sqlite3PagerWrite(pPg);
                sqlite3PagerUnref(pPg);
              }
            }
          }
          if( rc==0 ){
            rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);
          }


          iEnd = ((sqlite3PendingByte + pgszDest)<(iSize)?(sqlite3PendingByte + pgszDest):(iSize));
          for(
            iOff=sqlite3PendingByte+pgszSrc;
            rc==0 && iOff<iEnd;
            iOff+=pgszSrc
          ){
            PgHdr *pSrcPg = 0;
            const Pgno iSrcPg = (Pgno)((iOff/pgszSrc)+1);
            rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg, 0);
            if( rc==0 ){
              u8 *zData = sqlite3PagerGetData(pSrcPg);
              rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);
            }
            sqlite3PagerUnref(pSrcPg);
          }
          if( rc==0 ){
            rc = backupTruncateFile(pFile, iSize);
          }


          if( rc==0 ){
            rc = sqlite3PagerSync(pDestPager, 0);
          }
        }else{
          sqlite3PagerTruncateImage(pDestPager, nDestTruncate);
          rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);
        }


        if( 0==rc
         && 0==(rc = sqlite3BtreeCommitPhaseTwo(p->pDest, 0))
        ){
          rc = 101;
        }
      }
    }






    if( bCloseTrans ){
      ;
      sqlite3BtreeCommitPhaseOne(p->pSrc, 0);
      sqlite3BtreeCommitPhaseTwo(p->pSrc, 0);
      ((void)0);
    }

    if( rc==(10 | (12<<8)) ){
      rc = 7;
    }
    p->rc = rc;
  }
  if( p->pDestDb ){
    sqlite3_mutex_leave(p->pDestDb->mutex);
  }
  sqlite3BtreeLeave(p->pSrc);
  sqlite3_mutex_leave(p->pSrcDb->mutex);
  return rc;
}




 int sqlite3_backup_finish(sqlite3_backup *p){
  sqlite3_backup **pp;
  sqlite3 *pSrcDb;
  int rc;


  if( p==0 ) return 0;
  pSrcDb = p->pSrcDb;
  sqlite3_mutex_enter(pSrcDb->mutex);
  sqlite3BtreeEnter(p->pSrc);
  if( p->pDestDb ){
    sqlite3_mutex_enter(p->pDestDb->mutex);
  }


  if( p->pDestDb ){
    p->pSrc->nBackup--;
  }
  if( p->isAttached ){
    pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));
    ((void)0);
    while( *pp!=p ){
      pp = &(*pp)->pNext;
      ((void)0);
    }
    *pp = p->pNext;
  }


  sqlite3BtreeRollback(p->pDest, 0, 0);


  rc = (p->rc==101) ? 0 : p->rc;
  if( p->pDestDb ){
    sqlite3Error(p->pDestDb, rc);


    sqlite3LeaveMutexAndCloseZombie(p->pDestDb);
  }
  sqlite3BtreeLeave(p->pSrc);
  if( p->pDestDb ){



    sqlite3_free(p);
  }
  sqlite3LeaveMutexAndCloseZombie(pSrcDb);
  return rc;
}





 int sqlite3_backup_remaining(sqlite3_backup *p){






  return p->nRemaining;
}





 int sqlite3_backup_pagecount(sqlite3_backup *p){






  return p->nPagecount;
}
# 74551 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) void backupUpdate(
  sqlite3_backup *p,
  Pgno iPage,
  const u8 *aData
){
  ((void)0);
  do{
    ((void)0);
    if( !isFatalError(p->rc) && iPage<p->iNext ){




      int rc;
      ((void)0);
      sqlite3_mutex_enter(p->pDestDb->mutex);
      rc = backupOnePage(p, iPage, aData, 1);
      sqlite3_mutex_leave(p->pDestDb->mutex);
      ((void)0);
      if( rc!=0 ){
        p->rc = rc;
      }
    }
  }while( (p = p->pNext)!=0 );
}
static void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData){
  if( pBackup ) backupUpdate(pBackup, iPage, aData);
}
# 74591 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BackupRestart(sqlite3_backup *pBackup){
  sqlite3_backup *p;
  for(p=pBackup; p; p=p->pNext){
    ((void)0);
    p->iNext = 1;
  }
}
# 74608 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){
  int rc;
  sqlite3_file *pFd;
  sqlite3_backup b;
  sqlite3BtreeEnter(pTo);
  sqlite3BtreeEnter(pFrom);

  ((void)0);
  pFd = sqlite3PagerFile(sqlite3BtreePager(pTo));
  if( pFd->pMethods ){
    i64 nByte = sqlite3BtreeGetPageSize(pFrom)*(i64)sqlite3BtreeLastPage(pFrom);
    rc = sqlite3OsFileControl(pFd, 11, &nByte);
    if( rc==12 ) rc = 0;
    if( rc ) goto copy_finished;
  }






  memset(&b, 0, sizeof(b));
  b.pSrcDb = pFrom->db;
  b.pSrc = pFrom;
  b.pDest = pTo;
  b.iNext = 1;
# 74645 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_backup_step(&b, 0x7FFFFFFF);
  ((void)0);

  rc = sqlite3_backup_finish(&b);
  if( rc==0 ){
    pTo->pBt->btsFlags &= ~0x0002;
  }else{
    sqlite3PagerClearCache(sqlite3BtreePager(b.pDest));
  }

  ((void)0);
copy_finished:
  sqlite3BtreeLeave(pFrom);
  sqlite3BtreeLeave(pTo);
  return rc;
}
# 74688 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ISPOWEROF2(X) (((X)&((X)-1))==0)
# 74768 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void vdbeMemRenderNum(int sz, char *zBuf, Mem *p){
  StrAccum acc;
  ((void)0);
  sqlite3StrAccumInit(&acc, 0, zBuf, sz, 0);
  if( p->flags & 0x0004 ){
    sqlite3_str_appendf(&acc, "%lld", p->u.i);
  }else if( p->flags & 0x0020 ){
    sqlite3_str_appendf(&acc, "%!.15g", (double)p->u.i);
  }else{
    sqlite3_str_appendf(&acc, "%!.15g", p->u.r);
  }
  ((void)0);
  zBuf[acc.nChar] = 0;
}
# 74852 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){

  int rc;

  ((void)0);
  ((void)0)
                                          ;
  if( !(pMem->flags&0x0002) || pMem->enc==desiredEnc ){
    return 0;
  }
  ((void)0);







  rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);
  ((void)0);
  ((void)0);
  ((void)0);
  return rc;

}
# 74886 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int sqlite3VdbeMemGrow(Mem *pMem, int n, int bPreserve){
  ((void)0);
  ((void)0);
  ;



  ((void)0);
  ;

  ((void)0)
                                                                        ;
  if( pMem->szMalloc>0 && bPreserve && pMem->z==pMem->zMalloc ){
    if( pMem->db ){
      pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);
    }else{
      pMem->zMalloc = sqlite3Realloc(pMem->z, n);
      if( pMem->zMalloc==0 ) sqlite3_free(pMem->z);
      pMem->z = pMem->zMalloc;
    }
    bPreserve = 0;
  }else{
    if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
    pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);
  }
  if( pMem->zMalloc==0 ){
    sqlite3VdbeMemSetNull(pMem);
    pMem->z = 0;
    pMem->szMalloc = 0;
    return 7;
  }else{
    pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
  }

  if( bPreserve && pMem->z ){
    ((void)0);
    memcpy(pMem->zMalloc, pMem->z, pMem->n);
  }
  if( (pMem->flags&0x0400)!=0 ){
    ((void)0);
    pMem->xDel((void *)(pMem->z));
  }

  pMem->z = pMem->zMalloc;
  pMem->flags &= ~(0x0400|0x1000|0x0800);
  return 0;
}
# 74947 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemClearAndResize(Mem *pMem, int szNew){
  ((void)0);
  ((void)0);
  if( pMem->szMalloc<szNew ){
    return sqlite3VdbeMemGrow(pMem, szNew, 0);
  }
  ((void)0);
  pMem->z = pMem->zMalloc;
  pMem->flags &= (0x0001|0x0004|0x0008|0x0020);
  return 0;
}
# 74968 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int vdbeMemAddTerminator(Mem *pMem){
  if( sqlite3VdbeMemGrow(pMem, pMem->n+3, 1) ){
    return 7;
  }
  pMem->z[pMem->n] = 0;
  pMem->z[pMem->n+1] = 0;
  pMem->z[pMem->n+2] = 0;
  pMem->flags |= 0x0200;
  return 0;
}







static int sqlite3VdbeMemMakeWriteable(Mem *pMem){
  ((void)0);
  ((void)0);
  if( (pMem->flags & (0x0002|0x0010))!=0 ){
    if( (((pMem)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pMem):0) ) return 7;
    if( pMem->szMalloc==0 || pMem->z!=pMem->zMalloc ){
      int rc = vdbeMemAddTerminator(pMem);
      if( rc ) return rc;
    }
  }
  pMem->flags &= ~0x1000;




  return 0;
}






static int sqlite3VdbeMemExpandBlob(Mem *pMem){
  int nByte;
  ((void)0);
  ((void)0);
  ;
  ((void)0);
  ((void)0);


  nByte = pMem->n + pMem->u.nZero;
  if( nByte<=0 ){
    if( (pMem->flags & 0x0010)==0 ) return 0;
    nByte = 1;
  }
  if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){
    return 7;
  }

  memset(&pMem->z[pMem->n], 0, pMem->u.nZero);
  pMem->n += pMem->u.nZero;
  pMem->flags &= ~(0x4000|0x0200);
  return 0;
}





static int sqlite3VdbeMemNulTerminate(Mem *pMem){
  ((void)0);
  ;
  ;
  if( (pMem->flags & (0x0200|0x0002))!=0x0002 ){
    return 0;
  }else{
    return vdbeMemAddTerminator(pMem);
  }
}
# 75061 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemStringify(Mem *pMem, u8 enc, u8 bForce){
  const int nByte = 32;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  if( sqlite3VdbeMemClearAndResize(pMem, nByte) ){
    pMem->enc = 0;
    return 7;
  }

  vdbeMemRenderNum(nByte, pMem->z, pMem);
  ((void)0);
  pMem->n = (strlen(pMem->z)&0x3fffffff);
  pMem->enc = 1;
  pMem->flags |= 0x0002|0x0200;
  if( bForce ) pMem->flags &= ~(0x0004|0x0008|0x0020);
  sqlite3VdbeChangeEncoding(pMem, enc);
  return 0;
}
# 75095 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){
  sqlite3_context ctx;
  Mem t;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  memset(&ctx, 0, sizeof(ctx));
  memset(&t, 0, sizeof(t));
  t.flags = 0x0001;
  t.db = pMem->db;
  ctx.pOut = &t;
  ctx.pMem = pMem;
  ctx.pFunc = pFunc;
  pFunc->xFinalize(&ctx);
  ((void)0);
  if( pMem->szMalloc>0 ) sqlite3DbFreeNN(pMem->db, pMem->zMalloc);
  memcpy(pMem, &t, sizeof(t));
  return ctx.isError;
}
# 75125 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemAggValue(Mem *pAccum, Mem *pOut, FuncDef *pFunc){
  sqlite3_context ctx;
  Mem t;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  memset(&ctx, 0, sizeof(ctx));
  memset(&t, 0, sizeof(t));
  t.flags = 0x0001;
  t.db = pAccum->db;
  sqlite3VdbeMemSetNull(pOut);
  ctx.pOut = pOut;
  ctx.pMem = pAccum;
  ctx.pFunc = pFunc;
  pFunc->xValue(&ctx);
  return ctx.isError;
}
# 75154 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) void vdbeMemClearExternAndSetNull(Mem *p){
  ((void)0);
  ((void)0);
  if( p->flags&0x2000 ){
    sqlite3VdbeMemFinalize(p, p->u.pDef);
    ((void)0);
    ;
  }
  if( p->flags&0x0400 ){
    ((void)0);
    p->xDel((void *)p->z);
  }
  p->flags = 0x0001;
}
# 75177 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) void vdbeMemClear(Mem *p){
  if( (((p)->flags&(0x2000|0x0400))!=0) ){
    vdbeMemClearExternAndSetNull(p);
  }
  if( p->szMalloc ){
    sqlite3DbFreeNN(p->db, p->zMalloc);
    p->szMalloc = 0;
  }
  p->z = 0;
}
# 75198 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeMemRelease(Mem *p){
  ((void)0);
  if( (((p)->flags&(0x2000|0x0400))!=0) || p->szMalloc ){
    vdbeMemClear(p);
  }
}






static __attribute__((noinline)) i64 doubleToInt64(double r){
# 75222 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  static const i64 maxInt = (0xffffffff|(((i64)0x7fffffff)<<32));
  static const i64 minInt = (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));

  if( r<=(double)minInt ){
    return minInt;
  }else if( r>=(double)maxInt ){
    return maxInt;
  }else{
    return (i64)r;
  }

}
# 75246 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) i64 memIntValue(Mem *pMem){
  i64 value = 0;
  sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);
  return value;
}
static i64 sqlite3VdbeIntValue(Mem *pMem){
  int flags;
  ((void)0);
  ((void)0);
  flags = pMem->flags;
  if( flags & (0x0004|0x0020) ){
    ;
    return pMem->u.i;
  }else if( flags & 0x0008 ){
    return doubleToInt64(pMem->u.r);
  }else if( flags & (0x0002|0x0010) ){
    ((void)0);
    return memIntValue(pMem);
  }else{
    return 0;
  }
}







static __attribute__((noinline)) double memRealValue(Mem *pMem){

  double val = (double)0;
  sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);
  return val;
}
static double sqlite3VdbeRealValue(Mem *pMem){
  ((void)0);
  ((void)0);
  if( pMem->flags & 0x0008 ){
    return pMem->u.r;
  }else if( pMem->flags & (0x0004|0x0020) ){
    ;
    return (double)pMem->u.i;
  }else if( pMem->flags & (0x0002|0x0010) ){
    return memRealValue(pMem);
  }else{

    return (double)0;
  }
}





static int sqlite3VdbeBooleanValue(Mem *pMem, int ifNull){
  ;
  if( pMem->flags & (0x0004|0x0020) ) return pMem->u.i!=0;
  if( pMem->flags & 0x0001 ) return ifNull;
  return sqlite3VdbeRealValue(pMem)!=0.0;
}





static void sqlite3VdbeIntegerAffinity(Mem *pMem){
  i64 ix;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  ix = doubleToInt64(pMem->u.r);
# 75331 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pMem->u.r==ix && ix>(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) && ix<(0xffffffff|(((i64)0x7fffffff)<<32)) ){
    pMem->u.i = ix;
    ((pMem)->flags = ((pMem)->flags&~(0xc1bf|0x4000))|0x0004);
  }
}




static int sqlite3VdbeMemIntegerify(Mem *pMem){
  ((void)0);
  ((void)0);
  ((void)0);

  pMem->u.i = sqlite3VdbeIntValue(pMem);
  ((pMem)->flags = ((pMem)->flags&~(0xc1bf|0x4000))|0x0004);
  return 0;
}





static int sqlite3VdbeMemRealify(Mem *pMem){
  ((void)0);
  ((void)0);

  pMem->u.r = sqlite3VdbeRealValue(pMem);
  ((pMem)->flags = ((pMem)->flags&~(0xc1bf|0x4000))|0x0008);
  return 0;
}
# 75372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3RealSameAsInt(double r1, sqlite3_int64 i){
  double r2 = (double)i;
  return r1==0.0
      || (memcmp(&r1, &r2, sizeof(r1))==0
          && i >= -2251799813685248LL && i < 2251799813685248LL);
}
# 75387 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemNumerify(Mem *pMem){
  ;
  ;
  ;
  ;
  if( (pMem->flags & (0x0004|0x0008|0x0020|0x0001))==0 ){
    int rc;
    sqlite3_int64 ix;
    ((void)0);
    ((void)0);
    rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
    if( ((rc==0 || rc==1) && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1)
     || sqlite3RealSameAsInt(pMem->u.r, (ix = (i64)pMem->u.r))
    ){
      pMem->u.i = ix;
      ((pMem)->flags = ((pMem)->flags&~(0xc1bf|0x4000))|0x0004);
    }else{
      ((pMem)->flags = ((pMem)->flags&~(0xc1bf|0x4000))|0x0008);
    }
  }
  ((void)0);
  pMem->flags &= ~(0x0002|0x0010|0x4000);
  return 0;
}
# 75419 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeMemCast(Mem *pMem, u8 aff, u8 encoding){
  if( pMem->flags & 0x0001 ) return;
  switch( aff ){
    case 0x41: {
      if( (pMem->flags & 0x0010)==0 ){
        sqlite3ValueApplyAffinity(pMem, 0x42, encoding);
        ((void)0);
        if( pMem->flags & 0x0002 ) ((pMem)->flags = ((pMem)->flags&~(0xc1bf|0x4000))|0x0010);
      }else{
        pMem->flags &= ~(0xc1bf&~0x0010);
      }
      break;
    }
    case 0x43: {
      sqlite3VdbeMemNumerify(pMem);
      break;
    }
    case 0x44: {
      sqlite3VdbeMemIntegerify(pMem);
      break;
    }
    case 0x45: {
      sqlite3VdbeMemRealify(pMem);
      break;
    }
    default: {
      ((void)0);
      ((void)0);
      pMem->flags |= (pMem->flags&0x0010)>>3;
      sqlite3ValueApplyAffinity(pMem, 0x42, encoding);
      ((void)0);
      pMem->flags &= ~(0x0004|0x0008|0x0020|0x0010|0x4000);
      break;
    }
  }
}






static void sqlite3VdbeMemInit(Mem *pMem, sqlite3 *db, u16 flags){
  ((void)0);
  pMem->flags = flags;
  pMem->db = db;
  pMem->szMalloc = 0;
}
# 75481 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeMemSetNull(Mem *pMem){
  if( (((pMem)->flags&(0x2000|0x0400))!=0) ){
    vdbeMemClearExternAndSetNull(pMem);
  }else{
    pMem->flags = 0x0001;
  }
}
static void sqlite3ValueSetNull(sqlite3_value *p){
  sqlite3VdbeMemSetNull((Mem*)p);
}





static void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){
  sqlite3VdbeMemRelease(pMem);
  pMem->flags = 0x0010|0x4000;
  pMem->n = 0;
  if( n<0 ) n = 0;
  pMem->u.nZero = n;
  pMem->enc = 1;
  pMem->z = 0;
}






static __attribute__((noinline)) void vdbeReleaseAndSetInt64(Mem *pMem, i64 val){
  sqlite3VdbeMemSetNull(pMem);
  pMem->u.i = val;
  pMem->flags = 0x0004;
}





static void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){
  if( (((pMem)->flags&(0x2000|0x0400))!=0) ){
    vdbeReleaseAndSetInt64(pMem, val);
  }else{
    pMem->u.i = val;
    pMem->flags = 0x0004;
  }
}


static void sqlite3NoopDestructor(void *p){ (void)(p); }





static void sqlite3VdbeMemSetPointer(
  Mem *pMem,
  void *pPtr,
  const char *zPType,
  void (*xDestructor)(void*)
){
  ((void)0);
  pMem->u.zPType = zPType ? zPType : "";
  pMem->z = pPtr;
  pMem->flags = 0x0001|0x0400|0x8000|0x0200;
  pMem->eSubtype = 'p';
  pMem->xDel = xDestructor ? xDestructor : sqlite3NoopDestructor;
}






static void sqlite3VdbeMemSetDouble(Mem *pMem, double val){
  sqlite3VdbeMemSetNull(pMem);
  if( !sqlite3IsNaN(val) ){
    pMem->u.r = val;
    pMem->flags = 0x0008;
  }
}
# 75583 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemSetRowSet(Mem *pMem){
  sqlite3 *db = pMem->db;
  RowSet *p;
  ((void)0);
  ((void)0);
  sqlite3VdbeMemRelease(pMem);
  p = sqlite3RowSetInit(db);
  if( p==0 ) return 7;
  pMem->z = (char*)p;
  pMem->flags = 0x0010|0x0400;
  pMem->xDel = sqlite3RowSetDelete;
  return 0;
}





static int sqlite3VdbeMemTooBig(Mem *p){
  ((void)0);
  if( p->flags & (0x0002|0x0010) ){
    int n = p->n;
    if( p->flags & 0x4000 ){
      n += p->u.nZero;
    }
    return n>p->db->aLimit[0];
  }
  return 0;
}
# 75656 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) void vdbeClrCopy(Mem *pTo, const Mem *pFrom, int eType){
  vdbeMemClearExternAndSetNull(pTo);
  ((void)0);
  sqlite3VdbeMemShallowCopy(pTo, pFrom, eType);
}
static void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){
  ((void)0);
  ((void)0);
  if( (((pTo)->flags&(0x2000|0x0400))!=0) ){ vdbeClrCopy(pTo,pFrom,srcType); return; }
  memcpy(pTo, pFrom, __builtin_offsetof(Mem,zMalloc));
  if( (pFrom->flags&0x0800)==0 ){
    pTo->flags &= ~(0x0400|0x0800|0x1000);
    ((void)0);
    pTo->flags |= srcType;
  }
}





static int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){
  int rc = 0;

  ((void)0);
  if( (((pTo)->flags&(0x2000|0x0400))!=0) ) vdbeMemClearExternAndSetNull(pTo);
  memcpy(pTo, pFrom, __builtin_offsetof(Mem,zMalloc));
  pTo->flags &= ~0x0400;
  if( pTo->flags&(0x0002|0x0010) ){
    if( 0==(pFrom->flags&0x0800) ){
      pTo->flags |= 0x1000;
      rc = sqlite3VdbeMemMakeWriteable(pTo);
    }
  }

  return rc;
}







static void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){
  ((void)0);
  ((void)0);
  ((void)0);

  sqlite3VdbeMemRelease(pTo);
  memcpy(pTo, pFrom, sizeof(Mem));
  pFrom->flags = 0x0001;
  pFrom->szMalloc = 0;
}
# 75726 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMemSetStr(
  Mem *pMem,
  const char *z,
  int n,
  u8 enc,
  void (*xDel)(void*)
){
  int nByte = n;
  int iLimit;
  u16 flags = 0;

  ((void)0);
  ((void)0);


  if( !z ){
    sqlite3VdbeMemSetNull(pMem);
    return 0;
  }

  if( pMem->db ){
    iLimit = pMem->db->aLimit[0];
  }else{
    iLimit = 1000000000;
  }
  flags = (enc==0?0x0010:0x0002);
  if( nByte<0 ){
    ((void)0);
    if( enc==1 ){
      nByte = 0x7fffffff & (int)strlen(z);
    }else{
      for(nByte=0; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){}
    }
    flags |= 0x0200;
  }





  if( xDel==((sqlite3_destructor_type)-1) ){
    u32 nAlloc = nByte;
    if( flags&0x0200 ){
      nAlloc += (enc==1?1:2);
    }
    if( nByte>iLimit ){
      return sqlite3ErrorToParser(pMem->db, 18);
    }
    ;
    ;
    ;
    if( sqlite3VdbeMemClearAndResize(pMem, (int)((nAlloc)>(32)?(nAlloc):(32))) ){
      return 7;
    }
    memcpy(pMem->z, z, nAlloc);
  }else{
    sqlite3VdbeMemRelease(pMem);
    pMem->z = (char *)z;
    if( xDel==((sqlite3_destructor_type)sqlite3MallocSize) ){
      pMem->zMalloc = pMem->z;
      pMem->szMalloc = sqlite3DbMallocSize(pMem->db, pMem->zMalloc);
    }else{
      pMem->xDel = xDel;
      flags |= ((xDel==((sqlite3_destructor_type)0))?0x0800:0x0400);
    }
  }

  pMem->n = nByte;
  pMem->flags = flags;
  pMem->enc = (enc==0 ? 1 : enc);


  if( pMem->enc!=1 && sqlite3VdbeMemHandleBom(pMem) ){
    return 7;
  }


  if( nByte>iLimit ){
    return 18;
  }

  return 0;
}
# 75825 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int vdbeMemFromBtreeResize(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  Mem *pMem
){
  int rc;
  pMem->flags = 0x0001;
  if( sqlite3BtreeMaxRecordSize(pCur)<offset+amt ){
    return sqlite3CorruptError(75834);
  }
  if( 0==(rc = sqlite3VdbeMemClearAndResize(pMem, amt+1)) ){
    rc = sqlite3BtreePayload(pCur, offset, amt, pMem->z);
    if( rc==0 ){
      pMem->z[amt] = 0;
      pMem->flags = 0x0010;
      pMem->n = (int)amt;
    }else{
      sqlite3VdbeMemRelease(pMem);
    }
  }
  return rc;
}
static int sqlite3VdbeMemFromBtree(
  BtCursor *pCur,
  u32 offset,
  u32 amt,
  Mem *pMem
){
  char *zData;
  u32 available = 0;
  int rc = 0;

  ((void)0);
  ((void)0);



  ((void)0);
  zData = (char *)sqlite3BtreePayloadFetch(pCur, &available);
  ((void)0);

  if( offset+amt<=available ){
    pMem->z = &zData[offset];
    pMem->flags = 0x0010|0x1000;
    pMem->n = (int)amt;
  }else{
    rc = vdbeMemFromBtreeResize(pCur, offset, amt, pMem);
  }

  return rc;
}






static __attribute__((noinline)) const void *valueToText(sqlite3_value* pVal, u8 enc){
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( pVal->flags & (0x0010|0x0002) ){
    if( (((pVal)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pVal):0) ) return 0;
    pVal->flags |= 0x0002;
    if( pVal->enc != (enc & ~8) ){
      sqlite3VdbeChangeEncoding(pVal, enc & ~8);
    }
    if( (enc & 8)!=0 && 1==(1&((int)(long int)(pVal->z))) ){
      ((void)0);
      if( sqlite3VdbeMemMakeWriteable(pVal)!=0 ){
        return 0;
      }
    }
    sqlite3VdbeMemNulTerminate(pVal);
  }else{
    sqlite3VdbeMemStringify(pVal, enc, 0);
    ((void)0);
  }
  ((void)0)
                                         ;
  if( pVal->enc==(enc & ~8) ){
    ((void)0);
    return pVal->z;
  }else{
    return 0;
  }
}
# 75926 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){
  if( !pVal ) return 0;
  ((void)0);
  ((void)0);
  ((void)0);
  if( (pVal->flags&(0x0002|0x0200))==(0x0002|0x0200) && pVal->enc==enc ){
    ((void)0);
    return pVal->z;
  }
  if( pVal->flags&0x0001 ){
    return 0;
  }
  return valueToText(pVal, enc);
}




static sqlite3_value *sqlite3ValueNew(sqlite3 *db){
  Mem *p = sqlite3DbMallocZero(db, sizeof(*p));
  if( p ){
    p->flags = 0x0001;
    p->db = db;
  }
  return p;
}





struct ValueNewStat4Ctx {
  Parse *pParse;
  Index *pIdx;
  UnpackedRecord **ppRec;
  int iVal;
};
# 75975 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_value *valueNew(sqlite3 *db, struct ValueNewStat4Ctx *p){
# 76011 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(p);

  return sqlite3ValueNew(db);
}
# 76118 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define valueFromFunction(a,b,c,d,e,f) SQLITE_OK
# 76131 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int valueFromExpr(
  sqlite3 *db,
  Expr *pExpr,
  u8 enc,
  u8 affinity,
  sqlite3_value **ppVal,
  struct ValueNewStat4Ctx *pCtx
){
  int op;
  char *zVal = 0;
  sqlite3_value *pVal = 0;
  int negInt = 1;
  const char *zNeg = "";
  int rc = 0;

  ((void)0);
  while( (op = pExpr->op)==169 || op==176 ) pExpr = pExpr->pLeft;



  if( (op==171) ) op = pExpr->op2;






  ((void)0);

  if( op==36 ){
    u8 aff = sqlite3AffinityType(pExpr->u.zToken,0);
    rc = valueFromExpr(db, pExpr->pLeft, enc, aff, ppVal, pCtx);
    ;
    if( *ppVal ){
      sqlite3VdbeMemCast(*ppVal, aff, 1);
      sqlite3ValueApplyAffinity(*ppVal, affinity, 1);
    }
    return rc;
  }




  if( op==168
   && (pExpr->pLeft->op==150 || pExpr->pLeft->op==148) ){
    pExpr = pExpr->pLeft;
    op = pExpr->op;
    negInt = -1;
    zNeg = "-";
  }

  if( op==113 || op==148 || op==150 ){
    pVal = valueNew(db, pCtx);
    if( pVal==0 ) goto no_mem;
    if( (((pExpr)->flags&(0x000400))!=0) ){
      sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);
    }else{
      zVal = sqlite3MPrintf(db, "%s%s", zNeg, pExpr->u.zToken);
      if( zVal==0 ) goto no_mem;
      sqlite3ValueSetStr(pVal, -1, zVal, 1, ((sqlite3_destructor_type)sqlite3MallocSize));
    }
    if( (op==150 || op==148 ) && affinity==0x41 ){
      sqlite3ValueApplyAffinity(pVal, 0x43, 1);
    }else{
      sqlite3ValueApplyAffinity(pVal, affinity, 1);
    }
    ((void)0);
    if( pVal->flags & (0x0004|0x0020|0x0008) ){
      ;
      ;
      pVal->flags &= ~0x0002;
    }
    if( enc!=1 ){
      rc = sqlite3VdbeChangeEncoding(pVal, enc);
    }
  }else if( op==168 ) {

    if( 0==valueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal,pCtx)
     && pVal!=0
    ){
      sqlite3VdbeMemNumerify(pVal);
      if( pVal->flags & 0x0008 ){
        pVal->u.r = -pVal->u.r;
      }else if( pVal->u.i==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){
        pVal->u.r = -(double)(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32)));
        ((pVal)->flags = ((pVal)->flags&~(0xc1bf|0x4000))|0x0008);
      }else{
        pVal->u.i = -pVal->u.i;
      }
      sqlite3ValueApplyAffinity(pVal, affinity, enc);
    }
  }else if( op==117 ){
    pVal = valueNew(db, pCtx);
    if( pVal==0 ) goto no_mem;
    sqlite3VdbeMemSetNull(pVal);
  }

  else if( op==149 ){
    int nVal;
    ((void)0);
    ((void)0);
    pVal = valueNew(db, pCtx);
    if( !pVal ) goto no_mem;
    zVal = &pExpr->u.zToken[2];
    nVal = sqlite3Strlen30(zVal)-1;
    ((void)0);
    sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,
                         0, ((sqlite3_destructor_type)sqlite3MallocSize));
  }






  else if( op==165 ){
    pVal = valueNew(db, pCtx);
    if( pVal ){
      pVal->flags = 0x0004;
      pVal->u.i = pExpr->u.zToken[4]==0;
    }
  }

  *ppVal = pVal;
  return rc;

no_mem:



    sqlite3OomFault(db);
  sqlite3DbFree(db, zVal);
  ((void)0);



  ((void)0); sqlite3ValueFree(pVal);

  return 7;
}
# 76282 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ValueFromExpr(
  sqlite3 *db,
  Expr *pExpr,
  u8 enc,
  u8 affinity,
  sqlite3_value **ppVal
){
  return pExpr ? valueFromExpr(db, pExpr, enc, affinity, ppVal, 0) : 0;
}
# 76511 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ValueSetStr(
  sqlite3_value *v,
  int n,
  const void *z,
  u8 enc,
  void (*xDel)(void*)
){
  if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
}




static void sqlite3ValueFree(sqlite3_value *v){
  if( !v ) return;
  sqlite3VdbeMemRelease((Mem *)v);
  sqlite3DbFreeNN(((Mem*)v)->db, v);
}






static __attribute__((noinline)) int valueBytes(sqlite3_value *pVal, u8 enc){
  return valueToText(pVal, enc)!=0 ? pVal->n : 0;
}
static int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){
  Mem *p = (Mem*)pVal;
  ((void)0);
  if( (p->flags & 0x0002)!=0 && pVal->enc==enc ){
    return p->n;
  }
  if( (p->flags & 0x0010)!=0 ){
    if( p->flags & 0x4000 ){
      return p->n + p->u.nZero;
    }else{
      return p->n;
    }
  }
  if( p->flags & 0x0001 ) return 0;
  return valueBytes(pVal, enc);
}
# 76577 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Vdbe *sqlite3VdbeCreate(Parse *pParse){
  sqlite3 *db = pParse->db;
  Vdbe *p;
  p = sqlite3DbMallocRawNN(db, sizeof(Vdbe) );
  if( p==0 ) return 0;
  memset(&p->aOp, 0, sizeof(Vdbe)-__builtin_offsetof(Vdbe,aOp));
  p->db = db;
  if( db->pVdbe ){
    db->pVdbe->pPrev = p;
  }
  p->pNext = db->pVdbe;
  p->pPrev = 0;
  db->pVdbe = p;
  p->magic = 0x16bceaa5;
  p->pParse = pParse;
  pParse->pVdbe = p;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  sqlite3VdbeAddOp2(p, 61, 0, 1);
  return p;
}




static void sqlite3VdbeError(Vdbe *p, const char *zFormat, ...){
  va_list ap;
  sqlite3DbFree(p->db, p->zErrMsg);
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  p->zErrMsg = sqlite3VMPrintf(p->db, zFormat, ap);
  ( ap = (va_list)0 );
}




static void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, u8 prepFlags){
  if( p==0 ) return;
  p->prepFlags = prepFlags;
  if( (prepFlags & 0x80)==0 ){
    p->expmask = 0;
  }
  ((void)0);
  p->zSql = sqlite3DbStrNDup(p->db, z, n);
}
# 76665 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){
  Vdbe tmp, *pTmp;
  char *zTmp;
  ((void)0);
  tmp = *pA;
  *pA = *pB;
  *pB = tmp;
  pTmp = pA->pNext;
  pA->pNext = pB->pNext;
  pB->pNext = pTmp;
  pTmp = pA->pPrev;
  pA->pPrev = pB->pPrev;
  pB->pPrev = pTmp;
  zTmp = pA->zSql;
  pA->zSql = pB->zSql;
  pB->zSql = zTmp;





  pB->expmask = pA->expmask;
  pB->prepFlags = pA->prepFlags;
  memcpy(pB->aCounter, pA->aCounter, sizeof(pB->aCounter));
  pB->aCounter[5]++;
}
# 76702 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int growOpArray(Vdbe *v, int nOp){
  VdbeOp *pNew;
  Parse *p = v->pParse;
# 76717 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_int64 nNew = (v->nOpAlloc ? 2*(sqlite3_int64)v->nOpAlloc
                        : (sqlite3_int64)(1024/sizeof(Op)));
  (void)(nOp);



  if( nNew > p->db->aLimit[5] ){
    sqlite3OomFault(p->db);
    return 7;
  }

  ((void)0);
  ((void)0);
  pNew = sqlite3DbRealloc(p->db, v->aOp, nNew*sizeof(Op));
  if( pNew ){
    p->szOpAlloc = sqlite3DbMallocSize(p->db, pNew);
    v->nOpAlloc = p->szOpAlloc/sizeof(Op);
    v->aOp = pNew;
  }
  return (pNew ? 0 : 7);
}
# 76766 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int growOp3(Vdbe *p, int op, int p1, int p2, int p3){
  ((void)0);
  if( growOpArray(p, 1) ) return 1;
  ((void)0);
  return sqlite3VdbeAddOp3(p, op, p1, p2, p3);
}
static int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){
  int i;
  VdbeOp *pOp;

  i = p->nOp;
  ((void)0);
  ((void)0);
  if( p->nOpAlloc<=i ){
    return growOp3(p, op, p1, p2, p3);
  }
  p->nOp++;
  pOp = &p->aOp[i];
  pOp->opcode = (u8)op;
  pOp->p5 = 0;
  pOp->p1 = p1;
  pOp->p2 = p2;
  pOp->p3 = p3;
  pOp->p4.p = 0;
  pOp->p4type = 0;
# 76807 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return i;
}
static int sqlite3VdbeAddOp0(Vdbe *p, int op){
  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);
}
static int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){
  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);
}
static int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){
  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);
}



static int sqlite3VdbeGoto(Vdbe *p, int iDest){
  return sqlite3VdbeAddOp3(p, 11, 0, iDest, 0);
}




static int sqlite3VdbeLoadString(Vdbe *p, int iDest, const char *zStr){
  return sqlite3VdbeAddOp4(p, 113, 0, iDest, 0, zStr, 0);
}
# 76843 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeMultiLoad(Vdbe *p, int iDest, const char *zTypes, ...){
  va_list ap;
  int i;
  char c;
  ( ap = (va_list)( &(zTypes) ) + ( (sizeof(zTypes) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  for(i=0; (c = zTypes[i])!=0; i++){
    if( c=='s' ){
      const char *z = ( *(const char* *)((ap += ( (sizeof(const char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(const char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3VdbeAddOp4(p, z==0 ? 73 : 113, 0, iDest+i, 0, z, 0);
    }else if( c=='i' ){
      sqlite3VdbeAddOp2(p, 70, ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ), iDest+i);
    }else{
      goto skip_op_resultrow;
    }
  }
  sqlite3VdbeAddOp2(p, 81, iDest, i);
skip_op_resultrow:
  ( ap = (va_list)0 );
}




static int sqlite3VdbeAddOp4(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  const char *zP4,
  int p4type
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  sqlite3VdbeChangeP4(p, addr, zP4, p4type);
  return addr;
}





static int sqlite3VdbeAddOp4Dup8(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  const u8 *zP4,
  int p4type
){
  char *p4copy = sqlite3DbMallocRawNN(sqlite3VdbeDb(p), 8);
  if( p4copy ) memcpy(p4copy, zP4, 8);
  return sqlite3VdbeAddOp4(p, op, p1, p2, p3, p4copy, p4type);
}






static int sqlite3VdbeExplainParent(Parse *pParse){
  VdbeOp *pOp;
  if( pParse->addrExplain==0 ) return 0;
  pOp = sqlite3VdbeGetOp(pParse->pVdbe, pParse->addrExplain);
  return pOp->p2;
}
# 76927 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeExplain(Parse *pParse, u8 bPush, const char *zFmt, ...){



  if( pParse->explain==2 )

  {
    char *zMsg;
    Vdbe *v;
    va_list ap;
    int iThis;
    ( ap = (va_list)( &(zFmt) ) + ( (sizeof(zFmt) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
    zMsg = sqlite3VMPrintf(pParse->db, zFmt, ap);
    ( ap = (va_list)0 );
    v = pParse->pVdbe;
    iThis = v->nOp;
    sqlite3VdbeAddOp4(v, 171, iThis, pParse->addrExplain, 0,
                      zMsg, (-7));
    ;
    if( bPush){
      pParse->addrExplain = iThis;
    }
  }
}




static void sqlite3VdbeExplainPop(Parse *pParse){
  ;
  pParse->addrExplain = sqlite3VdbeExplainParent(pParse);
}
# 76969 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeAddParseSchemaOp(Vdbe *p, int iDb, char *zWhere){
  int j;
  sqlite3VdbeAddOp4(p, 141, iDb, 0, 0, zWhere, (-7));
  for(j=0; j<p->db->nDb; j++) sqlite3VdbeUsesBtree(p, j);
}




static int sqlite3VdbeAddOp4Int(
  Vdbe *p,
  int op,
  int p1,
  int p2,
  int p3,
  int p4
){
  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);
  if( p->db->mallocFailed==0 ){
    VdbeOp *pOp = &p->aOp[addr];
    pOp->p4type = (-3);
    pOp->p4.i = p4;
  }
  return addr;
}



static void sqlite3VdbeEndCoroutine(Vdbe *v, int regYield){
  sqlite3VdbeAddOp1(v, 67, regYield);







  v->pParse->nTempReg = 0;
  v->pParse->nRangeReg = 0;
}
# 77035 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeMakeLabel(Parse *pParse){
  return --pParse->nLabel;
}






static __attribute__((noinline)) void resizeResolveLabel(Parse *p, Vdbe *v, int j){
  int nNewSize = 10 - p->nLabel;
  p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,
                     nNewSize*sizeof(p->aLabel[0]));
  if( p->aLabel==0 ){
    p->nLabelAlloc = 0;
  }else{




    p->nLabelAlloc = nNewSize;
    p->aLabel[j] = v->nOp;
  }
}
static void sqlite3VdbeResolveLabel(Vdbe *v, int x){
  Parse *p = v->pParse;
  int j = (~(x));
  ((void)0);
  ((void)0);
  ((void)0);





  if( p->nLabelAlloc + p->nLabel < 0 ){
    resizeResolveLabel(p,v,j);
  }else{
    ((void)0);
    p->aLabel[j] = v->nOp;
  }
}




static void sqlite3VdbeRunOnlyOnce(Vdbe *p){
  p->runOnlyOnce = 1;
}




static void sqlite3VdbeReusable(Vdbe *p){
  p->runOnlyOnce = 0;
}
# 77282 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){
  int nMaxArgs = *pMaxFuncArgs;
  Op *pOp;
  Parse *pParse = p->pParse;
  int *aLabel = pParse->aLabel;
  p->readOnly = 1;
  p->bIsReader = 0;
  pOp = &p->aOp[p->nOp-1];
  while(1){







    if( pOp->opcode<=61 ){


      switch( pOp->opcode ){
        case 2: {
          if( pOp->p2!=0 ) p->readOnly = 0;

        }
        case 1:
        case 0: {
          p->bIsReader = 1;
          break;
        }

        case 6:

        case 8:
        case 7: {
          p->readOnly = 0;
          p->bIsReader = 1;
          break;
        }
        case 5:
        case 3: {
          pOp->p4.xAdvance = sqlite3BtreeNext;
          pOp->p4type = (-5);



          ((void)0);
          break;
        }
        case 4: {
          pOp->p4.xAdvance = sqlite3BtreePrevious;
          pOp->p4type = (-5);



          ((void)0);
          break;
        }

        case 10: {
          if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;
          break;
        }
        case 9: {
          int n;
          ((void)0);
          ((void)0);
          n = pOp[-1].p1;
          if( n>nMaxArgs ) nMaxArgs = n;

        }

        default: {
          if( pOp->p2<0 ){



            ((void)0);
            ((void)0);
            pOp->p2 = aLabel[(~(pOp->p2))];
          }
          break;
        }
      }



      ((void)0);
    }
    if( pOp==p->aOp ) break;
    pOp--;
  }
  sqlite3DbFree(p->db, pParse->aLabel);
  pParse->aLabel = 0;
  pParse->nLabel = 0;
  *pMaxFuncArgs = nMaxArgs;
  ((void)0);
}




static int sqlite3VdbeCurrentAddr(Vdbe *p){
  ((void)0);
  return p->nOp;
}
# 77440 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){
  VdbeOp *aOp = p->aOp;
  ((void)0);


  ((void)0);

  resolveP2Values(p, pnMaxArg);
  *pnOp = p->nOp;
  p->aOp = 0;
  return aOp;
}
# 77460 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static VdbeOp *sqlite3VdbeAddOpList(
  Vdbe *p,
  int nOp,
  VdbeOpList const *aOp,
  int iLineno
){
  int i;
  VdbeOp *pOut, *pFirst;
  ((void)0);
  ((void)0);
  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p, nOp) ){
    return 0;
  }
  pFirst = pOut = &p->aOp[p->nOp];
  for(i=0; i<nOp; i++, aOp++, pOut++){
    pOut->opcode = aOp->opcode;
    pOut->p1 = aOp->p1;
    pOut->p2 = aOp->p2;
    ((void)0);
    if( (sqlite3OpcodeProperty[aOp->opcode] & 0x01)!=0 && aOp->p2>0 ){
      pOut->p2 += p->nOp;
    }
    pOut->p3 = aOp->p3;
    pOut->p4type = 0;
    pOut->p4.p = 0;
    pOut->p5 = 0;






    (void)iLineno;






  }
  p->nOp += nOp;
  return pFirst;
}
# 77536 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeChangeOpcode(Vdbe *p, int addr, u8 iNewOpcode){
  sqlite3VdbeGetOp(p,addr)->opcode = iNewOpcode;
}
static void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){
  sqlite3VdbeGetOp(p,addr)->p1 = val;
}
static void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){
  sqlite3VdbeGetOp(p,addr)->p2 = val;
}
static void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){
  sqlite3VdbeGetOp(p,addr)->p3 = val;
}
static void sqlite3VdbeChangeP5(Vdbe *p, u16 p5){
  ((void)0);
  if( p->nOp>0 ) p->aOp[p->nOp-1].p5 = p5;
}





static void sqlite3VdbeJumpHere(Vdbe *p, int addr){
  sqlite3VdbeChangeP2(p, addr, p->nOp);
}






static void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){
  if( (pDef->funcFlags & 0x0010)!=0 ){
    sqlite3DbFreeNN(db, pDef);
  }
}

static void vdbeFreeOpArray(sqlite3 *, Op *, int);




static __attribute__((noinline)) void freeP4Mem(sqlite3 *db, Mem *p){
  if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);
  sqlite3DbFreeNN(db, p);
}
static __attribute__((noinline)) void freeP4FuncCtx(sqlite3 *db, sqlite3_context *p){
  freeEphemeralFunction(db, p->pFunc);
 sqlite3DbFreeNN(db, p);
}
static void freeP4(sqlite3 *db, int p4type, void *p4){
  ((void)0);
  switch( p4type ){
    case (-16): {
      freeP4FuncCtx(db, (sqlite3_context*)p4);
      break;
    }
    case (-13):
    case (-14):
    case (-7):
    case (-17):
    case (-15): {
      sqlite3DbFree(db, p4);
      break;
    }
    case (-9): {
      if( db->pnBytesFreed==0 ) sqlite3KeyInfoUnref((KeyInfo*)p4);
      break;
    }






    case (-8): {
      freeEphemeralFunction(db, (FuncDef*)p4);
      break;
    }
    case (-11): {
      if( db->pnBytesFreed==0 ){
        sqlite3ValueFree((sqlite3_value*)p4);
      }else{
        freeP4Mem(db, (Mem*)p4);
      }
      break;
    }
    case (-12) : {
      if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);
      break;
    }
  }
}






static void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){
  if( aOp ){
    Op *pOp;
    for(pOp=&aOp[nOp-1]; pOp>=aOp; pOp--){
      if( pOp->p4type <= (-7) ) freeP4(db, pOp->p4type, pOp->p4.p);



    }
    sqlite3DbFreeNN(db, aOp);
  }
}






static void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){
  p->pNext = pVdbe->pProgram;
  pVdbe->pProgram = p;
}




static int sqlite3VdbeChangeToNoop(Vdbe *p, int addr){
  VdbeOp *pOp;
  if( p->db->mallocFailed ) return 0;
  ((void)0);
  pOp = &p->aOp[addr];
  freeP4(p->db, pOp->p4type, pOp->p4.p);
  pOp->p4type = 0;
  pOp->p4.z = 0;
  pOp->opcode = 170;
  return 1;
}





static int sqlite3VdbeDeletePriorOpcode(Vdbe *p, u8 op){
  if( p->nOp>0 && p->aOp[p->nOp-1].opcode==op ){
    return sqlite3VdbeChangeToNoop(p, p->nOp-1);
  }else{
    return 0;
  }
}
# 77701 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void __attribute__((noinline)) vdbeChangeP4Full(
  Vdbe *p,
  Op *pOp,
  const char *zP4,
  int n
){
  if( pOp->p4type ){
    freeP4(p->db, pOp->p4type, pOp->p4.p);
    pOp->p4type = 0;
    pOp->p4.p = 0;
  }
  if( n<0 ){
    sqlite3VdbeChangeP4(p, (int)(pOp - p->aOp), zP4, n);
  }else{
    if( n==0 ) n = sqlite3Strlen30(zP4);
    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);
    pOp->p4type = (-7);
  }
}
static void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){
  Op *pOp;
  sqlite3 *db;
  ((void)0);
  db = p->db;
  ((void)0);
  ((void)0);
  if( db->mallocFailed ){
    if( n!=(-12) ) freeP4(db, n, (void*)*(char**)&zP4);
    return;
  }
  ((void)0);
  ((void)0);
  if( addr<0 ){
    addr = p->nOp - 1;
  }
  pOp = &p->aOp[addr];
  if( n>=0 || pOp->p4type ){
    vdbeChangeP4Full(p, pOp, zP4, n);
    return;
  }
  if( n==(-3) ){


    pOp->p4.i = ((int)(long int)(zP4));
    pOp->p4type = (-3);
  }else if( zP4!=0 ){
    ((void)0);
    pOp->p4.p = (void*)zP4;
    pOp->p4type = (signed char)n;
    if( n==(-12) ) sqlite3VtabLock((VTable*)zP4);
  }
}
# 77763 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeAppendP4(Vdbe *p, void *pP4, int n){
  VdbeOp *pOp;
  ((void)0);
  ((void)0);
  if( p->db->mallocFailed ){
    freeP4(p->db, n, pP4);
  }else{
    ((void)0);
    ((void)0);
    pOp = &p->aOp[p->nOp-1];
    ((void)0);
    pOp->p4type = n;
    pOp->p4.p = pP4;
  }
}





static void sqlite3VdbeSetP4KeyInfo(Parse *pParse, Index *pIdx){
  Vdbe *v = pParse->pVdbe;
  KeyInfo *pKeyInfo;
  ((void)0);
  ((void)0);
  pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pIdx);
  if( pKeyInfo ) sqlite3VdbeAppendP4(v, pKeyInfo, (-9));
}
# 77849 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){


  static VdbeOp dummy;
  ((void)0);
  if( addr<0 ){
    addr = p->nOp - 1;
  }
  ((void)0);
  if( p->db->mallocFailed ){
    return (VdbeOp*)&dummy;
  }else{
    return &p->aOp[addr];
  }
}
# 78043 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *displayP4(Op *pOp, char *zTemp, int nTemp){
  char *zP4 = zTemp;
  StrAccum x;
  ((void)0);
  sqlite3StrAccumInit(&x, 0, zTemp, nTemp, 0);
  switch( pOp->p4type ){
    case (-9): {
      int j;
      KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;
      ((void)0);
      sqlite3_str_appendf(&x, "k(%d", pKeyInfo->nKeyField);
      for(j=0; j<pKeyInfo->nKeyField; j++){
        CollSeq *pColl = pKeyInfo->aColl[j];
        const char *zColl = pColl ? pColl->zName : "";
        if( strcmp(zColl, "BINARY")==0 ) zColl = "B";
        sqlite3_str_appendf(&x, ",%s%s%s",
               (pKeyInfo->aSortFlags[j] & 0x01) ? "-" : "",
               (pKeyInfo->aSortFlags[j] & 0x02)? "N." : "",
               zColl);
      }
      sqlite3_str_append(&x, ")", 1);
      break;
    }






    case (-2): {
      CollSeq *pColl = pOp->p4.pColl;
      sqlite3_str_appendf(&x, "(%.20s)", pColl->zName);
      break;
    }
    case (-8): {
      FuncDef *pDef = pOp->p4.pFunc;
      sqlite3_str_appendf(&x, "%s(%d)", pDef->zName, pDef->nArg);
      break;
    }







    case (-14): {
      sqlite3_str_appendf(&x, "%lld", *pOp->p4.pI64);
      break;
    }
    case (-3): {
      sqlite3_str_appendf(&x, "%d", pOp->p4.i);
      break;
    }
    case (-13): {
      sqlite3_str_appendf(&x, "%.16g", *pOp->p4.pReal);
      break;
    }
    case (-11): {
      Mem *pMem = pOp->p4.pMem;
      if( pMem->flags & 0x0002 ){
        zP4 = pMem->z;
      }else if( pMem->flags & (0x0004|0x0020) ){
        sqlite3_str_appendf(&x, "%lld", pMem->u.i);
      }else if( pMem->flags & 0x0008 ){
        sqlite3_str_appendf(&x, "%.16g", pMem->u.r);
      }else if( pMem->flags & 0x0001 ){
        zP4 = "NULL";
      }else{
        ((void)0);
        zP4 = "(blob)";
      }
      break;
    }

    case (-12): {
      sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;
      sqlite3_str_appendf(&x, "vtab:%p", pVtab);
      break;
    }

    case (-15): {
      int i;
      int *ai = pOp->p4.ai;
      int n = ai[0];

      for(i=1; i<=n; i++){
        sqlite3_str_appendf(&x, ",%d", ai[i]);
      }
      zTemp[0] = '[';
      sqlite3_str_append(&x, "]", 1);
      break;
    }
    case (-4): {
      sqlite3_str_appendf(&x, "program");
      break;
    }
    case (-17):
    case (-5): {
      zTemp[0] = 0;
      break;
    }
    case (-6): {
      sqlite3_str_appendf(&x, "%s", pOp->p4.pTab->zName);
      break;
    }
    default: {
      zP4 = pOp->p4.z;
      if( zP4==0 ){
        zP4 = zTemp;
        zTemp[0] = 0;
      }
    }
  }
  sqlite3StrAccumFinish(&x);
  ((void)0);
  return zP4;
}
# 78171 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeUsesBtree(Vdbe *p, int i){
  ((void)0);
  ((void)0);
  (p->btreeMask)|=(((yDbMask)1)<<(i));
  if( i!=1 && sqlite3BtreeSharable(p->db->aDb[i].pBt) ){
    (p->lockMask)|=(((yDbMask)1)<<(i));
  }
}
# 78202 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeEnter(Vdbe *p){
  int i;
  sqlite3 *db;
  Db *aDb;
  int nDb;
  if( (p->lockMask)==0 ) return;
  db = p->db;
  aDb = db->aDb;
  nDb = db->nDb;
  for(i=0; i<nDb; i++){
    if( i!=1 && (((p->lockMask)&(((yDbMask)1)<<(i)))!=0) && (aDb[i].pBt!=0) ){
      sqlite3BtreeEnter(aDb[i].pBt);
    }
  }
}






static __attribute__((noinline)) void vdbeLeave(Vdbe *p){
  int i;
  sqlite3 *db;
  Db *aDb;
  int nDb;
  db = p->db;
  aDb = db->aDb;
  nDb = db->nDb;
  for(i=0; i<nDb; i++){
    if( i!=1 && (((p->lockMask)&(((yDbMask)1)<<(i)))!=0) && (aDb[i].pBt!=0) ){
      sqlite3BtreeLeave(aDb[i].pBt);
    }
  }
}
static void sqlite3VdbeLeave(Vdbe *p){
  if( (p->lockMask)==0 ) return;
  vdbeLeave(p);
}
# 78273 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void initMemArray(Mem *p, int N, sqlite3 *db, u16 flags){
  while( (N--)>0 ){
    p->db = db;
    p->flags = flags;
    p->szMalloc = 0;



    p++;
  }
}




static void releaseMemArray(Mem *p, int N){
  if( p && N ){
    Mem *pEnd = &p[N];
    sqlite3 *db = p->db;
    if( db->pnBytesFreed ){
      do{
        if( p->szMalloc ) sqlite3DbFree(db, p->zMalloc);
      }while( (++p)<pEnd );
      return;
    }
    do{
      ((void)0);
      ((void)0);
# 78314 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      ;
      ;
      ;
      if( p->flags&(0x2000|0x0400) ){
        sqlite3VdbeMemRelease(p);
      }else if( p->szMalloc ){
        sqlite3DbFreeNN(db, p->zMalloc);
        p->szMalloc = 0;
      }

      p->flags = 0x0080;
    }while( (++p)<pEnd );
  }
}
# 78350 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeFrameMemDel(void *pArg){
  VdbeFrame *pFrame = (VdbeFrame*)pArg;
  ((void)0);
  pFrame->pParent = pFrame->v->pDelFrame;
  pFrame->v->pDelFrame = pFrame;
}






static void sqlite3VdbeFrameDelete(VdbeFrame *p){
  int i;
  Mem *aMem = ((Mem *)&((u8 *)p)[(((sizeof(VdbeFrame))+7)&~7)]);
  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];
  ((void)0);
  for(i=0; i<p->nChildCsr; i++){
    sqlite3VdbeFreeCursor(p->v, apCsr[i]);
  }
  releaseMemArray(aMem, p->nChildMem);
  sqlite3VdbeDeleteAuxData(p->v->db, &p->pAuxData, -1, 0);
  sqlite3DbFree(p->v->db, p);
}
# 78394 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeList(
  Vdbe *p
){
  int nRow;
  int nSub = 0;
  SubProgram **apSub = 0;
  Mem *pSub = 0;
  sqlite3 *db = p->db;
  int i;
  int rc = 0;
  Mem *pMem = &p->aMem[1];
  int bListSubprogs = (p->explain==1 || (db->flags & 0x01000000)!=0);
  Op *pOp = 0;

  ((void)0);
  ((void)0);
  ((void)0);





  releaseMemArray(pMem, 8);
  p->pResultSet = 0;

  if( p->rc==7 ){


    sqlite3OomFault(db);
    return 1;
  }
# 78433 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  nRow = p->nOp;
  if( bListSubprogs ){




    ((void)0);
    pSub = &p->aMem[9];
    if( pSub->flags&0x0010 ){


      nSub = pSub->n/sizeof(Vdbe*);
      apSub = (SubProgram **)pSub->z;
    }
    for(i=0; i<nSub; i++){
      nRow += apSub[i]->nOp;
    }
  }

  while(1){
    i = p->pc++;
    if( i>=nRow ){
      p->rc = 0;
      rc = 101;
      break;
    }
    if( i<p->nOp ){


      pOp = &p->aOp[i];
    }else{


      int j;
      i -= p->nOp;
      ((void)0);
      ((void)0);
      for(j=0; i>=apSub[j]->nOp; j++){
        i -= apSub[j]->nOp;
        ((void)0);
      }
      pOp = &apSub[j]->aOp[i];
    }






    if( bListSubprogs && pOp->p4type==(-4) ){
      int nByte = (nSub+1)*sizeof(SubProgram*);
      int j;
      for(j=0; j<nSub; j++){
        if( apSub[j]==pOp->p4.pProgram ) break;
      }
      if( j==nSub ){
        p->rc = sqlite3VdbeMemGrow(pSub, nByte, nSub!=0);
        if( p->rc!=0 ){
          rc = 1;
          break;
        }
        apSub = (SubProgram **)pSub->z;
        apSub[nSub++] = pOp->p4.pProgram;
        pSub->flags |= 0x0010;
        pSub->n = nSub*sizeof(SubProgram*);
        nRow += pOp->p4.pProgram->nOp;
      }
    }
    if( p->explain<2 ) break;
    if( pOp->opcode==171 ) break;
    if( pOp->opcode==61 && p->pc>1 ) break;
  }

  if( rc==0 ){
    if( db->u1.isInterrupted ){
      p->rc = 9;
      rc = 1;
      sqlite3VdbeError(p, sqlite3ErrStr(p->rc));
    }else{
      char *zP4;
      if( p->explain==1 ){
        pMem->flags = 0x0004;
        pMem->u.i = i;
        pMem++;

        pMem->flags = 0x0800|0x0002|0x0200;
        pMem->z = (char*)sqlite3OpcodeName(pOp->opcode);
        ((void)0);
        pMem->n = sqlite3Strlen30(pMem->z);
        pMem->enc = 1;
        pMem++;
      }

      pMem->flags = 0x0004;
      pMem->u.i = pOp->p1;
      pMem++;

      pMem->flags = 0x0004;
      pMem->u.i = pOp->p2;
      pMem++;

      pMem->flags = 0x0004;
      pMem->u.i = pOp->p3;
      pMem++;

      if( sqlite3VdbeMemClearAndResize(pMem, 100) ){
        ((void)0);
        return 1;
      }
      pMem->flags = 0x0002|0x0200;
      zP4 = displayP4(pOp, pMem->z, pMem->szMalloc);
      if( zP4!=pMem->z ){
        pMem->n = 0;
        sqlite3VdbeMemSetStr(pMem, zP4, -1, 1, 0);
      }else{
        ((void)0);
        pMem->n = sqlite3Strlen30(pMem->z);
        pMem->enc = 1;
      }
      pMem++;

      if( p->explain==1 ){
        if( sqlite3VdbeMemClearAndResize(pMem, 4) ){
          ((void)0);
          return 1;
        }
        pMem->flags = 0x0002|0x0200;
        pMem->n = 2;
        sqlite3_snprintf(3, pMem->z, "%.2x", pOp->p5);
        pMem->enc = 1;
        pMem++;
# 78574 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        pMem->flags = 0x0001;

      }

      p->nResColumn = 8 - 4*(p->explain-1);
      p->pResultSet = &p->aMem[1];
      p->rc = 0;
      rc = 100;
    }
  }
  return rc;
}
# 78641 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct ReusableSpace {
  u8 *pSpace;
  sqlite3_int64 nFree;
  sqlite3_int64 nNeeded;
};
# 78661 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *allocSpace(
  struct ReusableSpace *p,
  void *pBuf,
  sqlite3_int64 nByte
){
  ((void)0);
  if( pBuf==0 ){
    nByte = (((nByte)+7)&~7);
    if( nByte <= p->nFree ){
      p->nFree -= nByte;
      pBuf = &p->pSpace[p->nFree];
    }else{
      p->nNeeded += nByte;
    }
  }
  ((void)0);
  return pBuf;
}





static void sqlite3VdbeRewind(Vdbe *p){



  ((void)0);
  ((void)0);



  ((void)0);


  p->magic = 0x2df20da3;






  p->pc = -1;
  p->rc = 0;
  p->errorAction = 2;
  p->nChange = 0;
  p->cacheCtr = 1;
  p->minWriteFileFormat = 255;
  p->iStatement = 0;
  p->nFkConstraint = 0;






}
# 78737 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeMakeReady(
  Vdbe *p,
  Parse *pParse
){
  sqlite3 *db;
  int nVar;
  int nMem;
  int nCursor;
  int nArg;
  int n;
  struct ReusableSpace x;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  db = p->db;
  ((void)0);
  nVar = pParse->nVar;
  nMem = pParse->nMem;
  nCursor = pParse->nTab;
  nArg = pParse->nMaxArg;






  nMem += nCursor;
  if( nCursor==0 && nMem>0 ) nMem++;





  n = (((sizeof(Op)*p->nOp)+7)&~7);
  x.pSpace = &((u8*)p->aOp)[n];
  ((void)0);
  x.nFree = ((pParse->szOpAlloc - n)&~7);
  ((void)0);
  ((void)0);

  resolveP2Values(p, &nArg);
  p->usesStmtJournal = (u8)(pParse->isMultiWrite && pParse->mayAbort);
  if( pParse->explain && nMem<10 ){
    nMem = 10;
  }
  p->expired = 0;
# 78797 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  x.nNeeded = 0;
  p->aMem = allocSpace(&x, 0, nMem*sizeof(Mem));
  p->aVar = allocSpace(&x, 0, nVar*sizeof(Mem));
  p->apArg = allocSpace(&x, 0, nArg*sizeof(Mem*));
  p->apCsr = allocSpace(&x, 0, nCursor*sizeof(VdbeCursor*));



  if( x.nNeeded ){
    x.pSpace = p->pFree = sqlite3DbMallocRawNN(db, x.nNeeded);
    x.nFree = x.nNeeded;
    if( !db->mallocFailed ){
      p->aMem = allocSpace(&x, p->aMem, nMem*sizeof(Mem));
      p->aVar = allocSpace(&x, p->aVar, nVar*sizeof(Mem));
      p->apArg = allocSpace(&x, p->apArg, nArg*sizeof(Mem*));
      p->apCsr = allocSpace(&x, p->apCsr, nCursor*sizeof(VdbeCursor*));



    }
  }

  p->pVList = pParse->pVList;
  pParse->pVList = 0;
  p->explain = pParse->explain;
  if( db->mallocFailed ){
    p->nVar = 0;
    p->nCursor = 0;
    p->nMem = 0;
  }else{
    p->nCursor = nCursor;
    p->nVar = (ynVar)nVar;
    initMemArray(p->aVar, nVar, db, 0x0001);
    p->nMem = nMem;
    initMemArray(p->aMem, nMem, db, 0x0080);
    memset(p->apCsr, 0, nCursor*sizeof(VdbeCursor*));



  }
  sqlite3VdbeRewind(p);
}





static void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){
  if( pCx==0 ){
    return;
  }
  ((void)0);
  switch( pCx->eCurType ){
    case 1: {
      sqlite3VdbeSorterClose(p->db, pCx);
      break;
    }
    case 0: {
      if( pCx->isEphemeral ){
        if( pCx->pBtx ) sqlite3BtreeClose(pCx->pBtx);


      }else{
        ((void)0);
        sqlite3BtreeCloseCursor(pCx->uc.pCursor);
      }
      break;
    }

    case 2: {
      sqlite3_vtab_cursor *pVCur = pCx->uc.pVCur;
      const sqlite3_module *pModule = pVCur->pVtab->pModule;
      ((void)0);
      pVCur->pVtab->nRef--;
      pModule->xClose(pVCur);
      break;
    }

  }
}




static void closeCursorsInFrame(Vdbe *p){
  if( p->apCsr ){
    int i;
    for(i=0; i<p->nCursor; i++){
      VdbeCursor *pC = p->apCsr[i];
      if( pC ){
        sqlite3VdbeFreeCursor(p, pC);
        p->apCsr[i] = 0;
      }
    }
  }
}






static int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){
  Vdbe *v = pFrame->v;
  closeCursorsInFrame(v);



  v->aOp = pFrame->aOp;
  v->nOp = pFrame->nOp;
  v->aMem = pFrame->aMem;
  v->nMem = pFrame->nMem;
  v->apCsr = pFrame->apCsr;
  v->nCursor = pFrame->nCursor;
  v->db->lastRowid = pFrame->lastRowid;
  v->nChange = pFrame->nChange;
  v->db->nChange = pFrame->nDbChange;
  sqlite3VdbeDeleteAuxData(v->db, &v->pAuxData, -1, 0);
  v->pAuxData = pFrame->pAuxData;
  pFrame->pAuxData = 0;
  return pFrame->pc;
}
# 78928 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void closeAllCursors(Vdbe *p){
  if( p->pFrame ){
    VdbeFrame *pFrame;
    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);
    sqlite3VdbeFrameRestore(pFrame);
    p->pFrame = 0;
    p->nFrame = 0;
  }
  ((void)0);
  closeCursorsInFrame(p);
  if( p->aMem ){
    releaseMemArray(p->aMem, p->nMem);
  }
  while( p->pDelFrame ){
    VdbeFrame *pDel = p->pDelFrame;
    p->pDelFrame = pDel->pParent;
    sqlite3VdbeFrameDelete(pDel);
  }


  if( p->pAuxData ) sqlite3VdbeDeleteAuxData(p->db, &p->pAuxData, -1, 0);
  ((void)0);
}







static void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){
  int n;
  sqlite3 *db = p->db;

  if( p->nResColumn ){
    releaseMemArray(p->aColName, p->nResColumn*2);
    sqlite3DbFree(db, p->aColName);
  }
  n = nResColumn*2;
  p->nResColumn = (u16)nResColumn;
  p->aColName = (Mem*)sqlite3DbMallocRawNN(db, sizeof(Mem)*n );
  if( p->aColName==0 ) return;
  initMemArray(p->aColName, n, db, 0x0001);
}
# 78983 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeSetColName(
  Vdbe *p,
  int idx,
  int var,
  const char *zName,
  void (*xDel)(void*)
){
  int rc;
  Mem *pColName;
  ((void)0);
  ((void)0);
  if( p->db->mallocFailed ){
    ((void)0);
    return 7;
  }
  ((void)0);
  pColName = &(p->aColName[idx+var*p->nResColumn]);
  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, 1, xDel);
  ((void)0);
  return rc;
}







static int vdbeCommit(sqlite3 *db, Vdbe *p){
  int i;
  int nTrans = 0;


  int rc = 0;
  int needXcommit = 0;
# 79032 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  rc = sqlite3VtabSync(db, p);







  for(i=0; rc==0 && i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( sqlite3BtreeIsInTrans(pBt) ){



      static const u8 aMJNeeded[] = {
                        1,
                        1,
                        0,
                        1,
                        0,
                        0
      };
      Pager *pPager;
      needXcommit = 1;
      sqlite3BtreeEnter(pBt);
      pPager = sqlite3BtreePager(pBt);
      if( db->aDb[i].safety_level!=0x01
       && aMJNeeded[sqlite3PagerGetJournalMode(pPager)]
       && sqlite3PagerIsMemdb(pPager)==0
      ){
        ((void)0);
        nTrans++;
      }
      rc = sqlite3PagerExclusiveLock(pPager);
      sqlite3BtreeLeave(pBt);
    }
  }
  if( rc!=0 ){
    return rc;
  }


  if( needXcommit && db->xCommitCallback ){
    rc = db->xCommitCallback(db->pCommitArg);
    if( rc ){
      return (19 | (2<<8));
    }
  }
# 79090 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))
   || nTrans<=1
  ){
    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        rc = sqlite3BtreeCommitPhaseOne(pBt, 0);
      }
    }






    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        rc = sqlite3BtreeCommitPhaseTwo(pBt, 0);
      }
    }
    if( rc==0 ){
      sqlite3VtabCommit(db);
    }
  }






  else{
    sqlite3_vfs *pVfs = db->pVfs;
    char *zMaster = 0;
    char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);
    sqlite3_file *pMaster = 0;
    i64 offset = 0;
    int res;
    int retryCount = 0;
    int nMainFile;


    nMainFile = sqlite3Strlen30(zMainFile);
    zMaster = sqlite3MPrintf(db, "%s-mjXXXXXX9XXz", zMainFile);
    if( zMaster==0 ) return 7;
    do {
      u32 iRandom;
      if( retryCount ){
        if( retryCount>100 ){
          sqlite3_log(13, "MJ delete: %s", zMaster);
          sqlite3OsDelete(pVfs, zMaster, 0);
          break;
        }else if( retryCount==1 ){
          sqlite3_log(13, "MJ collide: %s", zMaster);
        }
      }
      retryCount++;
      sqlite3_randomness(sizeof(iRandom), &iRandom);
      sqlite3_snprintf(13, &zMaster[nMainFile], "-mj%06X9%02X",
                               (iRandom>>8)&0xffffff, iRandom&0xff);


      ((void)0);
      ;
      rc = sqlite3OsAccess(pVfs, zMaster, 0, &res);
    }while( rc==0 && res );
    if( rc==0 ){

      rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster,
          0x00000002|0x00000004|
          0x00000010|0x00004000, 0
      );
    }
    if( rc!=0 ){
      sqlite3DbFree(db, zMaster);
      return rc;
    }







    for(i=0; i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( sqlite3BtreeIsInTrans(pBt) ){
        char const *zFile = sqlite3BtreeGetJournalname(pBt);
        if( zFile==0 ){
          continue;
        }
        ((void)0);
        rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile)+1, offset);
        offset += sqlite3Strlen30(zFile)+1;
        if( rc!=0 ){
          sqlite3OsCloseFree(pMaster);
          sqlite3OsDelete(pVfs, zMaster, 0);
          sqlite3DbFree(db, zMaster);
          return rc;
        }
      }
    }




    if( 0==(sqlite3OsDeviceCharacteristics(pMaster)&0x00000400)
     && 0!=(rc = sqlite3OsSync(pMaster, 0x00002))
    ){
      sqlite3OsCloseFree(pMaster);
      sqlite3OsDelete(pVfs, zMaster, 0);
      sqlite3DbFree(db, zMaster);
      return rc;
    }
# 79215 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    for(i=0; rc==0 && i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster);
      }
    }
    sqlite3OsCloseFree(pMaster);
    ((void)0);
    if( rc!=0 ){
      sqlite3DbFree(db, zMaster);
      return rc;
    }





    rc = sqlite3OsDelete(pVfs, zMaster, 1);
    sqlite3DbFree(db, zMaster);
    zMaster = 0;
    if( rc ){
      return rc;
    }
# 79246 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ;
    sqlite3BeginBenignMalloc();
    for(i=0; i<db->nDb; i++){
      Btree *pBt = db->aDb[i].pBt;
      if( pBt ){
        sqlite3BtreeCommitPhaseTwo(pBt, 1);
      }
    }
    sqlite3EndBenignMalloc();
    ;

    sqlite3VtabCommit(db);
  }


  return rc;
}
# 79293 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define checkActiveVdbeCnt(x) 
# 79306 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int vdbeCloseStatement(Vdbe *p, int eOp){
  sqlite3 *const db = p->db;
  int rc = 0;
  int i;
  const int iSavepoint = p->iStatement-1;

  ((void)0);
  ((void)0);
  ((void)0);

  for(i=0; i<db->nDb; i++){
    int rc2 = 0;
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      if( eOp==2 ){
        rc2 = sqlite3BtreeSavepoint(pBt, 2, iSavepoint);
      }
      if( rc2==0 ){
        rc2 = sqlite3BtreeSavepoint(pBt, 1, iSavepoint);
      }
      if( rc==0 ){
        rc = rc2;
      }
    }
  }
  db->nStatement--;
  p->iStatement = 0;

  if( rc==0 ){
    if( eOp==2 ){
      rc = sqlite3VtabSavepoint(db, 2, iSavepoint);
    }
    if( rc==0 ){
      rc = sqlite3VtabSavepoint(db, 1, iSavepoint);
    }
  }




  if( eOp==2 ){
    db->nDeferredCons = p->nStmtDefCons;
    db->nDeferredImmCons = p->nStmtDefImmCons;
  }
  return rc;
}
static int sqlite3VdbeCloseStatement(Vdbe *p, int eOp){
  if( p->db->nStatement && p->iStatement ){
    return vdbeCloseStatement(p, eOp);
  }
  return 0;
}
# 79371 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeCheckFk(Vdbe *p, int deferred){
  sqlite3 *db = p->db;
  if( (deferred && (db->nDeferredCons+db->nDeferredImmCons)>0)
   || (!deferred && p->nFkConstraint>0)
  ){
    p->rc = (19 | (3<<8));
    p->errorAction = 2;
    sqlite3VdbeError(p, "FOREIGN KEY constraint failed");
    return 1;
  }
  return 0;
}
# 79398 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeHalt(Vdbe *p){
  int rc;
  sqlite3 *db = p->db;
# 79418 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( p->magic!=0x2df20da3 ){
    return 0;
  }
  if( db->mallocFailed ){
    p->rc = 7;
  }
  closeAllCursors(p);
  ;



  if( p->pc>=0 && p->bIsReader ){
    int mrc;
    int eStatementOp = 0;
    int isSpecialError;


    sqlite3VdbeEnter(p);


    mrc = p->rc & 0xff;
    isSpecialError = mrc==7 || mrc==10
                     || mrc==9 || mrc==13;
    if( isSpecialError ){
# 79454 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( !p->readOnly || mrc!=9 ){
        if( (mrc==7 || mrc==13) && p->usesStmtJournal ){
          eStatementOp = 2;
        }else{



          sqlite3RollbackAll(db, (4 | (2<<8)));
          sqlite3CloseSavepoints(db);
          db->autoCommit = 1;
          p->nChange = 0;
        }
      }
    }


    if( p->rc==0 || (p->errorAction==3 && !isSpecialError) ){
      sqlite3VdbeCheckFk(p, 0);
    }







    if( !((db)->nVTrans>0 && (db)->aVTrans==0)
     && db->autoCommit
     && db->nVdbeWrite==(p->readOnly==0)
    ){
      if( p->rc==0 || (p->errorAction==3 && !isSpecialError) ){
        rc = sqlite3VdbeCheckFk(p, 1);
        if( rc!=0 ){
          if( (p->readOnly) ){
            sqlite3VdbeLeave(p);
            return 1;
          }
          rc = (19 | (3<<8));
        }else{




          rc = vdbeCommit(db, p);
        }
        if( rc==5 && p->readOnly ){
          sqlite3VdbeLeave(p);
          return 5;
        }else if( rc!=0 ){
          p->rc = rc;
          sqlite3RollbackAll(db, 0);
          p->nChange = 0;
        }else{
          db->nDeferredCons = 0;
          db->nDeferredImmCons = 0;
          db->flags &= ~(u64)0x00080000;
          sqlite3CommitInternalChanges(db);
        }
      }else{
        sqlite3RollbackAll(db, 0);
        p->nChange = 0;
      }
      db->nStatement = 0;
    }else if( eStatementOp==0 ){
      if( p->rc==0 || p->errorAction==3 ){
        eStatementOp = 1;
      }else if( p->errorAction==2 ){
        eStatementOp = 2;
      }else{
        sqlite3RollbackAll(db, (4 | (2<<8)));
        sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
        p->nChange = 0;
      }
    }







    if( eStatementOp ){
      rc = sqlite3VdbeCloseStatement(p, eStatementOp);
      if( rc ){
        if( p->rc==0 || (p->rc&0xff)==19 ){
          p->rc = rc;
          sqlite3DbFree(db, p->zErrMsg);
          p->zErrMsg = 0;
        }
        sqlite3RollbackAll(db, (4 | (2<<8)));
        sqlite3CloseSavepoints(db);
        db->autoCommit = 1;
        p->nChange = 0;
      }
    }




    if( p->changeCntOn ){
      if( eStatementOp!=2 ){
        sqlite3VdbeSetChanges(db, p->nChange);
      }else{
        sqlite3VdbeSetChanges(db, 0);
      }
      p->nChange = 0;
    }


    sqlite3VdbeLeave(p);
  }


  if( p->pc>=0 ){
    db->nVdbeActive--;
    if( !p->readOnly ) db->nVdbeWrite--;
    if( p->bIsReader ) db->nVdbeRead--;
    ((void)0);
    ((void)0);
    ((void)0);
  }
  p->magic = 0x319c2973;
  ;
  if( db->mallocFailed ){
    p->rc = 7;
  }





  if( db->autoCommit ){
    ;
  }

  ((void)0);
  return (p->rc==5 ? 5 : 0);
}






static void sqlite3VdbeResetStepResult(Vdbe *p){
  p->rc = 0;
}
# 79611 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeTransferError(Vdbe *p){
  sqlite3 *db = p->db;
  int rc = p->rc;
  if( p->zErrMsg ){
    db->bBenignMalloc++;
    sqlite3BeginBenignMalloc();
    if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);
    sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, 1, ((sqlite3_destructor_type)-1));
    sqlite3EndBenignMalloc();
    db->bBenignMalloc--;
  }else if( db->pErr ){
    sqlite3ValueSetNull(db->pErr);
  }
  db->errCode = rc;
  return rc;
}
# 79646 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define vdbeInvokeSqllog(x) 
# 79660 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeReset(Vdbe *p){




  sqlite3 *db;
  db = p->db;





  sqlite3VdbeHalt(p);






  if( p->pc>=0 ){
    ;
    sqlite3VdbeTransferError(p);
    if( p->runOnlyOnce ) p->expired = 1;
  }else if( p->rc && p->expired ){




    sqlite3ErrorWithMsg(db, p->rc, p->zErrMsg ? "%s" : 0, p->zErrMsg);
  }
# 79701 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3DbFree(db, p->zErrMsg);
  p->zErrMsg = 0;
  p->pResultSet = 0;
# 79743 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  p->magic = 0x48fa9f76;
  return p->rc & db->errMask;
}





static int sqlite3VdbeFinalize(Vdbe *p){
  int rc = 0;
  if( p->magic==0x2df20da3 || p->magic==0x319c2973 ){
    rc = sqlite3VdbeReset(p);
    ((void)0);
  }
  sqlite3VdbeDelete(p);
  return rc;
}
# 79777 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeDeleteAuxData(sqlite3 *db, AuxData **pp, int iOp, int mask){
  while( *pp ){
    AuxData *pAux = *pp;
    if( (iOp<0)
     || (pAux->iAuxOp==iOp
          && pAux->iAuxArg>=0
          && (pAux->iAuxArg>31 || !(mask & (((unsigned int)1)<<(pAux->iAuxArg)))))
    ){
      ;
      if( pAux->xDeleteAux ){
        pAux->xDeleteAux(pAux->pAux);
      }
      *pp = pAux->pNextAux;
      sqlite3DbFree(db, pAux);
    }else{
      pp= &pAux->pNextAux;
    }
  }
}
# 79805 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VdbeClearObject(sqlite3 *db, Vdbe *p){
  SubProgram *pSub, *pNext;
  ((void)0);
  releaseMemArray(p->aColName, p->nResColumn*2);
  for(pSub=p->pProgram; pSub; pSub=pNext){
    pNext = pSub->pNext;
    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);
    sqlite3DbFree(db, pSub);
  }
  if( p->magic!=0x16bceaa5 ){
    releaseMemArray(p->aVar, p->nVar);
    sqlite3DbFree(db, p->pVList);
    sqlite3DbFree(db, p->pFree);
  }
  vdbeFreeOpArray(db, p->aOp, p->nOp);
  sqlite3DbFree(db, p->aColName);
  sqlite3DbFree(db, p->zSql);
# 79841 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}




static void sqlite3VdbeDelete(Vdbe *p){
  sqlite3 *db;

  ((void)0);
  db = p->db;
  ((void)0);
  sqlite3VdbeClearObject(db, p);
  if( p->pPrev ){
    p->pPrev->pNext = p->pNext;
  }else{
    ((void)0);
    db->pVdbe = p->pNext;
  }
  if( p->pNext ){
    p->pNext->pPrev = p->pPrev;
  }
  p->magic = 0x5606c3c8;
  p->db = 0;
  sqlite3DbFreeNN(db, p);
}






static int __attribute__((noinline)) handleDeferredMoveto(VdbeCursor *p){
  int res, rc;



  ((void)0);
  ((void)0);
  ((void)0);
  rc = sqlite3BtreeMovetoUnpacked(p->uc.pCursor, 0, p->movetoTarget, 0, &res);
  if( rc ) return rc;
  if( res!=0 ) return sqlite3CorruptError(79882);



  p->deferredMoveto = 0;
  p->cacheStatus = 0;
  return 0;
}
# 79898 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int __attribute__((noinline)) handleMovedCursor(VdbeCursor *p){
  int isDifferentRow, rc;
  ((void)0);
  ((void)0);
  ((void)0);
  rc = sqlite3BtreeCursorRestore(p->uc.pCursor, &isDifferentRow);
  p->cacheStatus = 0;
  if( isDifferentRow ) p->nullRow = 1;
  return rc;
}





static int sqlite3VdbeCursorRestore(VdbeCursor *p){
  ((void)0);
  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){
    return handleMovedCursor(p);
  }
  return 0;
}
# 79934 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeCursorMoveto(VdbeCursor **pp, int *piCol){
  VdbeCursor *p = *pp;
  ((void)0);
  if( p->deferredMoveto ){
    int iMap;
    if( p->aAltMap && (iMap = p->aAltMap[1+*piCol])>0 ){
      *pp = p->pAltCursor;
      *piCol = iMap - 1;
      return 0;
    }
    return handleDeferredMoveto(p);
  }
  if( sqlite3BtreeCursorHasMoved(p->uc.pCursor) ){
    return handleMovedCursor(p);
  }
  return 0;
}
# 80070 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const u8 sqlite3SmallTypeSizes[] = {

            0, 1, 2, 3, 4, 6, 8, 8, 0, 0,
            0, 0, 0, 0, 1, 1, 2, 2, 3, 3,
            4, 4, 5, 5, 6, 6, 7, 7, 8, 8,
            9, 9, 10, 10, 11, 11, 12, 12, 13, 13,
           14, 14, 15, 15, 16, 16, 17, 17, 18, 18,
           19, 19, 20, 20, 21, 21, 22, 22, 23, 23,
           24, 24, 25, 25, 26, 26, 27, 27, 28, 28,
           29, 29, 30, 30, 31, 31, 32, 32, 33, 33,
           34, 34, 35, 35, 36, 36, 37, 37, 38, 38,
           39, 39, 40, 40, 41, 41, 42, 42, 43, 43,
           44, 44, 45, 45, 46, 46, 47, 47, 48, 48,
           49, 49, 50, 50, 51, 51, 52, 52, 53, 53,
           54, 54, 55, 55, 56, 56, 57, 57
};




static u32 sqlite3VdbeSerialTypeLen(u32 serial_type){
  if( serial_type>=128 ){
    return (serial_type-12)/2;
  }else{
    ((void)0)
                                                                         ;
    return sqlite3SmallTypeSizes[serial_type];
  }
}
static u8 sqlite3VdbeOneByteSerialTypeLen(u8 serial_type){
  ((void)0);
  return sqlite3SmallTypeSizes[serial_type];
}
# 80154 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define swapMixedEndianFloat(X) 
# 80170 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u32 sqlite3VdbeSerialPut(u8 *buf, Mem *pMem, u32 serial_type){
  u32 len;


  if( serial_type<=7 && serial_type>0 ){
    u64 v;
    u32 i;
    if( serial_type==7 ){
      ((void)0);
      memcpy(&v, &pMem->u.r, sizeof(v));
      ;
    }else{
      v = pMem->u.i;
    }
    len = i = sqlite3SmallTypeSizes[serial_type];
    ((void)0);
    do{
      buf[--i] = (u8)(v&0xFF);
      v >>= 8;
    }while( i );
    return len;
  }


  if( serial_type>=12 ){
    ((void)0)
                                                            ;
    len = pMem->n;
    if( len>0 ) memcpy(buf, pMem->z, len);
    return len;
  }


  return 0;
}




#define ONE_BYTE_INT(x) ((i8)(x)[0])
#define TWO_BYTE_INT(x) (256*(i8)((x)[0])|(x)[1])
#define THREE_BYTE_INT(x) (65536*(i8)((x)[0])|((x)[1]<<8)|(x)[2])
#define FOUR_BYTE_UINT(x) (((u32)(x)[0]<<24)|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
#define FOUR_BYTE_INT(x) (16777216*(i8)((x)[0])|((x)[1]<<16)|((x)[2]<<8)|(x)[3])
# 80224 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u32 serialGet(
  const unsigned char *buf,
  u32 serial_type,
  Mem *pMem
){
  u64 x = (((u32)(buf)[0]<<24)|((buf)[1]<<16)|((buf)[2]<<8)|(buf)[3]);
  u32 y = (((u32)(buf+4)[0]<<24)|((buf+4)[1]<<16)|((buf+4)[2]<<8)|(buf+4)[3]);
  x = (x<<32) + y;
  if( serial_type==6 ){


    pMem->u.i = *(i64*)&x;
    pMem->flags = 0x0004;
    ;
  }else{
# 80253 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    ;
    memcpy(&pMem->u.r, &x, sizeof(x));
    pMem->flags = (((x)&(((u64)0x7ff)<<52))==(((u64)0x7ff)<<52) && ((x)&((((u64)1)<<52)-1))!=0) ? 0x0001 : 0x0008;
  }
  return 8;
}
static u32 sqlite3VdbeSerialGet(
  const unsigned char *buf,
  u32 serial_type,
  Mem *pMem
){
  switch( serial_type ){
    case 10: {

      pMem->flags = 0x0001|0x4000;
      pMem->n = 0;
      pMem->u.nZero = 0;
      break;
    }
    case 11:
    case 0: {

      pMem->flags = 0x0001;
      break;
    }
    case 1: {


      pMem->u.i = ((i8)(buf)[0]);
      pMem->flags = 0x0004;
      ;
      return 1;
    }
    case 2: {


      pMem->u.i = (256*(i8)((buf)[0])|(buf)[1]);
      pMem->flags = 0x0004;
      ;
      return 2;
    }
    case 3: {


      pMem->u.i = (65536*(i8)((buf)[0])|((buf)[1]<<8)|(buf)[2]);
      pMem->flags = 0x0004;
      ;
      return 3;
    }
    case 4: {


      pMem->u.i = (16777216*(i8)((buf)[0])|((buf)[1]<<16)|((buf)[2]<<8)|(buf)[3]);




      pMem->flags = 0x0004;
      ;
      return 4;
    }
    case 5: {


      pMem->u.i = (((u32)(buf+2)[0]<<24)|((buf+2)[1]<<16)|((buf+2)[2]<<8)|(buf+2)[3]) + (((i64)1)<<32)*(256*(i8)((buf)[0])|(buf)[1]);
      pMem->flags = 0x0004;
      ;
      return 6;
    }
    case 6:
    case 7: {


      return serialGet(buf,serial_type,pMem);
    }
    case 8:
    case 9: {


      pMem->u.i = serial_type-8;
      pMem->flags = 0x0004;
      return 0;
    }
    default: {




      static const u16 aFlag[] = { 0x0010|0x1000, 0x0002|0x1000 };
      pMem->z = (char *)buf;
      pMem->n = (serial_type-12)/2;
      pMem->flags = aFlag[serial_type&1];
      return pMem->n;
    }
  }
  return 0;
}
# 80365 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static UnpackedRecord *sqlite3VdbeAllocUnpackedRecord(
  KeyInfo *pKeyInfo
){
  UnpackedRecord *p;
  int nByte;
  nByte = (((sizeof(UnpackedRecord))+7)&~7) + sizeof(Mem)*(pKeyInfo->nKeyField+1);
  p = (UnpackedRecord *)sqlite3DbMallocRaw(pKeyInfo->db, nByte);
  if( !p ) return 0;
  p->aMem = (Mem*)&((char*)p)[(((sizeof(UnpackedRecord))+7)&~7)];
  ((void)0);
  p->pKeyInfo = pKeyInfo;
  p->nField = pKeyInfo->nKeyField + 1;
  return p;
}






static void sqlite3VdbeRecordUnpack(
  KeyInfo *pKeyInfo,
  int nKey,
  const void *pKey,
  UnpackedRecord *p
){
  const unsigned char *aKey = (const unsigned char *)pKey;
  u32 d;
  u32 idx;
  u16 u;
  u32 szHdr;
  Mem *pMem = p->aMem;

  p->default_rc = 0;
  ((void)0);
  idx = (u8)((*(aKey)<(u8)0x80)?((szHdr)=(u32)*(aKey)),1:sqlite3GetVarint32((aKey),(u32 *)&(szHdr)));
  d = szHdr;
  u = 0;
  while( idx<szHdr && d<=(u32)nKey ){
    u32 serial_type;

    idx += (u8)((*(&aKey[idx])<(u8)0x80)?((serial_type)=(u32)*(&aKey[idx])),1:sqlite3GetVarint32((&aKey[idx]),(u32 *)&(serial_type)));
    pMem->enc = pKeyInfo->enc;
    pMem->db = pKeyInfo->db;

    pMem->szMalloc = 0;
    pMem->z = 0;
    d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);
    pMem++;
    if( (++u)>=p->nField ) break;
  }
  if( d>(u32)nKey && u ){
    ((void)0);



    sqlite3VdbeMemSetNull(pMem-1);
  }
  ((void)0);
  p->nField = u;
}
# 80571 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define vdbeAssertFieldCountWithinLimits(A,B,C) 
# 80580 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeCompareMemString(
  const Mem *pMem1,
  const Mem *pMem2,
  const CollSeq *pColl,
  u8 *prcErr
){
  if( pMem1->enc==pColl->enc ){


    return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);
  }else{
    int rc;
    const void *v1, *v2;
    Mem c1;
    Mem c2;
    sqlite3VdbeMemInit(&c1, pMem1->db, 0x0001);
    sqlite3VdbeMemInit(&c2, pMem1->db, 0x0001);
    sqlite3VdbeMemShallowCopy(&c1, pMem1, 0x1000);
    sqlite3VdbeMemShallowCopy(&c2, pMem2, 0x1000);
    v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);
    v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);
    if( (v1==0 || v2==0) ){
      if( prcErr ) *prcErr = 7;
      rc = 0;
    }else{
      rc = pColl->xCmp(pColl->pUser, c1.n, v1, c2.n, v2);
    }
    sqlite3VdbeMemRelease(&c1);
    sqlite3VdbeMemRelease(&c2);
    return rc;
  }
}





static int isAllZero(const char *z, int n){
  int i;
  for(i=0; i<n; i++){
    if( z[i] ) return 0;
  }
  return 1;
}






static __attribute__((noinline)) int sqlite3BlobCompare(const Mem *pB1, const Mem *pB2){
  int c;
  int n1 = pB1->n;
  int n2 = pB2->n;





  ((void)0);
  ((void)0);

  if( (pB1->flags|pB2->flags) & 0x4000 ){
    if( pB1->flags & pB2->flags & 0x4000 ){
      return pB1->u.nZero - pB2->u.nZero;
    }else if( pB1->flags & 0x4000 ){
      if( !isAllZero(pB2->z, pB2->n) ) return -1;
      return pB1->u.nZero - n2;
    }else{
      if( !isAllZero(pB1->z, pB1->n) ) return +1;
      return n1 - pB2->u.nZero;
    }
  }
  c = memcmp(pB1->z, pB2->z, n1>n2 ? n2 : n1);
  if( c ) return c;
  return n1 - n2;
}






static int sqlite3IntFloatCompare(i64 i, double r){
  if( sizeof(long double)>8 ){
    long double x = (long double)i;
    if( x<r ) return -1;
    if( x>r ) return +1;
    return 0;
  }else{
    i64 y;
    double s;
    if( r<-9223372036854775808.0 ) return +1;
    if( r>=9223372036854775808.0 ) return -1;
    y = (i64)r;
    if( i<y ) return -1;
    if( i>y ) return +1;
    s = (double)i;
    if( s<r ) return -1;
    if( s>r ) return +1;
    return 0;
  }
}
# 80693 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){
  int f1, f2;
  int combined_flags;

  f1 = pMem1->flags;
  f2 = pMem2->flags;
  combined_flags = f1|f2;
  ((void)0);




  if( combined_flags&0x0001 ){
    return (f2&0x0001) - (f1&0x0001);
  }



  if( combined_flags&(0x0004|0x0008|0x0020) ){
    ;
    ;
    ;
    if( (f1 & f2 & (0x0004|0x0020))!=0 ){
      ;
      ;
      if( pMem1->u.i < pMem2->u.i ) return -1;
      if( pMem1->u.i > pMem2->u.i ) return +1;
      return 0;
    }
    if( (f1 & f2 & 0x0008)!=0 ){
      if( pMem1->u.r < pMem2->u.r ) return -1;
      if( pMem1->u.r > pMem2->u.r ) return +1;
      return 0;
    }
    if( (f1&(0x0004|0x0020))!=0 ){
      ;
      ;
      if( (f2&0x0008)!=0 ){
        return sqlite3IntFloatCompare(pMem1->u.i, pMem2->u.r);
      }else if( (f2&(0x0004|0x0020))!=0 ){
        if( pMem1->u.i < pMem2->u.i ) return -1;
        if( pMem1->u.i > pMem2->u.i ) return +1;
        return 0;
      }else{
        return -1;
      }
    }
    if( (f1&0x0008)!=0 ){
      if( (f2&(0x0004|0x0020))!=0 ){
        ;
        ;
        return -sqlite3IntFloatCompare(pMem2->u.i, pMem1->u.r);
      }else{
        return -1;
      }
    }
    return +1;
  }




  if( combined_flags&0x0002 ){
    if( (f1 & 0x0002)==0 ){
      return 1;
    }
    if( (f2 & 0x0002)==0 ){
      return -1;
    }

    ((void)0);
    ((void)0)
                                                                      ;





    ((void)0);

    if( pColl ){
      return vdbeCompareMemString(pMem1, pMem2, pColl, 0);
    }


  }


  return sqlite3BlobCompare(pMem1, pMem2);
}
# 80792 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static i64 vdbeRecordDecodeInt(u32 serial_type, const u8 *aKey){
  u32 y;
  ((void)0);
  switch( serial_type ){
    case 0:
    case 1:
      ;
      return ((i8)(aKey)[0]);
    case 2:
      ;
      return (256*(i8)((aKey)[0])|(aKey)[1]);
    case 3:
      ;
      return (65536*(i8)((aKey)[0])|((aKey)[1]<<8)|(aKey)[2]);
    case 4: {
      ;
      y = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
      return (i64)*(int*)&y;
    }
    case 5: {
      ;
      return (((u32)(aKey+2)[0]<<24)|((aKey+2)[1]<<16)|((aKey+2)[2]<<8)|(aKey+2)[3]) + (((i64)1)<<32)*(256*(i8)((aKey)[0])|(aKey)[1]);
    }
    case 6: {
      u64 x = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
      ;
      x = (x<<32) | (((u32)(aKey+4)[0]<<24)|((aKey+4)[1]<<16)|((aKey+4)[2]<<8)|(aKey+4)[3]);
      return (i64)*(i64*)&x;
    }
  }

  return (serial_type - 8);
}
# 80847 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeRecordCompareWithSkip(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2,
  int bSkip
){
  u32 d1;
  int i;
  u32 szHdr1;
  u32 idx1;
  int rc = 0;
  Mem *pRhs = pPKey2->aMem;
  KeyInfo *pKeyInfo;
  const unsigned char *aKey1 = (const unsigned char *)pKey1;
  Mem mem1;




  if( bSkip ){
    u32 s1;
    idx1 = 1 + (u8)((*(&aKey1[1])<(u8)0x80)?((s1)=(u32)*(&aKey1[1])),1:sqlite3GetVarint32((&aKey1[1]),(u32 *)&(s1)));
    szHdr1 = aKey1[0];
    d1 = szHdr1 + sqlite3VdbeSerialTypeLen(s1);
    i = 1;
    pRhs++;
  }else{
    idx1 = (u8)((*(aKey1)<(u8)0x80)?((szHdr1)=(u32)*(aKey1)),1:sqlite3GetVarint32((aKey1),(u32 *)&(szHdr1)));
    d1 = szHdr1;
    i = 0;
  }
  if( d1>(unsigned)nKey1 ){
    pPKey2->errCode = (u8)sqlite3CorruptError(80878);
    return 0;
  }

 
  ((void)0)
                      ;
  ((void)0);
  ((void)0);
  ((void)0);
  do{
    u32 serial_type;


    if( pRhs->flags & (0x0004|0x0020) ){
      ;
      ;
      serial_type = aKey1[idx1];
      ;
      if( serial_type>=10 ){
        rc = +1;
      }else if( serial_type==0 ){
        rc = -1;
      }else if( serial_type==7 ){
        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);
        rc = -sqlite3IntFloatCompare(pRhs->u.i, mem1.u.r);
      }else{
        i64 lhs = vdbeRecordDecodeInt(serial_type, &aKey1[d1]);
        i64 rhs = pRhs->u.i;
        if( lhs<rhs ){
          rc = -1;
        }else if( lhs>rhs ){
          rc = +1;
        }
      }
    }


    else if( pRhs->flags & 0x0008 ){
      serial_type = aKey1[idx1];
      if( serial_type>=10 ){




        rc = +1;
      }else if( serial_type==0 ){
        rc = -1;
      }else{
        sqlite3VdbeSerialGet(&aKey1[d1], serial_type, &mem1);
        if( serial_type==7 ){
          if( mem1.u.r<pRhs->u.r ){
            rc = -1;
          }else if( mem1.u.r>pRhs->u.r ){
            rc = +1;
          }
        }else{
          rc = sqlite3IntFloatCompare(mem1.u.i, pRhs->u.r);
        }
      }
    }


    else if( pRhs->flags & 0x0002 ){
      (u8)((*(&aKey1[idx1])<(u8)0x80)?((serial_type)=(u32)*(&aKey1[idx1])),1:sqlite3GetVarint32((&aKey1[idx1]),(u32 *)&(serial_type)));
      ;
      if( serial_type<12 ){
        rc = -1;
      }else if( !(serial_type & 0x01) ){
        rc = +1;
      }else{
        mem1.n = (serial_type - 12) / 2;
        ;
        ;
        if( (d1+mem1.n) > (unsigned)nKey1
         || (pKeyInfo = pPKey2->pKeyInfo)->nAllField<=i
        ){
          pPKey2->errCode = (u8)sqlite3CorruptError(80955);
          return 0;
        }else if( pKeyInfo->aColl[i] ){
          mem1.enc = pKeyInfo->enc;
          mem1.db = pKeyInfo->db;
          mem1.flags = 0x0002;
          mem1.z = (char*)&aKey1[d1];
          rc = vdbeCompareMemString(
              &mem1, pRhs, pKeyInfo->aColl[i], &pPKey2->errCode
          );
        }else{
          int nCmp = ((mem1.n)<(pRhs->n)?(mem1.n):(pRhs->n));
          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
          if( rc==0 ) rc = mem1.n - pRhs->n;
        }
      }
    }


    else if( pRhs->flags & 0x0010 ){
      ((void)0);
      (u8)((*(&aKey1[idx1])<(u8)0x80)?((serial_type)=(u32)*(&aKey1[idx1])),1:sqlite3GetVarint32((&aKey1[idx1]),(u32 *)&(serial_type)));
      ;
      if( serial_type<12 || (serial_type & 0x01) ){
        rc = -1;
      }else{
        int nStr = (serial_type - 12) / 2;
        ;
        ;
        if( (d1+nStr) > (unsigned)nKey1 ){
          pPKey2->errCode = (u8)sqlite3CorruptError(80985);
          return 0;
        }else if( pRhs->flags & 0x4000 ){
          if( !isAllZero((const char*)&aKey1[d1],nStr) ){
            rc = 1;
          }else{
            rc = nStr - pRhs->u.nZero;
          }
        }else{
          int nCmp = ((nStr)<(pRhs->n)?(nStr):(pRhs->n));
          rc = memcmp(&aKey1[d1], pRhs->z, nCmp);
          if( rc==0 ) rc = nStr - pRhs->n;
        }
      }
    }


    else{
      serial_type = aKey1[idx1];
      rc = (serial_type!=0);
    }

    if( rc!=0 ){
      int sortFlags = pPKey2->pKeyInfo->aSortFlags[i];
      if( sortFlags ){
        if( (sortFlags & 0x02)==0
         || ((sortFlags & 0x01)
           !=(serial_type==0 || (pRhs->flags&0x0001)))
        ){
          rc = -rc;
        }
      }
      ((void)0);
      ((void)0);
      return rc;
    }

    i++;
    if( i==pPKey2->nField ) break;
    pRhs++;
    d1 += sqlite3VdbeSerialTypeLen(serial_type);
    idx1 += sqlite3VarintLen(serial_type);
  }while( idx1<(unsigned)szHdr1 && d1<=(unsigned)nKey1 );




  ((void)0);




  ((void)0)


   ;
  pPKey2->eqSeen = 1;
  return pPKey2->default_rc;
}
static int sqlite3VdbeRecordCompare(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2
){
  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 0);
}
# 81061 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeRecordCompareInt(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2
){
  const u8 *aKey = &((const u8*)pKey1)[*(const u8*)pKey1 & 0x3F];
  int serial_type = ((const u8*)pKey1)[1];
  int res;
  u32 y;
  u64 x;
  i64 v;
  i64 lhs;

  ;
  ((void)0);
  switch( serial_type ){
    case 1: {
      lhs = ((i8)(aKey)[0]);
      ;
      break;
    }
    case 2: {
      lhs = (256*(i8)((aKey)[0])|(aKey)[1]);
      ;
      break;
    }
    case 3: {
      lhs = (65536*(i8)((aKey)[0])|((aKey)[1]<<8)|(aKey)[2]);
      ;
      break;
    }
    case 4: {
      y = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
      lhs = (i64)*(int*)&y;
      ;
      break;
    }
    case 5: {
      lhs = (((u32)(aKey+2)[0]<<24)|((aKey+2)[1]<<16)|((aKey+2)[2]<<8)|(aKey+2)[3]) + (((i64)1)<<32)*(256*(i8)((aKey)[0])|(aKey)[1]);
      ;
      break;
    }
    case 6: {
      x = (((u32)(aKey)[0]<<24)|((aKey)[1]<<16)|((aKey)[2]<<8)|(aKey)[3]);
      x = (x<<32) | (((u32)(aKey+4)[0]<<24)|((aKey+4)[1]<<16)|((aKey+4)[2]<<8)|(aKey+4)[3]);
      lhs = *(i64*)&x;
      ;
      break;
    }
    case 8:
      lhs = 0;
      break;
    case 9:
      lhs = 1;
      break;







    case 0: case 7:
      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);

    default:
      return sqlite3VdbeRecordCompare(nKey1, pKey1, pPKey2);
  }

  v = pPKey2->aMem[0].u.i;
  if( v>lhs ){
    res = pPKey2->r1;
  }else if( v<lhs ){
    res = pPKey2->r2;
  }else if( pPKey2->nField>1 ){


    res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
  }else{


    res = pPKey2->default_rc;
    pPKey2->eqSeen = 1;
  }

  ((void)0);
  return res;
}







static int vdbeRecordCompareString(
  int nKey1, const void *pKey1,
  UnpackedRecord *pPKey2
){
  const u8 *aKey1 = (const u8*)pKey1;
  int serial_type;
  int res;

  ((void)0);
  ;
  (u8)((*(&aKey1[1])<(u8)0x80)?((serial_type)=(u32)*(&aKey1[1])),1:sqlite3GetVarint32((&aKey1[1]),(u32 *)&(serial_type)));
  if( serial_type<12 ){
    res = pPKey2->r1;
  }else if( !(serial_type & 0x01) ){
    res = pPKey2->r2;
  }else{
    int nCmp;
    int nStr;
    int szHdr = aKey1[0];

    nStr = (serial_type-12) / 2;
    if( (szHdr + nStr) > nKey1 ){
      pPKey2->errCode = (u8)sqlite3CorruptError(81177);
      return 0;
    }
    nCmp = ((pPKey2->aMem[0].n)<(nStr)?(pPKey2->aMem[0].n):(nStr));
    res = memcmp(&aKey1[szHdr], pPKey2->aMem[0].z, nCmp);

    if( res>0 ){
      res = pPKey2->r2;
    }else if( res<0 ){
      res = pPKey2->r1;
    }else{
      res = nStr - pPKey2->aMem[0].n;
      if( res==0 ){
        if( pPKey2->nField>1 ){
          res = sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, pPKey2, 1);
        }else{
          res = pPKey2->default_rc;
          pPKey2->eqSeen = 1;
        }
      }else if( res>0 ){
        res = pPKey2->r2;
      }else{
        res = pPKey2->r1;
      }
    }
  }

  ((void)0)


   ;
  return res;
}






static RecordCompare sqlite3VdbeFindCompare(UnpackedRecord *p){
# 81230 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( p->pKeyInfo->nAllField<=13 ){
    int flags = p->aMem[0].flags;
    if( p->pKeyInfo->aSortFlags[0] ){
      if( p->pKeyInfo->aSortFlags[0] & 0x02 ){
        return sqlite3VdbeRecordCompare;
      }
      p->r1 = 1;
      p->r2 = -1;
    }else{
      p->r1 = -1;
      p->r2 = 1;
    }
    if( (flags & 0x0004) ){
      return vdbeRecordCompareInt;
    }
    ;
    ;
    ;
    if( (flags & (0x0008|0x0020|0x0001|0x0010))==0
     && p->pKeyInfo->aColl[0]==0
    ){
      ((void)0);
      return vdbeRecordCompareString;
    }
  }

  return sqlite3VdbeRecordCompare;
}
# 81267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){
  i64 nCellKey = 0;
  int rc;
  u32 szHdr;
  u32 typeRowid;
  u32 lenRowid;
  Mem m, v;






  ((void)0);
  nCellKey = sqlite3BtreePayloadSize(pCur);
  ((void)0);


  sqlite3VdbeMemInit(&m, db, 0);
  rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &m);
  if( rc ){
    return rc;
  }


  (void)(u8)((*((u8*)m.z)<(u8)0x80)?((szHdr)=(u32)*((u8*)m.z)),1:sqlite3GetVarint32(((u8*)m.z),(u32 *)&(szHdr)));
  ;
  ;
  ;
  ((void)0);
  if( (szHdr<3 || szHdr>(unsigned)m.n) ){
    goto idx_rowid_corruption;
  }



  (void)(u8)((*((u8*)&m.z[szHdr-1])<(u8)0x80)?((typeRowid)=(u32)*((u8*)&m.z[szHdr-1])),1:sqlite3GetVarint32(((u8*)&m.z[szHdr-1]),(u32 *)&(typeRowid)));
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  if( (typeRowid<1 || typeRowid>9 || typeRowid==7) ){
    goto idx_rowid_corruption;
  }
  lenRowid = sqlite3SmallTypeSizes[typeRowid];
  ;
  if( ((u32)m.n<szHdr+lenRowid) ){
    goto idx_rowid_corruption;
  }


  sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);
  *rowid = v.u.i;
  sqlite3VdbeMemRelease(&m);
  return 0;



idx_rowid_corruption:
  ;
  sqlite3VdbeMemRelease(&m);
  return sqlite3CorruptError(81332);
}
# 81346 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeIdxKeyCompare(
  sqlite3 *db,
  VdbeCursor *pC,
  UnpackedRecord *pUnpacked,
  int *res
){
  i64 nCellKey = 0;
  int rc;
  BtCursor *pCur;
  Mem m;

  ((void)0);
  pCur = pC->uc.pCursor;
  ((void)0);
  nCellKey = sqlite3BtreePayloadSize(pCur);


  if( nCellKey<=0 || nCellKey>0x7fffffff ){
    *res = 0;
    return sqlite3CorruptError(81365);
  }
  sqlite3VdbeMemInit(&m, db, 0);
  rc = sqlite3VdbeMemFromBtree(pCur, 0, (u32)nCellKey, &m);
  if( rc ){
    return rc;
  }
  *res = sqlite3VdbeRecordCompareWithSkip(m.n, m.z, pUnpacked, 0);
  sqlite3VdbeMemRelease(&m);
  return 0;
}





static void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){
  ((void)0);
  db->nChange = nChange;
  db->nTotalChange += nChange;
}





static void sqlite3VdbeCountChanges(Vdbe *v){
  v->changeCntOn = 1;
}
# 81413 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExpirePreparedStatements(sqlite3 *db, int iCode){
  Vdbe *p;
  for(p = db->pVdbe; p; p=p->pNext){
    p->expired = iCode+1;
  }
}




static sqlite3 *sqlite3VdbeDb(Vdbe *v){
  return v->db;
}




static u8 sqlite3VdbePrepareFlags(Vdbe *v){
  return v->prepFlags;
}
# 81442 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_value *sqlite3VdbeGetBoundValue(Vdbe *v, int iVar, u8 aff){
  ((void)0);
  if( v ){
    Mem *pMem = &v->aVar[iVar-1];
    ((void)0);
    if( 0==(pMem->flags & 0x0001) ){
      sqlite3_value *pRet = sqlite3ValueNew(v->db);
      if( pRet ){
        sqlite3VdbeMemCopy((Mem *)pRet, pMem);
        sqlite3ValueApplyAffinity(pRet, aff, 1);
      }
      return pRet;
    }
  }
  return 0;
}






static void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){
  ((void)0);
  ((void)0);
  if( iVar>=32 ){
    v->expmask |= 0x80000000;
  }else{
    v->expmask |= ((u32)1 << (iVar-1));
  }
}
# 81483 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3NotPureFunc(sqlite3_context *pCtx){



  if( pCtx->pVdbe->aOp[pCtx->iOp].opcode==64 ){
    sqlite3_result_error(pCtx,
       "non-deterministic function in index expression or CHECK constraint",
       -1);
    return 0;
  }
  return 1;
}







static void sqlite3VtabImportErrmsg(Vdbe *p, sqlite3_vtab *pVtab){
  if( pVtab->zErrMsg ){
    sqlite3 *db = p->db;
    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);
    sqlite3_free(pVtab->zErrMsg);
    pVtab->zErrMsg = 0;
  }
}
# 81631 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_expired(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p==0 || p->expired;
}







static int vdbeSafety(Vdbe *p){
  if( p->db==0 ){
    sqlite3_log(21, "API called with finalized prepared statement");
    return 1;
  }else{
    return 0;
  }
}
static int vdbeSafetyNotNull(Vdbe *p){
  if( p==0 ){
    sqlite3_log(21, "API called with NULL prepared statement");
    return 1;
  }else{
    return vdbeSafety(p);
  }
}






static __attribute__((noinline)) void invokeProfileCallback(sqlite3 *db, Vdbe *p){
  sqlite3_int64 iNow;
  sqlite3_int64 iElapse;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);
  iElapse = (iNow - p->startTime)*1000000;

  if( db->xProfile ){
    db->xProfile(db->pProfileArg, p->zSql, iElapse);
  }

  if( db->mTrace & 0x02 ){
    db->xTrace(0x02, db->pTraceArg, p, (void*)&iElapse);
  }
  p->startTime = 0;
}




#define checkProfileCallback(DB,P) if( ((P)->startTime)>0 ){ invokeProfileCallback(DB,P); }
# 81702 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_finalize(sqlite3_stmt *pStmt){
  int rc;
  if( pStmt==0 ){


    rc = 0;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    sqlite3 *db = v->db;
    if( vdbeSafety(v) ) return sqlite3MisuseError(81711);
    sqlite3_mutex_enter(db->mutex);
    if( ((v)->startTime)>0 ){ invokeProfileCallback(db,v); };
    rc = sqlite3VdbeFinalize(v);
    rc = sqlite3ApiExit(db, rc);
    sqlite3LeaveMutexAndCloseZombie(db);
  }
  return rc;
}
# 81729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_reset(sqlite3_stmt *pStmt){
  int rc;
  if( pStmt==0 ){
    rc = 0;
  }else{
    Vdbe *v = (Vdbe*)pStmt;
    sqlite3 *db = v->db;
    sqlite3_mutex_enter(db->mutex);
    if( ((v)->startTime)>0 ){ invokeProfileCallback(db,v); };
    rc = sqlite3VdbeReset(v);
    sqlite3VdbeRewind(v);
    ((void)0);
    rc = sqlite3ApiExit(db, rc);
    sqlite3_mutex_leave(db->mutex);
  }
  return rc;
}




 int sqlite3_clear_bindings(sqlite3_stmt *pStmt){
  int i;
  int rc = 0;
  Vdbe *p = (Vdbe*)pStmt;

  sqlite3_mutex *mutex = ((Vdbe*)pStmt)->db->mutex;

  sqlite3_mutex_enter(mutex);
  for(i=0; i<p->nVar; i++){
    sqlite3VdbeMemRelease(&p->aVar[i]);
    p->aVar[i].flags = 0x0001;
  }
  ((void)0);
  if( p->expmask ){
    p->expired = 1;
  }
  sqlite3_mutex_leave(mutex);
  return rc;
}






 const void *sqlite3_value_blob(sqlite3_value *pVal){
  Mem *p = (Mem*)pVal;
  if( p->flags & (0x0010|0x0002) ){
    if( (((p)->flags&0x4000)?sqlite3VdbeMemExpandBlob(p):0)!=0 ){
      ((void)0);
      return 0;
    }
    p->flags |= 0x0010;
    return p->n ? p->z : 0;
  }else{
    return sqlite3_value_text(pVal);
  }
}
 int sqlite3_value_bytes(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, 1);
}
 int sqlite3_value_bytes16(sqlite3_value *pVal){
  return sqlite3ValueBytes(pVal, 2);
}
 double sqlite3_value_double(sqlite3_value *pVal){
  return sqlite3VdbeRealValue((Mem*)pVal);
}
 int sqlite3_value_int(sqlite3_value *pVal){
  return (int)sqlite3VdbeIntValue((Mem*)pVal);
}
 sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){
  return sqlite3VdbeIntValue((Mem*)pVal);
}
 unsigned int sqlite3_value_subtype(sqlite3_value *pVal){
  Mem *pMem = (Mem*)pVal;
  return ((pMem->flags & 0x8000) ? pMem->eSubtype : 0);
}
 void *sqlite3_value_pointer(sqlite3_value *pVal, const char *zPType){
  Mem *p = (Mem*)pVal;
  if( (p->flags&(0xc1bf|0x0200|0x8000)) ==
                 (0x0001|0x0200|0x8000)
   && zPType!=0
   && p->eSubtype=='p'
   && strcmp(p->u.zPType, zPType)==0
  ){
    return (void*)p->z;
  }else{
    return 0;
  }
}
 const unsigned char *sqlite3_value_text(sqlite3_value *pVal){
  return (const unsigned char *)sqlite3ValueText(pVal, 1);
}

 const void *sqlite3_value_text16(sqlite3_value* pVal){
  return sqlite3ValueText(pVal, 2);
}
 const void *sqlite3_value_text16be(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, 3);
}
 const void *sqlite3_value_text16le(sqlite3_value *pVal){
  return sqlite3ValueText(pVal, 2);
}





 int sqlite3_value_type(sqlite3_value* pVal){
  static const u8 aType[] = {
     4,
     5,
     3,
     5,
     1,
     5,
     1,
     5,
     2,
     5,
     2,
     5,
     1,
     5,
     1,
     5,
     4,
     5,
     3,
     5,
     1,
     5,
     1,
     5,
     2,
     5,
     2,
     5,
     1,
     5,
     1,
     5,
     2,
     5,
     3,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     4,
     5,
     3,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
     2,
     5,
  };
# 81920 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return aType[pVal->flags&0x003f];
}


 int sqlite3_value_nochange(sqlite3_value *pVal){
  return (pVal->flags&(0x0001|0x4000))==(0x0001|0x4000);
}


 int sqlite3_value_frombind(sqlite3_value *pVal){
  return (pVal->flags&0x0040)!=0;
}



 sqlite3_value *sqlite3_value_dup(const sqlite3_value *pOrig){
  sqlite3_value *pNew;
  if( pOrig==0 ) return 0;
  pNew = sqlite3_malloc( sizeof(*pNew) );
  if( pNew==0 ) return 0;
  memset(pNew, 0, sizeof(*pNew));
  memcpy(pNew, pOrig, __builtin_offsetof(Mem,zMalloc));
  pNew->flags &= ~0x0400;
  pNew->db = 0;
  if( pNew->flags&(0x0002|0x0010) ){
    pNew->flags &= ~(0x0800|0x0400);
    pNew->flags |= 0x1000;
    if( sqlite3VdbeMemMakeWriteable(pNew)!=0 ){
      sqlite3ValueFree(pNew);
      pNew = 0;
    }
  }
  return pNew;
}




 void sqlite3_value_free(sqlite3_value *pOld){
  sqlite3ValueFree(pOld);
}
# 81974 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void setResultStrOrError(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  u8 enc,
  void (*xDel)(void*)
){
  if( sqlite3VdbeMemSetStr(pCtx->pOut, z, n, enc, xDel)==18 ){
    sqlite3_result_error_toobig(pCtx);
  }
}
static int invokeValueDestructor(
  const void *p,
  void (*xDel)(void*),
  sqlite3_context *pCtx
){
  ((void)0);
  if( xDel==0 ){

  }else if( xDel==((sqlite3_destructor_type)-1) ){

  }else{
    xDel((void*)p);
  }
  if( pCtx ) sqlite3_result_error_toobig(pCtx);
  return 18;
}
 void sqlite3_result_blob(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void)0);
  ((void)0);
  setResultStrOrError(pCtx, z, n, 0, xDel);
}
 void sqlite3_result_blob64(
  sqlite3_context *pCtx,
  const void *z,
  sqlite3_uint64 n,
  void (*xDel)(void *)
){
  ((void)0);
  ((void)0);
  if( n>0x7fffffff ){
    (void)invokeValueDestructor(z, xDel, pCtx);
  }else{
    setResultStrOrError(pCtx, z, (int)n, 0, xDel);
  }
}
 void sqlite3_result_double(sqlite3_context *pCtx, double rVal){
  ((void)0);
  sqlite3VdbeMemSetDouble(pCtx->pOut, rVal);
}
 void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){
  ((void)0);
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, 1, ((sqlite3_destructor_type)-1));
}

 void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){
  ((void)0);
  pCtx->isError = 1;
  sqlite3VdbeMemSetStr(pCtx->pOut, z, n, 2, ((sqlite3_destructor_type)-1));
}

 void sqlite3_result_int(sqlite3_context *pCtx, int iVal){
  ((void)0);
  sqlite3VdbeMemSetInt64(pCtx->pOut, (i64)iVal);
}
 void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){
  ((void)0);
  sqlite3VdbeMemSetInt64(pCtx->pOut, iVal);
}
 void sqlite3_result_null(sqlite3_context *pCtx){
  ((void)0);
  sqlite3VdbeMemSetNull(pCtx->pOut);
}
 void sqlite3_result_pointer(
  sqlite3_context *pCtx,
  void *pPtr,
  const char *zPType,
  void (*xDestructor)(void*)
){
  Mem *pOut = pCtx->pOut;
  ((void)0);
  sqlite3VdbeMemRelease(pOut);
  pOut->flags = 0x0001;
  sqlite3VdbeMemSetPointer(pOut, pPtr, zPType, xDestructor);
}
 void sqlite3_result_subtype(sqlite3_context *pCtx, unsigned int eSubtype){
  Mem *pOut = pCtx->pOut;
  ((void)0);
  pOut->eSubtype = eSubtype & 0xff;
  pOut->flags |= 0x8000;
}
 void sqlite3_result_text(
  sqlite3_context *pCtx,
  const char *z,
  int n,
  void (*xDel)(void *)
){
  ((void)0);
  setResultStrOrError(pCtx, z, n, 1, xDel);
}
 void sqlite3_result_text64(
  sqlite3_context *pCtx,
  const char *z,
  sqlite3_uint64 n,
  void (*xDel)(void *),
  unsigned char enc
){
  ((void)0);
  ((void)0);
  if( enc==4 ) enc = 2;
  if( n>0x7fffffff ){
    (void)invokeValueDestructor(z, xDel, pCtx);
  }else{
    setResultStrOrError(pCtx, z, (int)n, enc, xDel);
  }
}

 void sqlite3_result_text16(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void)0);
  setResultStrOrError(pCtx, z, n, 2, xDel);
}
 void sqlite3_result_text16be(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void)0);
  setResultStrOrError(pCtx, z, n, 3, xDel);
}
 void sqlite3_result_text16le(
  sqlite3_context *pCtx,
  const void *z,
  int n,
  void (*xDel)(void *)
){
  ((void)0);
  setResultStrOrError(pCtx, z, n, 2, xDel);
}

 void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){
  ((void)0);
  sqlite3VdbeMemCopy(pCtx->pOut, pValue);
}
 void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){
  ((void)0);
  sqlite3VdbeMemSetZeroBlob(pCtx->pOut, n);
}
 int sqlite3_result_zeroblob64(sqlite3_context *pCtx, u64 n){
  Mem *pOut = pCtx->pOut;
  ((void)0);
  if( n>(u64)pOut->db->aLimit[0] ){
    return 18;
  }
  sqlite3VdbeMemSetZeroBlob(pCtx->pOut, (int)n);
  return 0;
}
 void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){
  pCtx->isError = errCode ? errCode : -1;



  if( pCtx->pOut->flags & 0x0001 ){
    sqlite3VdbeMemSetStr(pCtx->pOut, sqlite3ErrStr(errCode), -1,
                         1, ((sqlite3_destructor_type)0));
  }
}


 void sqlite3_result_error_toobig(sqlite3_context *pCtx){
  ((void)0);
  pCtx->isError = 18;
  sqlite3VdbeMemSetStr(pCtx->pOut, "string or blob too big", -1,
                       1, ((sqlite3_destructor_type)0));
}


 void sqlite3_result_error_nomem(sqlite3_context *pCtx){
  ((void)0);
  sqlite3VdbeMemSetNull(pCtx->pOut);
  pCtx->isError = 7;
  sqlite3OomFault(pCtx->pOut->db);
}






static void sqlite3ResultIntReal(sqlite3_context *pCtx){
  ((void)0);
  if( pCtx->pOut->flags & 0x0004 ){
    pCtx->pOut->flags &= ~0x0004;
    pCtx->pOut->flags |= 0x0020;
  }
}







static int doWalCallbacks(sqlite3 *db){
  int rc = 0;

  int i;
  for(i=0; i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      int nEntry;
      sqlite3BtreeEnter(pBt);
      nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));
      sqlite3BtreeLeave(pBt);
      if( nEntry>0 && db->xWalCallback && rc==0 ){
        rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zDbSName, nEntry);
      }
    }
  }

  return rc;
}
# 82218 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Step(Vdbe *p){
  sqlite3 *db;
  int rc;

  ((void)0);
  if( p->magic!=0x2df20da3 ){
# 82247 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    sqlite3_reset((sqlite3_stmt*)p);

  }


  db = p->db;
  if( db->mallocFailed ){
    p->rc = 7;
    return 7;
  }

  if( p->pc<0 && p->expired ){
    p->rc = 17;
    rc = 1;
    goto end_of_step;
  }
  if( p->pc<0 ){




    if( db->nVdbeActive==0 ){
      db->u1.isInterrupted = 0;
    }

    ((void)0)

     ;


    if( (db->mTrace & (0x02|0x80))!=0
        && !db->init.busy && p->zSql ){
      sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);
    }else{
      ((void)0);
    }


    db->nVdbeActive++;
    if( p->readOnly==0 ) db->nVdbeWrite++;
    if( p->bIsReader ) db->nVdbeRead++;
    p->pc = 0;
  }




  if( p->explain ){
    rc = sqlite3VdbeList(p);
  }else

  {
    db->nVdbeExec++;
    rc = sqlite3VdbeExec(p);
    db->nVdbeExec--;
  }

  if( rc!=100 ){


    if( ((p)->startTime)>0 ){ invokeProfileCallback(db,p); };


    if( rc==101 && db->autoCommit ){
      ((void)0);
      p->rc = doWalCallbacks(db);
      if( p->rc!=0 ){
        rc = 1;
      }
    }
  }

  db->errCode = rc;
  if( 7==sqlite3ApiExit(p->db, p->rc) ){
    p->rc = 7;
  }
end_of_step:







  ((void)0)

   ;
  ((void)0);
  if( rc!=100
   && rc!=101
   && (p->prepFlags & 0x80)!=0
  ){




    rc = sqlite3VdbeTransferError(p);
  }
  return (rc&db->errMask);
}






 int sqlite3_step(sqlite3_stmt *pStmt){
  int rc = 0;
  Vdbe *v = (Vdbe*)pStmt;
  int cnt = 0;
  sqlite3 *db;

  if( vdbeSafetyNotNull(v) ){
    return sqlite3MisuseError(82360);
  }
  db = v->db;
  sqlite3_mutex_enter(db->mutex);
  v->doingRerun = 0;
  while( (rc = sqlite3Step(v))==17
         && cnt++ < 50 ){
    int savedPc = v->pc;
    rc = sqlite3Reprepare(v);
    if( rc!=0 ){
# 82378 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      const char *zErr = (const char *)sqlite3_value_text(db->pErr);
      sqlite3DbFree(db, v->zErrMsg);
      if( !db->mallocFailed ){
        v->zErrMsg = sqlite3DbStrDup(db, zErr);
        v->rc = rc = sqlite3ApiExit(db, rc);
      } else {
        v->zErrMsg = 0;
        v->rc = rc = 7;
      }
      break;
    }
    sqlite3_reset(pStmt);
    if( savedPc>=0 ) v->doingRerun = 1;
    ((void)0);
  }
  sqlite3_mutex_leave(db->mutex);
  return rc;
}






 void *sqlite3_user_data(sqlite3_context *p){
  ((void)0);
  return p->pFunc->pUserData;
}
# 82417 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){
  ((void)0);
  return p->pOut->db;
}
# 82436 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_vtab_nochange(sqlite3_context *p){
  ((void)0);
  return sqlite3_value_nochange(p->pOut);
}
# 82448 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_int64 sqlite3StmtCurrentTime(sqlite3_context *p){
  int rc;

  sqlite3_int64 *piTime = &p->pVdbe->iCurrentTime;
  ((void)0);




  if( *piTime==0 ){
    rc = sqlite3OsCurrentTimeInt64(p->pOut->db->pVfs, piTime);
    if( rc ) *piTime = 0;
  }
  return *piTime;
}





static __attribute__((noinline)) void *createAggContext(sqlite3_context *p, int nByte){
  Mem *pMem = p->pMem;
  ((void)0);
  if( nByte<=0 ){
    sqlite3VdbeMemSetNull(pMem);
    pMem->z = 0;
  }else{
    sqlite3VdbeMemClearAndResize(pMem, nByte);
    pMem->flags = 0x2000;
    pMem->u.pDef = p->pFunc;
    if( pMem->z ){
      memset(pMem->z, 0, nByte);
    }
  }
  return (void*)pMem->z;
}






 void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){
  ((void)0);
  ((void)0);
  ;
  if( (p->pMem->flags & 0x2000)==0 ){
    return createAggContext(p, nByte);
  }else{
    return (void*)p->pMem->z;
  }
}
# 82511 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){
  AuxData *pAuxData;

  ((void)0);



  ((void)0);

  for(pAuxData=pCtx->pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){
    if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
      return pAuxData->pAux;
    }
  }
  return 0;
}
# 82539 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_set_auxdata(
  sqlite3_context *pCtx,
  int iArg,
  void *pAux,
  void (*xDelete)(void*)
){
  AuxData *pAuxData;
  Vdbe *pVdbe = pCtx->pVdbe;

  ((void)0);



  ((void)0);


  for(pAuxData=pVdbe->pAuxData; pAuxData; pAuxData=pAuxData->pNextAux){
    if( pAuxData->iAuxArg==iArg && (pAuxData->iAuxOp==pCtx->iOp || iArg<0) ){
      break;
    }
  }
  if( pAuxData==0 ){
    pAuxData = sqlite3DbMallocZero(pVdbe->db, sizeof(AuxData));
    if( !pAuxData ) goto failed;
    pAuxData->iAuxOp = pCtx->iOp;
    pAuxData->iAuxArg = iArg;
    pAuxData->pNextAux = pVdbe->pAuxData;
    pVdbe->pAuxData = pAuxData;
    if( pCtx->isError==0 ) pCtx->isError = -1;
  }else if( pAuxData->xDeleteAux ){
    pAuxData->xDeleteAux(pAuxData->pAux);
  }

  pAuxData->pAux = pAux;
  pAuxData->xDeleteAux = xDelete;
  return;

failed:
  if( xDelete ){
    xDelete(pAux);
  }
}
# 82592 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_aggregate_count(sqlite3_context *p){
  ((void)0);
  return p->pMem->n;
}





 int sqlite3_column_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  return pVm ? pVm->nResColumn : 0;
}





 int sqlite3_data_count(sqlite3_stmt *pStmt){
  Vdbe *pVm = (Vdbe *)pStmt;
  if( pVm==0 || pVm->pResultSet==0 ) return 0;
  return pVm->nResColumn;
}




static const Mem *columnNullValue(void){
# 82629 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  static const Mem nullMem



    = {
                            {0},
                            (u16)0x0001,
                            (u8)0,
                            (u8)0,
                            (int)0,
                            (char*)0,
                            (char*)0,
                            (int)0,
                            (u32)0,
                            (sqlite3*)0,
                            (void(*)(void*))0,




      };
  return &nullMem;
}







static Mem *columnMem(sqlite3_stmt *pStmt, int i){
  Vdbe *pVm;
  Mem *pOut;

  pVm = (Vdbe *)pStmt;
  if( pVm==0 ) return (Mem*)columnNullValue();
  ((void)0);
  sqlite3_mutex_enter(pVm->db->mutex);
  if( pVm->pResultSet!=0 && i<pVm->nResColumn && i>=0 ){
    pOut = &pVm->pResultSet[i];
  }else{
    sqlite3Error(pVm->db, 25);
    pOut = (Mem*)columnNullValue();
  }
  return pOut;
}
# 82694 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void columnMallocFailure(sqlite3_stmt *pStmt)
{





  Vdbe *p = (Vdbe *)pStmt;
  if( p ){
    ((void)0);
    ((void)0);
    p->rc = sqlite3ApiExit(p->db, p->rc);
    sqlite3_mutex_leave(p->db->mutex);
  }
}





 const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){
  const void *val;
  val = sqlite3_value_blob( columnMem(pStmt,i) );




  columnMallocFailure(pStmt);
  return val;
}
 int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
 int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_bytes16( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
 double sqlite3_column_double(sqlite3_stmt *pStmt, int i){
  double val = sqlite3_value_double( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
 int sqlite3_column_int(sqlite3_stmt *pStmt, int i){
  int val = sqlite3_value_int( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
 sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){
  sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
 const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){
  const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}
 sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){
  Mem *pOut = columnMem(pStmt, i);
  if( pOut->flags&0x0800 ){
    pOut->flags &= ~0x0800;
    pOut->flags |= 0x1000;
  }
  columnMallocFailure(pStmt);
  return (sqlite3_value *)pOut;
}

 const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){
  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return val;
}

 int sqlite3_column_type(sqlite3_stmt *pStmt, int i){
  int iType = sqlite3_value_type( columnMem(pStmt,i) );
  columnMallocFailure(pStmt);
  return iType;
}
# 82792 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const void *columnName(
  sqlite3_stmt *pStmt,
  int N,
  int useUtf16,
  int useType
){
  const void *ret;
  Vdbe *p;
  int n;
  sqlite3 *db;






  ret = 0;
  p = (Vdbe *)pStmt;
  db = p->db;
  ((void)0);
  n = sqlite3_column_count(pStmt);
  if( N<n && N>=0 ){
    N += useType*n;
    sqlite3_mutex_enter(db->mutex);
    ((void)0);

    if( useUtf16 ){
      ret = sqlite3_value_text16((sqlite3_value*)&p->aColName[N]);
    }else

    {
      ret = sqlite3_value_text((sqlite3_value*)&p->aColName[N]);
    }



    if( db->mallocFailed ){
      sqlite3OomClear(db);
      ret = 0;
    }
    sqlite3_mutex_leave(db->mutex);
  }
  return ret;
}





 const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, 0);
}

 const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, 0);
}
# 82864 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 0, 1);
}

 const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){
  return columnName(pStmt, N, 1, 1);
}
# 82934 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeUnbind(Vdbe *p, int i){
  Mem *pVar;
  if( vdbeSafetyNotNull(p) ){
    return sqlite3MisuseError(82937);
  }
  sqlite3_mutex_enter(p->db->mutex);
  if( p->magic!=0x2df20da3 || p->pc>=0 ){
    sqlite3Error(p->db, 21);
    sqlite3_mutex_leave(p->db->mutex);
    sqlite3_log(21,
        "bind on a busy prepared statement: [%s]", p->zSql);
    return sqlite3MisuseError(82945);
  }
  if( i<1 || i>p->nVar ){
    sqlite3Error(p->db, 25);
    sqlite3_mutex_leave(p->db->mutex);
    return 25;
  }
  i--;
  pVar = &p->aVar[i];
  sqlite3VdbeMemRelease(pVar);
  pVar->flags = 0x0001;
  p->db->errCode = 0;
# 82967 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( p->expmask!=0 && (p->expmask & (i>=31 ? 0x80000000 : (u32)1<<i))!=0 ){
    p->expired = 1;
  }
  return 0;
}




static int bindText(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*),
  u8 encoding
){
  Vdbe *p = (Vdbe *)pStmt;
  Mem *pVar;
  int rc;

  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    if( zData!=0 ){
      pVar = &p->aVar[i-1];
      rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);
      if( rc==0 && encoding!=0 ){
        rc = sqlite3VdbeChangeEncoding(pVar, ((p->db)->enc));
      }
      if( rc ){
        sqlite3Error(p->db, rc);
        rc = sqlite3ApiExit(p->db, rc);
      }
    }
    sqlite3_mutex_leave(p->db->mutex);
  }else if( xDel!=((sqlite3_destructor_type)0) && xDel!=((sqlite3_destructor_type)-1) ){
    xDel((void*)zData);
  }
  return rc;
}





 int sqlite3_bind_blob(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*)
){



  return bindText(pStmt, i, zData, nData, xDel, 0);
}
 int sqlite3_bind_blob64(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*)
){
  ((void)0);
  if( nData>0x7fffffff ){
    return invokeValueDestructor(zData, xDel, 0);
  }else{
    return bindText(pStmt, i, zData, (int)nData, xDel, 0);
  }
}
 int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
 int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){
  return sqlite3_bind_int64(p, i, (i64)iValue);
}
 int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
 int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
 int sqlite3_bind_pointer(
  sqlite3_stmt *pStmt,
  int i,
  void *pPtr,
  const char *zPTtype,
  void (*xDestructor)(void*)
){
  int rc;
  Vdbe *p = (Vdbe*)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3VdbeMemSetPointer(&p->aVar[i-1], pPtr, zPTtype, xDestructor);
    sqlite3_mutex_leave(p->db->mutex);
  }else if( xDestructor ){
    xDestructor(pPtr);
  }
  return rc;
}
 int sqlite3_bind_text(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  int nData,
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, 1);
}
 int sqlite3_bind_text64(
  sqlite3_stmt *pStmt,
  int i,
  const char *zData,
  sqlite3_uint64 nData,
  void (*xDel)(void*),
  unsigned char enc
){
  ((void)0);
  if( nData>0x7fffffff ){
    return invokeValueDestructor(zData, xDel, 0);
  }else{
    if( enc==4 ) enc = 2;
    return bindText(pStmt, i, zData, (int)nData, xDel, enc);
  }
}

 int sqlite3_bind_text16(
  sqlite3_stmt *pStmt,
  int i,
  const void *zData,
  int nData,
  void (*xDel)(void*)
){
  return bindText(pStmt, i, zData, nData, xDel, 2);
}

 int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){
  int rc;
  switch( sqlite3_value_type((sqlite3_value*)pValue) ){
    case 1: {
      rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);
      break;
    }
    case 2: {
      rc = sqlite3_bind_double(pStmt, i, pValue->u.r);
      break;
    }
    case 4: {
      if( pValue->flags & 0x4000 ){
        rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);
      }else{
        rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,((sqlite3_destructor_type)-1));
      }
      break;
    }
    case 3: {
      rc = bindText(pStmt,i, pValue->z, pValue->n, ((sqlite3_destructor_type)-1),
                              pValue->enc);
      break;
    }
    default: {
      rc = sqlite3_bind_null(pStmt, i);
      break;
    }
  }
  return rc;
}
 int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  rc = vdbeUnbind(p, i);
  if( rc==0 ){
    sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return rc;
}
 int sqlite3_bind_zeroblob64(sqlite3_stmt *pStmt, int i, sqlite3_uint64 n){
  int rc;
  Vdbe *p = (Vdbe *)pStmt;
  sqlite3_mutex_enter(p->db->mutex);
  if( n>(u64)p->db->aLimit[0] ){
    rc = 18;
  }else{
    ((void)0);
    rc = sqlite3_bind_zeroblob(pStmt, i, n);
  }
  rc = sqlite3ApiExit(p->db, rc);
  sqlite3_mutex_leave(p->db->mutex);
  return rc;
}





 int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe*)pStmt;
  return p ? p->nVar : 0;
}







 const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){
  Vdbe *p = (Vdbe*)pStmt;
  if( p==0 ) return 0;
  return sqlite3VListNumToName(p->pVList, i);
}






static int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){
  if( p==0 || zName==0 ) return 0;
  return sqlite3VListNameToNum(p->pVList, zName, nName);
}
 int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){
  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));
}




static int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  int i;
  ((void)0);
  ((void)0);
  sqlite3_mutex_enter(pTo->db->mutex);
  for(i=0; i<pFrom->nVar; i++){
    sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);
  }
  sqlite3_mutex_leave(pTo->db->mutex);
  return 0;
}
# 83245 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){
  Vdbe *pFrom = (Vdbe*)pFromStmt;
  Vdbe *pTo = (Vdbe*)pToStmt;
  if( pFrom->nVar!=pTo->nVar ){
    return 1;
  }
  ((void)0);
  if( pTo->expmask ){
    pTo->expired = 1;
  }
  ((void)0);
  if( pFrom->expmask ){
    pFrom->expired = 1;
  }
  return sqlite3TransferBindings(pFromStmt, pToStmt);
}
# 83269 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->db : 0;
}





 int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;
}





 int sqlite3_stmt_isexplain(sqlite3_stmt *pStmt){
  return pStmt ? ((Vdbe*)pStmt)->explain : 0;
}




 int sqlite3_stmt_busy(sqlite3_stmt *pStmt){
  Vdbe *v = (Vdbe*)pStmt;
  return v!=0 && v->magic==0x2df20da3 && v->pc>=0;
}







 sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){
  sqlite3_stmt *pNext;






  sqlite3_mutex_enter(pDb->mutex);
  if( pStmt==0 ){
    pNext = (sqlite3_stmt*)pDb->pVdbe;
  }else{
    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext;
  }
  sqlite3_mutex_leave(pDb->mutex);
  return pNext;
}




 int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){
  Vdbe *pVdbe = (Vdbe*)pStmt;
  u32 v;
# 83335 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( op==99 ){
    sqlite3 *db = pVdbe->db;
    sqlite3_mutex_enter(db->mutex);
    v = 0;
    db->pnBytesFreed = (int*)&v;
    sqlite3VdbeClearObject(db, pVdbe);
    sqlite3DbFree(db, pVdbe);
    db->pnBytesFreed = 0;
    sqlite3_mutex_leave(db->mutex);
  }else{
    v = pVdbe->aCounter[op];
    if( resetFlag ) pVdbe->aCounter[op] = 0;
  }
  return (int)v;
}




 const char *sqlite3_sql(sqlite3_stmt *pStmt){
  Vdbe *p = (Vdbe *)pStmt;
  return p ? p->zSql : 0;
}
# 83368 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_expanded_sql(sqlite3_stmt *pStmt){



  char *z = 0;
  const char *zSql = sqlite3_sql(pStmt);
  if( zSql ){
    Vdbe *p = (Vdbe *)pStmt;
    sqlite3_mutex_enter(p->db->mutex);
    z = sqlite3VdbeExpandSql(p, zSql);
    sqlite3_mutex_leave(p->db->mutex);
  }
  return z;

}
# 83687 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int findNextHostParameter(const char *zSql, int *pnToken){
  int tokenType;
  int nTotal = 0;
  int n;

  *pnToken = 0;
  while( zSql[0] ){
    n = sqlite3GetToken((u8*)zSql, &tokenType);
    ((void)0);
    if( tokenType==151 ){
      *pnToken = n;
      break;
    }
    nTotal += n;
    zSql += n;
  }
  return nTotal;
}
# 83730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *sqlite3VdbeExpandSql(
  Vdbe *p,
  const char *zRawSql
){
  sqlite3 *db;
  int idx = 0;
  int nextIndex = 1;
  int n;
  int nToken;
  int i;
  Mem *pVar;
  StrAccum out;

  Mem utf8;

  char zBase[100];

  db = p->db;
  sqlite3StrAccumInit(&out, 0, zBase, sizeof(zBase),
                      db->aLimit[0]);
  if( db->nVdbeExec>1 ){
    while( *zRawSql ){
      const char *zStart = zRawSql;
      while( *(zRawSql++)!='\n' && *zRawSql );
      sqlite3_str_append(&out, "-- ", 3);
      ((void)0);
      sqlite3_str_append(&out, zStart, (int)(zRawSql-zStart));
    }
  }else if( p->nVar==0 ){
    sqlite3_str_append(&out, zRawSql, sqlite3Strlen30(zRawSql));
  }else{
    while( zRawSql[0] ){
      n = findNextHostParameter(zRawSql, &nToken);
      ((void)0);
      sqlite3_str_append(&out, zRawSql, n);
      zRawSql += n;
      ((void)0);
      if( nToken==0 ) break;
      if( zRawSql[0]=='?' ){
        if( nToken>1 ){
          ((void)0);
          sqlite3GetInt32(&zRawSql[1], &idx);
        }else{
          idx = nextIndex;
        }
      }else{
        ((void)0)
                                                    ;
        ;
        ;
        ;
        ;
        idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);
        ((void)0);
      }
      zRawSql += nToken;
      nextIndex = idx + 1;
      ((void)0);
      pVar = &p->aVar[idx-1];
      if( pVar->flags & 0x0001 ){
        sqlite3_str_append(&out, "NULL", 4);
      }else if( pVar->flags & (0x0004|0x0020) ){
        sqlite3_str_appendf(&out, "%lld", pVar->u.i);
      }else if( pVar->flags & 0x0008 ){
        sqlite3_str_appendf(&out, "%!.15g", pVar->u.r);
      }else if( pVar->flags & 0x0002 ){
        int nOut;

        u8 enc = ((db)->enc);
        if( enc!=1 ){
          memset(&utf8, 0, sizeof(utf8));
          utf8.db = db;
          sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, ((sqlite3_destructor_type)0));
          if( 7==sqlite3VdbeChangeEncoding(&utf8, 1) ){
            out.accError = 7;
            out.nAlloc = 0;
          }
          pVar = &utf8;
        }

        nOut = pVar->n;






        sqlite3_str_appendf(&out, "'%.*q'", nOut, pVar->z);






        if( enc!=1 ) sqlite3VdbeMemRelease(&utf8);

      }else if( pVar->flags & 0x4000 ){
        sqlite3_str_appendf(&out, "zeroblob(%d)", pVar->u.nZero);
      }else{
        int nOut;
        ((void)0);
        sqlite3_str_append(&out, "x'", 2);
        nOut = pVar->n;



        for(i=0; i<nOut; i++){
          sqlite3_str_appendf(&out, "%02x", pVar->z[i]&0xff);
        }
        sqlite3_str_append(&out, "'", 1);





      }
    }
  }
  if( out.accError ) sqlite3_str_reset(&out);
  return sqlite3StrAccumFinish(&out);
}
# 83891 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define memAboutToChange(P,M) 
# 83951 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define HAS_UPDATE_HOOK(DB) ((DB)->xUpdateCallback)
# 83972 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define UPDATE_MAX_BLOBSIZE(P) 
# 84013 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define VdbeBranchTaken(I,M) 
# 84064 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define Deephemeralize(P) if( ((P)->flags&MEM_Ephem)!=0 && sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}




#define isSorter(x) ((x)->eCurType==CURTYPE_SORTER)





static VdbeCursor *allocateCursor(
  Vdbe *p,
  int iCur,
  int nField,
  int iDb,
  u8 eCurType
){
# 84100 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  Mem *pMem = iCur>0 ? &p->aMem[p->nMem-iCur] : p->aMem;

  int nByte;
  VdbeCursor *pCx = 0;
  nByte =
      (((sizeof(VdbeCursor))+7)&~7) + 2*sizeof(u32)*nField +
      (eCurType==0?sqlite3BtreeCursorSize():0);

  ((void)0);
  if( p->apCsr[iCur] ){




    if( p->apCsr[iCur]->pBtx==0 ) p->apCsr[iCur]->isEphemeral = 0;
    sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);
    p->apCsr[iCur] = 0;
  }
  if( 0==sqlite3VdbeMemClearAndResize(pMem, nByte) ){
    p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;
    memset(pCx, 0, __builtin_offsetof(VdbeCursor,pAltCursor));
    pCx->eCurType = eCurType;
    pCx->iDb = iDb;
    pCx->nField = nField;
    pCx->aOffset = &pCx->aType[nField];
    if( eCurType==0 ){
      pCx->uc.pCursor = (BtCursor*)
          &pMem->z[(((sizeof(VdbeCursor))+7)&~7)+2*sizeof(u32)*nField];
      sqlite3BtreeCursorZero(pCx->uc.pCursor);
    }
  }
  return pCx;
}







static int alsoAnInt(Mem *pRec, double rValue, i64 *piValue){
  i64 iValue = (double)rValue;
  if( sqlite3RealSameAsInt(rValue,iValue) ){
    *piValue = iValue;
    return 1;
  }
  return 0==sqlite3Atoi64(pRec->z, piValue, pRec->n, pRec->enc);
}
# 84164 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void applyNumericAffinity(Mem *pRec, int bTryForInt){
  double rValue;
  u8 enc = pRec->enc;
  int rc;
  ((void)0);
  rc = sqlite3AtoF(pRec->z, &rValue, pRec->n, enc);
  if( rc<=0 ) return;
  if( rc==1 && alsoAnInt(pRec, rValue, &pRec->u.i) ){
    pRec->flags |= 0x0004;
  }else{
    pRec->u.r = rValue;
    pRec->flags |= 0x0008;
    if( bTryForInt ) sqlite3VdbeIntegerAffinity(pRec);
  }




  pRec->flags &= ~0x0002;
}
# 84204 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void applyAffinity(
  Mem *pRec,
  char affinity,
  u8 enc
){
  if( affinity>=0x43 ){
    ((void)0)
                                              ;
    if( (pRec->flags & 0x0004)==0 ){
      if( (pRec->flags & 0x0008)==0 ){
        if( pRec->flags & 0x0002 ) applyNumericAffinity(pRec,1);
      }else{
        sqlite3VdbeIntegerAffinity(pRec);
      }
    }
  }else if( affinity==0x42 ){





    if( 0==(pRec->flags&0x0002) ){
      if( (pRec->flags&(0x0008|0x0004|0x0020)) ){
        ;
        ;
        ;
        sqlite3VdbeMemStringify(pRec, enc, 1);
      }
    }
    pRec->flags &= ~(0x0008|0x0004|0x0020);
  }
}







 int sqlite3_value_numeric_type(sqlite3_value *pVal){
  int eType = sqlite3_value_type(pVal);
  if( eType==3 ){
    Mem *pMem = (Mem*)pVal;
    applyNumericAffinity(pMem, 0);
    eType = sqlite3_value_type(pVal);
  }
  return eType;
}





static void sqlite3ValueApplyAffinity(
  sqlite3_value *pVal,
  u8 affinity,
  u8 enc
){
  applyAffinity((Mem *)pVal, affinity, enc);
}







static u16 __attribute__((noinline)) computeNumericType(Mem *pMem){
  int rc;
  sqlite3_int64 ix;
  ((void)0);
  ((void)0);
  (((pMem)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pMem):0);
  rc = sqlite3AtoF(pMem->z, &pMem->u.r, pMem->n, pMem->enc);
  if( rc<=0 ){
    if( rc==0 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)<=1 ){
      pMem->u.i = ix;
      return 0x0004;
    }else{
      return 0x0008;
    }
  }else if( rc==1 && sqlite3Atoi64(pMem->z, &ix, pMem->n, pMem->enc)==0 ){
    pMem->u.i = ix;
    return 0x0004;
  }
  return 0x0008;
}
# 84299 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u16 numericType(Mem *pMem){
  if( pMem->flags & (0x0004|0x0008|0x0020) ){
    ;
    ;
    ;
    return pMem->flags & (0x0004|0x0008|0x0020);
  }
  if( pMem->flags & (0x0002|0x0010) ){
    ;
    ;
    return computeNumericType(pMem);
  }
  return 0;
}
# 84434 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define REGISTER_TRACE(R,M) 
# 84561 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) Mem *out2PrereleaseWithClear(Mem *pOut){
  sqlite3VdbeMemSetNull(pOut);
  pOut->flags = 0x0004;
  return pOut;
}
static Mem *out2Prerelease(Vdbe *p, VdbeOp *pOp){
  Mem *pOut;
  ((void)0);
  ((void)0);
  pOut = &p->aMem[pOp->p2];
  ;
  if( (((pOut)->flags&(0x2000|0x0400))!=0) ){
    return out2PrereleaseWithClear(pOut);
  }else{
    pOut->flags = 0x0004;
    return pOut;
  }
}






static int sqlite3VdbeExec(
  Vdbe *p
){
  Op *aOp = p->aOp;
  Op *pOp = aOp;






  int rc = 0;
  sqlite3 *db = p->db;
  u8 resetSchemaOnFault = 0;
  u8 encoding = ((db)->enc);
  int iCompare = 0;
  unsigned nVmStep = 0;

  unsigned nProgressLimit;

  Mem *aMem = p->aMem;
  Mem *pIn1 = 0;
  Mem *pIn2 = 0;
  Mem *pIn3 = 0;
  Mem *pOut = 0;





  ((void)0);
  sqlite3VdbeEnter(p);

  if( db->xProgress ){
    u32 iPrior = p->aCounter[4];
    ((void)0);
    nProgressLimit = db->nProgressOps - (iPrior % db->nProgressOps);
  }else{
    nProgressLimit = 0xffffffff;
  }

  if( p->rc==7 ){


    goto no_mem;
  }
  ((void)0);
  ((void)0);
  p->iCurrentTime = 0;
  ((void)0);
  p->pResultSet = 0;
  db->busyHandler.nBusy = 0;
  if( db->u1.isInterrupted ) goto abort_due_to_interrupt;
  ;
# 84666 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(pOp=&aOp[p->pc]; 1; pOp++){


    ((void)0);

    ((void)0);



    nVmStep++;
# 84742 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    switch( pOp->opcode ){
# 84791 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 11: {
jump_to_p2_and_check_for_interrupt:
  pOp = &aOp[pOp->p2 - 1];
# 84805 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
check_for_interrupt:
  if( db->u1.isInterrupted ) goto abort_due_to_interrupt;







  while( nVmStep>=nProgressLimit && db->xProgress!=0 ){
    ((void)0);
    nProgressLimit += db->nProgressOps;
    if( db->xProgress(db->pProgressArg) ){
      nProgressLimit = 0xffffffff;
      rc = 9;
      goto abort_due_to_error;
    }
  }


  break;
}






case 12: {
  ((void)0);
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  ;
  pIn1->flags = 0x0004;
  pIn1->u.i = (int)(pOp-aOp);
  ;



jump_to_p2:
  pOp = &aOp[pOp->p2 - 1];
  break;
}






case 66: {
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  pOp = &aOp[pIn1->u.i];
  pIn1->flags = 0x0080;
  break;
}
# 84873 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 13: {
  ((void)0);
  ((void)0);
  ((void)0);
  pOut = &aMem[pOp->p1];
  ((void)0);
  pOut->u.i = pOp->p3 - 1;
  pOut->flags = 0x0004;
  if( pOp->p2 ) goto jump_to_p2;
  break;
}
# 84893 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 67: {
  VdbeOp *pCaller;
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  ((void)0);
  pCaller = &aOp[pIn1->u.i];
  ((void)0);
  ((void)0);
  pOp = &aOp[pCaller->p2 - 1];
  pIn1->flags = 0x0080;
  break;
}
# 84919 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 14: {
  int pcDest;
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  pIn1->flags = 0x0004;
  pcDest = (int)pIn1->u.i;
  pIn1->u.i = (int)(pOp - aOp);
  ;
  pOp = &aOp[pcDest];
  break;
}
# 84939 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 68: {
  pIn3 = &aMem[pOp->p3];



  if( (pIn3->flags & 0x0001)==0 ) break;

}
# 84978 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 69: {
  VdbeFrame *pFrame;
  int pcx;

  pcx = (int)(pOp - aOp);



  if( pOp->p1==0 && p->pFrame ){

    pFrame = p->pFrame;
    p->pFrame = pFrame->pParent;
    p->nFrame--;
    sqlite3VdbeSetChanges(db, p->nChange);
    pcx = sqlite3VdbeFrameRestore(pFrame);
    if( pOp->p2==4 ){





      pcx = p->aOp[pcx].p2-1;
    }
    aOp = p->aOp;
    aMem = p->aMem;
    pOp = &aOp[pcx];
    break;
  }
  p->rc = pOp->p1;
  p->errorAction = (u8)pOp->p2;
  p->pc = pcx;
  ((void)0);
  if( p->rc ){
    if( pOp->p5 ){
      static const char * const azType[] = { "NOT NULL", "UNIQUE", "CHECK",
                                             "FOREIGN KEY" };
      ;
      ;
      ;
      ;
      sqlite3VdbeError(p, "%s constraint failed", azType[pOp->p5-1]);
      if( pOp->p4.z ){
        p->zErrMsg = sqlite3MPrintf(db, "%z: %s", p->zErrMsg, pOp->p4.z);
      }
    }else{
      sqlite3VdbeError(p, "%s", pOp->p4.z);
    }
    sqlite3_log(pOp->p1, "abort at %d in [%s]: %s", pcx, p->zSql, p->zErrMsg);
  }
  rc = sqlite3VdbeHalt(p);
  ((void)0);
  if( rc==5 ){
    p->rc = 5;
  }else{
    ((void)0);
    ((void)0);
    rc = p->rc ? 1 : 101;
  }
  goto vdbe_return;
}






case 70: {
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = pOp->p1;
  break;
}







case 71: {
  pOut = out2Prerelease(p, pOp);
  ((void)0);
  pOut->u.i = *pOp->p4.pI64;
  break;
}
# 85070 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 148: {
  pOut = out2Prerelease(p, pOp);
  pOut->flags = 0x0008;
  ((void)0);
  pOut->u.r = *pOp->p4.pReal;
  break;
}
# 85087 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 113: {
  ((void)0);
  pOut = out2Prerelease(p, pOp);
  pOp->p1 = sqlite3Strlen30(pOp->p4.z);


  if( encoding!=1 ){
    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, 1, ((sqlite3_destructor_type)0));
    ((void)0);
    if( rc ) goto too_big;
    if( 0!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem;
    ((void)0);
    ((void)0);
    pOut->szMalloc = 0;
    pOut->flags |= 0x0800;
    if( pOp->p4type==(-7) ){
      sqlite3DbFree(db, pOp->p4.z);
    }
    pOp->p4type = (-7);
    pOp->p4.z = pOut->z;
    pOp->p1 = pOut->n;
  }

  if( pOp->p1>db->aLimit[0] ){
    goto too_big;
  }
  pOp->opcode = 72;
  ((void)0);

}
# 85130 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 72: {
  ((void)0);
  pOut = out2Prerelease(p, pOp);
  pOut->flags = 0x0002|0x0800|0x0200;
  pOut->z = pOp->p4.z;
  pOut->n = pOp->p1;
  pOut->enc = encoding;
  ;

  if( pOp->p3>0 ){
    ((void)0);
    pIn3 = &aMem[pOp->p3];
    ((void)0);
    if( pIn3->u.i==pOp->p5 ) pOut->flags = 0x0010|0x0800|0x0200;
  }

  break;
}
# 85161 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 73: {
  int cnt;
  u16 nullFlag;
  pOut = out2Prerelease(p, pOp);
  cnt = pOp->p3-pOp->p2;
  ((void)0);
  pOut->flags = nullFlag = pOp->p1 ? (0x0001|0x0100) : 0x0001;
  pOut->n = 0;



  while( cnt>0 ){
    pOut++;
    ;
    sqlite3VdbeMemSetNull(pOut);
    pOut->flags = nullFlag;
    pOut->n = 0;
    cnt--;
  }
  break;
}
# 85191 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 74: {
  ((void)0);
  pOut = &aMem[pOp->p1];
  pOut->flags = (pOut->flags&~(0x0080|0x003f))|0x0001;
  break;
}







case 75: {
  ((void)0);
  pOut = out2Prerelease(p, pOp);
  sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);
  pOut->enc = encoding;
  ;
  break;
}
# 85221 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 76: {
  Mem *pVar;

  ((void)0);
  ((void)0);
  pVar = &p->aVar[pOp->p1 - 1];
  if( sqlite3VdbeMemTooBig(pVar) ){
    goto too_big;
  }
  pOut = &aMem[pOp->p2];
  if( (((pOut)->flags&(0x2000|0x0400))!=0) ) sqlite3VdbeMemSetNull(pOut);
  memcpy(pOut, pVar, __builtin_offsetof(Mem,zMalloc));
  pOut->flags &= ~(0x0400|0x1000);
  pOut->flags |= 0x0800|0x0040;
  ;
  break;
}
# 85248 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 77: {
  int n;
  int p1;
  int p2;

  n = pOp->p3;
  p1 = pOp->p1;
  p2 = pOp->p2;
  ((void)0);
  ((void)0);

  pIn1 = &aMem[p1];
  pOut = &aMem[p2];
  do{
    ((void)0);
    ((void)0);
    ((void)0);
    ;
    sqlite3VdbeMemMove(pOut, pIn1);





    if( ((pOut)->flags&0x1000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){ goto no_mem;};
    ;
    pIn1++;
    pOut++;
  }while( --n );
  break;
}
# 85288 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 78: {
  int n;

  n = pOp->p3;
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  ((void)0);
  while( 1 ){
    ;
    sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);
    if( ((pOut)->flags&0x1000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){ goto no_mem;};



    ;
    if( (n--)==0 ) break;
    pOut++;
    pIn1++;
  }
  break;
}
# 85323 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 79: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  ((void)0);
  sqlite3VdbeMemShallowCopy(pOut, pIn1, 0x1000);




  break;
}
# 85343 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 80: {
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  pOut = &aMem[pOp->p2];
  sqlite3VdbeMemSetInt64(pOut, pIn1->u.i);
  break;
}
# 85360 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 81: {
  Mem *pMem;
  int i;
  ((void)0);
  ((void)0);
  ((void)0);




  if( 0!=(rc = sqlite3VdbeCheckFk(p, 0)) ){
    ((void)0);
    ((void)0);
    goto abort_due_to_error;
  }
# 85391 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  rc = sqlite3VdbeCloseStatement(p, 1);
  ((void)0);


  p->cacheCtr = (p->cacheCtr + 2)|1;





  pMem = p->pResultSet = &aMem[pOp->p1];
  for(i=0; i<pOp->p2; i++){
    ((void)0);
    if( ((&pMem[i])->flags&0x1000)!=0 && sqlite3VdbeMemMakeWriteable(&pMem[i]) ){ goto no_mem;};
    ((void)0)
                                                        ;
    sqlite3VdbeMemNulTerminate(&pMem[i]);
    ;
  }
  if( db->mallocFailed ) goto no_mem;

  if( db->mTrace & 0x04 ){
    db->xTrace(0x04, db->pTraceArg, p, 0);
  }



  p->pc = (int)(pOp - aOp) + 1;
  rc = 100;
  goto vdbe_return;
}
# 85437 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 108: {
  i64 nByte;
  u16 flags1;
  u16 flags2;

  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  pOut = &aMem[pOp->p3];
  ;
  ;
  ((void)0);
  flags1 = pIn1->flags;
  ;
  ;
  if( (flags1 | pIn2->flags) & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
    break;
  }
  if( (flags1 & (0x0002|0x0010))==0 ){
    if( sqlite3VdbeMemStringify(pIn1,encoding,0) ) goto no_mem;
    flags1 = pIn1->flags & ~0x0002;
  }else if( (flags1 & 0x4000)!=0 ){
    if( sqlite3VdbeMemExpandBlob(pIn1) ) goto no_mem;
    flags1 = pIn1->flags & ~0x0002;
  }
  flags2 = pIn2->flags;
  if( (flags2 & (0x0002|0x0010))==0 ){
    if( sqlite3VdbeMemStringify(pIn2,encoding,0) ) goto no_mem;
    flags2 = pIn2->flags & ~0x0002;
  }else if( (flags2 & 0x4000)!=0 ){
    if( sqlite3VdbeMemExpandBlob(pIn2) ) goto no_mem;
    flags2 = pIn2->flags & ~0x0002;
  }
  nByte = pIn1->n + pIn2->n;
  if( nByte>db->aLimit[0] ){
    goto too_big;
  }
  if( sqlite3VdbeMemGrow(pOut, (int)nByte+3, pOut==pIn2) ){
    goto no_mem;
  }
  ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0002);
  if( pOut!=pIn2 ){
    memcpy(pOut->z, pIn2->z, pIn2->n);
    ((void)0);
    pIn2->flags = flags2;
  }
  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);
  ((void)0);
  pIn1->flags = flags1;
  pOut->z[nByte]=0;
  pOut->z[nByte+1] = 0;
  pOut->z[nByte+2] = 0;
  pOut->flags |= 0x0200;
  pOut->n = (int)nByte;
  pOut->enc = encoding;
  ;
  break;
}
# 85534 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 103:
case 104:
case 105:
case 106:
case 107: {
  u16 flags;
  u16 type1;
  u16 type2;
  i64 iA;
  i64 iB;
  double rA;
  double rB;

  pIn1 = &aMem[pOp->p1];
  type1 = numericType(pIn1);
  pIn2 = &aMem[pOp->p2];
  type2 = numericType(pIn2);
  pOut = &aMem[pOp->p3];
  flags = pIn1->flags | pIn2->flags;
  if( (type1 & type2 & 0x0004)!=0 ){
    iA = pIn1->u.i;
    iB = pIn2->u.i;
    switch( pOp->opcode ){
      case 103: if( sqlite3AddInt64(&iB,iA) ) goto fp_math; break;
      case 104: if( sqlite3SubInt64(&iB,iA) ) goto fp_math; break;
      case 105: if( sqlite3MulInt64(&iB,iA) ) goto fp_math; break;
      case 106: {
        if( iA==0 ) goto arithmetic_result_is_null;
        if( iA==-1 && iB==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) goto fp_math;
        iB /= iA;
        break;
      }
      default: {
        if( iA==0 ) goto arithmetic_result_is_null;
        if( iA==-1 ) iA = 1;
        iB %= iA;
        break;
      }
    }
    pOut->u.i = iB;
    ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0004);
  }else if( (flags & 0x0001)!=0 ){
    goto arithmetic_result_is_null;
  }else{
fp_math:
    rA = sqlite3VdbeRealValue(pIn1);
    rB = sqlite3VdbeRealValue(pIn2);
    switch( pOp->opcode ){
      case 103: rB += rA; break;
      case 104: rB -= rA; break;
      case 105: rB *= rA; break;
      case 106: {

        if( rA==(double)0 ) goto arithmetic_result_is_null;
        rB /= rA;
        break;
      }
      default: {
        iA = sqlite3VdbeIntValue(pIn1);
        iB = sqlite3VdbeIntValue(pIn2);
        if( iA==0 ) goto arithmetic_result_is_null;
        if( iA==-1 ) iA = 1;
        rB = (double)(iB % iA);
        break;
      }
    }




    if( sqlite3IsNaN(rB) ){
      goto arithmetic_result_is_null;
    }
    pOut->u.r = rB;
    ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0008);

  }
  break;

arithmetic_result_is_null:
  sqlite3VdbeMemSetNull(pOut);
  break;
}
# 85633 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 82: {
  ((void)0);
  if( pOp->p1 ){
    sqlite3VdbeMemSetInt64(&aMem[pOp->p1], 0);
  }
  break;
}
# 85671 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 99:
case 100:
case 101:
case 102: {
  i64 iA;
  u64 uA;
  i64 iB;
  u8 op;

  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  pOut = &aMem[pOp->p3];
  if( (pIn1->flags | pIn2->flags) & 0x0001 ){
    sqlite3VdbeMemSetNull(pOut);
    break;
  }
  iA = sqlite3VdbeIntValue(pIn2);
  iB = sqlite3VdbeIntValue(pIn1);
  op = pOp->opcode;
  if( op==99 ){
    iA &= iB;
  }else if( op==100 ){
    iA |= iB;
  }else if( iB!=0 ){
    ((void)0);


    if( iB<0 ){
      ((void)0);
      op = 2*101 + 1 - op;
      iB = iB>(-64) ? -iB : 64;
    }

    if( iB>=64 ){
      iA = (iA>=0 || op==101) ? 0 : -1;
    }else{
      memcpy(&uA, &iA, sizeof(uA));
      if( op==101 ){
        uA <<= iB;
      }else{
        uA >>= iB;

        if( iA<0 ) uA |= ((((u64)0xffffffff)<<32)|0xffffffff) << (64-iB);
      }
      memcpy(&iA, &uA, sizeof(iA));
    }
  }
  pOut->u.i = iA;
  ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0004);
  break;
}
# 85731 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 83: {
  pIn1 = &aMem[pOp->p1];
  ;
  sqlite3VdbeMemIntegerify(pIn1);
  pIn1->u.i += pOp->p2;
  break;
}
# 85746 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 15: {
  pIn1 = &aMem[pOp->p1];
  if( (pIn1->flags & 0x0004)==0 ){
    applyAffinity(pIn1, 0x43, encoding);
    if( (pIn1->flags & 0x0004)==0 ){
      ;
      if( pOp->p2==0 ){
        rc = 20;
        goto abort_due_to_error;
      }else{
        goto jump_to_p2;
      }
    }
  }
  ;
  ((pIn1)->flags = ((pIn1)->flags&~(0xc1bf|0x4000))|0x0004);
  break;
}
# 85775 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 84: {
  pIn1 = &aMem[pOp->p1];
  if( pIn1->flags & (0x0004|0x0020) ){
    ;
    ;
    sqlite3VdbeMemRealify(pIn1);
    ;
  }
  break;
}
# 85803 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 85: {
  ((void)0);
  ;
  ;
  ;
  ;
  ;
  pIn1 = &aMem[pOp->p1];
  ;
  rc = (((pIn1)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn1):0);
  sqlite3VdbeMemCast(pIn1, pOp->p2, encoding);
  ;
  if( rc ) goto abort_due_to_error;
  break;
}
# 85916 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 53:
case 52:
case 56:
case 55:
case 54:
case 57: {
  int res, res2;
  char affinity;
  u16 flags1;
  u16 flags3;

  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  flags1 = pIn1->flags;
  flags3 = pIn3->flags;
  if( (flags1 | flags3)&0x0001 ){

    if( pOp->p5 & 0x80 ){




      ((void)0);
      ((void)0);
      ;
      if( (flags1&flags3&0x0001)!=0
       && (flags3&0x0100)==0
      ){
        res = 0;
      }else{
        res = ((flags3 & 0x0001) ? -1 : +1);
      }
    }else{




      if( pOp->p5 & 0x20 ){
        pOut = &aMem[pOp->p2];
        iCompare = 1;
        ;
        ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0001);
        ;
      }else{
        ;
        if( pOp->p5 & 0x10 ){
          goto jump_to_p2;
        }
      }
      break;
    }
  }else{

    affinity = pOp->p5 & 0x47;
    if( affinity>=0x43 ){
      if( (flags1 | flags3)&0x0002 ){
        if( (flags1 & (0x0004|0x0020|0x0008|0x0002))==0x0002 ){
          applyNumericAffinity(pIn1,0);
          ((void)0);





          flags3 = pIn3->flags;
        }
        if( (flags3 & (0x0004|0x0020|0x0008|0x0002))==0x0002 ){
          applyNumericAffinity(pIn3,0);
        }
      }


      if( (pIn1->flags & pIn3->flags & 0x0004)!=0 ){
        if( pIn3->u.i > pIn1->u.i ){ res = +1; goto compare_op; }
        if( pIn3->u.i < pIn1->u.i ){ res = -1; goto compare_op; }
        res = 0;
        goto compare_op;
      }
    }else if( affinity==0x42 ){
      if( (flags1 & 0x0002)==0 && (flags1&(0x0004|0x0008|0x0020))!=0 ){
        ;
        ;
        ;
        sqlite3VdbeMemStringify(pIn1, encoding, 1);
        ;
        flags1 = (pIn1->flags & ~0xc1bf) | (flags1 & 0xc1bf);
        ((void)0);
      }
      if( (flags3 & 0x0002)==0 && (flags3&(0x0004|0x0008|0x0020))!=0 ){
        ;
        ;
        ;
        sqlite3VdbeMemStringify(pIn3, encoding, 1);
        ;
        flags3 = (pIn3->flags & ~0xc1bf) | (flags3 & 0xc1bf);
      }
    }
    ((void)0);
    res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);
  }
compare_op:






  ((void)0); ((void)0); ((void)0);
  ((void)0); ((void)0);
  if( res<0 ){
    static const unsigned char aLTb[] = { 1, 0, 0, 1, 1, 0 };
    res2 = aLTb[pOp->opcode - 52];
  }else if( res==0 ){
    static const unsigned char aEQb[] = { 0, 1, 0, 1, 0, 1 };
    res2 = aEQb[pOp->opcode - 52];
  }else{
    static const unsigned char aGTb[] = { 1, 0, 1, 0, 0, 1 };
    res2 = aGTb[pOp->opcode - 52];
  }


  ((void)0);
  pIn1->flags = flags1;
  ((void)0);
  pIn3->flags = flags3;

  if( pOp->p5 & 0x20 ){
    pOut = &aMem[pOp->p2];
    iCompare = res;
    if( (pOp->p5 & 0x08)!=0 ){







      ((void)0);
      ((void)0);
      ;
      ;
      ;
      ;
      if( (pOp->opcode==53)==res2 ) break;
    }
    ;
    ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0004);
    pOut->u.i = res2;
    ;
  }else{
    ;
    if( res2 ){
      goto jump_to_p2;
    }
  }
  break;
}
# 86082 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 58: {
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  if( iCompare!=0 ) goto jump_to_p2;
  break;
}
# 86104 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 86: {
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  break;
}
# 86132 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 87: {
  int n;
  int i;
  int p1;
  int p2;
  const KeyInfo *pKeyInfo;
  int idx;
  CollSeq *pColl;
  int bRev;
  int *aPermute;

  if( (pOp->p5 & 0x01)==0 ){
    aPermute = 0;
  }else{
    ((void)0);
    ((void)0);
    ((void)0);
    aPermute = pOp[-1].p4.ai + 1;
    ((void)0);
  }
  n = pOp->p3;
  pKeyInfo = pOp->p4.pKeyInfo;
  ((void)0);
  ((void)0);
  p1 = pOp->p1;
  p2 = pOp->p2;
# 86169 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=0; i<n; i++){
    idx = aPermute ? aPermute[i] : i;
    ((void)0);
    ((void)0);
    ;
    ;
    ((void)0);
    pColl = pKeyInfo->aColl[i];
    bRev = (pKeyInfo->aSortFlags[i] & 0x01);
    iCompare = sqlite3MemCompare(&aMem[p1+idx], &aMem[p2+idx], pColl);
    if( iCompare ){
      if( (pKeyInfo->aSortFlags[i] & 0x02)
       && ((aMem[p1+idx].flags & 0x0001) || (aMem[p2+idx].flags & 0x0001))
      ){
        iCompare = -iCompare;
      }
      if( bRev ) iCompare = -iCompare;
      break;
    }
  }
  break;
}







case 16: {
  if( iCompare<0 ){
    ; pOp = &aOp[pOp->p1 - 1];
  }else if( iCompare==0 ){
    ; pOp = &aOp[pOp->p2 - 1];
  }else{
    ; pOp = &aOp[pOp->p3 - 1];
  }
  break;
}
# 86229 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 44:
case 43: {
  int v1;
  int v2;

  v1 = sqlite3VdbeBooleanValue(&aMem[pOp->p1], 2);
  v2 = sqlite3VdbeBooleanValue(&aMem[pOp->p2], 2);
  if( pOp->opcode==44 ){
    static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };
    v1 = and_logic[v1*3+v2];
  }else{
    static const unsigned char or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };
    v1 = or_logic[v1*3+v2];
  }
  pOut = &aMem[pOp->p3];
  if( v1==2 ){
    ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0001);
  }else{
    pOut->u.i = v1;
    ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0004);
  }
  break;
}
# 86273 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 88: {
  ((void)0);
  ((void)0);
  ((void)0);
  sqlite3VdbeMemSetInt64(&aMem[pOp->p2],
      sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3) ^ pOp->p4.i);
  break;
}
# 86289 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 19: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  if( (pIn1->flags & 0x0001)==0 ){
    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeBooleanValue(pIn1,0));
  }else{
    sqlite3VdbeMemSetNull(pOut);
  }
  break;
}
# 86307 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 110: {
  pIn1 = &aMem[pOp->p1];
  pOut = &aMem[pOp->p2];
  sqlite3VdbeMemSetNull(pOut);
  if( (pIn1->flags & 0x0001)==0 ){
    pOut->flags = 0x0004;
    pOut->u.i = ~sqlite3VdbeIntValue(pIn1);
  }
  break;
}
# 86335 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 17: {
  u32 iAddr;
  ((void)0);
  if( p->pFrame ){
    iAddr = (int)(pOp - p->aOp);
    if( (p->pFrame->aOnce[iAddr/8] & (1<<(iAddr & 7)))!=0 ){
      ;
      goto jump_to_p2;
    }
    p->pFrame->aOnce[iAddr/8] |= 1<<(iAddr & 7);
  }else{
    if( p->aOp[0].p1==pOp->p1 ){
      ;
      goto jump_to_p2;
    }
  }
  ;
  pOp->p1 = p->aOp[0].p1;
  break;
}







case 18: {
  int c;
  c = sqlite3VdbeBooleanValue(&aMem[pOp->p1], pOp->p3);
  ;
  if( c ) goto jump_to_p2;
  break;
}







case 20: {
  int c;
  c = !sqlite3VdbeBooleanValue(&aMem[pOp->p1], !pOp->p3);
  ;
  if( c ) goto jump_to_p2;
  break;
}






case 50: {
  pIn1 = &aMem[pOp->p1];
  ;
  if( (pIn1->flags & 0x0001)!=0 ){
    goto jump_to_p2;
  }
  break;
}






case 51: {
  pIn1 = &aMem[pOp->p1];
  ;
  if( (pIn1->flags & 0x0001)==0 ){
    goto jump_to_p2;
  }
  break;
}
# 86420 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 21: {
  ((void)0);
  ((void)0);
  if( p->apCsr[pOp->p1]->nullRow ){
    sqlite3VdbeMemSetNull(aMem + pOp->p3);
    goto jump_to_p2;
  }
  break;
}
# 86480 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 90: {
  int p2;
  VdbeCursor *pC;
  BtCursor *pCrsr;
  u32 *aOffset;
  int len;
  int i;
  Mem *pDest;
  Mem sMem;
  const u8 *zData;
  const u8 *zHdr;
  const u8 *zEndHdr;
  u64 offset64;
  u32 t;
  Mem *pReg;

  pC = p->apCsr[pOp->p1];
  p2 = pOp->p2;




  rc = sqlite3VdbeCursorMoveto(&pC, &p2);
  if( rc ) goto abort_due_to_error;

  ((void)0);
  pDest = &aMem[pOp->p3];
  ;
  ((void)0);
  ((void)0);
  ((void)0);
  aOffset = pC->aOffset;
  ((void)0);
  ((void)0);
  ((void)0);

  if( pC->cacheStatus!=p->cacheCtr ){
    if( pC->nullRow ){
      if( pC->eCurType==3 ){


        ((void)0);
        pReg = &aMem[pC->seekResult];
        ((void)0);
        ((void)0);
        pC->payloadSize = pC->szRow = pReg->n;
        pC->aRow = (u8*)pReg->z;
      }else{
        sqlite3VdbeMemSetNull(pDest);
        goto op_column_out;
      }
    }else{
      pCrsr = pC->uc.pCursor;
      ((void)0);
      ((void)0);
      ((void)0);
      pC->payloadSize = sqlite3BtreePayloadSize(pCrsr);
      pC->aRow = sqlite3BtreePayloadFetch(pCrsr, &pC->szRow);
      ((void)0);
      ((void)0);
      if( pC->payloadSize > (u32)db->aLimit[0] ){
        goto too_big;
      }
    }
    pC->cacheStatus = p->cacheCtr;
    pC->iHdrOffset = (u8)((*(pC->aRow)<(u8)0x80)?((aOffset[0])=(u32)*(pC->aRow)),1:sqlite3GetVarint32((pC->aRow),(u32 *)&(aOffset[0])));
    pC->nHdrParsed = 0;


    if( pC->szRow<aOffset[0] ){




      pC->aRow = 0;
      pC->szRow = 0;
# 86566 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( aOffset[0] > 98307 || aOffset[0] > pC->payloadSize ){
        goto op_column_corrupt;
      }
    }else{
# 86583 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      zData = pC->aRow;
      ((void)0);
      ;
      goto op_column_read_header;
    }
  }




  if( pC->nHdrParsed<=p2 ){



    if( pC->iHdrOffset<aOffset[0] ){

      if( pC->aRow==0 ){
        memset(&sMem, 0, sizeof(sMem));
        rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, 0, aOffset[0], &sMem);
        if( rc!=0 ) goto abort_due_to_error;
        zData = (u8*)sMem.z;
      }else{
        zData = pC->aRow;
      }


    op_column_read_header:
      i = pC->nHdrParsed;
      offset64 = aOffset[i];
      zHdr = zData + pC->iHdrOffset;
      zEndHdr = zData + aOffset[0];
      ;
      do{
        if( (pC->aType[i] = t = zHdr[0])<0x80 ){
          zHdr++;
          offset64 += sqlite3VdbeOneByteSerialTypeLen(t);
        }else{
          zHdr += sqlite3GetVarint32(zHdr, &t);
          pC->aType[i] = t;
          offset64 += sqlite3VdbeSerialTypeLen(t);
        }
        aOffset[++i] = (u32)(offset64 & 0xffffffff);
      }while( i<=p2 && zHdr<zEndHdr );






      if( (zHdr>=zEndHdr && (zHdr>zEndHdr || offset64!=pC->payloadSize))
       || (offset64 > pC->payloadSize)
      ){
        if( aOffset[0]==0 ){
          i = 0;
          zHdr = zEndHdr;
        }else{
          if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem);
          goto op_column_corrupt;
        }
      }

      pC->nHdrParsed = i;
      pC->iHdrOffset = (u32)(zHdr - zData);
      if( pC->aRow==0 ) sqlite3VdbeMemRelease(&sMem);
    }else{
      t = 0;
    }





    if( pC->nHdrParsed<=p2 ){
      if( pOp->p4type==(-11) ){
        sqlite3VdbeMemShallowCopy(pDest, pOp->p4.pMem, 0x0800);
      }else{
        sqlite3VdbeMemSetNull(pDest);
      }
      goto op_column_out;
    }
  }else{
    t = pC->aType[p2];
  }





  ((void)0);
  ((void)0);
  ((void)0);
  if( (((pDest)->flags&(0x2000|0x0400))!=0) ){
    sqlite3VdbeMemSetNull(pDest);
  }
  ((void)0);
  if( pC->szRow>=aOffset[p2+1] ){


    zData = pC->aRow + aOffset[p2];
    if( t<12 ){
      sqlite3VdbeSerialGet(zData, t, pDest);
    }else{




      static const u16 aFlag[] = { 0x0010, 0x0002|0x0200 };
      pDest->n = len = (t-12)/2;
      pDest->enc = encoding;
      if( pDest->szMalloc < len+2 ){
        pDest->flags = 0x0001;
        if( sqlite3VdbeMemGrow(pDest, len+2, 0) ) goto no_mem;
      }else{
        pDest->z = pDest->zMalloc;
      }
      memcpy(pDest->z, zData, len);
      pDest->z[len] = 0;
      pDest->z[len+1] = 0;
      pDest->flags = aFlag[t&1];
    }
  }else{
    pDest->enc = encoding;

    if( ((pOp->p5 & (0x40|0x80))!=0
          && ((t>=12 && (t&1)==0) || (pOp->p5 & 0x80)!=0))
     || (len = sqlite3VdbeSerialTypeLen(t))==0
    ){
# 86721 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      static u8 aZero[16];
      sqlite3VdbeSerialGet(aZero, t, pDest);
    }else{
      rc = sqlite3VdbeMemFromBtree(pC->uc.pCursor, aOffset[p2], len, pDest);
      if( rc!=0 ) goto abort_due_to_error;
      sqlite3VdbeSerialGet((const u8*)pDest->z, t, pDest);
      pDest->flags &= ~0x1000;
    }
  }

op_column_out:
  ;
  ;
  break;

op_column_corrupt:
  if( aOp[0].p3>0 ){
    pOp = &aOp[aOp[0].p3-1];
    break;
  }else{
    rc = sqlite3CorruptError(86741);
    goto abort_due_to_error;
  }
}
# 86755 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 91: {
  const char *zAffinity;

  zAffinity = pOp->p4.z;
  ((void)0);
  ((void)0);
  ((void)0);
  pIn1 = &aMem[pOp->p1];
  while( 1 ){
    ((void)0);
    ((void)0);
    applyAffinity(pIn1, zAffinity[0], encoding);
    if( zAffinity[0]==0x45 && (pIn1->flags & 0x0004)!=0 ){




      ;
      ;
      ;
      ;
      if( pIn1->u.i<=140737488355327LL && pIn1->u.i>=-140737488355328LL ){
        pIn1->flags |= 0x0020;
        pIn1->flags &= ~0x0004;
      }else{
        pIn1->u.r = (double)pIn1->u.i;
        pIn1->flags |= 0x0008;
        pIn1->flags &= ~0x0004;
      }
    }
    ;
    zAffinity++;
    if( zAffinity[0]==0 ) break;
    pIn1++;
  }
  break;
}
# 86809 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 92: {
  Mem *pRec;
  u64 nData;
  int nHdr;
  i64 nByte;
  i64 nZero;
  int nVarint;
  u32 serial_type;
  Mem *pData0;
  Mem *pLast;
  int nField;
  char *zAffinity;
  int file_format;
  u32 len;
  u8 *zHdr;
  u8 *zPayload;
# 86841 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  nData = 0;
  nHdr = 0;
  nZero = 0;
  nField = pOp->p1;
  zAffinity = pOp->p4.z;
  ((void)0);
  pData0 = &aMem[nField];
  nField = pOp->p2;
  pLast = &pData0[nField-1];
  file_format = p->minWriteFileFormat;


  ((void)0);
  pOut = &aMem[pOp->p3];
  ;



  ((void)0);
  if( zAffinity ){
    pRec = pData0;
    do{
      applyAffinity(pRec, zAffinity[0], encoding);
      if( zAffinity[0]==0x45 && (pRec->flags & 0x0004) ){
        pRec->flags |= 0x0020;
        pRec->flags &= ~(0x0004);
      }
      ;
      zAffinity++;
      pRec++;
      ((void)0);
    }while( zAffinity[0] );
  }
# 86915 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pRec = pLast;
  do{
    ((void)0);
    if( pRec->flags & 0x0001 ){
      if( pRec->flags & 0x4000 ){






        ((void)0);
        pRec->uTemp = 10;
      }else{
        pRec->uTemp = 0;
      }
      nHdr++;
    }else if( pRec->flags & (0x0004|0x0020) ){

      i64 i = pRec->u.i;
      u64 uu;
      ;
      ;
      if( i<0 ){
        uu = ~i;
      }else{
        uu = i;
      }
      nHdr++;
      ; ;
      ; ;
      ; ;
      ; ;
      ; ;
      if( uu<=127 ){
        if( (i&1)==i && file_format>=4 ){
          pRec->uTemp = 8+(u32)uu;
        }else{
          nData++;
          pRec->uTemp = 1;
        }
      }else if( uu<=32767 ){
        nData += 2;
        pRec->uTemp = 2;
      }else if( uu<=8388607 ){
        nData += 3;
        pRec->uTemp = 3;
      }else if( uu<=2147483647 ){
        nData += 4;
        pRec->uTemp = 4;
      }else if( uu<=140737488355327LL ){
        nData += 6;
        pRec->uTemp = 5;
      }else{
        nData += 8;
        if( pRec->flags & 0x0020 ){



          pRec->u.r = (double)pRec->u.i;
          pRec->flags &= ~0x0020;
          pRec->flags |= 0x0008;
          pRec->uTemp = 7;
        }else{
          pRec->uTemp = 6;
        }
      }
    }else if( pRec->flags & 0x0008 ){
      nHdr++;
      nData += 8;
      pRec->uTemp = 7;
    }else{
      ((void)0);
      ((void)0);
      len = (u32)pRec->n;
      serial_type = (len*2) + 12 + ((pRec->flags & 0x0002)!=0);
      if( pRec->flags & 0x4000 ){
        serial_type += pRec->u.nZero*2;
        if( nData ){
          if( sqlite3VdbeMemExpandBlob(pRec) ) goto no_mem;
          len += pRec->u.nZero;
        }else{
          nZero += pRec->u.nZero;
        }
      }
      nData += len;
      nHdr += sqlite3VarintLen(serial_type);
      pRec->uTemp = serial_type;
    }
    if( pRec==pData0 ) break;
    pRec--;
  }while(1);





  ;
  ;
  if( nHdr<=126 ){

    nHdr += 1;
  }else{

    nVarint = sqlite3VarintLen(nHdr);
    nHdr += nVarint;
    if( nVarint<sqlite3VarintLen(nHdr) ) nHdr++;
  }
  nByte = nHdr+nData;






  if( nByte+nZero<=pOut->szMalloc ){


    pOut->z = pOut->zMalloc;
  }else{


    if( nByte+nZero>db->aLimit[0] ){
      goto too_big;
    }
    if( sqlite3VdbeMemClearAndResize(pOut, (int)nByte) ){
      goto no_mem;
    }
  }
  pOut->n = (int)nByte;
  pOut->flags = 0x0010;
  if( nZero ){
    pOut->u.nZero = nZero;
    pOut->flags |= 0x4000;
  }
  ;
  zHdr = (u8 *)pOut->z;
  zPayload = zHdr + nHdr;


  zHdr += (u8)(((u32)(nHdr)<(u32)0x80)?(*(zHdr)=(unsigned char)(nHdr)),1: sqlite3PutVarint((zHdr),(nHdr)));
  ((void)0);
  pRec = pData0;
  do{
    serial_type = pRec->uTemp;


    zHdr += (u8)(((u32)(serial_type)<(u32)0x80)?(*(zHdr)=(unsigned char)(serial_type)),1: sqlite3PutVarint((zHdr),(serial_type)));


    zPayload += sqlite3VdbeSerialPut(zPayload, pRec, serial_type);
  }while( (++pRec)<=pLast );
  ((void)0);
  ((void)0);

  ((void)0);
  ;
  break;
}
# 87082 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 93: {
  i64 nEntry;
  BtCursor *pCrsr;

  ((void)0);
  pCrsr = p->apCsr[pOp->p1]->uc.pCursor;
  ((void)0);
  nEntry = 0;
  rc = sqlite3BtreeCount(pCrsr, &nEntry);
  if( rc ) goto abort_due_to_error;
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = nEntry;
  break;
}
# 87105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 0: {
  int p1;
  char *zName;
  int nName;
  Savepoint *pNew;
  Savepoint *pSavepoint;
  Savepoint *pTmp;
  int iSavepoint;
  int ii;

  p1 = pOp->p1;
  zName = pOp->p4.z;




  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( p1==0 ){
    if( db->nVdbeWrite>0 ){



      sqlite3VdbeError(p, "cannot open savepoint - SQL statements in progress");
      rc = 5;
    }else{
      nName = sqlite3Strlen30(zName);






      ((void)0);
      rc = sqlite3VtabSavepoint(db, 0,
                                db->nStatement+db->nSavepoint);
      if( rc!=0 ) goto abort_due_to_error;



      pNew = sqlite3DbMallocRawNN(db, sizeof(Savepoint)+nName+1);
      if( pNew ){
        pNew->zName = (char *)&pNew[1];
        memcpy(pNew->zName, zName, nName+1);



        if( db->autoCommit ){
          db->autoCommit = 0;
          db->isTransactionSavepoint = 1;
        }else{
          db->nSavepoint++;
        }


        pNew->pNext = db->pSavepoint;
        db->pSavepoint = pNew;
        pNew->nDeferredCons = db->nDeferredCons;
        pNew->nDeferredImmCons = db->nDeferredImmCons;
      }
    }
  }else{
    ((void)0);
    iSavepoint = 0;



    for(
      pSavepoint = db->pSavepoint;
      pSavepoint && sqlite3StrICmp(pSavepoint->zName, zName);
      pSavepoint = pSavepoint->pNext
    ){
      iSavepoint++;
    }
    if( !pSavepoint ){
      sqlite3VdbeError(p, "no such savepoint: %s", zName);
      rc = 1;
    }else if( db->nVdbeWrite>0 && p1==1 ){



      sqlite3VdbeError(p, "cannot release savepoint - "
                          "SQL statements in progress");
      rc = 5;
    }else{





      int isTransaction = pSavepoint->pNext==0 && db->isTransactionSavepoint;
      if( isTransaction && p1==1 ){
        if( (rc = sqlite3VdbeCheckFk(p, 1))!=0 ){
          goto vdbe_return;
        }
        db->autoCommit = 1;
        if( sqlite3VdbeHalt(p)==5 ){
          p->pc = (int)(pOp - aOp);
          db->autoCommit = 0;
          p->rc = rc = 5;
          goto vdbe_return;
        }
        db->isTransactionSavepoint = 0;
        rc = p->rc;
      }else{
        int isSchemaChange;
        iSavepoint = db->nSavepoint - iSavepoint - 1;
        if( p1==2 ){
          isSchemaChange = (db->mDbFlags & 0x0001)!=0;
          for(ii=0; ii<db->nDb; ii++){
            rc = sqlite3BtreeTripAllCursors(db->aDb[ii].pBt,
                                       (4 | (2<<8)),
                                       isSchemaChange==0);
            if( rc!=0 ) goto abort_due_to_error;
          }
        }else{
          ((void)0);
          isSchemaChange = 0;
        }
        for(ii=0; ii<db->nDb; ii++){
          rc = sqlite3BtreeSavepoint(db->aDb[ii].pBt, p1, iSavepoint);
          if( rc!=0 ){
            goto abort_due_to_error;
          }
        }
        if( isSchemaChange ){
          sqlite3ExpirePreparedStatements(db, 0);
          sqlite3ResetAllSchemasOfConnection(db);
          db->mDbFlags |= 0x0001;
        }
      }



      while( db->pSavepoint!=pSavepoint ){
        pTmp = db->pSavepoint;
        db->pSavepoint = pTmp->pNext;
        sqlite3DbFree(db, pTmp);
        db->nSavepoint--;
      }





      if( p1==1 ){
        ((void)0);
        db->pSavepoint = pSavepoint->pNext;
        sqlite3DbFree(db, pSavepoint);
        if( !isTransaction ){
          db->nSavepoint--;
        }
      }else{
        ((void)0);
        db->nDeferredCons = pSavepoint->nDeferredCons;
        db->nDeferredImmCons = pSavepoint->nDeferredImmCons;
      }

      if( !isTransaction || p1==2 ){
        rc = sqlite3VtabSavepoint(db, p1, iSavepoint);
        if( rc!=0 ) goto abort_due_to_error;
      }
    }
  }
  if( rc ) goto abort_due_to_error;

  break;
}
# 87287 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 1: {
  int desiredAutoCommit;
  int iRollback;

  desiredAutoCommit = pOp->p1;
  iRollback = pOp->p2;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( desiredAutoCommit!=db->autoCommit ){
    if( iRollback ){
      ((void)0);
      sqlite3RollbackAll(db, (4 | (2<<8)));
      db->autoCommit = 1;
    }else if( desiredAutoCommit && db->nVdbeWrite>0 ){



      sqlite3VdbeError(p, "cannot commit transaction - "
                          "SQL statements in progress");
      rc = 5;
      goto abort_due_to_error;
    }else if( (rc = sqlite3VdbeCheckFk(p, 1))!=0 ){
      goto vdbe_return;
    }else{
      db->autoCommit = (u8)desiredAutoCommit;
    }
    if( sqlite3VdbeHalt(p)==5 ){
      p->pc = (int)(pOp - aOp);
      db->autoCommit = (u8)(1-desiredAutoCommit);
      p->rc = rc = 5;
      goto vdbe_return;
    }
    ((void)0);
    sqlite3CloseSavepoints(db);
    if( p->rc==0 ){
      rc = 101;
    }else{
      rc = 1;
    }
    goto vdbe_return;
  }else{
    sqlite3VdbeError(p,
        (!desiredAutoCommit)?"cannot start a transaction within a transaction":(
        (iRollback)?"cannot rollback - no transaction is active":
                   "cannot commit - no transaction is active"));

    rc = 1;
    goto abort_due_to_error;
  }
                 ((void)0);
}
# 87376 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 2: {
  Btree *pBt;
  int iMeta = 0;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( pOp->p2 && (db->flags & 0x00100000)!=0 ){
    rc = 8;
    goto abort_due_to_error;
  }
  pBt = db->aDb[pOp->p1].pBt;

  if( pBt ){
    rc = sqlite3BtreeBeginTrans(pBt, pOp->p2, &iMeta);
    ;
    ;
    if( rc!=0 ){
      if( (rc&0xff)==5 ){
        p->pc = (int)(pOp - aOp);
        p->rc = rc;
        goto vdbe_return;
      }
      goto abort_due_to_error;
    }

    if( pOp->p2 && p->usesStmtJournal
     && (db->autoCommit==0 || db->nVdbeRead>1)
    ){
      ((void)0);
      if( p->iStatement==0 ){
        ((void)0);
        db->nStatement++;
        p->iStatement = db->nSavepoint + db->nStatement;
      }

      rc = sqlite3VtabSavepoint(db, 0, p->iStatement-1);
      if( rc==0 ){
        rc = sqlite3BtreeBeginStmt(pBt, p->iStatement);
      }




      p->nStmtDefCons = db->nDeferredCons;
      p->nStmtDefImmCons = db->nDeferredImmCons;
    }
  }
  ((void)0);
  if( pOp->p5
   && (iMeta!=pOp->p3
      || db->aDb[pOp->p1].pSchema->iGeneration!=pOp->p4.i)
  ){





    sqlite3DbFree(db, p->zErrMsg);
    p->zErrMsg = sqlite3DbStrDup(db, "database schema has changed");
# 87450 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( db->aDb[pOp->p1].pSchema->schema_cookie!=iMeta ){
      sqlite3ResetOneSchema(db, pOp->p1);
    }
    p->expired = 1;
    rc = 17;
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 87472 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 94: {
  int iMeta;
  int iDb;
  int iCookie;

  ((void)0);
  iDb = pOp->p1;
  iCookie = pOp->p3;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  sqlite3BtreeGetMeta(db->aDb[iDb].pBt, iCookie, (u32 *)&iMeta);
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = iMeta;
  break;
}
# 87501 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 95: {
  Db *pDb;

  ;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  pDb = &db->aDb[pOp->p1];
  ((void)0);
  ((void)0);

  rc = sqlite3BtreeUpdateMeta(pDb->pBt, pOp->p2, pOp->p3);
  if( pOp->p2==1 ){

    pDb->pSchema->schema_cookie = pOp->p3;
    db->mDbFlags |= 0x0001;
  }else if( pOp->p2==2 ){

    pDb->pSchema->file_format = pOp->p3;
  }
  if( pOp->p1==1 ){


    sqlite3ExpirePreparedStatements(db, 0);
    p->expired = 0;
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 87616 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 96: {
  int nField;
  KeyInfo *pKeyInfo;
  int p2;
  int iDb;
  int wrFlag;
  Btree *pX;
  VdbeCursor *pCur;
  Db *pDb;

  ((void)0);
  ((void)0);
  pCur = p->apCsr[pOp->p1];
  if( pCur && pCur->pgnoRoot==(u32)pOp->p2 ){
    ((void)0);
    goto open_cursor_set_hints;
  }


case 97:
case 98:

  ((void)0);
  ((void)0);
  ((void)0)
                             ;

  if( p->expired==1 ){
    rc = (4 | (2<<8));
    goto abort_due_to_error;
  }

  nField = 0;
  pKeyInfo = 0;
  p2 = pOp->p2;
  iDb = pOp->p3;
  ((void)0);
  ((void)0);
  pDb = &db->aDb[iDb];
  pX = pDb->pBt;
  ((void)0);
  if( pOp->opcode==98 ){
    ((void)0);
    wrFlag = 0x00000004 | (pOp->p5 & 0x08);
    ((void)0);
    if( pDb->pSchema->file_format < p->minWriteFileFormat ){
      p->minWriteFileFormat = pDb->pSchema->file_format;
    }
  }else{
    wrFlag = 0;
  }
  if( pOp->p5 & 0x10 ){
    ((void)0);
    ((void)0);
    ((void)0);
    pIn2 = &aMem[p2];
    ((void)0);
    ((void)0);
    sqlite3VdbeMemIntegerify(pIn2);
    p2 = (int)pIn2->u.i;




    ((void)0);
  }
  if( pOp->p4type==(-9) ){
    pKeyInfo = pOp->p4.pKeyInfo;
    ((void)0);
    ((void)0);
    nField = pKeyInfo->nAllField;
  }else if( pOp->p4type==(-3) ){
    nField = pOp->p4.i;
  }
  ((void)0);
  ((void)0);
  ;
  pCur = allocateCursor(p, pOp->p1, nField, iDb, 0);
  if( pCur==0 ) goto no_mem;
  pCur->nullRow = 1;
  pCur->isOrdered = 1;
  pCur->pgnoRoot = p2;



  rc = sqlite3BtreeCursor(pX, p2, wrFlag, pKeyInfo, pCur->uc.pCursor);
  pCur->pKeyInfo = pKeyInfo;




  pCur->isTable = pOp->p4type!=(-9);

open_cursor_set_hints:
  ((void)0);
  ((void)0);
  ;



  sqlite3BtreeCursorHintFlags(pCur->uc.pCursor,
                               (pOp->p5 & (0x01|0x02)));
  if( rc ) goto abort_due_to_error;
  break;
}
# 87730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 109: {
  VdbeCursor *pOrig;
  VdbeCursor *pCx;

  pOrig = p->apCsr[pOp->p2];
  ((void)0);

  pCx = allocateCursor(p, pOp->p1, pOrig->nField, -1, 0);
  if( pCx==0 ) goto no_mem;
  pCx->nullRow = 1;
  pCx->isEphemeral = 1;
  pCx->pKeyInfo = pOrig->pKeyInfo;
  pCx->isTable = pOrig->isTable;
  pCx->pgnoRoot = pOrig->pgnoRoot;
  pCx->isOrdered = pOrig->isOrdered;
  rc = sqlite3BtreeCursor(pOrig->pBtx, pCx->pgnoRoot, 0x00000004,
                          pCx->pKeyInfo, pCx->uc.pCursor);



  ((void)0);
  break;
}
# 87784 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 111:
case 112: {
  VdbeCursor *pCx;
  KeyInfo *pKeyInfo;

  static const int vfsFlags =
      0x00000002 |
      0x00000004 |
      0x00000010 |
      0x00000008 |
      0x00000400;
  ((void)0);
  ((void)0);
  pCx = p->apCsr[pOp->p1];
  if( pCx ){


    ((void)0);
    pCx->seqCount = 0;
    pCx->cacheStatus = 0;
    if( pCx->pBtx ){
      rc = sqlite3BtreeClearTable(pCx->pBtx, pCx->pgnoRoot, 0);
    }
  }else{
    pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, 0);
    if( pCx==0 ) goto no_mem;
    pCx->isEphemeral = 1;
    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pCx->pBtx,
                          1 | 4 | pOp->p5,
                          vfsFlags);
    if( rc==0 ){
      rc = sqlite3BtreeBeginTrans(pCx->pBtx, 1, 0);
    }
    if( rc==0 ){





      if( (pCx->pKeyInfo = pKeyInfo = pOp->p4.pKeyInfo)!=0 ){
        ((void)0);
        rc = sqlite3BtreeCreateTable(pCx->pBtx, (int*)&pCx->pgnoRoot,
                                     2 | pOp->p5);
        if( rc==0 ){
          ((void)0);
          ((void)0);
          ((void)0);
          rc = sqlite3BtreeCursor(pCx->pBtx, pCx->pgnoRoot, 0x00000004,
                                  pKeyInfo, pCx->uc.pCursor);
        }
        pCx->isTable = 0;
      }else{
        pCx->pgnoRoot = 1;
        rc = sqlite3BtreeCursor(pCx->pBtx, 1, 0x00000004,
                                0, pCx->uc.pCursor);
        pCx->isTable = 1;
      }
    }
    pCx->isOrdered = (pOp->p5!=8);
  }
  if( rc ) goto abort_due_to_error;
  pCx->nullRow = 1;
  break;
}
# 87859 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 114: {
  VdbeCursor *pCx;

  ((void)0);
  ((void)0);
  pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, 1);
  if( pCx==0 ) goto no_mem;
  pCx->pKeyInfo = pOp->p4.pKeyInfo;
  ((void)0);
  ((void)0);
  rc = sqlite3VdbeSorterInit(db, pOp->p3, pCx);
  if( rc ) goto abort_due_to_error;
  break;
}
# 87881 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 115: {
  VdbeCursor *pC;
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  if( (pC->seqCount++)==0 ){
    goto jump_to_p2;
  }
  break;
}
# 87908 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 116: {
  VdbeCursor *pCx;

  ((void)0);
  ((void)0);
  pCx = allocateCursor(p, pOp->p1, pOp->p3, -1, 3);
  if( pCx==0 ) goto no_mem;
  pCx->nullRow = 1;
  pCx->seekResult = pOp->p2;
  pCx->isTable = 1;




  pCx->uc.pCursor = sqlite3BtreeFakeValidCursor();
  ((void)0);
  break;
}






case 117: {
  ((void)0);
  sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);
  p->apCsr[pOp->p1] = 0;
  break;
}
# 88045 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 22:
case 23:
case 24:
case 25: {
  int res;
  int oc;
  VdbeCursor *pC;
  UnpackedRecord r;
  int nField;
  i64 iKey;
  int eqOnly;

  ((void)0);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  oc = pOp->opcode;
  eqOnly = 0;
  pC->nullRow = 0;




  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;
  if( pC->isTable ){
    u16 flags3, newType;

    ((void)0)
                             ;




    pIn3 = &aMem[pOp->p3];
    flags3 = pIn3->flags;
    if( (flags3 & (0x0004|0x0008|0x0020|0x0002))==0x0002 ){
      applyNumericAffinity(pIn3, 0);
    }
    iKey = sqlite3VdbeIntValue(pIn3);
    newType = pIn3->flags;
    pIn3->flags = flags3;



    if( (newType & (0x0004|0x0020))==0 ){
      if( (newType & 0x0008)==0 ){
        if( (newType & 0x0001) || oc>=24 ){
          ;
          goto jump_to_p2;
        }else{
          rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
          if( rc!=0 ) goto abort_due_to_error;
          goto seek_not_found;
        }
      }else
# 88115 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( pIn3->u.r<(double)iKey ){
        ((void)0);
        ((void)0);
        ((void)0);
        if( (oc & 0x0001)==(25 & 0x0001) ) oc--;
      }



      else if( pIn3->u.r>(double)iKey ){
        ((void)0);
        ((void)0);
        ((void)0);
        if( (oc & 0x0001)==(22 & 0x0001) ) oc++;
      }
    }
    rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)iKey, 0, &res);
    pC->movetoTarget = iKey;
    if( rc!=0 ){
      goto abort_due_to_error;
    }
  }else{




    if( sqlite3BtreeCursorHasHint(pC->uc.pCursor, 0x00000002) ){
      eqOnly = 1;
      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);
    }

    nField = pOp->p4.i;
    ((void)0);
    ((void)0);
    r.pKeyInfo = pC->pKeyInfo;
    r.nField = (u16)nField;
# 88164 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    r.default_rc = ((1 & (oc - 22)) ? -1 : +1);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);

    r.aMem = &aMem[pOp->p3];



    r.eqSeen = 0;
    rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, &r, 0, 0, &res);
    if( rc!=0 ){
      goto abort_due_to_error;
    }
    if( eqOnly && r.eqSeen==0 ){
      ((void)0);
      goto seek_not_found;
    }
  }



  if( oc>=24 ){ ((void)0);
    if( res<0 || (res==0 && oc==25) ){
      res = 0;
      rc = sqlite3BtreeNext(pC->uc.pCursor, 0);
      if( rc!=0 ){
        if( rc==101 ){
          rc = 0;
          res = 1;
        }else{
          goto abort_due_to_error;
        }
      }
    }else{
      res = 0;
    }
  }else{
    ((void)0);
    if( res>0 || (res==0 && oc==22) ){
      res = 0;
      rc = sqlite3BtreePrevious(pC->uc.pCursor, 0);
      if( rc!=0 ){
        if( rc==101 ){
          rc = 0;
          res = 1;
        }else{
          goto abort_due_to_error;
        }
      }
    }else{



      res = sqlite3BtreeEof(pC->uc.pCursor);
    }
  }
seek_not_found:
  ((void)0);
  ;
  if( res ){
    goto jump_to_p2;
  }else if( eqOnly ){
    ((void)0);
    pOp++;
  }
  break;
}
# 88243 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 119: {
  VdbeCursor *pC;
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  pC->seekHit = pOp->p2 & 1;
  break;
}
# 88339 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 26: {
  VdbeCursor *pC;
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  if( pC->seekHit ) break;

}
case 27:
case 28:
case 29: {
  int alreadyExists;
  int takeJump;
  int ii;
  VdbeCursor *pC;
  int res;
  UnpackedRecord *pFree;
  UnpackedRecord *pIdxKey;
  UnpackedRecord r;





  ((void)0);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);



  pIn3 = &aMem[pOp->p3];
  ((void)0);
  ((void)0);
  ((void)0);
  if( pOp->p4.i>0 ){
    r.pKeyInfo = pC->pKeyInfo;
    r.nField = (u16)pOp->p4.i;
    r.aMem = pIn3;







    pIdxKey = &r;
    pFree = 0;
  }else{
    ((void)0);
    rc = (((pIn3)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn3):0);
    ((void)0);
    if( rc ) goto no_mem;
    pFree = pIdxKey = sqlite3VdbeAllocUnpackedRecord(pC->pKeyInfo);
    if( pIdxKey==0 ) goto no_mem;
    sqlite3VdbeRecordUnpack(pC->pKeyInfo, pIn3->n, pIn3->z, pIdxKey);
  }
  pIdxKey->default_rc = 0;
  takeJump = 0;
  if( pOp->opcode==27 ){



    for(ii=0; ii<pIdxKey->nField; ii++){
      if( pIdxKey->aMem[ii].flags & 0x0001 ){
        takeJump = 1;
        break;
      }
    }
  }
  rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, pIdxKey, 0, 0, &res);
  if( pFree ) sqlite3DbFreeNN(db, pFree);
  if( rc!=0 ){
    goto abort_due_to_error;
  }
  pC->seekResult = res;
  alreadyExists = (res==0);
  pC->nullRow = 1-alreadyExists;
  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;
  if( pOp->opcode==29 ){
    ;
    if( alreadyExists ) goto jump_to_p2;
  }else{
    ;
    if( takeJump || !alreadyExists ) goto jump_to_p2;
  }
  break;
}
# 88476 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 30: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;
  u64 iKey;

  pIn3 = &aMem[pOp->p3];
  ;
  ;
  ;
  ;
  if( (pIn3->flags & (0x0004|0x0020))==0 ){





    Mem x = pIn3[0];
    applyAffinity(&x, 0x43, encoding);
    if( (x.flags & 0x0004)==0 ) goto jump_to_p2;
    iKey = x.u.i;
    goto notExistsWithKey;
  }

case 31:
  pIn3 = &aMem[pOp->p3];
  ((void)0);
  ((void)0);
  iKey = pIn3->u.i;
notExistsWithKey:
  pC = p->apCsr[pOp->p1];
  ((void)0);



  ((void)0);
  ((void)0);
  pCrsr = pC->uc.pCursor;
  ((void)0);
  res = 0;
  rc = sqlite3BtreeMovetoUnpacked(pCrsr, 0, iKey, 0, &res);
  ((void)0);
  pC->movetoTarget = iKey;
  pC->nullRow = 0;
  pC->cacheStatus = 0;
  pC->deferredMoveto = 0;
  ;
  pC->seekResult = res;
  if( res!=0 ){
    ((void)0);
    if( pOp->p2==0 ){
      rc = sqlite3CorruptError(88527);
    }else{
      goto jump_to_p2;
    }
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 88544 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 120: {
  ((void)0);
  ((void)0);
  ((void)0);
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = p->apCsr[pOp->p1]->seqCount++;
  break;
}
# 88569 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 121: {
  i64 v;
  VdbeCursor *pC;
  int res;
  int cnt;
  Mem *pMem;
  VdbeFrame *pFrame;

  v = 0;
  res = 0;
  pOut = out2Prerelease(p, pOp);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  {
# 88600 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
# 88609 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define MAX_ROWID (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )


    if( !pC->useRandomRowid ){
      rc = sqlite3BtreeLast(pC->uc.pCursor, &res);
      if( rc!=0 ){
        goto abort_due_to_error;
      }
      if( res ){
        v = 1;
      }else{
        ((void)0);
        v = sqlite3BtreeIntegerKey(pC->uc.pCursor);
        if( v>=(i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) ){
          pC->useRandomRowid = 1;
        }else{
          v++;
        }
      }
    }


    if( pOp->p3 ){

      ((void)0);
      if( p->pFrame ){
        for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);

        ((void)0);
        pMem = &pFrame->aMem[pOp->p3];
      }else{

        ((void)0);
        pMem = &aMem[pOp->p3];
        ;
      }
      ((void)0);

      ;
      sqlite3VdbeMemIntegerify(pMem);
      ((void)0);
      if( pMem->u.i==(i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff ) || pC->useRandomRowid ){
        rc = 13;
        goto abort_due_to_error;
      }
      if( v<pMem->u.i+1 ){
        v = pMem->u.i + 1;
      }
      pMem->u.i = v;
    }

    if( pC->useRandomRowid ){




      ((void)0);

      cnt = 0;
      do{
        sqlite3_randomness(sizeof(v), &v);
        v &= ((i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )>>1); v++;
      }while( ((rc = sqlite3BtreeMovetoUnpacked(pC->uc.pCursor, 0, (u64)v,
                                                 0, &res))==0)
            && (res==0)
            && (++cnt<100));
      if( rc ) goto abort_due_to_error;
      if( res==0 ){
        rc = 13;
        goto abort_due_to_error;
      }
      ((void)0);
    }
    pC->deferredMoveto = 0;
    pC->cacheStatus = 0;
  }
  pOut->u.i = v;
  break;
}
# 88726 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 122: {
  Mem *pData;
  Mem *pKey;
  VdbeCursor *pC;
  int seekResult;
  const char *zDb;
  Table *pTab;
  BtreePayload x;

  pData = &aMem[pOp->p2];
  ((void)0);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  ;

  pKey = &aMem[pOp->p3];
  ((void)0);
  ((void)0);
  ;
  x.nKey = pKey->u.i;

  if( pOp->p4type==(-6) && ((db)->xUpdateCallback) ){
    ((void)0);
    zDb = db->aDb[pC->iDb].zDbSName;
    pTab = pOp->p4.pTab;
    ((void)0);
  }else{
    pTab = 0;
    zDb = 0;
  }
# 88777 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pOp->p5 & 0x01 ) p->nChange++;
  if( pOp->p5 & 0x20 ) db->lastRowid = x.nKey;
  ((void)0);
  x.pData = pData->z;
  x.nData = pData->n;
  seekResult = ((pOp->p5 & 0x10) ? pC->seekResult : 0);
  if( pData->flags & 0x4000 ){
    x.nZero = pData->u.nZero;
  }else{
    x.nZero = 0;
  }
  x.pKey = 0;
  rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
      (pOp->p5 & (0x08|0x02)), seekResult
  );
  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;


  if( rc ) goto abort_due_to_error;
  if( pTab ){
    ((void)0);
    ((void)0);
    db->xUpdateCallback(db->pUpdateArg,
           (pOp->p5 & 0x04) ? 23 : 18,
           zDb, pTab->zName, x.nKey);
  }
  break;
}
# 88842 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 123: {
  VdbeCursor *pC;
  const char *zDb;
  Table *pTab;
  int opflags;

  opflags = pOp->p2;
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ;
# 88872 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pOp->p4type==(-6) && ((db)->xUpdateCallback) ){
    ((void)0);
    ((void)0);
    zDb = db->aDb[pC->iDb].zDbSName;
    pTab = pOp->p4.pTab;
    if( (pOp->p5 & 0x02)!=0 && pC->isTable ){
      pC->movetoTarget = sqlite3BtreeIntegerKey(pC->uc.pCursor);
    }
  }else{
    zDb = 0;
    pTab = 0;
  }
# 88902 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  ((void)0);
  ((void)0);
# 88920 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  rc = sqlite3BtreeDelete(pC->uc.pCursor, pOp->p5);
  pC->cacheStatus = 0;
  pC->seekResult = 0;
  if( rc ) goto abort_due_to_error;


  if( opflags & 0x01 ){
    p->nChange++;
    if( db->xUpdateCallback && (((pTab)->tabFlags & 0x0020)==0) ){
      db->xUpdateCallback(db->pUpdateArg, 9, zDb, pTab->zName,
          pC->movetoTarget);
      ((void)0);
    }
  }

  break;
}







case 124: {
  sqlite3VdbeSetChanges(db, p->nChange);
  p->nChange = 0;
  break;
}
# 88965 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 125: {
  VdbeCursor *pC;
  int res;
  int nKeyCol;

  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  pIn3 = &aMem[pOp->p3];
  nKeyCol = pOp->p4.i;
  res = 0;
  rc = sqlite3VdbeSorterCompare(pC, pIn3, nKeyCol, &res);
  ;
  if( rc ) goto abort_due_to_error;
  if( res ) goto jump_to_p2;
  break;
};
# 88995 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 126: {
  VdbeCursor *pC;

  pOut = &aMem[pOp->p2];
  pC = p->apCsr[pOp->p1];
  ((void)0);
  rc = sqlite3VdbeSorterRowkey(pC, pOut);
  ((void)0);
  ((void)0);
  if( rc ) goto abort_due_to_error;
  p->apCsr[pOp->p3]->cacheStatus = 0;
  break;
}
# 89037 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 127: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  u32 n;

  pOut = out2Prerelease(p, pOp);

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  pCrsr = pC->uc.pCursor;
# 89061 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  ((void)0);





  n = sqlite3BtreePayloadSize(pCrsr);
  if( n>(u32)db->aLimit[0] ){
    goto too_big;
  }
  ;
  rc = sqlite3VdbeMemFromBtree(pCrsr, 0, n, pOut);
  if( rc ) goto abort_due_to_error;
  if( !pOp->p3 ) if( ((pOut)->flags&0x1000)!=0 && sqlite3VdbeMemMakeWriteable(pOut) ){ goto no_mem;};
  ;
  ;
  break;
}
# 89091 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 128: {
  VdbeCursor *pC;
  i64 v;
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;

  pOut = out2Prerelease(p, pOp);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  if( pC->nullRow ){
    pOut->flags = 0x0001;
    break;
  }else if( pC->deferredMoveto ){
    v = pC->movetoTarget;

  }else if( pC->eCurType==2 ){
    ((void)0);
    pVtab = pC->uc.pVCur->pVtab;
    pModule = pVtab->pModule;
    ((void)0);
    rc = pModule->xRowid(pC->uc.pVCur, &v);
    sqlite3VtabImportErrmsg(p, pVtab);
    if( rc ) goto abort_due_to_error;

  }else{
    ((void)0);
    ((void)0);
    rc = sqlite3VdbeCursorRestore(pC);
    if( rc ) goto abort_due_to_error;
    if( pC->nullRow ){
      pOut->flags = 0x0001;
      break;
    }
    v = sqlite3BtreeIntegerKey(pC->uc.pCursor);
  }
  pOut->u.i = v;
  break;
}







case 129: {
  VdbeCursor *pC;

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  pC->nullRow = 1;
  pC->cacheStatus = 0;
  if( pC->eCurType==0 ){
    ((void)0);
    sqlite3BtreeClearCursor(pC->uc.pCursor);
  }



  break;
}
# 89178 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 130:
case 32: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  pCrsr = pC->uc.pCursor;
  res = 0;
  ((void)0);



  if( pOp->opcode==130 ){
    ((void)0);
    pC->seekResult = -1;
    if( sqlite3BtreeCursorIsValidNN(pCrsr) ){
      break;
    }
  }
  rc = sqlite3BtreeLast(pCrsr, &res);
  pC->nullRow = (u8)res;
  pC->deferredMoveto = 0;
  pC->cacheStatus = 0;
  if( rc ) goto abort_due_to_error;
  if( pOp->p2>0 ){
    ;
    if( res ) goto jump_to_p2;
  }
  break;
}






case 33: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;
  i64 sz;

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  pCrsr = pC->uc.pCursor;
  ((void)0);
  rc = sqlite3BtreeFirst(pCrsr, &res);
  if( rc ) goto abort_due_to_error;
  if( res==0 ){
    sz = sqlite3BtreeRowCountEst(pCrsr);
    if( (sz>=0) && sqlite3LogEst((u64)sz)<pOp->p3 ) res = 1;
  }
  ;
  if( res ) goto jump_to_p2;
  break;
}
# 89262 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 34:
case 35: {




  p->aCounter[2]++;

}
# 89283 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 36: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;

  ((void)0);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  res = 1;



  if( ((pC)->eCurType==1) ){
    rc = sqlite3VdbeSorterRewind(pC, &res);
  }else{
    ((void)0);
    pCrsr = pC->uc.pCursor;
    ((void)0);
    rc = sqlite3BtreeFirst(pCrsr, &res);
    pC->deferredMoveto = 0;
    pC->cacheStatus = 0;
  }
  if( rc ) goto abort_due_to_error;
  pC->nullRow = (u8)res;
  ((void)0);
  ;
  if( res ) goto jump_to_p2;
  break;
}
# 89375 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 3: {
  VdbeCursor *pC;

  pC = p->apCsr[pOp->p1];
  ((void)0);
  rc = sqlite3VdbeSorterNext(db, pC);
  goto next_tail;
case 4:
case 5:
  ((void)0);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);



  ((void)0)



                                  ;
  ((void)0)


                                 ;

  rc = pOp->p4.xAdvance(pC->uc.pCursor, pOp->p3);
next_tail:
  pC->cacheStatus = 0;
  ;
  if( rc==0 ){
    pC->nullRow = 0;
    p->aCounter[pOp->p5]++;



    goto jump_to_p2_and_check_for_interrupt;
  }
  if( rc!=101 ) goto abort_due_to_error;
  rc = 0;
  pC->nullRow = 1;
  goto check_for_interrupt;
}
# 89458 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 131:
case 132: {
  VdbeCursor *pC;
  BtreePayload x;

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ;
  ((void)0);
  ((void)0);
  pIn2 = &aMem[pOp->p2];
  ((void)0);
  if( pOp->p5 & 0x01 ) p->nChange++;
  ((void)0);
  ((void)0);
  rc = (((pIn2)->flags&0x4000)?sqlite3VdbeMemExpandBlob(pIn2):0);
  if( rc ) goto abort_due_to_error;
  if( pOp->opcode==131 ){
    rc = sqlite3VdbeSorterWrite(pC, pIn2);
  }else{
    x.nKey = pIn2->n;
    x.pKey = pIn2->z;
    x.aMem = aMem + pOp->p3;
    x.nMem = (u16)pOp->p4.i;
    rc = sqlite3BtreeInsert(pC->uc.pCursor, &x,
         (pOp->p5 & (0x08|0x02)),
        ((pOp->p5 & 0x10) ? pC->seekResult : 0)
        );
    ((void)0);
    pC->cacheStatus = 0;
  }
  if( rc) goto abort_due_to_error;
  break;
}
# 89500 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 133: {
  VdbeCursor *pC;
  BtCursor *pCrsr;
  int res;
  UnpackedRecord r;

  ((void)0);
  ((void)0);
  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ;
  pCrsr = pC->uc.pCursor;
  ((void)0);
  ((void)0);
  r.pKeyInfo = pC->pKeyInfo;
  r.nField = (u16)pOp->p3;
  r.default_rc = 0;
  r.aMem = &aMem[pOp->p2];
  rc = sqlite3BtreeMovetoUnpacked(pCrsr, &r, 0, 0, &res);
  if( rc ) goto abort_due_to_error;
  if( res==0 ){
    rc = sqlite3BtreeDelete(pCrsr, 0x04);
    if( rc ) goto abort_due_to_error;
  }
  ((void)0);
  pC->cacheStatus = 0;
  pC->seekResult = 0;
  break;
}
# 89560 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 134:
case 135: {
  VdbeCursor *pC;
  VdbeCursor *pTabCur;
  i64 rowid;

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);



  rc = sqlite3VdbeCursorRestore(pC);




  if( (rc!=0) ) goto abort_due_to_error;

  if( !pC->nullRow ){
    rowid = 0;
    rc = sqlite3VdbeIdxRowid(db, pC->uc.pCursor, &rowid);
    if( rc!=0 ){
      goto abort_due_to_error;
    }
    if( pOp->opcode==134 ){
      ((void)0);
      pTabCur = p->apCsr[pOp->p3];
      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);
      pTabCur->nullRow = 0;
      pTabCur->movetoTarget = rowid;
      pTabCur->deferredMoveto = 1;
      ((void)0);
      pTabCur->aAltMap = pOp->p4.ai;
      pTabCur->pAltCursor = pC;
    }else{
      pOut = out2Prerelease(p, pOp);
      pOut->u.i = rowid;
    }
  }else{
    ((void)0);
    sqlite3VdbeMemSetNull(&aMem[pOp->p2]);
  }
  break;
}
# 89658 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 37:
case 38:
case 39:
case 40: {
  VdbeCursor *pC;
  int res;
  UnpackedRecord r;

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  r.pKeyInfo = pC->pKeyInfo;
  r.nField = (u16)pOp->p4.i;
  if( pOp->opcode<39 ){
    ((void)0);
    r.default_rc = -1;
  }else{
    ((void)0);
    r.default_rc = 0;
  }
  r.aMem = &aMem[pOp->p3];
# 89694 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  res = 0;
  rc = sqlite3VdbeIdxKeyCompare(db, pC, &r, &res);
  ((void)0);
  if( (pOp->opcode&1)==(39&1) ){
    ((void)0);
    res = -res;
  }else{
    ((void)0);
    res++;
  }
  ;
  if( rc ) goto abort_due_to_error;
  if( res>0 ) goto jump_to_p2;
  break;
}
# 89737 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 136: {
  int iMoved;
  int iDb;

  ;
  ((void)0);
  ((void)0);
  pOut = out2Prerelease(p, pOp);
  pOut->flags = 0x0001;
  if( db->nVdbeRead > db->nVDestroy+1 ){
    rc = 6;
    p->errorAction = 2;
    goto abort_due_to_error;
  }else{
    iDb = pOp->p3;
    ((void)0);
    iMoved = 0;
    rc = sqlite3BtreeDropTable(db->aDb[iDb].pBt, pOp->p1, &iMoved);
    pOut->flags = 0x0004;
    pOut->u.i = iMoved;
    if( rc ) goto abort_due_to_error;

    if( iMoved!=0 ){
      sqlite3RootPageMoved(db, iDb, iMoved, pOp->p1);

      ((void)0);
      resetSchemaOnFault = iDb+1;
    }

  }
  break;
}
# 89788 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 137: {
  int nChange;

  ;
  nChange = 0;
  ((void)0);
  ((void)0);
  rc = sqlite3BtreeClearTable(
      db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &nChange : 0)
  );
  if( pOp->p3 ){
    p->nChange += nChange;
    if( pOp->p3>0 ){
      ((void)0);
      ;
      aMem[pOp->p3].u.i += nChange;
    }
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 89818 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 138: {
  VdbeCursor *pC;

  ((void)0);
  pC = p->apCsr[pOp->p1];
  ((void)0);
  if( ((pC)->eCurType==1) ){
    sqlite3VdbeSorterReset(db, pC->uc.pSorter);
  }else{
    ((void)0);
    ((void)0);
    rc = sqlite3BtreeClearTableOfCursor(pC->uc.pCursor);
    if( rc ) goto abort_due_to_error;
  }
  break;
}
# 89844 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 139: {
  int pgno;
  Db *pDb;

  ;
  pOut = out2Prerelease(p, pOp);
  pgno = 0;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  pDb = &db->aDb[pOp->p1];
  ((void)0);
  rc = sqlite3BtreeCreateTable(pDb->pBt, &pgno, pOp->p3);
  if( rc ) goto abort_due_to_error;
  pOut->u.i = pgno;
  break;
}





case 140: {
  ;
  db->nSqlExec++;
  rc = sqlite3_exec(db, pOp->p4.z, 0, 0, 0);
  db->nSqlExec--;
  if( rc ) goto abort_due_to_error;
  break;
}
# 89885 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 141: {
  int iDb;
  const char *zMaster;
  char *zSql;
  InitData initData;
# 89901 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  iDb = pOp->p1;
  ((void)0);
  ((void)0);


  if( pOp->p4.z==0 ){
    sqlite3SchemaClear(db->aDb[iDb].pSchema);
    db->mDbFlags &= ~0x0010;
    rc = sqlite3InitOne(db, iDb, &p->zErrMsg, 0x0001);
    db->mDbFlags |= 0x0001;
    p->expired = 0;
  }else

  {
    zMaster = "sqlite_master";
    initData.db = db;
    initData.iDb = iDb;
    initData.pzErrMsg = &p->zErrMsg;
    initData.mInitFlags = 0;
    zSql = sqlite3MPrintf(db,
       "SELECT*FROM\"%w\".%s WHERE %s ORDER BY rowid",
       db->aDb[iDb].zDbSName, zMaster, pOp->p4.z);
    if( zSql==0 ){
      rc = 7;
    }else{
      ((void)0);
      db->init.busy = 1;
      initData.rc = 0;
      initData.nInitRow = 0;
      ((void)0);
      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);
      if( rc==0 ) rc = initData.rc;
      if( rc==0 && initData.nInitRow==0 ){



        rc = sqlite3CorruptError(89937);
      }
      sqlite3DbFreeNN(db, zSql);
      db->init.busy = 0;
    }
  }
  if( rc ){
    sqlite3ResetAllSchemasOfConnection(db);
    if( rc==7 ){
      goto no_mem;
    }
    goto abort_due_to_error;
  }
  break;
}
# 89960 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 142: {
  ((void)0);
  rc = sqlite3AnalysisLoad(db, pOp->p1);
  if( rc ) goto abort_due_to_error;
  break;
}
# 89976 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 143: {
  ;
  sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);
  break;
}
# 89990 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 144: {
  ;
  sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);
  break;
}
# 90004 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 145: {
  ;
  sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);
  break;
}
# 90031 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 146: {
  int nRoot;
  int *aRoot;
  int nErr;
  char *z;
  Mem *pnErr;

  ((void)0);
  nRoot = pOp->p2;
  aRoot = pOp->p4.ai;
  ((void)0);
  ((void)0);
  ((void)0);
  pnErr = &aMem[pOp->p3];
  ((void)0);
  ((void)0);
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  ((void)0);
  z = sqlite3BtreeIntegrityCheck(db->aDb[pOp->p5].pBt, &aRoot[1], nRoot,
                                 (int)pnErr->u.i+1, &nErr);
  sqlite3VdbeMemSetNull(pIn1);
  if( nErr==0 ){
    ((void)0);
  }else if( z==0 ){
    goto no_mem;
  }else{
    pnErr->u.i -= nErr-1;
    sqlite3VdbeMemSetStr(pIn1, z, -1, 1, sqlite3_free);
  }
  ;
  sqlite3VdbeChangeEncoding(pIn1, encoding);
  break;
}
# 90075 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 147: {
  pIn1 = &aMem[pOp->p1];
  pIn2 = &aMem[pOp->p2];
  ((void)0);
  if( (pIn1->flags & 0x0010)==0 ){
    if( sqlite3VdbeMemSetRowSet(pIn1) ) goto no_mem;
  }
  ((void)0);
  sqlite3RowSetInsert((RowSet*)pIn1->z, pIn2->u.i);
  break;
}
# 90095 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 41: {
  i64 val;

  pIn1 = &aMem[pOp->p1];
  ((void)0);
  if( (pIn1->flags & 0x0010)==0
   || sqlite3RowSetNext((RowSet*)pIn1->z, &val)==0
  ){

    sqlite3VdbeMemSetNull(pIn1);
    ;
    goto jump_to_p2_and_check_for_interrupt;
  }else{

    ;
    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], val);
  }
  goto check_for_interrupt;
}
# 90138 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 42: {
  int iSet;
  int exists;

  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  iSet = pOp->p4.i;
  ((void)0);




  if( (pIn1->flags & 0x0010)==0 ){
    if( sqlite3VdbeMemSetRowSet(pIn1) ) goto no_mem;
  }
  ((void)0);
  ((void)0);
  ((void)0);
  if( iSet ){
    exists = sqlite3RowSetTest((RowSet*)pIn1->z, iSet, pIn3->u.i);
    ;
    if( exists ) goto jump_to_p2;
  }
  if( iSet>=0 ){
    sqlite3RowSetInsert((RowSet*)pIn1->z, pIn3->u.i);
  }
  break;
}
# 90185 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 45: {
  int nMem;
  int nByte;
  Mem *pRt;
  Mem *pMem;
  Mem *pEnd;
  VdbeFrame *pFrame;
  SubProgram *pProgram;
  void *t;

  pProgram = pOp->p4.pProgram;
  pRt = &aMem[pOp->p3];
  ((void)0);
# 90210 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pOp->p5 ){
    t = pProgram->token;
    for(pFrame=p->pFrame; pFrame && pFrame->token!=t; pFrame=pFrame->pParent);
    if( pFrame ) break;
  }

  if( p->nFrame>=db->aLimit[10] ){
    rc = 1;
    sqlite3VdbeError(p, "too many levels of trigger recursion");
    goto abort_due_to_error;
  }





  if( (pRt->flags&0x0010)==0 ){





    nMem = pProgram->nMem + pProgram->nCsr;
    ((void)0);
    if( pProgram->nCsr==0 ) nMem++;
    nByte = (((sizeof(VdbeFrame))+7)&~7)
              + nMem * sizeof(Mem)
              + pProgram->nCsr * sizeof(VdbeCursor*)
              + (pProgram->nOp + 7)/8;
    pFrame = sqlite3DbMallocZero(db, nByte);
    if( !pFrame ){
      goto no_mem;
    }
    sqlite3VdbeMemRelease(pRt);
    pRt->flags = 0x0010|0x0400;
    pRt->z = (char*)pFrame;
    pRt->n = nByte;
    pRt->xDel = sqlite3VdbeFrameMemDel;

    pFrame->v = p;
    pFrame->nChildMem = nMem;
    pFrame->nChildCsr = pProgram->nCsr;
    pFrame->pc = (int)(pOp - aOp);
    pFrame->aMem = p->aMem;
    pFrame->nMem = p->nMem;
    pFrame->apCsr = p->apCsr;
    pFrame->nCursor = p->nCursor;
    pFrame->aOp = p->aOp;
    pFrame->nOp = p->nOp;
    pFrame->token = pProgram->token;







    pEnd = &((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame))+7)&~7)])[pFrame->nChildMem];
    for(pMem=((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame))+7)&~7)]); pMem!=pEnd; pMem++){
      pMem->flags = 0x0080;
      pMem->db = db;
    }
  }else{
    pFrame = (VdbeFrame*)pRt->z;
    ((void)0);
    ((void)0)
                                                                       ;
    ((void)0);
    ((void)0);
  }

  p->nFrame++;
  pFrame->pParent = p->pFrame;
  pFrame->lastRowid = db->lastRowid;
  pFrame->nChange = p->nChange;
  pFrame->nDbChange = p->db->nChange;
  ((void)0);
  pFrame->pAuxData = p->pAuxData;
  p->pAuxData = 0;
  p->nChange = 0;
  p->pFrame = pFrame;
  p->aMem = aMem = ((Mem *)&((u8 *)pFrame)[(((sizeof(VdbeFrame))+7)&~7)]);
  p->nMem = pFrame->nChildMem;
  p->nCursor = (u16)pFrame->nChildCsr;
  p->apCsr = (VdbeCursor **)&aMem[p->nMem];
  pFrame->aOnce = (u8*)&p->apCsr[pProgram->nCsr];
  memset(pFrame->aOnce, 0, (pProgram->nOp + 7)/8);
  p->aOp = aOp = pProgram->aOp;
  p->nOp = pProgram->nOp;
# 90313 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pOp = &aOp[-1];
  goto check_for_interrupt;
}
# 90329 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 149: {
  VdbeFrame *pFrame;
  Mem *pIn;
  pOut = out2Prerelease(p, pOp);
  pFrame = p->pFrame;
  pIn = &pFrame->aMem[pOp->p1 + pFrame->aOp[pFrame->pc].p1];
  sqlite3VdbeMemShallowCopy(pOut, pIn, 0x1000);
  break;
}
# 90350 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 150: {
  if( db->flags & 0x00080000 ){
    db->nDeferredImmCons += pOp->p2;
  }else if( pOp->p1 ){
    db->nDeferredCons += pOp->p2;
  }else{
    p->nFkConstraint += pOp->p2;
  }
  break;
}
# 90373 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 46: {
  if( pOp->p1 ){
    ;
    if( db->nDeferredCons==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;
  }else{
    ;
    if( p->nFkConstraint==0 && db->nDeferredImmCons==0 ) goto jump_to_p2;
  }
  break;
}
# 90397 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 151: {
  VdbeFrame *pFrame;
  if( p->pFrame ){
    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);
    pIn1 = &pFrame->aMem[pOp->p1];
  }else{
    pIn1 = &aMem[pOp->p1];
  }
  ((void)0);
  sqlite3VdbeMemIntegerify(pIn1);
  pIn2 = &aMem[pOp->p2];
  sqlite3VdbeMemIntegerify(pIn2);
  if( pIn1->u.i<pIn2->u.i){
    pIn1->u.i = pIn2->u.i;
  }
  break;
}
# 90426 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 47: {
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  ;
  if( pIn1->u.i>0 ){
    pIn1->u.i -= pOp->p3;
    goto jump_to_p2;
  }
  break;
}
# 90455 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 152: {
  i64 x;
  pIn1 = &aMem[pOp->p1];
  pIn3 = &aMem[pOp->p3];
  pOut = out2Prerelease(p, pOp);
  ((void)0);
  ((void)0);
  x = pIn1->u.i;
  if( x<=0 || sqlite3AddInt64(&x, pIn3->u.i>0?pIn3->u.i:0) ){







    pOut->u.i = -1;
  }else{
    pOut->u.i = x;
  }
  break;
}
# 90486 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 48: {
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  ;
  if( pIn1->u.i ){
     if( pIn1->u.i>0 ) pIn1->u.i--;
     goto jump_to_p2;
  }
  break;
}







case 49: {
  pIn1 = &aMem[pOp->p1];
  ((void)0);
  if( pIn1->u.i>(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ) pIn1->u.i--;
  ;
  if( pIn1->u.i==0 ) goto jump_to_p2;
  break;
}
# 90552 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 153:
case 154: {
  int n;
  sqlite3_context *pCtx;

  ((void)0);
  n = pOp->p5;
  ((void)0);
  ((void)0);
  ((void)0);
  pCtx = sqlite3DbMallocRawNN(db, n*sizeof(sqlite3_value*) +
               (sizeof(pCtx[0]) + sizeof(Mem) - sizeof(sqlite3_value*)));
  if( pCtx==0 ) goto no_mem;
  pCtx->pMem = 0;
  pCtx->pOut = (Mem*)&(pCtx->argv[n]);
  sqlite3VdbeMemInit(pCtx->pOut, db, 0x0001);
  pCtx->pFunc = pOp->p4.pFunc;
  pCtx->iOp = (int)(pOp - aOp);
  pCtx->pVdbe = p;
  pCtx->skipFlag = 0;
  pCtx->isError = 0;
  pCtx->argc = n;
  pOp->p4type = (-16);
  pOp->p4.pCtx = pCtx;


  ((void)0);

  pOp->opcode = 155;

}
case 155: {
  int i;
  sqlite3_context *pCtx;
  Mem *pMem;

  ((void)0);
  pCtx = pOp->p4.pCtx;
  pMem = &aMem[pOp->p3];
# 90607 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pCtx->pMem != pMem ){
    pCtx->pMem = pMem;
    for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];
  }
# 90619 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pMem->n++;
  ((void)0);
  ((void)0);
  ((void)0);

  if( pOp->p1 ){
    (pCtx->pFunc->xInverse)(pCtx,pCtx->argc,pCtx->argv);
  }else

  (pCtx->pFunc->xSFunc)(pCtx,pCtx->argc,pCtx->argv);

  if( pCtx->isError ){
    if( pCtx->isError>0 ){
      sqlite3VdbeError(p, "%s", sqlite3_value_text(pCtx->pOut));
      rc = pCtx->isError;
    }
    if( pCtx->skipFlag ){
      ((void)0);
      i = pOp[-1].p1;
      if( i ) sqlite3VdbeMemSetInt64(&aMem[i], 1);
      pCtx->skipFlag = 0;
    }
    sqlite3VdbeMemRelease(pCtx->pOut);
    pCtx->pOut->flags = 0x0001;
    pCtx->isError = 0;
    if( rc ) goto abort_due_to_error;
  }
  ((void)0);
  ((void)0);
  break;
}
# 90677 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 156:
case 157: {
  Mem *pMem;
  ((void)0);
  ((void)0);
  pMem = &aMem[pOp->p1];
  ((void)0);

  if( pOp->p3 ){
    ;
    rc = sqlite3VdbeMemAggValue(pMem, &aMem[pOp->p3], pOp->p4.pFunc);
    pMem = &aMem[pOp->p3];
  }else

  {
    rc = sqlite3VdbeMemFinalize(pMem, pOp->p4.pFunc);
  }

  if( rc ){
    sqlite3VdbeError(p, "%s", sqlite3_value_text(pMem));
    goto abort_due_to_error;
  }
  sqlite3VdbeChangeEncoding(pMem, encoding);
  ;
  if( sqlite3VdbeMemTooBig(pMem) ){
    goto too_big;
  }
  break;
}
# 90719 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 6: {
  int i;
  int aRes[3];
  Mem *pMem;

  ((void)0);
  aRes[0] = 0;
  aRes[1] = aRes[2] = -1;
  ((void)0)



   ;
  rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &aRes[1], &aRes[2]);
  if( rc ){
    if( rc!=5 ) goto abort_due_to_error;
    rc = 0;
    aRes[0] = 1;
  }
  for(i=0, pMem = &aMem[pOp->p3]; i<3; i++, pMem++){
    sqlite3VdbeMemSetInt64(pMem, (i64)aRes[i]);
  }
  break;
};
# 90757 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 7: {
  Btree *pBt;
  Pager *pPager;
  int eNew;
  int eOld;

  const char *zFilename;


  pOut = out2Prerelease(p, pOp);
  eNew = pOp->p3;
  ((void)0)






   ;
  ((void)0);
  ((void)0);

  pBt = db->aDb[pOp->p1].pBt;
  pPager = sqlite3BtreePager(pBt);
  eOld = sqlite3PagerGetJournalMode(pPager);
  if( eNew==(-1) ) eNew = eOld;
  if( !sqlite3PagerOkToChangeJournalMode(pPager) ) eNew = eOld;


  zFilename = sqlite3PagerFilename(pPager, 1);




  if( eNew==5
   && (sqlite3Strlen30(zFilename)==0
       || !sqlite3PagerWalSupported(pPager))
  ){
    eNew = eOld;
  }

  if( (eNew!=eOld)
   && (eOld==5 || eNew==5)
  ){
    if( !db->autoCommit || db->nVdbeRead>1 ){
      rc = 1;
      sqlite3VdbeError(p,
          "cannot change %s wal mode from within a transaction",
          (eNew==5 ? "into" : "out of")
      );
      goto abort_due_to_error;
    }else{

      if( eOld==5 ){





        rc = sqlite3PagerCloseWal(pPager, db);
        if( rc==0 ){
          sqlite3PagerSetJournalMode(pPager, eNew);
        }
      }else if( eOld==4 ){


        sqlite3PagerSetJournalMode(pPager, 2);
      }




      ((void)0);
      if( rc==0 ){
        rc = sqlite3BtreeSetVersion(pBt, (eNew==5 ? 2 : 1));
      }
    }
  }


  if( rc ) eNew = eOld;
  eNew = sqlite3PagerSetJournalMode(pPager, eNew);

  pOut->flags = 0x0002|0x0800|0x0200;
  pOut->z = (char *)sqlite3JournalModename(eNew);
  pOut->n = sqlite3Strlen30(pOut->z);
  pOut->enc = 1;
  sqlite3VdbeChangeEncoding(pOut, encoding);
  if( rc ) goto abort_due_to_error;
  break;
};
# 90860 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 8: {
  ((void)0);
  rc = sqlite3RunVacuum(&p->zErrMsg, db, pOp->p1,
                        pOp->p2 ? &aMem[pOp->p2] : 0);
  if( rc ) goto abort_due_to_error;
  break;
}
# 90876 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 59: {
  Btree *pBt;

  ((void)0);
  ((void)0);
  ((void)0);
  pBt = db->aDb[pOp->p1].pBt;
  rc = sqlite3BtreeIncrVacuum(pBt);
  ;
  if( rc ){
    if( rc!=101 ) goto abort_due_to_error;
    rc = 0;
    goto jump_to_p2;
  }
  break;
}
# 90910 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 158: {
  ((void)0);
  if( !pOp->p1 ){
    sqlite3ExpirePreparedStatements(db, pOp->p2);
  }else{
    p->expired = pOp->p2+1;
  }
  break;
}
# 90936 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 159: {
  u8 isWriteLock = (u8)pOp->p3;
  if( isWriteLock || 0==(db->flags&0x00000400) ){
    int p1 = pOp->p1;
    ((void)0);
    ((void)0);
    ((void)0);
    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);
    if( rc ){
      if( (rc&0xFF)==6 ){
        const char *z = pOp->p4.z;
        sqlite3VdbeError(p, "database table is locked: %s", z);
      }
      goto abort_due_to_error;
    }
  }
  break;
}
# 90966 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 160: {
  VTable *pVTab;
  pVTab = pOp->p4.pVtab;
  rc = sqlite3VtabBegin(db, pVTab);
  if( pVTab ) sqlite3VtabImportErrmsg(p, pVTab->pVtab);
  if( rc ) goto abort_due_to_error;
  break;
}
# 90982 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 161: {
  Mem sMem;
  const char *zTab;

  memset(&sMem, 0, sizeof(sMem));
  sMem.db = db;


  ((void)0);
  ((void)0);
  rc = sqlite3VdbeMemCopy(&sMem, &aMem[pOp->p2]);
  ((void)0);
  zTab = (const char*)sqlite3_value_text(&sMem);
  ((void)0);
  if( zTab ){
    rc = sqlite3VtabCallCreate(db, pOp->p1, zTab, &p->zErrMsg);
  }
  sqlite3VdbeMemRelease(&sMem);
  if( rc ) goto abort_due_to_error;
  break;
}
# 91011 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 162: {
  db->nVDestroy++;
  rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);
  db->nVDestroy--;
  ((void)0);
  if( rc ) goto abort_due_to_error;
  break;
}
# 91028 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 163: {
  VdbeCursor *pCur;
  sqlite3_vtab_cursor *pVCur;
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;

  ((void)0);
  pCur = 0;
  pVCur = 0;
  pVtab = pOp->p4.pVtab->pVtab;
  if( pVtab==0 || (pVtab->pModule==0) ){
    rc = 6;
    goto abort_due_to_error;
  }
  pModule = pVtab->pModule;
  rc = pModule->xOpen(pVtab, &pVCur);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( rc ) goto abort_due_to_error;


  pVCur->pVtab = pVtab;


  pCur = allocateCursor(p, pOp->p1, 0, -1, 2);
  if( pCur ){
    pCur->uc.pVCur = pVCur;
    pVtab->nRef++;
  }else{
    ((void)0);
    pModule->xClose(pVCur);
    goto no_mem;
  }
  break;
}
# 91084 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 9: {
  int nArg;
  int iQuery;
  const sqlite3_module *pModule;
  Mem *pQuery;
  Mem *pArgc;
  sqlite3_vtab_cursor *pVCur;
  sqlite3_vtab *pVtab;
  VdbeCursor *pCur;
  int res;
  int i;
  Mem **apArg;

  pQuery = &aMem[pOp->p3];
  pArgc = &pQuery[1];
  pCur = p->apCsr[pOp->p1];
  ((void)0);
  ;
  ((void)0);
  pVCur = pCur->uc.pVCur;
  pVtab = pVCur->pVtab;
  pModule = pVtab->pModule;


  ((void)0);
  nArg = (int)pArgc->u.i;
  iQuery = (int)pQuery->u.i;


  res = 0;
  apArg = p->apArg;
  for(i = 0; i<nArg; i++){
    apArg[i] = &pArgc[i+1];
  }
  rc = pModule->xFilter(pVCur, iQuery, pOp->p4.z, nArg, apArg);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( rc ) goto abort_due_to_error;
  res = pModule->xEof(pVCur);
  pCur->nullRow = 0;
  ;
  if( res ) goto jump_to_p2;
  break;
}
# 91144 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 164: {
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;
  Mem *pDest;
  sqlite3_context sContext;

  VdbeCursor *pCur = p->apCsr[pOp->p1];
  ((void)0);
  ((void)0);
  pDest = &aMem[pOp->p3];
  ;
  if( pCur->nullRow ){
    sqlite3VdbeMemSetNull(pDest);
    break;
  }
  pVtab = pCur->uc.pVCur->pVtab;
  pModule = pVtab->pModule;
  ((void)0);
  memset(&sContext, 0, sizeof(sContext));
  sContext.pOut = pDest;
  ;
  if( pOp->p5 & 0x01 ){
    sqlite3VdbeMemSetNull(pDest);
    pDest->flags = 0x0001|0x4000;
    pDest->u.nZero = 0;
  }else{
    ((pDest)->flags = ((pDest)->flags&~(0xc1bf|0x4000))|0x0001);
  }
  rc = pModule->xColumn(pCur->uc.pVCur, &sContext, pOp->p2);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( sContext.isError>0 ){
    sqlite3VdbeError(p, "%s", sqlite3_value_text(pDest));
    rc = sContext.isError;
  }
  sqlite3VdbeChangeEncoding(pDest, encoding);
  ;
  ;

  if( sqlite3VdbeMemTooBig(pDest) ){
    goto too_big;
  }
  if( rc ) goto abort_due_to_error;
  break;
}
# 91197 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 60: {
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;
  int res;
  VdbeCursor *pCur;

  res = 0;
  pCur = p->apCsr[pOp->p1];
  ((void)0);
  if( pCur->nullRow ){
    break;
  }
  pVtab = pCur->uc.pVCur->pVtab;
  pModule = pVtab->pModule;
  ((void)0);







  rc = pModule->xNext(pCur->uc.pVCur);
  sqlite3VtabImportErrmsg(p, pVtab);
  if( rc ) goto abort_due_to_error;
  res = pModule->xEof(pCur->uc.pVCur);
  ;
  if( !res ){

    goto jump_to_p2_and_check_for_interrupt;
  }
  goto check_for_interrupt;
}
# 91239 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 165: {
  sqlite3_vtab *pVtab;
  Mem *pName;
  int isLegacy;

  isLegacy = (db->flags & 0x04000000);
  db->flags |= 0x04000000;
  pVtab = pOp->p4.pVtab->pVtab;
  pName = &aMem[pOp->p1];
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  ((void)0);
  ;
  ;
  ;
  rc = sqlite3VdbeChangeEncoding(pName, 1);
  if( rc ) goto abort_due_to_error;
  rc = pVtab->pModule->xRename(pVtab, pName->z);
  if( isLegacy==0 ) db->flags &= ~(u64)0x04000000;
  sqlite3VtabImportErrmsg(p, pVtab);
  p->expired = 0;
  if( rc ) goto abort_due_to_error;
  break;
}
# 91295 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 10: {
  sqlite3_vtab *pVtab;
  const sqlite3_module *pModule;
  int nArg;
  int i;
  sqlite_int64 rowid;
  Mem **apArg;
  Mem *pX;

  ((void)0)

   ;
  ((void)0);
  if( db->mallocFailed ) goto no_mem;
  ;
  pVtab = pOp->p4.pVtab->pVtab;
  if( pVtab==0 || (pVtab->pModule==0) ){
    rc = 6;
    goto abort_due_to_error;
  }
  pModule = pVtab->pModule;
  nArg = pOp->p2;
  ((void)0);
  if( (pModule->xUpdate) ){
    u8 vtabOnConflict = db->vtabOnConflict;
    apArg = p->apArg;
    pX = &aMem[pOp->p3];
    for(i=0; i<nArg; i++){
      ((void)0);
      ;
      apArg[i] = pX;
      pX++;
    }
    db->vtabOnConflict = pOp->p5;
    rc = pModule->xUpdate(pVtab, nArg, apArg, &rowid);
    db->vtabOnConflict = vtabOnConflict;
    sqlite3VtabImportErrmsg(p, pVtab);
    if( rc==0 && pOp->p1 ){
      ((void)0);
      db->lastRowid = rowid;
    }
    if( (rc&0xff)==19 && pOp->p4.pVtab->bConstraint ){
      if( pOp->p5==4 ){
        rc = 0;
      }else{
        p->errorAction = ((pOp->p5==5) ? 2 : pOp->p5);
      }
    }else{
      p->nChange++;
    }
    if( rc ) goto abort_due_to_error;
  }
  break;
}







case 166: {
  pOut = out2Prerelease(p, pOp);
  pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);
  break;
}
# 91373 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 167: {
  unsigned int newMax;
  Btree *pBt;

  pOut = out2Prerelease(p, pOp);
  pBt = db->aDb[pOp->p1].pBt;
  newMax = 0;
  if( pOp->p3 ){
    newMax = sqlite3BtreeLastPage(pBt);
    if( newMax < (unsigned)pOp->p3 ) newMax = (unsigned)pOp->p3;
  }
  pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);
  break;
}
# 91430 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 62:
case 63: {
  int n;
  sqlite3_context *pCtx;

  ((void)0);
  n = pOp->p5;
  ((void)0);
  ((void)0);
  ((void)0);
  pCtx = sqlite3DbMallocRawNN(db, sizeof(*pCtx) + (n-1)*sizeof(sqlite3_value*));
  if( pCtx==0 ) goto no_mem;
  pCtx->pOut = 0;
  pCtx->pFunc = pOp->p4.pFunc;
  pCtx->iOp = (int)(pOp - aOp);
  pCtx->pVdbe = p;
  pCtx->isError = 0;
  pCtx->argc = n;
  pOp->p4type = (-16);
  pOp->p4.pCtx = pCtx;
  ((void)0);
  ((void)0);
  pOp->opcode += 2;

}
case 64:
case 65: {
  int i;
  sqlite3_context *pCtx;

  ((void)0);
  pCtx = pOp->p4.pCtx;





  pOut = &aMem[pOp->p3];
  if( pCtx->pOut != pOut ){
    pCtx->pOut = pOut;
    for(i=pCtx->argc-1; i>=0; i--) pCtx->argv[i] = &aMem[pOp->p2+i];
  }

  ;






  ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0001);
  ((void)0);
  (*pCtx->pFunc->xSFunc)(pCtx, pCtx->argc, pCtx->argv);


  if( pCtx->isError ){
    if( pCtx->isError>0 ){
      sqlite3VdbeError(p, "%s", sqlite3_value_text(pOut));
      rc = pCtx->isError;
    }
    sqlite3VdbeDeleteAuxData(db, &p->pAuxData, pCtx->iOp, pOp->p1);
    pCtx->isError = 0;
    if( rc ) goto abort_due_to_error;
  }


  if( pOut->flags & (0x0002|0x0010) ){
    sqlite3VdbeChangeEncoding(pOut, encoding);
    if( sqlite3VdbeMemTooBig(pOut) ) goto too_big;
  }

  ;
  ;
  break;
}
# 91531 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
case 168:
case 61: {
  int i;

  char *zTrace;
# 91547 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);


  ((void)0);


  if( (db->mTrace & (0x01|0x40))!=0
   && !p->doingRerun
   && (zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql))!=0
  ){

    if( db->mTrace & 0x40 ){
      void (*x)(void*,const char*) = (void(*)(void*,const char*))db->xTrace;
      char *z = sqlite3VdbeExpandSql(p, zTrace);
      x(db->pTraceArg, z);
      sqlite3_free(z);
    }else

    if( db->nVdbeExec>1 ){
      char *z = sqlite3MPrintf(db, "-- %s", zTrace);
      (void)db->xTrace(0x01, db->pTraceArg, p, z);
      sqlite3DbFree(db, z);
    }else{
      (void)db->xTrace(0x01, db->pTraceArg, p, zTrace);
    }
  }
# 91591 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( pOp->p1>=sqlite3Config.iOnceResetThreshold ){
    if( pOp->opcode==168 ) break;
    for(i=1; i<p->nOp; i++){
      if( p->aOp[i].opcode==17 ) p->aOp[i].p1 = 0;
    }
    pOp->p1 = 0;
  }
  pOp->p1++;
  p->aCounter[6]++;
  goto jump_to_p2;
}
# 91654 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
default: {
  ((void)0);

  break;
}







    }
# 91697 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }




abort_due_to_error:
  if( db->mallocFailed ) rc = 7;
  ((void)0);
  if( p->zErrMsg==0 && rc!=(10 | (12<<8)) ){
    sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc));
  }
  p->rc = rc;
  sqlite3SystemError(db, rc);
  ;
  sqlite3_log(rc, "statement aborts at %d: [%s] %s",
                   (int)(pOp - aOp), p->zSql, p->zErrMsg);
  sqlite3VdbeHalt(p);
  if( rc==(10 | (12<<8)) ) sqlite3OomFault(db);
  rc = 1;
  if( resetSchemaOnFault>0 ){
    sqlite3ResetOneSchema(db, resetSchemaOnFault-1);
  }




vdbe_return:

  while( nVmStep>=nProgressLimit && db->xProgress!=0 ){
    nProgressLimit += db->nProgressOps;
    if( db->xProgress(db->pProgressArg) ){
      nProgressLimit = 0xffffffff;
      rc = 9;
      goto abort_due_to_error;
    }
  }

  p->aCounter[4] += (int)nVmStep;
  sqlite3VdbeLeave(p);
  ((void)0)

   ;
  return rc;




too_big:
  sqlite3VdbeError(p, "string or blob too big");
  rc = 18;
  goto abort_due_to_error;



no_mem:
  sqlite3OomFault(db);
  sqlite3VdbeError(p, "out of memory");
  rc = 7;
  goto abort_due_to_error;




abort_due_to_interrupt:
  ((void)0);
  rc = db->mallocFailed ? 7 : 9;
  p->rc = rc;
  sqlite3VdbeError(p, "%s", sqlite3ErrStr(rc));
  goto abort_due_to_error;
}
# 91794 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct Incrblob Incrblob;
struct Incrblob {
  int nByte;
  int iOffset;
  u16 iCol;
  BtCursor *pCsr;
  sqlite3_stmt *pStmt;
  sqlite3 *db;
  char *zDb;
  Table *pTab;
};
# 91824 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){
  int rc;
  char *zErr = 0;
  Vdbe *v = (Vdbe *)p->pStmt;




  v->aMem[1].flags = 0x0004;
  v->aMem[1].u.i = iRow;





  if( v->pc>4 ){
    v->pc = 4;
    ((void)0);
    rc = sqlite3VdbeExec(v);
  }else{
    rc = sqlite3_step(p->pStmt);
  }
  if( rc==100 ){
    VdbeCursor *pC = v->apCsr[0];
    u32 type = pC->nHdrParsed>p->iCol ? pC->aType[p->iCol] : 0;
    ;
    ;
    if( type<12 ){
      zErr = sqlite3MPrintf(p->db, "cannot open value of type %s",
          type==0?"null": type==7?"real": "integer"
      );
      rc = 1;
      sqlite3_finalize(p->pStmt);
      p->pStmt = 0;
    }else{
      p->iOffset = pC->aType[p->iCol + pC->nField];
      p->nByte = sqlite3VdbeSerialTypeLen(type);
      p->pCsr = pC->uc.pCursor;
      sqlite3BtreeIncrblobCursor(p->pCsr);
    }
  }

  if( rc==100 ){
    rc = 0;
  }else if( p->pStmt ){
    rc = sqlite3_finalize(p->pStmt);
    p->pStmt = 0;
    if( rc==0 ){
      zErr = sqlite3MPrintf(p->db, "no such rowid: %lld", iRow);
      rc = 1;
    }else{
      zErr = sqlite3MPrintf(p->db, "%s", sqlite3_errmsg(p->db));
    }
  }

  ((void)0);
  ((void)0);

  *pzErr = zErr;
  return rc;
}




 int sqlite3_blob_open(
  sqlite3* db,
  const char *zDb,
  const char *zTable,
  const char *zColumn,
  sqlite_int64 iRow,
  int wrFlag,
  sqlite3_blob **ppBlob
){
  int nAttempt = 0;
  int iCol;
  int rc = 0;
  char *zErr = 0;
  Table *pTab;
  Incrblob *pBlob = 0;
  Parse sParse;






  *ppBlob = 0;





  wrFlag = !!wrFlag;

  sqlite3_mutex_enter(db->mutex);

  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));
  do {
    memset(&sParse, 0, sizeof(Parse));
    if( !pBlob ) goto blob_open_out;
    sParse.db = db;
    sqlite3DbFree(db, zErr);
    zErr = 0;

    sqlite3BtreeEnterAll(db);
    pTab = sqlite3LocateTable(&sParse, 0, zTable, zDb);
    if( pTab && ((pTab)->nModuleArg) ){
      pTab = 0;
      sqlite3ErrorMsg(&sParse, "cannot open virtual table: %s", zTable);
    }
    if( pTab && !(((pTab)->tabFlags & 0x0020)==0) ){
      pTab = 0;
      sqlite3ErrorMsg(&sParse, "cannot open table without rowid: %s", zTable);
    }

    if( pTab && pTab->pSelect ){
      pTab = 0;
      sqlite3ErrorMsg(&sParse, "cannot open view: %s", zTable);
    }

    if( !pTab ){
      if( sParse.zErrMsg ){
        sqlite3DbFree(db, zErr);
        zErr = sParse.zErrMsg;
        sParse.zErrMsg = 0;
      }
      rc = 1;
      sqlite3BtreeLeaveAll(db);
      goto blob_open_out;
    }
    pBlob->pTab = pTab;
    pBlob->zDb = db->aDb[sqlite3SchemaToIndex(db, pTab->pSchema)].zDbSName;


    for(iCol=0; iCol<pTab->nCol; iCol++) {
      if( sqlite3StrICmp(pTab->aCol[iCol].zName, zColumn)==0 ){
        break;
      }
    }
    if( iCol==pTab->nCol ){
      sqlite3DbFree(db, zErr);
      zErr = sqlite3MPrintf(db, "no such column: \"%s\"", zColumn);
      rc = 1;
      sqlite3BtreeLeaveAll(db);
      goto blob_open_out;
    }




    if( wrFlag ){
      const char *zFault = 0;
      Index *pIdx;

      if( db->flags&0x00004000 ){




        FKey *pFKey;
        for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){
          int j;
          for(j=0; j<pFKey->nCol; j++){
            if( pFKey->aCol[j].iFrom==iCol ){
              zFault = "foreign key";
            }
          }
        }
      }

      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
        int j;
        for(j=0; j<pIdx->nKeyCol; j++){

          if( pIdx->aiColumn[j]==iCol || pIdx->aiColumn[j]==(-2) ){
            zFault = "indexed";
          }
        }
      }
      if( zFault ){
        sqlite3DbFree(db, zErr);
        zErr = sqlite3MPrintf(db, "cannot open %s column for writing", zFault);
        rc = 1;
        sqlite3BtreeLeaveAll(db);
        goto blob_open_out;
      }
    }

    pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(&sParse);
    ((void)0);
    if( pBlob->pStmt ){
# 92032 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      static const int iLn = 0;
      static const VdbeOpList openBlob[] = {
        {159, 0, 0, 0},
        {97, 0, 0, 0},

        {31, 0, 5, 1},
        {90, 0, 0, 1},
        {81, 1, 0, 0},
        {69, 0, 0, 0},
      };
      Vdbe *v = (Vdbe *)pBlob->pStmt;
      int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      VdbeOp *aOp;

      sqlite3VdbeAddOp4Int(v, 2, iDb, wrFlag,
                           pTab->pSchema->schema_cookie,
                           pTab->pSchema->iGeneration);
      sqlite3VdbeChangeP5(v, 1);
      ((void)0);
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(openBlob)/sizeof(openBlob[0]))), openBlob, iLn);


      sqlite3VdbeUsesBtree(v, iDb);

      if( db->mallocFailed==0 ){
        ((void)0);




        aOp[0].p1 = iDb;
        aOp[0].p2 = pTab->tnum;
        aOp[0].p3 = wrFlag;
        sqlite3VdbeChangeP4(v, 2, pTab->zName, 0);
      }
      if( db->mallocFailed==0 ){




        if( wrFlag ) aOp[1].opcode = 98;
        aOp[1].p2 = pTab->tnum;
        aOp[1].p3 = iDb;
# 92083 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        aOp[1].p4type = (-3);
        aOp[1].p4.i = pTab->nCol+1;
        aOp[3].p2 = pTab->nCol;

        sParse.nVar = 0;
        sParse.nMem = 1;
        sParse.nTab = 1;
        sqlite3VdbeMakeReady(v, &sParse);
      }
    }

    pBlob->iCol = iCol;
    pBlob->db = db;
    sqlite3BtreeLeaveAll(db);
    if( db->mallocFailed ){
      goto blob_open_out;
    }
    rc = blobSeekToRow(pBlob, iRow, &zErr);
  } while( (++nAttempt)<50 && rc==17 );

blob_open_out:
  if( rc==0 && db->mallocFailed==0 ){
    *ppBlob = (sqlite3_blob *)pBlob;
  }else{
    if( pBlob && pBlob->pStmt ) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);
    sqlite3DbFree(db, pBlob);
  }
  sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);
  sqlite3DbFree(db, zErr);
  sqlite3ParserReset(&sParse);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





 int sqlite3_blob_close(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  int rc;
  sqlite3 *db;

  if( p ){
    sqlite3_stmt *pStmt = p->pStmt;
    db = p->db;
    sqlite3_mutex_enter(db->mutex);
    sqlite3DbFree(db, p);
    sqlite3_mutex_leave(db->mutex);
    rc = sqlite3_finalize(pStmt);
  }else{
    rc = 0;
  }
  return rc;
}




static int blobReadWrite(
  sqlite3_blob *pBlob,
  void *z,
  int n,
  int iOffset,
  int (*xCall)(BtCursor*, u32, u32, void*)
){
  int rc;
  Incrblob *p = (Incrblob *)pBlob;
  Vdbe *v;
  sqlite3 *db;

  if( p==0 ) return sqlite3MisuseError(92155);
  db = p->db;
  sqlite3_mutex_enter(db->mutex);
  v = (Vdbe*)p->pStmt;

  if( n<0 || iOffset<0 || ((sqlite3_int64)iOffset+n)>p->nByte ){

    rc = 1;
  }else if( v==0 ){



    rc = 4;
  }else{



    ((void)0);
    sqlite3BtreeEnterCursor(p->pCsr);
# 92198 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);
    sqlite3BtreeLeaveCursor(p->pCsr);
    if( rc==4 ){
      sqlite3VdbeFinalize(v);
      p->pStmt = 0;
    }else{
      v->rc = rc;
    }
  }
  sqlite3Error(db, rc);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




 int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){
  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreePayloadChecked);
}




 int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){
  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);
}







 int sqlite3_blob_bytes(sqlite3_blob *pBlob){
  Incrblob *p = (Incrblob *)pBlob;
  return (p && p->pStmt) ? p->nByte : 0;
}
# 92248 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){
  int rc;
  Incrblob *p = (Incrblob *)pBlob;
  sqlite3 *db;

  if( p==0 ) return sqlite3MisuseError(92253);
  db = p->db;
  sqlite3_mutex_enter(db->mutex);

  if( p->pStmt==0 ){



    rc = 4;
  }else{
    char *zErr;
    rc = blobSeekToRow(p, iRow, &zErr);
    if( rc!=0 ){
      sqlite3ErrorWithMsg(db, rc, (zErr ? "%s" : 0), zErr);
      sqlite3DbFree(db, zErr);
    }
    ((void)0);
  }

  rc = sqlite3ApiExit(db, rc);
  ((void)0);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 92436 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_PMASZ (1<<29)




typedef struct MergeEngine MergeEngine;
typedef struct PmaReader PmaReader;
typedef struct PmaWriter PmaWriter;
typedef struct SorterRecord SorterRecord;
typedef struct SortSubtask SortSubtask;
typedef struct SorterFile SorterFile;
typedef struct SorterList SorterList;
typedef struct IncrMerger IncrMerger;





struct SorterFile {
  sqlite3_file *pFd;
  i64 iEof;
};
# 92467 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct SorterList {
  SorterRecord *pList;
  u8 *aMemory;
  int szPMA;
};
# 92537 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct MergeEngine {
  int nTree;
  SortSubtask *pTask;
  int *aTree;
  PmaReader *aReadr;
};
# 92575 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef int (*SorterCompare)(SortSubtask*,int*,const void*,int,const void*,int);
struct SortSubtask {
  SQLiteThread *pThread;
  int bDone;
  VdbeSorter *pSorter;
  UnpackedRecord *pUnpacked;
  SorterList list;
  int nPMA;
  SorterCompare xCompare;
  SorterFile file;
  SorterFile file2;
};
# 92598 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct VdbeSorter {
  int mnPmaSize;
  int mxPmaSize;
  int mxKeysize;
  int pgsz;
  PmaReader *pReader;
  MergeEngine *pMerger;
  sqlite3 *db;
  KeyInfo *pKeyInfo;
  UnpackedRecord *pUnpacked;
  SorterList list;
  int iMemory;
  int nMemory;
  u8 bUsePMA;
  u8 bUseThreads;
  u8 iPrev;
  u8 nTask;
  u8 typeMask;
  SortSubtask aTask[1];
};

#define SORTER_TYPE_INTEGER 0x01
#define SORTER_TYPE_TEXT 0x02
# 92631 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct PmaReader {
  i64 iReadOff;
  i64 iEof;
  int nAlloc;
  int nKey;
  sqlite3_file *pFd;
  u8 *aAlloc;
  u8 *aKey;
  u8 *aBuffer;
  int nBuffer;
  u8 *aMap;
  IncrMerger *pIncr;
};
# 92677 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct IncrMerger {
  SortSubtask *pTask;
  MergeEngine *pMerger;
  i64 iStartOff;
  int mxSz;
  int bEof;
  int bUseThread;
  SorterFile aFile[2];
};
# 92695 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct PmaWriter {
  int eFWErr;
  u8 *aBuffer;
  int nBuffer;
  int iBufStart;
  int iBufEnd;
  i64 iWriteOff;
  sqlite3_file *pFd;
};
# 92723 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct SorterRecord {
  int nVal;
  union {
    SorterRecord *pNext;
    int iNext;
  } u;

};






#define SRVAL(p) ((void*)((SorterRecord*)(p) + 1))



#define SORTER_MAX_MERGE_COUNT 16

static int vdbeIncrSwap(IncrMerger*);
static void vdbeIncrFree(IncrMerger *);





static void vdbePmaReaderClear(PmaReader *pReadr){
  sqlite3_free(pReadr->aAlloc);
  sqlite3_free(pReadr->aBuffer);
  if( pReadr->aMap ) sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
  vdbeIncrFree(pReadr->pIncr);
  memset(pReadr, 0, sizeof(PmaReader));
}
# 92767 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbePmaReadBlob(
  PmaReader *p,
  int nByte,
  u8 **ppOut
){
  int iBuf;
  int nAvail;

  if( p->aMap ){
    *ppOut = &p->aMap[p->iReadOff];
    p->iReadOff += nByte;
    return 0;
  }

  ((void)0);




  iBuf = p->iReadOff % p->nBuffer;
  if( iBuf==0 ){
    int nRead;
    int rc;


    if( (p->iEof - p->iReadOff) > (i64)p->nBuffer ){
      nRead = p->nBuffer;
    }else{
      nRead = (int)(p->iEof - p->iReadOff);
    }
    ((void)0);


    rc = sqlite3OsRead(p->pFd, p->aBuffer, nRead, p->iReadOff);
    ((void)0);
    if( rc!=0 ) return rc;
  }
  nAvail = p->nBuffer - iBuf;

  if( nByte<=nAvail ){



    *ppOut = &p->aBuffer[iBuf];
    p->iReadOff += nByte;
  }else{



    int nRem;


    if( p->nAlloc<nByte ){
      u8 *aNew;
      sqlite3_int64 nNew = ((128)>(2*(sqlite3_int64)p->nAlloc)?(128):(2*(sqlite3_int64)p->nAlloc));
      while( nByte>nNew ) nNew = nNew*2;
      aNew = sqlite3Realloc(p->aAlloc, nNew);
      if( !aNew ) return 7;
      p->nAlloc = nNew;
      p->aAlloc = aNew;
    }



    memcpy(p->aAlloc, &p->aBuffer[iBuf], nAvail);
    p->iReadOff += nAvail;
    nRem = nByte - nAvail;



    while( nRem>0 ){
      int rc;
      int nCopy;
      u8 *aNext;

      nCopy = nRem;
      if( nRem>p->nBuffer ) nCopy = p->nBuffer;
      rc = vdbePmaReadBlob(p, nCopy, &aNext);
      if( rc!=0 ) return rc;
      ((void)0);
      memcpy(&p->aAlloc[nByte - nRem], aNext, nCopy);
      nRem -= nCopy;
    }

    *ppOut = p->aAlloc;
  }

  return 0;
}





static int vdbePmaReadVarint(PmaReader *p, u64 *pnOut){
  int iBuf;

  if( p->aMap ){
    p->iReadOff += sqlite3GetVarint(&p->aMap[p->iReadOff], pnOut);
  }else{
    iBuf = p->iReadOff % p->nBuffer;
    if( iBuf && (p->nBuffer-iBuf)>=9 ){
      p->iReadOff += sqlite3GetVarint(&p->aBuffer[iBuf], pnOut);
    }else{
      u8 aVarint[16], *a;
      int i = 0, rc;
      do{
        rc = vdbePmaReadBlob(p, 1, &a);
        if( rc ) return rc;
        aVarint[(i++)&0xf] = a[0];
      }while( (a[0]&0x80)!=0 );
      sqlite3GetVarint(aVarint, pnOut);
    }
  }

  return 0;
}
# 92894 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterMapFile(SortSubtask *pTask, SorterFile *pFile, u8 **pp){
  int rc = 0;
  if( pFile->iEof<=(i64)(pTask->pSorter->db->nMaxSorterMmap) ){
    sqlite3_file *pFd = pFile->pFd;
    if( pFd->pMethods->iVersion>=3 ){
      rc = sqlite3OsFetch(pFd, 0, (int)pFile->iEof, (void**)pp);
      ;
    }
  }
  return rc;
}






static int vdbePmaReaderSeek(
  SortSubtask *pTask,
  PmaReader *pReadr,
  SorterFile *pFile,
  i64 iOff
){
  int rc = 0;

  ((void)0);

  if( sqlite3FaultSim(201) ) return (10 | (1<<8));
  if( pReadr->aMap ){
    sqlite3OsUnfetch(pReadr->pFd, 0, pReadr->aMap);
    pReadr->aMap = 0;
  }
  pReadr->iReadOff = iOff;
  pReadr->iEof = pFile->iEof;
  pReadr->pFd = pFile->pFd;

  rc = vdbeSorterMapFile(pTask, pFile, &pReadr->aMap);
  if( rc==0 && pReadr->aMap==0 ){
    int pgsz = pTask->pSorter->pgsz;
    int iBuf = pReadr->iReadOff % pgsz;
    if( pReadr->aBuffer==0 ){
      pReadr->aBuffer = (u8*)sqlite3Malloc(pgsz);
      if( pReadr->aBuffer==0 ) rc = 7;
      pReadr->nBuffer = pgsz;
    }
    if( rc==0 && iBuf ){
      int nRead = pgsz - iBuf;
      if( (pReadr->iReadOff + nRead) > pReadr->iEof ){
        nRead = (int)(pReadr->iEof - pReadr->iReadOff);
      }
      rc = sqlite3OsRead(
          pReadr->pFd, &pReadr->aBuffer[iBuf], nRead, pReadr->iReadOff
      );
      ;
    }
  }

  return rc;
}





static int vdbePmaReaderNext(PmaReader *pReadr){
  int rc = 0;
  u64 nRec = 0;


  if( pReadr->iReadOff>=pReadr->iEof ){
    IncrMerger *pIncr = pReadr->pIncr;
    int bEof = 1;
    if( pIncr ){
      rc = vdbeIncrSwap(pIncr);
      if( rc==0 && pIncr->bEof==0 ){
        rc = vdbePmaReaderSeek(
            pIncr->pTask, pReadr, &pIncr->aFile[0], pIncr->iStartOff
        );
        bEof = 0;
      }
    }

    if( bEof ){

      vdbePmaReaderClear(pReadr);
      ;
      return rc;
    }
  }

  if( rc==0 ){
    rc = vdbePmaReadVarint(pReadr, &nRec);
  }
  if( rc==0 ){
    pReadr->nKey = (int)nRec;
    rc = vdbePmaReadBlob(pReadr, (int)nRec, &pReadr->aKey);
    ;
  }

  return rc;
}
# 93005 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbePmaReaderInit(
  SortSubtask *pTask,
  SorterFile *pFile,
  i64 iStart,
  PmaReader *pReadr,
  i64 *pnByte
){
  int rc;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  rc = vdbePmaReaderSeek(pTask, pReadr, pFile, iStart);
  if( rc==0 ){
    u64 nByte = 0;
    rc = vdbePmaReadVarint(pReadr, &nByte);
    pReadr->iEof = pReadr->iReadOff + nByte;
    *pnByte += nByte;
  }

  if( rc==0 ){
    rc = vdbePmaReaderNext(pReadr);
  }
  return rc;
}






static int vdbeSorterCompareTail(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  UnpackedRecord *r2 = pTask->pUnpacked;
  if( *pbKey2Cached==0 ){
    sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  return sqlite3VdbeRecordCompareWithSkip(nKey1, pKey1, r2, 1);
}
# 93065 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterCompare(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  UnpackedRecord *r2 = pTask->pUnpacked;
  if( !*pbKey2Cached ){
    sqlite3VdbeRecordUnpack(pTask->pSorter->pKeyInfo, nKey2, pKey2, r2);
    *pbKey2Cached = 1;
  }
  return sqlite3VdbeRecordCompare(nKey1, pKey1, r2);
}






static int vdbeSorterCompareText(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  const u8 * const p1 = (const u8 * const)pKey1;
  const u8 * const p2 = (const u8 * const)pKey2;
  const u8 * const v1 = &p1[ p1[0] ];
  const u8 * const v2 = &p2[ p2[0] ];

  int n1;
  int n2;
  int res;

  (u8)((*(&p1[1])<(u8)0x80)?((n1)=(u32)*(&p1[1])),1:sqlite3GetVarint32((&p1[1]),(u32 *)&(n1)));
  (u8)((*(&p2[1])<(u8)0x80)?((n2)=(u32)*(&p2[1])),1:sqlite3GetVarint32((&p2[1]),(u32 *)&(n2)));
  res = memcmp(v1, v2, (((n1)<(n2)?(n1):(n2)) - 13)/2);
  if( res==0 ){
    res = n1 - n2;
  }

  if( res==0 ){
    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
      res = vdbeSorterCompareTail(
          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
      );
    }
  }else{
    ((void)0);
    if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
      res = res * -1;
    }
  }

  return res;
}





static int vdbeSorterCompareInt(
  SortSubtask *pTask,
  int *pbKey2Cached,
  const void *pKey1, int nKey1,
  const void *pKey2, int nKey2
){
  const u8 * const p1 = (const u8 * const)pKey1;
  const u8 * const p2 = (const u8 * const)pKey2;
  const int s1 = p1[1];
  const int s2 = p2[1];
  const u8 * const v1 = &p1[ p1[0] ];
  const u8 * const v2 = &p2[ p2[0] ];
  int res;

  ((void)0);
  ((void)0);

  if( s1==s2 ){

    static const u8 aLen[] = {0, 1, 2, 3, 4, 6, 8, 0, 0, 0 };
    const u8 n = aLen[s1];
    int i;
    res = 0;
    for(i=0; i<n; i++){
      if( (res = v1[i] - v2[i])!=0 ){
        if( ((v1[0] ^ v2[0]) & 0x80)!=0 ){
          res = v1[0] & 0x80 ? -1 : +1;
        }
        break;
      }
    }
  }else if( s1>7 && s2>7 ){
    res = s1 - s2;
  }else{
    if( s2>7 ){
      res = +1;
    }else if( s1>7 ){
      res = -1;
    }else{
      res = s1 - s2;
    }
    ((void)0);

    if( res>0 ){
      if( *v1 & 0x80 ) res = -1;
    }else{
      if( *v2 & 0x80 ) res = +1;
    }
  }

  if( res==0 ){
    if( pTask->pSorter->pKeyInfo->nKeyField>1 ){
      res = vdbeSorterCompareTail(
          pTask, pbKey2Cached, pKey1, nKey1, pKey2, nKey2
      );
    }
  }else if( pTask->pSorter->pKeyInfo->aSortFlags[0] ){
    ((void)0);
    res = res * -1;
  }

  return res;
}
# 93209 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeSorterInit(
  sqlite3 *db,
  int nField,
  VdbeCursor *pCsr
){
  int pgsz;
  int i;
  VdbeSorter *pSorter;
  KeyInfo *pKeyInfo;
  int szKeyInfo;
  int sz;
  int rc = 0;



  int nWorker;




  if( sqlite3TempInMemory(db) || sqlite3Config.bCoreMutex==0 ){
    nWorker = 0;
  }else{
    nWorker = db->aLimit[11];
  }
# 93244 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  ((void)0);
  szKeyInfo = sizeof(KeyInfo) + (pCsr->pKeyInfo->nKeyField-1)*sizeof(CollSeq*);
  sz = sizeof(VdbeSorter) + nWorker * sizeof(SortSubtask);

  pSorter = (VdbeSorter*)sqlite3DbMallocZero(db, sz + szKeyInfo);
  pCsr->uc.pSorter = pSorter;
  if( pSorter==0 ){
    rc = 7;
  }else{
    pSorter->pKeyInfo = pKeyInfo = (KeyInfo*)((u8*)pSorter + sz);
    memcpy(pKeyInfo, pCsr->pKeyInfo, szKeyInfo);
    pKeyInfo->db = 0;
    if( nField && nWorker==0 ){
      pKeyInfo->nKeyField = nField;
    }
    pSorter->pgsz = pgsz = sqlite3BtreeGetPageSize(db->aDb[0].pBt);
    pSorter->nTask = nWorker + 1;
    pSorter->iPrev = (u8)(nWorker - 1);
    pSorter->bUseThreads = (pSorter->nTask>1);
    pSorter->db = db;
    for(i=0; i<pSorter->nTask; i++){
      SortSubtask *pTask = &pSorter->aTask[i];
      pTask->pSorter = pSorter;
    }

    if( !sqlite3TempInMemory(db) ){
      i64 mxCache;
      u32 szPma = sqlite3Config.szPma;
      pSorter->mnPmaSize = szPma * pgsz;

      mxCache = db->aDb[0].pSchema->cache_size;
      if( mxCache<0 ){


        mxCache = mxCache * -1024;
      }else{
        mxCache = mxCache * pgsz;
      }
      mxCache = ((mxCache)<((1<<29))?(mxCache):((1<<29)));
      pSorter->mxPmaSize = ((pSorter->mnPmaSize)>((int)mxCache)?(pSorter->mnPmaSize):((int)mxCache));



      if( sqlite3Config.bSmallMalloc==0 ){
        ((void)0);
        pSorter->nMemory = pgsz;
        pSorter->list.aMemory = (u8*)sqlite3Malloc(pgsz);
        if( !pSorter->list.aMemory ) rc = 7;
      }
    }

    if( pKeyInfo->nAllField<13
     && (pKeyInfo->aColl[0]==0 || pKeyInfo->aColl[0]==db->pDfltColl)
     && (pKeyInfo->aSortFlags[0] & 0x02)==0
    ){
      pSorter->typeMask = 0x01 | 0x02;
    }
  }

  return rc;
}
#undef nWorker




static void vdbeSorterRecordFree(sqlite3 *db, SorterRecord *pRecord){
  SorterRecord *p;
  SorterRecord *pNext;
  for(p=pRecord; p; p=pNext){
    pNext = p->u.pNext;
    sqlite3DbFree(db, p);
  }
}





static void vdbeSortSubtaskCleanup(sqlite3 *db, SortSubtask *pTask){
  sqlite3DbFree(db, pTask->pUnpacked);



  if( pTask->list.aMemory ){
    sqlite3_free(pTask->list.aMemory);
  }else

  {
    ((void)0);
    vdbeSorterRecordFree(0, pTask->list.pList);
  }
  if( pTask->file.pFd ){
    sqlite3OsCloseFree(pTask->file.pFd);
  }
  if( pTask->file2.pFd ){
    sqlite3OsCloseFree(pTask->file2.pFd);
  }
  memset(pTask, 0, sizeof(SortSubtask));
}
# 93379 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define vdbeSorterWorkDebug(x,y) 
#define vdbeSorterRewindDebug(y) 
#define vdbeSorterPopulateDebug(x,y) 
#define vdbeSorterBlockDebug(x,y,z) 






static int vdbeSorterJoinThread(SortSubtask *pTask){
  int rc = 0;
  if( pTask->pThread ){



    void *pRet = ((void*)(long int)(1));
    ;
    (void)sqlite3ThreadJoin(pTask->pThread, &pRet);
    ;
    rc = ((int)(long int)(pRet));
    ((void)0);
    pTask->bDone = 0;
    pTask->pThread = 0;
  }
  return rc;
}




static int vdbeSorterCreateThread(
  SortSubtask *pTask,
  void *(*xTask)(void*),
  void *pIn
){
  ((void)0);
  return sqlite3ThreadCreate(&pTask->pThread, xTask, pIn);
}





static int vdbeSorterJoinAll(VdbeSorter *pSorter, int rcin){
  int rc = rcin;
  int i;
# 93434 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=pSorter->nTask-1; i>=0; i--){
    SortSubtask *pTask = &pSorter->aTask[i];
    int rc2 = vdbeSorterJoinThread(pTask);
    if( rc==0 ) rc = rc2;
  }
  return rc;
}
# 93453 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static MergeEngine *vdbeMergeEngineNew(int nReader){
  int N = 2;
  int nByte;
  MergeEngine *pNew;

  ((void)0);

  while( N<nReader ) N += N;
  nByte = sizeof(MergeEngine) + N * (sizeof(int) + sizeof(PmaReader));

  pNew = sqlite3FaultSim(100) ? 0 : (MergeEngine*)sqlite3MallocZero(nByte);
  if( pNew ){
    pNew->nTree = N;
    pNew->pTask = 0;
    pNew->aReadr = (PmaReader*)&pNew[1];
    pNew->aTree = (int*)&pNew->aReadr[N];
  }
  return pNew;
}




static void vdbeMergeEngineFree(MergeEngine *pMerger){
  int i;
  if( pMerger ){
    for(i=0; i<pMerger->nTree; i++){
      vdbePmaReaderClear(&pMerger->aReadr[i]);
    }
  }
  sqlite3_free(pMerger);
}





static void vdbeIncrFree(IncrMerger *pIncr){
  if( pIncr ){

    if( pIncr->bUseThread ){
      vdbeSorterJoinThread(pIncr->pTask);
      if( pIncr->aFile[0].pFd ) sqlite3OsCloseFree(pIncr->aFile[0].pFd);
      if( pIncr->aFile[1].pFd ) sqlite3OsCloseFree(pIncr->aFile[1].pFd);
    }

    vdbeMergeEngineFree(pIncr->pMerger);
    sqlite3_free(pIncr);
  }
}




static void sqlite3VdbeSorterReset(sqlite3 *db, VdbeSorter *pSorter){
  int i;
  (void)vdbeSorterJoinAll(pSorter, 0);
  ((void)0);

  if( pSorter->pReader ){
    vdbePmaReaderClear(pSorter->pReader);
    sqlite3DbFree(db, pSorter->pReader);
    pSorter->pReader = 0;
  }

  vdbeMergeEngineFree(pSorter->pMerger);
  pSorter->pMerger = 0;
  for(i=0; i<pSorter->nTask; i++){
    SortSubtask *pTask = &pSorter->aTask[i];
    vdbeSortSubtaskCleanup(db, pTask);
    pTask->pSorter = pSorter;
  }
  if( pSorter->list.aMemory==0 ){
    vdbeSorterRecordFree(0, pSorter->list.pList);
  }
  pSorter->list.pList = 0;
  pSorter->list.szPMA = 0;
  pSorter->bUsePMA = 0;
  pSorter->iMemory = 0;
  pSorter->mxKeysize = 0;
  sqlite3DbFree(db, pSorter->pUnpacked);
  pSorter->pUnpacked = 0;
}




static void sqlite3VdbeSorterClose(sqlite3 *db, VdbeCursor *pCsr){
  VdbeSorter *pSorter;
  ((void)0);
  pSorter = pCsr->uc.pSorter;
  if( pSorter ){
    sqlite3VdbeSorterReset(db, pSorter);
    sqlite3_free(pSorter->list.aMemory);
    sqlite3DbFree(db, pSorter);
    pCsr->uc.pSorter = 0;
  }
}
# 93562 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void vdbeSorterExtendFile(sqlite3 *db, sqlite3_file *pFd, i64 nByte){
  if( nByte<=(i64)(db->nMaxSorterMmap) && pFd->pMethods->iVersion>=3 ){
    void *p = 0;
    int chunksize = 4*1024;
    sqlite3OsFileControlHint(pFd, 6, &chunksize);
    sqlite3OsFileControlHint(pFd, 5, &nByte);
    sqlite3OsFetch(pFd, 0, (int)nByte, &p);
    sqlite3OsUnfetch(pFd, 0, p);
  }
}
# 93581 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterOpenTempFile(
  sqlite3 *db,
  i64 nExtend,
  sqlite3_file **ppFd
){
  int rc;
  if( sqlite3FaultSim(202) ) return (10 | (13<<8));
  rc = sqlite3OsOpenMalloc(db->pVfs, 0, ppFd,
      0x00001000 |
      0x00000002 | 0x00000004 |
      0x00000010 | 0x00000008, &rc
  );
  if( rc==0 ){
    i64 max = 0x7fff0000;
    sqlite3OsFileControlHint(*ppFd, 18, (void*)&max);
    if( nExtend>0 ){
      vdbeSorterExtendFile(db, *ppFd, nExtend);
    }
  }
  return rc;
}






static int vdbeSortAllocUnpacked(SortSubtask *pTask){
  if( pTask->pUnpacked==0 ){
    pTask->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pTask->pSorter->pKeyInfo);
    if( pTask->pUnpacked==0 ) return 7;
    pTask->pUnpacked->nField = pTask->pSorter->pKeyInfo->nKeyField;
    pTask->pUnpacked->errCode = 0;
  }
  return 0;
}





static SorterRecord *vdbeSorterMerge(
  SortSubtask *pTask,
  SorterRecord *p1,
  SorterRecord *p2
){
  SorterRecord *pFinal = 0;
  SorterRecord **pp = &pFinal;
  int bCached = 0;

  ((void)0);
  for(;;){
    int res;
    res = pTask->xCompare(
        pTask, &bCached, ((void*)((SorterRecord*)(p1) + 1)), p1->nVal, ((void*)((SorterRecord*)(p2) + 1)), p2->nVal
    );

    if( res<=0 ){
      *pp = p1;
      pp = &p1->u.pNext;
      p1 = p1->u.pNext;
      if( p1==0 ){
        *pp = p2;
        break;
      }
    }else{
      *pp = p2;
      pp = &p2->u.pNext;
      p2 = p2->u.pNext;
      bCached = 0;
      if( p2==0 ){
        *pp = p1;
        break;
      }
    }
  }
  return pFinal;
}





static SorterCompare vdbeSorterGetCompare(VdbeSorter *p){
  if( p->typeMask==0x01 ){
    return vdbeSorterCompareInt;
  }else if( p->typeMask==0x02 ){
    return vdbeSorterCompareText;
  }
  return vdbeSorterCompare;
}






static int vdbeSorterSort(SortSubtask *pTask, SorterList *pList){
  int i;
  SorterRecord **aSlot;
  SorterRecord *p;
  int rc;

  rc = vdbeSortAllocUnpacked(pTask);
  if( rc!=0 ) return rc;

  p = pList->pList;
  pTask->xCompare = vdbeSorterGetCompare(pTask->pSorter);

  aSlot = (SorterRecord **)sqlite3MallocZero(64 * sizeof(SorterRecord *));
  if( !aSlot ){
    return 7;
  }

  while( p ){
    SorterRecord *pNext;
    if( pList->aMemory ){
      if( (u8*)p==pList->aMemory ){
        pNext = 0;
      }else{
        ((void)0);
        pNext = (SorterRecord*)&pList->aMemory[p->u.iNext];
      }
    }else{
      pNext = p->u.pNext;
    }

    p->u.pNext = 0;
    for(i=0; aSlot[i]; i++){
      p = vdbeSorterMerge(pTask, p, aSlot[i]);
      aSlot[i] = 0;
    }
    aSlot[i] = p;
    p = pNext;
  }

  p = 0;
  for(i=0; i<64; i++){
    if( aSlot[i]==0 ) continue;
    p = p ? vdbeSorterMerge(pTask, p, aSlot[i]) : aSlot[i];
  }
  pList->pList = p;

  sqlite3_free(aSlot);
  ((void)0)

   ;
  return pTask->pUnpacked->errCode;
}




static void vdbePmaWriterInit(
  sqlite3_file *pFd,
  PmaWriter *p,
  int nBuf,
  i64 iStart
){
  memset(p, 0, sizeof(PmaWriter));
  p->aBuffer = (u8*)sqlite3Malloc(nBuf);
  if( !p->aBuffer ){
    p->eFWErr = 7;
  }else{
    p->iBufEnd = p->iBufStart = (iStart % nBuf);
    p->iWriteOff = iStart - p->iBufStart;
    p->nBuffer = nBuf;
    p->pFd = pFd;
  }
}





static void vdbePmaWriteBlob(PmaWriter *p, u8 *pData, int nData){
  int nRem = nData;
  while( nRem>0 && p->eFWErr==0 ){
    int nCopy = nRem;
    if( nCopy>(p->nBuffer - p->iBufEnd) ){
      nCopy = p->nBuffer - p->iBufEnd;
    }

    memcpy(&p->aBuffer[p->iBufEnd], &pData[nData-nRem], nCopy);
    p->iBufEnd += nCopy;
    if( p->iBufEnd==p->nBuffer ){
      p->eFWErr = sqlite3OsWrite(p->pFd,
          &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,
          p->iWriteOff + p->iBufStart
      );
      p->iBufStart = p->iBufEnd = 0;
      p->iWriteOff += p->nBuffer;
    }
    ((void)0);

    nRem -= nCopy;
  }
}
# 93789 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbePmaWriterFinish(PmaWriter *p, i64 *piEof){
  int rc;
  if( p->eFWErr==0 && (p->aBuffer) && p->iBufEnd>p->iBufStart ){
    p->eFWErr = sqlite3OsWrite(p->pFd,
        &p->aBuffer[p->iBufStart], p->iBufEnd - p->iBufStart,
        p->iWriteOff + p->iBufStart
    );
  }
  *piEof = (p->iWriteOff + p->iBufEnd);
  sqlite3_free(p->aBuffer);
  rc = p->eFWErr;
  memset(p, 0, sizeof(PmaWriter));
  return rc;
}





static void vdbePmaWriteVarint(PmaWriter *p, u64 iVal){
  int nByte;
  u8 aByte[10];
  nByte = sqlite3PutVarint(aByte, iVal);
  vdbePmaWriteBlob(p, aByte, nByte);
}
# 93829 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterListToPMA(SortSubtask *pTask, SorterList *pList){
  sqlite3 *db = pTask->pSorter->db;
  int rc = 0;
  PmaWriter writer;







  ;
  memset(&writer, 0, sizeof(PmaWriter));
  ((void)0);


  if( pTask->file.pFd==0 ){
    rc = vdbeSorterOpenTempFile(db, 0, &pTask->file.pFd);
    ((void)0);
    ((void)0);
    ((void)0);
  }


  if( rc==0 ){
    vdbeSorterExtendFile(db, pTask->file.pFd, pTask->file.iEof+pList->szPMA+9);
  }


  if( rc==0 ){
    rc = vdbeSorterSort(pTask, pList);
  }

  if( rc==0 ){
    SorterRecord *p;
    SorterRecord *pNext = 0;

    vdbePmaWriterInit(pTask->file.pFd, &writer, pTask->pSorter->pgsz,
                      pTask->file.iEof);
    pTask->nPMA++;
    vdbePmaWriteVarint(&writer, pList->szPMA);
    for(p=pList->pList; p; p=pNext){
      pNext = p->u.pNext;
      vdbePmaWriteVarint(&writer, p->nVal);
      vdbePmaWriteBlob(&writer, ((void*)((SorterRecord*)(p) + 1)), p->nVal);
      if( pList->aMemory==0 ) sqlite3_free(p);
    }
    pList->pList = p;
    rc = vdbePmaWriterFinish(&writer, &pTask->file.iEof);
  }

  ;
  ((void)0);
  ((void)0);
  return rc;
}
# 93893 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeMergeEngineStep(
  MergeEngine *pMerger,
  int *pbEof
){
  int rc;
  int iPrev = pMerger->aTree[1];
  SortSubtask *pTask = pMerger->pTask;


  rc = vdbePmaReaderNext(&pMerger->aReadr[iPrev]);


  if( rc==0 ){
    int i;
    PmaReader *pReadr1;
    PmaReader *pReadr2;
    int bCached = 0;



    pReadr1 = &pMerger->aReadr[(iPrev & 0xFFFE)];
    pReadr2 = &pMerger->aReadr[(iPrev | 0x0001)];

    for(i=(pMerger->nTree+iPrev)/2; i>0; i=i/2){

      int iRes;
      if( pReadr1->pFd==0 ){
        iRes = +1;
      }else if( pReadr2->pFd==0 ){
        iRes = -1;
      }else{
        iRes = pTask->xCompare(pTask, &bCached,
            pReadr1->aKey, pReadr1->nKey, pReadr2->aKey, pReadr2->nKey
        );
      }
# 93944 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( iRes<0 || (iRes==0 && pReadr1<pReadr2) ){
        pMerger->aTree[i] = (int)(pReadr1 - pMerger->aReadr);
        pReadr2 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
        bCached = 0;
      }else{
        if( pReadr1->pFd ) bCached = 0;
        pMerger->aTree[i] = (int)(pReadr2 - pMerger->aReadr);
        pReadr1 = &pMerger->aReadr[ pMerger->aTree[i ^ 0x0001] ];
      }
    }
    *pbEof = (pMerger->aReadr[pMerger->aTree[1]].pFd==0);
  }

  return (rc==0 ? pTask->pUnpacked->errCode : rc);
}





static void *vdbeSorterFlushThread(void *pCtx){
  SortSubtask *pTask = (SortSubtask*)pCtx;
  int rc;
  ((void)0);
  rc = vdbeSorterListToPMA(pTask, &pTask->list);
  pTask->bDone = 1;
  return ((void*)(long int)(rc));
}






static int vdbeSorterFlushPMA(VdbeSorter *pSorter){




  int rc = 0;
  int i;
  SortSubtask *pTask = 0;
  int nWorker = (pSorter->nTask-1);



  pSorter->bUsePMA = 1;
# 94000 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=0; i<nWorker; i++){
    int iTest = (pSorter->iPrev + i + 1) % nWorker;
    pTask = &pSorter->aTask[iTest];
    if( pTask->bDone ){
      rc = vdbeSorterJoinThread(pTask);
    }
    if( rc!=0 || pTask->pThread==0 ) break;
  }

  if( rc==0 ){
    if( i==nWorker ){

      rc = vdbeSorterListToPMA(&pSorter->aTask[nWorker], &pSorter->list);
    }else{

      u8 *aMem;
      void *pCtx;

      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);

      aMem = pTask->list.aMemory;
      pCtx = (void*)pTask;
      pSorter->iPrev = (u8)(pTask - pSorter->aTask);
      pTask->list = pSorter->list;
      pSorter->list.pList = 0;
      pSorter->list.szPMA = 0;
      if( aMem ){
        pSorter->list.aMemory = aMem;
        pSorter->nMemory = sqlite3MallocSize(aMem);
      }else if( pSorter->list.aMemory ){
        pSorter->list.aMemory = sqlite3Malloc(pSorter->nMemory);
        if( !pSorter->list.aMemory ) return 7;
      }

      rc = vdbeSorterCreateThread(pTask, vdbeSorterFlushThread, pCtx);
    }
  }

  return rc;

}




static int sqlite3VdbeSorterWrite(
  const VdbeCursor *pCsr,
  Mem *pVal
){
  VdbeSorter *pSorter;
  int rc = 0;
  SorterRecord *pNew;
  int bFlush;
  int nReq;
  int nPMA;
  int t;

  ((void)0);
  pSorter = pCsr->uc.pSorter;
  (u8)((*((const u8*)&pVal->z[1])<(u8)0x80)?((t)=(u32)*((const u8*)&pVal->z[1])),1:sqlite3GetVarint32(((const u8*)&pVal->z[1]),(u32 *)&(t)));
  if( t>0 && t<10 && t!=7 ){
    pSorter->typeMask &= 0x01;
  }else if( t>10 && (t & 0x01) ){
    pSorter->typeMask &= 0x02;
  }else{
    pSorter->typeMask = 0;
  }

  ((void)0);
# 94089 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  nReq = pVal->n + sizeof(SorterRecord);
  nPMA = pVal->n + sqlite3VarintLen(pVal->n);
  if( pSorter->mxPmaSize ){
    if( pSorter->list.aMemory ){
      bFlush = pSorter->iMemory && (pSorter->iMemory+nReq) > pSorter->mxPmaSize;
    }else{
      bFlush = (
          (pSorter->list.szPMA > pSorter->mxPmaSize)
       || (pSorter->list.szPMA > pSorter->mnPmaSize && sqlite3HeapNearlyFull())
      );
    }
    if( bFlush ){
      rc = vdbeSorterFlushPMA(pSorter);
      pSorter->list.szPMA = 0;
      pSorter->iMemory = 0;
      ((void)0);
    }
  }

  pSorter->list.szPMA += nPMA;
  if( nPMA>pSorter->mxKeysize ){
    pSorter->mxKeysize = nPMA;
  }

  if( pSorter->list.aMemory ){
    int nMin = pSorter->iMemory + nReq;

    if( nMin>pSorter->nMemory ){
      u8 *aNew;
      sqlite3_int64 nNew = 2 * (sqlite3_int64)pSorter->nMemory;
      int iListOff = -1;
      if( pSorter->list.pList ){
        iListOff = (u8*)pSorter->list.pList - pSorter->list.aMemory;
      }
      while( nNew < nMin ) nNew = nNew*2;
      if( nNew > pSorter->mxPmaSize ) nNew = pSorter->mxPmaSize;
      if( nNew < nMin ) nNew = nMin;
      aNew = sqlite3Realloc(pSorter->list.aMemory, nNew);
      if( !aNew ) return 7;
      if( iListOff>=0 ){
        pSorter->list.pList = (SorterRecord*)&aNew[iListOff];
      }
      pSorter->list.aMemory = aNew;
      pSorter->nMemory = nNew;
    }

    pNew = (SorterRecord*)&pSorter->list.aMemory[pSorter->iMemory];
    pSorter->iMemory += (((nReq)+7)&~7);
    if( pSorter->list.pList ){
      pNew->u.iNext = (int)((u8*)(pSorter->list.pList) - pSorter->list.aMemory);
    }
  }else{
    pNew = (SorterRecord *)sqlite3Malloc(nReq);
    if( pNew==0 ){
      return 7;
    }
    pNew->u.pNext = pSorter->list.pList;
  }

  memcpy(((void*)((SorterRecord*)(pNew) + 1)), pVal->z, pVal->n);
  pNew->nVal = pVal->n;
  pSorter->list.pList = pNew;

  return rc;
}






static int vdbeIncrPopulate(IncrMerger *pIncr){
  int rc = 0;
  int rc2;
  i64 iStart = pIncr->iStartOff;
  SorterFile *pOut = &pIncr->aFile[1];
  SortSubtask *pTask = pIncr->pTask;
  MergeEngine *pMerger = pIncr->pMerger;
  PmaWriter writer;
  ((void)0);

  ;

  vdbePmaWriterInit(pOut->pFd, &writer, pTask->pSorter->pgsz, iStart);
  while( rc==0 ){
    int dummy;
    PmaReader *pReader = &pMerger->aReadr[ pMerger->aTree[1] ];
    int nKey = pReader->nKey;
    i64 iEof = writer.iWriteOff + writer.iBufEnd;



    if( pReader->pFd==0 ) break;
    if( (iEof + nKey + sqlite3VarintLen(nKey))>(iStart + pIncr->mxSz) ) break;


    vdbePmaWriteVarint(&writer, nKey);
    vdbePmaWriteBlob(&writer, pReader->aKey, nKey);
    ((void)0);
    rc = vdbeMergeEngineStep(pIncr->pMerger, &dummy);
  }

  rc2 = vdbePmaWriterFinish(&writer, &pOut->iEof);
  if( rc==0 ) rc = rc2;
  ;
  return rc;
}






static void *vdbeIncrPopulateThread(void *pCtx){
  IncrMerger *pIncr = (IncrMerger*)pCtx;
  void *pRet = ((void*)(long int)(vdbeIncrPopulate(pIncr)));
  pIncr->pTask->bDone = 1;
  return pRet;
}




static int vdbeIncrBgPopulate(IncrMerger *pIncr){
  void *p = (void*)pIncr;
  ((void)0);
  return vdbeSorterCreateThread(pIncr->pTask, vdbeIncrPopulateThread, p);
}
# 94236 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeIncrSwap(IncrMerger *pIncr){
  int rc = 0;


  if( pIncr->bUseThread ){
    rc = vdbeSorterJoinThread(pIncr->pTask);

    if( rc==0 ){
      SorterFile f0 = pIncr->aFile[0];
      pIncr->aFile[0] = pIncr->aFile[1];
      pIncr->aFile[1] = f0;
    }

    if( rc==0 ){
      if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
        pIncr->bEof = 1;
      }else{
        rc = vdbeIncrBgPopulate(pIncr);
      }
    }
  }else

  {
    rc = vdbeIncrPopulate(pIncr);
    pIncr->aFile[0] = pIncr->aFile[1];
    if( pIncr->aFile[0].iEof==pIncr->iStartOff ){
      pIncr->bEof = 1;
    }
  }

  return rc;
}







static int vdbeIncrMergerNew(
  SortSubtask *pTask,
  MergeEngine *pMerger,
  IncrMerger **ppOut
){
  int rc = 0;
  IncrMerger *pIncr = *ppOut = (IncrMerger*)
       (sqlite3FaultSim(100) ? 0 : sqlite3MallocZero(sizeof(*pIncr)));
  if( pIncr ){
    pIncr->pMerger = pMerger;
    pIncr->pTask = pTask;
    pIncr->mxSz = ((pTask->pSorter->mxKeysize+9)>(pTask->pSorter->mxPmaSize/2)?(pTask->pSorter->mxKeysize+9):(pTask->pSorter->mxPmaSize/2));
    pTask->file2.iEof += pIncr->mxSz;
  }else{
    vdbeMergeEngineFree(pMerger);
    rc = 7;
  }
  return rc;
}





static void vdbeIncrMergerSetThreads(IncrMerger *pIncr){
  pIncr->bUseThread = 1;
  pIncr->pTask->file2.iEof -= pIncr->mxSz;
}
# 94312 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void vdbeMergeEngineCompare(
  MergeEngine *pMerger,
  int iOut
){
  int i1;
  int i2;
  int iRes;
  PmaReader *p1;
  PmaReader *p2;

  ((void)0);

  if( iOut>=(pMerger->nTree/2) ){
    i1 = (iOut - pMerger->nTree/2) * 2;
    i2 = i1 + 1;
  }else{
    i1 = pMerger->aTree[iOut*2];
    i2 = pMerger->aTree[iOut*2+1];
  }

  p1 = &pMerger->aReadr[i1];
  p2 = &pMerger->aReadr[i2];

  if( p1->pFd==0 ){
    iRes = i2;
  }else if( p2->pFd==0 ){
    iRes = i1;
  }else{
    SortSubtask *pTask = pMerger->pTask;
    int bCached = 0;
    int res;
    ((void)0);
    res = pTask->xCompare(
        pTask, &bCached, p1->aKey, p1->nKey, p2->aKey, p2->nKey
    );
    if( res<=0 ){
      iRes = i1;
    }else{
      iRes = i2;
    }
  }

  pMerger->aTree[iOut] = iRes;
}
# 94365 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define INCRINIT_NORMAL 0
#define INCRINIT_TASK 1
#define INCRINIT_ROOT 2






static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode);
# 94394 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeMergeEngineInit(
  SortSubtask *pTask,
  MergeEngine *pMerger,
  int eMode
){
  int rc = 0;
  int i;
  int nTree;



  ((void)0);


  ((void)0);


  ((void)0);
  pMerger->pTask = pTask;

  nTree = pMerger->nTree;
  for(i=0; i<nTree; i++){
    if( 8>0 && eMode==2 ){







      rc = vdbePmaReaderNext(&pMerger->aReadr[nTree-i-1]);
    }else{
      rc = vdbePmaReaderIncrInit(&pMerger->aReadr[i], 0);
    }
    if( rc!=0 ) return rc;
  }

  for(i=pMerger->nTree-1; i>0; i--){
    vdbeMergeEngineCompare(pMerger, i);
  }
  return pTask->pUnpacked->errCode;
}
# 94470 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbePmaReaderIncrMergeInit(PmaReader *pReadr, int eMode){
  int rc = 0;
  IncrMerger *pIncr = pReadr->pIncr;
  SortSubtask *pTask = pIncr->pTask;
  sqlite3 *db = pTask->pSorter->db;


  ((void)0);

  rc = vdbeMergeEngineInit(pTask, pIncr->pMerger, eMode);




  if( rc==0 ){
    int mxSz = pIncr->mxSz;

    if( pIncr->bUseThread ){
      rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[0].pFd);
      if( rc==0 ){
        rc = vdbeSorterOpenTempFile(db, mxSz, &pIncr->aFile[1].pFd);
      }
    }else

                                {
      if( pTask->file2.pFd==0 ){
        ((void)0);
        rc = vdbeSorterOpenTempFile(db, pTask->file2.iEof, &pTask->file2.pFd);
        pTask->file2.iEof = 0;
      }
      if( rc==0 ){
        pIncr->aFile[1].pFd = pTask->file2.pFd;
        pIncr->iStartOff = pTask->file2.iEof;
        pTask->file2.iEof += mxSz;
      }
    }
  }


  if( rc==0 && pIncr->bUseThread ){
# 94520 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    rc = vdbeIncrPopulate(pIncr);
  }


  if( rc==0 && (8==0 || eMode!=1) ){
    rc = vdbePmaReaderNext(pReadr);
  }

  return rc;
}






static void *vdbePmaReaderBgIncrInit(void *pCtx){
  PmaReader *pReader = (PmaReader*)pCtx;
  void *pRet = ((void*)(long int)(vdbePmaReaderIncrMergeInit(pReader,1)))

                ;
  pReader->pIncr->pTask->bDone = 1;
  return pRet;
}
# 94558 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbePmaReaderIncrInit(PmaReader *pReadr, int eMode){
  IncrMerger *pIncr = pReadr->pIncr;
  int rc = 0;
  if( pIncr ){

    ((void)0);
    if( pIncr->bUseThread ){
      void *pCtx = (void*)pReadr;
      rc = vdbeSorterCreateThread(pIncr->pTask, vdbePmaReaderBgIncrInit, pCtx);
    }else

    {
      rc = vdbePmaReaderIncrMergeInit(pReadr, eMode);
    }
  }
  return rc;
}
# 94588 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeMergeEngineLevel0(
  SortSubtask *pTask,
  int nPMA,
  i64 *piOffset,
  MergeEngine **ppOut
){
  MergeEngine *pNew;
  i64 iOff = *piOffset;
  int i;
  int rc = 0;

  *ppOut = pNew = vdbeMergeEngineNew(nPMA);
  if( pNew==0 ) rc = 7;

  for(i=0; i<nPMA && rc==0; i++){
    i64 nDummy = 0;
    PmaReader *pReadr = &pNew->aReadr[i];
    rc = vdbePmaReaderInit(pTask, &pTask->file, iOff, pReadr, &nDummy);
    iOff = pReadr->iEof;
  }

  if( rc!=0 ){
    vdbeMergeEngineFree(pNew);
    *ppOut = 0;
  }
  *piOffset = iOff;
  return rc;
}
# 94627 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterTreeDepth(int nPMA){
  int nDepth = 0;
  i64 nDiv = 16;
  while( nDiv < (i64)nPMA ){
    nDiv = nDiv * 16;
    nDepth++;
  }
  return nDepth;
}
# 94645 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterAddToTree(
  SortSubtask *pTask,
  int nDepth,
  int iSeq,
  MergeEngine *pRoot,
  MergeEngine *pLeaf
){
  int rc = 0;
  int nDiv = 1;
  int i;
  MergeEngine *p = pRoot;
  IncrMerger *pIncr;

  rc = vdbeIncrMergerNew(pTask, pLeaf, &pIncr);

  for(i=1; i<nDepth; i++){
    nDiv = nDiv * 16;
  }

  for(i=1; i<nDepth && rc==0; i++){
    int iIter = (iSeq / nDiv) % 16;
    PmaReader *pReadr = &p->aReadr[iIter];

    if( pReadr->pIncr==0 ){
      MergeEngine *pNew = vdbeMergeEngineNew(16);
      if( pNew==0 ){
        rc = 7;
      }else{
        rc = vdbeIncrMergerNew(pTask, pNew, &pReadr->pIncr);
      }
    }
    if( rc==0 ){
      p = pReadr->pIncr->pMerger;
      nDiv = nDiv / 16;
    }
  }

  if( rc==0 ){
    p->aReadr[iSeq % 16].pIncr = pIncr;
  }else{
    vdbeIncrFree(pIncr);
  }
  return rc;
}
# 94701 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterMergeTreeBuild(
  VdbeSorter *pSorter,
  MergeEngine **ppOut
){
  MergeEngine *pMain = 0;
  int rc = 0;
  int iTask;





  ((void)0);
  if( pSorter->nTask>1 ){
    pMain = vdbeMergeEngineNew(pSorter->nTask);
    if( pMain==0 ) rc = 7;
  }


  for(iTask=0; rc==0 && iTask<pSorter->nTask; iTask++){
    SortSubtask *pTask = &pSorter->aTask[iTask];
    ((void)0);
    if( 8==0 || pTask->nPMA ){
      MergeEngine *pRoot = 0;
      int nDepth = vdbeSorterTreeDepth(pTask->nPMA);
      i64 iReadOff = 0;

      if( pTask->nPMA<=16 ){
        rc = vdbeMergeEngineLevel0(pTask, pTask->nPMA, &iReadOff, &pRoot);
      }else{
        int i;
        int iSeq = 0;
        pRoot = vdbeMergeEngineNew(16);
        if( pRoot==0 ) rc = 7;
        for(i=0; i<pTask->nPMA && rc==0; i += 16){
          MergeEngine *pMerger = 0;
          int nReader;

          nReader = ((pTask->nPMA - i)<(16)?(pTask->nPMA - i):(16));
          rc = vdbeMergeEngineLevel0(pTask, nReader, &iReadOff, &pMerger);
          if( rc==0 ){
            rc = vdbeSorterAddToTree(pTask, nDepth, iSeq++, pRoot, pMerger);
          }
        }
      }

      if( rc==0 ){

        if( pMain!=0 ){
          rc = vdbeIncrMergerNew(pTask, pRoot, &pMain->aReadr[iTask].pIncr);
        }else

        {
          ((void)0);
          pMain = pRoot;
        }
      }else{
        vdbeMergeEngineFree(pRoot);
      }
    }
  }

  if( rc!=0 ){
    vdbeMergeEngineFree(pMain);
    pMain = 0;
  }
  *ppOut = pMain;
  return rc;
}
# 94780 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vdbeSorterSetupMerge(VdbeSorter *pSorter){
  int rc;
  SortSubtask *pTask0 = &pSorter->aTask[0];
  MergeEngine *pMain = 0;

  sqlite3 *db = pTask0->pSorter->db;
  int i;
  SorterCompare xCompare = vdbeSorterGetCompare(pSorter);
  for(i=0; i<pSorter->nTask; i++){
    pSorter->aTask[i].xCompare = xCompare;
  }


  rc = vdbeSorterMergeTreeBuild(pSorter, &pMain);
  if( rc==0 ){

    ((void)0);
    if( pSorter->bUseThreads ){
      int iTask;
      PmaReader *pReadr = 0;
      SortSubtask *pLast = &pSorter->aTask[pSorter->nTask-1];
      rc = vdbeSortAllocUnpacked(pLast);
      if( rc==0 ){
        pReadr = (PmaReader*)sqlite3DbMallocZero(db, sizeof(PmaReader));
        pSorter->pReader = pReadr;
        if( pReadr==0 ) rc = 7;
      }
      if( rc==0 ){
        rc = vdbeIncrMergerNew(pLast, pMain, &pReadr->pIncr);
        if( rc==0 ){
          vdbeIncrMergerSetThreads(pReadr->pIncr);
          for(iTask=0; iTask<(pSorter->nTask-1); iTask++){
            IncrMerger *pIncr;
            if( (pIncr = pMain->aReadr[iTask].pIncr) ){
              vdbeIncrMergerSetThreads(pIncr);
              ((void)0);
            }
          }
          for(iTask=0; rc==0 && iTask<pSorter->nTask; iTask++){
# 94828 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
            PmaReader *p = &pMain->aReadr[iTask];
            ((void)0)


              ;
            rc = vdbePmaReaderIncrInit(p, 1);
          }
        }
        pMain = 0;
      }
      if( rc==0 ){
        rc = vdbePmaReaderIncrMergeInit(pReadr, 2);
      }
    }else

    {
      rc = vdbeMergeEngineInit(pTask0, pMain, 0);
      pSorter->pMerger = pMain;
      pMain = 0;
    }
  }

  if( rc!=0 ){
    vdbeMergeEngineFree(pMain);
  }
  return rc;
}







static int sqlite3VdbeSorterRewind(const VdbeCursor *pCsr, int *pbEof){
  VdbeSorter *pSorter;
  int rc = 0;

  ((void)0);
  pSorter = pCsr->uc.pSorter;
  ((void)0);




  if( pSorter->bUsePMA==0 ){
    if( pSorter->list.pList ){
      *pbEof = 0;
      rc = vdbeSorterSort(&pSorter->aTask[0], &pSorter->list);
    }else{
      *pbEof = 1;
    }
    return rc;
  }





  ((void)0);
  rc = vdbeSorterFlushPMA(pSorter);


  rc = vdbeSorterJoinAll(pSorter, rc);

  ;



  ((void)0);
  if( rc==0 ){
    rc = vdbeSorterSetupMerge(pSorter);
    *pbEof = 0;
  }

  ;
  return rc;
}
# 94914 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeSorterNext(sqlite3 *db, const VdbeCursor *pCsr){
  VdbeSorter *pSorter;
  int rc;

  ((void)0);
  pSorter = pCsr->uc.pSorter;
  ((void)0);
  if( pSorter->bUsePMA ){
    ((void)0);
    ((void)0);
    ((void)0);

    if( pSorter->bUseThreads ){
      rc = vdbePmaReaderNext(pSorter->pReader);
      if( rc==0 && pSorter->pReader->pFd==0 ) rc = 101;
    }else

                                    {
      int res = 0;
      ((void)0);
      ((void)0);
      rc = vdbeMergeEngineStep(pSorter->pMerger, &res);
      if( rc==0 && res ) rc = 101;
    }
  }else{
    SorterRecord *pFree = pSorter->list.pList;
    pSorter->list.pList = pFree->u.pNext;
    pFree->u.pNext = 0;
    if( pSorter->list.aMemory==0 ) vdbeSorterRecordFree(db, pFree);
    rc = pSorter->list.pList ? 0 : 101;
  }
  return rc;
}





static void *vdbeSorterRowkey(
  const VdbeSorter *pSorter,
  int *pnKey
){
  void *pKey;
  if( pSorter->bUsePMA ){
    PmaReader *pReader;

    if( pSorter->bUseThreads ){
      pReader = pSorter->pReader;
    }else

                                   {
      pReader = &pSorter->pMerger->aReadr[pSorter->pMerger->aTree[1]];
    }
    *pnKey = pReader->nKey;
    pKey = pReader->aKey;
  }else{
    *pnKey = pSorter->list.pList->nVal;
    pKey = ((void*)((SorterRecord*)(pSorter->list.pList) + 1));
  }
  return pKey;
}




static int sqlite3VdbeSorterRowkey(const VdbeCursor *pCsr, Mem *pOut){
  VdbeSorter *pSorter;
  void *pKey; int nKey;

  ((void)0);
  pSorter = pCsr->uc.pSorter;
  pKey = vdbeSorterRowkey(pSorter, &nKey);
  if( sqlite3VdbeMemClearAndResize(pOut, nKey) ){
    return 7;
  }
  pOut->n = nKey;
  ((pOut)->flags = ((pOut)->flags&~(0xc1bf|0x4000))|0x0010);
  memcpy(pOut->z, pKey, nKey);

  return 0;
}
# 95012 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VdbeSorterCompare(
  const VdbeCursor *pCsr,
  Mem *pVal,
  int nKeyCol,
  int *pRes
){
  VdbeSorter *pSorter;
  UnpackedRecord *r2;
  KeyInfo *pKeyInfo;
  int i;
  void *pKey; int nKey;

  ((void)0);
  pSorter = pCsr->uc.pSorter;
  r2 = pSorter->pUnpacked;
  pKeyInfo = pCsr->pKeyInfo;
  if( r2==0 ){
    r2 = pSorter->pUnpacked = sqlite3VdbeAllocUnpackedRecord(pKeyInfo);
    if( r2==0 ) return 7;
    r2->nField = nKeyCol;
  }
  ((void)0);

  pKey = vdbeSorterRowkey(pSorter, &nKey);
  sqlite3VdbeRecordUnpack(pKeyInfo, nKey, pKey, r2);
  for(i=0; i<nKeyCol; i++){
    if( r2->aMem[i].flags & 0x0001 ){
      *pRes = -1;
      return 0;
    }
  }

  *pRes = sqlite3VdbeRecordCompare(pVal->n, pVal->z, r2);
  return 0;
}
# 95078 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct MemJournal MemJournal;
typedef struct FilePoint FilePoint;
typedef struct FileChunk FileChunk;







struct FileChunk {
  FileChunk *pNext;
  u8 zChunk[8];
};




#define MEMJOURNAL_DFLT_FILECHUNKSIZE 1024





#define fileChunkSize(nChunkSize) (sizeof(FileChunk) + ((nChunkSize)-8))





struct FilePoint {
  sqlite3_int64 iOffset;
  FileChunk *pChunk;
};





struct MemJournal {
  const sqlite3_io_methods *pMethod;
  int nChunkSize;

  int nSpill;
  int nSize;
  FileChunk *pFirst;
  FilePoint endpoint;
  FilePoint readpoint;

  int flags;
  sqlite3_vfs *pVfs;
  const char *zJournal;
};





static int memjrnlRead(
  sqlite3_file *pJfd,
  void *zBuf,
  int iAmt,
  sqlite_int64 iOfst
){
  MemJournal *p = (MemJournal *)pJfd;
  u8 *zOut = zBuf;
  int nRead = iAmt;
  int iChunkOffset;
  FileChunk *pChunk;

  if( (iAmt+iOfst)>p->endpoint.iOffset ){
    return (10 | (2<<8));
  }
  ((void)0);
  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){
    sqlite3_int64 iOff = 0;
    for(pChunk=p->pFirst;
        (pChunk) && (iOff+p->nChunkSize)<=iOfst;
        pChunk=pChunk->pNext
    ){
      iOff += p->nChunkSize;
    }
  }else{
    pChunk = p->readpoint.pChunk;
    ((void)0);
  }

  iChunkOffset = (int)(iOfst%p->nChunkSize);
  do {
    int iSpace = p->nChunkSize - iChunkOffset;
    int nCopy = ((nRead)<((p->nChunkSize - iChunkOffset))?(nRead):((p->nChunkSize - iChunkOffset)));
    memcpy(zOut, (u8*)pChunk->zChunk + iChunkOffset, nCopy);
    zOut += nCopy;
    nRead -= iSpace;
    iChunkOffset = 0;
  } while( nRead>=0 && (pChunk=pChunk->pNext)!=0 && nRead>0 );
  p->readpoint.iOffset = pChunk ? iOfst+iAmt : 0;
  p->readpoint.pChunk = pChunk;

  return 0;
}




static void memjrnlFreeChunks(MemJournal *p){
  FileChunk *pIter;
  FileChunk *pNext;
  for(pIter=p->pFirst; pIter; pIter=pNext){
    pNext = pIter->pNext;
    sqlite3_free(pIter);
  }
  p->pFirst = 0;
}




static int memjrnlCreateFile(MemJournal *p){
  int rc;
  sqlite3_file *pReal = (sqlite3_file*)p;
  MemJournal copy = *p;

  memset(p, 0, sizeof(MemJournal));
  rc = sqlite3OsOpen(copy.pVfs, copy.zJournal, pReal, copy.flags, 0);
  if( rc==0 ){
    int nChunk = copy.nChunkSize;
    i64 iOff = 0;
    FileChunk *pIter;
    for(pIter=copy.pFirst; pIter; pIter=pIter->pNext){
      if( iOff + nChunk > copy.endpoint.iOffset ){
        nChunk = copy.endpoint.iOffset - iOff;
      }
      rc = sqlite3OsWrite(pReal, (u8*)pIter->zChunk, nChunk, iOff);
      if( rc ) break;
      iOff += nChunk;
    }
    if( rc==0 ){

      memjrnlFreeChunks(&copy);
    }
  }
  if( rc!=0 ){




    sqlite3OsClose(pReal);
    *p = copy;
  }
  return rc;
}





static int memjrnlWrite(
  sqlite3_file *pJfd,
  const void *zBuf,
  int iAmt,
  sqlite_int64 iOfst
){
  MemJournal *p = (MemJournal *)pJfd;
  int nWrite = iAmt;
  u8 *zWrite = (u8 *)zBuf;



  if( p->nSpill>0 && (iAmt+iOfst)>p->nSpill ){
    int rc = memjrnlCreateFile(p);
    if( rc==0 ){
      rc = sqlite3OsWrite(pJfd, zBuf, iAmt, iOfst);
    }
    return rc;
  }


  else{





    ((void)0);







    ((void)0);

    {
      while( nWrite>0 ){
        FileChunk *pChunk = p->endpoint.pChunk;
        int iChunkOffset = (int)(p->endpoint.iOffset%p->nChunkSize);
        int iSpace = ((nWrite)<(p->nChunkSize - iChunkOffset)?(nWrite):(p->nChunkSize - iChunkOffset));

        if( iChunkOffset==0 ){

          FileChunk *pNew = sqlite3_malloc((sizeof(FileChunk) + ((p->nChunkSize)-8)));
          if( !pNew ){
            return (10 | (12<<8));
          }
          pNew->pNext = 0;
          if( pChunk ){
            ((void)0);
            pChunk->pNext = pNew;
          }else{
            ((void)0);
            p->pFirst = pNew;
          }
          p->endpoint.pChunk = pNew;
        }

        memcpy((u8*)p->endpoint.pChunk->zChunk + iChunkOffset, zWrite, iSpace);
        zWrite += iSpace;
        nWrite -= iSpace;
        p->endpoint.iOffset += iSpace;
      }
      p->nSize = iAmt + iOfst;
    }
  }

  return 0;
}
# 95314 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){
  MemJournal *p = (MemJournal *)pJfd;
  if( (size==0) ){
    memjrnlFreeChunks(p);
    p->nSize = 0;
    p->endpoint.pChunk = 0;
    p->endpoint.iOffset = 0;
    p->readpoint.pChunk = 0;
    p->readpoint.iOffset = 0;
  }
  return 0;
}




static int memjrnlClose(sqlite3_file *pJfd){
  MemJournal *p = (MemJournal *)pJfd;
  memjrnlFreeChunks(p);
  return 0;
}







static int memjrnlSync(sqlite3_file *pJfd, int flags){
  (void)(pJfd),(void)(flags);
  return 0;
}




static int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){
  MemJournal *p = (MemJournal *)pJfd;
  *pSize = (sqlite_int64) p->endpoint.iOffset;
  return 0;
}




static const struct sqlite3_io_methods MemJournalMethods = {
  1,
  memjrnlClose,
  memjrnlRead,
  memjrnlWrite,
  memjrnlTruncate,
  memjrnlSync,
  memjrnlFileSize,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
};
# 95393 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3JournalOpen(
  sqlite3_vfs *pVfs,
  const char *zName,
  sqlite3_file *pJfd,
  int flags,
  int nSpill
){
  MemJournal *p = (MemJournal*)pJfd;





  memset(p, 0, sizeof(MemJournal));
  if( nSpill==0 ){
    return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0);
  }

  if( nSpill>0 ){
    p->nChunkSize = nSpill;
  }else{
    p->nChunkSize = 8 + 1024 - sizeof(FileChunk);
    ((void)0);
  }

  p->pMethod = (const sqlite3_io_methods*)&MemJournalMethods;
  p->nSpill = nSpill;
  p->flags = flags;
  p->zJournal = zName;
  p->pVfs = pVfs;
  return 0;
}




static void sqlite3MemJournalOpen(sqlite3_file *pJfd){
  sqlite3JournalOpen(0, 0, pJfd, 0, -1);
}
# 95468 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3JournalIsInMemory(sqlite3_file *p){
  return p->pMethods==&MemJournalMethods;
}





static int sqlite3JournalSize(sqlite3_vfs *pVfs){
  return ((pVfs->szOsFile)>((int)sizeof(MemJournal))?(pVfs->szOsFile):((int)sizeof(MemJournal)));
}
# 95506 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int walkWindowList(Walker *pWalker, Window *pList){
  Window *pWin;
  for(pWin=pList; pWin; pWin=pWin->pNextWin){
    int rc;
    rc = sqlite3WalkExprList(pWalker, pWin->pOrderBy);
    if( rc ) return 2;
    rc = sqlite3WalkExprList(pWalker, pWin->pPartition);
    if( rc ) return 2;
    rc = sqlite3WalkExpr(pWalker, pWin->pFilter);
    if( rc ) return 2;





    rc = sqlite3WalkExpr(pWalker, pWin->pStart);
    if( (rc) ) return 2;
    rc = sqlite3WalkExpr(pWalker, pWin->pEnd);
    if( (rc) ) return 2;
  }
  return 0;
}
# 95549 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int walkExpr(Walker *pWalker, Expr *pExpr){
  int rc;
  ;
  ;
  while(1){
    rc = pWalker->xExprCallback(pWalker, pExpr);
    if( rc ) return rc & 2;
    if( !(((pExpr)->flags&((0x004000|0x800000)))!=0) ){
      if( pExpr->pLeft && walkExpr(pWalker, pExpr->pLeft) ) return 2;
       ((void)0);
      if( pExpr->pRight ){
        ((void)0);
        pExpr = pExpr->pRight;
        continue;
      }else if( (((pExpr)->flags&(0x000800))!=0) ){
        ((void)0);
        if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return 2;
      }else{
        if( pExpr->x.pList ){
          if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return 2;
        }

        if( (((pExpr)->flags&(0x1000000))!=0) ){
          if( walkWindowList(pWalker, pExpr->y.pWin) ) return 2;
        }

      }
    }
    break;
  }
  return 0;
}
static int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){
  return pExpr ? walkExpr(pWalker,pExpr) : 0;
}





static int sqlite3WalkExprList(Walker *pWalker, ExprList *p){
  int i;
  struct ExprList_item *pItem;
  if( p ){
    for(i=p->nExpr, pItem=p->a; i>0; i--, pItem++){
      if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) return 2;
    }
  }
  return 0;
}







static int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){
  if( sqlite3WalkExprList(pWalker, p->pEList) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pWhere) ) return 2;
  if( sqlite3WalkExprList(pWalker, p->pGroupBy) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pHaving) ) return 2;
  if( sqlite3WalkExprList(pWalker, p->pOrderBy) ) return 2;
  if( sqlite3WalkExpr(pWalker, p->pLimit) ) return 2;

  {
    Parse *pParse = pWalker->pParse;
    if( pParse && (pParse->eParseMode>=2) ){


      int rc = walkWindowList(pWalker, p->pWinDefn);
      return rc;
    }
  }

  return 0;
}
# 95634 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){
  SrcList *pSrc;
  int i;
  struct SrcList_item *pItem;

  pSrc = p->pSrc;
  ((void)0);
  for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
    if( pItem->pSelect && sqlite3WalkSelect(pWalker, pItem->pSelect) ){
      return 2;
    }
    if( pItem->fg.isTabFunc
     && sqlite3WalkExprList(pWalker, pItem->u1.pFuncArg)
    ){
      return 2;
    }
  }
  return 0;
}
# 95671 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalkSelect(Walker *pWalker, Select *p){
  int rc;
  if( p==0 ) return 0;
  if( pWalker->xSelectCallback==0 ) return 0;
  do{
    rc = pWalker->xSelectCallback(pWalker, p);
    if( rc ) return rc & 2;
    if( sqlite3WalkSelectExpr(pWalker, p)
     || sqlite3WalkSelectFrom(pWalker, p)
    ){
      return 2;
    }
    if( pWalker->xSelectCallback2 ){
      pWalker->xSelectCallback2(pWalker, p);
    }
    p = p->pPrior;
  }while( p!=0 );
  return 0;
}
# 95720 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int incrAggDepth(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==163 ) pExpr->op2 += pWalker->u.n;
  return 0;
}
static void incrAggFunctionDepth(Expr *pExpr, int N){
  if( N>0 ){
    Walker w;
    memset(&w, 0, sizeof(w));
    w.xExprCallback = incrAggDepth;
    w.u.n = N;
    sqlite3WalkExpr(&w, pExpr);
  }
}
# 95753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void resolveAlias(
  Parse *pParse,
  ExprList *pEList,
  int iCol,
  Expr *pExpr,
  const char *zType,
  int nSubquery
){
  Expr *pOrig;
  Expr *pDup;
  sqlite3 *db;

  ((void)0);
  pOrig = pEList->a[iCol].pExpr;
  ((void)0);
  db = pParse->db;
  pDup = sqlite3ExprDup(db, pOrig, 0);
  if( pDup!=0 ){
    if( zType[0]!='G' ) incrAggFunctionDepth(pDup, nSubquery);
    if( pExpr->op==109 ){
      pDup = sqlite3ExprAddCollateString(pParse, pDup, pExpr->u.zToken);
    }
# 95783 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    (pExpr)->flags|=(0x8000000);
    sqlite3ExprDelete(db, pExpr);
    memcpy(pExpr, pDup, sizeof(*pExpr));
    if( !(((pExpr)->flags&(0x000400))!=0) && pExpr->u.zToken!=0 ){
      ((void)0);
      pExpr->u.zToken = sqlite3DbStrDup(db, pExpr->u.zToken);
      pExpr->flags |= 0x010000;
    }
    if( (((pExpr)->flags&(0x1000000))!=0) ){
      if( pExpr->y.pWin!=0 ){
        pExpr->y.pWin->pOwner = pExpr;
      }else{
        ((void)0);
      }
    }
    sqlite3DbFree(db, pDup);
  }
  (pExpr)->flags|=(0x400000);
}
# 95810 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int nameInUsingClause(IdList *pUsing, const char *zCol){
  if( pUsing ){
    int k;
    for(k=0; k<pUsing->nId; k++){
      if( sqlite3StrICmp(pUsing->a[k].zName, zCol)==0 ) return 1;
    }
  }
  return 0;
}
# 95827 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3MatchSpanName(
  const char *zSpan,
  const char *zCol,
  const char *zTab,
  const char *zDb
){
  int n;
  for(n=0; (zSpan[n]) && zSpan[n]!='.'; n++){}
  if( zDb && (sqlite3_strnicmp(zSpan, zDb, n)!=0 || zDb[n]!=0) ){
    return 0;
  }
  zSpan += n+1;
  for(n=0; (zSpan[n]) && zSpan[n]!='.'; n++){}
  if( zTab && (sqlite3_strnicmp(zSpan, zTab, n)!=0 || zTab[n]!=0) ){
    return 0;
  }
  zSpan += n+1;
  if( zCol && sqlite3StrICmp(zSpan, zCol)!=0 ){
    return 0;
  }
  return 1;
}




static int areDoubleQuotedStringsEnabled(sqlite3 *db, NameContext *pTopNC){
  if( db->init.busy ) return 1;
  if( pTopNC->ncFlags & 0x10000 ){

    if( sqlite3WritableSchema(db) && (db->flags & 0x40000000)!=0 ){
      return 1;
    }
    return (db->flags & 0x20000000)!=0;
  }else{

    return (db->flags & 0x40000000)!=0;
  }
}
# 95894 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int lookupName(
  Parse *pParse,
  const char *zDb,
  const char *zTab,
  const char *zCol,
  NameContext *pNC,
  Expr *pExpr
){
  int i, j;
  int cnt = 0;
  int cntTab = 0;
  int nSubquery = 0;
  sqlite3 *db = pParse->db;
  struct SrcList_item *pItem;
  struct SrcList_item *pMatch = 0;
  NameContext *pTopNC = pNC;
  Schema *pSchema = 0;
  int eNewExprOp = 162;
  Table *pTab = 0;
  Column *pCol;

  ((void)0);
  ((void)0);
  ((void)0);


  pExpr->iTable = -1;
  ;





  if( zDb ){
    ;
    ;
    if( (pNC->ncFlags & (0x0002|0x0004))!=0 ){




      zDb = 0;
    }else{
      for(i=0; i<db->nDb; i++){
        ((void)0);
        if( sqlite3StrICmp(db->aDb[i].zDbSName,zDb)==0 ){
          pSchema = db->aDb[i].pSchema;
          break;
        }
      }
    }
  }


  ((void)0);
  do{
    ExprList *pEList;
    SrcList *pSrcList = pNC->pSrcList;

    if( pSrcList ){
      for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){
        pTab = pItem->pTab;
        ((void)0);
        ((void)0);
        if( pItem->pSelect && (pItem->pSelect->selFlags & 0x00800)!=0 ){
          int hit = 0;
          pEList = pItem->pSelect->pEList;
          for(j=0; j<pEList->nExpr; j++){
            if( sqlite3MatchSpanName(pEList->a[j].zSpan, zCol, zTab, zDb) ){
              cnt++;
              cntTab = 2;
              pMatch = pItem;
              pExpr->iColumn = j;
              hit = 1;
            }
          }
          if( hit || zTab==0 ) continue;
        }
        if( zDb && pTab->pSchema!=pSchema ){
          continue;
        }
        if( zTab ){
          const char *zTabName = pItem->zAlias ? pItem->zAlias : pTab->zName;
          ((void)0);
          if( sqlite3StrICmp(zTabName, zTab)!=0 ){
            continue;
          }
          if( (pParse->eParseMode>=2) && pItem->zAlias ){
            sqlite3RenameTokenRemap(pParse, 0, (void*)&pExpr->y.pTab);
          }
        }
        if( 0==(cntTab++) ){
          pMatch = pItem;
        }
        for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){
          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){




            if( cnt==1 ){
              if( pItem->fg.jointype & 0x0004 ) continue;
              if( nameInUsingClause(pItem->pUsing, zCol) ) continue;
            }
            cnt++;
            pMatch = pItem;

            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;
            break;
          }
        }
      }
      if( pMatch ){
        pExpr->iTable = pMatch->iCursor;
        pExpr->y.pTab = pMatch->pTab;

        ((void)0);
        if( (pMatch->fg.jointype & 0x0008)!=0 ){
          (pExpr)->flags|=(0x100000);
        }
        pSchema = pExpr->y.pTab->pSchema;
      }
    }






    if( zDb==0 && zTab!=0 && cntTab==0 ){
      pTab = 0;

      if( pParse->pTriggerTab!=0 ){
        int op = pParse->eTriggerOp;
        ((void)0);
        if( op!=124 && sqlite3StrICmp("new",zTab) == 0 ){
          pExpr->iTable = 1;
          pTab = pParse->pTriggerTab;
        }else if( op!=123 && sqlite3StrICmp("old",zTab)==0 ){
          pExpr->iTable = 0;
          pTab = pParse->pTriggerTab;
        }
      }


      if( (pNC->ncFlags & 0x0200)!=0 ){
        Upsert *pUpsert = pNC->uNC.pUpsert;
        if( pUpsert && sqlite3StrICmp("excluded",zTab)==0 ){
          pTab = pUpsert->pUpsertSrc->a[0].pTab;
          pExpr->iTable = 2;
        }
      }


      if( pTab ){
        int iCol;
        pSchema = pTab->pSchema;
        cntTab++;
        for(iCol=0, pCol=pTab->aCol; iCol<pTab->nCol; iCol++, pCol++){
          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){
            if( iCol==pTab->iPKey ){
              iCol = -1;
            }
            break;
          }
        }
        if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) && (((pTab)->tabFlags & 0x0040)==0) ){

          iCol = -1;
        }
        if( iCol<pTab->nCol ){
          cnt++;

          if( pExpr->iTable==2 ){
            ;
            if( (pParse->eParseMode>=2) ){
              pExpr->iColumn = iCol;
              pExpr->y.pTab = pTab;
              eNewExprOp = 162;
            }else{
              pExpr->iTable = pNC->uNC.pUpsert->regData + iCol;
              eNewExprOp = 171;
              (pExpr)->flags|=(0x400000);
            }
          }else

          {

            if( iCol<0 ){
              pExpr->affExpr = 0x44;
            }else if( pExpr->iTable==0 ){
              ;
              ;
              pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
            }else{
              ;
              ;
              pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));
            }
            pExpr->y.pTab = pTab;
            pExpr->iColumn = (i16)iCol;
            eNewExprOp = 77;

          }
        }
      }
    }





    if( cnt==0
     && cntTab==1
     && pMatch
     && (pNC->ncFlags & 0x0020)==0
     && sqlite3IsRowid(zCol)
     && (((pMatch->pTab)->tabFlags & 0x0040)==0)
    ){
      cnt = 1;
      pExpr->iColumn = -1;
      pExpr->affExpr = 0x44;
    }
# 96136 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (pNC->ncFlags & 0x0080)!=0
     && cnt==0
     && zTab==0
    ){
      pEList = pNC->uNC.pEList;
      ((void)0);
      for(j=0; j<pEList->nExpr; j++){
        char *zAs = pEList->a[j].zName;
        if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){
          Expr *pOrig;
          ((void)0);
          ((void)0);
          ((void)0);
          pOrig = pEList->a[j].pExpr;
          if( (pNC->ncFlags&0x0001)==0 && (((pOrig)->flags&(0x000010))!=0) ){
            sqlite3ErrorMsg(pParse, "misuse of aliased aggregate %s", zAs);
            return 2;
          }
          if( (pNC->ncFlags&0x4000)==0 && (((pOrig)->flags&(0x008000))!=0) ){
            sqlite3ErrorMsg(pParse, "misuse of aliased window function %s",zAs);
            return 2;
          }
          if( sqlite3ExprVectorSize(pOrig)!=1 ){
            sqlite3ErrorMsg(pParse, "row value misused");
            return 2;
          }
          resolveAlias(pParse, pEList, j, pExpr, "", nSubquery);
          cnt = 1;
          pMatch = 0;
          ((void)0);
          if( (pParse->eParseMode>=2) ){
            sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
          }
          goto lookupname_end;
        }
      }
    }




    if( cnt ) break;
    pNC = pNC->pNext;
    nSubquery++;
  }while( pNC );
# 96193 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( cnt==0 && zTab==0 ){
    ((void)0);
    if( (((pExpr)->flags&(0x000040))!=0)
     && areDoubleQuotedStringsEnabled(db, pTopNC)
    ){
# 96212 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      sqlite3_log(28,
        "double-quoted string literal: \"%w\"", zCol);



      pExpr->op = 113;
      pExpr->y.pTab = 0;
      return 1;
    }
    if( sqlite3ExprIdToTrueFalse(pExpr) ){
      return 1;
    }
  }





  if( cnt!=1 ){
    const char *zErr;
    zErr = cnt==0 ? "no such column" : "ambiguous column name";
    if( zDb ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s.%s", zErr, zDb, zTab, zCol);
    }else if( zTab ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zErr, zTab, zCol);
    }else{
      sqlite3ErrorMsg(pParse, "%s: %s", zErr, zCol);
    }
    pParse->checkSchema = 1;
    pTopNC->nErr++;
  }







  if( pExpr->iColumn>=0 && pMatch!=0 ){
    int n = pExpr->iColumn;
    ;
    if( n>=((int)(sizeof(Bitmask)*8)) ){
      n = ((int)(sizeof(Bitmask)*8))-1;
    }
    ((void)0);
    pMatch->colUsed |= ((Bitmask)1)<<n;
  }



  sqlite3ExprDelete(db, pExpr->pLeft);
  pExpr->pLeft = 0;
  sqlite3ExprDelete(db, pExpr->pRight);
  pExpr->pRight = 0;
  pExpr->op = eNewExprOp;
  (pExpr)->flags|=(0x800000);
lookupname_end:
  if( cnt==1 ){
    ((void)0);
    if( !(((pExpr)->flags&(0x400000))!=0) ){
      sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);
    }


    for(;;){
      ((void)0);
      pTopNC->nRef++;
      if( pTopNC==pNC ) break;
      pTopNC = pTopNC->pNext;
    }
    return 1;
  } else {
    return 2;
  }
}





static Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){
  Expr *p = sqlite3ExprAlloc(db, 162, 0, 0);
  if( p ){
    struct SrcList_item *pItem = &pSrc->a[iSrc];
    p->y.pTab = pItem->pTab;
    p->iTable = pItem->iCursor;
    if( p->y.pTab->iPKey==iCol ){
      p->iColumn = -1;
    }else{
      p->iColumn = (ynVar)iCol;
      ;
      ;
      pItem->colUsed |= ((Bitmask)1)<<(iCol>=((int)(sizeof(Bitmask)*8)) ? ((int)(sizeof(Bitmask)*8))-1 : iCol);
    }
  }
  return p;
}





static void notValid(
  Parse *pParse,
  NameContext *pNC,
  const char *zMsg,
  int validMask
){
  ((void)0);
  if( (pNC->ncFlags & validMask)!=0 ){
    const char *zIn = "partial index WHERE clauses";
    if( pNC->ncFlags & 0x0020 ) zIn = "index expressions";

    else if( pNC->ncFlags & 0x0004 ) zIn = "CHECK constraints";

    sqlite3ErrorMsg(pParse, "%s prohibited in %s", zMsg, zIn);
  }
}






static int exprProbability(Expr *p){
  double r = -1.0;
  if( p->op!=148 ) return -1;
  sqlite3AtoF(p->u.zToken, &r, sqlite3Strlen30(p->u.zToken), 1);
  ((void)0);
  if( r>1.0 ) return -1;
  return (int)(r*134217728.0);
}
# 96356 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int resolveExprStep(Walker *pWalker, Expr *pExpr){
  NameContext *pNC;
  Parse *pParse;

  pNC = pWalker->u.pNC;
  ((void)0);
  pParse = pNC->pParse;
  ((void)0);
# 96374 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  switch( pExpr->op ){
# 96405 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 59:
    case 137: {
      const char *zColumn;
      const char *zTable;
      const char *zDb;
      Expr *pRight;

      if( pExpr->op==59 ){
        zDb = 0;
        zTable = 0;
        zColumn = pExpr->u.zToken;
      }else{
        Expr *pLeft = pExpr->pLeft;
        notValid(pParse, pNC, "the \".\" operator", 0x0020);
        pRight = pExpr->pRight;
        if( pRight->op==59 ){
          zDb = 0;
        }else{
          ((void)0);
          zDb = pLeft->u.zToken;
          pLeft = pRight->pLeft;
          pRight = pRight->pRight;
        }
        zTable = pLeft->u.zToken;
        zColumn = pRight->u.zToken;
        if( (pParse->eParseMode>=2) ){
          sqlite3RenameTokenRemap(pParse, (void*)pExpr, (void*)pRight);
          sqlite3RenameTokenRemap(pParse, (void*)&pExpr->y.pTab, (void*)pLeft);
        }
      }
      return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);
    }



    case 167: {
      ExprList *pList = pExpr->x.pList;
      int n = pList ? pList->nExpr : 0;
      int no_such_func = 0;
      int wrong_num_args = 0;
      int is_agg = 0;
      int nId;
      const char *zId;
      FuncDef *pDef;
      u8 enc = ((pParse->db)->enc);
      int savedAllowFlags = (pNC->ncFlags & (0x0001 | 0x4000));

      Window *pWin = (( ((((pExpr))->flags&(0x1000000))!=0) && pExpr->y.pWin->eFrmType!=161 ) ? pExpr->y.pWin : 0);

      ((void)0);
      zId = pExpr->u.zToken;
      nId = sqlite3Strlen30(zId);
      pDef = sqlite3FindFunction(pParse->db, zId, n, enc, 0);
      if( pDef==0 ){
        pDef = sqlite3FindFunction(pParse->db, zId, -2, enc, 0);
        if( pDef==0 ){
          no_such_func = 1;
        }else{
          wrong_num_args = 1;
        }
      }else{
        is_agg = pDef->xFinalize!=0;
        if( pDef->funcFlags & 0x0400 ){
          (pExpr)->flags|=(0x040000);
          if( n==2 ){
            pExpr->iTable = exprProbability(pList->a[1].pExpr);
            if( pExpr->iTable<0 ){
              sqlite3ErrorMsg(pParse,
                "second argument to likelihood() must be a "
                "constant between 0.0 and 1.0");
              pNC->nErr++;
            }
          }else{
# 96487 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
            pExpr->iTable = pDef->zName[0]=='u' ? 8388608 : 125829120;
          }
        }

        {
          int auth = sqlite3AuthCheck(pParse, 31, 0,pDef->zName,0);
          if( auth!=0 ){
            if( auth==1 ){
              sqlite3ErrorMsg(pParse, "not authorized to use function: %s",
                                      pDef->zName);
              pNC->nErr++;
            }
            pExpr->op = 117;
            return 1;
          }
        }

        if( pDef->funcFlags & (0x0800|0x2000) ){



          (pExpr)->flags|=(0x080000);
        }
        if( (pDef->funcFlags & 0x0800)==0 ){



          notValid(pParse, pNC, "non-deterministic functions",
                   0x0020|0x0002);
        }
        if( (pDef->funcFlags & 0x00040000)!=0
         && pParse->nested==0
         && sqlite3Config.bInternalFunctions==0
        ){


          no_such_func = 1;
          pDef = 0;
        }else
        if( (pDef->funcFlags & 0x00080000)!=0
         && (((pExpr)->flags&(0x40000000))!=0)
         && !(pParse->eParseMode>=2)
        ){


          sqlite3ErrorMsg(pParse, "%s() prohibited in triggers and views",
                          pDef->zName);
        }
      }

      if( 0==(pParse->eParseMode>=2) ){

        ((void)0)


         ;
        if( pDef && pDef->xValue==0 && pWin ){
          sqlite3ErrorMsg(pParse,
              "%.*s() may not be used as a window function", nId, zId
          );
          pNC->nErr++;
        }else if(
              (is_agg && (pNC->ncFlags & 0x0001)==0)
           || (is_agg && (pDef->funcFlags&0x00010000) && !pWin)
           || (is_agg && pWin && (pNC->ncFlags & 0x4000)==0)
        ){
          const char *zType;
          if( (pDef->funcFlags & 0x00010000) || pWin ){
            zType = "window";
          }else{
            zType = "aggregate";
          }
          sqlite3ErrorMsg(pParse, "misuse of %s function %.*s()",zType,nId,zId);
          pNC->nErr++;
          is_agg = 0;
        }







        else if( no_such_func && pParse->db->init.busy==0



        ){
          sqlite3ErrorMsg(pParse, "no such function: %.*s", nId, zId);
          pNC->nErr++;
        }else if( wrong_num_args ){
          sqlite3ErrorMsg(pParse,"wrong number of arguments to function %.*s()",
               nId, zId);
          pNC->nErr++;
        }

        else if( is_agg==0 && (((pExpr)->flags&(0x1000000))!=0) ){
          sqlite3ErrorMsg(pParse,
              "FILTER may not be used with non-aggregate %.*s()",
              nId, zId
          );
          pNC->nErr++;
        }

        if( is_agg ){




          pNC->ncFlags &= ~(0x4000 | (!pWin ? 0x0001 : 0));



        }
      }

      else if( (((pExpr)->flags&(0x1000000))!=0) ){
        is_agg = 1;
      }

      sqlite3WalkExprList(pWalker, pList);
      if( is_agg ){

        if( pWin ){
          Select *pSel = pNC->pWinSelect;
          ((void)0);
          if( (pParse->eParseMode>=2)==0 ){
            sqlite3WindowUpdate(pParse, pSel->pWinDefn, pWin, pDef);
          }
          sqlite3WalkExprList(pWalker, pWin->pPartition);
          sqlite3WalkExprList(pWalker, pWin->pOrderBy);
          sqlite3WalkExpr(pWalker, pWin->pFilter);
          sqlite3WindowLink(pSel, pWin);
          pNC->ncFlags |= 0x8000;
        }else

        {
          NameContext *pNC2 = pNC;
          pExpr->op = 163;
          pExpr->op2 = 0;

          if( (((pExpr)->flags&(0x1000000))!=0) ){
            sqlite3WalkExpr(pWalker, pExpr->y.pWin->pFilter);
          }

          while( pNC2 && !sqlite3FunctionUsesThisSrc(pExpr, pNC2->pSrcList) ){
            pExpr->op2++;
            pNC2 = pNC2->pNext;
          }
          ((void)0);
          if( pNC2 && pDef ){
            ((void)0);
            ;
            pNC2->ncFlags |= 0x0010 | (pDef->funcFlags & 0x1000);

          }
        }
        pNC->ncFlags |= savedAllowFlags;
      }



      return 1;
    }

    case 134:
    case 20: ;

    case 49: {
      ;
      if( (((pExpr)->flags&(0x000800))!=0) ){
        int nRef = pNC->nRef;
        notValid(pParse, pNC, "subqueries", 0x0004|0x0002|0x0020);
        sqlite3WalkSelect(pWalker, pExpr->x.pSelect);
        ((void)0);
        if( nRef!=pNC->nRef ){
          (pExpr)->flags|=(0x000020);
          pNC->ncFlags |= 0x0040;
        }
      }
      break;
    }
    case 151: {
      notValid(pParse, pNC, "parameters", 0x0004|0x0002|0x0020);
      break;
    }
    case 45:
    case 166: {
      Expr *pRight = sqlite3ExprSkipCollateAndLikely(pExpr->pRight);
      ((void)0);


      if( pRight->op==59 ){
        int rc = resolveExprStep(pWalker, pRight);
        if( rc==2 ) return 2;
        if( pRight->op==165 ){
          pExpr->op2 = pExpr->op;
          pExpr->op = 170;
          return 0;
        }
      }

    }
    case 48:
    case 53:
    case 52:
    case 56:
    case 55:
    case 54:
    case 57: {
      int nLeft, nRight;
      if( pParse->db->mallocFailed ) break;
      ((void)0);
      nLeft = sqlite3ExprVectorSize(pExpr->pLeft);
      if( pExpr->op==48 ){
        nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[0].pExpr);
        if( nRight==nLeft ){
          nRight = sqlite3ExprVectorSize(pExpr->x.pList->a[1].pExpr);
        }
      }else{
        ((void)0);
        nRight = sqlite3ExprVectorSize(pExpr->pRight);
      }
      if( nLeft!=nRight ){
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        ;
        sqlite3ErrorMsg(pParse, "row value misused");
      }
      break;
    }
  }
  return (pParse->nErr || pParse->db->mallocFailed) ? 2 : 0;
}
# 96740 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int resolveAsName(
  Parse *pParse,
  ExprList *pEList,
  Expr *pE
){
  int i;

  (void)(pParse);

  if( pE->op==59 ){
    char *zCol = pE->u.zToken;
    for(i=0; i<pEList->nExpr; i++){
      char *zAs = pEList->a[i].zName;
      if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){
        return i+1;
      }
    }
  }
  return 0;
}
# 96779 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int resolveOrderByTermToExprList(
  Parse *pParse,
  Select *pSelect,
  Expr *pE
){
  int i;
  ExprList *pEList;
  NameContext nc;
  sqlite3 *db;
  int rc;
  u8 savedSuppErr;

  ((void)0);
  pEList = pSelect->pEList;



  memset(&nc, 0, sizeof(nc));
  nc.pParse = pParse;
  nc.pSrcList = pSelect->pSrc;
  nc.uNC.pEList = pEList;
  nc.ncFlags = 0x0001|0x0080;
  nc.nErr = 0;
  db = pParse->db;
  savedSuppErr = db->suppressErr;
  db->suppressErr = 1;
  rc = sqlite3ResolveExprNames(&nc, pE);
  db->suppressErr = savedSuppErr;
  if( rc ) return 0;





  for(i=0; i<pEList->nExpr; i++){
    if( sqlite3ExprCompare(0, pEList->a[i].pExpr, pE, -1)<2 ){
      return i+1;
    }
  }


  return 0;
}




static void resolveOutOfRangeError(
  Parse *pParse,
  const char *zType,
  int i,
  int mx
){
  sqlite3ErrorMsg(pParse,
    "%r %s BY term out of range - should be "
    "between 1 and %d", i, zType, mx);
}
# 96852 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int resolveCompoundOrderBy(
  Parse *pParse,
  Select *pSelect
){
  int i;
  ExprList *pOrderBy;
  ExprList *pEList;
  sqlite3 *db;
  int moreToDo = 1;

  pOrderBy = pSelect->pOrderBy;
  if( pOrderBy==0 ) return 0;
  db = pParse->db;
  if( pOrderBy->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many terms in ORDER BY clause");
    return 1;
  }
  for(i=0; i<pOrderBy->nExpr; i++){
    pOrderBy->a[i].done = 0;
  }
  pSelect->pNext = 0;
  while( pSelect->pPrior ){
    pSelect->pPrior->pNext = pSelect;
    pSelect = pSelect->pPrior;
  }
  while( pSelect && moreToDo ){
    struct ExprList_item *pItem;
    moreToDo = 0;
    pEList = pSelect->pEList;
    ((void)0);
    for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
      int iCol = -1;
      Expr *pE, *pDup;
      if( pItem->done ) continue;
      pE = sqlite3ExprSkipCollateAndLikely(pItem->pExpr);
      if( sqlite3ExprIsInteger(pE, &iCol) ){
        if( iCol<=0 || iCol>pEList->nExpr ){
          resolveOutOfRangeError(pParse, "ORDER", i+1, pEList->nExpr);
          return 1;
        }
      }else{
        iCol = resolveAsName(pParse, pEList, pE);
        if( iCol==0 ){
# 96908 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          if( (pParse->eParseMode>=2) ){
            pDup = pE;
          }else{
            pDup = sqlite3ExprDup(db, pE, 0);
          }
          if( !db->mallocFailed ){
            ((void)0);
            iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);
          }
          if( !(pParse->eParseMode>=2) ){
            sqlite3ExprDelete(db, pDup);
          }
        }
      }
      if( iCol>0 ){


        if( !(pParse->eParseMode>=2) ){
          Expr *pNew = sqlite3Expr(db, 150, 0);
          if( pNew==0 ) return 1;
          pNew->flags |= 0x000400;
          pNew->u.iValue = iCol;
          if( pItem->pExpr==pE ){
            pItem->pExpr = pNew;
          }else{
            Expr *pParent = pItem->pExpr;
            ((void)0);
            while( pParent->pLeft->op==109 ) pParent = pParent->pLeft;
            ((void)0);
            pParent->pLeft = pNew;
          }
          sqlite3ExprDelete(db, pE);
          pItem->u.x.iOrderByCol = (u16)iCol;
        }
        pItem->done = 1;
      }else{
        moreToDo = 1;
      }
    }
    pSelect = pSelect->pNext;
  }
  for(i=0; i<pOrderBy->nExpr; i++){
    if( pOrderBy->a[i].done==0 ){
      sqlite3ErrorMsg(pParse, "%r ORDER BY term does not match any "
            "column in the result set", i+1);
      return 1;
    }
  }
  return 0;
}
# 96969 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ResolveOrderGroupBy(
  Parse *pParse,
  Select *pSelect,
  ExprList *pOrderBy,
  const char *zType
){
  int i;
  sqlite3 *db = pParse->db;
  ExprList *pEList;
  struct ExprList_item *pItem;

  if( pOrderBy==0 || pParse->db->mallocFailed || (pParse->eParseMode>=2) ) return 0;
  if( pOrderBy->nExpr>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many terms in %s BY clause", zType);
    return 1;
  }
  pEList = pSelect->pEList;
  ((void)0);
  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
    if( pItem->u.x.iOrderByCol ){
      if( pItem->u.x.iOrderByCol>pEList->nExpr ){
        resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr);
        return 1;
      }
      resolveAlias(pParse, pEList, pItem->u.x.iOrderByCol-1, pItem->pExpr,
                   zType,0);
    }
  }
  return 0;
}





static int resolveRemoveWindowsCb(Walker *pWalker, Expr *pExpr){
  (void)(pWalker);
  if( (((pExpr)->flags&(0x1000000))!=0) ){
    Window *pWin = pExpr->y.pWin;
    sqlite3WindowUnlinkFromSelect(pWin);
  }
  return 0;
}





static void windowRemoveExprFromSelect(Select *pSelect, Expr *pExpr){
  if( pSelect->pWin ){
    Walker sWalker;
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.xExprCallback = resolveRemoveWindowsCb;
    sWalker.u.pSelect = pSelect;
    sqlite3WalkExpr(&sWalker, pExpr);
  }
}
# 97048 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int resolveOrderGroupBy(
  NameContext *pNC,
  Select *pSelect,
  ExprList *pOrderBy,
  const char *zType
){
  int i, j;
  int iCol;
  struct ExprList_item *pItem;
  Parse *pParse;
  int nResult;

  if( pOrderBy==0 ) return 0;
  nResult = pSelect->pEList->nExpr;
  pParse = pNC->pParse;
  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){
    Expr *pE = pItem->pExpr;
    Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pE);
    if( zType[0]!='G' ){
      iCol = resolveAsName(pParse, pSelect->pEList, pE2);
      if( iCol>0 ){




        pItem->u.x.iOrderByCol = (u16)iCol;
        continue;
      }
    }
    if( sqlite3ExprIsInteger(pE2, &iCol) ){



      if( iCol<1 || iCol>0xffff ){
        resolveOutOfRangeError(pParse, zType, i+1, nResult);
        return 1;
      }
      pItem->u.x.iOrderByCol = (u16)iCol;
      continue;
    }


    pItem->u.x.iOrderByCol = 0;
    if( sqlite3ResolveExprNames(pNC, pE) ){
      return 1;
    }
    for(j=0; j<pSelect->pEList->nExpr; j++){
      if( sqlite3ExprCompare(0, pE, pSelect->pEList->a[j].pExpr, -1)==0 ){



        windowRemoveExprFromSelect(pSelect, pE);
        pItem->u.x.iOrderByCol = j+1;
      }
    }
  }
  return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);
}




static int resolveSelectStep(Walker *pWalker, Select *p){
  NameContext *pOuterNC;
  NameContext sNC;
  int isCompound;
  int nCompound;
  Parse *pParse;
  int i;
  ExprList *pGroupBy;
  Select *pLeftmost;
  sqlite3 *db;


  ((void)0);
  if( p->selFlags & 0x00004 ){
    return 1;
  }
  pOuterNC = pWalker->u.pNC;
  pParse = pWalker->pParse;
  db = pParse->db;
# 97138 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (p->selFlags & 0x00040)==0 ){
    sqlite3SelectPrep(pParse, p, pOuterNC);
    return (pParse->nErr || db->mallocFailed) ? 2 : 1;
  }

  isCompound = p->pPrior!=0;
  nCompound = 0;
  pLeftmost = p;
  while( p ){
    ((void)0);
    ((void)0);
    p->selFlags |= 0x00004;




    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pWinSelect = p;
    if( sqlite3ResolveExprNames(&sNC, p->pLimit) ){
      return 2;
    }







    if( p->selFlags & 0x10000 ){
      Select *pSub = p->pSrc->a[0].pSelect;
      ((void)0);
      ((void)0);
      pSub->pOrderBy = p->pOrderBy;
      p->pOrderBy = 0;
    }



    for(i=0; i<p->pSrc->nSrc; i++){
      struct SrcList_item *pItem = &p->pSrc->a[i];
      if( pItem->pSelect && (pItem->pSelect->selFlags & 0x00004)==0 ){
        NameContext *pNC;
        int nRef = 0;
        const char *zSavedContext = pParse->zAuthContext;






        for(pNC=pOuterNC; pNC; pNC=pNC->pNext) nRef += pNC->nRef;

        if( pItem->zName ) pParse->zAuthContext = pItem->zName;
        sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);
        pParse->zAuthContext = zSavedContext;
        if( pParse->nErr || db->mallocFailed ) return 2;

        for(pNC=pOuterNC; pNC; pNC=pNC->pNext) nRef -= pNC->nRef;
        ((void)0);
        pItem->fg.isCorrelated = (nRef!=0);
      }
    }




    sNC.ncFlags = 0x0001|0x4000;
    sNC.pSrcList = p->pSrc;
    sNC.pNext = pOuterNC;


    if( sqlite3ResolveExprListNames(&sNC, p->pEList) ) return 2;
    sNC.ncFlags &= ~0x4000;




    ((void)0);
    pGroupBy = p->pGroupBy;
    if( pGroupBy || (sNC.ncFlags & 0x0010)!=0 ){
      ((void)0);
      p->selFlags |= 0x00008 | (sNC.ncFlags&0x1000);
    }else{
      sNC.ncFlags &= ~0x0001;
    }



    if( p->pHaving && !pGroupBy ){
      sqlite3ErrorMsg(pParse, "a GROUP BY clause is required before HAVING");
      return 2;
    }
# 97240 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    sNC.uNC.pEList = p->pEList;
    sNC.ncFlags |= 0x0080;
    if( sqlite3ResolveExprNames(&sNC, p->pHaving) ) return 2;
    if( sqlite3ResolveExprNames(&sNC, p->pWhere) ) return 2;


    for(i=0; i<p->pSrc->nSrc; i++){
      struct SrcList_item *pItem = &p->pSrc->a[i];
      if( pItem->fg.isTabFunc
       && sqlite3ResolveExprListNames(&sNC, pItem->u1.pFuncArg)
      ){
        return 2;
      }
    }




    sNC.pNext = 0;
    sNC.ncFlags |= 0x0001|0x4000;






    if( p->selFlags & 0x10000 ){
      Select *pSub = p->pSrc->a[0].pSelect;
      p->pOrderBy = pSub->pOrderBy;
      pSub->pOrderBy = 0;
    }
# 97283 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( isCompound<=nCompound
     && resolveOrderGroupBy(&sNC, p, p->pOrderBy, "ORDER")
    ){
      return 2;
    }
    if( db->mallocFailed ){
      return 2;
    }
    sNC.ncFlags &= ~0x4000;




    if( pGroupBy ){
      struct ExprList_item *pItem;

      if( resolveOrderGroupBy(&sNC, p, pGroupBy, "GROUP") || db->mallocFailed ){
        return 2;
      }
      for(i=0, pItem=pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++){
        if( (((pItem->pExpr)->flags&(0x000010))!=0) ){
          sqlite3ErrorMsg(pParse, "aggregate functions are not allowed in "
              "the GROUP BY clause");
          return 2;
        }
      }
    }


    if( (pParse->eParseMode>=2) ){
      Window *pWin;
      for(pWin=p->pWinDefn; pWin; pWin=pWin->pNextWin){
        if( sqlite3ResolveExprListNames(&sNC, pWin->pOrderBy)
         || sqlite3ResolveExprListNames(&sNC, pWin->pPartition)
        ){
          return 2;
        }
      }
    }




    if( p->pNext && p->pEList->nExpr!=p->pNext->pEList->nExpr ){
      sqlite3SelectWrongNumTermsError(pParse, p->pNext);
      return 2;
    }



    p = p->pPrior;
    nCompound++;
  }




  if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){
    return 2;
  }

  return 1;
}
# 97395 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ResolveExprNames(
  NameContext *pNC,
  Expr *pExpr
){
  int savedHasAgg;
  Walker w;

  if( pExpr==0 ) return 0;
  savedHasAgg = pNC->ncFlags & (0x0010|0x1000|0x8000);
  pNC->ncFlags &= ~(0x0010|0x1000|0x8000);
  w.pParse = pNC->pParse;
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.u.pNC = pNC;

  w.pParse->nHeight += pExpr->nHeight;
  if( sqlite3ExprCheckHeight(w.pParse, w.pParse->nHeight) ){
    return 1;
  }

  sqlite3WalkExpr(&w, pExpr);

  w.pParse->nHeight -= pExpr->nHeight;

  ((void)0);
  ((void)0);
  ;
  ;
  (pExpr)->flags|=(pNC->ncFlags & (0x0010|0x8000));
  pNC->ncFlags |= savedHasAgg;
  return pNC->nErr>0 || w.pParse->nErr>0;
}






static int sqlite3ResolveExprListNames(
  NameContext *pNC,
  ExprList *pList
){
  int i;
  if( pList ){
    for(i=0; i<pList->nExpr; i++){
      if( sqlite3ResolveExprNames(pNC, pList->a[i].pExpr) ) return 2;
    }
  }
  return 0;
}
# 97459 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ResolveSelectNames(
  Parse *pParse,
  Select *p,
  NameContext *pOuterNC
){
  Walker w;

  ((void)0);
  w.xExprCallback = resolveExprStep;
  w.xSelectCallback = resolveSelectStep;
  w.xSelectCallback2 = 0;
  w.pParse = pParse;
  w.u.pNC = pOuterNC;
  sqlite3WalkSelect(&w, p);
}
# 97490 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ResolveSelfReference(
  Parse *pParse,
  Table *pTab,
  int type,
  Expr *pExpr,
  ExprList *pList
){
  SrcList sSrc;
  NameContext sNC;
  int rc;

  ((void)0);
  ((void)0);
  memset(&sNC, 0, sizeof(sNC));
  memset(&sSrc, 0, sizeof(sSrc));
  if( pTab ){
    sSrc.nSrc = 1;
    sSrc.a[0].zName = pTab->zName;
    sSrc.a[0].pTab = pTab;
    sSrc.a[0].iCursor = -1;
  }
  sNC.pParse = pParse;
  sNC.pSrcList = &sSrc;
  sNC.ncFlags = type | 0x10000;
  if( (rc = sqlite3ResolveExprNames(&sNC, pExpr))!=0 ) return rc;
  if( pList ) rc = sqlite3ResolveExprListNames(&sNC, pList);
  return rc;
}
# 97538 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void exprCodeBetween(Parse*,Expr*,int,void(*)(Parse*,Expr*,int,int),int);
static int exprCodeVector(Parse *pParse, Expr *p, int *piToFree);




static char sqlite3TableColumnAffinity(Table *pTab, int iCol){
  ((void)0);
  return iCol>=0 ? pTab->aCol[iCol].affinity : 0x44;
}
# 97565 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char sqlite3ExprAffinity(Expr *pExpr){
  int op;
  while( (((pExpr)->flags&(0x001000))!=0) ){
    ((void)0);
    pExpr = pExpr->pLeft;
    ((void)0);
  }
  op = pExpr->op;
  if( op==134 ){
    ((void)0);
    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);
  }
  if( op==171 ) op = pExpr->op2;

  if( op==36 ){
    ((void)0);
    return sqlite3AffinityType(pExpr->u.zToken, 0);
  }

  if( (op==164 || op==162) && pExpr->y.pTab ){
    return sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);
  }
  if( op==173 ){
    ((void)0);
    return sqlite3ExprAffinity(
        pExpr->pLeft->x.pSelect->pEList->a[pExpr->iColumn].pExpr
    );
  }
  return pExpr->affExpr;
}
# 97604 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3ExprAddCollateToken(
  Parse *pParse,
  Expr *pExpr,
  const Token *pCollName,
  int dequote
){
  if( pCollName->n>0 ){
    Expr *pNew = sqlite3ExprAlloc(pParse->db, 109, pCollName, dequote);
    if( pNew ){
      pNew->pLeft = pExpr;
      pNew->flags |= 0x000100|0x001000;
      pExpr = pNew;
    }
  }
  return pExpr;
}
static Expr *sqlite3ExprAddCollateString(Parse *pParse, Expr *pExpr, const char *zC){
  Token s;
  ((void)0);
  sqlite3TokenInit(&s, (char*)zC);
  return sqlite3ExprAddCollateToken(pParse, pExpr, &s, 0);
}




static Expr *sqlite3ExprSkipCollate(Expr *pExpr){
  while( pExpr && (((pExpr)->flags&(0x001000))!=0) ){
    ((void)0);
    pExpr = pExpr->pLeft;
  }
  return pExpr;
}






static Expr *sqlite3ExprSkipCollateAndLikely(Expr *pExpr){
  while( pExpr && (((pExpr)->flags&(0x001000|0x040000))!=0) ){
    if( (((pExpr)->flags&(0x040000))!=0) ){
      ((void)0);
      ((void)0);
      ((void)0);
      pExpr = pExpr->x.pList->a[0].pExpr;
    }else{
      ((void)0);
      pExpr = pExpr->pLeft;
    }
  }
  return pExpr;
}
# 97672 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){
  sqlite3 *db = pParse->db;
  CollSeq *pColl = 0;
  Expr *p = pExpr;
  while( p ){
    int op = p->op;
    if( op==171 ) op = p->op2;
    if( (op==164 || op==162 || op==77)
     && p->y.pTab!=0
    ){


      int j = p->iColumn;
      if( j>=0 ){
        const char *zColl = p->y.pTab->aCol[j].zColl;
        pColl = sqlite3FindCollSeq(db, ((db)->enc), zColl, 0);
      }
      break;
    }
    if( op==36 || op==169 ){
      p = p->pLeft;
      continue;
    }
    if( op==109 ){
      pColl = sqlite3GetCollSeq(pParse, ((db)->enc), 0, p->u.zToken);
      break;
    }
    if( p->flags & 0x000100 ){
      if( p->pLeft && (p->pLeft->flags & 0x000100)!=0 ){
        p = p->pLeft;
      }else{
        Expr *pNext = p->pRight;

        ((void)0);



        if( p->x.pList!=0 && (!(((p)->flags&(0x000800))!=0)) ){
          int i;
          for(i=0; (i<p->x.pList->nExpr); i++){
            if( (((p->x.pList->a[i].pExpr)->flags&(0x000100))!=0) ){
              pNext = p->x.pList->a[i].pExpr;
              break;
            }
          }
        }
        p = pNext;
      }
    }else{
      break;
    }
  }
  if( sqlite3CheckCollSeq(pParse, pColl) ){
    pColl = 0;
  }
  return pColl;
}
# 97740 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *sqlite3ExprNNCollSeq(Parse *pParse, Expr *pExpr){
  CollSeq *p = sqlite3ExprCollSeq(pParse, pExpr);
  if( p==0 ) p = pParse->db->pDfltColl;
  ((void)0);
  return p;
}




static int sqlite3ExprCollSeqMatch(Parse *pParse, Expr *pE1, Expr *pE2){
  CollSeq *pColl1 = sqlite3ExprNNCollSeq(pParse, pE1);
  CollSeq *pColl2 = sqlite3ExprNNCollSeq(pParse, pE2);
  return sqlite3StrICmp(pColl1->zName, pColl2->zName)==0;
}






static char sqlite3CompareAffinity(Expr *pExpr, char aff2){
  char aff1 = sqlite3ExprAffinity(pExpr);
  if( aff1>0x40 && aff2>0x40 ){



    if( ((aff1)>=0x43) || ((aff2)>=0x43) ){
      return 0x43;
    }else{
      return 0x41;
    }
  }else{

    ((void)0);
    return (aff1<=0x40 ? aff2 : aff1) | 0x40;
  }
}





static char comparisonAffinity(Expr *pExpr){
  char aff;
  ((void)0)

                                                                       ;
  ((void)0);
  aff = sqlite3ExprAffinity(pExpr->pLeft);
  if( pExpr->pRight ){
    aff = sqlite3CompareAffinity(pExpr->pRight, aff);
  }else if( (((pExpr)->flags&(0x000800))!=0) ){
    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);
  }else if( aff==0 ){
    aff = 0x41;
  }
  return aff;
}







static int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){
  char aff = comparisonAffinity(pExpr);
  if( aff<0x42 ){
    return 1;
  }
  if( aff==0x42 ){
    return idx_affinity==0x42;
  }
  return ((idx_affinity)>=0x43);
}





static u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){
  u8 aff = (char)sqlite3ExprAffinity(pExpr2);
  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;
  return aff;
}
# 97839 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *sqlite3BinaryCompareCollSeq(
  Parse *pParse,
  Expr *pLeft,
  Expr *pRight
){
  CollSeq *pColl;
  ((void)0);
  if( pLeft->flags & 0x000100 ){
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
  }else if( pRight && (pRight->flags & 0x000100)!=0 ){
    pColl = sqlite3ExprCollSeq(pParse, pRight);
  }else{
    pColl = sqlite3ExprCollSeq(pParse, pLeft);
    if( !pColl ){
      pColl = sqlite3ExprCollSeq(pParse, pRight);
    }
  }
  return pColl;
}




static int codeCompare(
  Parse *pParse,
  Expr *pLeft,
  Expr *pRight,
  int opcode,
  int in1, int in2,
  int dest,
  int jumpIfNull
){
  int p5;
  int addr;
  CollSeq *p4;

  p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);
  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);
  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,
                           (void*)p4, (-2));
  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);
  return addr;
}
# 97892 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprIsVector(Expr *pExpr){
  return sqlite3ExprVectorSize(pExpr)>1;
}







static int sqlite3ExprVectorSize(Expr *pExpr){
  u8 op = pExpr->op;
  if( op==171 ) op = pExpr->op2;
  if( op==172 ){
    return pExpr->x.pList->nExpr;
  }else if( op==134 ){
    return pExpr->x.pSelect->pEList->nExpr;
  }else{
    return 1;
  }
}
# 97929 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3VectorFieldSubexpr(Expr *pVector, int i){
  ((void)0);
  if( sqlite3ExprIsVector(pVector) ){
    ((void)0);
    if( pVector->op==134 || pVector->op2==134 ){
      return pVector->x.pSelect->pEList->a[i].pExpr;
    }else{
      return pVector->x.pList->a[i].pExpr;
    }
  }
  return pVector;
}
# 97963 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3ExprForVectorField(
  Parse *pParse,
  Expr *pVector,
  int iField
){
  Expr *pRet;
  if( pVector->op==134 ){
    ((void)0);
# 97987 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pRet = sqlite3PExpr(pParse, 173, 0, 0);
    if( pRet ){
      pRet->iColumn = iField;
      pRet->pLeft = pVector;
    }
    ((void)0);
  }else{
    if( pVector->op==172 ) pVector = pVector->x.pList->a[iField].pExpr;
    pRet = sqlite3ExprDup(pParse->db, pVector, 0);
    sqlite3RenameTokenRemap(pParse, pRet, pVector);
  }
  return pRet;
}
# 98009 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int exprCodeSubselect(Parse *pParse, Expr *pExpr){
  int reg = 0;

  if( pExpr->op==134 ){
    reg = sqlite3CodeSubselect(pParse, pExpr);
  }

  return reg;
}
# 98037 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int exprVectorRegister(
  Parse *pParse,
  Expr *pVector,
  int iField,
  int regSelect,
  Expr **ppExpr,
  int *pRegFree
){
  u8 op = pVector->op;
  ((void)0);
  if( op==171 ){
    *ppExpr = sqlite3VectorFieldSubexpr(pVector, iField);
    return pVector->iTable+iField;
  }
  if( op==134 ){
    *ppExpr = pVector->x.pSelect->pEList->a[iField].pExpr;
     return regSelect+iField;
  }
  *ppExpr = pVector->x.pList->a[iField].pExpr;
  return sqlite3ExprCodeTemp(pParse, *ppExpr, pRegFree);
}
# 98070 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void codeVectorCompare(
  Parse *pParse,
  Expr *pExpr,
  int dest,
  u8 op,
  u8 p5
){
  Vdbe *v = pParse->pVdbe;
  Expr *pLeft = pExpr->pLeft;
  Expr *pRight = pExpr->pRight;
  int nLeft = sqlite3ExprVectorSize(pLeft);
  int i;
  int regLeft = 0;
  int regRight = 0;
  u8 opx = op;
  int addrDone = sqlite3VdbeMakeLabel(pParse);

  if( nLeft!=sqlite3ExprVectorSize(pRight) ){
    sqlite3ErrorMsg(pParse, "row value misused");
    return;
  }
  ((void)0)



   ;
  ((void)0)
                                                   ;
  ((void)0);
  ((void)0);

  p5 |= 0x20;
  if( opx==55 ) opx = 56;
  if( opx==57 ) opx = 54;

  regLeft = exprCodeSubselect(pParse, pLeft);
  regRight = exprCodeSubselect(pParse, pRight);

  for(i=0; 1 ; i++){
    int regFree1 = 0, regFree2 = 0;
    Expr *pL, *pR;
    int r1, r2;
    ((void)0);
    r1 = exprVectorRegister(pParse, pLeft, i, regLeft, &pL, &regFree1);
    r2 = exprVectorRegister(pParse, pRight, i, regRight, &pR, &regFree2);
    codeCompare(pParse, pL, pR, opx, r1, r2, dest, p5);
    ; ;
    ; ;
    ; ;
    ; ;
    ; ;
    ; ;
    sqlite3ReleaseTempReg(pParse, regFree1);
    sqlite3ReleaseTempReg(pParse, regFree2);
    if( i==nLeft-1 ){
      break;
    }
    if( opx==53 ){
      sqlite3VdbeAddOp2(v, 20, dest, addrDone); ;
      p5 |= 0x08;
    }else if( opx==52 ){
      sqlite3VdbeAddOp2(v, 18, dest, addrDone); ;
      p5 |= 0x08;
    }else{
      ((void)0);
      sqlite3VdbeAddOp2(v, 58, 0, addrDone);
      ;
      ;
      ;
      ;
      if( i==nLeft-2 ) opx = op;
    }
  }
  sqlite3VdbeResolveLabel(v, addrDone);
}







static int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){
  int rc = 0;
  int mxHeight = pParse->db->aLimit[3];
  if( nHeight>mxHeight ){
    sqlite3ErrorMsg(pParse,
       "Expression tree is too large (maximum depth %d)", mxHeight
    );
    rc = 1;
  }
  return rc;
}
# 98173 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void heightOfExpr(Expr *p, int *pnHeight){
  if( p ){
    if( p->nHeight>*pnHeight ){
      *pnHeight = p->nHeight;
    }
  }
}
static void heightOfExprList(ExprList *p, int *pnHeight){
  if( p ){
    int i;
    for(i=0; i<p->nExpr; i++){
      heightOfExpr(p->a[i].pExpr, pnHeight);
    }
  }
}
static void heightOfSelect(Select *pSelect, int *pnHeight){
  Select *p;
  for(p=pSelect; p; p=p->pPrior){
    heightOfExpr(p->pWhere, pnHeight);
    heightOfExpr(p->pHaving, pnHeight);
    heightOfExpr(p->pLimit, pnHeight);
    heightOfExprList(p->pEList, pnHeight);
    heightOfExprList(p->pGroupBy, pnHeight);
    heightOfExprList(p->pOrderBy, pnHeight);
  }
}
# 98210 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void exprSetHeight(Expr *p){
  int nHeight = 0;
  heightOfExpr(p->pLeft, &nHeight);
  heightOfExpr(p->pRight, &nHeight);
  if( (((p)->flags&(0x000800))!=0) ){
    heightOfSelect(p->x.pSelect, &nHeight);
  }else if( p->x.pList ){
    heightOfExprList(p->x.pList, &nHeight);
    p->flags |= (0x000100|0x200000|0x000004) & sqlite3ExprListFlags(p->x.pList);
  }
  p->nHeight = nHeight + 1;
}
# 98231 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprSetHeightAndFlags(Parse *pParse, Expr *p){
  if( pParse->nErr ) return;
  exprSetHeight(p);
  sqlite3ExprCheckHeight(pParse, p->nHeight);
}





static int sqlite3SelectExprHeight(Select *p){
  int nHeight = 0;
  heightOfSelect(p, &nHeight);
  return nHeight;
}
# 98279 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3ExprAlloc(
  sqlite3 *db,
  int op,
  const Token *pToken,
  int dequote
){
  Expr *pNew;
  int nExtra = 0;
  int iValue = 0;

  ((void)0);
  if( pToken ){
    if( op!=150 || pToken->z==0
          || sqlite3GetInt32(pToken->z, &iValue)==0 ){
      nExtra = pToken->n+1;
      ((void)0);
    }
  }
  pNew = sqlite3DbMallocRawNN(db, sizeof(Expr)+nExtra);
  if( pNew ){
    memset(pNew, 0, sizeof(Expr));
    pNew->op = (u8)op;
    pNew->iAgg = -1;
    if( pToken ){
      if( nExtra==0 ){
        pNew->flags |= 0x000400|0x800000|(iValue?0x10000000:0x20000000);
        pNew->u.iValue = iValue;
      }else{
        pNew->u.zToken = (char*)&pNew[1];
        ((void)0);
        if( pToken->n ) memcpy(pNew->u.zToken, pToken->z, pToken->n);
        pNew->u.zToken[pToken->n] = 0;
        if( dequote && (sqlite3CtypeMap[(unsigned char)(pNew->u.zToken[0])]&0x80) ){
          sqlite3DequoteExpr(pNew);
        }
      }
    }

    pNew->nHeight = 1;

  }
  return pNew;
}





static Expr *sqlite3Expr(
  sqlite3 *db,
  int op,
  const char *zToken
){
  Token x;
  x.z = zToken;
  x.n = sqlite3Strlen30(zToken);
  return sqlite3ExprAlloc(db, op, &x, 0);
}







static void sqlite3ExprAttachSubtrees(
  sqlite3 *db,
  Expr *pRoot,
  Expr *pLeft,
  Expr *pRight
){
  if( pRoot==0 ){
    ((void)0);
    sqlite3ExprDelete(db, pLeft);
    sqlite3ExprDelete(db, pRight);
  }else{
    if( pRight ){
      pRoot->pRight = pRight;
      pRoot->flags |= (0x000100|0x200000|0x000004) & pRight->flags;
    }
    if( pLeft ){
      pRoot->pLeft = pLeft;
      pRoot->flags |= (0x000100|0x200000|0x000004) & pLeft->flags;
    }
    exprSetHeight(pRoot);
  }
}
# 98374 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3PExpr(
  Parse *pParse,
  int op,
  Expr *pLeft,
  Expr *pRight
){
  Expr *p;
  p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr));
  if( p ){
    memset(p, 0, sizeof(Expr));
    p->op = op & 0xff;
    p->iAgg = -1;
    sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);
    sqlite3ExprCheckHeight(pParse, p->nHeight);
  }else{
    sqlite3ExprDelete(pParse->db, pLeft);
    sqlite3ExprDelete(pParse->db, pRight);
  }
  return p;
}





static void sqlite3PExprAddSelect(Parse *pParse, Expr *pExpr, Select *pSelect){
  if( pExpr ){
    pExpr->x.pSelect = pSelect;
    (pExpr)->flags|=(0x000800|0x200000);
    sqlite3ExprSetHeightAndFlags(pParse, pExpr);
  }else{
    ((void)0);
    sqlite3SelectDelete(pParse->db, pSelect);
  }
}
# 98419 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3ExprAnd(Parse *pParse, Expr *pLeft, Expr *pRight){
  sqlite3 *db = pParse->db;
  if( pLeft==0 ){
    return pRight;
  }else if( pRight==0 ){
    return pLeft;
  }else if( (((pLeft)->flags&(0x000001|0x20000000))==0x20000000) || (((pRight)->flags&(0x000001|0x20000000))==0x20000000) ){
    sqlite3ExprUnmapAndDelete(pParse, pLeft);
    sqlite3ExprUnmapAndDelete(pParse, pRight);
    return sqlite3Expr(db, 150, "0");
  }else{
    return sqlite3PExpr(pParse, 44, pLeft, pRight);
  }
}





static Expr *sqlite3ExprFunction(
  Parse *pParse,
  ExprList *pList,
  Token *pToken,
  int eDistinct
){
  Expr *pNew;
  sqlite3 *db = pParse->db;
  ((void)0);
  pNew = sqlite3ExprAlloc(db, 167, pToken, 1);
  if( pNew==0 ){
    sqlite3ExprListDelete(db, pList);
    return 0;
  }
  if( pList && pList->nExpr > pParse->db->aLimit[6] ){
    sqlite3ErrorMsg(pParse, "too many arguments on function %T", pToken);
  }
  pNew->x.pList = pList;
  (pNew)->flags|=(0x000004);
  ((void)0);
  sqlite3ExprSetHeightAndFlags(pParse, pNew);
  if( eDistinct==0x00001 ) (pNew)->flags|=(0x000002);
  return pNew;
}
# 98479 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr, u32 n){
  sqlite3 *db = pParse->db;
  const char *z;
  ynVar x;

  if( pExpr==0 ) return;
  ((void)0);
  z = pExpr->u.zToken;
  ((void)0);
  ((void)0);
  ((void)0);
  if( z[1]==0 ){

    ((void)0);
    x = (ynVar)(++pParse->nVar);
  }else{
    int doAdd = 0;
    if( z[0]=='?' ){


      i64 i;
      int bOk;
      if( n==2 ){
        i = z[1]-'0';
        bOk = 1;
      }else{
        bOk = 0==sqlite3Atoi64(&z[1], &i, n-1, 1);
      }
      ;
      ;
      ;
      ;
      if( bOk==0 || i<1 || i>db->aLimit[9] ){
        sqlite3ErrorMsg(pParse, "variable number must be between ?1 and ?%d",
            db->aLimit[9]);
        return;
      }
      x = (ynVar)i;
      if( x>pParse->nVar ){
        pParse->nVar = (int)x;
        doAdd = 1;
      }else if( sqlite3VListNumToName(pParse->pVList, x)==0 ){
        doAdd = 1;
      }
    }else{




      x = (ynVar)sqlite3VListNameToNum(pParse->pVList, z, n);
      if( x==0 ){
        x = (ynVar)(++pParse->nVar);
        doAdd = 1;
      }
    }
    if( doAdd ){
      pParse->pVList = sqlite3VListAdd(db, pParse->pVList, z, n, x);
    }
  }
  pExpr->iColumn = x;
  if( x>db->aLimit[9] ){
    sqlite3ErrorMsg(pParse, "too many SQL variables");
  }
}




static __attribute__((noinline)) void sqlite3ExprDeleteNN(sqlite3 *db, Expr *p){
  ((void)0);

  ((void)0);

  ((void)0);
  ((void)0)
                                                             ;







  if( !(((p)->flags&((0x004000|0x800000)))!=0) ){

    ((void)0);
    if( p->pLeft && p->op!=173 ) sqlite3ExprDeleteNN(db, p->pLeft);
    if( p->pRight ){
      ((void)0);
      sqlite3ExprDeleteNN(db, p->pRight);
    }else if( (((p)->flags&(0x000800))!=0) ){
      ((void)0);
      sqlite3SelectDelete(db, p->x.pSelect);
    }else{
      sqlite3ExprListDelete(db, p->x.pList);

      if( (((p)->flags&(0x1000000))!=0) ){
        sqlite3WindowDelete(db, p->y.pWin);
      }

    }
  }
  if( (((p)->flags&(0x010000))!=0) ) sqlite3DbFree(db, p->u.zToken);
  if( !(((p)->flags&(0x8000000))!=0) ){
    sqlite3DbFreeNN(db, p);
  }
}
static void sqlite3ExprDelete(sqlite3 *db, Expr *p){
  if( p ) sqlite3ExprDeleteNN(db, p);
}




static void sqlite3ExprUnmapAndDelete(Parse *pParse, Expr *p){
  if( p ){
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameExprUnmap(pParse, p);
    }
    sqlite3ExprDeleteNN(pParse->db, p);
  }
}






static int exprStructSize(Expr *p){
  if( (((p)->flags&(0x004000))!=0) ) return __builtin_offsetof(Expr,pLeft);
  if( (((p)->flags&(0x002000))!=0) ) return __builtin_offsetof(Expr,iTable);
  return sizeof(Expr);
}
# 98647 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int dupedExprStructSize(Expr *p, int flags){
  int nSize;
  ((void)0);
  ((void)0);
  ((void)0);
  if( 0==flags || p->op==173

   || (((p)->flags&(0x1000000))!=0)

  ){
    nSize = sizeof(Expr);
  }else{
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    if( p->pLeft || p->x.pList ){
      nSize = __builtin_offsetof(Expr,iTable) | 0x002000;
    }else{
      ((void)0);
      nSize = __builtin_offsetof(Expr,pLeft) | 0x004000;
    }
  }
  return nSize;
}






static int dupedExprNodeSize(Expr *p, int flags){
  int nByte = dupedExprStructSize(p, flags) & 0xfff;
  if( !(((p)->flags&(0x000400))!=0) && p->u.zToken ){
    nByte += (strlen(p->u.zToken)&0x3fffffff)+1;
  }
  return (((nByte)+7)&~7);
}
# 98699 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int dupedExprSize(Expr *p, int flags){
  int nByte = 0;
  if( p ){
    nByte = dupedExprNodeSize(p, flags);
    if( flags&0x0001 ){
      nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);
    }
  }
  return nByte;
}
# 98718 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *exprDup(sqlite3 *db, Expr *p, int dupFlags, u8 **pzBuffer){
  Expr *pNew;
  u8 *zAlloc;
  u32 staticFlag;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  if( pzBuffer ){
    zAlloc = *pzBuffer;
    staticFlag = 0x8000000;
  }else{
    zAlloc = sqlite3DbMallocRawNN(db, dupedExprSize(p, dupFlags));
    staticFlag = 0;
  }
  pNew = (Expr *)zAlloc;

  if( pNew ){





    const unsigned nStructSize = dupedExprStructSize(p, dupFlags);
    const int nNewSize = nStructSize & 0xfff;
    int nToken;
    if( !(((p)->flags&(0x000400))!=0) && p->u.zToken ){
      nToken = sqlite3Strlen30(p->u.zToken) + 1;
    }else{
      nToken = 0;
    }
    if( dupFlags ){
      ((void)0);
      memcpy(zAlloc, p, nNewSize);
    }else{
      u32 nSize = (u32)exprStructSize(p);
      memcpy(zAlloc, p, nSize);
      if( nSize<sizeof(Expr) ){
        memset(&zAlloc[nSize], 0, sizeof(Expr)-nSize);
      }
    }


    pNew->flags &= ~(0x002000|0x004000|0x8000000|0x010000);
    pNew->flags |= nStructSize & (0x002000|0x004000);
    pNew->flags |= staticFlag;


    if( nToken ){
      char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];
      memcpy(zToken, p->u.zToken, nToken);
    }

    if( 0==((p->flags|pNew->flags) & (0x004000|0x800000)) ){

      if( (((p)->flags&(0x000800))!=0) ){
        pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, dupFlags);
      }else{
        pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, dupFlags);
      }
    }


    if( (((pNew)->flags&(0x002000|0x004000|0x1000000))!=0) ){
      zAlloc += dupedExprNodeSize(p, dupFlags);
      if( !(((pNew)->flags&(0x004000|0x800000))!=0) ){
        pNew->pLeft = p->pLeft ?
                      exprDup(db, p->pLeft, 0x0001, &zAlloc) : 0;
        pNew->pRight = p->pRight ?
                       exprDup(db, p->pRight, 0x0001, &zAlloc) : 0;
      }

      if( (((p)->flags&(0x1000000))!=0) ){
        pNew->y.pWin = sqlite3WindowDup(db, pNew, p->y.pWin);
        ((void)0);
      }

      if( pzBuffer ){
        *pzBuffer = zAlloc;
      }
    }else{
      if( !(((p)->flags&(0x004000|0x800000))!=0) ){
        if( pNew->op==173 ){
          pNew->pLeft = p->pLeft;
          ((void)0);
          ((void)0);
        }else{
          pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);
        }
        pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);
      }
    }
  }
  return pNew;
}







static With *withDup(sqlite3 *db, With *p){
  With *pRet = 0;
  if( p ){
    sqlite3_int64 nByte = sizeof(*p) + sizeof(p->a[0]) * (p->nCte-1);
    pRet = sqlite3DbMallocZero(db, nByte);
    if( pRet ){
      int i;
      pRet->nCte = p->nCte;
      for(i=0; i<p->nCte; i++){
        pRet->a[i].pSelect = sqlite3SelectDup(db, p->a[i].pSelect, 0);
        pRet->a[i].pCols = sqlite3ExprListDup(db, p->a[i].pCols, 0);
        pRet->a[i].zName = sqlite3DbStrDup(db, p->a[i].zName);
      }
    }
  }
  return pRet;
}
# 98851 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int gatherSelectWindowsCallback(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==167 && (((pExpr)->flags&(0x1000000))!=0) ){
    Select *pSelect = pWalker->u.pSelect;
    Window *pWin = pExpr->y.pWin;
    ((void)0);
    ((void)0);
    ((void)0);
    sqlite3WindowLink(pSelect, pWin);
  }
  return 0;
}
static int gatherSelectWindowsSelectCallback(Walker *pWalker, Select *p){
  return p==pWalker->u.pSelect ? 0 : 1;
}
static void gatherSelectWindows(Select *p){
  Walker w;
  w.xExprCallback = gatherSelectWindowsCallback;
  w.xSelectCallback = gatherSelectWindowsSelectCallback;
  w.xSelectCallback2 = 0;
  w.pParse = 0;
  w.u.pSelect = p;
  sqlite3WalkSelect(&w, p);
}
# 98894 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){
  ((void)0);
  return p ? exprDup(db, p, flags, 0) : 0;
}
static ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){
  ExprList *pNew;
  struct ExprList_item *pItem, *pOldItem;
  int i;
  Expr *pPriorSelectCol = 0;
  ((void)0);
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRawNN(db, sqlite3DbMallocSize(db, p));
  if( pNew==0 ) return 0;
  pNew->nExpr = p->nExpr;
  pItem = pNew->a;
  pOldItem = p->a;
  for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){
    Expr *pOldExpr = pOldItem->pExpr;
    Expr *pNewExpr;
    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);
    if( pOldExpr
     && pOldExpr->op==173
     && (pNewExpr = pItem->pExpr)!=0
    ){
      ((void)0);
      if( pNewExpr->iColumn==0 ){
        ((void)0);
        pPriorSelectCol = pNewExpr->pLeft = pNewExpr->pRight;
      }else{
        ((void)0);
        ((void)0);
        ((void)0);
        ((void)0);
        pNewExpr->pLeft = pPriorSelectCol;
      }
    }
    pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);
    pItem->sortFlags = pOldItem->sortFlags;
    pItem->done = 0;
    pItem->bNulls = pOldItem->bNulls;
    pItem->bSpanIsTab = pOldItem->bSpanIsTab;
    pItem->bSorterRef = pOldItem->bSorterRef;
    pItem->u = pOldItem->u;
  }
  return pNew;
}
# 98950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){
  SrcList *pNew;
  int i;
  int nByte;
  ((void)0);
  if( p==0 ) return 0;
  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);
  pNew = sqlite3DbMallocRawNN(db, nByte );
  if( pNew==0 ) return 0;
  pNew->nSrc = pNew->nAlloc = p->nSrc;
  for(i=0; i<p->nSrc; i++){
    struct SrcList_item *pNewItem = &pNew->a[i];
    struct SrcList_item *pOldItem = &p->a[i];
    Table *pTab;
    pNewItem->pSchema = pOldItem->pSchema;
    pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);
    pNewItem->fg = pOldItem->fg;
    pNewItem->iCursor = pOldItem->iCursor;
    pNewItem->addrFillSub = pOldItem->addrFillSub;
    pNewItem->regReturn = pOldItem->regReturn;
    if( pNewItem->fg.isIndexedBy ){
      pNewItem->u1.zIndexedBy = sqlite3DbStrDup(db, pOldItem->u1.zIndexedBy);
    }
    pNewItem->pIBIndex = pOldItem->pIBIndex;
    if( pNewItem->fg.isTabFunc ){
      pNewItem->u1.pFuncArg =
          sqlite3ExprListDup(db, pOldItem->u1.pFuncArg, flags);
    }
    pTab = pNewItem->pTab = pOldItem->pTab;
    if( pTab ){
      pTab->nTabRef++;
    }
    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);
    pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);
    pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);
    pNewItem->colUsed = pOldItem->colUsed;
  }
  return pNew;
}
static IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){
  IdList *pNew;
  int i;
  ((void)0);
  if( p==0 ) return 0;
  pNew = sqlite3DbMallocRawNN(db, sizeof(*pNew) );
  if( pNew==0 ) return 0;
  pNew->nId = p->nId;
  pNew->a = sqlite3DbMallocRawNN(db, p->nId*sizeof(p->a[0]) );
  if( pNew->a==0 ){
    sqlite3DbFreeNN(db, pNew);
    return 0;
  }



  for(i=0; i<p->nId; i++){
    struct IdList_item *pNewItem = &pNew->a[i];
    struct IdList_item *pOldItem = &p->a[i];
    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);
    pNewItem->idx = pOldItem->idx;
  }
  return pNew;
}
static Select *sqlite3SelectDup(sqlite3 *db, Select *pDup, int flags){
  Select *pRet = 0;
  Select *pNext = 0;
  Select **pp = &pRet;
  Select *p;

  ((void)0);
  for(p=pDup; p; p=p->pPrior){
    Select *pNew = sqlite3DbMallocRawNN(db, sizeof(*p) );
    if( pNew==0 ) break;
    pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);
    pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);
    pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);
    pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);
    pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);
    pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);
    pNew->op = p->op;
    pNew->pNext = pNext;
    pNew->pPrior = 0;
    pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);
    pNew->iLimit = 0;
    pNew->iOffset = 0;
    pNew->selFlags = p->selFlags & ~0x00020;
    pNew->addrOpenEphm[0] = -1;
    pNew->addrOpenEphm[1] = -1;
    pNew->nSelectRow = p->nSelectRow;
    pNew->pWith = withDup(db, p->pWith);

    pNew->pWin = 0;
    pNew->pWinDefn = sqlite3WindowListDup(db, p->pWinDefn);
    if( p->pWin && db->mallocFailed==0 ) gatherSelectWindows(pNew);

    pNew->selId = p->selId;
    *pp = pNew;
    pp = &pNew->pPrior;
    pNext = pNew;
  }

  return pRet;
}
# 99078 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static ExprList *sqlite3ExprListAppend(
  Parse *pParse,
  ExprList *pList,
  Expr *pExpr
){
  struct ExprList_item *pItem;
  sqlite3 *db = pParse->db;
  ((void)0);
  if( pList==0 ){
    pList = sqlite3DbMallocRawNN(db, sizeof(ExprList) );
    if( pList==0 ){
      goto no_mem;
    }
    pList->nExpr = 0;
  }else if( (pList->nExpr & (pList->nExpr-1))==0 ){
    ExprList *pNew;
    pNew = sqlite3DbRealloc(db, pList,
         sizeof(*pList)+(2*(sqlite3_int64)pList->nExpr-1)*sizeof(pList->a[0]));
    if( pNew==0 ){
      goto no_mem;
    }
    pList = pNew;
  }
  pItem = &pList->a[pList->nExpr++];
  ((void)0);
  ((void)0);
  memset(&pItem->zName,0,sizeof(*pItem)-__builtin_offsetof(struct ExprList_item,zName));
  pItem->pExpr = pExpr;
  return pList;

no_mem:

  sqlite3ExprDelete(db, pExpr);
  sqlite3ExprListDelete(db, pList);
  return 0;
}
# 99126 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static ExprList *sqlite3ExprListAppendVector(
  Parse *pParse,
  ExprList *pList,
  IdList *pColumns,
  Expr *pExpr
){
  sqlite3 *db = pParse->db;
  int n;
  int i;
  int iFirst = pList ? pList->nExpr : 0;


  if( (pColumns==0) ) goto vector_append_error;
  if( pExpr==0 ) goto vector_append_error;






  if( pExpr->op!=134 && pColumns->nId!=(n=sqlite3ExprVectorSize(pExpr)) ){
    sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
                    pColumns->nId, n);
    goto vector_append_error;
  }

  for(i=0; i<pColumns->nId; i++){
    Expr *pSubExpr = sqlite3ExprForVectorField(pParse, pExpr, i);
    ((void)0);
    ((void)0);
    if( pSubExpr==0 ) continue;
    pSubExpr->iTable = pColumns->nId;
    pList = sqlite3ExprListAppend(pParse, pList, pSubExpr);
    if( pList ){
      ((void)0);
      pList->a[pList->nExpr-1].zName = pColumns->a[i].zName;
      pColumns->a[i].zName = 0;
    }
  }

  if( !db->mallocFailed && pExpr->op==134 && (pList!=0) ){
    Expr *pFirst = pList->a[iFirst].pExpr;
    ((void)0);
    ((void)0);



    pFirst->pRight = pExpr;
    pExpr = 0;



    pFirst->iTable = pColumns->nId;
  }

vector_append_error:
  sqlite3ExprUnmapAndDelete(pParse, pExpr);
  sqlite3IdListDelete(db, pColumns);
  return pList;
}




static void sqlite3ExprListSetSortOrder(ExprList *p, int iSortOrder, int eNulls){
  struct ExprList_item *pItem;
  if( p==0 ) return;
  ((void)0);

  ((void)0);
  ((void)0)


   ;
  ((void)0)


   ;

  pItem = &p->a[p->nExpr-1];
  ((void)0);
  if( iSortOrder==-1 ){
    iSortOrder = 0;
  }
  pItem->sortFlags = (u8)iSortOrder;

  if( eNulls!=-1 ){
    pItem->bNulls = 1;
    if( iSortOrder!=eNulls ){
      pItem->sortFlags |= 0x02;
    }
  }
}
# 99228 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprListSetName(
  Parse *pParse,
  ExprList *pList,
  Token *pName,
  int dequote
){
  ((void)0);
  if( pList ){
    struct ExprList_item *pItem;
    ((void)0);
    pItem = &pList->a[pList->nExpr-1];
    ((void)0);
    pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);
    if( dequote ) sqlite3Dequote(pItem->zName);
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameTokenMap(pParse, (void*)pItem->zName, pName);
    }
  }
}
# 99256 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprListSetSpan(
  Parse *pParse,
  ExprList *pList,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  ((void)0);
  if( pList ){
    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];
    ((void)0);
    sqlite3DbFree(db, pItem->zSpan);
    pItem->zSpan = sqlite3DbSpanDup(db, zStart, zEnd);
  }
}





static void sqlite3ExprListCheckLength(
  Parse *pParse,
  ExprList *pEList,
  const char *zObject
){
  int mx = pParse->db->aLimit[2];
  ;
  ;
  if( pEList && pEList->nExpr>mx ){
    sqlite3ErrorMsg(pParse, "too many columns in %s", zObject);
  }
}




static __attribute__((noinline)) void exprListDeleteNN(sqlite3 *db, ExprList *pList){
  int i = pList->nExpr;
  struct ExprList_item *pItem = pList->a;
  ((void)0);
  do{
    sqlite3ExprDelete(db, pItem->pExpr);
    sqlite3DbFree(db, pItem->zName);
    sqlite3DbFree(db, pItem->zSpan);
    pItem++;
  }while( --i>0 );
  sqlite3DbFreeNN(db, pList);
}
static void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){
  if( pList ) exprListDeleteNN(db, pList);
}





static u32 sqlite3ExprListFlags(const ExprList *pList){
  int i;
  u32 m = 0;
  ((void)0);
  for(i=0; i<pList->nExpr; i++){
     Expr *pExpr = pList->a[i].pExpr;
     ((void)0);
     m |= pExpr->flags;
  }
  return m;
}
# 99331 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3SelectWalkFail(Walker *pWalker, Select *NotUsed){
  (void)(NotUsed);
  pWalker->eCode = 0;
  return 2;
}






static int sqlite3ExprIdToTrueFalse(Expr *pExpr){
  ((void)0);
  if( !(((pExpr)->flags&(0x4000000))!=0)
   && (sqlite3StrICmp(pExpr->u.zToken, "true")==0
       || sqlite3StrICmp(pExpr->u.zToken, "false")==0)
  ){
    pExpr->op = 165;
    (pExpr)->flags|=(pExpr->u.zToken[4]==0 ? 0x10000000 : 0x20000000);
    return 1;
  }
  return 0;
}





static int sqlite3ExprTruthValue(const Expr *pExpr){
  pExpr = sqlite3ExprSkipCollate((Expr*)pExpr);
  ((void)0);
  ((void)0)
                                                      ;
  return pExpr->u.zToken[4]==0;
}
# 99380 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3ExprSimplifiedAndOr(Expr *pExpr){
  ((void)0);
  if( pExpr->op==44 || pExpr->op==43 ){
    Expr *pRight = sqlite3ExprSimplifiedAndOr(pExpr->pRight);
    Expr *pLeft = sqlite3ExprSimplifiedAndOr(pExpr->pLeft);
    if( (((pLeft)->flags&(0x000001|0x10000000))==0x10000000) || (((pRight)->flags&(0x000001|0x20000000))==0x20000000) ){
      pExpr = pExpr->op==44 ? pRight : pLeft;
    }else if( (((pRight)->flags&(0x000001|0x10000000))==0x10000000) || (((pLeft)->flags&(0x000001|0x20000000))==0x20000000) ){
      pExpr = pExpr->op==44 ? pLeft : pRight;
    }
  }
  return pExpr;
}
# 99420 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){




  if( pWalker->eCode==2 && (((pExpr)->flags&(0x000001))!=0) ){
    pWalker->eCode = 0;
    return 2;
  }

  switch( pExpr->op ){



    case 167:
      if( pWalker->eCode>=4 || (((pExpr)->flags&(0x080000))!=0) ){
        return 0;
      }else{
        pWalker->eCode = 0;
        return 2;
      }
    case 59:


      if( sqlite3ExprIdToTrueFalse(pExpr) ){
        return 1;
      }

    case 162:
    case 163:
    case 164:
      ;
      ;
      ;
      ;
      if( (((pExpr)->flags&(0x000008))!=0) && pWalker->eCode!=2 ){
        return 0;
      }
      if( pWalker->eCode==3 && pExpr->iTable==pWalker->u.iCur ){
        return 0;
      }

    case 174:
    case 171:
      ;
      ;
      pWalker->eCode = 0;
      return 2;
    case 151:
      if( pWalker->eCode==5 ){



        pExpr->op = 117;
      }else if( pWalker->eCode==4 ){


        pWalker->eCode = 0;
        return 2;
      }

    default:
      ;
      ;
      return 0;
  }
}
static int exprIsConst(Expr *p, int initFlag, int iCur){
  Walker w;
  w.eCode = initFlag;
  w.xExprCallback = exprNodeIsConstant;
  w.xSelectCallback = sqlite3SelectWalkFail;



  w.u.iCur = iCur;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 99508 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprIsConstant(Expr *p){
  return exprIsConst(p, 1, 0);
}
# 99525 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprIsConstantNotJoin(Expr *p){
  return exprIsConst(p, 2, 0);
}







static int sqlite3ExprIsTableConstant(Expr *p, int iCur){
  return exprIsConst(p, 3, iCur);
}





static int exprNodeIsConstantOrGroupBy(Walker *pWalker, Expr *pExpr){
  ExprList *pGroupBy = pWalker->u.pGroupBy;
  int i;



  for(i=0; i<pGroupBy->nExpr; i++){
    Expr *p = pGroupBy->a[i].pExpr;
    if( sqlite3ExprCompare(0, pExpr, p, -1)<2 ){
      CollSeq *pColl = sqlite3ExprNNCollSeq(pWalker->pParse, p);
      if( sqlite3IsBinary(pColl) ){
        return 1;
      }
    }
  }


  if( (((pExpr)->flags&(0x000800))!=0) ){
    pWalker->eCode = 0;
    return 2;
  }

  return exprNodeIsConstant(pWalker, pExpr);
}
# 99587 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprIsConstantOrGroupBy(Parse *pParse, Expr *p, ExprList *pGroupBy){
  Walker w;
  w.eCode = 1;
  w.xExprCallback = exprNodeIsConstantOrGroupBy;
  w.xSelectCallback = 0;
  w.u.pGroupBy = pGroupBy;
  w.pParse = pParse;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 99607 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprIsConstantOrFunction(Expr *p, u8 isInit){
  ((void)0);
  return exprIsConst(p, 4+isInit, 0);
}
# 99636 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprIsInteger(Expr *p, int *pValue){
  int rc = 0;
  if( (p==0) ) return 0;



  ((void)0)
                                                    ;

  if( p->flags & 0x000400 ){
    *pValue = p->u.iValue;
    return 1;
  }
  switch( p->op ){
    case 169: {
      rc = sqlite3ExprIsInteger(p->pLeft, pValue);
      break;
    }
    case 168: {
      int v;
      if( sqlite3ExprIsInteger(p->pLeft, &v) ){
        ((void)0);
        *pValue = -v;
        rc = 1;
      }
      break;
    }
    default: break;
  }
  return rc;
}
# 99682 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCanBeNull(const Expr *p){
  u8 op;
  while( p->op==169 || p->op==168 ){
    p = p->pLeft;
  }
  op = p->op;
  if( op==171 ) op = p->op2;
  switch( op ){
    case 150:
    case 113:
    case 148:
    case 149:
      return 0;
    case 162:
      return (((p)->flags&(0x100000))!=0) ||
             p->y.pTab==0 ||
             (p->iColumn>=0 && p->y.pTab->aCol[p->iColumn].notNull==0);
    default:
      return 1;
  }
}
# 99714 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){
  u8 op;
  int unaryMinus = 0;
  if( aff==0x41 ) return 1;
  while( p->op==169 || p->op==168 ){
    if( p->op==168 ) unaryMinus = 1;
    p = p->pLeft;
  }
  op = p->op;
  if( op==171 ) op = p->op2;
  switch( op ){
    case 150: {
      return aff>=0x43;
    }
    case 148: {
      return aff>=0x43;
    }
    case 113: {
      return !unaryMinus && aff==0x42;
    }
    case 149: {
      return !unaryMinus;
    }
    case 162: {
      ((void)0);
      return aff>=0x43 && p->iColumn<0;
    }
    default: {
      return 0;
    }
  }
}




static int sqlite3IsRowid(const char *z){
  if( sqlite3StrICmp(z, "_ROWID_")==0 ) return 1;
  if( sqlite3StrICmp(z, "ROWID")==0 ) return 1;
  if( sqlite3StrICmp(z, "OID")==0 ) return 1;
  return 0;
}
# 99765 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Select *isCandidateForInOpt(Expr *pX){
  Select *p;
  SrcList *pSrc;
  ExprList *pEList;
  Table *pTab;
  int i;
  if( !(((pX)->flags&(0x000800))!=0) ) return 0;
  if( (((pX)->flags&(0x000020))!=0) ) return 0;
  p = pX->x.pSelect;
  if( p->pPrior ) return 0;
  if( p->selFlags & (0x00001|0x00008) ){
    ;
    ;
    return 0;
  }
  ((void)0);
  if( p->pLimit ) return 0;
  if( p->pWhere ) return 0;
  pSrc = p->pSrc;
  ((void)0);
  if( pSrc->nSrc!=1 ) return 0;
  if( pSrc->a[0].pSelect ) return 0;
  pTab = pSrc->a[0].pTab;
  ((void)0);
  ((void)0);
  if( ((pTab)->nModuleArg) ) return 0;
  pEList = p->pEList;
  ((void)0);

  for(i=0; i<pEList->nExpr; i++){
    Expr *pRes = pEList->a[i].pExpr;
    if( pRes->op!=162 ) return 0;
    ((void)0);
  }
  return p;
}
# 99810 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SetHasNullFlag(Vdbe *v, int iCur, int regHasNull){
  int addr1;
  sqlite3VdbeAddOp2(v, 70, 0, regHasNull);
  addr1 = sqlite3VdbeAddOp1(v, 36, iCur); ;
  sqlite3VdbeAddOp3(v, 90, iCur, 0, regHasNull);
  sqlite3VdbeChangeP5(v, 0x80);
  ;
  sqlite3VdbeJumpHere(v, addr1);
}
# 99827 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3InRhsIsConstant(Expr *pIn){
  Expr *pLHS;
  int res;
  ((void)0);
  pLHS = pIn->pLeft;
  pIn->pLeft = 0;
  res = sqlite3ExprIsConstant(pIn);
  pIn->pLeft = pLHS;
  return res;
}
# 99920 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3FindInIndex(
  Parse *pParse,
  Expr *pX,
  u32 inFlags,
  int *prRhsHasNull,
  int *aiMap,
  int *piTab
){
  Select *p;
  int eType = 0;
  int iTab = pParse->nTab++;
  int mustBeUnique;
  Vdbe *v = sqlite3GetVdbe(pParse);

  ((void)0);
  mustBeUnique = (inFlags & 0x0004)!=0;






  if( prRhsHasNull && (pX->flags & 0x000800) ){
    int i;
    ExprList *pEList = pX->x.pSelect->pEList;
    for(i=0; i<pEList->nExpr; i++){
      if( sqlite3ExprCanBeNull(pEList->a[i].pExpr) ) break;
    }
    if( i==pEList->nExpr ){
      prRhsHasNull = 0;
    }
  }




  if( pParse->nErr==0 && (p = isCandidateForInOpt(pX))!=0 ){
    sqlite3 *db = pParse->db;
    Table *pTab;
    i16 iDb;
    ExprList *pEList = p->pEList;
    int nExpr = pEList->nExpr;

    ((void)0);
    ((void)0);
    ((void)0);
    pTab = p->pSrc->a[0].pTab;


    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    sqlite3CodeVerifySchema(pParse, iDb);
    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);

    ((void)0);
    if( nExpr==1 && pEList->a[0].pExpr->iColumn<0 ){

      int iAddr = sqlite3VdbeAddOp0(v, 17);
      ;

      sqlite3OpenTable(pParse, iTab, iDb, pTab, 97);
      eType = 1;
      sqlite3VdbeExplain (pParse, 0, "USING ROWID SEARCH ON TABLE %s FOR IN-OPERATOR",pTab->zName)
                                                                          ;
      sqlite3VdbeJumpHere(v, iAddr);
    }else{
      Index *pIdx;
      int affinity_ok = 1;
      int i;





      for(i=0; i<nExpr && affinity_ok; i++){
        Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
        int iCol = pEList->a[i].pExpr->iColumn;
        char idxaff = sqlite3TableColumnAffinity(pTab,iCol);
        char cmpaff = sqlite3CompareAffinity(pLhs, idxaff);
        ;
        ;
        switch( cmpaff ){
          case 0x41:
            break;
          case 0x42:




            ((void)0);
            break;
          default:
            affinity_ok = ((idxaff)>=0x43);
        }
      }

      if( affinity_ok ){

        for(pIdx=pTab->pIndex; pIdx && eType==0; pIdx=pIdx->pNext){
          Bitmask colUsed;
          Bitmask mCol;
          if( pIdx->nColumn<nExpr ) continue;
          if( pIdx->pPartIdxWhere!=0 ) continue;


          ;
          ;
          if( pIdx->nColumn>=((int)(sizeof(Bitmask)*8))-1 ) continue;
          if( mustBeUnique ){
            if( pIdx->nKeyCol>nExpr
             ||(pIdx->nColumn>nExpr && !((pIdx)->onError!=0))
            ){
              continue;
            }
          }

          colUsed = 0;
          for(i=0; i<nExpr; i++){
            Expr *pLhs = sqlite3VectorFieldSubexpr(pX->pLeft, i);
            Expr *pRhs = pEList->a[i].pExpr;
            CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
            int j;

            ((void)0);
            for(j=0; j<nExpr; j++){
              if( pIdx->aiColumn[j]!=pRhs->iColumn ) continue;
              ((void)0);
              if( pReq!=0 && sqlite3StrICmp(pReq->zName, pIdx->azColl[j])!=0 ){
                continue;
              }
              break;
            }
            if( j==nExpr ) break;
            mCol = (((Bitmask)1)<<(j));
            if( mCol & colUsed ) break;
            colUsed |= mCol;
            if( aiMap ) aiMap[i] = j;
          }

          ((void)0);
          if( colUsed==((((Bitmask)1)<<(nExpr))-1) ){

            int iAddr = sqlite3VdbeAddOp0(v, 17); ;
            sqlite3VdbeExplain (pParse, 0, "USING INDEX %s FOR IN-OPERATOR",pIdx->zName)
                                                                            ;
            sqlite3VdbeAddOp3(v, 97, iTab, pIdx->tnum, iDb);
            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
            ;
            ((void)0);
            eType = 3 + pIdx->aSortOrder[0];

            if( prRhsHasNull ){





              *prRhsHasNull = ++pParse->nMem;
              if( nExpr==1 ){
                sqlite3SetHasNullFlag(v, iTab, *prRhsHasNull);
              }
            }
            sqlite3VdbeJumpHere(v, iAddr);
          }
        }
      }
    }
  }
# 100095 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( eType==0
   && (inFlags & 0x0001)
   && !(((pX)->flags&(0x000800))!=0)
   && (!sqlite3InRhsIsConstant(pX) || pX->x.pList->nExpr<=2)
  ){
    eType = 5;
  }

  if( eType==0 ){



    u32 savedNQueryLoop = pParse->nQueryLoop;
    int rMayHaveNull = 0;
    eType = 2;
    if( inFlags & 0x0004 ){
      pParse->nQueryLoop = 0;
    }else if( prRhsHasNull ){
      *prRhsHasNull = rMayHaveNull = ++pParse->nMem;
    }
    ((void)0);
    sqlite3CodeRhsOfIN(pParse, pX, iTab);
    if( rMayHaveNull ){
      sqlite3SetHasNullFlag(v, iTab, rMayHaveNull);
    }
    pParse->nQueryLoop = savedNQueryLoop;
  }

  if( aiMap && eType!=3 && eType!=4 ){
    int i, n;
    n = sqlite3ExprVectorSize(pX->pLeft);
    for(i=0; i<n; i++) aiMap[i] = i;
  }
  *piTab = iTab;
  return eType;
}
# 100142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *exprINAffinity(Parse *pParse, Expr *pExpr){
  Expr *pLeft = pExpr->pLeft;
  int nVal = sqlite3ExprVectorSize(pLeft);
  Select *pSelect = (pExpr->flags & 0x000800) ? pExpr->x.pSelect : 0;
  char *zRet;

  ((void)0);
  zRet = sqlite3DbMallocRaw(pParse->db, nVal+1);
  if( zRet ){
    int i;
    for(i=0; i<nVal; i++){
      Expr *pA = sqlite3VectorFieldSubexpr(pLeft, i);
      char a = sqlite3ExprAffinity(pA);
      if( pSelect ){
        zRet[i] = sqlite3CompareAffinity(pSelect->pEList->a[i].pExpr, a);
      }else{
        zRet[i] = a;
      }
    }
    zRet[nVal] = '\0';
  }
  return zRet;
}
# 100174 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SubselectError(Parse *pParse, int nActual, int nExpect){
  const char *zFmt = "sub-select returns %d columns - expected %d";
  sqlite3ErrorMsg(pParse, zFmt, nActual, nExpect);
}
# 100191 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VectorErrorMsg(Parse *pParse, Expr *pExpr){

  if( pExpr->flags & 0x000800 ){
    sqlite3SubselectError(pParse, pExpr->x.pSelect->pEList->nExpr, 1);
  }else

  {
    sqlite3ErrorMsg(pParse, "row value misused");
  }
}
# 100225 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3CodeRhsOfIN(
  Parse *pParse,
  Expr *pExpr,
  int iTab
){
  int addrOnce = 0;
  int addr;
  Expr *pLeft;
  KeyInfo *pKeyInfo = 0;
  int nVal;
  Vdbe *v;

  v = pParse->pVdbe;
  ((void)0);
# 100250 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( !(((pExpr)->flags&(0x000020))!=0) && pParse->iSelfTab==0 ){




    if( (((pExpr)->flags&(0x2000000))!=0) ){
      addrOnce = sqlite3VdbeAddOp0(v, 17); ;
      if( (((pExpr)->flags&(0x000800))!=0) ){
        sqlite3VdbeExplain (pParse, 0, "REUSE LIST SUBQUERY %d", pExpr->x.pSelect->selId)
                                       ;
      }
      sqlite3VdbeAddOp2(v, 12, pExpr->y.sub.regReturn,
                        pExpr->y.sub.iAddr);
      sqlite3VdbeAddOp2(v, 109, iTab, pExpr->iTable);
      sqlite3VdbeJumpHere(v, addrOnce);
      return;
    }


    (pExpr)->flags|=(0x2000000);
    pExpr->y.sub.regReturn = ++pParse->nMem;
    pExpr->y.sub.iAddr =
      sqlite3VdbeAddOp2(v, 70, 0, pExpr->y.sub.regReturn) + 1;
    ;

    addrOnce = sqlite3VdbeAddOp0(v, 17); ;
  }


  pLeft = pExpr->pLeft;
  nVal = sqlite3ExprVectorSize(pLeft);




  pExpr->iTable = iTab;
  addr = sqlite3VdbeAddOp2(v, 112, pExpr->iTable, nVal);







  pKeyInfo = sqlite3KeyInfoAlloc(pParse->db, nVal, 1);

  if( (((pExpr)->flags&(0x000800))!=0) ){





    Select *pSelect = pExpr->x.pSelect;
    ExprList *pEList = pSelect->pEList;

    sqlite3VdbeExplain (pParse, 1, "%sLIST SUBQUERY %d", addrOnce?"":"CORRELATED ", pSelect->selId )

      ;


    if( (pEList->nExpr==nVal) ){
      SelectDest dest;
      int i;
      sqlite3SelectDestInit(&dest, 11, iTab);
      dest.zAffSdst = exprINAffinity(pParse, pExpr);
      pSelect->iLimit = 0;
      ;
      ;
      if( sqlite3Select(pParse, pSelect, &dest) ){
        sqlite3DbFree(pParse->db, dest.zAffSdst);
        sqlite3KeyInfoUnref(pKeyInfo);
        return;
      }
      sqlite3DbFree(pParse->db, dest.zAffSdst);
      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);
      for(i=0; i<nVal; i++){
        Expr *p = sqlite3VectorFieldSubexpr(pLeft, i);
        pKeyInfo->aColl[i] = sqlite3BinaryCompareCollSeq(
            pParse, p, pEList->a[i].pExpr
        );
      }
    }
  }else if( (pExpr->x.pList!=0) ){







    char affinity;
    int i;
    ExprList *pList = pExpr->x.pList;
    struct ExprList_item *pItem;
    int r1, r2;
    affinity = sqlite3ExprAffinity(pLeft);
    if( affinity<=0x40 ){
      affinity = 0x41;
    }
    if( pKeyInfo ){
      ((void)0);
      pKeyInfo->aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    }


    r1 = sqlite3GetTempReg(pParse);
    r2 = sqlite3GetTempReg(pParse);
    for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){
      Expr *pE2 = pItem->pExpr;






      if( addrOnce && !sqlite3ExprIsConstant(pE2) ){
        sqlite3VdbeChangeToNoop(v, addrOnce);
        (pExpr)->flags&=~(0x2000000);
        addrOnce = 0;
      }


      sqlite3ExprCode(pParse, pE2, r1);
      sqlite3VdbeAddOp4(v, 92, r1, 1, r2, &affinity, 1);
      sqlite3VdbeAddOp4Int(v, 132, iTab, r2, r1, 1);
    }
    sqlite3ReleaseTempReg(pParse, r1);
    sqlite3ReleaseTempReg(pParse, r2);
  }
  if( pKeyInfo ){
    sqlite3VdbeChangeP4(v, addr, (void *)pKeyInfo, (-9));
  }
  if( addrOnce ){
    sqlite3VdbeJumpHere(v, addrOnce);

    sqlite3VdbeAddOp1(v, 66, pExpr->y.sub.regReturn);
    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);
    sqlite3ClearTempRegCache(pParse);
  }
}
# 100410 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3CodeSubselect(Parse *pParse, Expr *pExpr){
  int addrOnce = 0;
  int rReg = 0;
  Select *pSel;
  SelectDest dest;
  int nReg;
  Expr *pLimit;

  Vdbe *v = pParse->pVdbe;
  ((void)0);
  ;
  ;
  ((void)0);
  ((void)0);
  pSel = pExpr->x.pSelect;
# 100436 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( !(((pExpr)->flags&(0x000020))!=0) ){


    if( (((pExpr)->flags&(0x2000000))!=0) ){
      sqlite3VdbeExplain (pParse, 0, "REUSE SUBQUERY %d", pSel->selId);
      sqlite3VdbeAddOp2(v, 12, pExpr->y.sub.regReturn,
                        pExpr->y.sub.iAddr);
      return pExpr->iTable;
    }


    (pExpr)->flags|=(0x2000000);
    pExpr->y.sub.regReturn = ++pParse->nMem;
    pExpr->y.sub.iAddr =
      sqlite3VdbeAddOp2(v, 70, 0, pExpr->y.sub.regReturn) + 1;
    ;

    addrOnce = sqlite3VdbeAddOp0(v, 17); ;
  }
# 100466 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3VdbeExplain (pParse, 1, "%sSCALAR SUBQUERY %d", addrOnce?"":"CORRELATED ", pSel->selId)
                                                ;
  nReg = pExpr->op==134 ? pSel->pEList->nExpr : 1;
  sqlite3SelectDestInit(&dest, 0, pParse->nMem+1);
  pParse->nMem += nReg;
  if( pExpr->op==134 ){
    dest.eDest = 10;
    dest.iSdst = dest.iSDParm;
    dest.nSdst = nReg;
    sqlite3VdbeAddOp3(v, 73, 0, dest.iSDParm, dest.iSDParm+nReg-1);
    ;
  }else{
    dest.eDest = 3;
    sqlite3VdbeAddOp2(v, 70, 0, dest.iSDParm);
    ;
  }
  if( pSel->pLimit ){


    sqlite3 *db = pParse->db;
    pLimit = sqlite3Expr(db, 150, "0");
    if( pLimit ){
      pLimit->affExpr = 0x43;
      pLimit = sqlite3PExpr(pParse, 52,
                            sqlite3ExprDup(db, pSel->pLimit->pLeft, 0), pLimit);
    }
    sqlite3ExprDelete(db, pSel->pLimit->pLeft);
    pSel->pLimit->pLeft = pLimit;
  }else{

    pLimit = sqlite3Expr(pParse->db, 150, "1");
    pSel->pLimit = sqlite3PExpr(pParse, 144, pLimit, 0);
  }
  pSel->iLimit = 0;
  if( sqlite3Select(pParse, pSel, &dest) ){
    return 0;
  }
  pExpr->iTable = rReg = dest.iSDParm;
  ;
  if( addrOnce ){
    sqlite3VdbeJumpHere(v, addrOnce);


    sqlite3VdbeAddOp1(v, 66, pExpr->y.sub.regReturn);
    sqlite3VdbeChangeP1(v, pExpr->y.sub.iAddr-1, sqlite3VdbeCurrentAddr(v)-1);
    sqlite3ClearTempRegCache(pParse);
  }

  return rReg;
}
# 100525 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCheckIN(Parse *pParse, Expr *pIn){
  int nVector = sqlite3ExprVectorSize(pIn->pLeft);
  if( (pIn->flags & 0x000800) ){
    if( nVector!=pIn->x.pSelect->pEList->nExpr ){
      sqlite3SubselectError(pParse, pIn->x.pSelect->pEList->nExpr, nVector);
      return 1;
    }
  }else if( nVector!=1 ){
    sqlite3VectorErrorMsg(pParse, pIn->pLeft);
    return 1;
  }
  return 0;
}
# 100566 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprCodeIN(
  Parse *pParse,
  Expr *pExpr,
  int destIfFalse,
  int destIfNull
){
  int rRhsHasNull = 0;
  int eType;
  int rLhs;
  int rLhsOrig;
  Vdbe *v;
  int *aiMap = 0;
  char *zAff = 0;
  int nVector;
  int iDummy;
  Expr *pLeft;
  int i;
  int destStep2;
  int destStep6 = 0;
  int addrTruthOp;
  int destNotNull;
  int addrTop;
  int iTab = 0;

  pLeft = pExpr->pLeft;
  if( sqlite3ExprCheckIN(pParse, pExpr) ) return;
  zAff = exprINAffinity(pParse, pExpr);
  nVector = sqlite3ExprVectorSize(pExpr->pLeft);
  aiMap = (int*)sqlite3DbMallocZero(
      pParse->db, nVector*(sizeof(int) + sizeof(char)) + 1
  );
  if( pParse->db->mallocFailed ) goto sqlite3ExprCodeIN_oom_error;





  v = pParse->pVdbe;
  ((void)0);
  ;
  eType = sqlite3FindInIndex(pParse, pExpr,
                             0x0002 | 0x0001,
                             destIfFalse==destIfNull ? 0 : &rRhsHasNull,
                             aiMap, &iTab);

  ((void)0)

   ;
# 100633 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  rLhsOrig = exprCodeVector(pParse, pLeft, &iDummy);
  for(i=0; i<nVector && aiMap[i]==i; i++){}
  if( i==nVector ){

    rLhs = rLhsOrig;
  }else{

    rLhs = sqlite3GetTempRange(pParse, nVector);
    for(i=0; i<nVector; i++){
      sqlite3VdbeAddOp3(v, 78, rLhsOrig+i, rLhs+aiMap[i], 0);
    }
  }







  if( eType==5 ){
    ExprList *pList = pExpr->x.pList;
    CollSeq *pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);
    int labelOk = sqlite3VdbeMakeLabel(pParse);
    int r2, regToFree;
    int regCkNull = 0;
    int ii;
    int bLhsReal;
    ((void)0);
    if( destIfNull!=destIfFalse ){
      regCkNull = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 99, rLhs, rLhs, regCkNull);
    }
    bLhsReal = sqlite3ExprAffinity(pExpr->pLeft)==0x45;
    for(ii=0; ii<pList->nExpr; ii++){
      if( bLhsReal ){
        r2 = regToFree = sqlite3GetTempReg(pParse);
        sqlite3ExprCode(pParse, pList->a[ii].pExpr, r2);
        sqlite3VdbeAddOp4(v, 91, r2, 1, 0, "E", (-1));
      }else{
        r2 = sqlite3ExprCodeTemp(pParse, pList->a[ii].pExpr, &regToFree);
      }
      if( regCkNull && sqlite3ExprCanBeNull(pList->a[ii].pExpr) ){
        sqlite3VdbeAddOp3(v, 99, regCkNull, r2, regCkNull);
      }
      if( ii<pList->nExpr-1 || destIfNull!=destIfFalse ){
        sqlite3VdbeAddOp4(v, 53, rLhs, labelOk, r2,
                          (void*)pColl, (-2));
        ;
        ;
        sqlite3VdbeChangeP5(v, zAff[0]);
      }else{
        ((void)0);
        sqlite3VdbeAddOp4(v, 52, rLhs, destIfFalse, r2,
                          (void*)pColl, (-2)); ;
        sqlite3VdbeChangeP5(v, zAff[0] | 0x10);
      }
      sqlite3ReleaseTempReg(pParse, regToFree);
    }
    if( regCkNull ){
      sqlite3VdbeAddOp2(v, 50, regCkNull, destIfNull); ;
      sqlite3VdbeGoto(v, destIfFalse);
    }
    sqlite3VdbeResolveLabel(v, labelOk);
    sqlite3ReleaseTempReg(pParse, regCkNull);
    goto sqlite3ExprCodeIN_finished;
  }





  if( destIfNull==destIfFalse ){
    destStep2 = destIfFalse;
  }else{
    destStep2 = destStep6 = sqlite3VdbeMakeLabel(pParse);
  }
  for(i=0; i<nVector; i++){
    Expr *p = sqlite3VectorFieldSubexpr(pExpr->pLeft, i);
    if( sqlite3ExprCanBeNull(p) ){
      sqlite3VdbeAddOp2(v, 50, rLhs+i, destStep2);
      ;
    }
  }





  if( eType==1 ){



    sqlite3VdbeAddOp3(v, 30, iTab, destIfFalse, rLhs);
    ;
    addrTruthOp = sqlite3VdbeAddOp0(v, 11);
  }else{
    sqlite3VdbeAddOp4(v, 91, rLhs, nVector, 0, zAff, nVector);
    if( destIfFalse==destIfNull ){

      sqlite3VdbeAddOp4Int(v, 28, iTab, destIfFalse,
                           rLhs, nVector); ;
      goto sqlite3ExprCodeIN_finished;
    }

    addrTruthOp = sqlite3VdbeAddOp4Int(v, 29, iTab, 0,
                                      rLhs, nVector); ;
  }




  if( rRhsHasNull && nVector==1 ){
    sqlite3VdbeAddOp2(v, 51, rRhsHasNull, destIfFalse);
    ;
  }




  if( destIfFalse==destIfNull ) sqlite3VdbeGoto(v, destIfFalse);
# 100761 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( destStep6 ) sqlite3VdbeResolveLabel(v, destStep6);
  addrTop = sqlite3VdbeAddOp2(v, 36, iTab, destIfFalse);
  ;
  if( nVector>1 ){
    destNotNull = sqlite3VdbeMakeLabel(pParse);
  }else{


    destNotNull = destIfFalse;
  }
  for(i=0; i<nVector; i++){
    Expr *p;
    CollSeq *pColl;
    int r3 = sqlite3GetTempReg(pParse);
    p = sqlite3VectorFieldSubexpr(pLeft, i);
    pColl = sqlite3ExprCollSeq(pParse, p);
    sqlite3VdbeAddOp3(v, 90, iTab, i, r3);
    sqlite3VdbeAddOp4(v, 52, rLhs+i, destNotNull, r3,
                      (void*)pColl, (-2));
    ;
    sqlite3ReleaseTempReg(pParse, r3);
  }
  sqlite3VdbeAddOp2(v, 11, 0, destIfNull);
  if( nVector>1 ){
    sqlite3VdbeResolveLabel(v, destNotNull);
    sqlite3VdbeAddOp2(v, 5, iTab, addrTop+1);
    ;



    sqlite3VdbeAddOp2(v, 11, 0, destIfFalse);
  }


  sqlite3VdbeJumpHere(v, addrTruthOp);

sqlite3ExprCodeIN_finished:
  if( rLhs!=rLhsOrig ) sqlite3ReleaseTempReg(pParse, rLhs);
  ;
sqlite3ExprCodeIN_oom_error:
  sqlite3DbFree(pParse->db, aiMap);
  sqlite3DbFree(pParse->db, zAff);
}
# 100815 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){
  if( (z!=0) ){
    double value;
    sqlite3AtoF(z, &value, sqlite3Strlen30(z), 1);
    ((void)0);
    if( negateFlag ) value = -value;
    sqlite3VdbeAddOp4Dup8(v, 148, 0, iMem, 0, (u8*)&value, (-13));
  }
}
# 100833 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){
  Vdbe *v = pParse->pVdbe;
  if( pExpr->flags & 0x000400 ){
    int i = pExpr->u.iValue;
    ((void)0);
    if( negFlag ) i = -i;
    sqlite3VdbeAddOp2(v, 70, i, iMem);
  }else{
    int c;
    i64 value;
    const char *z = pExpr->u.zToken;
    ((void)0);
    c = sqlite3DecOrHexToI64(z, &value);
    if( (c==3 && !negFlag) || (c==2) || (negFlag && value==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))))){




      if( sqlite3_strnicmp(z,"0x",2)==0 ){
        sqlite3ErrorMsg(pParse, "hex literal too big: %s%s", negFlag?"-":"",z);
      }else

      {
        codeReal(v, z, negFlag, iMem);
      }

    }else{
      if( negFlag ){ value = c==3 ? (((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) : -value; }
      sqlite3VdbeAddOp4Dup8(v, 71, 0, iMem, 0, (u8*)&value, (-14));
    }
  }
}





static void sqlite3ExprCodeLoadIndexColumn(
  Parse *pParse,
  Index *pIdx,
  int iTabCur,
  int iIdxCol,
  int regOut
){
  i16 iTabCol = pIdx->aiColumn[iIdxCol];
  if( iTabCol==(-2) ){
    ((void)0);
    ((void)0);
    pParse->iSelfTab = iTabCur + 1;
    sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[iIdxCol].pExpr, regOut);
    pParse->iSelfTab = 0;
  }else{
    sqlite3ExprCodeGetColumnOfTable(pParse->pVdbe, pIdx->pTable, iTabCur,
                                    iTabCol, regOut);
  }
}




static void sqlite3ExprCodeGetColumnOfTable(
  Vdbe *v,
  Table *pTab,
  int iTabCur,
  int iCol,
  int regOut
){
  if( pTab==0 ){
    sqlite3VdbeAddOp3(v, 90, iTabCur, iCol, regOut);
    return;
  }
  if( iCol<0 || iCol==pTab->iPKey ){
    sqlite3VdbeAddOp2(v, 128, iTabCur, regOut);
  }else{
    int op = ((pTab)->nModuleArg) ? 164 : 90;
    int x = iCol;
    if( !(((pTab)->tabFlags & 0x0020)==0) && !((pTab)->nModuleArg) ){
      x = sqlite3ColumnOfIndex(sqlite3PrimaryKeyIndex(pTab), iCol);
    }
    sqlite3VdbeAddOp3(v, op, iTabCur, x, regOut);
  }
  if( iCol>=0 ){
    sqlite3ColumnDefault(v, pTab, iCol, regOut);
  }
}
# 100926 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCodeGetColumn(
  Parse *pParse,
  Table *pTab,
  int iColumn,
  int iTable,
  int iReg,
  u8 p5
){
  Vdbe *v = pParse->pVdbe;
  ((void)0);
  sqlite3ExprCodeGetColumnOfTable(v, pTab, iTable, iColumn, iReg);
  if( p5 ){
    sqlite3VdbeChangeP5(v, p5);
  }
  return iReg;
}





static void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){
  ((void)0);
  sqlite3VdbeAddOp3(pParse->pVdbe, 77, iFrom, iTo, nReg);
}






static void exprToRegister(Expr *pExpr, int iReg){
  Expr *p = sqlite3ExprSkipCollateAndLikely(pExpr);
  p->op2 = p->op;
  p->op = 171;
  p->iTable = iReg;
  (p)->flags&=~(0x001000);
}
# 100975 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int exprCodeVector(Parse *pParse, Expr *p, int *piFreeable){
  int iResult;
  int nResult = sqlite3ExprVectorSize(p);
  if( nResult==1 ){
    iResult = sqlite3ExprCodeTemp(pParse, p, piFreeable);
  }else{
    *piFreeable = 0;
    if( p->op==134 ){



      iResult = sqlite3CodeSubselect(pParse, p);

    }else{
      int i;
      iResult = pParse->nMem+1;
      pParse->nMem += nResult;
      for(i=0; i<nResult; i++){
        sqlite3ExprCodeFactorable(pParse, p->x.pList->a[i].pExpr, i+iResult);
      }
    }
  }
  return iResult;
}
# 101012 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){
  Vdbe *v = pParse->pVdbe;
  int op;
  int inReg = target;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;
  Expr tempX;
  int p5 = 0;

  ((void)0);
  if( v==0 ){
    ((void)0);
    return 0;
  }

expr_code_doover:
  if( pExpr==0 ){
    op = 117;
  }else{
    op = pExpr->op;
  }
  switch( op ){
    case 164: {
      AggInfo *pAggInfo = pExpr->pAggInfo;
      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];
      if( !pAggInfo->directMode ){
        ((void)0);
        return pCol->iMem;
      }else if( pAggInfo->useSortingIdx ){
        sqlite3VdbeAddOp3(v, 90, pAggInfo->sortingIdxPTab,
                              pCol->iSorterColumn, target);
        return target;
      }

    }
    case 162: {
      int iTab = pExpr->iTable;
      if( (((pExpr)->flags&(0x000008))!=0) ){






        int iReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft,target);
        int aff = sqlite3TableColumnAffinity(pExpr->y.pTab, pExpr->iColumn);
        if( aff>0x41 ){
          static const char zAff[] = "B\000C\000D\000E";
          ((void)0);
          ((void)0);
          if( iReg!=target ){
            sqlite3VdbeAddOp2(v, 79, iReg, target);
            iReg = target;
          }
          sqlite3VdbeAddOp4(v, 91, iReg, 1, 0,
                            &zAff[(aff-'B')*2], (-1));
        }
        return iReg;
      }
      if( iTab<0 ){
        if( pParse->iSelfTab<0 ){

          ((void)0);
          ((void)0);
          ((void)0);
          if( pExpr->iColumn>=0
            && pExpr->y.pTab->aCol[pExpr->iColumn].affinity==0x45
          ){
            sqlite3VdbeAddOp2(v, 79, pExpr->iColumn - pParse->iSelfTab,
                              target);
            sqlite3VdbeAddOp1(v, 84, target);
            return target;
          }else{
            return pExpr->iColumn - pParse->iSelfTab;
          }
        }else{


          iTab = pParse->iSelfTab - 1;
        }
      }
      return sqlite3ExprCodeGetColumn(pParse, pExpr->y.pTab,
                               pExpr->iColumn, iTab, target,
                               pExpr->op2);
    }
    case 150: {
      codeInteger(pParse, pExpr, 0, target);
      return target;
    }
    case 165: {
      sqlite3VdbeAddOp2(v, 70, sqlite3ExprTruthValue(pExpr), target);
      return target;
    }

    case 148: {
      ((void)0);
      codeReal(v, pExpr->u.zToken, 0, target);
      return target;
    }

    case 113: {
      ((void)0);
      sqlite3VdbeLoadString(v, target, pExpr->u.zToken);
      return target;
    }
    case 117: {
      sqlite3VdbeAddOp2(v, 73, 0, target);
      return target;
    }

    case 149: {
      int n;
      const char *z;
      char *zBlob;
      ((void)0);
      ((void)0);
      ((void)0);
      z = &pExpr->u.zToken[2];
      n = sqlite3Strlen30(z) - 1;
      ((void)0);
      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);
      sqlite3VdbeAddOp4(v, 75, n/2, target, 0, zBlob, (-7));
      return target;
    }

    case 151: {
      ((void)0);
      ((void)0);
      ((void)0);
      sqlite3VdbeAddOp2(v, 76, pExpr->iColumn, target);
      if( pExpr->u.zToken[1]!=0 ){
        const char *z = sqlite3VListNumToName(pParse->pVList, pExpr->iColumn);
        ((void)0);
        pParse->pVList[0] = 0;
        sqlite3VdbeAppendP4(v, (char*)z, (-1));
      }
      return target;
    }
    case 171: {
      return pExpr->iTable;
    }

    case 36: {

      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
      if( inReg!=target ){
        sqlite3VdbeAddOp2(v, 79, inReg, target);
        inReg = target;
      }
      sqlite3VdbeAddOp2(v, 85, target,
                        sqlite3AffinityType(pExpr->u.zToken, 0));
      return inReg;
    }

    case 45:
    case 166:
      op = (op==45) ? 53 : 52;
      p5 = 0x80;

    case 56:
    case 55:
    case 54:
    case 57:
    case 52:
    case 53: {
      Expr *pLeft = pExpr->pLeft;
      if( sqlite3ExprIsVector(pLeft) ){
        codeVectorCompare(pParse, pExpr, target, op, p5);
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
        codeCompare(pParse, pLeft, pExpr->pRight, op,
            r1, r2, inReg, 0x20 | p5);
        ((void)0); ; ;
        ((void)0); ; ;
        ((void)0); ; ;
        ((void)0); ; ;
        ((void)0); ; ;
        ((void)0); ; ;
        ;
        ;
      }
      break;
    }
    case 44:
    case 43:
    case 103:
    case 105:
    case 104:
    case 107:
    case 99:
    case 100:
    case 106:
    case 101:
    case 102:
    case 108: {
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      ((void)0); ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      sqlite3VdbeAddOp3(v, op, r2, r1, target);
      ;
      ;
      break;
    }
    case 168: {
      Expr *pLeft = pExpr->pLeft;
      ((void)0);
      if( pLeft->op==150 ){
        codeInteger(pParse, pLeft, 1, target);
        return target;

      }else if( pLeft->op==148 ){
        ((void)0);
        codeReal(v, pLeft->u.zToken, 1, target);
        return target;

      }else{
        tempX.op = 150;
        tempX.flags = 0x000400|0x004000;
        tempX.u.iValue = 0;
        r1 = sqlite3ExprCodeTemp(pParse, &tempX, &regFree1);
        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);
        sqlite3VdbeAddOp3(v, 104, r2, r1, target);
        ;
      }
      break;
    }
    case 110:
    case 19: {
      ((void)0); ;
      ((void)0); ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      ;
      sqlite3VdbeAddOp2(v, op, r1, inReg);
      break;
    }
    case 170: {
      int isTrue;
      int bNormal;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      ;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
      bNormal = pExpr->op2==45;
      ;
      ;
      sqlite3VdbeAddOp4Int(v, 88, r1, inReg, !isTrue, isTrue ^ bNormal);
      break;
    }
    case 50:
    case 51: {
      int addr;
      ((void)0); ;
      ((void)0); ;
      sqlite3VdbeAddOp2(v, 70, 1, target);
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      ;
      addr = sqlite3VdbeAddOp1(v, op, r1);
      ;
      ;
      sqlite3VdbeAddOp2(v, 70, 0, target);
      sqlite3VdbeJumpHere(v, addr);
      break;
    }
    case 163: {
      AggInfo *pInfo = pExpr->pAggInfo;
      if( pInfo==0 ){
        ((void)0);
        sqlite3ErrorMsg(pParse, "misuse of aggregate: %s()", pExpr->u.zToken);
      }else{
        return pInfo->aFunc[pExpr->iAgg].iMem;
      }
      break;
    }
    case 167: {
      ExprList *pFarg;
      int nFarg;
      FuncDef *pDef;
      const char *zId;
      u32 constMask = 0;
      int i;
      sqlite3 *db = pParse->db;
      u8 enc = ((db)->enc);
      CollSeq *pColl = 0;


      if( (((pExpr)->flags&(0x1000000))!=0) ){
        return pExpr->y.pWin->regResult;
      }


      if( ((pParse)->okConstFactor) && sqlite3ExprIsConstantNotJoin(pExpr) ){


        return sqlite3ExprCodeAtInit(pParse, pExpr, -1);
      }
      ((void)0);
      if( (((pExpr)->flags&(0x004000))!=0) ){
        pFarg = 0;
      }else{
        pFarg = pExpr->x.pList;
      }
      nFarg = pFarg ? pFarg->nExpr : 0;
      ((void)0);
      zId = pExpr->u.zToken;
      pDef = sqlite3FindFunction(db, zId, nFarg, enc, 0);





      if( pDef==0 || pDef->xFinalize!=0 ){
        sqlite3ErrorMsg(pParse, "unknown function: %s()", zId);
        break;
      }





      if( pDef->funcFlags & 0x0200 ){
        int endCoalesce = sqlite3VdbeMakeLabel(pParse);
        ((void)0);
        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);
        for(i=1; i<nFarg; i++){
          sqlite3VdbeAddOp2(v, 51, target, endCoalesce);
          ;
          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);
        }
        sqlite3VdbeResolveLabel(v, endCoalesce);
        break;
      }




      if( pDef->funcFlags & 0x0400 ){
        ((void)0);
        return sqlite3ExprCodeTarget(pParse, pFarg->a[0].pExpr, target);
      }
# 101379 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      for(i=0; i<nFarg; i++){
        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){
          ;
          constMask |= (((unsigned int)1)<<(i));
        }
        if( (pDef->funcFlags & 0x0020)!=0 && !pColl ){
          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);
        }
      }
      if( pFarg ){
        if( constMask ){
          r1 = pParse->nMem+1;
          pParse->nMem += nFarg;
        }else{
          r1 = sqlite3GetTempRange(pParse, nFarg);
        }






        if( (pDef->funcFlags & (0x0040|0x0080))!=0 ){
          u8 exprOp;
          ((void)0);
          ((void)0);
          exprOp = pFarg->a[0].pExpr->op;
          if( exprOp==162 || exprOp==164 ){
            ((void)0);
            ((void)0);
            ;
            pFarg->a[0].pExpr->op2 =
                  pDef->funcFlags & (0x40|0x80);
          }
        }

        sqlite3ExprCodeExprList(pParse, pFarg, r1, 0,
                                0x01|0x02);
      }else{
        r1 = 0;
      }
# 101433 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( nFarg>=2 && (((pExpr)->flags&(0x000080))!=0) ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);
      }else if( nFarg>0 ){
        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);
      }

      if( pDef->funcFlags & 0x0020 ){
        if( !pColl ) pColl = db->pDfltColl;
        sqlite3VdbeAddOp4(v, 82, 0, 0, 0, (char *)pColl, (-2));
      }
# 101453 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      {
        sqlite3VdbeAddOp4(v, pParse->iSelfTab ? 62 : 63,
                          constMask, r1, target, (char*)pDef, (-8));
        sqlite3VdbeChangeP5(v, (u8)nFarg);
      }
      if( nFarg && constMask==0 ){
        sqlite3ReleaseTempRange(pParse, r1, nFarg);
      }
      return target;
    }

    case 20:
    case 134: {
      int nCol;
      ;
      ;
      if( op==134 && (nCol = pExpr->x.pSelect->pEList->nExpr)!=1 ){
        sqlite3SubselectError(pParse, nCol, 1);
      }else{
        return sqlite3CodeSubselect(pParse, pExpr);
      }
      break;
    }
    case 173: {
      int n;
      if( pExpr->pLeft->iTable==0 ){
        pExpr->pLeft->iTable = sqlite3CodeSubselect(pParse, pExpr->pLeft);
      }
      ((void)0);
      if( pExpr->iTable!=0
       && pExpr->iTable!=(n = sqlite3ExprVectorSize(pExpr->pLeft))
      ){
        sqlite3ErrorMsg(pParse, "%d columns assigned %d values",
                                pExpr->iTable, n);
      }
      return pExpr->pLeft->iTable + pExpr->iColumn;
    }
    case 49: {
      int destIfFalse = sqlite3VdbeMakeLabel(pParse);
      int destIfNull = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeAddOp2(v, 73, 0, target);
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeAddOp2(v, 70, 1, target);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      sqlite3VdbeAddOp2(v, 83, target, 0);
      sqlite3VdbeResolveLabel(v, destIfNull);
      return target;
    }
# 101515 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 48: {
      exprCodeBetween(pParse, pExpr, target, 0, 0);
      return target;
    }
    case 176:
    case 109:
    case 169: {
      pExpr = pExpr->pLeft;
      goto expr_code_doover;
    }

    case 77: {
# 101552 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      Table *pTab = pExpr->y.pTab;
      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 + pExpr->iColumn;

      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);

      sqlite3VdbeAddOp2(v, 149, p1, target);
     


        ;







      if( pExpr->iColumn>=0
       && pTab->aCol[pExpr->iColumn].affinity==0x45
      ){
        sqlite3VdbeAddOp1(v, 84, target);
      }

      break;
    }

    case 172: {
      sqlite3ErrorMsg(pParse, "row value misused");
      break;
    }







    case 174: {
      int addrINR;
      u8 okConstFactor = pParse->okConstFactor;
      addrINR = sqlite3VdbeAddOp1(v, 21, pExpr->iTable);




      pParse->okConstFactor = 0;
      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);
      pParse->okConstFactor = okConstFactor;
      sqlite3VdbeJumpHere(v, addrINR);
      sqlite3VdbeChangeP3(v, addrINR, inReg);
      break;
    }
# 101629 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    default: ((void)0); {
      int endLabel;
      int nextCase;
      int nExpr;
      int i;
      ExprList *pEList;
      struct ExprList_item *aListelem;
      Expr opCompare;
      Expr *pX;
      Expr *pTest = 0;
      Expr *pDel = 0;
      sqlite3 *db = pParse->db;

      ((void)0);
      ((void)0);
      pEList = pExpr->x.pList;
      aListelem = pEList->a;
      nExpr = pEList->nExpr;
      endLabel = sqlite3VdbeMakeLabel(pParse);
      if( (pX = pExpr->pLeft)!=0 ){
        pDel = sqlite3ExprDup(db, pX, 0);
        if( db->mallocFailed ){
          sqlite3ExprDelete(db, pDel);
          break;
        }
        ;
        exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
        ;
        memset(&opCompare, 0, sizeof(opCompare));
        opCompare.op = 53;
        opCompare.pLeft = pDel;
        pTest = &opCompare;




        regFree1 = 0;
      }
      for(i=0; i<nExpr-1; i=i+2){
        if( pX ){
          ((void)0);
          opCompare.pRight = aListelem[i].pExpr;
        }else{
          pTest = aListelem[i].pExpr;
        }
        nextCase = sqlite3VdbeMakeLabel(pParse);
        ;
        sqlite3ExprIfFalse(pParse, pTest, nextCase, 0x10);
        ;
        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);
        sqlite3VdbeGoto(v, endLabel);
        sqlite3VdbeResolveLabel(v, nextCase);
      }
      if( (nExpr&1)!=0 ){
        sqlite3ExprCode(pParse, pEList->a[nExpr-1].pExpr, target);
      }else{
        sqlite3VdbeAddOp2(v, 73, 0, target);
      }
      sqlite3ExprDelete(db, pDel);
      sqlite3VdbeResolveLabel(v, endLabel);
      break;
    }

    case 71: {
      ((void)0)



       ;
      if( !pParse->pTriggerTab ){
        sqlite3ErrorMsg(pParse,
                       "RAISE() may only be used within a trigger-program");
        return 0;
      }
      if( pExpr->affExpr==2 ){
        sqlite3MayAbort(pParse);
      }
      ((void)0);
      if( pExpr->affExpr==4 ){
        sqlite3VdbeAddOp4(
            v, 69, 0, 4, 0, pExpr->u.zToken,0);
        ;
      }else{
        sqlite3HaltConstraint(pParse, (19 | (7<<8)),
                              pExpr->affExpr, pExpr->u.zToken, 0, 0);
      }

      break;
    }

  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
  return inReg;
}
# 101734 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCodeAtInit(
  Parse *pParse,
  Expr *pExpr,
  int regDest
){
  ExprList *p;
  ((void)0);
  p = pParse->pConstExpr;
  if( regDest<0 && p ){
    struct ExprList_item *pItem;
    int i;
    for(pItem=p->a, i=p->nExpr; i>0; pItem++, i--){
      if( pItem->reusable && sqlite3ExprCompare(0,pItem->pExpr,pExpr,-1)==0 ){
        return pItem->u.iConstExprReg;
      }
    }
  }
  pExpr = sqlite3ExprDup(pParse->db, pExpr, 0);
  p = sqlite3ExprListAppend(pParse, p, pExpr);
  if( p ){
     struct ExprList_item *pItem = &p->a[p->nExpr-1];
     pItem->reusable = regDest<0;
     if( regDest<0 ) regDest = ++pParse->nMem;
     pItem->u.iConstExprReg = regDest;
  }
  pParse->pConstExpr = p;
  return regDest;
}
# 101776 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){
  int r2;
  pExpr = sqlite3ExprSkipCollateAndLikely(pExpr);
  if( ((pParse)->okConstFactor)
   && pExpr->op!=171
   && sqlite3ExprIsConstantNotJoin(pExpr)
  ){
    *pReg = 0;
    r2 = sqlite3ExprCodeAtInit(pParse, pExpr, -1);
  }else{
    int r1 = sqlite3GetTempReg(pParse);
    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);
    if( r2==r1 ){
      *pReg = r1;
    }else{
      sqlite3ReleaseTempReg(pParse, r1);
      *pReg = 0;
    }
  }
  return r2;
}






static void sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){
  int inReg;

  ((void)0);
  if( pExpr && pExpr->op==171 ){
    sqlite3VdbeAddOp2(pParse->pVdbe, 78, pExpr->iTable, target);
  }else{
    inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);
    ((void)0);
    if( inReg!=target && pParse->pVdbe ){
      sqlite3VdbeAddOp2(pParse->pVdbe, 79, inReg, target);
    }
  }
}






static void sqlite3ExprCodeCopy(Parse *pParse, Expr *pExpr, int target){
  sqlite3 *db = pParse->db;
  pExpr = sqlite3ExprDup(db, pExpr, 0);
  if( !db->mallocFailed ) sqlite3ExprCode(pParse, pExpr, target);
  sqlite3ExprDelete(db, pExpr);
}







static void sqlite3ExprCodeFactorable(Parse *pParse, Expr *pExpr, int target){
  if( pParse->okConstFactor && sqlite3ExprIsConstantNotJoin(pExpr) ){
    sqlite3ExprCodeAtInit(pParse, pExpr, target);
  }else{
    sqlite3ExprCode(pParse, pExpr, target);
  }
}
# 101856 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){
  Vdbe *v = pParse->pVdbe;
  int iMem;

  ((void)0);
  ((void)0);
  sqlite3ExprCode(pParse, pExpr, target);
  iMem = ++pParse->nMem;
  sqlite3VdbeAddOp2(v, 78, target, iMem);
  exprToRegister(pExpr, iMem);
}
# 101888 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCodeExprList(
  Parse *pParse,
  ExprList *pList,
  int target,
  int srcReg,
  u8 flags
){
  struct ExprList_item *pItem;
  int i, j, n;
  u8 copyOp = (flags & 0x01) ? 78 : 79;
  Vdbe *v = pParse->pVdbe;
  ((void)0);
  ((void)0);
  ((void)0);
  n = pList->nExpr;
  if( !((pParse)->okConstFactor) ) flags &= ~0x02;
  for(pItem=pList->a, i=0; i<n; i++, pItem++){
    Expr *pExpr = pItem->pExpr;






    if( (flags & 0x04)!=0 && (j = pItem->u.x.iOrderByCol)>0 ){
      if( flags & 0x08 ){
        i--;
        n--;
      }else{
        sqlite3VdbeAddOp2(v, copyOp, j+srcReg-1, target+i);
      }
    }else if( (flags & 0x02)!=0
           && sqlite3ExprIsConstantNotJoin(pExpr)
    ){
      sqlite3ExprCodeAtInit(pParse, pExpr, target+i);
    }else{
      int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);
      if( inReg!=target+i ){
        VdbeOp *pOp;
        if( copyOp==78
         && (pOp=sqlite3VdbeGetOp(v, -1))->opcode==78
         && pOp->p1+pOp->p3+1==inReg
         && pOp->p2+pOp->p3+1==target+i
        ){
          pOp->p3++;
        }else{
          sqlite3VdbeAddOp2(v, copyOp, inReg, target+i);
        }
      }
    }
  }
  return n;
}
# 101962 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void exprCodeBetween(
  Parse *pParse,
  Expr *pExpr,
  int dest,
  void (*xJump)(Parse*,Expr*,int,int),
  int jumpIfNull
){
  Expr exprAnd;
  Expr compLeft;
  Expr compRight;
  int regFree1 = 0;
  Expr *pDel = 0;
  sqlite3 *db = pParse->db;

  memset(&compLeft, 0, sizeof(Expr));
  memset(&compRight, 0, sizeof(Expr));
  memset(&exprAnd, 0, sizeof(Expr));

  ((void)0);
  pDel = sqlite3ExprDup(db, pExpr->pLeft, 0);
  if( db->mallocFailed==0 ){
    exprAnd.op = 44;
    exprAnd.pLeft = &compLeft;
    exprAnd.pRight = &compRight;
    compLeft.op = 57;
    compLeft.pLeft = pDel;
    compLeft.pRight = pExpr->x.pList->a[0].pExpr;
    compRight.op = 55;
    compRight.pLeft = pDel;
    compRight.pRight = pExpr->x.pList->a[1].pExpr;
    exprToRegister(pDel, exprCodeVector(pParse, pDel, &regFree1));
    if( xJump ){
      xJump(pParse, &exprAnd, dest, jumpIfNull);
    }else{





      pDel->flags |= 0x000001;
      sqlite3ExprCodeTarget(pParse, &exprAnd, dest);
    }
    sqlite3ReleaseTempReg(pParse, regFree1);
  }
  sqlite3ExprDelete(db, pDel);


  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
  ;
}
# 102034 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  ((void)0);
  if( (v==0) ) return;
  if( (pExpr==0) ) return;
  op = pExpr->op;
  switch( op ){
    case 44:
    case 43: {
      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
      if( pAlt!=pExpr ){
        sqlite3ExprIfTrue(pParse, pAlt, dest, jumpIfNull);
      }else if( op==44 ){
        int d2 = sqlite3VdbeMakeLabel(pParse);
        ;
        sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,
                           jumpIfNull^0x10);
        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
        sqlite3VdbeResolveLabel(v, d2);
      }else{
        ;
        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
        sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);
      }
      break;
    }
    case 19: {
      ;
      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 170: {
      int isNot;
      int isTrue;
      ;
      isNot = pExpr->op2==166;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
      ;
      ;
      if( isTrue ^ isNot ){
        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
                          isNot ? 0x10 : 0);
      }else{
        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
                           isNot ? 0x10 : 0);
      }
      break;
    }
    case 45:
    case 166:
      ;
      ;
      op = (op==45) ? 53 : 52;
      jumpIfNull = 0x80;

    case 56:
    case 55:
    case 54:
    case 57:
    case 52:
    case 53: {
      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;
      ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull);
      ((void)0); ; ;
      ((void)0); ; ;
      ((void)0); ; ;
      ((void)0); ; ;
      ((void)0); ;
      ;
      ;
      ((void)0); ;
      ;
      ;
      ;
      ;
      break;
    }
    case 50:
    case 51: {
      ((void)0); ;
      ((void)0); ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      sqlite3VdbeAddOp2(v, op, r1, dest);
      ;
      ;
      ;
      break;
    }
    case 48: {
      ;
      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfTrue, jumpIfNull);
      break;
    }

    case 49: {
      int destIfFalse = sqlite3VdbeMakeLabel(pParse);
      int destIfNull = jumpIfNull ? dest : destIfFalse;
      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);
      sqlite3VdbeGoto(v, dest);
      sqlite3VdbeResolveLabel(v, destIfFalse);
      break;
    }

    default: {
    default_expr:
      if( (((pExpr)->flags&(0x000001|0x10000000))==0x10000000) ){
        sqlite3VdbeGoto(v, dest);
      }else if( (((pExpr)->flags&(0x000001|0x20000000))==0x20000000) ){

      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
        sqlite3VdbeAddOp3(v, 18, r1, dest, jumpIfNull!=0);
        ;
        ;
        ;
      }
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}
# 102175 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){
  Vdbe *v = pParse->pVdbe;
  int op = 0;
  int regFree1 = 0;
  int regFree2 = 0;
  int r1, r2;

  ((void)0);
  if( (v==0) ) return;
  if( pExpr==0 ) return;
# 102204 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  op = ((pExpr->op+(50&1))^1)-(50&1);



  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  switch( pExpr->op ){
    case 44:
    case 43: {
      Expr *pAlt = sqlite3ExprSimplifiedAndOr(pExpr);
      if( pAlt!=pExpr ){
        sqlite3ExprIfFalse(pParse, pAlt, dest, jumpIfNull);
      }else if( pExpr->op==44 ){
        ;
        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);
        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
      }else{
        int d2 = sqlite3VdbeMakeLabel(pParse);
        ;
        sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2,
                          jumpIfNull^0x10);
        sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);
        sqlite3VdbeResolveLabel(v, d2);
      }
      break;
    }
    case 19: {
      ;
      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);
      break;
    }
    case 170: {
      int isNot;
      int isTrue;
      ;
      isNot = pExpr->op2==166;
      isTrue = sqlite3ExprTruthValue(pExpr->pRight);
      ;
      ;
      if( isTrue ^ isNot ){

        sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest,
                           isNot ? 0 : 0x10);

      }else{

        sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest,
                          isNot ? 0 : 0x10);
      }
      break;
    }
    case 45:
    case 166:
      ;
      ;
      op = (pExpr->op==45) ? 52 : 53;
      jumpIfNull = 0x80;

    case 56:
    case 55:
    case 54:
    case 57:
    case 52:
    case 53: {
      if( sqlite3ExprIsVector(pExpr->pLeft) ) goto default_expr;
      ;
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);
      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,
                  r1, r2, dest, jumpIfNull);
      ((void)0); ; ;
      ((void)0); ; ;
      ((void)0); ; ;
      ((void)0); ; ;
      ((void)0); ;
      ;
      ;
      ((void)0); ;
      ;
      ;
      ;
      ;
      break;
    }
    case 50:
    case 51: {
      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);
      sqlite3VdbeAddOp2(v, op, r1, dest);
      ; ;
      ; ;
      ;
      break;
    }
    case 48: {
      ;
      exprCodeBetween(pParse, pExpr, dest, sqlite3ExprIfFalse, jumpIfNull);
      break;
    }

    case 49: {
      if( jumpIfNull ){
        sqlite3ExprCodeIN(pParse, pExpr, dest, dest);
      }else{
        int destIfNull = sqlite3VdbeMakeLabel(pParse);
        sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);
        sqlite3VdbeResolveLabel(v, destIfNull);
      }
      break;
    }

    default: {
    default_expr:
      if( (((pExpr)->flags&(0x000001|0x20000000))==0x20000000) ){
        sqlite3VdbeGoto(v, dest);
      }else if( (((pExpr)->flags&(0x000001|0x10000000))==0x10000000) ){

      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);
        sqlite3VdbeAddOp3(v, 20, r1, dest, jumpIfNull!=0);
        ;
        ;
        ;
      }
      break;
    }
  }
  sqlite3ReleaseTempReg(pParse, regFree1);
  sqlite3ReleaseTempReg(pParse, regFree2);
}






static void sqlite3ExprIfFalseDup(Parse *pParse, Expr *pExpr, int dest,int jumpIfNull){
  sqlite3 *db = pParse->db;
  Expr *pCopy = sqlite3ExprDup(db, pExpr, 0);
  if( db->mallocFailed==0 ){
    sqlite3ExprIfFalse(pParse, pCopy, dest, jumpIfNull);
  }
  sqlite3ExprDelete(db, pCopy);
}
# 102368 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int exprCompareVariable(Parse *pParse, Expr *pVar, Expr *pExpr){
  int res = 0;
  int iVar;
  sqlite3_value *pL, *pR = 0;

  sqlite3ValueFromExpr(pParse->db, pExpr, 1, 0x41, &pR);
  if( pR ){
    iVar = pVar->iColumn;
    sqlite3VdbeSetVarmask(pParse->pVdbe, iVar);
    pL = sqlite3VdbeGetBoundValue(pParse->pReprepare, iVar, 0x41);
    if( pL ){
      if( sqlite3_value_type(pL)==3 ){
        sqlite3_value_text(pL);
      }
      res = 0==sqlite3MemCompare(pL, pR, 0);
    }
    sqlite3ValueFree(pR);
    sqlite3ValueFree(pL);
  }

  return res;
}
# 102420 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCompare(Parse *pParse, Expr *pA, Expr *pB, int iTab){
  u32 combinedFlags;
  if( pA==0 || pB==0 ){
    return pB==pA ? 0 : 2;
  }
  if( pParse && pA->op==151 && exprCompareVariable(pParse, pA, pB) ){
    return 0;
  }
  combinedFlags = pA->flags | pB->flags;
  if( combinedFlags & 0x000400 ){
    if( (pA->flags&pB->flags&0x000400)!=0 && pA->u.iValue==pB->u.iValue ){
      return 0;
    }
    return 2;
  }
  if( pA->op!=pB->op || pA->op==71 ){
    if( pA->op==109 && sqlite3ExprCompare(pParse, pA->pLeft,pB,iTab)<2 ){
      return 1;
    }
    if( pB->op==109 && sqlite3ExprCompare(pParse, pA,pB->pLeft,iTab)<2 ){
      return 1;
    }
    return 2;
  }
  if( pA->op!=162 && pA->op!=164 && pA->u.zToken ){
    if( pA->op==167 || pA->op==163 ){
      if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;

      ((void)0);
      if( (((pA)->flags&(0x1000000))!=0)!=(((pB)->flags&(0x1000000))!=0) ){
        return 2;
      }
      if( (((pA)->flags&(0x1000000))!=0) ){
        if( sqlite3WindowCompare(pParse, pA->y.pWin, pB->y.pWin, 1)!=0 ){
          return 2;
        }
      }

    }else if( pA->op==117 ){
      return 0;
    }else if( pA->op==109 ){
      if( sqlite3_stricmp(pA->u.zToken,pB->u.zToken)!=0 ) return 2;
    }else if( (pB->u.zToken!=0) && strcmp(pA->u.zToken,pB->u.zToken)!=0 ){
      return 2;
    }
  }
  if( (pA->flags & 0x000002)!=(pB->flags & 0x000002) ) return 2;
  if( (combinedFlags & 0x004000)==0 ){
    if( combinedFlags & 0x000800 ) return 2;
    if( (combinedFlags & 0x000008)==0
     && sqlite3ExprCompare(pParse, pA->pLeft, pB->pLeft, iTab) ) return 2;
    if( sqlite3ExprCompare(pParse, pA->pRight, pB->pRight, iTab) ) return 2;
    if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList, iTab) ) return 2;
    if( pA->op!=113
     && pA->op!=165
     && (combinedFlags & 0x002000)==0
    ){
      if( pA->iColumn!=pB->iColumn ) return 2;
      if( pA->op2!=pB->op2 ) return 2;
      if( pA->op!=49
       && pA->iTable!=pB->iTable
       && (pA->iTable!=iTab || (pB->iTable>=0)) ) return 2;
    }
  }
  return 0;
}
# 102502 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprListCompare(ExprList *pA, ExprList *pB, int iTab){
  int i;
  if( pA==0 && pB==0 ) return 0;
  if( pA==0 || pB==0 ) return 1;
  if( pA->nExpr!=pB->nExpr ) return 1;
  for(i=0; i<pA->nExpr; i++){
    Expr *pExprA = pA->a[i].pExpr;
    Expr *pExprB = pB->a[i].pExpr;
    if( pA->a[i].sortFlags!=pB->a[i].sortFlags ) return 1;
    if( sqlite3ExprCompare(0, pExprA, pExprB, iTab) ) return 1;
  }
  return 0;
}





static int sqlite3ExprCompareSkip(Expr *pA, Expr *pB, int iTab){
  return sqlite3ExprCompare(0,
             sqlite3ExprSkipCollateAndLikely(pA),
             sqlite3ExprSkipCollateAndLikely(pB),
             iTab);
}







static int exprImpliesNotNull(
  Parse *pParse,
  Expr *p,
  Expr *pNN,
  int iTab,
  int seenNot
){
  ((void)0);
  ((void)0);
  if( sqlite3ExprCompare(pParse, p, pNN, iTab)==0 ){
    return pNN->op!=117;
  }
  switch( p->op ){
    case 49: {
      if( seenNot && (((p)->flags&(0x000800))!=0) ) return 0;
      ((void)0)
                                                      ;
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case 48: {
      ExprList *pList = p->x.pList;
      ((void)0);
      ((void)0);
      if( seenNot ) return 0;
      if( exprImpliesNotNull(pParse, pList->a[0].pExpr, pNN, iTab, 1)
       || exprImpliesNotNull(pParse, pList->a[1].pExpr, pNN, iTab, 1)
      ){
        return 1;
      }
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case 53:
    case 52:
    case 56:
    case 55:
    case 54:
    case 57:
    case 103:
    case 104:
    case 100:
    case 101:
    case 102:
    case 108:
      seenNot = 1;

    case 105:
    case 107:
    case 99:
    case 106: {
      if( exprImpliesNotNull(pParse, p->pRight, pNN, iTab, seenNot) ) return 1;

    }
    case 176:
    case 109:
    case 169:
    case 168: {
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, seenNot);
    }
    case 170: {
      if( seenNot ) return 0;
      if( p->op2!=45 ) return 0;
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
    case 110:
    case 19: {
      return exprImpliesNotNull(pParse, p->pLeft, pNN, iTab, 1);
    }
  }
  return 0;
}
# 102629 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprImpliesExpr(Parse *pParse, Expr *pE1, Expr *pE2, int iTab){
  if( sqlite3ExprCompare(pParse, pE1, pE2, iTab)==0 ){
    return 1;
  }
  if( pE2->op==43
   && (sqlite3ExprImpliesExpr(pParse, pE1, pE2->pLeft, iTab)
             || sqlite3ExprImpliesExpr(pParse, pE1, pE2->pRight, iTab) )
  ){
    return 1;
  }
  if( pE2->op==51
   && exprImpliesNotNull(pParse, pE1, pE2->pLeft, iTab, 0)
  ){
    return 1;
  }
  return 0;
}
# 102656 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int impliesNotNullRow(Walker *pWalker, Expr *pExpr){
  ;
  ;
  if( (((pExpr)->flags&(0x000001))!=0) ) return 1;
  switch( pExpr->op ){
    case 166:
    case 50:
    case 51:
    case 45:
    case 43:
    case 152:
    case 49:
    case 167:
    case 170:
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      return 1;
    case 162:
      if( pWalker->u.iCur==pExpr->iTable ){
        pWalker->eCode = 1;
        return 2;
      }
      return 1;

    case 44:
      if( sqlite3ExprImpliesNonNullRow(pExpr->pLeft, pWalker->u.iCur)
       && sqlite3ExprImpliesNonNullRow(pExpr->pRight, pWalker->u.iCur)
      ){
        pWalker->eCode = 1;
      }
      return 1;

    case 48:
      sqlite3WalkExpr(pWalker, pExpr->pLeft);
      return 1;




    case 53:
    case 52:
    case 56:
    case 55:
    case 54:
    case 57:
      ;
      ;
      ;
      ;
      ;
      ;
      if( (pExpr->pLeft->op==162 && ((pExpr->pLeft->y.pTab)->nModuleArg))
       || (pExpr->pRight->op==162 && ((pExpr->pRight->y.pTab)->nModuleArg))
      ){
       return 1;
      }

    default:
      return 0;
  }
}
# 102747 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprImpliesNonNullRow(Expr *p, int iTab){
  Walker w;
  p = sqlite3ExprSkipCollateAndLikely(p);
  while( p ){
    if( p->op==51 ){
      p = p->pLeft;
    }else if( p->op==44 ){
      if( sqlite3ExprImpliesNonNullRow(p->pLeft, iTab) ) return 1;
      p = p->pRight;
    }else{
      break;
    }
  }
  w.xExprCallback = impliesNotNullRow;
  w.xSelectCallback = 0;
  w.xSelectCallback2 = 0;
  w.eCode = 0;
  w.u.iCur = iTab;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 102776 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct IdxCover {
  Index *pIdx;
  int iCur;
};






static int exprIdxCover(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==162
   && pExpr->iTable==pWalker->u.pIdxCover->iCur
   && sqlite3ColumnOfIndex(pWalker->u.pIdxCover->pIdx, pExpr->iColumn)<0
  ){
    pWalker->eCode = 1;
    return 2;
  }
  return 0;
}
# 102807 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprCoveredByIndex(
  Expr *pExpr,
  int iCur,
  Index *pIdx
){
  Walker w;
  struct IdxCover xcov;
  memset(&w, 0, sizeof(w));
  xcov.iCur = iCur;
  xcov.pIdx = pIdx;
  w.xExprCallback = exprIdxCover;
  w.u.pIdxCover = &xcov;
  sqlite3WalkExpr(&w, pExpr);
  return !w.eCode;
}
# 102830 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct SrcCount {
  SrcList *pSrc;
  int nThis;
  int nOther;
};




static int exprSrcCount(Walker *pWalker, Expr *pExpr){





  if( pExpr->op==162 || (pExpr->op==164) ){
    int i;
    struct SrcCount *p = pWalker->u.pSrcCount;
    SrcList *pSrc = p->pSrc;
    int nSrc = pSrc ? pSrc->nSrc : 0;
    for(i=0; i<nSrc; i++){
      if( pExpr->iTable==pSrc->a[i].iCursor ) break;
    }
    if( i<nSrc ){
      p->nThis++;
    }else if( nSrc==0 || pExpr->iTable<pSrc->a[0].iCursor ){



      p->nOther++;
    }
  }
  return 0;
}







static int sqlite3FunctionUsesThisSrc(Expr *pExpr, SrcList *pSrcList){
  Walker w;
  struct SrcCount cnt;
  ((void)0);
  memset(&w, 0, sizeof(w));
  w.xExprCallback = exprSrcCount;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  w.u.pSrcCount = &cnt;
  cnt.pSrc = pSrcList;
  cnt.nThis = 0;
  cnt.nOther = 0;
  sqlite3WalkExprList(&w, pExpr->x.pList);
  return cnt.nThis>0 || cnt.nOther==0;
}





static int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aCol = sqlite3ArrayAllocate(
       db,
       pInfo->aCol,
       sizeof(pInfo->aCol[0]),
       &pInfo->nColumn,
       &i
  );
  return i;
}





static int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){
  int i;
  pInfo->aFunc = sqlite3ArrayAllocate(
       db,
       pInfo->aFunc,
       sizeof(pInfo->aFunc[0]),
       &pInfo->nFunc,
       &i
  );
  return i;
}






static int analyzeAggregate(Walker *pWalker, Expr *pExpr){
  int i;
  NameContext *pNC = pWalker->u.pNC;
  Parse *pParse = pNC->pParse;
  SrcList *pSrcList = pNC->pSrcList;
  AggInfo *pAggInfo = pNC->uNC.pAggInfo;

  ((void)0);
  switch( pExpr->op ){
    case 164:
    case 162: {
      ;
      ;


      if( (pSrcList!=0) ){
        struct SrcList_item *pItem = pSrcList->a;
        for(i=0; i<pSrcList->nSrc; i++, pItem++){
          struct AggInfo_col *pCol;
          ((void)0);
          if( pExpr->iTable==pItem->iCursor ){






            int k;
            pCol = pAggInfo->aCol;
            for(k=0; k<pAggInfo->nColumn; k++, pCol++){
              if( pCol->iTable==pExpr->iTable &&
                  pCol->iColumn==pExpr->iColumn ){
                break;
              }
            }
            if( (k>=pAggInfo->nColumn)
             && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0
            ){
              pCol = &pAggInfo->aCol[k];
              pCol->pTab = pExpr->y.pTab;
              pCol->iTable = pExpr->iTable;
              pCol->iColumn = pExpr->iColumn;
              pCol->iMem = ++pParse->nMem;
              pCol->iSorterColumn = -1;
              pCol->pExpr = pExpr;
              if( pAggInfo->pGroupBy ){
                int j, n;
                ExprList *pGB = pAggInfo->pGroupBy;
                struct ExprList_item *pTerm = pGB->a;
                n = pGB->nExpr;
                for(j=0; j<n; j++, pTerm++){
                  Expr *pE = pTerm->pExpr;
                  if( pE->op==162 && pE->iTable==pExpr->iTable &&
                      pE->iColumn==pExpr->iColumn ){
                    pCol->iSorterColumn = j;
                    break;
                  }
                }
              }
              if( pCol->iSorterColumn<0 ){
                pCol->iSorterColumn = pAggInfo->nSortingColumn++;
              }
            }





            ;
            pExpr->pAggInfo = pAggInfo;
            pExpr->op = 164;
            pExpr->iAgg = (i16)k;
            break;
          }
        }
      }
      return 1;
    }
    case 163: {
      if( (pNC->ncFlags & 0x0008)==0
       && pWalker->walkerDepth==pExpr->op2
      ){



        struct AggInfo_func *pItem = pAggInfo->aFunc;
        for(i=0; i<pAggInfo->nFunc; i++, pItem++){
          if( sqlite3ExprCompare(0, pItem->pExpr, pExpr, -1)==0 ){
            break;
          }
        }
        if( i>=pAggInfo->nFunc ){


          u8 enc = ((pParse->db)->enc);
          i = addAggInfoFunc(pParse->db, pAggInfo);
          if( i>=0 ){
            ((void)0);
            pItem = &pAggInfo->aFunc[i];
            pItem->pExpr = pExpr;
            pItem->iMem = ++pParse->nMem;
            ((void)0);
            pItem->pFunc = sqlite3FindFunction(pParse->db,
                   pExpr->u.zToken,
                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);
            if( pExpr->flags & 0x000002 ){
              pItem->iDistinct = pParse->nTab++;
            }else{
              pItem->iDistinct = -1;
            }
          }
        }


        ((void)0);
        ;
        pExpr->iAgg = (i16)i;
        pExpr->pAggInfo = pAggInfo;
        return 1;
      }else{
        return 0;
      }
    }
  }
  return 0;
}
static int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){
  (void)(pSelect);
  pWalker->walkerDepth++;
  return 0;
}
static void analyzeAggregatesInSelectEnd(Walker *pWalker, Select *pSelect){
  (void)(pSelect);
  pWalker->walkerDepth--;
}
# 103068 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){
  Walker w;
  w.xExprCallback = analyzeAggregate;
  w.xSelectCallback = analyzeAggregatesInSelect;
  w.xSelectCallback2 = analyzeAggregatesInSelectEnd;
  w.walkerDepth = 0;
  w.u.pNC = pNC;
  w.pParse = 0;
  ((void)0);
  sqlite3WalkExpr(&w, pExpr);
}







static void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){
  struct ExprList_item *pItem;
  int i;
  if( pList ){
    for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){
      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);
    }
  }
}




static int sqlite3GetTempReg(Parse *pParse){
  if( pParse->nTempReg==0 ){
    return ++pParse->nMem;
  }
  return pParse->aTempReg[--pParse->nTempReg];
}





static void sqlite3ReleaseTempReg(Parse *pParse, int iReg){
  if( iReg && pParse->nTempReg<((int)(sizeof(pParse->aTempReg)/sizeof(pParse->aTempReg[0]))) ){
    pParse->aTempReg[pParse->nTempReg++] = iReg;
  }
}




static int sqlite3GetTempRange(Parse *pParse, int nReg){
  int i, n;
  if( nReg==1 ) return sqlite3GetTempReg(pParse);
  i = pParse->iRangeReg;
  n = pParse->nRangeReg;
  if( nReg<=n ){
    pParse->iRangeReg += nReg;
    pParse->nRangeReg -= nReg;
  }else{
    i = pParse->nMem+1;
    pParse->nMem += nReg;
  }
  return i;
}
static void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){
  if( nReg==1 ){
    sqlite3ReleaseTempReg(pParse, iReg);
    return;
  }
  if( nReg>pParse->nRangeReg ){
    pParse->nRangeReg = nReg;
    pParse->iRangeReg = iReg;
  }
}
# 103152 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ClearTempRegCache(Parse *pParse){
  pParse->nTempReg = 0;
  pParse->nRangeReg = 0;
}
# 103212 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isAlterableTable(Parse *pParse, Table *pTab){
  if( 0==sqlite3_strnicmp(pTab->zName, "sqlite_", 7)

   || ( (pTab->tabFlags & 0x0400)
     && (pParse->db->flags & 0x10000000)
     && pParse->db->nVdbeExec==0
   )

  ){
    sqlite3ErrorMsg(pParse, "table %s may not be altered", pTab->zName);
    return 1;
  }
  return 0;
}
# 103234 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void renameTestSchema(Parse *pParse, const char *zDb, int bTemp){
  sqlite3NestedParse(pParse,
      "SELECT 1 "
      "FROM \"%w\".%s "
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      " AND sql NOT LIKE 'create virtual%%'"
      " AND sqlite_rename_test(%Q, sql, type, name, %d)=NULL ",
      zDb, "sqlite_master",
      zDb, bTemp
  );

  if( bTemp==0 ){
    sqlite3NestedParse(pParse,
        "SELECT 1 "
        "FROM temp.%s "
        "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
        " AND sql NOT LIKE 'create virtual%%'"
        " AND sqlite_rename_test(%Q, sql, type, name, 1)=NULL ",
        "sqlite_master", zDb
    );
  }
}





static void renameReloadSchema(Parse *pParse, int iDb){
  Vdbe *v = pParse->pVdbe;
  if( v ){
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, iDb, 0);
    if( iDb!=1 ) sqlite3VdbeAddParseSchemaOp(pParse->pVdbe, 1, 0);
  }
}





static void sqlite3AlterRenameTable(
  Parse *pParse,
  SrcList *pSrc,
  Token *pName
){
  int iDb;
  char *zDb;
  Table *pTab;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  int nTabName;
  const char *zTabName;
  Vdbe *v;
  VTable *pVTab = 0;
  u32 savedDbFlags;

  savedDbFlags = db->mDbFlags;
  if( (db->mallocFailed) ) goto exit_rename_table;
  ((void)0);
  ((void)0);

  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) goto exit_rename_table;
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  zDb = db->aDb[iDb].zDbSName;
  db->mDbFlags |= 0x0002;


  zName = sqlite3NameFromToken(db, pName);
  if( !zName ) goto exit_rename_table;




  if( sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) ){
    sqlite3ErrorMsg(pParse,
        "there is already another table or index with this name: %s", zName);
    goto exit_rename_table;
  }




  if( 0!=isAlterableTable(pParse, pTab) ){
    goto exit_rename_table;
  }
  if( 0!=sqlite3CheckObjectName(pParse,zName,"table",zName) ){
    goto exit_rename_table;
  }


  if( pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "view %s may not be altered", pTab->zName);
    goto exit_rename_table;
  }




  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    goto exit_rename_table;
  }



  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_rename_table;
  }
  if( ((pTab)->nModuleArg) ){
    pVTab = sqlite3GetVTable(db, pTab);
    if( pVTab->pVtab->pModule->xRename==0 ){
      pVTab = 0;
    }
  }






  v = sqlite3GetVdbe(pParse);
  if( v==0 ){
    goto exit_rename_table;
  }
  sqlite3MayAbort(pParse);


  zTabName = pTab->zName;
  nTabName = sqlite3Utf8CharLen(zTabName, -1);



  sqlite3NestedParse(pParse,
      "UPDATE \"%w\".%s SET "
      "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, %d) "
      "WHERE (type!='index' OR tbl_name=%Q COLLATE nocase)"
      "AND   name NOT LIKE 'sqliteX_%%' ESCAPE 'X'"
      , zDb, "sqlite_master", zDb, zTabName, zName, (iDb==1), zTabName
  );



  sqlite3NestedParse(pParse,
      "UPDATE %Q.%s SET "
          "tbl_name = %Q, "
          "name = CASE "
            "WHEN type='table' THEN %Q "
            "WHEN name LIKE 'sqliteX_autoindex%%' ESCAPE 'X' "
            "     AND type='index' THEN "
             "'sqlite_autoindex_' || %Q || substr(name,%d+18) "
            "ELSE name END "
      "WHERE tbl_name=%Q COLLATE nocase AND "
          "(type='table' OR type='index' OR type='trigger');",
      zDb, "sqlite_master",
      zName, zName, zName,
      nTabName, zTabName
  );





  if( sqlite3FindTable(db, "sqlite_sequence", zDb) ){
    sqlite3NestedParse(pParse,
        "UPDATE \"%w\".sqlite_sequence set name = %Q WHERE name = %Q",
        zDb, zName, pTab->zName);
  }





  if( iDb!=1 ){
    sqlite3NestedParse(pParse,
        "UPDATE sqlite_temp_master SET "
            "sql = sqlite_rename_table(%Q, type, name, sql, %Q, %Q, 1), "
            "tbl_name = "
              "CASE WHEN tbl_name=%Q COLLATE nocase AND "
              "          sqlite_rename_test(%Q, sql, type, name, 1) "
              "THEN %Q ELSE tbl_name END "
            "WHERE type IN ('view', 'trigger')"
        , zDb, zTabName, zName, zTabName, zDb, zName);
  }







  if( pVTab ){
    int i = ++pParse->nMem;
    sqlite3VdbeLoadString(v, i, zName);
    sqlite3VdbeAddOp4(v, 165, i, 0, 0,(const char*)pVTab, (-12));
  }


  renameReloadSchema(pParse, iDb);
  renameTestSchema(pParse, zDb, iDb==1);

exit_rename_table:
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, zName);
  db->mDbFlags = savedDbFlags;
}
# 103448 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){
  Table *pNew;
  Table *pTab;
  int iDb;
  const char *zDb;
  const char *zTab;
  char *zCol;
  Column *pCol;
  Expr *pDflt;
  sqlite3 *db;
  Vdbe *v;
  int r1;

  db = pParse->db;
  if( pParse->nErr || db->mallocFailed ) return;
  pNew = pParse->pNewTable;
  ((void)0);

  ((void)0);
  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);
  zDb = db->aDb[iDb].zDbSName;
  zTab = &pNew->zName[16];
  pCol = &pNew->aCol[pNew->nCol-1];
  pDflt = pCol->pDflt;
  pTab = sqlite3FindTable(db, zTab, zDb);
  ((void)0);



  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    return;
  }






  ((void)0);
  if( pDflt && pDflt->pLeft->op==117 ){
    pDflt = 0;
  }





  if( pCol->colFlags & 0x0001 ){
    sqlite3ErrorMsg(pParse, "Cannot add a PRIMARY KEY column");
    return;
  }
  if( pNew->pIndex ){
    sqlite3ErrorMsg(pParse, "Cannot add a UNIQUE column");
    return;
  }
  if( (db->flags&0x00004000) && pNew->pFKey && pDflt ){
    sqlite3ErrorMsg(pParse,
        "Cannot add a REFERENCES column with non-NULL default value");
    return;
  }
  if( pCol->notNull && !pDflt ){
    sqlite3ErrorMsg(pParse,
        "Cannot add a NOT NULL column with default value NULL");
    return;
  }




  if( pDflt ){
    sqlite3_value *pVal = 0;
    int rc;
    rc = sqlite3ValueFromExpr(db, pDflt, 1, 0x41, &pVal);
    ((void)0);
    if( rc!=0 ){
      ((void)0);
      return;
    }
    if( !pVal ){
      sqlite3ErrorMsg(pParse, "Cannot add a column with non-constant default");
      return;
    }
    sqlite3ValueFree(pVal);
  }


  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);
  if( zCol ){
    char *zEnd = &zCol[pColDef->n-1];
    u32 savedDbFlags = db->mDbFlags;
    while( zEnd>zCol && (*zEnd==';' || (sqlite3CtypeMap[(unsigned char)(*zEnd)]&0x01)) ){
      *zEnd-- = '\0';
    }
    db->mDbFlags |= 0x0002;
    sqlite3NestedParse(pParse,
        "UPDATE \"%w\".%s SET "
          "sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) "
        "WHERE type = 'table' AND name = %Q",
      zDb, "sqlite_master", pNew->addColOffset, zCol, pNew->addColOffset+1,
      zTab
    );
    sqlite3DbFree(db, zCol);
    db->mDbFlags = savedDbFlags;
  }





  v = sqlite3GetVdbe(pParse);
  if( v ){
    r1 = sqlite3GetTempReg(pParse);
    sqlite3VdbeAddOp3(v, 94, iDb, r1, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    sqlite3VdbeAddOp2(v, 83, r1, -2);
    sqlite3VdbeAddOp2(v, 47, r1, sqlite3VdbeCurrentAddr(v)+2);
    ;
    sqlite3VdbeAddOp3(v, 95, iDb, 2, 3);
    sqlite3ReleaseTempReg(pParse, r1);
  }


  renameReloadSchema(pParse, iDb);
}
# 103588 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){
  Table *pNew;
  Table *pTab;
  int iDb;
  int i;
  int nAlloc;
  sqlite3 *db = pParse->db;


  ((void)0);
  ((void)0);
  if( db->mallocFailed ) goto exit_begin_add_column;
  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) goto exit_begin_add_column;


  if( ((pTab)->nModuleArg) ){
    sqlite3ErrorMsg(pParse, "virtual tables may not be altered");
    goto exit_begin_add_column;
  }



  if( pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "Cannot add a column to a view");
    goto exit_begin_add_column;
  }
  if( 0!=isAlterableTable(pParse, pTab) ){
    goto exit_begin_add_column;
  }

  sqlite3MayAbort(pParse);
  ((void)0);
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
# 103630 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));
  if( !pNew ) goto exit_begin_add_column;
  pParse->pNewTable = pNew;
  pNew->nTabRef = 1;
  pNew->nCol = pTab->nCol;
  ((void)0);
  nAlloc = (((pNew->nCol-1)/8)*8)+8;
  ((void)0);
  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);
  pNew->zName = sqlite3MPrintf(db, "sqlite_altertab_%s", pTab->zName);
  if( !pNew->aCol || !pNew->zName ){
    ((void)0);
    goto exit_begin_add_column;
  }
  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);
  for(i=0; i<pNew->nCol; i++){
    Column *pCol = &pNew->aCol[i];
    pCol->zName = sqlite3DbStrDup(db, pCol->zName);
    pCol->zColl = 0;
    pCol->pDflt = 0;
  }
  pNew->pSchema = db->aDb[iDb].pSchema;
  pNew->addColOffset = pTab->addColOffset;
  pNew->nTabRef = 1;

exit_begin_add_column:
  sqlite3SrcListDelete(db, pSrc);
  return;
}
# 103669 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isRealTable(Parse *pParse, Table *pTab){
  const char *zType = 0;

  if( pTab->pSelect ){
    zType = "view";
  }


  if( ((pTab)->nModuleArg) ){
    zType = "virtual table";
  }

  if( zType ){
    sqlite3ErrorMsg(
        pParse, "cannot rename columns of %s \"%s\"", zType, pTab->zName
    );
    return 1;
  }
  return 0;
}
# 103698 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3AlterRenameColumn(
  Parse *pParse,
  SrcList *pSrc,
  Token *pOld,
  Token *pNew
){
  sqlite3 *db = pParse->db;
  Table *pTab;
  int iCol;
  char *zOld = 0;
  char *zNew = 0;
  const char *zDb;
  int iSchema;
  int bQuote;


  pTab = sqlite3LocateTableItem(pParse, 0, &pSrc->a[0]);
  if( !pTab ) goto exit_rename_column;


  if( 0!=isAlterableTable(pParse, pTab) ) goto exit_rename_column;
  if( 0!=isRealTable(pParse, pTab) ) goto exit_rename_column;


  iSchema = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void)0);
  zDb = db->aDb[iSchema].zDbSName;



  if( sqlite3AuthCheck(pParse, 26, zDb, pTab->zName, 0) ){
    goto exit_rename_column;
  }




  zOld = sqlite3NameFromToken(db, pOld);
  if( !zOld ) goto exit_rename_column;
  for(iCol=0; iCol<pTab->nCol; iCol++){
    if( 0==sqlite3StrICmp(pTab->aCol[iCol].zName, zOld) ) break;
  }
  if( iCol==pTab->nCol ){
    sqlite3ErrorMsg(pParse, "no such column: \"%s\"", zOld);
    goto exit_rename_column;
  }





  sqlite3MayAbort(pParse);
  zNew = sqlite3NameFromToken(db, pNew);
  if( !zNew ) goto exit_rename_column;
  ((void)0);
  bQuote = (sqlite3CtypeMap[(unsigned char)(pNew->z[0])]&0x80);
  sqlite3NestedParse(pParse,
      "UPDATE \"%w\".%s SET "
      "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, %d) "
      "WHERE name NOT LIKE 'sqliteX_%%' ESCAPE 'X' "
      " AND (type != 'index' OR tbl_name = %Q)"
      " AND sql NOT LIKE 'create virtual%%'",
      zDb, "sqlite_master",
      zDb, pTab->zName, iCol, zNew, bQuote, iSchema==1,
      pTab->zName
  );

  sqlite3NestedParse(pParse,
      "UPDATE temp.%s SET "
      "sql = sqlite_rename_column(sql, type, name, %Q, %Q, %d, %Q, %d, 1) "
      "WHERE type IN ('trigger', 'view')",
      "sqlite_master",
      zDb, pTab->zName, iCol, zNew, bQuote
  );


  renameReloadSchema(pParse, iSchema);
  renameTestSchema(pParse, zDb, iSchema==1);

 exit_rename_column:
  sqlite3SrcListDelete(db, pSrc);
  sqlite3DbFree(db, zOld);
  sqlite3DbFree(db, zNew);
  return;
}
# 103801 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct RenameToken {
  void *p;
  Token t;
  RenameToken *pNext;
};





typedef struct RenameCtx RenameCtx;
struct RenameCtx {
  RenameToken *pList;
  int nList;
  int iCol;
  Table *pTab;
  const char *zOld;
};
# 103857 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define renameTokenCheckAll(x,y) 
# 103872 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3RenameTokenMap(Parse *pParse, void *pPtr, Token *pToken){
  RenameToken *pNew;
  ((void)0);
  ;
  pNew = sqlite3DbMallocZero(pParse->db, sizeof(RenameToken));
  if( pNew ){
    pNew->p = pPtr;
    pNew->t = *pToken;
    pNew->pNext = pParse->pRename;
    pParse->pRename = pNew;
  }

  return pPtr;
}






static void sqlite3RenameTokenRemap(Parse *pParse, void *pTo, void *pFrom){
  RenameToken *p;
  ;
  for(p=pParse->pRename; p; p=p->pNext){
    if( p->p==pFrom ){
      p->p = pTo;
      break;
    }
  }
}




static int renameUnmapExprCb(Walker *pWalker, Expr *pExpr){
  Parse *pParse = pWalker->pParse;
  sqlite3RenameTokenRemap(pParse, 0, (void*)pExpr);
  return 0;
}




static int renameUnmapSelectCb(Walker *pWalker, Select *p){
  Parse *pParse = pWalker->pParse;
  int i;
  if( (p->pEList) ){
    ExprList *pList = p->pEList;
    for(i=0; i<pList->nExpr; i++){
      if( pList->a[i].zName ){
        sqlite3RenameTokenRemap(pParse, 0, (void*)pList->a[i].zName);
      }
    }
  }
  if( (p->pSrc) ){
    SrcList *pSrc = p->pSrc;
    for(i=0; i<pSrc->nSrc; i++){
      sqlite3RenameTokenRemap(pParse, 0, (void*)pSrc->a[i].zName);
    }
  }
  return 0;
}




static void sqlite3RenameExprUnmap(Parse *pParse, Expr *pExpr){
  Walker sWalker;
  memset(&sWalker, 0, sizeof(Walker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = renameUnmapExprCb;
  sWalker.xSelectCallback = renameUnmapSelectCb;
  sqlite3WalkExpr(&sWalker, pExpr);
}





static void sqlite3RenameExprlistUnmap(Parse *pParse, ExprList *pEList){
  if( pEList ){
    int i;
    Walker sWalker;
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.pParse = pParse;
    sWalker.xExprCallback = renameUnmapExprCb;
    sqlite3WalkExprList(&sWalker, pEList);
    for(i=0; i<pEList->nExpr; i++){
      sqlite3RenameTokenRemap(pParse, 0, (void*)pEList->a[i].zName);
    }
  }
}




static void renameTokenFree(sqlite3 *db, RenameToken *pToken){
  RenameToken *pNext;
  RenameToken *p;
  for(p=pToken; p; p=pNext){
    pNext = p->pNext;
    sqlite3DbFree(db, p);
  }
}







static void renameTokenFind(Parse *pParse, struct RenameCtx *pCtx, void *pPtr){
  RenameToken **pp;
  ((void)0);
  for(pp=&pParse->pRename; (*pp); pp=&(*pp)->pNext){
    if( (*pp)->p==pPtr ){
      RenameToken *pToken = *pp;
      *pp = pToken->pNext;
      pToken->pNext = pCtx->pList;
      pCtx->pList = pToken;
      pCtx->nList++;
      break;
    }
  }
}





static void renameWalkWith(Walker *pWalker, Select *pSelect){
  if( pSelect->pWith ){
    int i;
    for(i=0; i<pSelect->pWith->nCte; i++){
      Select *p = pSelect->pWith->a[i].pSelect;
      NameContext sNC;
      memset(&sNC, 0, sizeof(sNC));
      sNC.pParse = pWalker->pParse;
      sqlite3SelectPrep(sNC.pParse, p, &sNC);
      sqlite3WalkSelect(pWalker, p);
    }
  }
}






static int renameColumnSelectCb(Walker *pWalker, Select *p){
  renameWalkWith(pWalker, p);
  return 0;
}
# 104035 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int renameColumnExprCb(Walker *pWalker, Expr *pExpr){
  RenameCtx *p = pWalker->u.pRename;
  if( pExpr->op==77
   && pExpr->iColumn==p->iCol
   && pWalker->pParse->pTriggerTab==p->pTab
  ){
    renameTokenFind(pWalker->pParse, p, (void*)pExpr);
  }else if( pExpr->op==162
   && pExpr->iColumn==p->iCol
   && p->pTab==pExpr->y.pTab
  ){
    renameTokenFind(pWalker->pParse, p, (void*)pExpr);
  }
  return 0;
}
# 104060 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static RenameToken *renameColumnTokenNext(RenameCtx *pCtx){
  RenameToken *pBest = pCtx->pList;
  RenameToken *pToken;
  RenameToken **pp;

  for(pToken=pBest->pNext; pToken; pToken=pToken->pNext){
    if( pToken->t.z>pBest->t.z ) pBest = pToken;
  }
  for(pp=&pCtx->pList; *pp!=pBest; pp=&(*pp)->pNext);
  *pp = pBest->pNext;

  return pBest;
}
# 104081 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void renameColumnParseError(
  sqlite3_context *pCtx,
  int bPost,
  sqlite3_value *pType,
  sqlite3_value *pObject,
  Parse *pParse
){
  const char *zT = (const char*)sqlite3_value_text(pType);
  const char *zN = (const char*)sqlite3_value_text(pObject);
  char *zErr;

  zErr = sqlite3_mprintf("error in %s %s%s: %s",
      zT, zN, (bPost ? " after rename" : ""),
      pParse->zErrMsg
  );
  sqlite3_result_error(pCtx, zErr, -1);
  sqlite3_free(zErr);
}







static void renameColumnElistNames(
  Parse *pParse,
  RenameCtx *pCtx,
  ExprList *pEList,
  const char *zOld
){
  if( pEList ){
    int i;
    for(i=0; i<pEList->nExpr; i++){
      char *zName = pEList->a[i].zName;
      if( 0==sqlite3_stricmp(zName, zOld) ){
        renameTokenFind(pParse, pCtx, (void*)zName);
      }
    }
  }
}






static void renameColumnIdlistNames(
  Parse *pParse,
  RenameCtx *pCtx,
  IdList *pIdList,
  const char *zOld
){
  if( pIdList ){
    int i;
    for(i=0; i<pIdList->nId; i++){
      char *zName = pIdList->a[i].zName;
      if( 0==sqlite3_stricmp(zName, zOld) ){
        renameTokenFind(pParse, pCtx, (void*)zName);
      }
    }
  }
}





static int renameParseSql(
  Parse *p,
  const char *zDb,
  int bTable,
  sqlite3 *db,
  const char *zSql,
  int bTemp
){
  int rc;
  char *zErr = 0;

  db->init.iDb = bTemp ? 1 : sqlite3FindDbName(db, zDb);




  memset(p, 0, sizeof(Parse));
  p->eParseMode = (bTable ? 3 : 2);
  p->db = db;
  p->nQueryLoop = 1;
  rc = sqlite3RunParser(p, zSql, &zErr);
  ((void)0);
  ((void)0);
  p->zErrMsg = zErr;
  if( db->mallocFailed ) rc = 7;
  if( rc==0
   && p->pNewTable==0 && p->pNewIndex==0 && p->pNewTrigger==0
  ){
    rc = sqlite3CorruptError(104177);
  }
# 104192 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  db->init.iDb = 0;
  return rc;
}
# 104205 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int renameEditSql(
  sqlite3_context *pCtx,
  RenameCtx *pRename,
  const char *zSql,
  const char *zNew,
  int bQuote
){
  int nNew = sqlite3Strlen30(zNew);
  int nSql = sqlite3Strlen30(zSql);
  sqlite3 *db = sqlite3_context_db_handle(pCtx);
  int rc = 0;
  char *zQuot;
  char *zOut;
  int nQuot;






  zQuot = sqlite3MPrintf(db, "\"%w\"", zNew);
  if( zQuot==0 ){
    return 7;
  }else{
    nQuot = sqlite3Strlen30(zQuot);
  }
  if( bQuote ){
    zNew = zQuot;
    nNew = nQuot;
  }





  ((void)0);
  zOut = sqlite3DbMallocZero(db, nSql + pRename->nList*nQuot + 1);
  if( zOut ){
    int nOut = nSql;
    memcpy(zOut, zSql, nSql);
    while( pRename->pList ){
      int iOff;
      RenameToken *pBest = renameColumnTokenNext(pRename);

      u32 nReplace;
      const char *zReplace;
      if( sqlite3IsIdChar(*pBest->t.z) ){
        nReplace = nNew;
        zReplace = zNew;
      }else{
        nReplace = nQuot;
        zReplace = zQuot;
      }

      iOff = pBest->t.z - zSql;
      if( pBest->t.n!=nReplace ){
        memmove(&zOut[iOff + nReplace], &zOut[iOff + pBest->t.n],
            nOut - (iOff + pBest->t.n)
        );
        nOut += nReplace - pBest->t.n;
        zOut[nOut] = '\0';
      }
      memcpy(&zOut[iOff], zReplace, nReplace);
      sqlite3DbFree(db, pBest);
    }

    sqlite3_result_text(pCtx, zOut, -1, ((sqlite3_destructor_type)-1));
    sqlite3DbFree(db, zOut);
  }else{
    rc = 7;
  }

  sqlite3_free(zQuot);
  return rc;
}







static int renameResolveTrigger(Parse *pParse, const char *zDb){
  sqlite3 *db = pParse->db;
  Trigger *pNew = pParse->pNewTrigger;
  TriggerStep *pStep;
  NameContext sNC;
  int rc = 0;

  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  ((void)0);
  pParse->pTriggerTab = sqlite3FindTable(db, pNew->table,
      db->aDb[sqlite3SchemaToIndex(db, pNew->pTabSchema)].zDbSName
  );
  pParse->eTriggerOp = pNew->op;


  if( (pParse->pTriggerTab) ){
    rc = sqlite3ViewGetColumnNames(pParse, pParse->pTriggerTab);
  }


  if( rc==0 && pNew->pWhen ){
    rc = sqlite3ResolveExprNames(&sNC, pNew->pWhen);
  }

  for(pStep=pNew->step_list; rc==0 && pStep; pStep=pStep->pNext){
    if( pStep->pSelect ){
      sqlite3SelectPrep(pParse, pStep->pSelect, &sNC);
      if( pParse->nErr ) rc = pParse->rc;
    }
    if( rc==0 && pStep->zTarget ){
      Table *pTarget = sqlite3LocateTable(pParse, 0, pStep->zTarget, zDb);
      if( pTarget==0 ){
        rc = 1;
      }else if( 0==(rc = sqlite3ViewGetColumnNames(pParse, pTarget)) ){
        SrcList sSrc;
        memset(&sSrc, 0, sizeof(sSrc));
        sSrc.nSrc = 1;
        sSrc.a[0].zName = pStep->zTarget;
        sSrc.a[0].pTab = pTarget;
        sNC.pSrcList = &sSrc;
        if( pStep->pWhere ){
          rc = sqlite3ResolveExprNames(&sNC, pStep->pWhere);
        }
        if( rc==0 ){
          rc = sqlite3ResolveExprListNames(&sNC, pStep->pExprList);
        }
        ((void)0);
        if( pStep->pUpsert ){
          Upsert *pUpsert = pStep->pUpsert;
          ((void)0);
          pUpsert->pUpsertSrc = &sSrc;
          sNC.uNC.pUpsert = pUpsert;
          sNC.ncFlags = 0x0200;
          rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);
          if( rc==0 ){
            ExprList *pUpsertSet = pUpsert->pUpsertSet;
            rc = sqlite3ResolveExprListNames(&sNC, pUpsertSet);
          }
          if( rc==0 ){
            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertWhere);
          }
          if( rc==0 ){
            rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);
          }
          sNC.ncFlags = 0;
        }
        sNC.pSrcList = 0;
      }
    }
  }
  return rc;
}





static void renameWalkTrigger(Walker *pWalker, Trigger *pTrigger){
  TriggerStep *pStep;


  sqlite3WalkExpr(pWalker, pTrigger->pWhen);


  for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){
    sqlite3WalkSelect(pWalker, pStep->pSelect);
    sqlite3WalkExpr(pWalker, pStep->pWhere);
    sqlite3WalkExprList(pWalker, pStep->pExprList);
    if( pStep->pUpsert ){
      Upsert *pUpsert = pStep->pUpsert;
      sqlite3WalkExprList(pWalker, pUpsert->pUpsertTarget);
      sqlite3WalkExprList(pWalker, pUpsert->pUpsertSet);
      sqlite3WalkExpr(pWalker, pUpsert->pUpsertWhere);
      sqlite3WalkExpr(pWalker, pUpsert->pUpsertTargetWhere);
    }
  }
}





static void renameParseCleanup(Parse *pParse){
  sqlite3 *db = pParse->db;
  Index *pIdx;
  if( pParse->pVdbe ){
    sqlite3VdbeFinalize(pParse->pVdbe);
  }
  sqlite3DeleteTable(db, pParse->pNewTable);
  while( (pIdx = pParse->pNewIndex)!=0 ){
    pParse->pNewIndex = pIdx->pNext;
    sqlite3FreeIndex(db, pIdx);
  }
  sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  sqlite3DbFree(db, pParse->zErrMsg);
  renameTokenFree(db, pParse->pRename);
  sqlite3ParserReset(pParse);
}
# 104430 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void renameColumnFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  RenameCtx sCtx;
  const char *zSql = (const char*)sqlite3_value_text(argv[0]);
  const char *zDb = (const char*)sqlite3_value_text(argv[3]);
  const char *zTable = (const char*)sqlite3_value_text(argv[4]);
  int iCol = sqlite3_value_int(argv[5]);
  const char *zNew = (const char*)sqlite3_value_text(argv[6]);
  int bQuote = sqlite3_value_int(argv[7]);
  int bTemp = sqlite3_value_int(argv[8]);
  const char *zOld;
  int rc;
  Parse sParse;
  Walker sWalker;
  Index *pIdx;
  int i;
  Table *pTab;

  sqlite3_xauth xAuth = db->xAuth;


  (void)(NotUsed);
  if( zSql==0 ) return;
  if( zTable==0 ) return;
  if( zNew==0 ) return;
  if( iCol<0 ) return;
  sqlite3BtreeEnterAll(db);
  pTab = sqlite3FindTable(db, zTable, zDb);
  if( pTab==0 || iCol>=pTab->nCol ){
    sqlite3BtreeLeaveAll(db);
    return;
  }
  zOld = pTab->aCol[iCol].zName;
  memset(&sCtx, 0, sizeof(sCtx));
  sCtx.iCol = ((iCol==pTab->iPKey) ? -1 : iCol);


  db->xAuth = 0;

  rc = renameParseSql(&sParse, zDb, 0, db, zSql, bTemp);


  memset(&sWalker, 0, sizeof(Walker));
  sWalker.pParse = &sParse;
  sWalker.xExprCallback = renameColumnExprCb;
  sWalker.xSelectCallback = renameColumnSelectCb;
  sWalker.u.pRename = &sCtx;

  sCtx.pTab = pTab;
  if( rc!=0 ) goto renameColumnFunc_done;
  if( sParse.pNewTable ){
    Select *pSelect = sParse.pNewTable->pSelect;
    if( pSelect ){
      sParse.rc = 0;
      sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, 0);
      rc = (db->mallocFailed ? 7 : sParse.rc);
      if( rc==0 ){
        sqlite3WalkSelect(&sWalker, pSelect);
      }
      if( rc!=0 ) goto renameColumnFunc_done;
    }else{

      int bFKOnly = sqlite3_stricmp(zTable, sParse.pNewTable->zName);
      FKey *pFKey;
      ((void)0);
      sCtx.pTab = sParse.pNewTable;
      if( bFKOnly==0 ){
        renameTokenFind(
            &sParse, &sCtx, (void*)sParse.pNewTable->aCol[iCol].zName
        );
        if( sCtx.iCol<0 ){
          renameTokenFind(&sParse, &sCtx, (void*)&sParse.pNewTable->iPKey);
        }
        sqlite3WalkExprList(&sWalker, sParse.pNewTable->pCheck);
        for(pIdx=sParse.pNewTable->pIndex; pIdx; pIdx=pIdx->pNext){
          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);
        }
        for(pIdx=sParse.pNewIndex; pIdx; pIdx=pIdx->pNext){
          sqlite3WalkExprList(&sWalker, pIdx->aColExpr);
        }
      }

      for(pFKey=sParse.pNewTable->pFKey; pFKey; pFKey=pFKey->pNextFrom){
        for(i=0; i<pFKey->nCol; i++){
          if( bFKOnly==0 && pFKey->aCol[i].iFrom==iCol ){
            renameTokenFind(&sParse, &sCtx, (void*)&pFKey->aCol[i]);
          }
          if( 0==sqlite3_stricmp(pFKey->zTo, zTable)
           && 0==sqlite3_stricmp(pFKey->aCol[i].zCol, zOld)
          ){
            renameTokenFind(&sParse, &sCtx, (void*)pFKey->aCol[i].zCol);
          }
        }
      }
    }
  }else if( sParse.pNewIndex ){
    sqlite3WalkExprList(&sWalker, sParse.pNewIndex->aColExpr);
    sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
  }else{

    TriggerStep *pStep;
    rc = renameResolveTrigger(&sParse, (bTemp ? 0 : zDb));
    if( rc!=0 ) goto renameColumnFunc_done;

    for(pStep=sParse.pNewTrigger->step_list; pStep; pStep=pStep->pNext){
      if( pStep->zTarget ){
        Table *pTarget = sqlite3LocateTable(&sParse, 0, pStep->zTarget, zDb);
        if( pTarget==pTab ){
          if( pStep->pUpsert ){
            ExprList *pUpsertSet = pStep->pUpsert->pUpsertSet;
            renameColumnElistNames(&sParse, &sCtx, pUpsertSet, zOld);
          }
          renameColumnIdlistNames(&sParse, &sCtx, pStep->pIdList, zOld);
          renameColumnElistNames(&sParse, &sCtx, pStep->pExprList, zOld);
        }
      }
    }



    if( sParse.pTriggerTab==pTab ){
      renameColumnIdlistNames(&sParse, &sCtx,sParse.pNewTrigger->pColumns,zOld);
    }


    renameWalkTrigger(&sWalker, sParse.pNewTrigger);
  }

  ((void)0);
  rc = renameEditSql(context, &sCtx, zSql, zNew, bQuote);

renameColumnFunc_done:
  if( rc!=0 ){
    if( sParse.zErrMsg ){
      renameColumnParseError(context, 0, argv[1], argv[2], &sParse);
    }else{
      sqlite3_result_error_code(context, rc);
    }
  }

  renameParseCleanup(&sParse);
  renameTokenFree(db, sCtx.pList);

  db->xAuth = xAuth;

  sqlite3BtreeLeaveAll(db);
}




static int renameTableExprCb(Walker *pWalker, Expr *pExpr){
  RenameCtx *p = pWalker->u.pRename;
  if( pExpr->op==162 && p->pTab==pExpr->y.pTab ){
    renameTokenFind(pWalker->pParse, p, (void*)&pExpr->y.pTab);
  }
  return 0;
}




static int renameTableSelectCb(Walker *pWalker, Select *pSelect){
  int i;
  RenameCtx *p = pWalker->u.pRename;
  SrcList *pSrc = pSelect->pSrc;
  if( pSrc==0 ){
    ((void)0);
    return 2;
  }
  for(i=0; i<pSrc->nSrc; i++){
    struct SrcList_item *pItem = &pSrc->a[i];
    if( pItem->pTab==p->pTab ){
      renameTokenFind(pWalker->pParse, p, pItem->zName);
    }
  }
  renameWalkWith(pWalker, pSelect);

  return 0;
}
# 104635 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void renameTableFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  const char *zDb = (const char*)sqlite3_value_text(argv[0]);
  const char *zInput = (const char*)sqlite3_value_text(argv[3]);
  const char *zOld = (const char*)sqlite3_value_text(argv[4]);
  const char *zNew = (const char*)sqlite3_value_text(argv[5]);
  int bTemp = sqlite3_value_int(argv[6]);
  (void)(NotUsed);

  if( zInput && zOld && zNew ){
    Parse sParse;
    int rc;
    int bQuote = 1;
    RenameCtx sCtx;
    Walker sWalker;


    sqlite3_xauth xAuth = db->xAuth;
    db->xAuth = 0;


    sqlite3BtreeEnterAll(db);

    memset(&sCtx, 0, sizeof(RenameCtx));
    sCtx.pTab = sqlite3FindTable(db, zOld, zDb);
    memset(&sWalker, 0, sizeof(Walker));
    sWalker.pParse = &sParse;
    sWalker.xExprCallback = renameTableExprCb;
    sWalker.xSelectCallback = renameTableSelectCb;
    sWalker.u.pRename = &sCtx;

    rc = renameParseSql(&sParse, zDb, 1, db, zInput, bTemp);

    if( rc==0 ){
      int isLegacy = (db->flags & 0x04000000);
      if( sParse.pNewTable ){
        Table *pTab = sParse.pNewTable;

        if( pTab->pSelect ){
          if( isLegacy==0 ){
            NameContext sNC;
            memset(&sNC, 0, sizeof(sNC));
            sNC.pParse = &sParse;

            sqlite3SelectPrep(&sParse, pTab->pSelect, &sNC);
            if( sParse.nErr ) rc = sParse.rc;
            sqlite3WalkSelect(&sWalker, pTab->pSelect);
          }
        }else{


          if( isLegacy==0 || (db->flags & 0x00004000) ){
            FKey *pFKey;
            for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){
              if( sqlite3_stricmp(pFKey->zTo, zOld)==0 ){
                renameTokenFind(&sParse, &sCtx, (void*)pFKey->zTo);
              }
            }
          }





          if( sqlite3_stricmp(zOld, pTab->zName)==0 ){
            sCtx.pTab = pTab;
            if( isLegacy==0 ){
              sqlite3WalkExprList(&sWalker, pTab->pCheck);
            }
            renameTokenFind(&sParse, &sCtx, pTab->zName);
          }
        }
      }

      else if( sParse.pNewIndex ){
        renameTokenFind(&sParse, &sCtx, sParse.pNewIndex->zName);
        if( isLegacy==0 ){
          sqlite3WalkExpr(&sWalker, sParse.pNewIndex->pPartIdxWhere);
        }
      }


      else{
        Trigger *pTrigger = sParse.pNewTrigger;
        TriggerStep *pStep;
        if( 0==sqlite3_stricmp(sParse.pNewTrigger->table, zOld)
            && sCtx.pTab->pSchema==pTrigger->pTabSchema
          ){
          renameTokenFind(&sParse, &sCtx, sParse.pNewTrigger->table);
        }

        if( isLegacy==0 ){
          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);
          if( rc==0 ){
            renameWalkTrigger(&sWalker, pTrigger);
            for(pStep=pTrigger->step_list; pStep; pStep=pStep->pNext){
              if( pStep->zTarget && 0==sqlite3_stricmp(pStep->zTarget, zOld) ){
                renameTokenFind(&sParse, &sCtx, pStep->zTarget);
              }
            }
          }
        }
      }

    }

    if( rc==0 ){
      rc = renameEditSql(context, &sCtx, zInput, zNew, bQuote);
    }
    if( rc!=0 ){
      if( sParse.zErrMsg ){
        renameColumnParseError(context, 0, argv[1], argv[2], &sParse);
      }else{
        sqlite3_result_error_code(context, rc);
      }
    }

    renameParseCleanup(&sParse);
    renameTokenFree(db, sCtx.pList);
    sqlite3BtreeLeaveAll(db);

    db->xAuth = xAuth;

  }

  return;
}
# 104786 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void renameTableTest(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  char const *zDb = (const char*)sqlite3_value_text(argv[0]);
  char const *zInput = (const char*)sqlite3_value_text(argv[1]);
  int bTemp = sqlite3_value_int(argv[4]);
  int isLegacy = (db->flags & 0x04000000);


  sqlite3_xauth xAuth = db->xAuth;
  db->xAuth = 0;


  (void)(NotUsed);
  if( zDb && zInput ){
    int rc;
    Parse sParse;
    rc = renameParseSql(&sParse, zDb, 1, db, zInput, bTemp);
    if( rc==0 ){
      if( isLegacy==0 && sParse.pNewTable && sParse.pNewTable->pSelect ){
        NameContext sNC;
        memset(&sNC, 0, sizeof(sNC));
        sNC.pParse = &sParse;
        sqlite3SelectPrep(&sParse, sParse.pNewTable->pSelect, &sNC);
        if( sParse.nErr ) rc = sParse.rc;
      }

      else if( sParse.pNewTrigger ){
        if( isLegacy==0 ){
          rc = renameResolveTrigger(&sParse, bTemp ? 0 : zDb);
        }
        if( rc==0 ){
          int i1 = sqlite3SchemaToIndex(db, sParse.pNewTrigger->pTabSchema);
          int i2 = sqlite3FindDbName(db, zDb);
          if( i1==i2 ) sqlite3_result_int(context, 1);
        }
      }
    }

    if( rc!=0 ){
      renameColumnParseError(context, 1, argv[2], argv[3], &sParse);
    }
    renameParseCleanup(&sParse);
  }


  db->xAuth = xAuth;

}




static void sqlite3AlterFunctions(void){
  static FuncDef aAlterTableFuncs[] = {
    {9, 0x00040000|1|0x0800, 0, 0, renameColumnFunc, 0, 0, 0, "sqlite_rename_column", {0} },
    {7, 0x00040000|1|0x0800, 0, 0, renameTableFunc, 0, 0, 0, "sqlite_rename_table", {0} },
    {5, 0x00040000|1|0x0800, 0, 0, renameTableTest, 0, 0, 0, "sqlite_rename_test", {0} },
  };
  sqlite3InsertBuiltinFuncs(aAlterTableFuncs, ((int)(sizeof(aAlterTableFuncs)/sizeof(aAlterTableFuncs[0]))));
}
# 105001 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IsStat4 0
#undef SQLITE_STAT4_SAMPLES
#define SQLITE_STAT4_SAMPLES 1
# 105019 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void openStatTable(
  Parse *pParse,
  int iDb,
  int iStatCur,
  const char *zWhere,
  const char *zWhereType
){
  static const struct {
    const char *zName;
    const char *zCols;
  } aTable[] = {
    { "sqlite_stat1", "tbl,idx,stat" },



    { "sqlite_stat4", 0 },

    { "sqlite_stat3", 0 },
  };
  int i;
  sqlite3 *db = pParse->db;
  Db *pDb;
  Vdbe *v = sqlite3GetVdbe(pParse);
  int aRoot[((int)(sizeof(aTable)/sizeof(aTable[0])))];
  u8 aCreateTbl[((int)(sizeof(aTable)/sizeof(aTable[0])))];

  if( v==0 ) return;
  ((void)0);
  ((void)0);
  pDb = &db->aDb[iDb];




  for(i=0; i<((int)(sizeof(aTable)/sizeof(aTable[0]))); i++){
    const char *zTab = aTable[i].zName;
    Table *pStat;
    if( (pStat = sqlite3FindTable(db, zTab, pDb->zDbSName))==0 ){
      if( aTable[i].zCols ){




        sqlite3NestedParse(pParse,
            "CREATE TABLE %Q.%s(%s)", pDb->zDbSName, zTab, aTable[i].zCols
        );
        aRoot[i] = pParse->regRoot;
        aCreateTbl[i] = 0x10;
      }
    }else{



      aRoot[i] = pStat->tnum;
      aCreateTbl[i] = 0;
      sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);
      if( zWhere ){
        sqlite3NestedParse(pParse,
           "DELETE FROM %Q.%s WHERE %s=%Q",
           pDb->zDbSName, zTab, zWhereType, zWhere
        );




      }else{

        sqlite3VdbeAddOp2(v, 137, aRoot[i], iDb);
      }
    }
  }


  for(i=0; aTable[i].zCols; i++){
    ((void)0);
    sqlite3VdbeAddOp4Int(v, 98, iStatCur+i, aRoot[i], iDb, 3);
    sqlite3VdbeChangeP5(v, aCreateTbl[i]);
    ;
  }
}
# 105112 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct Stat4Accum Stat4Accum;
typedef struct Stat4Sample Stat4Sample;
struct Stat4Sample {
  tRowcnt *anEq;
  tRowcnt *anDLt;
# 105128 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};
struct Stat4Accum {
  tRowcnt nRow;
  tRowcnt nPSample;
  int nCol;
  int nKeyCol;
  int mxSample;
  Stat4Sample current;
  u32 iPrn;
  Stat4Sample *aBest;
  int iMin;
  int nSample;
  int nMaxEqZero;
  int iGet;
  Stat4Sample *a;
  sqlite3 *db;
};
# 105208 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void stat4Destructor(void *pOld){
  Stat4Accum *p = (Stat4Accum*)pOld;






  sqlite3DbFree(p->db, p);
}
# 105242 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void statInit(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  Stat4Accum *p;
  int nCol;
  int nKeyCol;
  int nColUp;
  int n;
  sqlite3 *db;





  (void)(argc);
  nCol = sqlite3_value_int(argv[0]);
  ((void)0);
  nColUp = sizeof(tRowcnt)<8 ? (nCol+1)&~1 : nCol;
  nKeyCol = sqlite3_value_int(argv[1]);
  ((void)0);
  ((void)0);


  n = sizeof(*p)
    + sizeof(tRowcnt)*nColUp
    + sizeof(tRowcnt)*nColUp





  ;
  db = sqlite3_context_db_handle(context);
  p = sqlite3DbMallocZero(db, n);
  if( p==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }

  p->db = db;
  p->nRow = 0;
  p->nCol = nCol;
  p->nKeyCol = nKeyCol;
  p->current.anDLt = (tRowcnt*)&p[1];
  p->current.anEq = &p->current.anDLt[nColUp];
# 105322 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_result_blob(context, p, sizeof(*p), stat4Destructor);
}
static const FuncDef statInitFuncdef = {
  2+0,
  1,
  0,
  0,
  statInit,
  0,
  0, 0,
  "stat_init",
  {0}
};
# 105486 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void samplePushPrevious(Stat4Accum *p, int iChng){
# 105520 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(p);
  (void)(iChng);

}
# 105541 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void statPush(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i;


  Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);
  int iChng = sqlite3_value_int(argv[1]);

  (void)(argc);
  (void)(context);
  ((void)0);
  ((void)0);

  if( p->nRow==0 ){

    for(i=0; i<p->nCol; i++) p->current.anEq[i] = 1;
  }else{

    samplePushPrevious(p, iChng);



    for(i=0; i<iChng; i++){
      p->current.anEq[i]++;
    }
    for(i=iChng; i<p->nCol; i++){
      p->current.anDLt[i]++;



      p->current.anEq[i] = 1;
    }
  }
  p->nRow++;
# 105609 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
static const FuncDef statPushFuncdef = {
  2+0,
  1,
  0,
  0,
  statPush,
  0,
  0, 0,
  "stat_push",
  {0}
};

#define STAT_GET_STAT1 0
#define STAT_GET_ROWID 1
#define STAT_GET_NEQ 2
#define STAT_GET_NLT 3
#define STAT_GET_NDLT 4
# 105647 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void statGet(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  Stat4Accum *p = (Stat4Accum*)sqlite3_value_blob(argv[0]);
# 105663 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);

  {
# 105687 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    char *z;
    int i;

    char *zRet = sqlite3MallocZero( (p->nKeyCol+1)*25 );
    if( zRet==0 ){
      sqlite3_result_error_nomem(context);
      return;
    }

    sqlite3_snprintf(24, zRet, "%llu", (u64)p->nRow);
    z = zRet + sqlite3Strlen30(zRet);
    for(i=0; i<p->nKeyCol; i++){
      u64 nDistinct = p->current.anDLt[i] + 1;
      u64 iVal = (p->nRow + nDistinct - 1) / nDistinct;
      sqlite3_snprintf(24, z, " %llu", iVal);
      z += sqlite3Strlen30(z);
      ((void)0);
    }
    ((void)0);

    sqlite3_result_text(context, zRet, -1, sqlite3_free);
  }
# 105757 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(argc);

}
static const FuncDef statGetFuncdef = {
  1+0,
  1,
  0,
  0,
  statGet,
  0,
  0, 0,
  "stat_get",
  {0}
};

static void callStatGet(Vdbe *v, int regStat4, int iParam, int regOut){
  ((void)0);





  (void)(iParam);

  sqlite3VdbeAddOp4(v, 63, 0, regStat4, regOut,
                    (char*)&statGetFuncdef, (-8));
  sqlite3VdbeChangeP5(v, 1 + 0);
}





static void analyzeOneTable(
  Parse *pParse,
  Table *pTab,
  Index *pOnlyIdx,
  int iStatCur,
  int iMem,
  int iTab
){
  sqlite3 *db = pParse->db;
  Index *pIdx;
  int iIdxCur;
  int iTabCur;
  Vdbe *v;
  int i;
  int jZeroRows = -1;
  int iDb;
  u8 needTableCnt = 1;
  int regNewRowid = iMem++;
  int regStat4 = iMem++;
  int regChng = iMem++;



  int regTemp = iMem++;
  int regTabname = iMem++;
  int regIdxname = iMem++;
  int regStat1 = iMem++;
  int regPrev = iMem;




  pParse->nMem = ((pParse->nMem)>(iMem)?(pParse->nMem):(iMem));
  v = sqlite3GetVdbe(pParse);
  if( v==0 || (pTab==0) ){
    return;
  }
  if( pTab->tnum==0 ){

    return;
  }
  if( sqlite3_strlike("sqlite\\_%", pTab->zName, '\\')==0 ){

    return;
  }
  ((void)0);
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void)0);
  ((void)0);

  if( sqlite3AuthCheck(pParse, 28, pTab->zName, 0,
      db->aDb[iDb].zDbSName ) ){
    return;
  }
# 105862 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
  iTabCur = iTab++;
  iIdxCur = iTab++;
  pParse->nTab = ((pParse->nTab)>(iTab)?(pParse->nTab):(iTab));
  sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 97);
  sqlite3VdbeLoadString(v, regTabname, pTab->zName);

  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    int nCol;
    int addrRewind;
    int addrNextRow;
    const char *zIdxName;
    int nColTest;

    if( pOnlyIdx && pOnlyIdx!=pIdx ) continue;
    if( pIdx->pPartIdxWhere==0 ) needTableCnt = 0;
    if( !(((pTab)->tabFlags & 0x0020)==0) && ((pIdx)->idxType==2) ){
      nCol = pIdx->nKeyCol;
      zIdxName = pTab->zName;
      nColTest = nCol - 1;
    }else{
      nCol = pIdx->nColumn;
      zIdxName = pIdx->zName;
      nColTest = pIdx->uniqNotNull ? pIdx->nKeyCol-1 : nCol-1;
    }


    sqlite3VdbeLoadString(v, regIdxname, zIdxName);
    ;
# 105928 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pParse->nMem = ((pParse->nMem)>(regPrev+nColTest)?(pParse->nMem):(regPrev+nColTest));


    ((void)0);
    sqlite3VdbeAddOp3(v, 97, iIdxCur, pIdx->tnum, iDb);
    sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
    ;
# 105949 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    sqlite3VdbeAddOp2(v, 70, nCol, regStat4+1);
    sqlite3VdbeAddOp2(v, 70, pIdx->nKeyCol, regStat4+2);
    sqlite3VdbeAddOp4(v, 63, 0, regStat4+1, regStat4,
                     (char*)&statInitFuncdef, (-8));
    sqlite3VdbeChangeP5(v, 2+0);
# 105963 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    addrRewind = sqlite3VdbeAddOp1(v, 36, iIdxCur);
    ;
    sqlite3VdbeAddOp2(v, 70, 0, regChng);
    addrNextRow = sqlite3VdbeCurrentAddr(v);

    if( nColTest>0 ){
      int endDistinctTest = sqlite3VdbeMakeLabel(pParse);
      int *aGotoChng;
      aGotoChng = sqlite3DbMallocRawNN(db, sizeof(int)*nColTest);
      if( aGotoChng==0 ) continue;
# 105984 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      sqlite3VdbeAddOp0(v, 11);
      addrNextRow = sqlite3VdbeCurrentAddr(v);
      if( nColTest==1 && pIdx->nKeyCol==1 && ((pIdx)->onError!=0) ){



        sqlite3VdbeAddOp2(v, 51, regPrev, endDistinctTest);
        ;
      }
      for(i=0; i<nColTest; i++){
        char *pColl = (char*)sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);
        sqlite3VdbeAddOp2(v, 70, i, regChng);
        sqlite3VdbeAddOp3(v, 90, iIdxCur, i, regTemp);
        aGotoChng[i] =
        sqlite3VdbeAddOp4(v, 52, regTemp, 0, regPrev+i, pColl, (-2));
        sqlite3VdbeChangeP5(v, 0x80);
        ;
      }
      sqlite3VdbeAddOp2(v, 70, nColTest, regChng);
      sqlite3VdbeGoto(v, endDistinctTest);
# 106013 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      sqlite3VdbeJumpHere(v, addrNextRow-1);
      for(i=0; i<nColTest; i++){
        sqlite3VdbeJumpHere(v, aGotoChng[i]);
        sqlite3VdbeAddOp3(v, 90, iIdxCur, i, regPrev+i);
      }
      sqlite3VdbeResolveLabel(v, endDistinctTest);
      sqlite3DbFree(db, aGotoChng);
    }
# 106047 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    sqlite3VdbeAddOp4(v, 63, 1, regStat4, regTemp,
                     (char*)&statPushFuncdef, (-8));
    sqlite3VdbeChangeP5(v, 2+0);
    sqlite3VdbeAddOp2(v, 5, iIdxCur, addrNextRow); ;


    callStatGet(v, regStat4, 0, regStat1);
    ((void)0);
    sqlite3VdbeAddOp4(v, 92, regTabname, 3, regTemp, "BBB", 0);
    sqlite3VdbeAddOp2(v, 121, iStatCur, regNewRowid);
    sqlite3VdbeAddOp3(v, 122, iStatCur, regTemp, regNewRowid);



    sqlite3VdbeChangeP5(v, 0x08);
# 106101 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    sqlite3VdbeJumpHere(v, addrRewind);
  }





  if( pOnlyIdx==0 && needTableCnt ){
    ;
    sqlite3VdbeAddOp2(v, 93, iTabCur, regStat1);
    jZeroRows = sqlite3VdbeAddOp1(v, 20, regStat1); ;
    sqlite3VdbeAddOp2(v, 73, 0, regIdxname);
    ((void)0);
    sqlite3VdbeAddOp4(v, 92, regTabname, 3, regTemp, "BBB", 0);
    sqlite3VdbeAddOp2(v, 121, iStatCur, regNewRowid);
    sqlite3VdbeAddOp3(v, 122, iStatCur, regTemp, regNewRowid);
    sqlite3VdbeChangeP5(v, 0x08);



    sqlite3VdbeJumpHere(v, jZeroRows);
  }
}






static void loadAnalysis(Parse *pParse, int iDb){
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp1(v, 142, iDb);
  }
}




static void analyzeDatabase(Parse *pParse, int iDb){
  sqlite3 *db = pParse->db;
  Schema *pSchema = db->aDb[iDb].pSchema;
  HashElem *k;
  int iStatCur;
  int iMem;
  int iTab;

  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 3;
  openStatTable(pParse, iDb, iStatCur, 0, 0);
  iMem = pParse->nMem+1;
  iTab = pParse->nTab;
  ((void)0);
  for(k=((&pSchema->tblHash)->first); k; k=((k)->next)){
    Table *pTab = (Table*)((k)->data);
    analyzeOneTable(pParse, pTab, 0, iStatCur, iMem, iTab);
  }
  loadAnalysis(pParse, iDb);
}






static void analyzeTable(Parse *pParse, Table *pTab, Index *pOnlyIdx){
  int iDb;
  int iStatCur;

  ((void)0);
  ((void)0);
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  sqlite3BeginWriteOperation(pParse, 0, iDb);
  iStatCur = pParse->nTab;
  pParse->nTab += 3;
  if( pOnlyIdx ){
    openStatTable(pParse, iDb, iStatCur, pOnlyIdx->zName, "idx");
  }else{
    openStatTable(pParse, iDb, iStatCur, pTab->zName, "tbl");
  }
  analyzeOneTable(pParse, pTab, pOnlyIdx, iStatCur,pParse->nMem+1,pParse->nTab);
  loadAnalysis(pParse, iDb);
}
# 106198 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){
  sqlite3 *db = pParse->db;
  int iDb;
  int i;
  char *z, *zDb;
  Table *pTab;
  Index *pIdx;
  Token *pTableName;
  Vdbe *v;



  ((void)0);
  if( 0!=sqlite3ReadSchema(pParse) ){
    return;
  }

  ((void)0);
  if( pName1==0 ){

    for(i=0; i<db->nDb; i++){
      if( i==1 ) continue;
      analyzeDatabase(pParse, i);
    }
  }else if( pName2->n==0 && (iDb = sqlite3FindDb(db, pName1))>=0 ){

    analyzeDatabase(pParse, iDb);
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName);
    if( iDb>=0 ){
      zDb = pName2->n ? db->aDb[iDb].zDbSName : 0;
      z = sqlite3NameFromToken(db, pTableName);
      if( z ){
        if( (pIdx = sqlite3FindIndex(db, z, zDb))!=0 ){
          analyzeTable(pParse, pIdx->pTable, pIdx);
        }else if( (pTab = sqlite3LocateTable(pParse, 0, z, zDb))!=0 ){
          analyzeTable(pParse, pTab, 0);
        }
        sqlite3DbFree(db, z);
      }
    }
  }
  if( db->nSqlExec==0 && (v = sqlite3GetVdbe(pParse))!=0 ){
    sqlite3VdbeAddOp0(v, 158);
  }
}





typedef struct analysisInfo analysisInfo;
struct analysisInfo {
  sqlite3 *db;
  const char *zDatabase;
};






static void decodeIntArray(
  char *zIntArray,
  int nOut,
  tRowcnt *aOut,
  LogEst *aLog,
  Index *pIndex
){
  char *z = zIntArray;
  int c;
  int i;
  tRowcnt v;




  ((void)0);

  for(i=0; *z && i<nOut; i++){
    v = 0;
    while( (c=z[0])>='0' && c<='9' ){
      v = v*10 + c - '0';
      z++;
    }




    ((void)0);
    (void)(aOut);
    ((void)0);
    aLog[i] = sqlite3LogEst(v);

    if( *z==' ' ) z++;
  }

  ((void)0); {



    pIndex->bUnordered = 0;
    pIndex->noSkipScan = 0;
    while( z[0] ){
      if( sqlite3_strglob("unordered*", z)==0 ){
        pIndex->bUnordered = 1;
      }else if( sqlite3_strglob("sz=[0-9]*", z)==0 ){
        int sz = sqlite3Atoi(z+3);
        if( sz<2 ) sz = 2;
        pIndex->szIdxRow = sqlite3LogEst(sz);
      }else if( sqlite3_strglob("noskipscan*", z)==0 ){
        pIndex->noSkipScan = 1;
      }





      while( z[0]!=0 && z[0]!=' ' ) z++;
      while( z[0]==' ' ) z++;
    }
  }
}
# 106334 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){
  analysisInfo *pInfo = (analysisInfo*)pData;
  Index *pIndex;
  Table *pTable;
  const char *z;

  ((void)0);
  (void)(NotUsed),(void)(argc);

  if( argv==0 || argv[0]==0 || argv[2]==0 ){
    return 0;
  }
  pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase);
  if( pTable==0 ){
    return 0;
  }
  if( argv[1]==0 ){
    pIndex = 0;
  }else if( sqlite3_stricmp(argv[0],argv[1])==0 ){
    pIndex = sqlite3PrimaryKeyIndex(pTable);
  }else{
    pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase);
  }
  z = argv[2];

  if( pIndex ){
    tRowcnt *aiRowEst = 0;
    int nCol = pIndex->nKeyCol+1;
# 106372 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pIndex->bUnordered = 0;
    decodeIntArray((char*)z, nCol, aiRowEst, pIndex->aiRowLogEst, pIndex);
    pIndex->hasStat1 = 1;
    if( pIndex->pPartIdxWhere==0 ){
      pTable->nRowLogEst = pIndex->aiRowLogEst[0];
      pTable->tabFlags |= 0x0010;
    }
  }else{
    Index fakeIdx;
    fakeIdx.szIdxRow = pTable->szTabRow;



    decodeIntArray((char*)z, 1, 0, &pTable->nRowLogEst, &fakeIdx);
    pTable->szTabRow = fakeIdx.szIdxRow;
    pTable->tabFlags |= 0x0010;
  }

  return 0;
}





static void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx){
# 106412 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(db);
  (void)(pIdx);

}
# 106661 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3AnalysisLoad(sqlite3 *db, int iDb){
  analysisInfo sInfo;
  HashElem *i;
  char *zSql;
  int rc = 0;
  Schema *pSchema = db->aDb[iDb].pSchema;

  ((void)0);
  ((void)0);


  ((void)0);
  for(i=((&pSchema->tblHash)->first); i; i=((i)->next)){
    Table *pTab = ((i)->data);
    pTab->tabFlags &= ~0x0010;
  }
  for(i=((&pSchema->idxHash)->first); i; i=((i)->next)){
    Index *pIdx = ((i)->data);
    pIdx->hasStat1 = 0;




  }


  sInfo.db = db;
  sInfo.zDatabase = db->aDb[iDb].zDbSName;
  if( sqlite3FindTable(db, "sqlite_stat1", sInfo.zDatabase)!=0 ){
    zSql = sqlite3MPrintf(db,
        "SELECT tbl,idx,stat FROM %Q.sqlite_stat1", sInfo.zDatabase);
    if( zSql==0 ){
      rc = 7;
    }else{
      rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);
      sqlite3DbFree(db, zSql);
    }
  }


  ((void)0);
  for(i=((&pSchema->idxHash)->first); i; i=((i)->next)){
    Index *pIdx = ((i)->data);
    if( !pIdx->hasStat1 ) sqlite3DefaultRowEst(pIdx);
  }
# 106721 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rc==7 ){
    sqlite3OomFault(db);
  }
  return rc;
}
# 106766 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int resolveAttachExpr(NameContext *pName, Expr *pExpr)
{
  int rc = 0;
  if( pExpr ){
    if( pExpr->op!=59 ){
      rc = sqlite3ResolveExprNames(pName, pExpr);
    }else{
      pExpr->op = 113;
    }
  }
  return rc;
}
# 106794 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void attachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  int i;
  int rc = 0;
  sqlite3 *db = sqlite3_context_db_handle(context);
  const char *zName;
  const char *zFile;
  char *zPath = 0;
  char *zErr = 0;
  unsigned int flags;
  Db *aNew;
  Db *pNew;
  char *zErrDyn = 0;
  sqlite3_vfs *pVfs;

  (void)(NotUsed);
  zFile = (const char *)sqlite3_value_text(argv[0]);
  zName = (const char *)sqlite3_value_text(argv[1]);
  if( zFile==0 ) zFile = "";
  if( zName==0 ) zName = "";




#define REOPEN_AS_MEMDB(db) (0)


  if( (0) ){



    pVfs = sqlite3_vfs_find("memdb");
    if( pVfs==0 ) return;
    pNew = &db->aDb[db->init.iDb];
    if( pNew->pBt ) sqlite3BtreeClose(pNew->pBt);
    pNew->pBt = 0;
    pNew->pSchema = 0;
    rc = sqlite3BtreeOpen(pVfs, "x\0", db, &pNew->pBt, 0, 0x00000100);
  }else{
# 106844 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( db->nDb>=db->aLimit[7]+2 ){
      zErrDyn = sqlite3MPrintf(db, "too many attached databases - max %d",
        db->aLimit[7]
      );
      goto attach_error;
    }
    for(i=0; i<db->nDb; i++){
      char *z = db->aDb[i].zDbSName;
      ((void)0);
      if( sqlite3StrICmp(z, zName)==0 ){
        zErrDyn = sqlite3MPrintf(db, "database %s is already in use", zName);
        goto attach_error;
      }
    }




    if( db->aDb==db->aDbStatic ){
      aNew = sqlite3DbMallocRawNN(db, sizeof(db->aDb[0])*3 );
      if( aNew==0 ) return;
      memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);
    }else{
      aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );
      if( aNew==0 ) return;
    }
    db->aDb = aNew;
    pNew = &db->aDb[db->nDb];
    memset(pNew, 0, sizeof(*pNew));





    flags = db->openFlags;
    rc = sqlite3ParseUri(db->pVfs->zName, zFile, &flags, &pVfs, &zPath, &zErr);
    if( rc!=0 ){
      if( rc==7 ) sqlite3OomFault(db);
      sqlite3_result_error(context, zErr, -1);
      sqlite3_free(zErr);
      return;
    }
    ((void)0);
    flags |= 0x00000100;
    rc = sqlite3BtreeOpen(pVfs, zPath, db, &pNew->pBt, 0, flags);
    db->nDb++;
    pNew->zDbSName = sqlite3DbStrDup(db, zName);
  }
  db->noSharedCache = 0;
  if( rc==19 ){
    rc = 1;
    zErrDyn = sqlite3MPrintf(db, "database is already attached");
  }else if( rc==0 ){
    Pager *pPager;
    pNew->pSchema = sqlite3SchemaGet(db, pNew->pBt);
    if( !pNew->pSchema ){
      rc = 7;
    }else if( pNew->pSchema->file_format && pNew->pSchema->enc!=((db)->enc) ){
      zErrDyn = sqlite3MPrintf(db,
        "attached databases must use the same text encoding as main database");
      rc = 1;
    }
    sqlite3BtreeEnter(pNew->pBt);
    pPager = sqlite3BtreePager(pNew->pBt);
    sqlite3PagerLockingMode(pPager, db->dfltLockMode);
    sqlite3BtreeSecureDelete(pNew->pBt,
                             sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );

    sqlite3BtreeSetPagerFlags(pNew->pBt,
                      0x03 | (db->flags & 0x38));

    sqlite3BtreeLeave(pNew->pBt);
  }
  pNew->safety_level = 2 +1;
  if( rc==0 && pNew->zDbSName==0 ){
    rc = 7;
  }
# 106957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_free( zPath );






  if( rc==0 ){
    sqlite3BtreeEnterAll(db);
    db->init.iDb = 0;
    db->mDbFlags &= ~(0x0010);
    if( !(0) ){
      rc = sqlite3Init(db, &zErrDyn);
    }
    sqlite3BtreeLeaveAll(db);
    ((void)0);
  }
# 106983 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rc ){
    if( !(0) ){
      int iDb = db->nDb - 1;
      ((void)0);
      if( db->aDb[iDb].pBt ){
        sqlite3BtreeClose(db->aDb[iDb].pBt);
        db->aDb[iDb].pBt = 0;
        db->aDb[iDb].pSchema = 0;
      }
      sqlite3ResetAllSchemasOfConnection(db);
      db->nDb = iDb;
      if( rc==7 || rc==(10 | (12<<8)) ){
        sqlite3OomFault(db);
        sqlite3DbFree(db, zErrDyn);
        zErrDyn = sqlite3MPrintf(db, "out of memory");
      }else if( zErrDyn==0 ){
        zErrDyn = sqlite3MPrintf(db, "unable to open database: %s", zFile);
      }
    }
    goto attach_error;
  }

  return;

attach_error:

  if( zErrDyn ){
    sqlite3_result_error(context, zErrDyn, -1);
    sqlite3DbFree(db, zErrDyn);
  }
  if( rc ) sqlite3_result_error_code(context, rc);
}
# 107024 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void detachFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  const char *zName = (const char *)sqlite3_value_text(argv[0]);
  sqlite3 *db = sqlite3_context_db_handle(context);
  int i;
  Db *pDb = 0;
  HashElem *pEntry;
  char zErr[128];

  (void)(NotUsed);

  if( zName==0 ) zName = "";
  for(i=0; i<db->nDb; i++){
    pDb = &db->aDb[i];
    if( pDb->pBt==0 ) continue;
    if( sqlite3StrICmp(pDb->zDbSName, zName)==0 ) break;
  }

  if( i>=db->nDb ){
    sqlite3_snprintf(sizeof(zErr),zErr, "no such database: %s", zName);
    goto detach_error;
  }
  if( i<2 ){
    sqlite3_snprintf(sizeof(zErr),zErr, "cannot detach database %s", zName);
    goto detach_error;
  }
  if( sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt) ){
    sqlite3_snprintf(sizeof(zErr),zErr, "database %s is locked", zName);
    goto detach_error;
  }



  ((void)0);
  pEntry = ((&db->aDb[1].pSchema->trigHash)->first);
  while( pEntry ){
    Trigger *pTrig = (Trigger*)((pEntry)->data);
    if( pTrig->pTabSchema==pDb->pSchema ){
      pTrig->pTabSchema = pTrig->pSchema;
    }
    pEntry = ((pEntry)->next);
  }

  sqlite3BtreeClose(pDb->pBt);
  pDb->pBt = 0;
  pDb->pSchema = 0;
  sqlite3CollapseDatabaseArray(db);
  return;

detach_error:
  sqlite3_result_error(context, zErr, -1);
}





static void codeAttach(
  Parse *pParse,
  int type,
  FuncDef const *pFunc,
  Expr *pAuthArg,
  Expr *pFilename,
  Expr *pDbname,
  Expr *pKey
){
  int rc;
  NameContext sName;
  Vdbe *v;
  sqlite3* db = pParse->db;
  int regArgs;

  if( pParse->nErr ) goto attach_end;
  memset(&sName, 0, sizeof(NameContext));
  sName.pParse = pParse;

  if(
      0!=(rc = resolveAttachExpr(&sName, pFilename)) ||
      0!=(rc = resolveAttachExpr(&sName, pDbname)) ||
      0!=(rc = resolveAttachExpr(&sName, pKey))
  ){
    goto attach_end;
  }


  if( pAuthArg ){
    char *zAuthArg;
    if( pAuthArg->op==113 ){
      zAuthArg = pAuthArg->u.zToken;
    }else{
      zAuthArg = 0;
    }
    rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);
    if(rc!=0 ){
      goto attach_end;
    }
  }



  v = sqlite3GetVdbe(pParse);
  regArgs = sqlite3GetTempRange(pParse, 4);
  sqlite3ExprCode(pParse, pFilename, regArgs);
  sqlite3ExprCode(pParse, pDbname, regArgs+1);
  sqlite3ExprCode(pParse, pKey, regArgs+2);

  ((void)0);
  if( v ){
    sqlite3VdbeAddOp4(v, 63, 0, regArgs+3-pFunc->nArg, regArgs+3,
                      (char *)pFunc, (-8));
    ((void)0);
    sqlite3VdbeChangeP5(v, (u8)(pFunc->nArg));





    sqlite3VdbeAddOp1(v, 158, (type==24));
  }

attach_end:
  sqlite3ExprDelete(db, pFilename);
  sqlite3ExprDelete(db, pDbname);
  sqlite3ExprDelete(db, pKey);
}






static void sqlite3Detach(Parse *pParse, Expr *pDbname){
  static const FuncDef detach_func = {
    1,
    1,
    0,
    0,
    detachFunc,
    0,
    0, 0,
    "sqlite_detach",
    {0}
  };
  codeAttach(pParse, 25, &detach_func, pDbname, 0, 0, pDbname);
}






static void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){
  static const FuncDef attach_func = {
    3,
    1,
    0,
    0,
    attachFunc,
    0,
    0, 0,
    "sqlite_attach",
    {0}
  };
  codeAttach(pParse, 24, &attach_func, p, p, pDbname, pKey);
}






static void sqlite3FixInit(
  DbFixer *pFix,
  Parse *pParse,
  int iDb,
  const char *zType,
  const Token *pName
){
  sqlite3 *db;

  db = pParse->db;
  ((void)0);
  pFix->pParse = pParse;
  pFix->zDb = db->aDb[iDb].zDbSName;
  pFix->pSchema = db->aDb[iDb].pSchema;
  pFix->zType = zType;
  pFix->pName = pName;
  pFix->bVarOnly = (iDb==1);
}
# 107231 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3FixSrcList(
  DbFixer *pFix,
  SrcList *pList
){
  int i;
  const char *zDb;
  struct SrcList_item *pItem;

  if( (pList==0) ) return 0;
  zDb = pFix->zDb;
  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){
    if( pFix->bVarOnly==0 ){
      if( pItem->zDatabase && sqlite3StrICmp(pItem->zDatabase, zDb) ){
        sqlite3ErrorMsg(pFix->pParse,
            "%s %T cannot reference objects in database %s",
            pFix->zType, pFix->pName, pItem->zDatabase);
        return 1;
      }
      sqlite3DbFree(pFix->pParse->db, pItem->zDatabase);
      pItem->zDatabase = 0;
      pItem->pSchema = pFix->pSchema;
    }

    if( sqlite3FixSelect(pFix, pItem->pSelect) ) return 1;
    if( sqlite3FixExpr(pFix, pItem->pOn) ) return 1;

    if( pItem->fg.isTabFunc && sqlite3FixExprList(pFix, pItem->u1.pFuncArg) ){
      return 1;
    }
  }
  return 0;
}

static int sqlite3FixSelect(
  DbFixer *pFix,
  Select *pSelect
){
  while( pSelect ){
    if( sqlite3FixExprList(pFix, pSelect->pEList) ){
      return 1;
    }
    if( sqlite3FixSrcList(pFix, pSelect->pSrc) ){
      return 1;
    }
    if( sqlite3FixExpr(pFix, pSelect->pWhere) ){
      return 1;
    }
    if( sqlite3FixExprList(pFix, pSelect->pGroupBy) ){
      return 1;
    }
    if( sqlite3FixExpr(pFix, pSelect->pHaving) ){
      return 1;
    }
    if( sqlite3FixExprList(pFix, pSelect->pOrderBy) ){
      return 1;
    }
    if( sqlite3FixExpr(pFix, pSelect->pLimit) ){
      return 1;
    }
    if( pSelect->pWith ){
      int i;
      for(i=0; i<pSelect->pWith->nCte; i++){
        if( sqlite3FixSelect(pFix, pSelect->pWith->a[i].pSelect) ){
          return 1;
        }
      }
    }
    pSelect = pSelect->pPrior;
  }
  return 0;
}
static int sqlite3FixExpr(
  DbFixer *pFix,
  Expr *pExpr
){
  while( pExpr ){
    (pExpr)->flags|=(0x40000000);
    if( pExpr->op==151 ){
      if( pFix->pParse->db->init.busy ){
        pExpr->op = 117;
      }else{
        sqlite3ErrorMsg(pFix->pParse, "%s cannot use variables", pFix->zType);
        return 1;
      }
    }
    if( (((pExpr)->flags&(0x004000|0x800000))!=0) ) break;
    if( (((pExpr)->flags&(0x000800))!=0) ){
      if( sqlite3FixSelect(pFix, pExpr->x.pSelect) ) return 1;
    }else{
      if( sqlite3FixExprList(pFix, pExpr->x.pList) ) return 1;
    }
    if( sqlite3FixExpr(pFix, pExpr->pRight) ){
      return 1;
    }
    pExpr = pExpr->pLeft;
  }
  return 0;
}
static int sqlite3FixExprList(
  DbFixer *pFix,
  ExprList *pList
){
  int i;
  struct ExprList_item *pItem;
  if( pList==0 ) return 0;
  for(i=0, pItem=pList->a; i<pList->nExpr; i++, pItem++){
    if( sqlite3FixExpr(pFix, pItem->pExpr) ){
      return 1;
    }
  }
  return 0;
}



static int sqlite3FixTriggerStep(
  DbFixer *pFix,
  TriggerStep *pStep
){
  while( pStep ){
    if( sqlite3FixSelect(pFix, pStep->pSelect) ){
      return 1;
    }
    if( sqlite3FixExpr(pFix, pStep->pWhere) ){
      return 1;
    }
    if( sqlite3FixExprList(pFix, pStep->pExprList) ){
      return 1;
    }

    if( pStep->pUpsert ){
      Upsert *pUp = pStep->pUpsert;
      if( sqlite3FixExprList(pFix, pUp->pUpsertTarget)
       || sqlite3FixExpr(pFix, pUp->pUpsertTargetWhere)
       || sqlite3FixExprList(pFix, pUp->pUpsertSet)
       || sqlite3FixExpr(pFix, pUp->pUpsertWhere)
      ){
        return 1;
      }
    }

    pStep = pStep->pNext;
  }
  return 0;
}
# 107449 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_set_authorizer(
  sqlite3 *db,
  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),
  void *pArg
){



  sqlite3_mutex_enter(db->mutex);
  db->xAuth = (sqlite3_xauth)xAuth;
  db->pAuthArg = pArg;
  if( db->xAuth ) sqlite3ExpirePreparedStatements(db, 1);
  sqlite3_mutex_leave(db->mutex);
  return 0;
}





static void sqliteAuthBadReturnCode(Parse *pParse){
  sqlite3ErrorMsg(pParse, "authorizer malfunction");
  pParse->rc = 1;
}
# 107483 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3AuthReadCol(
  Parse *pParse,
  const char *zTab,
  const char *zCol,
  int iDb
){
  sqlite3 *db = pParse->db;
  char *zDb = db->aDb[iDb].zDbSName;
  int rc;

  if( db->init.busy ) return 0;
  rc = db->xAuth(db->pAuthArg, 20, zTab,zCol,zDb,pParse->zAuthContext



                );
  if( rc==1 ){
    char *z = sqlite3_mprintf("%s.%s", zTab, zCol);
    if( db->nDb>2 || iDb!=0 ) z = sqlite3_mprintf("%s.%z", zDb, z);
    sqlite3ErrorMsg(pParse, "access to %z is prohibited", z);
    pParse->rc = 23;
  }else if( rc!=2 && rc!=0 ){
    sqliteAuthBadReturnCode(pParse);
  }
  return rc;
}
# 107519 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3AuthRead(
  Parse *pParse,
  Expr *pExpr,
  Schema *pSchema,
  SrcList *pTabList
){
  sqlite3 *db = pParse->db;
  Table *pTab = 0;
  const char *zCol;
  int iSrc;
  int iDb;
  int iCol;

  ((void)0);
  ((void)0);
  if( db->xAuth==0 ) return;
  iDb = sqlite3SchemaToIndex(pParse->db, pSchema);
  if( iDb<0 ){


    return;
  }

  if( pExpr->op==77 ){
    pTab = pParse->pTriggerTab;
  }else{
    ((void)0);
    for(iSrc=0; (iSrc<pTabList->nSrc); iSrc++){
      if( pExpr->iTable==pTabList->a[iSrc].iCursor ){
        pTab = pTabList->a[iSrc].pTab;
        break;
      }
    }
  }
  iCol = pExpr->iColumn;
  if( (pTab==0) ) return;

  if( iCol>=0 ){
    ((void)0);
    zCol = pTab->aCol[iCol].zName;
  }else if( pTab->iPKey>=0 ){
    ((void)0);
    zCol = pTab->aCol[pTab->iPKey].zName;
  }else{
    zCol = "ROWID";
  }
  ((void)0);
  if( 2==sqlite3AuthReadCol(pParse, pTab->zName, zCol, iDb) ){
    pExpr->op = 117;
  }
}







static int sqlite3AuthCheck(
  Parse *pParse,
  int code,
  const char *zArg1,
  const char *zArg2,
  const char *zArg3
){
  sqlite3 *db = pParse->db;
  int rc;




  ((void)0);
  if( db->init.busy || (pParse->eParseMode!=0) ){
    return 0;
  }

  if( db->xAuth==0 ){
    return 0;
  }







  ;
  ;
  ;
  ;

  rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext



                );
  if( rc==1 ){
    sqlite3ErrorMsg(pParse, "not authorized");
    pParse->rc = 23;
  }else if( rc!=0 && rc!=2 ){
    rc = 1;
    sqliteAuthBadReturnCode(pParse);
  }
  return rc;
}






static void sqlite3AuthContextPush(
  Parse *pParse,
  AuthContext *pContext,
  const char *zContext
){
  ((void)0);
  pContext->pParse = pParse;
  pContext->zAuthContext = pParse->zAuthContext;
  pParse->zAuthContext = zContext;
}





static void sqlite3AuthContextPop(AuthContext *pContext){
  if( pContext->pParse ){
    pContext->pParse->zAuthContext = pContext->zAuthContext;
    pContext->pParse = 0;
  }
}
# 107687 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct TableLock {
  int iDb;
  int iTab;
  u8 isWriteLock;
  const char *zLockName;
};
# 107704 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3TableLock(
  Parse *pParse,
  int iDb,
  int iTab,
  u8 isWriteLock,
  const char *zName
){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  int i;
  int nBytes;
  TableLock *p;
  ((void)0);

  if( iDb==1 ) return;
  if( !sqlite3BtreeSharable(pParse->db->aDb[iDb].pBt) ) return;
  for(i=0; i<pToplevel->nTableLock; i++){
    p = &pToplevel->aTableLock[i];
    if( p->iDb==iDb && p->iTab==iTab ){
      p->isWriteLock = (p->isWriteLock || isWriteLock);
      return;
    }
  }

  nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);
  pToplevel->aTableLock =
      sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);
  if( pToplevel->aTableLock ){
    p = &pToplevel->aTableLock[pToplevel->nTableLock++];
    p->iDb = iDb;
    p->iTab = iTab;
    p->isWriteLock = isWriteLock;
    p->zLockName = zName;
  }else{
    pToplevel->nTableLock = 0;
    sqlite3OomFault(pToplevel->db);
  }
}





static void codeTableLocks(Parse *pParse){
  int i;
  Vdbe *pVdbe;

  pVdbe = sqlite3GetVdbe(pParse);
  ((void)0);

  for(i=0; i<pParse->nTableLock; i++){
    TableLock *p = &pParse->aTableLock[i];
    int p1 = p->iDb;
    sqlite3VdbeAddOp4(pVdbe, 159, p1, p->iTab, p->isWriteLock,
                      p->zLockName, (-1));
  }
}
# 107787 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3FinishCoding(Parse *pParse){
  sqlite3 *db;
  Vdbe *v;

  ((void)0);
  db = pParse->db;
  if( pParse->nested ) return;
  if( db->mallocFailed || pParse->nErr ){
    if( pParse->rc==0 ) pParse->rc = 1;
    return;
  }




  v = sqlite3GetVdbe(pParse);
  ((void)0)
                                                         ;
  if( v ){
    sqlite3VdbeAddOp0(v, 69);
# 107825 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( db->mallocFailed==0
     && ((pParse->cookieMask)!=0 || pParse->pConstExpr)
    ){
      int iDb, i;
      ((void)0);
      sqlite3VdbeJumpHere(v, 0);
      for(iDb=0; iDb<db->nDb; iDb++){
        Schema *pSchema;
        if( (((pParse->cookieMask)&(((yDbMask)1)<<(iDb)))!=0)==0 ) continue;
        sqlite3VdbeUsesBtree(v, iDb);
        pSchema = db->aDb[iDb].pSchema;
        sqlite3VdbeAddOp4Int(v,
          2,
          iDb,
          (((pParse->writeMask)&(((yDbMask)1)<<(iDb)))!=0),
          pSchema->schema_cookie,
          pSchema->iGeneration
        );
        if( db->init.busy==0 ) sqlite3VdbeChangeP5(v, 1);
       
                                                                              ;
      }

      for(i=0; i<pParse->nVtabLock; i++){
        char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);
        sqlite3VdbeAddOp4(v, 160, 0, 0, 0, vtab, (-12));
      }
      pParse->nVtabLock = 0;






      codeTableLocks(pParse);



      sqlite3AutoincrementBegin(pParse);


      if( pParse->pConstExpr ){
        ExprList *pEL = pParse->pConstExpr;
        pParse->okConstFactor = 0;
        for(i=0; i<pEL->nExpr; i++){
          sqlite3ExprCode(pParse, pEL->a[i].pExpr, pEL->a[i].u.iConstExprReg);
        }
      }


      sqlite3VdbeGoto(v, 1);
    }
  }




  if( v && pParse->nErr==0 && !db->mallocFailed ){


    ((void)0);
    sqlite3VdbeMakeReady(v, pParse);
    pParse->rc = 101;
  }else{
    pParse->rc = 1;
  }
}
# 107905 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){
  va_list ap;
  char *zSql;
  char *zErrMsg = 0;
  sqlite3 *db = pParse->db;
  char saveBuf[(sizeof(Parse)-__builtin_offsetof(Parse,sLastToken))];

  if( pParse->nErr ) return;
  ((void)0);
  ( ap = (va_list)( &(zFormat) ) + ( (sizeof(zFormat) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  zSql = sqlite3VMPrintf(db, zFormat, ap);
  ( ap = (va_list)0 );
  if( zSql==0 ){



    if( !db->mallocFailed ) pParse->rc = 18;
    pParse->nErr++;
    return;
  }
  pParse->nested++;
  memcpy(saveBuf, (((char*)(pParse))+__builtin_offsetof(Parse,sLastToken)), (sizeof(Parse)-__builtin_offsetof(Parse,sLastToken)));
  memset((((char*)(pParse))+__builtin_offsetof(Parse,sLastToken)), 0, (sizeof(Parse)-__builtin_offsetof(Parse,sLastToken)));
  sqlite3RunParser(pParse, zSql, &zErrMsg);
  sqlite3DbFree(db, zErrMsg);
  sqlite3DbFree(db, zSql);
  memcpy((((char*)(pParse))+__builtin_offsetof(Parse,sLastToken)), saveBuf, (sizeof(Parse)-__builtin_offsetof(Parse,sLastToken)));
  pParse->nested--;
}
# 107957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){
  Table *p = 0;
  int i;


  ((void)0);







  while(1){
    for(i=0; i<db->nDb; i++){
      int j = (i<2) ? i^1 : i;
      if( zDatabase==0 || sqlite3StrICmp(zDatabase, db->aDb[j].zDbSName)==0 ){
        ((void)0);
        p = sqlite3HashFind(&db->aDb[j].pSchema->tblHash, zName);
        if( p ) return p;
      }
    }


    if( sqlite3StrICmp(zName, "sqlite_master")!=0 ) break;
    if( sqlite3_stricmp(zDatabase, db->aDb[1].zDbSName)!=0 ) break;
    zName = "sqlite_temp_master";
  }
  return 0;
}
# 107998 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Table *sqlite3LocateTable(
  Parse *pParse,
  u32 flags,
  const char *zName,
  const char *zDbase
){
  Table *p;
  sqlite3 *db = pParse->db;



  if( (db->mDbFlags & 0x0010)==0
   && 0!=sqlite3ReadSchema(pParse)
  ){
    return 0;
  }

  p = sqlite3FindTable(db, zName, zDbase);
  if( p==0 ){




    if( pParse->disableVtab==0 ){
      Module *pMod = (Module*)sqlite3HashFind(&db->aModule, zName);
      if( pMod==0 && sqlite3_strnicmp(zName, "pragma_", 7)==0 ){
        pMod = sqlite3PragmaVtabRegister(db, zName);
      }
      if( pMod && sqlite3VtabEponymousTableInit(pParse, pMod) ){
        return pMod->pEpoTab;
      }
    }

    if( flags & 0x02 ) return 0;
    pParse->checkSchema = 1;
  }else if( ((p)->nModuleArg) && pParse->disableVtab ){
    p = 0;
  }

  if( p==0 ){
    const char *zMsg = flags & 0x01 ? "no such view" : "no such table";
    if( zDbase ){
      sqlite3ErrorMsg(pParse, "%s: %s.%s", zMsg, zDbase, zName);
    }else{
      sqlite3ErrorMsg(pParse, "%s: %s", zMsg, zName);
    }
  }

  return p;
}
# 108058 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Table *sqlite3LocateTableItem(
  Parse *pParse,
  u32 flags,
  struct SrcList_item *p
){
  const char *zDb;
  ((void)0);
  if( p->pSchema ){
    int iDb = sqlite3SchemaToIndex(pParse->db, p->pSchema);
    zDb = pParse->db->aDb[iDb].zDbSName;
  }else{
    zDb = p->zDatabase;
  }
  return sqlite3LocateTable(pParse, flags, p->zName, zDb);
}
# 108086 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){
  Index *p = 0;
  int i;

  ((void)0);
  for(i=0; i<db->nDb; i++){
    int j = (i<2) ? i^1 : i;
    Schema *pSchema = db->aDb[j].pSchema;
    ((void)0);
    if( zDb && sqlite3StrICmp(zDb, db->aDb[j].zDbSName) ) continue;
    ((void)0);
    p = sqlite3HashFind(&pSchema->idxHash, zName);
    if( p ) break;
  }
  return p;
}




static void sqlite3FreeIndex(sqlite3 *db, Index *p){

  sqlite3DeleteIndexSamples(db, p);

  sqlite3ExprDelete(db, p->pPartIdxWhere);
  sqlite3ExprListDelete(db, p->aColExpr);
  sqlite3DbFree(db, p->zColAff);
  if( p->isResized ) sqlite3DbFree(db, (void *)p->azColl);



  sqlite3DbFree(db, p);
}







static void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){
  Index *pIndex;
  Hash *pHash;

  ((void)0);
  pHash = &db->aDb[iDb].pSchema->idxHash;
  pIndex = sqlite3HashInsert(pHash, zIdxName, 0);
  if( (pIndex) ){
    if( pIndex->pTable->pIndex==pIndex ){
      pIndex->pTable->pIndex = pIndex->pNext;
    }else{
      Index *p;


      p = pIndex->pTable->pIndex;
      while( (p) && p->pNext!=pIndex ){ p = p->pNext; }
      if( (p && p->pNext==pIndex) ){
        p->pNext = pIndex->pNext;
      }
    }
    sqlite3FreeIndex(db, pIndex);
  }
  db->mDbFlags |= 0x0001;
}
# 108159 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3CollapseDatabaseArray(sqlite3 *db){
  int i, j;
  for(i=j=2; i<db->nDb; i++){
    struct Db *pDb = &db->aDb[i];
    if( pDb->pBt==0 ){
      sqlite3DbFree(db, pDb->zDbSName);
      pDb->zDbSName = 0;
      continue;
    }
    if( j<i ){
      db->aDb[j] = db->aDb[i];
    }
    j++;
  }
  db->nDb = j;
  if( db->nDb<=2 && db->aDb!=db->aDbStatic ){
    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));
    sqlite3DbFree(db, db->aDb);
    db->aDb = db->aDbStatic;
  }
}






static void sqlite3ResetOneSchema(sqlite3 *db, int iDb){
  int i;
  ((void)0);

  if( iDb>=0 ){
    ((void)0);
    (db)->aDb[iDb].pSchema->schemaFlags|=(0x0008);
    (db)->aDb[1].pSchema->schemaFlags|=(0x0008);
    db->mDbFlags &= ~0x0010;
  }

  if( db->nSchemaLock==0 ){
    for(i=0; i<db->nDb; i++){
      if( (((db)->aDb[i].pSchema->schemaFlags&(0x0008))==(0x0008)) ){
        sqlite3SchemaClear(db->aDb[i].pSchema);
      }
    }
  }
}





static void sqlite3ResetAllSchemasOfConnection(sqlite3 *db){
  int i;
  sqlite3BtreeEnterAll(db);
  for(i=0; i<db->nDb; i++){
    Db *pDb = &db->aDb[i];
    if( pDb->pSchema ){
      if( db->nSchemaLock==0 ){
        sqlite3SchemaClear(pDb->pSchema);
      }else{
        (db)->aDb[i].pSchema->schemaFlags|=(0x0008);
      }
    }
  }
  db->mDbFlags &= ~(0x0001|0x0010);
  sqlite3VtabUnlockList(db);
  sqlite3BtreeLeaveAll(db);
  if( db->nSchemaLock==0 ){
    sqlite3CollapseDatabaseArray(db);
  }
}




static void sqlite3CommitInternalChanges(sqlite3 *db){
  db->mDbFlags &= ~0x0001;
}





static void sqlite3DeleteColumnNames(sqlite3 *db, Table *pTable){
  int i;
  Column *pCol;
  ((void)0);
  if( (pCol = pTable->aCol)!=0 ){
    for(i=0; i<pTable->nCol; i++, pCol++){
      sqlite3DbFree(db, pCol->zName);
      sqlite3ExprDelete(db, pCol->pDflt);
      sqlite3DbFree(db, pCol->zColl);
    }
    sqlite3DbFree(db, pTable->aCol);
  }
}
# 108271 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void __attribute__((noinline)) deleteTable(sqlite3 *db, Table *pTable){
  Index *pIndex, *pNext;
# 108289 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){
    pNext = pIndex->pNext;
    ((void)0)
                                                                           ;
    if( (db==0 || db->pnBytesFreed==0) && !((pTable)->nModuleArg) ){
      char *zName = pIndex->zName;
      sqlite3HashInsert(
         &pIndex->pSchema->idxHash, zName, 0
      );
      ((void)0);
      ((void)0);
    }
    sqlite3FreeIndex(db, pIndex);
  }


  sqlite3FkDelete(db, pTable);



  sqlite3DeleteColumnNames(db, pTable);
  sqlite3DbFree(db, pTable->zName);
  sqlite3DbFree(db, pTable->zColAff);
  sqlite3SelectDelete(db, pTable->pSelect);
  sqlite3ExprListDelete(db, pTable->pCheck);

  sqlite3VtabClear(db, pTable);

  sqlite3DbFree(db, pTable);


  ((void)0);
}
static void sqlite3DeleteTable(sqlite3 *db, Table *pTable){

  if( !pTable ) return;
  if( ((!db || db->pnBytesFreed==0) && (--pTable->nTabRef)>0) ) return;
  deleteTable(db, pTable);
}






static void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){
  Table *p;
  Db *pDb;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  pDb = &db->aDb[iDb];
  p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName, 0);
  sqlite3DeleteTable(db, p);
  db->mDbFlags |= 0x0001;
}
# 108362 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char *sqlite3NameFromToken(sqlite3 *db, Token *pName){
  char *zName;
  if( pName ){
    zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);
    sqlite3Dequote(zName);
  }else{
    zName = 0;
  }
  return zName;
}





static void sqlite3OpenMasterTable(Parse *p, int iDb){
  Vdbe *v = sqlite3GetVdbe(p);
  sqlite3TableLock(p, iDb, 1, 1, "sqlite_master");
  sqlite3VdbeAddOp4Int(v, 98, 0, 1, iDb, 5);
  if( p->nTab==0 ){
    p->nTab = 1;
  }
}







static int sqlite3FindDbName(sqlite3 *db, const char *zName){
  int i = -1;
  if( zName ){
    Db *pDb;
    for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){
      if( 0==sqlite3_stricmp(pDb->zDbSName, zName) ) break;


      if( i==0 && 0==sqlite3_stricmp("main", zName) ) break;
    }
  }
  return i;
}







static int sqlite3FindDb(sqlite3 *db, Token *pName){
  int i;
  char *zName;
  zName = sqlite3NameFromToken(db, pName);
  i = sqlite3FindDbName(db, zName);
  sqlite3DbFree(db, zName);
  return i;
}
# 108437 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3TwoPartName(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  Token **pUnqual
){
  int iDb;
  sqlite3 *db = pParse->db;

  ((void)0);
  if( pName2->n>0 ){
    if( db->init.busy ) {
      sqlite3ErrorMsg(pParse, "corrupt database");
      return -1;
    }
    *pUnqual = pName2;
    iDb = sqlite3FindDb(db, pName1);
    if( iDb<0 ){
      sqlite3ErrorMsg(pParse, "unknown database %T", pName1);
      return -1;
    }
  }else{
    ((void)0)
                                                  ;
    iDb = db->init.iDb;
    *pUnqual = pName1;
  }
  return iDb;
}




static int sqlite3WritableSchema(sqlite3 *db){
  ;
 
                                   ;
 
                                 ;
 
                                                      ;
  return (db->flags&(0x00000001|0x10000000))==0x00000001;
}
# 108492 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3CheckObjectName(
  Parse *pParse,
  const char *zName,
  const char *zType,
  const char *zTblName
){
  sqlite3 *db = pParse->db;
  if( sqlite3WritableSchema(db) || db->init.imposterTable ){

    return 0;
  }
  if( db->init.busy ){
    if( sqlite3_stricmp(zType, db->init.azInit[0])
     || sqlite3_stricmp(zName, db->init.azInit[1])
     || sqlite3_stricmp(zTblName, db->init.azInit[2])
    ){
      if( sqlite3Config.bExtraSchemaChecks ){
        sqlite3ErrorMsg(pParse, "");
        return 1;
      }
    }
  }else{
    if( pParse->nested==0
     && 0==sqlite3_strnicmp(zName, "sqlite_", 7)
    ){
      sqlite3ErrorMsg(pParse, "object name reserved for internal use: %s",
                      zName);
      return 1;
    }
  }
  return 0;
}




static Index *sqlite3PrimaryKeyIndex(Table *pTab){
  Index *p;
  for(p=pTab->pIndex; p && !((p)->idxType==2); p=p->pNext){}
  return p;
}





static i16 sqlite3ColumnOfIndex(Index *pIdx, i16 iCol){
  int i;
  for(i=0; i<pIdx->nColumn; i++){
    if( iCol==pIdx->aiColumn[i] ) return i;
  }
  return -1;
}
# 108562 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3StartTable(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  int isTemp,
  int isView,
  int isVirtual,
  int noErr
){
  Table *pTable;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  Vdbe *v;
  int iDb;
  Token *pName;

  if( db->init.busy && db->init.newTnum==1 ){

    iDb = db->init.iDb;
    zName = sqlite3DbStrDup(db, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"));
    pName = pName1;
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ) return;
    if( !0 && isTemp && pName2->n>0 && iDb!=1 ){


      sqlite3ErrorMsg(pParse, "temporary table name must be unqualified");
      return;
    }
    if( !0 && isTemp ) iDb = 1;
    zName = sqlite3NameFromToken(db, pName);
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameTokenMap(pParse, (void*)zName, pName);
    }
  }
  pParse->sNameToken = *pName;
  if( zName==0 ) return;
  if( sqlite3CheckObjectName(pParse, zName, isView?"view":"table", zName) ){
    goto begin_table_error;
  }
  if( db->init.iDb==1 ) isTemp = 1;

  ((void)0);
  ((void)0);
  {
    static const u8 aCode[] = {
       2,
       4,
       8,
       6
    };
    char *zDb = db->aDb[iDb].zDbSName;
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(isTemp==1)?"sqlite_temp_master":"sqlite_master"), 0, zDb) ){
      goto begin_table_error;
    }
    if( !isVirtual && sqlite3AuthCheck(pParse, (int)aCode[isTemp+2*isView],
                                       zName, 0, zDb) ){
      goto begin_table_error;
    }
  }
# 108633 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( !(pParse->eParseMode!=0) ){
    char *zDb = db->aDb[iDb].zDbSName;
    if( 0!=sqlite3ReadSchema(pParse) ){
      goto begin_table_error;
    }
    pTable = sqlite3FindTable(db, zName, zDb);
    if( pTable ){
      if( !noErr ){
        sqlite3ErrorMsg(pParse, "table %T already exists", pName);
      }else{
        ((void)0);
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto begin_table_error;
    }
    if( sqlite3FindIndex(db, zName, zDb)!=0 ){
      sqlite3ErrorMsg(pParse, "there is already an index named %s", zName);
      goto begin_table_error;
    }
  }

  pTable = sqlite3DbMallocZero(db, sizeof(Table));
  if( pTable==0 ){
    ((void)0);
    pParse->rc = 7;
    pParse->nErr++;
    goto begin_table_error;
  }
  pTable->zName = zName;
  pTable->iPKey = -1;
  pTable->pSchema = db->aDb[iDb].pSchema;
  pTable->nTabRef = 1;



  pTable->nRowLogEst = 200; ((void)0);

  ((void)0);
  pParse->pNewTable = pTable;






  if( !pParse->nested && strcmp(zName, "sqlite_sequence")==0 ){
    ((void)0);
    pTable->pSchema->pSeqTab = pTable;
  }
# 108692 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){
    int addr1;
    int fileFormat;
    int reg1, reg2, reg3;

    static const char nullRow[] = { 6, 0, 0, 0, 0, 0 };
    sqlite3BeginWriteOperation(pParse, 1, iDb);


    if( isVirtual ){
      sqlite3VdbeAddOp0(v, 160);
    }





    reg1 = pParse->regRowid = ++pParse->nMem;
    reg2 = pParse->regRoot = ++pParse->nMem;
    reg3 = ++pParse->nMem;
    sqlite3VdbeAddOp3(v, 94, iDb, reg3, 2);
    sqlite3VdbeUsesBtree(v, iDb);
    addr1 = sqlite3VdbeAddOp1(v, 18, reg3); ;
    fileFormat = (db->flags & 0x00000002)!=0 ?
                  1 : 4;
    sqlite3VdbeAddOp3(v, 95, iDb, 2, fileFormat);
    sqlite3VdbeAddOp3(v, 95, iDb, 5, ((db)->enc));
    sqlite3VdbeJumpHere(v, addr1);
# 108731 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( isView || isVirtual ){
      sqlite3VdbeAddOp2(v, 70, 0, reg2);
    }else

    {
      pParse->addrCrTab =
         sqlite3VdbeAddOp3(v, 139, iDb, reg2, 1);
    }
    sqlite3OpenMasterTable(pParse, iDb);
    sqlite3VdbeAddOp2(v, 121, 0, reg1);
    sqlite3VdbeAddOp4(v, 75, 6, reg3, 0, nullRow, (-1));
    sqlite3VdbeAddOp3(v, 122, 0, reg3, reg1);
    sqlite3VdbeChangeP5(v, 0x08);
    sqlite3VdbeAddOp0(v, 117);
  }


  return;


begin_table_error:
  sqlite3DbFree(db, zName);
  return;
}
# 108778 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3AddColumn(Parse *pParse, Token *pName, Token *pType){
  Table *p;
  int i;
  char *z;
  char *zType;
  Column *pCol;
  sqlite3 *db = pParse->db;
  if( (p = pParse->pNewTable)==0 ) return;
  if( p->nCol+1>db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many columns on %s", p->zName);
    return;
  }
  z = sqlite3DbMallocRaw(db, pName->n + pType->n + 2);
  if( z==0 ) return;
  if( (pParse->eParseMode>=2) ) sqlite3RenameTokenMap(pParse, (void*)z, pName);
  memcpy(z, pName->z, pName->n);
  z[pName->n] = 0;
  sqlite3Dequote(z);
  for(i=0; i<p->nCol; i++){
    if( sqlite3_stricmp(z, p->aCol[i].zName)==0 ){
      sqlite3ErrorMsg(pParse, "duplicate column name: %s", z);
      sqlite3DbFree(db, z);
      return;
    }
  }
  if( (p->nCol & 0x7)==0 ){
    Column *aNew;
    aNew = sqlite3DbRealloc(db,p->aCol,(p->nCol+8)*sizeof(p->aCol[0]));
    if( aNew==0 ){
      sqlite3DbFree(db, z);
      return;
    }
    p->aCol = aNew;
  }
  pCol = &p->aCol[p->nCol];
  memset(pCol, 0, sizeof(p->aCol[0]));
  pCol->zName = z;
  ;

  if( pType->n==0 ){


    pCol->affinity = 0x41;
    pCol->szEst = 1;





  }else{
    zType = z + sqlite3Strlen30(z) + 1;
    memcpy(zType, pType->z, pType->n);
    zType[pType->n] = 0;
    sqlite3Dequote(zType);
    pCol->affinity = sqlite3AffinityType(zType, pCol);
    pCol->colFlags |= 0x0004;
  }
  p->nCol++;
  pParse->constraintName.n = 0;
}







static void sqlite3AddNotNull(Parse *pParse, int onError){
  Table *p;
  Column *pCol;
  p = pParse->pNewTable;
  if( p==0 || (p->nCol<1) ) return;
  pCol = &p->aCol[p->nCol-1];
  pCol->notNull = (u8)onError;
  p->tabFlags |= 0x0200;



  if( pCol->colFlags & 0x0008 ){
    Index *pIdx;
    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void)0);
      if( pIdx->aiColumn[0]==p->nCol-1 ){
        pIdx->uniqNotNull = 1;
      }
    }
  }
}
# 108892 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static char sqlite3AffinityType(const char *zIn, Column *pCol){
  u32 h = 0;
  char aff = 0x43;
  const char *zChar = 0;

  ((void)0);
  while( zIn[0] ){
    h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];
    zIn++;
    if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){
      aff = 0x42;
      zChar = zIn;
    }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){
      aff = 0x42;
    }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){
      aff = 0x42;
    }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')
        && (aff==0x43 || aff==0x45) ){
      aff = 0x41;
      if( zIn[0]=='(' ) zChar = zIn;

    }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')
        && aff==0x43 ){
      aff = 0x45;
    }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')
        && aff==0x43 ){
      aff = 0x45;
    }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')
        && aff==0x43 ){
      aff = 0x45;

    }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){
      aff = 0x44;
      break;
    }
  }



  if( pCol ){
    int v = 0;
    if( aff<0x43 ){
      if( zChar ){
        while( zChar[0] ){
          if( (sqlite3CtypeMap[(unsigned char)(zChar[0])]&0x04) ){

            sqlite3GetInt32(zChar, &v);
            break;
          }
          zChar++;
        }
      }else{
        v = 16;
      }
    }





    v = v/4 + 1;
    if( v>255 ) v = 255;
    pCol->szEst = v;
  }
  return aff;
}
# 108969 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3AddDefaultValue(
  Parse *pParse,
  Expr *pExpr,
  const char *zStart,
  const char *zEnd
){
  Table *p;
  Column *pCol;
  sqlite3 *db = pParse->db;
  p = pParse->pNewTable;
  if( p!=0 ){
    pCol = &(p->aCol[p->nCol-1]);
    if( !sqlite3ExprIsConstantOrFunction(pExpr, db->init.busy) ){
      sqlite3ErrorMsg(pParse, "default value of column [%s] is not constant",
          pCol->zName);
    }else{



      Expr x;
      sqlite3ExprDelete(db, pCol->pDflt);
      memset(&x, 0, sizeof(x));
      x.op = 176;
      x.u.zToken = sqlite3DbSpanDup(db, zStart, zEnd);
      x.pLeft = pExpr;
      x.flags = 0x001000;
      pCol->pDflt = sqlite3ExprDup(db, &x, 0x0001);
      sqlite3DbFree(db, x.u.zToken);
    }
  }
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameExprUnmap(pParse, pExpr);
  }
  sqlite3ExprDelete(db, pExpr);
}
# 109021 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3StringToId(Expr *p){
  if( p->op==113 ){
    p->op = 59;
  }else if( p->op==109 && p->pLeft->op==113 ){
    p->pLeft->op = 59;
  }
}
# 109047 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3AddPrimaryKey(
  Parse *pParse,
  ExprList *pList,
  int onError,
  int autoInc,
  int sortOrder
){
  Table *pTab = pParse->pNewTable;
  Column *pCol = 0;
  int iCol = -1, i;
  int nTerm;
  if( pTab==0 ) goto primary_key_exit;
  if( pTab->tabFlags & 0x0004 ){
    sqlite3ErrorMsg(pParse,
      "table \"%s\" has more than one primary key", pTab->zName);
    goto primary_key_exit;
  }
  pTab->tabFlags |= 0x0004;
  if( pList==0 ){
    iCol = pTab->nCol - 1;
    pCol = &pTab->aCol[iCol];
    pCol->colFlags |= 0x0001;
    nTerm = 1;
  }else{
    nTerm = pList->nExpr;
    for(i=0; i<nTerm; i++){
      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[i].pExpr);
      ((void)0);
      sqlite3StringToId(pCExpr);
      if( pCExpr->op==59 ){
        const char *zCName = pCExpr->u.zToken;
        for(iCol=0; iCol<pTab->nCol; iCol++){
          if( sqlite3StrICmp(zCName, pTab->aCol[iCol].zName)==0 ){
            pCol = &pTab->aCol[iCol];
            pCol->colFlags |= 0x0001;
            break;
          }
        }
      }
    }
  }
  if( nTerm==1
   && pCol
   && sqlite3StrICmp(sqlite3ColumnType(pCol,""), "INTEGER")==0
   && sortOrder!=1
  ){
    if( (pParse->eParseMode>=2) && pList ){
      Expr *pCExpr = sqlite3ExprSkipCollate(pList->a[0].pExpr);
      sqlite3RenameTokenRemap(pParse, &pTab->iPKey, pCExpr);
    }
    pTab->iPKey = iCol;
    pTab->keyConf = (u8)onError;
    ((void)0);
    pTab->tabFlags |= autoInc*0x0008;
    if( pList ) pParse->iPkSortOrder = pList->a[0].sortFlags;
  }else if( autoInc ){

    sqlite3ErrorMsg(pParse, "AUTOINCREMENT is only allowed on an "
       "INTEGER PRIMARY KEY");

  }else{
    sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0,
                           0, sortOrder, 0, 2);
    pList = 0;
  }

primary_key_exit:
  sqlite3ExprListDelete(pParse->db, pList);
  return;
}




static void sqlite3AddCheckConstraint(
  Parse *pParse,
  Expr *pCheckExpr
){

  Table *pTab = pParse->pNewTable;
  sqlite3 *db = pParse->db;
  if( pTab && !(pParse->eParseMode==1)
   && !sqlite3BtreeIsReadonly(db->aDb[db->init.iDb].pBt)
  ){
    pTab->pCheck = sqlite3ExprListAppend(pParse, pTab->pCheck, pCheckExpr);
    if( pParse->constraintName.n ){
      sqlite3ExprListSetName(pParse, pTab->pCheck, &pParse->constraintName, 1);
    }
  }else

  {
    sqlite3ExprDelete(pParse->db, pCheckExpr);
  }
}





static void sqlite3AddCollateType(Parse *pParse, Token *pToken){
  Table *p;
  int i;
  char *zColl;
  sqlite3 *db;

  if( (p = pParse->pNewTable)==0 ) return;
  i = p->nCol-1;
  db = pParse->db;
  zColl = sqlite3NameFromToken(db, pToken);
  if( !zColl ) return;

  if( sqlite3LocateCollSeq(pParse, zColl) ){
    Index *pIdx;
    sqlite3DbFree(db, p->aCol[i].zColl);
    p->aCol[i].zColl = zColl;





    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void)0);
      if( pIdx->aiColumn[0]==i ){
        pIdx->azColl[0] = p->aCol[i].zColl;
      }
    }
  }else{
    sqlite3DbFree(db, zColl);
  }
}
# 109198 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName){
  sqlite3 *db = pParse->db;
  u8 enc = ((db)->enc);
  u8 initbusy = db->init.busy;
  CollSeq *pColl;

  pColl = sqlite3FindCollSeq(db, enc, zName, initbusy);
  if( !initbusy && (!pColl || !pColl->xCmp) ){
    pColl = sqlite3GetCollSeq(pParse, enc, pColl, zName);
  }

  return pColl;
}
# 109232 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ChangeCookie(Parse *pParse, int iDb){
  sqlite3 *db = pParse->db;
  Vdbe *v = pParse->pVdbe;
  ((void)0);
  sqlite3VdbeAddOp3(v, 95, iDb, 1,
                   (int)(1+(unsigned)db->aDb[iDb].pSchema->schema_cookie));
}
# 109248 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int identLength(const char *z){
  int n;
  for(n=0; *z; n++, z++){
    if( *z=='"' ){ n++; }
  }
  return n + 2;
}
# 109269 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void identPut(char *z, int *pIdx, char *zSignedIdent){
  unsigned char *zIdent = (unsigned char*)zSignedIdent;
  int i, j, needQuote;
  i = *pIdx;

  for(j=0; zIdent[j]; j++){
    if( !(sqlite3CtypeMap[(unsigned char)(zIdent[j])]&0x06) && zIdent[j]!='_' ) break;
  }
  needQuote = (sqlite3CtypeMap[(unsigned char)(zIdent[0])]&0x04)
            || sqlite3KeywordCode(zIdent, j)!=59
            || zIdent[j]!=0
            || j==0;

  if( needQuote ) z[i++] = '"';
  for(j=0; zIdent[j]; j++){
    z[i++] = zIdent[j];
    if( zIdent[j]=='"' ) z[i++] = '"';
  }
  if( needQuote ) z[i++] = '"';
  z[i] = 0;
  *pIdx = i;
}






static char *createTableStmt(sqlite3 *db, Table *p){
  int i, k, n;
  char *zStmt;
  char *zSep, *zSep2, *zEnd;
  Column *pCol;
  n = 0;
  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){
    n += identLength(pCol->zName) + 5;
  }
  n += identLength(p->zName);
  if( n<50 ){
    zSep = "";
    zSep2 = ",";
    zEnd = ")";
  }else{
    zSep = "\n  ";
    zSep2 = ",\n  ";
    zEnd = "\n)";
  }
  n += 35 + 6*p->nCol;
  zStmt = sqlite3DbMallocRaw(0, n);
  if( zStmt==0 ){
    sqlite3OomFault(db);
    return 0;
  }
  sqlite3_snprintf(n, zStmt, "CREATE TABLE ");
  k = sqlite3Strlen30(zStmt);
  identPut(zStmt, &k, p->zName);
  zStmt[k++] = '(';
  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){
    static const char * const azType[] = {
                                 "",
                                 " TEXT",
                                 " NUM",
                                 " INT",
                                 " REAL"
    };
    int len;
    const char *zType;

    sqlite3_snprintf(n-k, &zStmt[k], zSep);
    k += sqlite3Strlen30(&zStmt[k]);
    zSep = zSep2;
    identPut(zStmt, &k, pCol->zName);
    ((void)0);
    ((void)0);
    ;
    ;
    ;
    ;
    ;

    zType = azType[pCol->affinity - 0x41];
    len = sqlite3Strlen30(zType);
    ((void)0)
                                                              ;
    memcpy(&zStmt[k], zType, len);
    k += len;
    ((void)0);
  }
  sqlite3_snprintf(n-k, &zStmt[k], "%s", zEnd);
  return zStmt;
}





static int resizeIndexObject(sqlite3 *db, Index *pIdx, int N){
  char *zExtra;
  int nByte;
  if( pIdx->nColumn>=N ) return 0;
  ((void)0);
  nByte = (sizeof(char*) + sizeof(i16) + 1)*N;
  zExtra = sqlite3DbMallocZero(db, nByte);
  if( zExtra==0 ) return 7;
  memcpy(zExtra, pIdx->azColl, sizeof(char*)*pIdx->nColumn);
  pIdx->azColl = (const char**)zExtra;
  zExtra += sizeof(char*)*N;
  memcpy(zExtra, pIdx->aiColumn, sizeof(i16)*pIdx->nColumn);
  pIdx->aiColumn = (i16*)zExtra;
  zExtra += sizeof(i16)*N;
  memcpy(zExtra, pIdx->aSortOrder, pIdx->nColumn);
  pIdx->aSortOrder = (u8*)zExtra;
  pIdx->nColumn = N;
  pIdx->isResized = 1;
  return 0;
}




static void estimateTableWidth(Table *pTab){
  unsigned wTable = 0;
  const Column *pTabCol;
  int i;
  for(i=pTab->nCol, pTabCol=pTab->aCol; i>0; i--, pTabCol++){
    wTable += pTabCol->szEst;
  }
  if( pTab->iPKey<0 ) wTable++;
  pTab->szTabRow = sqlite3LogEst(wTable*4);
}




static void estimateIndexWidth(Index *pIdx){
  unsigned wIndex = 0;
  int i;
  const Column *aCol = pIdx->pTable->aCol;
  for(i=0; i<pIdx->nColumn; i++){
    i16 x = pIdx->aiColumn[i];
    ((void)0);
    wIndex += x<0 ? 1 : aCol[pIdx->aiColumn[i]].szEst;
  }
  pIdx->szIdxRow = sqlite3LogEst(wIndex*4);
}





static int hasColumn(const i16 *aiCol, int nCol, int x){
  while( nCol-- > 0 ){
    ((void)0);
    if( x==*(aiCol++) ){
      return 1;
    }
  }
  return 0;
}
# 109442 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isDupColumn(Index *pIdx, int nKey, Index *pPk, int iCol){
  int i, j;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  j = pPk->aiColumn[iCol];
  ((void)0);
  for(i=0; i<nKey; i++){
    ((void)0);
    if( pIdx->aiColumn[i]==j
     && sqlite3StrICmp(pIdx->azColl[i], pPk->azColl[iCol])==0
    ){
      return 1;
    }
  }
  return 0;
}
# 109473 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void recomputeColumnsNotIndexed(Index *pIdx){
  Bitmask m = 0;
  int j;
  for(j=pIdx->nColumn-1; j>=0; j--){
    int x = pIdx->aiColumn[j];
    if( x>=0 ){
      ;
      ;
      if( x<((int)(sizeof(Bitmask)*8))-1 ) m |= (((Bitmask)1)<<(x));
    }
  }
  pIdx->colNotIdxed = ~m;
  ((void)0);
}
# 109512 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void convertToWithoutRowidTable(Parse *pParse, Table *pTab){
  Index *pIdx;
  Index *pPk;
  int nPk;
  int nExtra;
  int i, j;
  sqlite3 *db = pParse->db;
  Vdbe *v = pParse->pVdbe;



  if( !db->init.imposterTable ){
    for(i=0; i<pTab->nCol; i++){
      if( (pTab->aCol[i].colFlags & 0x0001)!=0 ){
        pTab->aCol[i].notNull = 2;
      }
    }
  }




  if( pParse->addrCrTab ){
    ((void)0);
    sqlite3VdbeChangeP3(v, pParse->addrCrTab, 2);
  }




  if( pTab->iPKey>=0 ){
    ExprList *pList;
    Token ipkToken;
    sqlite3TokenInit(&ipkToken, pTab->aCol[pTab->iPKey].zName);
    pList = sqlite3ExprListAppend(pParse, 0,
                  sqlite3ExprAlloc(db, 59, &ipkToken, 0));
    if( pList==0 ) return;
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameTokenRemap(pParse, pList->a[0].pExpr, &pTab->iPKey);
    }
    pList->a[0].sortFlags = pParse->iPkSortOrder;
    ((void)0);
    pTab->iPKey = -1;
    sqlite3CreateIndex(pParse, 0, 0, 0, pList, pTab->keyConf, 0, 0, 0, 0,
                       2);
    if( db->mallocFailed || pParse->nErr ) return;
    pPk = sqlite3PrimaryKeyIndex(pTab);
    ((void)0);
  }else{
    pPk = sqlite3PrimaryKeyIndex(pTab);
    ((void)0);






    for(i=j=1; i<pPk->nKeyCol; i++){
      if( isDupColumn(pPk, j, pPk, i) ){
        pPk->nColumn--;
      }else{
        ;
        pPk->azColl[j] = pPk->azColl[i];
        pPk->aSortOrder[j] = pPk->aSortOrder[i];
        pPk->aiColumn[j++] = pPk->aiColumn[i];
      }
    }
    pPk->nKeyCol = j;
  }
  ((void)0);
  pPk->isCovering = 1;
  if( !db->init.imposterTable ) pPk->uniqNotNull = 1;
  nPk = pPk->nColumn = pPk->nKeyCol;





  if( v && pPk->tnum>0 ){
    ((void)0);
    sqlite3VdbeChangeOpcode(v, pPk->tnum, 11);
  }


  pPk->tnum = pTab->tnum;




  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    int n;
    if( ((pIdx)->idxType==2) ) continue;
    for(i=n=0; i<nPk; i++){
      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){
        ;
        n++;
      }
    }
    if( n==0 ){

      pIdx->nColumn = pIdx->nKeyCol;
      continue;
    }
    if( resizeIndexObject(db, pIdx, pIdx->nKeyCol+n) ) return;
    for(i=0, j=pIdx->nKeyCol; i<nPk; i++){
      if( !isDupColumn(pIdx, pIdx->nKeyCol, pPk, i) ){
        ;
        pIdx->aiColumn[j] = pPk->aiColumn[i];
        pIdx->azColl[j] = pPk->azColl[i];
        if( pPk->aSortOrder[i] ){

          pIdx->bAscKeyBug = 1;
        }
        j++;
      }
    }
    ((void)0);
    ((void)0);
  }



  nExtra = 0;
  for(i=0; i<pTab->nCol; i++){
    if( !hasColumn(pPk->aiColumn, nPk, i) ) nExtra++;
  }
  if( resizeIndexObject(db, pPk, nPk+nExtra) ) return;
  for(i=0, j=nPk; i<pTab->nCol; i++){
    if( !hasColumn(pPk->aiColumn, j, i) ){
      ((void)0);
      pPk->aiColumn[j] = i;
      pPk->azColl[j] = sqlite3StrBINARY;
      j++;
    }
  }
  ((void)0);
  ((void)0);
  recomputeColumnsNotIndexed(pPk);
}
# 109660 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isShadowTableName(sqlite3 *db, char *zName){
  char *zTail;
  Table *pTab;
  Module *pMod;

  zTail = strrchr(zName, '_');
  if( zTail==0 ) return 0;
  *zTail = 0;
  pTab = sqlite3FindTable(db, zName, 0);
  *zTail = '_';
  if( pTab==0 ) return 0;
  if( !((pTab)->nModuleArg) ) return 0;
  pMod = (Module*)sqlite3HashFind(&db->aModule, pTab->azModuleArg[0]);
  if( pMod==0 ) return 0;
  if( pMod->pModule->iVersion<3 ) return 0;
  if( pMod->pModule->xShadowName==0 ) return 0;
  return pMod->pModule->xShadowName(zTail+1);
}
# 109702 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3EndTable(
  Parse *pParse,
  Token *pCons,
  Token *pEnd,
  u8 tabOpts,
  Select *pSelect
){
  Table *p;
  sqlite3 *db = pParse->db;
  int iDb;
  Index *pIdx;

  if( pEnd==0 && pSelect==0 ){
    return;
  }
  ((void)0);
  p = pParse->pNewTable;
  if( p==0 ) return;

  if( pSelect==0 && isShadowTableName(db, p->zName) ){
    p->tabFlags |= 0x0400;
  }
# 109734 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( db->init.busy ){
    if( pSelect ){
      sqlite3ErrorMsg(pParse, "");
      return;
    }
    p->tnum = db->init.newTnum;
    if( p->tnum==1 ) p->tabFlags |= 0x0001;
  }

  ((void)0)
                                                       ;
  ((void)0)
                                                        ;


  if( tabOpts & 0x0020 ){
    if( (p->tabFlags & 0x0008) ){
      sqlite3ErrorMsg(pParse,
          "AUTOINCREMENT not allowed on WITHOUT ROWID tables");
      return;
    }
    if( (p->tabFlags & 0x0004)==0 ){
      sqlite3ErrorMsg(pParse, "PRIMARY KEY missing on table %s", p->zName);
    }else{
      p->tabFlags |= 0x0020 | 0x0040;
      convertToWithoutRowidTable(pParse, p);
    }
  }

  iDb = sqlite3SchemaToIndex(db, p->pSchema);




  if( p->pCheck ){
    sqlite3ResolveSelfReference(pParse, p, 0x0004, 0, p->pCheck);
  }



  estimateTableWidth(p);
  for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){
    estimateIndexWidth(pIdx);
  }







  if( !db->init.busy ){
    int n;
    Vdbe *v;
    char *zType;
    char *zType2;
    char *zStmt;

    v = sqlite3GetVdbe(pParse);
    if( (v==0) ) return;

    sqlite3VdbeAddOp1(v, 117, 0);




    if( p->pSelect==0 ){

      zType = "table";
      zType2 = "TABLE";

    }else{

      zType = "view";
      zType2 = "VIEW";

    }
# 109825 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pSelect ){
      SelectDest dest;
      int regYield;
      int addrTop;
      int regRec;
      int regRowid;
      int addrInsLoop;
      Table *pSelTab;

      regYield = ++pParse->nMem;
      regRec = ++pParse->nMem;
      regRowid = ++pParse->nMem;
      ((void)0);
      sqlite3MayAbort(pParse);
      sqlite3VdbeAddOp3(v, 98, 1, pParse->regRoot, iDb);
      sqlite3VdbeChangeP5(v, 0x10);
      pParse->nTab = 2;
      addrTop = sqlite3VdbeCurrentAddr(v) + 1;
      sqlite3VdbeAddOp3(v, 13, regYield, 0, addrTop);
      if( pParse->nErr ) return;
      pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect, 0x41);
      if( pSelTab==0 ) return;
      ((void)0);
      p->nCol = pSelTab->nCol;
      p->aCol = pSelTab->aCol;
      pSelTab->nCol = 0;
      pSelTab->aCol = 0;
      sqlite3DeleteTable(db, pSelTab);
      sqlite3SelectDestInit(&dest, 13, regYield);
      sqlite3Select(pParse, pSelect, &dest);
      if( pParse->nErr ) return;
      sqlite3VdbeEndCoroutine(v, regYield);
      sqlite3VdbeJumpHere(v, addrTop - 1);
      addrInsLoop = sqlite3VdbeAddOp1(v, 14, dest.iSDParm);
      ;
      sqlite3VdbeAddOp3(v, 92, dest.iSdst, dest.nSdst, regRec);
      sqlite3TableAffinity(v, p, 0);
      sqlite3VdbeAddOp2(v, 121, 1, regRowid);
      sqlite3VdbeAddOp3(v, 122, 1, regRec, regRowid);
      sqlite3VdbeGoto(v, addrInsLoop);
      sqlite3VdbeJumpHere(v, addrInsLoop);
      sqlite3VdbeAddOp1(v, 117, 1);
    }


    if( pSelect ){
      zStmt = createTableStmt(db, p);
    }else{
      Token *pEnd2 = tabOpts ? &pParse->sLastToken : pEnd;
      n = (int)(pEnd2->z - pParse->sNameToken.z);
      if( pEnd2->z[0]!=';' ) n += pEnd2->n;
      zStmt = sqlite3MPrintf(db,
          "CREATE %s %.*s", zType2, n, pParse->sNameToken.z
      );
    }





    sqlite3NestedParse(pParse,
      "UPDATE %Q.%s "
         "SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q "
       "WHERE rowid=#%d",
      db->aDb[iDb].zDbSName, "sqlite_master",
      zType,
      p->zName,
      p->zName,
      pParse->regRoot,
      zStmt,
      pParse->regRowid
    );
    sqlite3DbFree(db, zStmt);
    sqlite3ChangeCookie(pParse, iDb);





    if( (p->tabFlags & 0x0008)!=0 ){
      Db *pDb = &db->aDb[iDb];
      ((void)0);
      if( pDb->pSchema->pSeqTab==0 ){
        sqlite3NestedParse(pParse,
          "CREATE TABLE %Q.sqlite_sequence(name,seq)",
          pDb->zDbSName
        );
      }
    }



    sqlite3VdbeAddParseSchemaOp(v, iDb,
           sqlite3MPrintf(db, "tbl_name='%q' AND type!='trigger'", p->zName));
  }




  if( db->init.busy ){
    Table *pOld;
    Schema *pSchema = p->pSchema;
    ((void)0);
    pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName, p);
    if( pOld ){
      ((void)0);
      sqlite3OomFault(db);
      return;
    }
    pParse->pNewTable = 0;
    db->mDbFlags |= 0x0001;


    if( !p->pSelect ){
      const char *zName = (const char *)pParse->sNameToken.z;
      int nName;
      ((void)0);
      if( pCons->z==0 ){
        pCons = pEnd;
      }
      nName = (int)((const char *)pCons->z - zName);
      p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);
    }

  }
}





static void sqlite3CreateView(
  Parse *pParse,
  Token *pBegin,
  Token *pName1,
  Token *pName2,
  ExprList *pCNames,
  Select *pSelect,
  int isTemp,
  int noErr
){
  Table *p;
  int n;
  const char *z;
  Token sEnd;
  DbFixer sFix;
  Token *pName = 0;
  int iDb;
  sqlite3 *db = pParse->db;

  if( pParse->nVar>0 ){
    sqlite3ErrorMsg(pParse, "parameters are not allowed in views");
    goto create_view_fail;
  }
  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);
  p = pParse->pNewTable;
  if( p==0 || pParse->nErr ) goto create_view_fail;
  sqlite3TwoPartName(pParse, pName1, pName2, &pName);
  iDb = sqlite3SchemaToIndex(db, p->pSchema);
  sqlite3FixInit(&sFix, pParse, iDb, "view", pName);
  if( sqlite3FixSelect(&sFix, pSelect) ) goto create_view_fail;






  if( (pParse->eParseMode>=2) ){
    p->pSelect = pSelect;
    pSelect = 0;
  }else{
    p->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
  }
  p->pCheck = sqlite3ExprListDup(db, pCNames, 0x0001);
  if( db->mallocFailed ) goto create_view_fail;




  sEnd = pParse->sLastToken;
  ((void)0);
  if( sEnd.z[0]!=';' ){
    sEnd.z += sEnd.n;
  }
  sEnd.n = 0;
  n = (int)(sEnd.z - pBegin->z);
  ((void)0);
  z = pBegin->z;
  while( (sqlite3CtypeMap[(unsigned char)(z[n-1])]&0x01) ){ n--; }
  sEnd.z = &z[n-1];
  sEnd.n = 1;


  sqlite3EndTable(pParse, 0, &sEnd, 0, 0);

create_view_fail:
  sqlite3SelectDelete(db, pSelect);
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameExprlistUnmap(pParse, pCNames);
  }
  sqlite3ExprListDelete(db, pCNames);
  return;
}
# 110036 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){
  Table *pSelTab;
  Select *pSel;
  int nErr = 0;
  int n;
  sqlite3 *db = pParse->db;

  int rc;


  sqlite3_xauth xAuth;


  ((void)0);


  db->nSchemaLock++;
  rc = sqlite3VtabCallConnect(pParse, pTable);
  db->nSchemaLock--;
  if( rc ){
    return 1;
  }
  if( ((pTable)->nModuleArg) ) return 0;






  if( pTable->nCol>0 ) return 0;
# 110082 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pTable->nCol<0 ){
    sqlite3ErrorMsg(pParse, "view %s is circularly defined", pTable->zName);
    return 1;
  }
  ((void)0);
# 110095 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);
  if( pSel ){

    u8 eParseMode = pParse->eParseMode;
    pParse->eParseMode = 0;

    n = pParse->nTab;
    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);
    pTable->nCol = -1;
    db->lookaside.bDisable++;

    xAuth = db->xAuth;
    db->xAuth = 0;
    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel, 0x40);
    db->xAuth = xAuth;



    pParse->nTab = n;
    if( pTable->pCheck ){






      sqlite3ColumnsFromExprList(pParse, pTable->pCheck,
                                 &pTable->nCol, &pTable->aCol);
      if( db->mallocFailed==0
       && pParse->nErr==0
       && pTable->nCol==pSel->pEList->nExpr
      ){
        sqlite3SelectAddColumnTypeAndCollation(pParse, pTable, pSel,
                                               0x40);
      }
    }else if( pSelTab ){



      ((void)0);
      pTable->nCol = pSelTab->nCol;
      pTable->aCol = pSelTab->aCol;
      pSelTab->nCol = 0;
      pSelTab->aCol = 0;
      ((void)0);
    }else{
      pTable->nCol = 0;
      nErr++;
    }
    sqlite3DeleteTable(db, pSelTab);
    sqlite3SelectDelete(db, pSel);
    db->lookaside.bDisable--;

    pParse->eParseMode = eParseMode;

  } else {
    nErr++;
  }
  pTable->pSchema->schemaFlags |= 0x0002;
  if( db->mallocFailed ){
    sqlite3DeleteColumnNames(db, pTable);
    pTable->aCol = 0;
    pTable->nCol = 0;
  }

  return nErr;
}






static void sqliteViewResetAll(sqlite3 *db, int idx){
  HashElem *i;
  ((void)0);
  if( !(((db)->aDb[idx].pSchema->schemaFlags&(0x0002))==(0x0002)) ) return;
  for(i=((&db->aDb[idx].pSchema->tblHash)->first); i;i=((i)->next)){
    Table *pTab = ((i)->data);
    if( pTab->pSelect ){
      sqlite3DeleteColumnNames(db, pTab);
      pTab->aCol = 0;
      pTab->nCol = 0;
    }
  }
  (db)->aDb[idx].pSchema->schemaFlags&=~(0x0002);
}
# 110205 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3RootPageMoved(sqlite3 *db, int iDb, int iFrom, int iTo){
  HashElem *pElem;
  Hash *pHash;
  Db *pDb;

  ((void)0);
  pDb = &db->aDb[iDb];
  pHash = &pDb->pSchema->tblHash;
  for(pElem=((pHash)->first); pElem; pElem=((pElem)->next)){
    Table *pTab = ((pElem)->data);
    if( pTab->tnum==iFrom ){
      pTab->tnum = iTo;
    }
  }
  pHash = &pDb->pSchema->idxHash;
  for(pElem=((pHash)->first); pElem; pElem=((pElem)->next)){
    Index *pIdx = ((pElem)->data);
    if( pIdx->tnum==iFrom ){
      pIdx->tnum = iTo;
    }
  }
}
# 110235 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void destroyRootPage(Parse *pParse, int iTable, int iDb){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int r1 = sqlite3GetTempReg(pParse);
  if( iTable<2 ) sqlite3ErrorMsg(pParse, "corrupt schema");
  sqlite3VdbeAddOp3(v, 136, iTable, r1, iDb);
  sqlite3MayAbort(pParse);
# 110251 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3NestedParse(pParse,
     "UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d",
     pParse->db->aDb[iDb].zDbSName, "sqlite_master", iTable, r1, r1);

  sqlite3ReleaseTempReg(pParse, r1);
}







static void destroyTable(Parse *pParse, Table *pTab){
# 110281 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  int iTab = pTab->tnum;
  int iDestroyed = 0;

  while( 1 ){
    Index *pIdx;
    int iLargest = 0;

    if( iDestroyed==0 || iTab<iDestroyed ){
      iLargest = iTab;
    }
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int iIdx = pIdx->tnum;
      ((void)0);
      if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){
        iLargest = iIdx;
      }
    }
    if( iLargest==0 ){
      return;
    }else{
      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
      ((void)0);
      destroyRootPage(pParse, iLargest, iDb);
      iDestroyed = iLargest;
    }
  }
}





static void sqlite3ClearStatTables(
  Parse *pParse,
  int iDb,
  const char *zType,
  const char *zName
){
  int i;
  const char *zDbName = pParse->db->aDb[iDb].zDbSName;
  for(i=1; i<=4; i++){
    char zTab[24];
    sqlite3_snprintf(sizeof(zTab),zTab,"sqlite_stat%d",i);
    if( sqlite3FindTable(pParse->db, zTab, zDbName) ){
      sqlite3NestedParse(pParse,
        "DELETE FROM %Q.%s WHERE %s=%Q",
        zDbName, zTab, zType, zName
      );
    }
  }
}




static void sqlite3CodeDropTable(Parse *pParse, Table *pTab, int iDb, int isView){
  Vdbe *v;
  sqlite3 *db = pParse->db;
  Trigger *pTrigger;
  Db *pDb = &db->aDb[iDb];

  v = sqlite3GetVdbe(pParse);
  ((void)0);
  sqlite3BeginWriteOperation(pParse, 1, iDb);


  if( ((pTab)->nModuleArg) ){
    sqlite3VdbeAddOp0(v, 160);
  }






  pTrigger = sqlite3TriggerList(pParse, pTab);
  while( pTrigger ){
    ((void)0)
                                               ;
    sqlite3DropTriggerPtr(pParse, pTrigger);
    pTrigger = pTrigger->pNext;
  }







  if( pTab->tabFlags & 0x0008 ){
    sqlite3NestedParse(pParse,
      "DELETE FROM %Q.sqlite_sequence WHERE name=%Q",
      pDb->zDbSName, pTab->zName
    );
  }
# 110385 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3NestedParse(pParse,
      "DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'",
      pDb->zDbSName, "sqlite_master", pTab->zName);
  if( !isView && !((pTab)->nModuleArg) ){
    destroyTable(pParse, pTab);
  }




  if( ((pTab)->nModuleArg) ){
    sqlite3VdbeAddOp4(v, 162, iDb, 0, 0, pTab->zName, 0);
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, 143, iDb, 0, 0, pTab->zName, 0);
  sqlite3ChangeCookie(pParse, iDb);
  sqliteViewResetAll(db, iDb);
}





static void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){
  Table *pTab;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  if( db->mallocFailed ){
    goto exit_drop_table;
  }
  ((void)0);
  ((void)0);
  if( sqlite3ReadSchema(pParse) ) goto exit_drop_table;
  if( noErr ) db->suppressErr++;
  ((void)0);
  pTab = sqlite3LocateTableItem(pParse, isView, &pName->a[0]);
  if( noErr ) db->suppressErr--;

  if( pTab==0 ){
    if( noErr ) sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
    goto exit_drop_table;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void)0);




  if( ((pTab)->nModuleArg) && sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto exit_drop_table;
  }

  {
    int code;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    const char *zDb = db->aDb[iDb].zDbSName;
    const char *zArg2 = 0;
    if( sqlite3AuthCheck(pParse, 9, zTab, 0, zDb)){
      goto exit_drop_table;
    }
    if( isView ){
      if( !0 && iDb==1 ){
        code = 15;
      }else{
        code = 17;
      }

    }else if( ((pTab)->nModuleArg) ){
      code = 30;
      zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;

    }else{
      if( !0 && iDb==1 ){
        code = 13;
      }else{
        code = 11;
      }
    }
    if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){
      goto exit_drop_table;
    }
    if( sqlite3AuthCheck(pParse, 9, pTab->zName, 0, zDb) ){
      goto exit_drop_table;
    }
  }

  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0
    && sqlite3_strnicmp(pTab->zName+7, "stat", 4)!=0
    && sqlite3_strnicmp(pTab->zName+7, "parameters", 10)!=0 ){
    sqlite3ErrorMsg(pParse, "table %s may not be dropped", pTab->zName);
    goto exit_drop_table;
  }





  if( isView && pTab->pSelect==0 ){
    sqlite3ErrorMsg(pParse, "use DROP TABLE to delete table %s", pTab->zName);
    goto exit_drop_table;
  }
  if( !isView && pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "use DROP VIEW to delete view %s", pTab->zName);
    goto exit_drop_table;
  }





  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    if( !isView ){
      sqlite3ClearStatTables(pParse, iDb, "tbl", pTab->zName);
      sqlite3FkDropTable(pParse, pName, pTab);
    }
    sqlite3CodeDropTable(pParse, pTab, iDb, isView);
  }

exit_drop_table:
  sqlite3SrcListDelete(db, pName);
}
# 110527 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3CreateForeignKey(
  Parse *pParse,
  ExprList *pFromCol,
  Token *pTo,
  ExprList *pToCol,
  int flags
){
  sqlite3 *db = pParse->db;

  FKey *pFKey = 0;
  FKey *pNextTo;
  Table *p = pParse->pNewTable;
  int nByte;
  int i;
  int nCol;
  char *z;

  ((void)0);
  if( p==0 || (pParse->eParseMode==1) ) goto fk_end;
  if( pFromCol==0 ){
    int iCol = p->nCol-1;
    if( (iCol<0) ) goto fk_end;
    if( pToCol && pToCol->nExpr!=1 ){
      sqlite3ErrorMsg(pParse, "foreign key on %s"
         " should reference only one column of table %T",
         p->aCol[iCol].zName, pTo);
      goto fk_end;
    }
    nCol = 1;
  }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){
    sqlite3ErrorMsg(pParse,
        "number of columns in foreign key does not match the number of "
        "columns in the referenced table");
    goto fk_end;
  }else{
    nCol = pFromCol->nExpr;
  }
  nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;
  if( pToCol ){
    for(i=0; i<pToCol->nExpr; i++){
      nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;
    }
  }
  pFKey = sqlite3DbMallocZero(db, nByte );
  if( pFKey==0 ){
    goto fk_end;
  }
  pFKey->pFrom = p;
  pFKey->pNextFrom = p->pFKey;
  z = (char*)&pFKey->aCol[nCol];
  pFKey->zTo = z;
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameTokenMap(pParse, (void*)z, pTo);
  }
  memcpy(z, pTo->z, pTo->n);
  z[pTo->n] = 0;
  sqlite3Dequote(z);
  z += pTo->n+1;
  pFKey->nCol = nCol;
  if( pFromCol==0 ){
    pFKey->aCol[0].iFrom = p->nCol-1;
  }else{
    for(i=0; i<nCol; i++){
      int j;
      for(j=0; j<p->nCol; j++){
        if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName)==0 ){
          pFKey->aCol[i].iFrom = j;
          break;
        }
      }
      if( j>=p->nCol ){
        sqlite3ErrorMsg(pParse,
          "unknown column \"%s\" in foreign key definition",
          pFromCol->a[i].zName);
        goto fk_end;
      }
      if( (pParse->eParseMode>=2) ){
        sqlite3RenameTokenRemap(pParse, &pFKey->aCol[i], pFromCol->a[i].zName);
      }
    }
  }
  if( pToCol ){
    for(i=0; i<nCol; i++){
      int n = sqlite3Strlen30(pToCol->a[i].zName);
      pFKey->aCol[i].zCol = z;
      if( (pParse->eParseMode>=2) ){
        sqlite3RenameTokenRemap(pParse, z, pToCol->a[i].zName);
      }
      memcpy(z, pToCol->a[i].zName, n);
      z[n] = 0;
      z += n+1;
    }
  }
  pFKey->isDeferred = 0;
  pFKey->aAction[0] = (u8)(flags & 0xff);
  pFKey->aAction[1] = (u8)((flags >> 8 ) & 0xff);

  ((void)0);
  pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash,
      pFKey->zTo, (void *)pFKey
  );
  if( pNextTo==pFKey ){
    sqlite3OomFault(db);
    goto fk_end;
  }
  if( pNextTo ){
    ((void)0);
    pFKey->pNextTo = pNextTo;
    pNextTo->pPrevTo = pFKey;
  }



  p->pFKey = pFKey;
  pFKey = 0;

fk_end:
  sqlite3DbFree(db, pFKey);

  sqlite3ExprListDelete(db, pFromCol);
  sqlite3ExprListDelete(db, pToCol);
}
# 110657 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){

  Table *pTab;
  FKey *pFKey;
  if( (pTab = pParse->pNewTable)==0 || (pFKey = pTab->pFKey)==0 ) return;
  ((void)0);
  pFKey->isDeferred = (u8)isDeferred;

}
# 110678 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){
  Table *pTab = pIndex->pTable;
  int iTab = pParse->nTab++;
  int iIdx = pParse->nTab++;
  int iSorter;
  int addr1;
  int addr2;
  int tnum;
  int iPartIdxLabel;
  Vdbe *v;
  KeyInfo *pKey;
  int regRecord;
  sqlite3 *db = pParse->db;
  int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);


  if( sqlite3AuthCheck(pParse, 27, pIndex->zName, 0,
      db->aDb[iDb].zDbSName ) ){
    return;
  }



  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);

  v = sqlite3GetVdbe(pParse);
  if( v==0 ) return;
  if( memRootPage>=0 ){
    tnum = memRootPage;
  }else{
    tnum = pIndex->tnum;
  }
  pKey = sqlite3KeyInfoOfIndex(pParse, pIndex);
  ((void)0);


  iSorter = pParse->nTab++;
  sqlite3VdbeAddOp4(v, 114, iSorter, 0, pIndex->nKeyCol, (char*)
                    sqlite3KeyInfoRef(pKey), (-9));



  sqlite3OpenTable(pParse, iTab, iDb, pTab, 97);
  addr1 = sqlite3VdbeAddOp2(v, 36, iTab, 0); ;
  regRecord = sqlite3GetTempReg(pParse);
  sqlite3MultiWrite(pParse);

  sqlite3GenerateIndexKey(pParse,pIndex,iTab,regRecord,0,&iPartIdxLabel,0,0);
  sqlite3VdbeAddOp2(v, 131, iSorter, regRecord);
  sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
  sqlite3VdbeAddOp2(v, 5, iTab, addr1+1); ;
  sqlite3VdbeJumpHere(v, addr1);
  if( memRootPage<0 ) sqlite3VdbeAddOp2(v, 137, tnum, iDb);
  sqlite3VdbeAddOp4(v, 98, iIdx, tnum, iDb,
                    (char *)pKey, (-9));
  sqlite3VdbeChangeP5(v, 0x01|((memRootPage>=0)?0x10:0));

  addr1 = sqlite3VdbeAddOp2(v, 34, iSorter, 0); ;
  if( ((pIndex)->onError!=0) ){
    int j2 = sqlite3VdbeGoto(v, 1);
    addr2 = sqlite3VdbeCurrentAddr(v);
    ;
    sqlite3VdbeAddOp4Int(v, 125, iSorter, j2, regRecord,
                         pIndex->nKeyCol); ;
    sqlite3UniqueConstraint(pParse, 2, pIndex);
    sqlite3VdbeJumpHere(v, j2);
  }else{







    sqlite3MayAbort(pParse);
    addr2 = sqlite3VdbeCurrentAddr(v);
  }
  sqlite3VdbeAddOp3(v, 126, iSorter, regRecord, iIdx);
  if( !pIndex->bAscKeyBug ){







    sqlite3VdbeAddOp1(v, 130, iIdx);
  }
  sqlite3VdbeAddOp2(v, 132, iIdx, regRecord);
  sqlite3VdbeChangeP5(v, 0x10);
  sqlite3ReleaseTempReg(pParse, regRecord);
  sqlite3VdbeAddOp2(v, 3, iSorter, addr2); ;
  sqlite3VdbeJumpHere(v, addr1);

  sqlite3VdbeAddOp1(v, 117, iTab);
  sqlite3VdbeAddOp1(v, 117, iIdx);
  sqlite3VdbeAddOp1(v, 117, iSorter);
}
# 110784 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Index *sqlite3AllocateIndexObject(
  sqlite3 *db,
  i16 nCol,
  int nExtra,
  char **ppExtra
){
  Index *p;
  int nByte;

  nByte = (((sizeof(Index))+7)&~7) +
          (((sizeof(char*)*nCol)+7)&~7) +
          (((sizeof(LogEst)*(nCol+1) + sizeof(i16)*nCol + sizeof(u8)*nCol)+7)&~7)

                                 ;
  p = sqlite3DbMallocZero(db, nByte + nExtra);
  if( p ){
    char *pExtra = ((char*)p)+(((sizeof(Index))+7)&~7);
    p->azColl = (const char**)pExtra; pExtra += (((sizeof(char*)*nCol)+7)&~7);
    p->aiRowLogEst = (LogEst*)pExtra; pExtra += sizeof(LogEst)*(nCol+1);
    p->aiColumn = (i16*)pExtra; pExtra += sizeof(i16)*nCol;
    p->aSortOrder = (u8*)pExtra;
    p->nColumn = nCol;
    p->nKeyCol = nCol - 1;
    *ppExtra = ((char*)p) + nByte;
  }
  return p;
}






static int sqlite3HasExplicitNulls(Parse *pParse, ExprList *pList){
  if( pList ){
    int i;
    for(i=0; i<pList->nExpr; i++){
      if( pList->a[i].bNulls ){
        u8 sf = pList->a[i].sortFlags;
        sqlite3ErrorMsg(pParse, "unsupported use of NULLS %s",
            (sf==0 || sf==3) ? "FIRST" : "LAST"
        );
        return 1;
      }
    }
  }
  return 0;
}
# 110845 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3CreateIndex(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  SrcList *pTblName,
  ExprList *pList,
  int onError,
  Token *pStart,
  Expr *pPIWhere,
  int sortOrder,
  int ifNotExist,
  u8 idxType
){
  Table *pTab = 0;
  Index *pIndex = 0;
  char *zName = 0;
  int nName;
  int i, j;
  DbFixer sFix;
  int sortOrderMask;
  sqlite3 *db = pParse->db;
  Db *pDb;
  int iDb;
  Token *pName = 0;
  struct ExprList_item *pListItem;
  int nExtra = 0;
  int nExtraCol;
  char *zExtra = 0;
  Index *pPk = 0;

  if( db->mallocFailed || pParse->nErr>0 ){
    goto exit_create_index;
  }
  if( (pParse->eParseMode==1) && idxType!=2 ){
    goto exit_create_index;
  }
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto exit_create_index;
  }
  if( sqlite3HasExplicitNulls(pParse, pList) ){
    goto exit_create_index;
  }




  if( pTblName!=0 ){





    ((void)0);
    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ) goto exit_create_index;
    ((void)0);






    if( !db->init.busy ){
      pTab = sqlite3SrcListLookup(pParse, pTblName);
      if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){
        iDb = 1;
      }
    }


    sqlite3FixInit(&sFix, pParse, iDb, "index", pName);
    if( sqlite3FixSrcList(&sFix, pTblName) ){


      ((void)0);
    }
    pTab = sqlite3LocateTableItem(pParse, 0, &pTblName->a[0]);
    ((void)0);
    if( pTab==0 ) goto exit_create_index;
    if( iDb==1 && db->aDb[iDb].pSchema!=pTab->pSchema ){
      sqlite3ErrorMsg(pParse,
           "cannot create a TEMP index on non-TEMP table \"%s\"",
           pTab->zName);
      goto exit_create_index;
    }
    if( !(((pTab)->tabFlags & 0x0020)==0) ) pPk = sqlite3PrimaryKeyIndex(pTab);
  }else{
    ((void)0);
    ((void)0);
    pTab = pParse->pNewTable;
    if( !pTab ) goto exit_create_index;
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  }
  pDb = &db->aDb[iDb];

  ((void)0);
  ((void)0);
  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0
       && db->init.busy==0
       && pTblName!=0






 ){
    sqlite3ErrorMsg(pParse, "table %s may not be indexed", pTab->zName);
    goto exit_create_index;
  }

  if( pTab->pSelect ){
    sqlite3ErrorMsg(pParse, "views may not be indexed");
    goto exit_create_index;
  }


  if( ((pTab)->nModuleArg) ){
    sqlite3ErrorMsg(pParse, "virtual tables may not be indexed");
    goto exit_create_index;
  }
# 110981 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pName ){
    zName = sqlite3NameFromToken(db, pName);
    if( zName==0 ) goto exit_create_index;
    ((void)0);
    if( 0!=sqlite3CheckObjectName(pParse, zName,"index",pTab->zName) ){
      goto exit_create_index;
    }
    if( !(pParse->eParseMode>=2) ){
      if( !db->init.busy ){
        if( sqlite3FindTable(db, zName, 0)!=0 ){
          sqlite3ErrorMsg(pParse, "there is already a table named %s", zName);
          goto exit_create_index;
        }
      }
      if( sqlite3FindIndex(db, zName, pDb->zDbSName)!=0 ){
        if( !ifNotExist ){
          sqlite3ErrorMsg(pParse, "index %s already exists", zName);
        }else{
          ((void)0);
          sqlite3CodeVerifySchema(pParse, iDb);
        }
        goto exit_create_index;
      }
    }
  }else{
    int n;
    Index *pLoop;
    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}
    zName = sqlite3MPrintf(db, "sqlite_autoindex_%s_%d", pTab->zName, n);
    if( zName==0 ){
      goto exit_create_index;
    }






    if( (pParse->eParseMode!=0) ) zName[7]++;
  }




  if( !(pParse->eParseMode>=2) ){
    const char *zDb = pDb->zDbSName;
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master"), 0, zDb) ){
      goto exit_create_index;
    }
    i = 1;
    if( !0 && iDb==1 ) i = 3;
    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){
      goto exit_create_index;
    }
  }






  if( pList==0 ){
    Token prevCol;
    Column *pCol = &pTab->aCol[pTab->nCol-1];
    pCol->colFlags |= 0x0008;
    sqlite3TokenInit(&prevCol, pCol->zName);
    pList = sqlite3ExprListAppend(pParse, 0,
              sqlite3ExprAlloc(db, 59, &prevCol, 0));
    if( pList==0 ) goto exit_create_index;
    ((void)0);
    sqlite3ExprListSetSortOrder(pList, sortOrder, -1);
  }else{
    sqlite3ExprListCheckLength(pParse, pList, "index");
    if( pParse->nErr ) goto exit_create_index;
  }




  for(i=0; i<pList->nExpr; i++){
    Expr *pExpr = pList->a[i].pExpr;
    ((void)0);
    if( pExpr->op==109 ){
      nExtra += (1 + sqlite3Strlen30(pExpr->u.zToken));
    }
  }




  nName = sqlite3Strlen30(zName);
  nExtraCol = pPk ? pPk->nKeyCol : 1;
  ((void)0);
  pIndex = sqlite3AllocateIndexObject(db, pList->nExpr + nExtraCol,
                                      nName + nExtra + 1, &zExtra);
  if( db->mallocFailed ){
    goto exit_create_index;
  }
  ((void)0);
  ((void)0);
  pIndex->zName = zExtra;
  zExtra += nName + 1;
  memcpy(pIndex->zName, zName, nName+1);
  pIndex->pTable = pTab;
  pIndex->onError = (u8)onError;
  pIndex->uniqNotNull = onError!=0;
  pIndex->idxType = idxType;
  pIndex->pSchema = db->aDb[iDb].pSchema;
  pIndex->nKeyCol = pList->nExpr;
  if( pPIWhere ){
    sqlite3ResolveSelfReference(pParse, pTab, 0x0002, pPIWhere, 0);
    pIndex->pPartIdxWhere = pPIWhere;
    pPIWhere = 0;
  }
  ((void)0);



  if( pDb->pSchema->file_format>=4 ){
    sortOrderMask = -1;
  }else{
    sortOrderMask = 0;
  }
# 111114 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pListItem = pList->a;
  if( (pParse->eParseMode>=2) ){
    pIndex->aColExpr = pList;
    pList = 0;
  }
  for(i=0; i<pIndex->nKeyCol; i++, pListItem++){
    Expr *pCExpr;
    int requestedSortOrder;
    const char *zColl;

    sqlite3StringToId(pListItem->pExpr);
    sqlite3ResolveSelfReference(pParse, pTab, 0x0020, pListItem->pExpr, 0);
    if( pParse->nErr ) goto exit_create_index;
    pCExpr = sqlite3ExprSkipCollate(pListItem->pExpr);
    if( pCExpr->op!=162 ){
      if( pTab==pParse->pNewTable ){
        sqlite3ErrorMsg(pParse, "expressions prohibited in PRIMARY KEY and "
                                "UNIQUE constraints");
        goto exit_create_index;
      }
      if( pIndex->aColExpr==0 ){
        pIndex->aColExpr = pList;
        pList = 0;
      }
      j = (-2);
      pIndex->aiColumn[i] = (-2);
      pIndex->uniqNotNull = 0;
    }else{
      j = pCExpr->iColumn;
      ((void)0);
      if( j<0 ){
        j = pTab->iPKey;
      }else if( pTab->aCol[j].notNull==0 ){
        pIndex->uniqNotNull = 0;
      }
      pIndex->aiColumn[i] = (i16)j;
    }
    zColl = 0;
    if( pListItem->pExpr->op==109 ){
      int nColl;
      zColl = pListItem->pExpr->u.zToken;
      nColl = sqlite3Strlen30(zColl) + 1;
      ((void)0);
      memcpy(zExtra, zColl, nColl);
      zColl = zExtra;
      zExtra += nColl;
      nExtra -= nColl;
    }else if( j>=0 ){
      zColl = pTab->aCol[j].zColl;
    }
    if( !zColl ) zColl = sqlite3StrBINARY;
    if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){
      goto exit_create_index;
    }
    pIndex->azColl[i] = zColl;
    requestedSortOrder = pListItem->sortFlags & sortOrderMask;
    pIndex->aSortOrder[i] = (u8)requestedSortOrder;
  }





  if( pPk ){
    for(j=0; j<pPk->nKeyCol; j++){
      int x = pPk->aiColumn[j];
      ((void)0);
      if( isDupColumn(pIndex, pIndex->nKeyCol, pPk, j) ){
        pIndex->nColumn--;
      }else{
        ;
        pIndex->aiColumn[i] = x;
        pIndex->azColl[i] = pPk->azColl[j];
        pIndex->aSortOrder[i] = pPk->aSortOrder[j];
        i++;
      }
    }
    ((void)0);
  }else{
    pIndex->aiColumn[i] = (-1);
    pIndex->azColl[i] = sqlite3StrBINARY;
  }
  sqlite3DefaultRowEst(pIndex);
  if( pParse->pNewTable==0 ) estimateIndexWidth(pIndex);



  ((void)0)
                                                                        ;
  recomputeColumnsNotIndexed(pIndex);
  if( pTblName!=0 && pIndex->nColumn>=pTab->nCol ){
    pIndex->isCovering = 1;
    for(j=0; j<pTab->nCol; j++){
      if( j==pTab->iPKey ) continue;
      if( sqlite3ColumnOfIndex(pIndex,j)>=0 ) continue;
      pIndex->isCovering = 0;
      break;
    }
  }

  if( pTab==pParse->pNewTable ){
# 111236 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    Index *pIdx;
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int k;
      ((void)0);
      ((void)0);
      ((void)0);

      if( pIdx->nKeyCol!=pIndex->nKeyCol ) continue;
      for(k=0; k<pIdx->nKeyCol; k++){
        const char *z1;
        const char *z2;
        ((void)0);
        if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;
        z1 = pIdx->azColl[k];
        z2 = pIndex->azColl[k];
        if( sqlite3StrICmp(z1, z2) ) break;
      }
      if( k==pIdx->nKeyCol ){
        if( pIdx->onError!=pIndex->onError ){







          if( !(pIdx->onError==11 || pIndex->onError==11) ){
            sqlite3ErrorMsg(pParse,
                "conflicting ON CONFLICT clauses specified", 0);
          }
          if( pIdx->onError==11 ){
            pIdx->onError = pIndex->onError;
          }
        }
        if( idxType==2 ) pIdx->idxType = idxType;
        if( (pParse->eParseMode>=2) ){
          pIndex->pNext = pParse->pNewIndex;
          pParse->pNewIndex = pIndex;
          pIndex = 0;
        }
        goto exit_create_index;
      }
    }
  }

  if( !(pParse->eParseMode>=2) ){




    ((void)0);
    if( db->init.busy ){
      Index *p;
      ((void)0);
      ((void)0);
      if( pTblName!=0 ){
        pIndex->tnum = db->init.newTnum;
        if( sqlite3IndexHasDuplicateRootPage(pIndex) ){
          sqlite3ErrorMsg(pParse, "invalid rootpage");
          pParse->rc = sqlite3CorruptError(111295);
          goto exit_create_index;
        }
      }
      p = sqlite3HashInsert(&pIndex->pSchema->idxHash,
          pIndex->zName, pIndex);
      if( p ){
        ((void)0);
        sqlite3OomFault(db);
        goto exit_create_index;
      }
      db->mDbFlags |= 0x0001;
    }
# 111322 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    else if( (((pTab)->tabFlags & 0x0020)==0) || pTblName!=0 ){
      Vdbe *v;
      char *zStmt;
      int iMem = ++pParse->nMem;

      v = sqlite3GetVdbe(pParse);
      if( v==0 ) goto exit_create_index;

      sqlite3BeginWriteOperation(pParse, 1, iDb);







      pIndex->tnum = sqlite3VdbeAddOp0(v, 170);
      sqlite3VdbeAddOp3(v, 139, iDb, iMem, 2);




      ((void)0);
      if( pStart ){
        int n = (int)(pParse->sLastToken.z - pName->z) + pParse->sLastToken.n;
        if( pName->z[n-1]==';' ) n--;

        zStmt = sqlite3MPrintf(db, "CREATE%s INDEX %.*s",
            onError==0 ? "" : " UNIQUE", n, pName->z);
      }else{


        zStmt = 0;
      }



      sqlite3NestedParse(pParse,
          "INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);",
          db->aDb[iDb].zDbSName, "sqlite_master",
          pIndex->zName,
          pTab->zName,
          iMem,
          zStmt
          );
      sqlite3DbFree(db, zStmt);




      if( pTblName ){
        sqlite3RefillIndex(pParse, pIndex, iMem);
        sqlite3ChangeCookie(pParse, iDb);
        sqlite3VdbeAddParseSchemaOp(v, iDb,
            sqlite3MPrintf(db, "name='%q' AND type='index'", pIndex->zName));
        sqlite3VdbeAddOp2(v, 158, 0, 1);
      }

      sqlite3VdbeJumpHere(v, pIndex->tnum);
    }
  }







  if( db->init.busy || pTblName==0 ){
    if( onError!=5 || pTab->pIndex==0
         || pTab->pIndex->onError==5){
      pIndex->pNext = pTab->pIndex;
      pTab->pIndex = pIndex;
    }else{
      Index *pOther = pTab->pIndex;
      while( pOther->pNext && pOther->pNext->onError!=5 ){
        pOther = pOther->pNext;
      }
      pIndex->pNext = pOther->pNext;
      pOther->pNext = pIndex;
    }
    pIndex = 0;
  }
  else if( (pParse->eParseMode>=2) ){
    ((void)0);
    pParse->pNewIndex = pIndex;
    pIndex = 0;
  }


exit_create_index:
  if( pIndex ) sqlite3FreeIndex(db, pIndex);
  sqlite3ExprDelete(db, pPIWhere);
  sqlite3ExprListDelete(db, pList);
  sqlite3SrcListDelete(db, pTblName);
  sqlite3DbFree(db, zName);
}
# 111438 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3DefaultRowEst(Index *pIdx){

  LogEst aVal[] = { 33, 32, 30, 28, 26 };
  LogEst *a = pIdx->aiRowLogEst;
  int nCopy = ((((int)(sizeof(aVal)/sizeof(aVal[0]))))<(pIdx->nKeyCol)?(((int)(sizeof(aVal)/sizeof(aVal[0])))):(pIdx->nKeyCol));
  int i;


  ((void)0);




  a[0] = pIdx->pTable->nRowLogEst;
  if( pIdx->pPartIdxWhere!=0 ) a[0] -= 10; ((void)0);
  if( a[0]<33 ) a[0] = 33; ((void)0);



  memcpy(&a[1], aVal, nCopy*sizeof(LogEst));
  for(i=nCopy+1; i<=pIdx->nKeyCol; i++){
    a[i] = 23; ((void)0);
  }

  ((void)0);
  if( ((pIdx)->onError!=0) ) a[pIdx->nKeyCol] = 0;
}





static void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){
  Index *pIndex;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  ((void)0);
  if( db->mallocFailed ){
    goto exit_drop_index;
  }
  ((void)0);
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto exit_drop_index;
  }
  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);
  if( pIndex==0 ){
    if( !ifExists ){
      sqlite3ErrorMsg(pParse, "no such index: %S", pName, 0);
    }else{
      sqlite3CodeVerifyNamedSchema(pParse, pName->a[0].zDatabase);
    }
    pParse->checkSchema = 1;
    goto exit_drop_index;
  }
  if( pIndex->idxType!=0 ){
    sqlite3ErrorMsg(pParse, "index associated with UNIQUE "
      "or PRIMARY KEY constraint cannot be dropped", 0);
    goto exit_drop_index;
  }
  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);

  {
    int code = 10;
    Table *pTab = pIndex->pTable;
    const char *zDb = db->aDb[iDb].zDbSName;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    if( sqlite3AuthCheck(pParse, 9, zTab, 0, zDb) ){
      goto exit_drop_index;
    }
    if( !0 && iDb ) code = 12;
    if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){
      goto exit_drop_index;
    }
  }



  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3BeginWriteOperation(pParse, 1, iDb);
    sqlite3NestedParse(pParse,
       "DELETE FROM %Q.%s WHERE name=%Q AND type='index'",
       db->aDb[iDb].zDbSName, "sqlite_master", pIndex->zName
    );
    sqlite3ClearStatTables(pParse, iDb, "idx", pIndex->zName);
    sqlite3ChangeCookie(pParse, iDb);
    destroyRootPage(pParse, pIndex->tnum, iDb);
    sqlite3VdbeAddOp4(v, 144, iDb, 0, 0, pIndex->zName, 0);
  }

exit_drop_index:
  sqlite3SrcListDelete(db, pName);
}
# 111551 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *sqlite3ArrayAllocate(
  sqlite3 *db,
  void *pArray,
  int szEntry,
  int *pnEntry,
  int *pIdx
){
  char *z;
  sqlite3_int64 n = *pIdx = *pnEntry;
  if( (n & (n-1))==0 ){
    sqlite3_int64 sz = (n==0) ? 1 : 2*n;
    void *pNew = sqlite3DbRealloc(db, pArray, sz*szEntry);
    if( pNew==0 ){
      *pIdx = -1;
      return pArray;
    }
    pArray = pNew;
  }
  z = (char*)pArray;
  memset(&z[n * szEntry], 0, szEntry);
  ++*pnEntry;
  return pArray;
}







static IdList *sqlite3IdListAppend(Parse *pParse, IdList *pList, Token *pToken){
  sqlite3 *db = pParse->db;
  int i;
  if( pList==0 ){
    pList = sqlite3DbMallocZero(db, sizeof(IdList) );
    if( pList==0 ) return 0;
  }
  pList->a = sqlite3ArrayAllocate(
      db,
      pList->a,
      sizeof(pList->a[0]),
      &pList->nId,
      &i
  );
  if( i<0 ){
    sqlite3IdListDelete(db, pList);
    return 0;
  }
  pList->a[i].zName = sqlite3NameFromToken(db, pToken);
  if( (pParse->eParseMode>=2) && pList->a[i].zName ){
    sqlite3RenameTokenMap(pParse, (void*)pList->a[i].zName, pToken);
  }
  return pList;
}




static void sqlite3IdListDelete(sqlite3 *db, IdList *pList){
  int i;
  if( pList==0 ) return;
  for(i=0; i<pList->nId; i++){
    sqlite3DbFree(db, pList->a[i].zName);
  }
  sqlite3DbFree(db, pList->a);
  sqlite3DbFreeNN(db, pList);
}





static int sqlite3IdListIndex(IdList *pList, const char *zName){
  int i;
  if( pList==0 ) return -1;
  for(i=0; i<pList->nId; i++){
    if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;
  }
  return -1;
}
# 111641 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_MAX_SRCLIST 200
# 111664 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static SrcList *sqlite3SrcListEnlarge(
  Parse *pParse,
  SrcList *pSrc,
  int nExtra,
  int iStart
){
  int i;


  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  if( (u32)pSrc->nSrc+nExtra>pSrc->nAlloc ){
    SrcList *pNew;
    sqlite3_int64 nAlloc = 2*(sqlite3_int64)pSrc->nSrc+nExtra;
    sqlite3 *db = pParse->db;

    if( pSrc->nSrc+nExtra>=200 ){
      sqlite3ErrorMsg(pParse, "too many FROM clause terms, max: %d",
                      200);
      return 0;
    }
    if( nAlloc>200 ) nAlloc = 200;
    pNew = sqlite3DbRealloc(db, pSrc,
               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );
    if( pNew==0 ){
      ((void)0);
      return 0;
    }
    pSrc = pNew;
    pSrc->nAlloc = nAlloc;
  }



  for(i=pSrc->nSrc-1; i>=iStart; i--){
    pSrc->a[i+nExtra] = pSrc->a[i];
  }
  pSrc->nSrc += nExtra;


  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);
  for(i=iStart; i<iStart+nExtra; i++){
    pSrc->a[i].iCursor = -1;
  }


  return pSrc;
}
# 111753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static SrcList *sqlite3SrcListAppend(
  Parse *pParse,
  SrcList *pList,
  Token *pTable,
  Token *pDatabase
){
  struct SrcList_item *pItem;
  sqlite3 *db;
  ((void)0);
  ((void)0);
  ((void)0);
  db = pParse->db;
  if( pList==0 ){
    pList = sqlite3DbMallocRawNN(pParse->db, sizeof(SrcList) );
    if( pList==0 ) return 0;
    pList->nAlloc = 1;
    pList->nSrc = 1;
    memset(&pList->a[0], 0, sizeof(pList->a[0]));
    pList->a[0].iCursor = -1;
  }else{
    SrcList *pNew = sqlite3SrcListEnlarge(pParse, pList, 1, pList->nSrc);
    if( pNew==0 ){
      sqlite3SrcListDelete(db, pList);
      return 0;
    }else{
      pList = pNew;
    }
  }
  pItem = &pList->a[pList->nSrc-1];
  if( pDatabase && pDatabase->z==0 ){
    pDatabase = 0;
  }
  if( pDatabase ){
    pItem->zName = sqlite3NameFromToken(db, pDatabase);
    pItem->zDatabase = sqlite3NameFromToken(db, pTable);
  }else{
    pItem->zName = sqlite3NameFromToken(db, pTable);
    pItem->zDatabase = 0;
  }
  return pList;
}




static void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){
  int i;
  struct SrcList_item *pItem;
  ((void)0);
  if( pList ){
    for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){
      if( pItem->iCursor>=0 ) break;
      pItem->iCursor = pParse->nTab++;
      if( pItem->pSelect ){
        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);
      }
    }
  }
}




static void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){
  int i;
  struct SrcList_item *pItem;
  if( pList==0 ) return;
  for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){
    sqlite3DbFree(db, pItem->zDatabase);
    sqlite3DbFree(db, pItem->zName);
    sqlite3DbFree(db, pItem->zAlias);
    if( pItem->fg.isIndexedBy ) sqlite3DbFree(db, pItem->u1.zIndexedBy);
    if( pItem->fg.isTabFunc ) sqlite3ExprListDelete(db, pItem->u1.pFuncArg);
    sqlite3DeleteTable(db, pItem->pTab);
    sqlite3SelectDelete(db, pItem->pSelect);
    sqlite3ExprDelete(db, pItem->pOn);
    sqlite3IdListDelete(db, pItem->pUsing);
  }
  sqlite3DbFreeNN(db, pList);
}
# 111850 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static SrcList *sqlite3SrcListAppendFromTerm(
  Parse *pParse,
  SrcList *p,
  Token *pTable,
  Token *pDatabase,
  Token *pAlias,
  Select *pSubquery,
  Expr *pOn,
  IdList *pUsing
){
  struct SrcList_item *pItem;
  sqlite3 *db = pParse->db;
  if( !p && (pOn || pUsing) ){
    sqlite3ErrorMsg(pParse, "a JOIN clause is required before %s",
      (pOn ? "ON" : "USING")
    );
    goto append_from_error;
  }
  p = sqlite3SrcListAppend(pParse, p, pTable, pDatabase);
  if( p==0 ){
    goto append_from_error;
  }
  ((void)0);
  pItem = &p->a[p->nSrc-1];
  ((void)0);
  ((void)0);
  if( (pParse->eParseMode>=2) && pItem->zName ){
    Token *pToken = ((pDatabase) && pDatabase->z) ? pDatabase : pTable;
    sqlite3RenameTokenMap(pParse, pItem->zName, pToken);
  }
  ((void)0);
  if( pAlias->n ){
    pItem->zAlias = sqlite3NameFromToken(db, pAlias);
  }
  pItem->pSelect = pSubquery;
  pItem->pOn = pOn;
  pItem->pUsing = pUsing;
  return p;

 append_from_error:
  ((void)0);
  sqlite3ExprDelete(db, pOn);
  sqlite3IdListDelete(db, pUsing);
  sqlite3SelectDelete(db, pSubquery);
  return 0;
}





static void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){
  ((void)0);
  if( p && pIndexedBy->n>0 ){
    struct SrcList_item *pItem;
    ((void)0);
    pItem = &p->a[p->nSrc-1];
    ((void)0);
    ((void)0);
    ((void)0);
    if( pIndexedBy->n==1 && !pIndexedBy->z ){


      pItem->fg.notIndexed = 1;
    }else{
      pItem->u1.zIndexedBy = sqlite3NameFromToken(pParse->db, pIndexedBy);
      pItem->fg.isIndexedBy = 1;
    }
  }
}





static void sqlite3SrcListFuncArgs(Parse *pParse, SrcList *p, ExprList *pList){
  if( p ){
    struct SrcList_item *pItem = &p->a[p->nSrc-1];
    ((void)0);
    ((void)0);
    ((void)0);
    pItem->u1.pFuncArg = pList;
    pItem->fg.isTabFunc = 1;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
}
# 111953 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SrcListShiftJoinType(SrcList *p){
  if( p ){
    int i;
    for(i=p->nSrc-1; i>0; i--){
      p->a[i].fg.jointype = p->a[i-1].fg.jointype;
    }
    p->a[0].fg.jointype = 0;
  }
}




static void sqlite3BeginTransaction(Parse *pParse, int type){
  sqlite3 *db;
  Vdbe *v;
  int i;

  ((void)0);
  db = pParse->db;
  ((void)0);
  if( sqlite3AuthCheck(pParse, 22, "BEGIN", 0, 0) ){
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if( !v ) return;
  if( type!=7 ){
    for(i=0; i<db->nDb; i++){
      sqlite3VdbeAddOp2(v, 2, i, (type==9)+1);
      sqlite3VdbeUsesBtree(v, i);
    }
  }
  sqlite3VdbeAddOp0(v, 1);
}






static void sqlite3EndTransaction(Parse *pParse, int eType){
  Vdbe *v;
  int isRollback;

  ((void)0);
  ((void)0);
  ((void)0);
  isRollback = eType==12;
  if( sqlite3AuthCheck(pParse, 22,
       isRollback ? "ROLLBACK" : "COMMIT", 0, 0) ){
    return;
  }
  v = sqlite3GetVdbe(pParse);
  if( v ){
    sqlite3VdbeAddOp2(v, 1, 1, isRollback);
  }
}





static void sqlite3Savepoint(Parse *pParse, int op, Token *pName){
  char *zName = sqlite3NameFromToken(pParse->db, pName);
  if( zName ){
    Vdbe *v = sqlite3GetVdbe(pParse);

    static const char * const az[] = { "BEGIN", "RELEASE", "ROLLBACK" };
    ((void)0);

    if( !v || sqlite3AuthCheck(pParse, 32, az[op], zName, 0) ){
      sqlite3DbFree(pParse->db, zName);
      return;
    }
    sqlite3VdbeAddOp4(v, 0, op, 0, 0, zName, (-7));
  }
}





static int sqlite3OpenTempDatabase(Parse *pParse){
  sqlite3 *db = pParse->db;
  if( db->aDb[1].pBt==0 && !pParse->explain ){
    int rc;
    Btree *pBt;
    static const int flags =
          0x00000002 |
          0x00000004 |
          0x00000010 |
          0x00000008 |
          0x00000200;

    rc = sqlite3BtreeOpen(db->pVfs, 0, db, &pBt, 0, flags);
    if( rc!=0 ){
      sqlite3ErrorMsg(pParse, "unable to open a temporary database "
        "file for storing temporary tables");
      pParse->rc = rc;
      return 1;
    }
    db->aDb[1].pBt = pBt;
    ((void)0);
    if( 7==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0) ){
      sqlite3OomFault(db);
      return 1;
    }
  }
  return 0;
}







static void sqlite3CodeVerifySchema(Parse *pParse, int iDb){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( (((pToplevel->cookieMask)&(((yDbMask)1)<<(iDb)))!=0)==0 ){
    (pToplevel->cookieMask)|=(((yDbMask)1)<<(iDb));
    if( !0 && iDb==1 ){
      sqlite3OpenTempDatabase(pToplevel);
    }
  }
}





static void sqlite3CodeVerifyNamedSchema(Parse *pParse, const char *zDb){
  sqlite3 *db = pParse->db;
  int i;
  for(i=0; i<db->nDb; i++){
    Db *pDb = &db->aDb[i];
    if( pDb->pBt && (!zDb || 0==sqlite3StrICmp(zDb, pDb->zDbSName)) ){
      sqlite3CodeVerifySchema(pParse, i);
    }
  }
}
# 112113 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  sqlite3CodeVerifySchema(pParse, iDb);
  (pToplevel->writeMask)|=(((yDbMask)1)<<(iDb));
  pToplevel->isMultiWrite |= setStatement;
}
# 112127 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3MultiWrite(Parse *pParse){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  pToplevel->isMultiWrite = 1;
}
# 112148 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3MayAbort(Parse *pParse){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  pToplevel->mayAbort = 1;
}






static void sqlite3HaltConstraint(
  Parse *pParse,
  int errCode,
  int onError,
  char *p4,
  i8 p4type,
  u8 p5Errmsg
){
  Vdbe *v = sqlite3GetVdbe(pParse);
  ((void)0);
  if( onError==2 ){
    sqlite3MayAbort(pParse);
  }
  sqlite3VdbeAddOp4(v, 69, errCode, onError, 0, p4, p4type);
  sqlite3VdbeChangeP5(v, p5Errmsg);
}




static void sqlite3UniqueConstraint(
  Parse *pParse,
  int onError,
  Index *pIdx
){
  char *zErr;
  int j;
  StrAccum errMsg;
  Table *pTab = pIdx->pTable;

  sqlite3StrAccumInit(&errMsg, pParse->db, 0, 0,
                      pParse->db->aLimit[0]);
  if( pIdx->aColExpr ){
    sqlite3_str_appendf(&errMsg, "index '%q'", pIdx->zName);
  }else{
    for(j=0; j<pIdx->nKeyCol; j++){
      char *zCol;
      ((void)0);
      zCol = pTab->aCol[pIdx->aiColumn[j]].zName;
      if( j ) sqlite3_str_append(&errMsg, ", ", 2);
      sqlite3_str_appendall(&errMsg, pTab->zName);
      sqlite3_str_append(&errMsg, ".", 1);
      sqlite3_str_appendall(&errMsg, zCol);
    }
  }
  zErr = sqlite3StrAccumFinish(&errMsg);
  sqlite3HaltConstraint(pParse,
    ((pIdx)->idxType==2) ? (19 | (6<<8))
                            : (19 | (8<<8)),
    onError, zErr, (-7), 2);
}





static void sqlite3RowidConstraint(
  Parse *pParse,
  int onError,
  Table *pTab
){
  char *zMsg;
  int rc;
  if( pTab->iPKey>=0 ){
    zMsg = sqlite3MPrintf(pParse->db, "%s.%s", pTab->zName,
                          pTab->aCol[pTab->iPKey].zName);
    rc = (19 | (6<<8));
  }else{
    zMsg = sqlite3MPrintf(pParse->db, "%s.rowid", pTab->zName);
    rc = (19 |(10<<8));
  }
  sqlite3HaltConstraint(pParse, rc, onError, zMsg, (-7),
                        2);
}






static int collationMatch(const char *zColl, Index *pIndex){
  int i;
  ((void)0);
  for(i=0; i<pIndex->nColumn; i++){
    const char *z = pIndex->azColl[i];
    ((void)0);
    if( pIndex->aiColumn[i]>=0 && 0==sqlite3StrICmp(z, zColl) ){
      return 1;
    }
  }
  return 0;
}







static void reindexTable(Parse *pParse, Table *pTab, char const *zColl){
  if( !((pTab)->nModuleArg) ){
    Index *pIndex;

    for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){
      if( zColl==0 || collationMatch(zColl, pIndex) ){
        int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        sqlite3BeginWriteOperation(pParse, 0, iDb);
        sqlite3RefillIndex(pParse, pIndex, -1);
      }
    }
  }
}
# 112278 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void reindexDatabases(Parse *pParse, char const *zColl){
  Db *pDb;
  int iDb;
  sqlite3 *db = pParse->db;
  HashElem *k;
  Table *pTab;

  ((void)0);
  for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){
    ((void)0);
    for(k=((&pDb->pSchema->tblHash)->first); k; k=((k)->next)){
      pTab = (Table*)((k)->data);
      reindexTable(pParse, pTab, zColl);
    }
  }
}
# 112310 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){
  CollSeq *pColl;
  char *z;
  const char *zDb;
  Table *pTab;
  Index *pIndex;
  int iDb;
  sqlite3 *db = pParse->db;
  Token *pObjName;



  if( 0!=sqlite3ReadSchema(pParse) ){
    return;
  }

  if( pName1==0 ){
    reindexDatabases(pParse, 0);
    return;
  }else if( (pName2==0) || pName2->z==0 ){
    char *zColl;
    ((void)0);
    zColl = sqlite3NameFromToken(pParse->db, pName1);
    if( !zColl ) return;
    pColl = sqlite3FindCollSeq(db, ((db)->enc), zColl, 0);
    if( pColl ){
      reindexDatabases(pParse, zColl);
      sqlite3DbFree(db, zColl);
      return;
    }
    sqlite3DbFree(db, zColl);
  }
  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);
  if( iDb<0 ) return;
  z = sqlite3NameFromToken(db, pObjName);
  if( z==0 ) return;
  zDb = db->aDb[iDb].zDbSName;
  pTab = sqlite3FindTable(db, z, zDb);
  if( pTab ){
    reindexTable(pParse, pTab, 0);
    sqlite3DbFree(db, z);
    return;
  }
  pIndex = sqlite3FindIndex(db, z, zDb);
  sqlite3DbFree(db, z);
  if( pIndex ){
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3RefillIndex(pParse, pIndex, -1);
    return;
  }
  sqlite3ErrorMsg(pParse, "unable to identify the object to be reindexed");
}
# 112370 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static KeyInfo *sqlite3KeyInfoOfIndex(Parse *pParse, Index *pIdx){
  int i;
  int nCol = pIdx->nColumn;
  int nKey = pIdx->nKeyCol;
  KeyInfo *pKey;
  if( pParse->nErr ) return 0;
  if( pIdx->uniqNotNull ){
    pKey = sqlite3KeyInfoAlloc(pParse->db, nKey, nCol-nKey);
  }else{
    pKey = sqlite3KeyInfoAlloc(pParse->db, nCol, 0);
  }
  if( pKey ){
    ((void)0);
    for(i=0; i<nCol; i++){
      const char *zColl = pIdx->azColl[i];
      pKey->aColl[i] = zColl==sqlite3StrBINARY ? 0 :
                        sqlite3LocateCollSeq(pParse, zColl);
      pKey->aSortFlags[i] = pIdx->aSortOrder[i];
      ((void)0);
    }
    if( pParse->nErr ){
      ((void)0);
      if( pIdx->bNoQuery==0 ){







        pIdx->bNoQuery = 1;
        pParse->rc = (1 | (2<<8));
      }
      sqlite3KeyInfoUnref(pKey);
      pKey = 0;
    }
  }
  return pKey;
}






static With *sqlite3WithAdd(
  Parse *pParse,
  With *pWith,
  Token *pName,
  ExprList *pArglist,
  Select *pQuery
){
  sqlite3 *db = pParse->db;
  With *pNew;
  char *zName;



  zName = sqlite3NameFromToken(pParse->db, pName);
  if( zName && pWith ){
    int i;
    for(i=0; i<pWith->nCte; i++){
      if( sqlite3StrICmp(zName, pWith->a[i].zName)==0 ){
        sqlite3ErrorMsg(pParse, "duplicate WITH table name: %s", zName);
      }
    }
  }

  if( pWith ){
    sqlite3_int64 nByte = sizeof(*pWith) + (sizeof(pWith->a[1]) * pWith->nCte);
    pNew = sqlite3DbRealloc(db, pWith, nByte);
  }else{
    pNew = sqlite3DbMallocZero(db, sizeof(*pWith));
  }
  ((void)0);

  if( db->mallocFailed ){
    sqlite3ExprListDelete(db, pArglist);
    sqlite3SelectDelete(db, pQuery);
    sqlite3DbFree(db, zName);
    pNew = pWith;
  }else{
    pNew->a[pNew->nCte].pSelect = pQuery;
    pNew->a[pNew->nCte].pCols = pArglist;
    pNew->a[pNew->nCte].zName = zName;
    pNew->a[pNew->nCte].zCteErr = 0;
    pNew->nCte++;
  }

  return pNew;
}




static void sqlite3WithDelete(sqlite3 *db, With *pWith){
  if( pWith ){
    int i;
    for(i=0; i<pWith->nCte; i++){
      struct Cte *pCte = &pWith->a[i];
      sqlite3ExprListDelete(db, pCte->pCols);
      sqlite3SelectDelete(db, pCte->pSelect);
      sqlite3DbFree(db, pCte->zName);
    }
    sqlite3DbFree(db, pWith);
  }
}
# 112503 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void callCollNeeded(sqlite3 *db, int enc, const char *zName){
  ((void)0);
  if( db->xCollNeeded ){
    char *zExternal = sqlite3DbStrDup(db, zName);
    if( !zExternal ) return;
    db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);
    sqlite3DbFree(db, zExternal);
  }

  if( db->xCollNeeded16 ){
    char const *zExternal;
    sqlite3_value *pTmp = sqlite3ValueNew(db);
    sqlite3ValueSetStr(pTmp, -1, zName, 1, ((sqlite3_destructor_type)0));
    zExternal = sqlite3ValueText(pTmp, 2);
    if( zExternal ){
      db->xCollNeeded16(db->pCollNeededArg, db, (int)((db)->enc), zExternal);
    }
    sqlite3ValueFree(pTmp);
  }

}
# 112532 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int synthCollSeq(sqlite3 *db, CollSeq *pColl){
  CollSeq *pColl2;
  char *z = pColl->zName;
  int i;
  static const u8 aEnc[] = { 3, 2, 1 };
  for(i=0; i<3; i++){
    pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);
    if( pColl2->xCmp!=0 ){
      memcpy(pColl, pColl2, sizeof(CollSeq));
      pColl->xDel = 0;
      return 0;
    }
  }
  return 1;
}
# 112562 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *sqlite3GetCollSeq(
  Parse *pParse,
  u8 enc,
  CollSeq *pColl,
  const char *zName
){
  CollSeq *p;
  sqlite3 *db = pParse->db;

  p = pColl;
  if( !p ){
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if( !p || !p->xCmp ){



    callCollNeeded(db, enc, zName);
    p = sqlite3FindCollSeq(db, enc, zName, 0);
  }
  if( p && !p->xCmp && synthCollSeq(db, p) ){
    p = 0;
  }
  ((void)0);
  if( p==0 ){
    sqlite3ErrorMsg(pParse, "no such collation sequence: %s", zName);
    pParse->rc = (1 | (1<<8));
  }
  return p;
}
# 112604 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){
  if( pColl && pColl->xCmp==0 ){
    const char *zName = pColl->zName;
    sqlite3 *db = pParse->db;
    CollSeq *p = sqlite3GetCollSeq(pParse, ((db)->enc), pColl, zName);
    if( !p ){
      return 1;
    }
    ((void)0);
  }
  return 0;
}
# 112632 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *findCollSeqEntry(
  sqlite3 *db,
  const char *zName,
  int create
){
  CollSeq *pColl;
  pColl = sqlite3HashFind(&db->aCollSeq, zName);

  if( 0==pColl && create ){
    int nName = sqlite3Strlen30(zName) + 1;
    pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName);
    if( pColl ){
      CollSeq *pDel = 0;
      pColl[0].zName = (char*)&pColl[3];
      pColl[0].enc = 1;
      pColl[1].zName = (char*)&pColl[3];
      pColl[1].enc = 2;
      pColl[2].zName = (char*)&pColl[3];
      pColl[2].enc = 3;
      memcpy(pColl[0].zName, zName, nName);
      pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, pColl);





      ((void)0);
      if( pDel!=0 ){
        sqlite3OomFault(db);
        sqlite3DbFree(db, pDel);
        pColl = 0;
      }
    }
  }
  return pColl;
}
# 112684 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *sqlite3FindCollSeq(
  sqlite3 *db,
  u8 enc,
  const char *zName,
  int create
){
  CollSeq *pColl;
  if( zName ){
    pColl = findCollSeqEntry(db, zName, create);
  }else{
    pColl = db->pDfltColl;
  }
  ((void)0);
  ((void)0);
  if( pColl ) pColl += enc-1;
  return pColl;
}
# 112730 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define FUNC_PERFECT_MATCH 6
static int matchQuality(
  FuncDef *p,
  int nArg,
  u8 enc
){
  int match;


  if( nArg==(-2) ) return (p->xSFunc==0) ? 0 : 6;


  if( p->nArg!=nArg && p->nArg>=0 ) return 0;



  if( p->nArg==nArg ){
    match = 4;
  }else{
    match = 1;
  }


  if( enc==(p->funcFlags & 0x0003) ){
    match += 2;
  }else if( (enc & p->funcFlags & 2)!=0 ){
    match += 1;
  }

  return match;
}





static FuncDef *sqlite3FunctionSearch(
  int h,
  const char *zFunc
){
  FuncDef *p;
  for(p=sqlite3BuiltinFunctions.a[h]; p; p=p->u.pHash){
    if( sqlite3StrICmp(p->zName, zFunc)==0 ){
      return p;
    }
  }
  return 0;
}




static void sqlite3InsertBuiltinFuncs(
  FuncDef *aDef,
  int nDef
){
  int i;
  for(i=0; i<nDef; i++){
    FuncDef *pOther;
    const char *zName = aDef[i].zName;
    int nName = sqlite3Strlen30(zName);
    int h = (((zName[0])+(nName))%23);
    ((void)0);
    pOther = sqlite3FunctionSearch(h, zName);
    if( pOther ){
      ((void)0);
      aDef[i].pNext = pOther->pNext;
      pOther->pNext = &aDef[i];
    }else{
      aDef[i].pNext = 0;
      aDef[i].u.pHash = sqlite3BuiltinFunctions.a[h];
      sqlite3BuiltinFunctions.a[h] = &aDef[i];
    }
  }
}
# 112827 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static FuncDef *sqlite3FindFunction(
  sqlite3 *db,
  const char *zName,
  int nArg,
  u8 enc,
  u8 createFlag
){
  FuncDef *p;
  FuncDef *pBest = 0;
  int bestScore = 0;
  int h;
  int nName;

  ((void)0);
  ((void)0);
  nName = sqlite3Strlen30(zName);



  p = (FuncDef*)sqlite3HashFind(&db->aFunc, zName);
  while( p ){
    int score = matchQuality(p, nArg, enc);
    if( score>bestScore ){
      pBest = p;
      bestScore = score;
    }
    p = p->pNext;
  }
# 112868 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( !createFlag && (pBest==0 || (db->mDbFlags & 0x0002)!=0) ){
    bestScore = 0;
    h = (((sqlite3UpperToLower[(u8)zName[0]])+(nName))%23);
    p = sqlite3FunctionSearch(h, zName);
    while( p ){
      int score = matchQuality(p, nArg, enc);
      if( score>bestScore ){
        pBest = p;
        bestScore = score;
      }
      p = p->pNext;
    }
  }





  if( createFlag && bestScore<6 &&
      (pBest = sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){
    FuncDef *pOther;
    u8 *z;
    pBest->zName = (const char*)&pBest[1];
    pBest->nArg = (u16)nArg;
    pBest->funcFlags = enc;
    memcpy((char*)&pBest[1], zName, nName+1);
    for(z=(u8*)pBest->zName; *z; z++) *z = sqlite3UpperToLower[*z];
    pOther = (FuncDef*)sqlite3HashInsert(&db->aFunc, pBest->zName, pBest);
    if( pOther==pBest ){
      sqlite3DbFree(db, pBest);
      sqlite3OomFault(db);
      return 0;
    }else{
      pBest->pNext = pOther;
    }
  }

  if( pBest && (pBest->xSFunc || createFlag) ){
    return pBest;
  }
  return 0;
}
# 112919 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SchemaClear(void *p){
  Hash temp1;
  Hash temp2;
  HashElem *pElem;
  Schema *pSchema = (Schema *)p;

  temp1 = pSchema->tblHash;
  temp2 = pSchema->trigHash;
  sqlite3HashInit(&pSchema->trigHash);
  sqlite3HashClear(&pSchema->idxHash);
  for(pElem=((&temp2)->first); pElem; pElem=((pElem)->next)){
    sqlite3DeleteTrigger(0, (Trigger*)((pElem)->data));
  }
  sqlite3HashClear(&temp2);
  sqlite3HashInit(&pSchema->tblHash);
  for(pElem=((&temp1)->first); pElem; pElem=((pElem)->next)){
    Table *pTab = ((pElem)->data);
    sqlite3DeleteTable(0, pTab);
  }
  sqlite3HashClear(&temp1);
  sqlite3HashClear(&pSchema->fkeyHash);
  pSchema->pSeqTab = 0;
  if( pSchema->schemaFlags & 0x0001 ){
    pSchema->iGeneration++;
  }
  pSchema->schemaFlags &= ~(0x0001|0x0008);
}





static Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){
  Schema * p;
  if( pBt ){
    p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaClear);
  }else{
    p = (Schema *)sqlite3DbMallocZero(0, sizeof(Schema));
  }
  if( !p ){
    sqlite3OomFault(db);
  }else if ( 0==p->file_format ){
    sqlite3HashInit(&p->tblHash);
    sqlite3HashInit(&p->idxHash);
    sqlite3HashInit(&p->trigHash);
    sqlite3HashInit(&p->fkeyHash);
    p->enc = 1;
  }
  return p;
}
# 113002 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){
  struct SrcList_item *pItem = pSrc->a;
  Table *pTab;
  ((void)0);
  pTab = sqlite3LocateTableItem(pParse, 0, pItem);
  sqlite3DeleteTable(pParse->db, pItem->pTab);
  pItem->pTab = pTab;
  if( pTab ){
    pTab->nTabRef++;
  }
  if( sqlite3IndexedByLookup(pParse, pItem) ){
    pTab = 0;
  }
  return pTab;
}
# 113033 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int tabIsReadOnly(Parse *pParse, Table *pTab){
  sqlite3 *db;
  if( ((pTab)->nModuleArg) ){
    return sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0;
  }
  if( (pTab->tabFlags & (0x0001|0x0400))==0 ) return 0;
  db = pParse->db;
  if( (pTab->tabFlags & 0x0001)!=0 ){
    return sqlite3WritableSchema(db)==0 && pParse->nested==0;
  }
  ((void)0);
  return (db->flags & 0x10000000)!=0

          && db->pVtabCtx==0

          && db->nVdbeExec==0;
}






static int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){
  if( tabIsReadOnly(pParse, pTab) ){
    sqlite3ErrorMsg(pParse, "table %s may not be modified", pTab->zName);
    return 1;
  }

  if( !viewOk && pTab->pSelect ){
    sqlite3ErrorMsg(pParse,"cannot modify %s because it is a view",pTab->zName);
    return 1;
  }

  return 0;
}
# 113077 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3MaterializeView(
  Parse *pParse,
  Table *pView,
  Expr *pWhere,
  ExprList *pOrderBy,
  Expr *pLimit,
  int iCur
){
  SelectDest dest;
  Select *pSel;
  SrcList *pFrom;
  sqlite3 *db = pParse->db;
  int iDb = sqlite3SchemaToIndex(db, pView->pSchema);
  pWhere = sqlite3ExprDup(db, pWhere, 0);
  pFrom = sqlite3SrcListAppend(pParse, 0, 0, 0);
  if( pFrom ){
    ((void)0);
    pFrom->a[0].zName = sqlite3DbStrDup(db, pView->zName);
    pFrom->a[0].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zDbSName);
    ((void)0);
    ((void)0);
  }
  pSel = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, pOrderBy,
                          0x20000, pLimit);
  sqlite3SelectDestInit(&dest, 12, iCur);
  sqlite3Select(pParse, pSel, &dest);
  sqlite3SelectDelete(db, pSel);
}
# 113209 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3DeleteFrom(
  Parse *pParse,
  SrcList *pTabList,
  Expr *pWhere,
  ExprList *pOrderBy,
  Expr *pLimit
){
  Vdbe *v;
  Table *pTab;
  int i;
  WhereInfo *pWInfo;
  Index *pIdx;
  int iTabCur;
  int iDataCur = 0;
  int iIdxCur = 0;
  int nIdx;
  sqlite3 *db;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int memCnt = 0;
  int rcauth;
  int eOnePass;
  int aiCurOnePass[2];
  u8 *aToOpen = 0;
  Index *pPk;
  int iPk = 0;
  i16 nPk = 1;
  int iKey;
  i16 nKey;
  int iEphCur = 0;
  int iRowSet = 0;
  int addrBypass = 0;
  int addrLoop = 0;
  int addrEphOpen = 0;
  int bComplex;



  int isView;
  Trigger *pTrigger;


  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  if( pParse->nErr || db->mallocFailed ){
    goto delete_from_cleanup;
  }
  ((void)0);







  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ) goto delete_from_cleanup;





  pTrigger = sqlite3TriggersExist(pParse, pTab, 124, 0, 0);
  isView = pTab->pSelect!=0;




  bComplex = pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0);
# 113296 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto delete_from_cleanup;
  }

  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){
    goto delete_from_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void)0);
  rcauth = sqlite3AuthCheck(pParse, 9, pTab->zName, 0,
                            db->aDb[iDb].zDbSName);
  ((void)0);
  if( rcauth==1 ){
    goto delete_from_cleanup;
  }
  ((void)0);



  ((void)0);
  iTabCur = pTabList->a[0].iCursor = pParse->nTab++;
  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){
    pParse->nTab++;
  }



  if( isView ){
    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }



  v = sqlite3GetVdbe(pParse);
  if( v==0 ){
    goto delete_from_cleanup;
  }
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, bComplex, iDb);





  if( isView ){
    sqlite3MaterializeView(pParse, pTab,
        pWhere, pOrderBy, pLimit, iTabCur
    );
    iDataCur = iIdxCur = iTabCur;
    pOrderBy = 0;
    pLimit = 0;
  }




  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  if( sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto delete_from_cleanup;
  }




  if( (db->flags & 0x00000080)!=0
   && !pParse->nested
   && !pParse->pTriggerTab
  ){
    memCnt = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 70, 0, memCnt);
  }
# 113382 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rcauth==0
   && pWhere==0
   && !bComplex
   && !((pTab)->nModuleArg)



  ){
    ((void)0);
    sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);
    if( (((pTab)->tabFlags & 0x0020)==0) ){
      sqlite3VdbeAddOp4(v, 137, pTab->tnum, iDb, memCnt ? memCnt : -1,
                        pTab->zName, (-1));
    }
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      ((void)0);
      sqlite3VdbeAddOp2(v, 137, pIdx->tnum, iDb);
    }
  }else

  {
    u16 wcf = 0x0004|0x0010|0x0400;
    if( sNC.ncFlags & 0x0040 ) bComplex = 1;
    wcf |= (bComplex ? 0 : 0x0008);
    if( (((pTab)->tabFlags & 0x0020)==0) ){

      pPk = 0;
      nPk = 1;
      iRowSet = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 73, 0, iRowSet);
    }else{


      pPk = sqlite3PrimaryKeyIndex(pTab);
      ((void)0);
      nPk = pPk->nKeyCol;
      iPk = pParse->nMem+1;
      pParse->nMem += nPk;
      iEphCur = pParse->nTab++;
      addrEphOpen = sqlite3VdbeAddOp2(v, 112, iEphCur, nPk);
      sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    }
# 113433 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, wcf, iTabCur+1);
    if( pWInfo==0 ) goto delete_from_cleanup;
    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
    ((void)0);
    ((void)0);
    if( eOnePass!=1 ) sqlite3MultiWrite(pParse);


    if( memCnt ){
      sqlite3VdbeAddOp2(v, 83, memCnt, 1);
    }


    if( pPk ){
      for(i=0; i<nPk; i++){
        ((void)0);
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur,
                                        pPk->aiColumn[i], iPk+i);
      }
      iKey = iPk;
    }else{
      iKey = ++pParse->nMem;
      sqlite3ExprCodeGetColumnOfTable(v, pTab, iTabCur, -1, iKey);
    }

    if( eOnePass!=0 ){



      nKey = nPk;
      aToOpen = sqlite3DbMallocRawNN(db, nIdx+2);
      if( aToOpen==0 ){
        sqlite3WhereEnd(pWInfo);
        goto delete_from_cleanup;
      }
      memset(aToOpen, 1, nIdx+1);
      aToOpen[nIdx+1] = 0;
      if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iTabCur] = 0;
      if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iTabCur] = 0;
      if( addrEphOpen ) sqlite3VdbeChangeToNoop(v, addrEphOpen);
    }else{
      if( pPk ){

        iKey = ++pParse->nMem;
        nKey = 0;
        sqlite3VdbeAddOp4(v, 92, iPk, nPk, iKey,
            sqlite3IndexAffinityStr(pParse->db, pPk), nPk);
        sqlite3VdbeAddOp4Int(v, 132, iEphCur, iKey, iPk, nPk);
      }else{

        nKey = 1;
        sqlite3VdbeAddOp2(v, 147, iRowSet, iKey);
      }
    }



    if( eOnePass!=0 ){
      addrBypass = sqlite3VdbeMakeLabel(pParse);
    }else{
      sqlite3WhereEnd(pWInfo);
    }






    if( !isView ){
      int iAddrOnce = 0;
      if( eOnePass==2 ){
        iAddrOnce = sqlite3VdbeAddOp0(v, 17); ;
      }
      ;
      sqlite3OpenTableAndIndices(pParse, pTab, 98, 0x08,
                                 iTabCur, aToOpen, &iDataCur, &iIdxCur);
      ((void)0);
      ((void)0);
      if( eOnePass==2 ) sqlite3VdbeJumpHere(v, iAddrOnce);
    }




    if( eOnePass!=0 ){
      ((void)0);
      if( !((pTab)->nModuleArg) && aToOpen[iDataCur-iTabCur] ){
        ((void)0);
        sqlite3VdbeAddOp4Int(v, 28, iDataCur, addrBypass, iKey, nKey);
        ;
      }
    }else if( pPk ){
      addrLoop = sqlite3VdbeAddOp1(v, 36, iEphCur); ;
      if( ((pTab)->nModuleArg) ){
        sqlite3VdbeAddOp3(v, 90, iEphCur, 0, iKey);
      }else{
        sqlite3VdbeAddOp2(v, 127, iEphCur, iKey);
      }
      ((void)0);
    }else{
      addrLoop = sqlite3VdbeAddOp3(v, 41, iRowSet, 0, iKey);
      ;
      ((void)0);
    }



    if( ((pTab)->nModuleArg) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      sqlite3VtabMakeWritable(pParse, pTab);
      ((void)0);
      sqlite3MayAbort(pParse);
      if( eOnePass==1 ){
        sqlite3VdbeAddOp1(v, 117, iTabCur);
        if( ((pParse)->pToplevel==0) ){
          pParse->isMultiWrite = 0;
        }
      }
      sqlite3VdbeAddOp4(v, 10, 0, 1, iKey, pVTab, (-12));
      sqlite3VdbeChangeP5(v, 2);
    }else

    {
      int count = (pParse->nested==0);
      sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
          iKey, nKey, count, 11, eOnePass, aiCurOnePass[1]);
    }


    if( eOnePass!=0 ){
      sqlite3VdbeResolveLabel(v, addrBypass);
      sqlite3WhereEnd(pWInfo);
    }else if( pPk ){
      sqlite3VdbeAddOp2(v, 5, iEphCur, addrLoop+1); ;
      sqlite3VdbeJumpHere(v, addrLoop);
    }else{
      sqlite3VdbeGoto(v, addrLoop);
      sqlite3VdbeJumpHere(v, addrLoop);
    }
  }





  if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    sqlite3AutoincrementEnd(pParse);
  }





  if( memCnt ){
    sqlite3VdbeAddOp2(v, 81, memCnt, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows deleted", ((sqlite3_destructor_type)0));
  }

delete_from_cleanup:
  sqlite3AuthContextPop(&sContext);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprDelete(db, pWhere);




  sqlite3DbFree(db, aToOpen);
  return;
}
# 113654 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3GenerateRowDelete(
  Parse *pParse,
  Table *pTab,
  Trigger *pTrigger,
  int iDataCur,
  int iIdxCur,
  int iPk,
  i16 nPk,
  u8 count,
  u8 onconf,
  u8 eMode,
  int iIdxNoSeek
){
  Vdbe *v = pParse->pVdbe;
  int iOld = 0;
  int iLabel;
  u8 opSeek;


  ((void)0);
 
                                                           ;




  iLabel = sqlite3VdbeMakeLabel(pParse);
  opSeek = (((pTab)->tabFlags & 0x0020)==0) ? 31 : 28;
  if( eMode==0 ){
    sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
    ;
    ;
  }



  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){
    u32 mask;
    int iCol;
    int addrStart;



    mask = sqlite3TriggerColmask(
        pParse, pTrigger, 0, 0, 1|2, pTab, onconf
    );
    mask |= sqlite3FkOldmask(pParse, pTab);
    iOld = pParse->nMem+1;
    pParse->nMem += (1 + pTab->nCol);



    sqlite3VdbeAddOp2(v, 78, iPk, iOld);
    for(iCol=0; iCol<pTab->nCol; iCol++){
      ;
      ;
      if( mask==0xffffffff || (iCol<=31 && (mask & (((unsigned int)1)<<(iCol)))!=0) ){
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, iCol, iOld+iCol+1);
      }
    }


    addrStart = sqlite3VdbeCurrentAddr(v);
    sqlite3CodeRowTrigger(pParse, pTrigger,
        124, 0, 1, pTab, iOld, onconf, iLabel
    );
# 113729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( addrStart<sqlite3VdbeCurrentAddr(v) ){
      sqlite3VdbeAddOp4Int(v, opSeek, iDataCur, iLabel, iPk, nPk);
      ;
      ;
      ;
      iIdxNoSeek = -1;
    }




    sqlite3FkCheck(pParse, pTab, iOld, 0, 0, 0);
  }
# 113753 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pTab->pSelect==0 ){
    u8 p5 = 0;
    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,iIdxNoSeek);
    sqlite3VdbeAddOp2(v, 123, iDataCur, (count?0x01:0));
    if( pParse->nested==0 || 0==sqlite3_stricmp(pTab->zName, "sqlite_stat1") ){
      sqlite3VdbeAppendP4(v, (char*)pTab, (-6));
    }
    if( eMode!=0 ){
      sqlite3VdbeChangeP5(v, 0x04);
    }
    if( iIdxNoSeek>=0 && iIdxNoSeek!=iDataCur ){
      sqlite3VdbeAddOp1(v, 123, iIdxNoSeek);
    }
    if( eMode==2 ) p5 |= 0x02;
    sqlite3VdbeChangeP5(v, p5);
  }




  sqlite3FkActions(pParse, pTab, 0, iOld, 0, 0);


  sqlite3CodeRowTrigger(pParse, pTrigger,
      124, 0, 2, pTab, iOld, onconf, iLabel
  );




  sqlite3VdbeResolveLabel(v, iLabel);
  ;
}
# 113805 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3GenerateRowIndexDelete(
  Parse *pParse,
  Table *pTab,
  int iDataCur,
  int iIdxCur,
  int *aRegIdx,
  int iIdxNoSeek
){
  int i;
  int r1 = -1;
  int iPartIdxLabel;
  Index *pIdx;
  Index *pPrior = 0;
  Vdbe *v;
  Index *pPk;

  v = pParse->pVdbe;
  pPk = (((pTab)->tabFlags & 0x0020)==0) ? 0 : sqlite3PrimaryKeyIndex(pTab);
  for(i=0, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){
    ((void)0);
    if( aRegIdx!=0 && aRegIdx[i]==0 ) continue;
    if( pIdx==pPk ) continue;
    if( iIdxCur+i==iIdxNoSeek ) continue;
    ;
    r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 1,
        &iPartIdxLabel, pPrior, r1);
    sqlite3VdbeAddOp3(v, 133, iIdxCur+i, r1,
        pIdx->uniqNotNull ? pIdx->nKeyCol : pIdx->nColumn);
    sqlite3ResolvePartIdxLabel(pParse, iPartIdxLabel);
    pPrior = pIdx;
  }
}
# 113869 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3GenerateIndexKey(
  Parse *pParse,
  Index *pIdx,
  int iDataCur,
  int regOut,
  int prefixOnly,
  int *piPartIdxLabel,
  Index *pPrior,
  int regPrior
){
  Vdbe *v = pParse->pVdbe;
  int j;
  int regBase;
  int nCol;

  if( piPartIdxLabel ){
    if( pIdx->pPartIdxWhere ){
      *piPartIdxLabel = sqlite3VdbeMakeLabel(pParse);
      pParse->iSelfTab = iDataCur + 1;
      sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, *piPartIdxLabel,
                            0x10);
      pParse->iSelfTab = 0;
    }else{
      *piPartIdxLabel = 0;
    }
  }
  nCol = (prefixOnly && pIdx->uniqNotNull) ? pIdx->nKeyCol : pIdx->nColumn;
  regBase = sqlite3GetTempRange(pParse, nCol);
  if( pPrior && (regBase!=regPrior || pPrior->pPartIdxWhere) ) pPrior = 0;
  for(j=0; j<nCol; j++){
    if( pPrior
     && pPrior->aiColumn[j]==pIdx->aiColumn[j]
     && pPrior->aiColumn[j]!=(-2)
    ){

      continue;
    }
    sqlite3ExprCodeLoadIndexColumn(pParse, pIdx, iDataCur, j, regBase+j);






    sqlite3VdbeDeletePriorOpcode(v, 84);
  }
  if( regOut ){
    sqlite3VdbeAddOp3(v, 92, regBase, nCol, regOut);
    if( pIdx->pTable->pSelect ){
      const char *zAff = sqlite3IndexAffinityStr(pParse->db, pIdx);
      sqlite3VdbeChangeP4(v, -1, zAff, 0);
    }
  }
  sqlite3ReleaseTempRange(pParse, regBase, nCol);
  return regBase;
}






static void sqlite3ResolvePartIdxLabel(Parse *pParse, int iLabel){
  if( iLabel ){
    sqlite3VdbeResolveLabel(pParse->pVdbe, iLabel);
  }
}
# 113963 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){
  VdbeOp *pOp;
  ((void)0);
  pOp = &context->pVdbe->aOp[context->iOp-1];
  ((void)0);
  ((void)0);
  return pOp->p4.pColl;
}





static void sqlite3SkipAccumulatorLoad(sqlite3_context *context){
  ((void)0);
  context->isError = -1;
  context->skipFlag = 1;
}




static void minmaxFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i;
  int mask;
  int iBest;
  CollSeq *pColl;

  ((void)0);
  mask = sqlite3_user_data(context)==0 ? 0 : -1;
  pColl = sqlite3GetFuncCollSeq(context);
  ((void)0);
  ((void)0);
  iBest = 0;
  if( sqlite3_value_type(argv[0])==5 ) return;
  for(i=1; i<argc; i++){
    if( sqlite3_value_type(argv[i])==5 ) return;
    if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){
      ;
      iBest = i;
    }
  }
  sqlite3_result_value(context, argv[iBest]);
}




static void typeofFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  static const char *azType[] = { "integer", "real", "text", "blob", "null" };
  int i = sqlite3_value_type(argv[0]) - 1;
  (void)(NotUsed);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);




  sqlite3_result_text(context, azType[i], -1, ((sqlite3_destructor_type)0));
}





static void lengthFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  ((void)0);
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 4:
    case 1:
    case 2: {
      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));
      break;
    }
    case 3: {
      const unsigned char *z = sqlite3_value_text(argv[0]);
      const unsigned char *z0;
      unsigned char c;
      if( z==0 ) return;
      z0 = z;
      while( (c = *z)!=0 ){
        z++;
        if( c>=0xc0 ){
          while( (*z & 0xc0)==0x80 ){ z++; z0++; }
        }
      }
      sqlite3_result_int(context, (int)(z-z0));
      break;
    }
    default: {
      sqlite3_result_null(context);
      break;
    }
  }
}







static void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  ((void)0);
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 1: {
      i64 iVal = sqlite3_value_int64(argv[0]);
      if( iVal<0 ){
        if( iVal==(((i64)-1) - (0xffffffff|(((i64)0x7fffffff)<<32))) ){



          sqlite3_result_error(context, "integer overflow", -1);
          return;
        }
        iVal = -iVal;
      }
      sqlite3_result_int64(context, iVal);
      break;
    }
    case 5: {

      sqlite3_result_null(context);
      break;
    }
    default: {





      double rVal = sqlite3_value_double(argv[0]);
      if( rVal<0 ) rVal = -rVal;
      sqlite3_result_double(context, rVal);
      break;
    }
  }
}
# 114131 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void instrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zHaystack;
  const unsigned char *zNeedle;
  int nHaystack;
  int nNeedle;
  int typeHaystack, typeNeedle;
  int N = 1;
  int isText;
  unsigned char firstChar;
  sqlite3_value *pC1 = 0;
  sqlite3_value *pC2 = 0;

  (void)(argc);
  typeHaystack = sqlite3_value_type(argv[0]);
  typeNeedle = sqlite3_value_type(argv[1]);
  if( typeHaystack==5 || typeNeedle==5 ) return;
  nHaystack = sqlite3_value_bytes(argv[0]);
  nNeedle = sqlite3_value_bytes(argv[1]);
  if( nNeedle>0 ){
    if( typeHaystack==4 && typeNeedle==4 ){
      zHaystack = sqlite3_value_blob(argv[0]);
      zNeedle = sqlite3_value_blob(argv[1]);
      isText = 0;
    }else if( typeHaystack!=4 && typeNeedle!=4 ){
      zHaystack = sqlite3_value_text(argv[0]);
      zNeedle = sqlite3_value_text(argv[1]);
      isText = 1;
    }else{
      pC1 = sqlite3_value_dup(argv[0]);
      zHaystack = sqlite3_value_text(pC1);
      if( zHaystack==0 ) goto endInstrOOM;
      nHaystack = sqlite3_value_bytes(pC1);
      pC2 = sqlite3_value_dup(argv[1]);
      zNeedle = sqlite3_value_text(pC2);
      if( zNeedle==0 ) goto endInstrOOM;
      nNeedle = sqlite3_value_bytes(pC2);
      isText = 1;
    }
    if( zNeedle==0 || (nHaystack && zHaystack==0) ) goto endInstrOOM;
    firstChar = zNeedle[0];
    while( nNeedle<=nHaystack
       && (zHaystack[0]!=firstChar || memcmp(zHaystack, zNeedle, nNeedle)!=0)
    ){
      N++;
      do{
        nHaystack--;
        zHaystack++;
      }while( isText && (zHaystack[0]&0xc0)==0x80 );
    }
    if( nNeedle>nHaystack ) N = 0;
  }
  sqlite3_result_int(context, N);
endInstr:
  sqlite3_value_free(pC1);
  sqlite3_value_free(pC2);
  return;
endInstrOOM:
  sqlite3_result_error_nomem(context);
  goto endInstr;
}




static void printfFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  PrintfArguments x;
  StrAccum str;
  const char *zFormat;
  int n;
  sqlite3 *db = sqlite3_context_db_handle(context);

  if( argc>=1 && (zFormat = (const char*)sqlite3_value_text(argv[0]))!=0 ){
    x.nArg = argc-1;
    x.nUsed = 0;
    x.apArg = argv+1;
    sqlite3StrAccumInit(&str, db, 0, 0, db->aLimit[0]);
    str.printfFlags = 0x02;
    sqlite3_str_appendf(&str, zFormat, &x);
    n = str.nChar;
    sqlite3_result_text(context, sqlite3StrAccumFinish(&str), n,
                        ((sqlite3_destructor_type)sqlite3MallocSize));
  }
}
# 114235 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void substrFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *z;
  const unsigned char *z2;
  int len;
  int p0type;
  i64 p1, p2;
  int negP2 = 0;

  ((void)0);
  if( sqlite3_value_type(argv[1])==5
   || (argc==3 && sqlite3_value_type(argv[2])==5)
  ){
    return;
  }
  p0type = sqlite3_value_type(argv[0]);
  p1 = sqlite3_value_int(argv[1]);
  if( p0type==4 ){
    len = sqlite3_value_bytes(argv[0]);
    z = sqlite3_value_blob(argv[0]);
    if( z==0 ) return;
    ((void)0);
  }else{
    z = sqlite3_value_text(argv[0]);
    if( z==0 ) return;
    len = 0;
    if( p1<0 ){
      for(z2=z; *z2; len++){
        { if( (*(z2++))>=0xc0 ){ while( (*z2 & 0xc0)==0x80 ){ z2++; } } };
      }
    }
  }
# 114278 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( argc==3 ){
    p2 = sqlite3_value_int(argv[2]);
    if( p2<0 ){
      p2 = -p2;
      negP2 = 1;
    }
  }else{
    p2 = sqlite3_context_db_handle(context)->aLimit[0];
  }
  if( p1<0 ){
    p1 += len;
    if( p1<0 ){
      p2 += p1;
      if( p2<0 ) p2 = 0;
      p1 = 0;
    }
  }else if( p1>0 ){
    p1--;
  }else if( p2>0 ){
    p2--;
  }
  if( negP2 ){
    p1 -= p2;
    if( p1<0 ){
      p2 += p1;
      p1 = 0;
    }
  }
  ((void)0);
  if( p0type!=4 ){
    while( *z && p1 ){
      { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
      p1--;
    }
    for(z2=z; *z2 && p2; p2--){
      { if( (*(z2++))>=0xc0 ){ while( (*z2 & 0xc0)==0x80 ){ z2++; } } };
    }
    sqlite3_result_text64(context, (char*)z, z2-z, ((sqlite3_destructor_type)-1),
                          1);
  }else{
    if( p1+p2>len ){
      p2 = len-p1;
      if( p2<0 ) p2 = 0;
    }
    sqlite3_result_blob64(context, (char*)&z[p1], (u64)p2, ((sqlite3_destructor_type)-1));
  }
}





static void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  int n = 0;
  double r;
  char *zBuf;
  ((void)0);
  if( argc==2 ){
    if( 5==sqlite3_value_type(argv[1]) ) return;
    n = sqlite3_value_int(argv[1]);
    if( n>30 ) n = 30;
    if( n<0 ) n = 0;
  }
  if( sqlite3_value_type(argv[0])==5 ) return;
  r = sqlite3_value_double(argv[0]);




  if( r<-4503599627370496.0 || r>+4503599627370496.0 ){

  }else if( n==0 ){
    r = (double)((sqlite_int64)(r+(r<0?-0.5:+0.5)));
  }else{
    zBuf = sqlite3_mprintf("%.*f",n,r);
    if( zBuf==0 ){
      sqlite3_result_error_nomem(context);
      return;
    }
    sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), 1);
    sqlite3_free(zBuf);
  }
  sqlite3_result_double(context, r);
}
# 114371 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void *contextMalloc(sqlite3_context *context, i64 nByte){
  char *z;
  sqlite3 *db = sqlite3_context_db_handle(context);
  ((void)0);
  ;
  ;
  if( nByte>db->aLimit[0] ){
    sqlite3_result_error_toobig(context);
    z = 0;
  }else{
    z = sqlite3Malloc(nByte);
    if( !z ){
      sqlite3_result_error_nomem(context);
    }
  }
  return z;
}




static void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  char *z1;
  const char *z2;
  int i, n;
  (void)(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);

  ((void)0);
  if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    if( z1 ){
      for(i=0; i<n; i++){
        z1[i] = (char)((z2[i])&~(sqlite3CtypeMap[(unsigned char)(z2[i])]&0x20));
      }
      sqlite3_result_text(context, z1, n, sqlite3_free);
    }
  }
}
static void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  char *z1;
  const char *z2;
  int i, n;
  (void)(argc);
  z2 = (char*)sqlite3_value_text(argv[0]);
  n = sqlite3_value_bytes(argv[0]);

  ((void)0);
  if( z2 ){
    z1 = contextMalloc(context, ((i64)n)+1);
    if( z1 ){
      for(i=0; i<n; i++){
        z1[i] = (sqlite3UpperToLower[(unsigned char)(z2[i])]);
      }
      sqlite3_result_text(context, z1, n, sqlite3_free);
    }
  }
}
# 114439 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define noopFunc versionFunc




static void randomFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite_int64 r;
  (void)(NotUsed),(void)(NotUsed2);
  sqlite3_randomness(sizeof(r), &r);
  if( r<0 ){
# 114461 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    r = -(r & (0xffffffff|(((i64)0x7fffffff)<<32)));
  }
  sqlite3_result_int64(context, r);
}





static void randomBlob(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  sqlite3_int64 n;
  unsigned char *p;
  ((void)0);
  (void)(argc);
  n = sqlite3_value_int64(argv[0]);
  if( n<1 ){
    n = 1;
  }
  p = contextMalloc(context, n);
  if( p ){
    sqlite3_randomness(n, p);
    sqlite3_result_blob(context, (char*)p, n, sqlite3_free);
  }
}





static void last_insert_rowid(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);



  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));
}
# 114514 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);
  sqlite3_result_int(context, sqlite3_changes(db));
}





static void total_changes(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  sqlite3 *db = sqlite3_context_db_handle(context);
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_int(context, sqlite3_total_changes(db));
}




struct compareInfo {
  u8 matchAll;
  u8 matchOne;
  u8 matchSet;
  u8 noCase;
};
# 114560 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define Utf8Read(A) (A[0]<0x80?*(A++):sqlite3Utf8Read(&A))


static const struct compareInfo globInfo = { '*', '?', '[', 0 };


static const struct compareInfo likeInfoNorm = { '%', '_', 0, 1 };


static const struct compareInfo likeInfoAlt = { '%', '_', 0, 0 };




#define SQLITE_MATCH 0
#define SQLITE_NOMATCH 1
#define SQLITE_NOWILDCARDMATCH 2
# 114616 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int patternCompare(
  const u8 *zPattern,
  const u8 *zString,
  const struct compareInfo *pInfo,
  u32 matchOther
){
  u32 c, c2;
  u32 matchOne = pInfo->matchOne;
  u32 matchAll = pInfo->matchAll;
  u8 noCase = pInfo->noCase;
  const u8 *zEscaped = 0;

  while( (c = (zPattern[0]<0x80?*(zPattern++):sqlite3Utf8Read(&zPattern)))!=0 ){
    if( c==matchAll ){



      while( (c=(zPattern[0]<0x80?*(zPattern++):sqlite3Utf8Read(&zPattern))) == matchAll || c == matchOne ){
        if( c==matchOne && sqlite3Utf8Read(&zString)==0 ){
          return 2;
        }
      }
      if( c==0 ){
        return 0;
      }else if( c==matchOther ){
        if( pInfo->matchSet==0 ){
          c = sqlite3Utf8Read(&zPattern);
          if( c==0 ) return 2;
        }else{


          ((void)0);
          while( *zString ){
            int bMatch = patternCompare(&zPattern[-1],zString,pInfo,matchOther);
            if( bMatch!=1 ) return bMatch;
            { if( (*(zString++))>=0xc0 ){ while( (*zString & 0xc0)==0x80 ){ zString++; } } };
          }
          return 2;
        }
      }
# 114666 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( c<=0x80 ){
        char zStop[3];
        int bMatch;
        if( noCase ){
          zStop[0] = ((c)&~(sqlite3CtypeMap[(unsigned char)(c)]&0x20));
          zStop[1] = (sqlite3UpperToLower[(unsigned char)(c)]);
          zStop[2] = 0;
        }else{
          zStop[0] = c;
          zStop[1] = 0;
        }
        while(1){
          zString += strcspn((const char*)zString, zStop);
          if( zString[0]==0 ) break;
          zString++;
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          if( bMatch!=1 ) return bMatch;
        }
      }else{
        int bMatch;
        while( (c2 = (zString[0]<0x80?*(zString++):sqlite3Utf8Read(&zString)))!=0 ){
          if( c2!=c ) continue;
          bMatch = patternCompare(zPattern,zString,pInfo,matchOther);
          if( bMatch!=1 ) return bMatch;
        }
      }
      return 2;
    }
    if( c==matchOther ){
      if( pInfo->matchSet==0 ){
        c = sqlite3Utf8Read(&zPattern);
        if( c==0 ) return 1;
        zEscaped = zPattern;
      }else{
        u32 prior_c = 0;
        int seen = 0;
        int invert = 0;
        c = sqlite3Utf8Read(&zString);
        if( c==0 ) return 1;
        c2 = sqlite3Utf8Read(&zPattern);
        if( c2=='^' ){
          invert = 1;
          c2 = sqlite3Utf8Read(&zPattern);
        }
        if( c2==']' ){
          if( c==']' ) seen = 1;
          c2 = sqlite3Utf8Read(&zPattern);
        }
        while( c2 && c2!=']' ){
          if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){
            c2 = sqlite3Utf8Read(&zPattern);
            if( c>=prior_c && c<=c2 ) seen = 1;
            prior_c = 0;
          }else{
            if( c==c2 ){
              seen = 1;
            }
            prior_c = c2;
          }
          c2 = sqlite3Utf8Read(&zPattern);
        }
        if( c2==0 || (seen ^ invert)==0 ){
          return 1;
        }
        continue;
      }
    }
    c2 = (zString[0]<0x80?*(zString++):sqlite3Utf8Read(&zString));
    if( c==c2 ) continue;
    if( noCase && (sqlite3UpperToLower[(unsigned char)(c)])==(sqlite3UpperToLower[(unsigned char)(c2)]) && c<0x80 && c2<0x80 ){
      continue;
    }
    if( c==matchOne && zPattern!=zEscaped && c2!=0 ) continue;
    return 1;
  }
  return *zString==0 ? 0 : 1;
}





 int sqlite3_strglob(const char *zGlobPattern, const char *zString){
  return patternCompare((u8*)zGlobPattern, (u8*)zString, &globInfo, '[');
}





 int sqlite3_strlike(const char *zPattern, const char *zStr, unsigned int esc){
  return patternCompare((u8*)zPattern, (u8*)zStr, &likeInfoNorm, esc);
}
# 114782 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void likeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zA, *zB;
  u32 escape;
  int nPat;
  sqlite3 *db = sqlite3_context_db_handle(context);
  struct compareInfo *pInfo = sqlite3_user_data(context);
# 114808 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  nPat = sqlite3_value_bytes(argv[0]);
  ;
  ;
  if( nPat > db->aLimit[8] ){
    sqlite3_result_error(context, "LIKE or GLOB pattern too complex", -1);
    return;
  }
  if( argc==3 ){



    const unsigned char *zEsc = sqlite3_value_text(argv[2]);
    if( zEsc==0 ) return;
    if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){
      sqlite3_result_error(context,
          "ESCAPE expression must be a single character", -1);
      return;
    }
    escape = sqlite3Utf8Read(&zEsc);
  }else{
    escape = pInfo->matchSet;
  }
  zB = sqlite3_value_text(argv[0]);
  zA = sqlite3_value_text(argv[1]);
  if( zA && zB ){



    sqlite3_result_int(context,
                      patternCompare(zB, zA, pInfo, escape)==0);
  }
}






static void nullifFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  CollSeq *pColl = sqlite3GetFuncCollSeq(context);
  (void)(NotUsed);
  if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){
    sqlite3_result_value(context, argv[0]);
  }
}





static void versionFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_text(context, sqlite3_libversion(), -1, ((sqlite3_destructor_type)0));
}






static void sourceidFunc(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  (void)(NotUsed),(void)(NotUsed2);


  sqlite3_result_text(context, sqlite3_sourceid(), -1, ((sqlite3_destructor_type)0));
}






static void errlogFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  (void)(argc);
  (void)(context);
  sqlite3_log(sqlite3_value_int(argv[0]), "%s", sqlite3_value_text(argv[1]));
}







static void compileoptionusedFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zOptName;
  ((void)0);
  (void)(argc);




  if( (zOptName = (const char*)sqlite3_value_text(argv[0]))!=0 ){
    sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));
  }
}
# 114934 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void compileoptiongetFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  ((void)0);
  (void)(argc);



  n = sqlite3_value_int(argv[0]);
  sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, ((sqlite3_destructor_type)0));
}




static const char hexdigits[] = {
  '0', '1', '2', '3', '4', '5', '6', '7',
  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'
};
# 114964 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){
  ((void)0);
  (void)(argc);
  switch( sqlite3_value_type(argv[0]) ){
    case 2: {
      double r1, r2;
      char zBuf[50];
      r1 = sqlite3_value_double(argv[0]);
      sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.15g", r1);
      sqlite3AtoF(zBuf, &r2, 20, 1);
      if( r1!=r2 ){
        sqlite3_snprintf(sizeof(zBuf), zBuf, "%!.20e", r1);
      }
      sqlite3_result_text(context, zBuf, -1, ((sqlite3_destructor_type)-1));
      break;
    }
    case 1: {
      sqlite3_result_value(context, argv[0]);
      break;
    }
    case 4: {
      char *zText = 0;
      char const *zBlob = sqlite3_value_blob(argv[0]);
      int nBlob = sqlite3_value_bytes(argv[0]);
      ((void)0);
      zText = (char *)contextMalloc(context, (2*(i64)nBlob)+4);
      if( zText ){
        int i;
        for(i=0; i<nBlob; i++){
          zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];
          zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];
        }
        zText[(nBlob*2)+2] = '\'';
        zText[(nBlob*2)+3] = '\0';
        zText[0] = 'X';
        zText[1] = '\'';
        sqlite3_result_text(context, zText, -1, ((sqlite3_destructor_type)-1));
        sqlite3_free(zText);
      }
      break;
    }
    case 3: {
      int i,j;
      u64 n;
      const unsigned char *zArg = sqlite3_value_text(argv[0]);
      char *z;

      if( zArg==0 ) return;
      for(i=0, n=0; zArg[i]; i++){ if( zArg[i]=='\'' ) n++; }
      z = contextMalloc(context, ((i64)i)+((i64)n)+3);
      if( z ){
        z[0] = '\'';
        for(i=0, j=1; zArg[i]; i++){
          z[j++] = zArg[i];
          if( zArg[i]=='\'' ){
            z[j++] = '\'';
          }
        }
        z[j++] = '\'';
        z[j] = 0;
        sqlite3_result_text(context, z, j, sqlite3_free);
      }
      break;
    }
    default: {
      ((void)0);
      sqlite3_result_text(context, "NULL", 4, ((sqlite3_destructor_type)0));
      break;
    }
  }
}





static void unicodeFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *z = sqlite3_value_text(argv[0]);
  (void)argc;
  if( z && z[0] ) sqlite3_result_int(context, sqlite3Utf8Read(&z));
}






static void charFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  unsigned char *z, *zOut;
  int i;
  zOut = z = sqlite3_malloc64( argc*4+1 );
  if( z==0 ){
    sqlite3_result_error_nomem(context);
    return;
  }
  for(i=0; i<argc; i++){
    sqlite3_int64 x;
    unsigned c;
    x = sqlite3_value_int64(argv[i]);
    if( x<0 || x>0x10ffff ) x = 0xfffd;
    c = (unsigned)(x & 0x1fffff);
    if( c<0x00080 ){
      *zOut++ = (u8)(c&0xFF);
    }else if( c<0x00800 ){
      *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    }else if( c<0x10000 ){
      *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);
      *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    }else{
      *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);
      *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);
      *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);
      *zOut++ = 0x80 + (u8)(c & 0x3F);
    }
  }
  sqlite3_result_text64(context, (char*)z, zOut-z, sqlite3_free, 1);
}





static void hexFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int i, n;
  const unsigned char *pBlob;
  char *zHex, *z;
  ((void)0);
  (void)(argc);
  pBlob = sqlite3_value_blob(argv[0]);
  n = sqlite3_value_bytes(argv[0]);
  ((void)0);
  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);
  if( zHex ){
    for(i=0; i<n; i++, pBlob++){
      unsigned char c = *pBlob;
      *(z++) = hexdigits[(c>>4)&0xf];
      *(z++) = hexdigits[c&0xf];
    }
    *z = 0;
    sqlite3_result_text(context, zHex, n*2, sqlite3_free);
  }
}




static void zeroblobFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  i64 n;
  int rc;
  ((void)0);
  (void)(argc);
  n = sqlite3_value_int64(argv[0]);
  if( n<0 ) n = 0;
  rc = sqlite3_result_zeroblob64(context, n);
  if( rc ){
    sqlite3_result_error_code(context, rc);
  }
}







static void replaceFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zStr;
  const unsigned char *zPattern;
  const unsigned char *zRep;
  unsigned char *zOut;
  int nStr;
  int nPattern;
  int nRep;
  i64 nOut;
  int loopLimit;
  int i, j;
  unsigned cntExpand;
  sqlite3 *db = sqlite3_context_db_handle(context);

  ((void)0);
  (void)(argc);
  zStr = sqlite3_value_text(argv[0]);
  if( zStr==0 ) return;
  nStr = sqlite3_value_bytes(argv[0]);
  ((void)0);
  zPattern = sqlite3_value_text(argv[1]);
  if( zPattern==0 ){
    ((void)0)
                                                                 ;
    return;
  }
  if( zPattern[0]==0 ){
    ((void)0);
    sqlite3_result_value(context, argv[0]);
    return;
  }
  nPattern = sqlite3_value_bytes(argv[1]);
  ((void)0);
  zRep = sqlite3_value_text(argv[2]);
  if( zRep==0 ) return;
  nRep = sqlite3_value_bytes(argv[2]);
  ((void)0);
  nOut = nStr + 1;
  ((void)0);
  zOut = contextMalloc(context, (i64)nOut);
  if( zOut==0 ){
    return;
  }
  loopLimit = nStr - nPattern;
  cntExpand = 0;
  for(i=j=0; i<=loopLimit; i++){
    if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){
      zOut[j++] = zStr[i];
    }else{
      if( nRep>nPattern ){
        nOut += nRep - nPattern;
        ;
        ;
        if( nOut-1>db->aLimit[0] ){
          sqlite3_result_error_toobig(context);
          sqlite3_free(zOut);
          return;
        }
        cntExpand++;
        if( (cntExpand&(cntExpand-1))==0 ){


          u8 *zOld;
          zOld = zOut;
          zOut = sqlite3_realloc64(zOut, (int)nOut + (nOut - nStr - 1));
          if( zOut==0 ){
            sqlite3_result_error_nomem(context);
            sqlite3_free(zOld);
            return;
          }
        }
      }
      memcpy(&zOut[j], zRep, nRep);
      j += nRep;
      i += nPattern-1;
    }
  }
  ((void)0);
  memcpy(&zOut[j], &zStr[i], nStr-i);
  j += nStr - i;
  ((void)0);
  zOut[j] = 0;
  sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);
}





static void trimFunc(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const unsigned char *zIn;
  const unsigned char *zCharSet;
  int nIn;
  int flags;
  int i;
  unsigned char *aLen = 0;
  unsigned char **azChar = 0;
  int nChar;

  if( sqlite3_value_type(argv[0])==5 ){
    return;
  }
  zIn = sqlite3_value_text(argv[0]);
  if( zIn==0 ) return;
  nIn = sqlite3_value_bytes(argv[0]);
  ((void)0);
  if( argc==1 ){
    static const unsigned char lenOne[] = { 1 };
    static unsigned char * const azOne[] = { (u8*)" " };
    nChar = 1;
    aLen = (u8*)lenOne;
    azChar = (unsigned char **)azOne;
    zCharSet = 0;
  }else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){
    return;
  }else{
    const unsigned char *z;
    for(z=zCharSet, nChar=0; *z; nChar++){
      { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
    }
    if( nChar>0 ){
      azChar = contextMalloc(context, ((i64)nChar)*(sizeof(char*)+1));
      if( azChar==0 ){
        return;
      }
      aLen = (unsigned char*)&azChar[nChar];
      for(z=zCharSet, nChar=0; *z; nChar++){
        azChar[nChar] = (unsigned char *)z;
        { if( (*(z++))>=0xc0 ){ while( (*z & 0xc0)==0x80 ){ z++; } } };
        aLen[nChar] = (u8)(z - azChar[nChar]);
      }
    }
  }
  if( nChar>0 ){
    flags = ((int)(long int)(sqlite3_user_data(context)));
    if( flags & 1 ){
      while( nIn>0 ){
        int len = 0;
        for(i=0; i<nChar; i++){
          len = aLen[i];
          if( len<=nIn && memcmp(zIn, azChar[i], len)==0 ) break;
        }
        if( i>=nChar ) break;
        zIn += len;
        nIn -= len;
      }
    }
    if( flags & 2 ){
      while( nIn>0 ){
        int len = 0;
        for(i=0; i<nChar; i++){
          len = aLen[i];
          if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) break;
        }
        if( i>=nChar ) break;
        nIn -= len;
      }
    }
    if( zCharSet ){
      sqlite3_free(azChar);
    }
  }
  sqlite3_result_text(context, (char*)zIn, nIn, ((sqlite3_destructor_type)-1));
}
# 115405 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){
  const char *zFile = (const char *)sqlite3_value_text(argv[0]);
  const char *zProc;
  sqlite3 *db = sqlite3_context_db_handle(context);
  char *zErrMsg = 0;




  if( (db->flags & 0x00020000)==0 ){
    sqlite3_result_error(context, "not authorized", -1);
    return;
  }

  if( argc==2 ){
    zProc = (const char *)sqlite3_value_text(argv[1]);
  }else{
    zProc = 0;
  }
  if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){
    sqlite3_result_error(context, zErrMsg, -1);
    sqlite3_free(zErrMsg);
  }
}







typedef struct SumCtx SumCtx;
struct SumCtx {
  double rSum;
  i64 iSum;
  i64 cnt;
  u8 overflow;
  u8 approx;
};
# 115455 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  SumCtx *p;
  int type;
  ((void)0);
  (void)(argc);
  p = sqlite3_aggregate_context(context, sizeof(*p));
  type = sqlite3_value_numeric_type(argv[0]);
  if( p && type!=5 ){
    p->cnt++;
    if( type==1 ){
      i64 v = sqlite3_value_int64(argv[0]);
      p->rSum += v;
      if( (p->approx|p->overflow)==0 && sqlite3AddInt64(&p->iSum, v) ){
        p->approx = p->overflow = 1;
      }
    }else{
      p->rSum += sqlite3_value_double(argv[0]);
      p->approx = 1;
    }
  }
}

static void sumInverse(sqlite3_context *context, int argc, sqlite3_value**argv){
  SumCtx *p;
  int type;
  ((void)0);
  (void)(argc);
  p = sqlite3_aggregate_context(context, sizeof(*p));
  type = sqlite3_value_numeric_type(argv[0]);


  if( (p) && type!=5 ){
    ((void)0);
    p->cnt--;
    ((void)0);
    if( type==1 && p->approx==0 ){
      i64 v = sqlite3_value_int64(argv[0]);
      p->rSum -= v;
      p->iSum -= v;
    }else{
      p->rSum -= sqlite3_value_double(argv[0]);
    }
  }
}



static void sumFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  if( p && p->cnt>0 ){
    if( p->overflow ){
      sqlite3_result_error(context,"integer overflow",-1);
    }else if( p->approx ){
      sqlite3_result_double(context, p->rSum);
    }else{
      sqlite3_result_int64(context, p->iSum);
    }
  }
}
static void avgFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  if( p && p->cnt>0 ){
    sqlite3_result_double(context, p->rSum/(double)p->cnt);
  }
}
static void totalFinalize(sqlite3_context *context){
  SumCtx *p;
  p = sqlite3_aggregate_context(context, 0);

  sqlite3_result_double(context, p ? p->rSum : (double)0);
}





typedef struct CountCtx CountCtx;
struct CountCtx {
  i64 n;



};




static void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, sizeof(*p));
  if( (argc==0 || 5!=sqlite3_value_type(argv[0])) && p ){
    p->n++;
  }






  ((void)0)
                                                     ;

}
static void countFinalize(sqlite3_context *context){
  CountCtx *p;
  p = sqlite3_aggregate_context(context, 0);
  sqlite3_result_int64(context, p ? p->n : 0);
}

static void countInverse(sqlite3_context *ctx, int argc, sqlite3_value **argv){
  CountCtx *p;
  p = sqlite3_aggregate_context(ctx, sizeof(*p));

  if( (argc==0 || 5!=sqlite3_value_type(argv[0])) && (p) ){
    p->n--;



  }
}







static void minmaxStep(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **argv
){
  Mem *pArg = (Mem *)argv[0];
  Mem *pBest;
  (void)(NotUsed);

  pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));
  if( !pBest ) return;

  if( sqlite3_value_type(pArg)==5 ){
    if( pBest->flags ) sqlite3SkipAccumulatorLoad(context);
  }else if( pBest->flags ){
    int max;
    int cmp;
    CollSeq *pColl = sqlite3GetFuncCollSeq(context);
# 115610 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    max = sqlite3_user_data(context)!=0;
    cmp = sqlite3MemCompare(pBest, pArg, pColl);
    if( (max && cmp<0) || (!max && cmp>0) ){
      sqlite3VdbeMemCopy(pBest, pArg);
    }else{
      sqlite3SkipAccumulatorLoad(context);
    }
  }else{
    pBest->db = sqlite3_context_db_handle(context);
    sqlite3VdbeMemCopy(pBest, pArg);
  }
}
static void minMaxValueFinalize(sqlite3_context *context, int bValue){
  sqlite3_value *pRes;
  pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);
  if( pRes ){
    if( pRes->flags ){
      sqlite3_result_value(context, pRes);
    }
    if( bValue==0 ) sqlite3VdbeMemRelease(pRes);
  }
}

static void minMaxValue(sqlite3_context *context){
  minMaxValueFinalize(context, 1);
}



static void minMaxFinalize(sqlite3_context *context){
  minMaxValueFinalize(context, 0);
}




static void groupConcatStep(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  const char *zVal;
  StrAccum *pAccum;
  const char *zSep;
  int nVal, nSep;
  ((void)0);
  if( sqlite3_value_type(argv[0])==5 ) return;
  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));

  if( pAccum ){
    sqlite3 *db = sqlite3_context_db_handle(context);
    int firstTerm = pAccum->mxAlloc==0;
    pAccum->mxAlloc = db->aLimit[0];
    if( !firstTerm ){
      if( argc==2 ){
        zSep = (char*)sqlite3_value_text(argv[1]);
        nSep = sqlite3_value_bytes(argv[1]);
      }else{
        zSep = ",";
        nSep = 1;
      }
      if( zSep ) sqlite3_str_append(pAccum, zSep, nSep);
    }
    zVal = (char*)sqlite3_value_text(argv[0]);
    nVal = sqlite3_value_bytes(argv[0]);
    if( zVal ) sqlite3_str_append(pAccum, zVal, nVal);
  }
}

static void groupConcatInverse(
  sqlite3_context *context,
  int argc,
  sqlite3_value **argv
){
  int n;
  StrAccum *pAccum;
  ((void)0);
  if( sqlite3_value_type(argv[0])==5 ) return;
  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));


  if( (pAccum) ){
    n = sqlite3_value_bytes(argv[0]);
    if( argc==2 ){
      n += sqlite3_value_bytes(argv[1]);
    }else{
      n++;
    }
    if( n>=(int)pAccum->nChar ){
      pAccum->nChar = 0;
    }else{
      pAccum->nChar -= n;
      memmove(pAccum->zText, &pAccum->zText[n], pAccum->nChar);
    }
    if( pAccum->nChar==0 ) pAccum->mxAlloc = 0;
  }
}



static void groupConcatFinalize(sqlite3_context *context){
  StrAccum *pAccum;
  pAccum = sqlite3_aggregate_context(context, 0);
  if( pAccum ){
    if( pAccum->accError==18 ){
      sqlite3_result_error_toobig(context);
    }else if( pAccum->accError==7 ){
      sqlite3_result_error_nomem(context);
    }else{
      sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), -1,
                          sqlite3_free);
    }
  }
}

static void groupConcatValue(sqlite3_context *context){
  sqlite3_str *pAccum;
  pAccum = (sqlite3_str*)sqlite3_aggregate_context(context, 0);
  if( pAccum ){
    if( pAccum->accError==18 ){
      sqlite3_result_error_toobig(context);
    }else if( pAccum->accError==7 ){
      sqlite3_result_error_nomem(context);
    }else{
      const char *zText = sqlite3_str_value(pAccum);
      sqlite3_result_text(context, zText, -1, ((sqlite3_destructor_type)-1));
    }
  }
}
# 115748 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3RegisterPerConnectionBuiltinFunctions(sqlite3 *db){
  int rc = sqlite3_overload_function(db, "MATCH", 2);
  ((void)0);
  if( rc==7 ){
    sqlite3OomFault(db);
  }
}






static void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){
  struct compareInfo *pInfo;
  int flags;
  if( caseSensitive ){
    pInfo = (struct compareInfo*)&likeInfoAlt;
    flags = 0x0004 | 0x0008;
  }else{
    pInfo = (struct compareInfo*)&likeInfoNorm;
    flags = 0x0004;
  }
  sqlite3CreateFunc(db, "like", 2, 1, pInfo, likeFunc, 0, 0, 0, 0, 0);
  sqlite3CreateFunc(db, "like", 3, 1, pInfo, likeFunc, 0, 0, 0, 0, 0);
  sqlite3FindFunction(db, "like", 2, 1, 0)->funcFlags |= flags;
  sqlite3FindFunction(db, "like", 3, 1, 0)->funcFlags |= flags;
}
# 115794 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){
  FuncDef *pDef;
  int nExpr;
  if( pExpr->op!=167 || !pExpr->x.pList ){
    return 0;
  }
  ((void)0);
  nExpr = pExpr->x.pList->nExpr;
  pDef = sqlite3FindFunction(db, pExpr->u.zToken, nExpr, 1, 0);
  if( (pDef==0) || (pDef->funcFlags & 0x0004)==0 ){
    return 0;
  }
  if( nExpr<3 ){
    aWc[3] = 0;
  }else{
    Expr *pEscape = pExpr->x.pList->a[2].pExpr;
    char *zEscape;
    if( pEscape->op!=113 ) return 0;
    zEscape = pEscape->u.zToken;
    if( zEscape[0]==0 || zEscape[1]!=0 ) return 0;
    aWc[3] = zEscape[0];
  }





  memcpy(aWc, pDef->pUserData, 3);
  ((void)0);
  ((void)0);
  ((void)0);
  *pIsNocase = (pDef->funcFlags & 0x0008)==0;
  return 1;
}
# 115836 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3RegisterBuiltinFunctions(void){
# 115847 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  static FuncDef aBuiltinFunc[] = {




    {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, loadExt, 0, 0, 0, "load_extension", {0} },
    {2, 1|(0*0x0020), ((void*)(long int)(0)), 0, loadExt, 0, 0, 0, "load_extension", {0} },





    {1, 0x2000|1, 0, 0, compileoptionusedFunc, 0, 0, 0, "sqlite_compileoption_used", {0} },
    {1, 0x2000|1, 0, 0, compileoptiongetFunc, 0, 0, 0, "sqlite_compileoption_get", {0} },

    {1,0x0800|1|(0*0x0020)|0x0400, ((void*)(long int)(0)), 0, versionFunc, 0, 0, 0, "unlikely", {0} },
    {2,0x0800|1|(0*0x0020)|0x0400, ((void*)(long int)(0)), 0, versionFunc, 0, 0, 0, "likelihood", {0} },
    {1,0x0800|1|(0*0x0020)|0x0400, ((void*)(long int)(0)), 0, versionFunc, 0, 0, 0, "likely", {0} },







    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(1)), 0, trimFunc, 0, 0, 0, "ltrim", {0} },
    {2, 0x0800|1|(0*0x0020), ((void*)(long int)(1)), 0, trimFunc, 0, 0, 0, "ltrim", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(2)), 0, trimFunc, 0, 0, 0, "rtrim", {0} },
    {2, 0x0800|1|(0*0x0020), ((void*)(long int)(2)), 0, trimFunc, 0, 0, 0, "rtrim", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(3)), 0, trimFunc, 0, 0, 0, "trim", {0} },
    {2, 0x0800|1|(0*0x0020), ((void*)(long int)(3)), 0, trimFunc, 0, 0, 0, "trim", {0} },
    {-1, 0x0800|1|(1*0x0020), ((void*)(long int)(0)), 0, minmaxFunc, 0, 0, 0, "min", {0} },
    {0, 0x0800|1|(1*0x0020), ((void*)(long int)(0)), 0, 0, 0, 0, 0, "min", {0} },
    {1, 1|(1*0x0020)|0x1000, ((void*)(long int)(0)), 0, minmaxStep,minMaxFinalize,minMaxValue,0,"min", {0}}
                                                              ,
    {-1, 0x0800|1|(1*0x0020), ((void*)(long int)(1)), 0, minmaxFunc, 0, 0, 0, "max", {0} },
    {0, 0x0800|1|(1*0x0020), ((void*)(long int)(1)), 0, 0, 0, 0, 0, "max", {0} },
    {1, 1|(1*0x0020)|0x1000, ((void*)(long int)(1)), 0, minmaxStep,minMaxFinalize,minMaxValue,0,"max", {0}}
                                                              ,
    {1,0x0800|1|(0*0x0020)|0x0080, ((void*)(long int)(0)), 0, typeofFunc, 0, 0, 0, "typeof", {0} },
    {1,0x0800|1|(0*0x0020)|0x0040, ((void*)(long int)(0)), 0, lengthFunc, 0, 0, 0, "length", {0} },
    {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, instrFunc, 0, 0, 0, "instr", {0} },
    {-1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, printfFunc, 0, 0, 0, "printf", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, unicodeFunc, 0, 0, 0, "unicode", {0} },
    {-1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, charFunc, 0, 0, 0, "char", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, absFunc, 0, 0, 0, "abs", {0} },

    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, roundFunc, 0, 0, 0, "round", {0} },
    {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, roundFunc, 0, 0, 0, "round", {0} },

    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, upperFunc, 0, 0, 0, "upper", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, lowerFunc, 0, 0, 0, "lower", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, hexFunc, 0, 0, 0, "hex", {0} },
    {2,0x0800|1|(0*0x0020)|0x0200, ((void*)(long int)(0)), 0, versionFunc, 0, 0, 0, "ifnull", {0} },
    {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, randomFunc, 0, 0, 0, "random", {0} },
    {1, 1|(0*0x0020), ((void*)(long int)(0)), 0, randomBlob, 0, 0, 0, "randomblob", {0} },
    {2, 0x0800|1|(1*0x0020), ((void*)(long int)(0)), 0, nullifFunc, 0, 0, 0, "nullif", {0} },
    {0, 0x2000|1, 0, 0, versionFunc, 0, 0, 0, "sqlite_version", {0} },
    {0, 0x2000|1, 0, 0, sourceidFunc, 0, 0, 0, "sqlite_source_id", {0} },
    {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, errlogFunc, 0, 0, 0, "sqlite_log", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, quoteFunc, 0, 0, 0, "quote", {0} },
    {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, last_insert_rowid, 0, 0, 0, "last_insert_rowid", {0} },
    {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, changes, 0, 0, 0, "changes", {0} },
    {0, 1|(0*0x0020), ((void*)(long int)(0)), 0, total_changes, 0, 0, 0, "total_changes", {0} },
    {3, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, replaceFunc, 0, 0, 0, "replace", {0} },
    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, zeroblobFunc, 0, 0, 0, "zeroblob", {0} },
    {2, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, substrFunc, 0, 0, 0, "substr", {0} },
    {3, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, substrFunc, 0, 0, 0, "substr", {0} },
    {1, 1|(0*0x0020)|0, ((void*)(long int)(0)), 0, sumStep,sumFinalize,sumFinalize,sumInverse,"sum", {0}},
    {1, 1|(0*0x0020)|0, ((void*)(long int)(0)), 0, sumStep,totalFinalize,totalFinalize,sumInverse,"total", {0}},
    {1, 1|(0*0x0020)|0, ((void*)(long int)(0)), 0, sumStep,avgFinalize,avgFinalize,sumInverse,"avg", {0}},
    {0, 1|(0*0x0020)|0x0100, ((void*)(long int)(0)), 0, countStep,countFinalize,countFinalize,countInverse,"count", {0}}
                                                                        ,
    {1, 1|(0*0x0020)|0, ((void*)(long int)(0)), 0, countStep,countFinalize,countFinalize,countInverse,"count", {0}}
                                                        ,
    {1, 1|(0*0x0020)|0, ((void*)(long int)(0)), 0, groupConcatStep,groupConcatFinalize,groupConcatValue,groupConcatInverse,"group_concat", {0}}
                                                                     ,
    {2, 1|(0*0x0020)|0, ((void*)(long int)(0)), 0, groupConcatStep,groupConcatFinalize,groupConcatValue,groupConcatInverse,"group_concat", {0}}
                                                                     ,

    {2, 0x0800|1|0x0004|0x0008, (void *)&globInfo, 0, likeFunc, 0, 0, 0, "glob", {0} },




    {2, 0x0800|1|0x0004, (void *)&likeInfoNorm, 0, likeFunc, 0, 0, 0, "like", {0} },
    {3, 0x0800|1|0x0004, (void *)&likeInfoNorm, 0, likeFunc, 0, 0, 0, "like", {0} },




    {1, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 0, 0, 0, 0, "coalesce", {0} },
    {0, 0x0800|1|(0*0x0020), ((void*)(long int)(0)), 0, 0, 0, 0, 0, "coalesce", {0} },
    {-1,0x0800|1|(0*0x0020)|0x0200, ((void*)(long int)(0)), 0, versionFunc, 0, 0, 0, "coalesce", {0} },
  };

  sqlite3AlterFunctions();

  sqlite3WindowFunctions();
  sqlite3RegisterDateTimeFunctions();
  sqlite3InsertBuiltinFuncs(aBuiltinFunc, ((int)(sizeof(aBuiltinFunc)/sizeof(aBuiltinFunc[0]))));
# 115964 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}
# 116150 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3FkLocateIndex(
  Parse *pParse,
  Table *pParent,
  FKey *pFKey,
  Index **ppIdx,
  int **paiCol
){
  Index *pIdx = 0;
  int *aiCol = 0;
  int nCol = pFKey->nCol;
  char *zKey = pFKey->aCol[0].zCol;


  ((void)0);
  ((void)0);
  ((void)0);
# 116175 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( nCol==1 ){







    if( pParent->iPKey>=0 ){
      if( !zKey ) return 0;
      if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zName, zKey) ) return 0;
    }
  }else if( paiCol ){
    ((void)0);
    aiCol = (int *)sqlite3DbMallocRawNN(pParse->db, nCol*sizeof(int));
    if( !aiCol ) return 1;
    *paiCol = aiCol;
  }

  for(pIdx=pParent->pIndex; pIdx; pIdx=pIdx->pNext){
    if( pIdx->nKeyCol==nCol && ((pIdx)->onError!=0) && pIdx->pPartIdxWhere==0 ){




      if( zKey==0 ){



        if( ((pIdx)->idxType==2) ){
          if( aiCol ){
            int i;
            for(i=0; i<nCol; i++) aiCol[i] = pFKey->aCol[i].iFrom;
          }
          break;
        }
      }else{




        int i, j;
        for(i=0; i<nCol; i++){
          i16 iCol = pIdx->aiColumn[i];
          const char *zDfltColl;
          char *zIdxCol;

          if( iCol<0 ) break;




          zDfltColl = pParent->aCol[iCol].zColl;
          if( !zDfltColl ) zDfltColl = sqlite3StrBINARY;
          if( sqlite3StrICmp(pIdx->azColl[i], zDfltColl) ) break;

          zIdxCol = pParent->aCol[iCol].zName;
          for(j=0; j<nCol; j++){
            if( sqlite3StrICmp(pFKey->aCol[j].zCol, zIdxCol)==0 ){
              if( aiCol ) aiCol[i] = pFKey->aCol[j].iFrom;
              break;
            }
          }
          if( j==nCol ) break;
        }
        if( i==nCol ) break;
      }
    }
  }

  if( !pIdx ){
    if( !pParse->disableTriggers ){
      sqlite3ErrorMsg(pParse,
           "foreign key mismatch - \"%w\" referencing \"%w\"",
           pFKey->pFrom->zName, pFKey->zTo);
    }
    sqlite3DbFree(pParse->db, aiCol);
    return 1;
  }

  *ppIdx = pIdx;
  return 0;
}
# 116285 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void fkLookupParent(
  Parse *pParse,
  int iDb,
  Table *pTab,
  Index *pIdx,
  FKey *pFKey,
  int *aiCol,
  int regData,
  int nIncr,
  int isIgnore
){
  int i;
  Vdbe *v = sqlite3GetVdbe(pParse);
  int iCur = pParse->nTab - 1;
  int iOk = sqlite3VdbeMakeLabel(pParse);

 



                                                       ;
# 116314 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( nIncr<0 ){
    sqlite3VdbeAddOp2(v, 46, pFKey->isDeferred, iOk);
    ;
  }
  for(i=0; i<pFKey->nCol; i++){
    int iReg = aiCol[i] + regData + 1;
    sqlite3VdbeAddOp2(v, 50, iReg, iOk); ;
  }

  if( isIgnore==0 ){
    if( pIdx==0 ){


      int iMustBeInt;
      int regTemp = sqlite3GetTempReg(pParse);






      sqlite3VdbeAddOp2(v, 79, aiCol[0]+1+regData, regTemp);
      iMustBeInt = sqlite3VdbeAddOp2(v, 15, regTemp, 0);
      ;





      if( pTab==pFKey->pFrom && nIncr==1 ){
        sqlite3VdbeAddOp3(v, 53, regData, iOk, regTemp); ;
        sqlite3VdbeChangeP5(v, 0x90);
      }

      sqlite3OpenTable(pParse, iCur, iDb, pTab, 97);
      sqlite3VdbeAddOp3(v, 31, iCur, 0, regTemp); ;
      sqlite3VdbeGoto(v, iOk);
      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
      sqlite3VdbeJumpHere(v, iMustBeInt);
      sqlite3ReleaseTempReg(pParse, regTemp);
    }else{
      int nCol = pFKey->nCol;
      int regTemp = sqlite3GetTempRange(pParse, nCol);
      int regRec = sqlite3GetTempReg(pParse);

      sqlite3VdbeAddOp3(v, 97, iCur, pIdx->tnum, iDb);
      sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      for(i=0; i<nCol; i++){
        sqlite3VdbeAddOp2(v, 78, aiCol[i]+1+regData, regTemp+i);
      }
# 116375 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( pTab==pFKey->pFrom && nIncr==1 ){
        int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;
        for(i=0; i<nCol; i++){
          int iChild = aiCol[i]+1+regData;
          int iParent = pIdx->aiColumn[i]+1+regData;
          ((void)0);
          ((void)0);
          if( pIdx->aiColumn[i]==pTab->iPKey ){

            iParent = regData;
          }
          sqlite3VdbeAddOp3(v, 52, iChild, iJump, iParent); ;
          sqlite3VdbeChangeP5(v, 0x10);
        }
        sqlite3VdbeGoto(v, iOk);
      }

      sqlite3VdbeAddOp4(v, 92, regTemp, nCol, regRec,
                        sqlite3IndexAffinityStr(pParse->db,pIdx), nCol);
      sqlite3VdbeAddOp4Int(v, 29, iCur, iOk, regRec, 0); ;

      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempRange(pParse, regTemp, nCol);
    }
  }

  if( !pFKey->isDeferred && !(pParse->db->flags & 0x00080000)
   && !pParse->pToplevel
   && !pParse->isMultiWrite
  ){




    ((void)0);
    sqlite3HaltConstraint(pParse, (19 | (3<<8)),
        2, 0, (-1), 4);
  }else{
    if( nIncr>0 && pFKey->isDeferred==0 ){
      sqlite3MayAbort(pParse);
    }
    sqlite3VdbeAddOp2(v, 150, pFKey->isDeferred, nIncr);
  }

  sqlite3VdbeResolveLabel(v, iOk);
  sqlite3VdbeAddOp1(v, 117, iCur);
}
# 116432 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *exprTableRegister(
  Parse *pParse,
  Table *pTab,
  int regBase,
  i16 iCol
){
  Expr *pExpr;
  Column *pCol;
  const char *zColl;
  sqlite3 *db = pParse->db;

  pExpr = sqlite3Expr(db, 171, 0);
  if( pExpr ){
    if( iCol>=0 && iCol!=pTab->iPKey ){
      pCol = &pTab->aCol[iCol];
      pExpr->iTable = regBase + iCol + 1;
      pExpr->affExpr = pCol->affinity;
      zColl = pCol->zColl;
      if( zColl==0 ) zColl = db->pDfltColl->zName;
      pExpr = sqlite3ExprAddCollateString(pParse, pExpr, zColl);
    }else{
      pExpr->iTable = regBase;
      pExpr->affExpr = 0x44;
    }
  }
  return pExpr;
}





static Expr *exprTableColumn(
  sqlite3 *db,
  Table *pTab,
  int iCursor,
  i16 iCol
){
  Expr *pExpr = sqlite3Expr(db, 162, 0);
  if( pExpr ){
    pExpr->y.pTab = pTab;
    pExpr->iTable = iCursor;
    pExpr->iColumn = iCol;
  }
  return pExpr;
}
# 116511 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void fkScanChildren(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  Index *pIdx,
  FKey *pFKey,
  int *aiCol,
  int regData,
  int nIncr
){
  sqlite3 *db = pParse->db;
  int i;
  Expr *pWhere = 0;
  NameContext sNameContext;
  WhereInfo *pWInfo;
  int iFkIfZero = 0;
  Vdbe *v = sqlite3GetVdbe(pParse);

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( nIncr<0 ){
    iFkIfZero = sqlite3VdbeAddOp2(v, 46, pFKey->isDeferred, 0);
    ;
  }
# 116547 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=0; i<pFKey->nCol; i++){
    Expr *pLeft;
    Expr *pRight;
    Expr *pEq;
    i16 iCol;
    const char *zCol;

    iCol = pIdx ? pIdx->aiColumn[i] : -1;
    pLeft = exprTableRegister(pParse, pTab, regData, iCol);
    iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
    ((void)0);
    zCol = pFKey->pFrom->aCol[iCol].zName;
    pRight = sqlite3Expr(db, 59, zCol);
    pEq = sqlite3PExpr(pParse, 53, pLeft, pRight);
    pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);
  }
# 116578 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pTab==pFKey->pFrom && nIncr>0 ){
    Expr *pNe;
    Expr *pLeft;
    Expr *pRight;
    if( (((pTab)->tabFlags & 0x0020)==0) ){
      pLeft = exprTableRegister(pParse, pTab, regData, -1);
      pRight = exprTableColumn(db, pTab, pSrc->a[0].iCursor, -1);
      pNe = sqlite3PExpr(pParse, 52, pLeft, pRight);
    }else{
      Expr *pEq, *pAll = 0;
      ((void)0);
      for(i=0; i<pIdx->nKeyCol; i++){
        i16 iCol = pIdx->aiColumn[i];
        ((void)0);
        pLeft = exprTableRegister(pParse, pTab, regData, iCol);
        pRight = sqlite3Expr(db, 59, pTab->aCol[iCol].zName);
        pEq = sqlite3PExpr(pParse, 45, pLeft, pRight);
        pAll = sqlite3ExprAnd(pParse, pAll, pEq);
      }
      pNe = sqlite3PExpr(pParse, 19, pAll, 0);
    }
    pWhere = sqlite3ExprAnd(pParse, pWhere, pNe);
  }


  memset(&sNameContext, 0, sizeof(NameContext));
  sNameContext.pSrcList = pSrc;
  sNameContext.pParse = pParse;
  sqlite3ResolveExprNames(&sNameContext, pWhere);




  if( pParse->nErr==0 ){
    pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0, 0, 0);
    sqlite3VdbeAddOp2(v, 150, pFKey->isDeferred, nIncr);
    if( pWInfo ){
      sqlite3WhereEnd(pWInfo);
    }
  }


  sqlite3ExprDelete(db, pWhere);
  if( iFkIfZero ){
    sqlite3VdbeJumpHere(v, iFkIfZero);
  }
}
# 116640 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static FKey *sqlite3FkReferences(Table *pTab){
  return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName);
}
# 116652 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){
  if( p ){
    TriggerStep *pStep = p->step_list;
    sqlite3ExprDelete(dbMem, pStep->pWhere);
    sqlite3ExprListDelete(dbMem, pStep->pExprList);
    sqlite3SelectDelete(dbMem, pStep->pSelect);
    sqlite3ExprDelete(dbMem, p->pWhen);
    sqlite3DbFree(dbMem, p);
  }
}
# 116680 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab){
  sqlite3 *db = pParse->db;
  if( (db->flags&0x00004000) && !((pTab)->nModuleArg) ){
    int iSkip = 0;
    Vdbe *v = sqlite3GetVdbe(pParse);

    ((void)0);
    ((void)0);
    if( sqlite3FkReferences(pTab)==0 ){





      FKey *p;
      for(p=pTab->pFKey; p; p=p->pNextFrom){
        if( p->isDeferred || (db->flags & 0x00080000) ) break;
      }
      if( !p ) return;
      iSkip = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeAddOp2(v, 46, 1, iSkip); ;
    }

    pParse->disableTriggers = 1;
    sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0, 0, 0);
    pParse->disableTriggers = 0;
# 116716 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (db->flags & 0x00080000)==0 ){
      ;
      sqlite3VdbeAddOp2(v, 46, 0, sqlite3VdbeCurrentAddr(v)+2);
      ;
      sqlite3HaltConstraint(pParse, (19 | (3<<8)),
          2, 0, (-1), 4);
    }

    if( iSkip ){
      sqlite3VdbeResolveLabel(v, iSkip);
    }
  }
}
# 116743 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int fkChildIsModified(
  Table *pTab,
  FKey *p,
  int *aChange,
  int bChngRowid
){
  int i;
  for(i=0; i<p->nCol; i++){
    int iChildKey = p->aCol[i].iFrom;
    if( aChange[iChildKey]>=0 ) return 1;
    if( iChildKey==pTab->iPKey && bChngRowid ) return 1;
  }
  return 0;
}
# 116770 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int fkParentIsModified(
  Table *pTab,
  FKey *p,
  int *aChange,
  int bChngRowid
){
  int i;
  for(i=0; i<p->nCol; i++){
    char *zKey = p->aCol[i].zCol;
    int iKey;
    for(iKey=0; iKey<pTab->nCol; iKey++){
      if( aChange[iKey]>=0 || (iKey==pTab->iPKey && bChngRowid) ){
        Column *pCol = &pTab->aCol[iKey];
        if( zKey ){
          if( 0==sqlite3StrICmp(pCol->zName, zKey) ) return 1;
        }else if( pCol->colFlags & 0x0001 ){
          return 1;
        }
      }
    }
  }
  return 0;
}






static int isSetNullAction(Parse *pParse, FKey *pFKey){
  Parse *pTop = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  if( pTop->pTriggerPrg ){
    Trigger *p = pTop->pTriggerPrg->pTrigger;
    if( (p==pFKey->apTrigger[0] && pFKey->aAction[0]==8)
     || (p==pFKey->apTrigger[1] && pFKey->aAction[1]==8)
    ){
      return 1;
    }
  }
  return 0;
}
# 116832 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3FkCheck(
  Parse *pParse,
  Table *pTab,
  int regOld,
  int regNew,
  int *aChange,
  int bChngRowid
){
  sqlite3 *db = pParse->db;
  FKey *pFKey;
  int iDb;
  const char *zDb;
  int isIgnoreErrors = pParse->disableTriggers;


  ((void)0);


  if( (db->flags&0x00004000)==0 ) return;

  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  zDb = db->aDb[iDb].zDbSName;



  for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){
    Table *pTo;
    Index *pIdx = 0;
    int *aiFree = 0;
    int *aiCol;
    int iCol;
    int i;
    int bIgnore = 0;

    if( aChange
     && sqlite3_stricmp(pTab->zName, pFKey->zTo)!=0
     && fkChildIsModified(pTab, pFKey, aChange, bChngRowid)==0
    ){
      continue;
    }





    if( pParse->disableTriggers ){
      pTo = sqlite3FindTable(db, pFKey->zTo, zDb);
    }else{
      pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb);
    }
    if( !pTo || sqlite3FkLocateIndex(pParse, pTo, pFKey, &pIdx, &aiFree) ){
      ((void)0);
      if( !isIgnoreErrors || db->mallocFailed ) return;
      if( pTo==0 ){







        Vdbe *v = sqlite3GetVdbe(pParse);
        int iJump = sqlite3VdbeCurrentAddr(v) + pFKey->nCol + 1;
        for(i=0; i<pFKey->nCol; i++){
          int iReg = pFKey->aCol[i].iFrom + regOld + 1;
          sqlite3VdbeAddOp2(v, 50, iReg, iJump); ;
        }
        sqlite3VdbeAddOp2(v, 150, pFKey->isDeferred, -1);
      }
      continue;
    }
    ((void)0);

    if( aiFree ){
      aiCol = aiFree;
    }else{
      iCol = pFKey->aCol[0].iFrom;
      aiCol = &iCol;
    }
    for(i=0; i<pFKey->nCol; i++){
      if( aiCol[i]==pTab->iPKey ){
        aiCol[i] = -1;
      }
      ((void)0);




      if( db->xAuth ){
        int rcauth;
        char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zName;
        rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);
        bIgnore = (rcauth==2);
      }

    }




    sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);
    pParse->nTab++;

    if( regOld!=0 ){



      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1, bIgnore);
    }
    if( regNew!=0 && !isSetNullAction(pParse, pFKey) ){
# 116950 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, +1, bIgnore);
    }

    sqlite3DbFree(db, aiFree);
  }



  for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
    Index *pIdx = 0;
    SrcList *pSrc;
    int *aiCol = 0;

    if( aChange && fkParentIsModified(pTab, pFKey, aChange, bChngRowid)==0 ){
      continue;
    }

    if( !pFKey->isDeferred && !(db->flags & 0x00080000)
     && !pParse->pToplevel && !pParse->isMultiWrite
    ){
      ((void)0);


      continue;
    }

    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){
      if( !isIgnoreErrors || db->mallocFailed ) return;
      continue;
    }
    ((void)0);



    pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
    if( pSrc ){
      struct SrcList_item *pItem = pSrc->a;
      pItem->pTab = pFKey->pFrom;
      pItem->zName = pFKey->pFrom->zName;
      pItem->pTab->nTabRef++;
      pItem->iCursor = pParse->nTab++;

      if( regNew!=0 ){
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1);
      }
      if( regOld!=0 ){
        int eAction = pFKey->aAction[aChange!=0];
        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);
# 117015 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        if( !pFKey->isDeferred && eAction!=10 && eAction!=8 ){
          sqlite3MayAbort(pParse);
        }
      }
      pItem->zName = 0;
      sqlite3SrcListDelete(db, pSrc);
    }
    sqlite3DbFree(db, aiCol);
  }
}

#define COLUMN_MASK(x) (((x)>31) ? 0xffffffff : ((u32)1<<(x)))





static u32 sqlite3FkOldmask(
  Parse *pParse,
  Table *pTab
){
  u32 mask = 0;
  if( pParse->db->flags&0x00004000 ){
    FKey *p;
    int i;
    for(p=pTab->pFKey; p; p=p->pNextFrom){
      for(i=0; i<p->nCol; i++) mask |= (((p->aCol[i].iFrom)>31) ? 0xffffffff : ((u32)1<<(p->aCol[i].iFrom)));
    }
    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
      Index *pIdx = 0;
      sqlite3FkLocateIndex(pParse, pTab, p, &pIdx, 0);
      if( pIdx ){
        for(i=0; i<pIdx->nKeyCol; i++){
          ((void)0);
          mask |= (((pIdx->aiColumn[i])>31) ? 0xffffffff : ((u32)1<<(pIdx->aiColumn[i])));
        }
      }
    }
  }
  return mask;
}
# 117080 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3FkRequired(
  Parse *pParse,
  Table *pTab,
  int *aChange,
  int chngRowid
){
  int eRet = 0;
  if( pParse->db->flags&0x00004000 ){
    if( !aChange ){



      eRet = (sqlite3FkReferences(pTab) || pTab->pFKey);
    }else{


      FKey *p;


      for(p=pTab->pFKey; p; p=p->pNextFrom){
        if( 0==sqlite3_stricmp(pTab->zName, p->zTo) ) return 2;
        if( fkChildIsModified(pTab, p, aChange, chngRowid) ){
          eRet = 1;
        }
      }


      for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){
        if( fkParentIsModified(pTab, p, aChange, chngRowid) ){
          if( p->aAction[1]!=0 ) return 2;
          eRet = 1;
        }
      }
    }
  }
  return eRet;
}
# 117147 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Trigger *fkActionTrigger(
  Parse *pParse,
  Table *pTab,
  FKey *pFKey,
  ExprList *pChanges
){
  sqlite3 *db = pParse->db;
  int action;
  Trigger *pTrigger;
  int iAction = (pChanges!=0);

  action = pFKey->aAction[iAction];
  if( action==7 && (db->flags & 0x00080000) ){
    return 0;
  }
  pTrigger = pFKey->apTrigger[iAction];

  if( action!=0 && !pTrigger ){
    char const *zFrom;
    int nFrom;
    Index *pIdx = 0;
    int *aiCol = 0;
    TriggerStep *pStep = 0;
    Expr *pWhere = 0;
    ExprList *pList = 0;
    Select *pSelect = 0;
    int i;
    Expr *pWhen = 0;

    if( sqlite3FkLocateIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;
    ((void)0);

    for(i=0; i<pFKey->nCol; i++){
      Token tOld = { "old", 3 };
      Token tNew = { "new", 3 };
      Token tFromCol;
      Token tToCol;
      int iFromCol;
      Expr *pEq;

      iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;
      ((void)0);
      ((void)0);
      ((void)0);
      sqlite3TokenInit(&tToCol,
                   pTab->aCol[pIdx ? pIdx->aiColumn[i] : pTab->iPKey].zName);
      sqlite3TokenInit(&tFromCol, pFKey->pFrom->aCol[iFromCol].zName);





      pEq = sqlite3PExpr(pParse, 53,
          sqlite3PExpr(pParse, 137,
            sqlite3ExprAlloc(db, 59, &tOld, 0),
            sqlite3ExprAlloc(db, 59, &tToCol, 0)),
          sqlite3ExprAlloc(db, 59, &tFromCol, 0)
      );
      pWhere = sqlite3ExprAnd(pParse, pWhere, pEq);






      if( pChanges ){
        pEq = sqlite3PExpr(pParse, 45,
            sqlite3PExpr(pParse, 137,
              sqlite3ExprAlloc(db, 59, &tOld, 0),
              sqlite3ExprAlloc(db, 59, &tToCol, 0)),
            sqlite3PExpr(pParse, 137,
              sqlite3ExprAlloc(db, 59, &tNew, 0),
              sqlite3ExprAlloc(db, 59, &tToCol, 0))
            );
        pWhen = sqlite3ExprAnd(pParse, pWhen, pEq);
      }

      if( action!=7 && (action!=10 || pChanges) ){
        Expr *pNew;
        if( action==10 ){
          pNew = sqlite3PExpr(pParse, 137,
            sqlite3ExprAlloc(db, 59, &tNew, 0),
            sqlite3ExprAlloc(db, 59, &tToCol, 0));
        }else if( action==9 ){
          Expr *pDflt = pFKey->pFrom->aCol[iFromCol].pDflt;
          if( pDflt ){
            pNew = sqlite3ExprDup(db, pDflt, 0);
          }else{
            pNew = sqlite3ExprAlloc(db, 117, 0, 0);
          }
        }else{
          pNew = sqlite3ExprAlloc(db, 117, 0, 0);
        }
        pList = sqlite3ExprListAppend(pParse, pList, pNew);
        sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);
      }
    }
    sqlite3DbFree(db, aiCol);

    zFrom = pFKey->pFrom->zName;
    nFrom = sqlite3Strlen30(zFrom);

    if( action==7 ){
      Token tFrom;
      Expr *pRaise;

      tFrom.z = zFrom;
      tFrom.n = nFrom;
      pRaise = sqlite3Expr(db, 71, "FOREIGN KEY constraint failed");
      if( pRaise ){
        pRaise->affExpr = 2;
      }
      pSelect = sqlite3SelectNew(pParse,
          sqlite3ExprListAppend(pParse, 0, pRaise),
          sqlite3SrcListAppend(pParse, 0, &tFrom, 0),
          pWhere,
          0, 0, 0, 0, 0
      );
      pWhere = 0;
    }


    db->lookaside.bDisable++;

    pTrigger = (Trigger *)sqlite3DbMallocZero(db,
        sizeof(Trigger) +
        sizeof(TriggerStep) +
        nFrom + 1
    );
    if( pTrigger ){
      pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];
      pStep->zTarget = (char *)&pStep[1];
      memcpy((char *)pStep->zTarget, zFrom, nFrom);

      pStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
      pStep->pExprList = sqlite3ExprListDup(db, pList, 0x0001);
      pStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
      if( pWhen ){
        pWhen = sqlite3PExpr(pParse, 19, pWhen, 0);
        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001);
      }
    }


    db->lookaside.bDisable--;

    sqlite3ExprDelete(db, pWhere);
    sqlite3ExprDelete(db, pWhen);
    sqlite3ExprListDelete(db, pList);
    sqlite3SelectDelete(db, pSelect);
    if( db->mallocFailed==1 ){
      fkTriggerDelete(db, pTrigger);
      return 0;
    }
    ((void)0);
    ((void)0);

    switch( action ){
      case 7:
        pStep->op = 134;
        break;
      case 10:
        if( !pChanges ){
          pStep->op = 124;
          break;
        }
      default:
        pStep->op = 125;
    }
    pStep->pTrig = pTrigger;
    pTrigger->pSchema = pTab->pSchema;
    pTrigger->pTabSchema = pTab->pSchema;
    pFKey->apTrigger[iAction] = pTrigger;
    pTrigger->op = (pChanges ? 125 : 124);
  }

  return pTrigger;
}





static void sqlite3FkActions(
  Parse *pParse,
  Table *pTab,
  ExprList *pChanges,
  int regOld,
  int *aChange,
  int bChngRowid
){




  if( pParse->db->flags&0x00004000 ){
    FKey *pFKey;
    for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){
      if( aChange==0 || fkParentIsModified(pTab, pFKey, aChange, bChngRowid) ){
        Trigger *pAct = fkActionTrigger(pParse, pTab, pFKey, pChanges);
        if( pAct ){
          sqlite3CodeRowTriggerDirect(pParse, pAct, pTab, regOld, 2, 0);
        }
      }
    }
  }
}
# 117362 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3FkDelete(sqlite3 *db, Table *pTab){
  FKey *pFKey;
  FKey *pNext;

  ((void)0)
                                                          ;
  for(pFKey=pTab->pFKey; pFKey; pFKey=pNext){


    if( !db || db->pnBytesFreed==0 ){
      if( pFKey->pPrevTo ){
        pFKey->pPrevTo->pNextTo = pFKey->pNextTo;
      }else{
        void *p = (void *)pFKey->pNextTo;
        const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);
        sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, p);
      }
      if( pFKey->pNextTo ){
        pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;
      }
    }




    ((void)0);



    fkTriggerDelete(db, pFKey->apTrigger[0]);
    fkTriggerDelete(db, pFKey->apTrigger[1]);


    pNext = pFKey->pNextFrom;
    sqlite3DbFree(db, pFKey);
  }
}
# 117428 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3OpenTable(
  Parse *pParse,
  int iCur,
  int iDb,
  Table *pTab,
  int opcode
){
  Vdbe *v;
  ((void)0);
  v = sqlite3GetVdbe(pParse);
  ((void)0);
  sqlite3TableLock(pParse, iDb, pTab->tnum,
                   (opcode==98)?1:0, pTab->zName);
  if( (((pTab)->tabFlags & 0x0020)==0) ){
    sqlite3VdbeAddOp4Int(v, opcode, iCur, pTab->tnum, iDb, pTab->nCol);
    ;
  }else{
    Index *pPk = sqlite3PrimaryKeyIndex(pTab);
    ((void)0);
    ((void)0);
    sqlite3VdbeAddOp3(v, opcode, iCur, pPk->tnum, iDb);
    sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    ;
  }
}
# 117474 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *sqlite3IndexAffinityStr(sqlite3 *db, Index *pIdx){
  if( !pIdx->zColAff ){
# 117484 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    int n;
    Table *pTab = pIdx->pTable;
    pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+1);
    if( !pIdx->zColAff ){
      sqlite3OomFault(db);
      return 0;
    }
    for(n=0; n<pIdx->nColumn; n++){
      i16 x = pIdx->aiColumn[n];
      char aff;
      if( x>=0 ){
        aff = pTab->aCol[x].affinity;
      }else if( x==(-1) ){
        aff = 0x44;
      }else{
        ((void)0);
        ((void)0);
        aff = sqlite3ExprAffinity(pIdx->aColExpr->a[n].pExpr);
      }
      if( aff<0x41 ) aff = 0x41;
      if( aff>0x43) aff = 0x43;
      pIdx->zColAff[n] = aff;
    }
    pIdx->zColAff[n] = 0;
  }

  return pIdx->zColAff;
}
# 117533 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3TableAffinity(Vdbe *v, Table *pTab, int iReg){
  int i;
  char *zColAff = pTab->zColAff;
  if( zColAff==0 ){
    sqlite3 *db = sqlite3VdbeDb(v);
    zColAff = (char *)sqlite3DbMallocRaw(0, pTab->nCol+1);
    if( !zColAff ){
      sqlite3OomFault(db);
      return;
    }

    for(i=0; i<pTab->nCol; i++){
      ((void)0);
      zColAff[i] = pTab->aCol[i].affinity;
    }
    do{
      zColAff[i--] = 0;
    }while( i>=0 && zColAff[i]<=0x41 );
    pTab->zColAff = zColAff;
  }
  ((void)0);
  i = (strlen(zColAff)&0x3fffffff);
  if( i ){
    if( iReg ){
      sqlite3VdbeAddOp4(v, 91, iReg, i, 0, zColAff, i);
    }else{
      sqlite3VdbeChangeP4(v, -1, zColAff, i);
    }
  }
}







static int readsTable(Parse *p, int iDb, Table *pTab){
  Vdbe *v = sqlite3GetVdbe(p);
  int i;
  int iEnd = sqlite3VdbeCurrentAddr(v);

  VTable *pVTab = ((pTab)->nModuleArg) ? sqlite3GetVTable(p->db, pTab) : 0;


  for(i=1; i<iEnd; i++){
    VdbeOp *pOp = sqlite3VdbeGetOp(v, i);
    ((void)0);
    if( pOp->opcode==97 && pOp->p3==iDb ){
      Index *pIndex;
      int tnum = pOp->p2;
      if( tnum==pTab->tnum ){
        return 1;
      }
      for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){
        if( tnum==pIndex->tnum ){
          return 1;
        }
      }
    }

    if( pOp->opcode==163 && pOp->p4.pVtab==pVTab ){
      ((void)0);
      ((void)0);
      return 1;
    }

  }
  return 0;
}
# 117628 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int autoIncBegin(
  Parse *pParse,
  int iDb,
  Table *pTab
){
  int memId = 0;
  ((void)0);
  if( (pTab->tabFlags & 0x0008)!=0
   && (pParse->db->mDbFlags & 0x0004)==0
  ){
    Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
    AutoincInfo *pInfo;
    Table *pSeqTab = pParse->db->aDb[iDb].pSchema->pSeqTab;




    if( pSeqTab==0
     || !(((pSeqTab)->tabFlags & 0x0020)==0)
     || ((pSeqTab)->nModuleArg)
     || pSeqTab->nCol!=2
    ){
      pParse->nErr++;
      pParse->rc = (11 | (2<<8));
      return 0;
    }

    pInfo = pToplevel->pAinc;
    while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; }
    if( pInfo==0 ){
      pInfo = sqlite3DbMallocRawNN(pParse->db, sizeof(*pInfo));
      if( pInfo==0 ) return 0;
      pInfo->pNext = pToplevel->pAinc;
      pToplevel->pAinc = pInfo;
      pInfo->pTab = pTab;
      pInfo->iDb = iDb;
      pToplevel->nMem++;
      pInfo->regCtr = ++pToplevel->nMem;
      pToplevel->nMem +=2;
    }
    memId = pInfo->regCtr;
  }
  return memId;
}





static void sqlite3AutoincrementBegin(Parse *pParse){
  AutoincInfo *p;
  sqlite3 *db = pParse->db;
  Db *pDb;
  int memId;
  Vdbe *v = pParse->pVdbe;



  ((void)0);
  ((void)0);

  ((void)0);
  for(p = pParse->pAinc; p; p = p->pNext){
    static const int iLn = 0;
    static const VdbeOpList autoInc[] = {
               {73, 0, 0, 0},
               {36, 0, 10, 0},
               {90, 0, 0, 0},
               {52, 0, 9, 0},
               {128, 0, 0, 0},
               {90, 0, 1, 0},
               {83, 0, 0, 0},
               {78, 0, 0, 0},
               {11, 0, 11, 0},
               {5, 0, 2, 0},
               {70, 0, 0, 0},
               {117, 0, 0, 0}
    };
    VdbeOp *aOp;
    pDb = &db->aDb[p->iDb];
    memId = p->regCtr;
    ((void)0);
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 97);
    sqlite3VdbeLoadString(v, memId-1, p->pTab->zName);
    aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(autoInc)/sizeof(autoInc[0]))), autoInc, iLn);
    if( aOp==0 ) break;
    aOp[0].p2 = memId;
    aOp[0].p3 = memId+2;
    aOp[2].p3 = memId;
    aOp[3].p1 = memId-1;
    aOp[3].p3 = memId;
    aOp[3].p5 = 0x10;
    aOp[4].p2 = memId+1;
    aOp[5].p3 = memId;
    aOp[6].p1 = memId;
    aOp[7].p2 = memId+2;
    aOp[7].p1 = memId;
    aOp[10].p2 = memId;
    if( pParse->nTab==0 ) pParse->nTab = 1;
  }
}
# 117738 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void autoIncStep(Parse *pParse, int memId, int regRowid){
  if( memId>0 ){
    sqlite3VdbeAddOp2(pParse->pVdbe, 151, memId, regRowid);
  }
}
# 117751 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) void autoIncrementEnd(Parse *pParse){
  AutoincInfo *p;
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;

  ((void)0);
  for(p = pParse->pAinc; p; p = p->pNext){
    static const int iLn = 0;
    static const VdbeOpList autoIncEnd[] = {
              {51, 0, 2, 0},
              {121, 0, 0, 0},
              {92, 0, 2, 0},
              {122, 0, 0, 0},
              {117, 0, 0, 0}
    };
    VdbeOp *aOp;
    Db *pDb = &db->aDb[p->iDb];
    int iRec;
    int memId = p->regCtr;

    iRec = sqlite3GetTempReg(pParse);
    ((void)0);
    sqlite3VdbeAddOp3(v, 55, memId+2, sqlite3VdbeCurrentAddr(v)+7, memId);
    ;
    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, 98);
    aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(autoIncEnd)/sizeof(autoIncEnd[0]))), autoIncEnd, iLn);
    if( aOp==0 ) break;
    aOp[0].p1 = memId+1;
    aOp[1].p2 = memId+1;
    aOp[2].p1 = memId-1;
    aOp[2].p3 = iRec;
    aOp[3].p2 = iRec;
    aOp[3].p3 = memId+1;
    aOp[3].p5 = 0x08;
    sqlite3ReleaseTempReg(pParse, iRec);
  }
}
static void sqlite3AutoincrementEnd(Parse *pParse){
  if( pParse->pAinc ) autoIncrementEnd(pParse);
}
# 117802 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int xferOptimization(
  Parse *pParse,
  Table *pDest,
  Select *pSelect,
  int onError,
  int iDbDest
);
# 117907 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Insert(
  Parse *pParse,
  SrcList *pTabList,
  Select *pSelect,
  IdList *pColumn,
  int onError,
  Upsert *pUpsert
){
  sqlite3 *db;
  Table *pTab;
  int i, j;
  Vdbe *v;
  Index *pIdx;
  int nColumn;
  int nHidden = 0;
  int iDataCur = 0;
  int iIdxCur = 0;
  int ipkColumn = -1;
  int endOfLoop;
  int srcTab = 0;
  int addrInsTop = 0;
  int addrCont = 0;
  SelectDest dest;
  int iDb;
  u8 useTempTable = 0;
  u8 appendFlag = 0;
  u8 withoutRowid;
  u8 bIdListInOrder;
  ExprList *pList = 0;


  int regFromSelect = 0;
  int regAutoinc = 0;
  int regRowCount = 0;
  int regIns;
  int regRowid;
  int regData;
  int *aRegIdx = 0;


  int isView;
  Trigger *pTrigger;
  int tmask;


  db = pParse->db;
  if( pParse->nErr || db->mallocFailed ){
    goto insert_cleanup;
  }
  dest.iSDParm = 0;





  if( pSelect && (pSelect->selFlags & 0x00200)!=0 && pSelect->pPrior==0 ){
    pList = pSelect->pEList;
    pSelect->pEList = 0;
    sqlite3SelectDelete(db, pSelect);
    pSelect = 0;
  }



  ((void)0);
  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ){
    goto insert_cleanup;
  }
  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  ((void)0);
  if( sqlite3AuthCheck(pParse, 18, pTab->zName, 0,
                       db->aDb[iDb].zDbSName) ){
    goto insert_cleanup;
  }
  withoutRowid = !(((pTab)->tabFlags & 0x0020)==0);





  pTrigger = sqlite3TriggersExist(pParse, pTab, 123, 0, &tmask);
  isView = pTab->pSelect!=0;
# 117999 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);




  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto insert_cleanup;
  }



  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){
    goto insert_cleanup;
  }



  v = sqlite3GetVdbe(pParse);
  if( v==0 ) goto insert_cleanup;
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);
# 118031 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pColumn==0 && xferOptimization(pParse, pTab, pSelect, onError, iDb) ){
    ((void)0);
    ((void)0);
    goto insert_end;
  }





  regAutoinc = autoIncBegin(pParse, iDb, pTab);




  regRowid = regIns = pParse->nMem+1;
  pParse->nMem += pTab->nCol + 1;
  if( ((pTab)->nModuleArg) ){
    regRowid++;
    pParse->nMem++;
  }
  regData = regRowid+1;
# 118065 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  bIdListInOrder = (pTab->tabFlags & 0x0080)==0;
  if( pColumn ){
    for(i=0; i<pColumn->nId; i++){
      pColumn->a[i].idx = -1;
    }
    for(i=0; i<pColumn->nId; i++){
      for(j=0; j<pTab->nCol; j++){
        if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zName)==0 ){
          pColumn->a[i].idx = j;
          if( i!=j ) bIdListInOrder = 0;
          if( j==pTab->iPKey ){
            ipkColumn = i; ((void)0);
          }
          break;
        }
      }
      if( j>=pTab->nCol ){
        if( sqlite3IsRowid(pColumn->a[i].zName) && !withoutRowid ){
          ipkColumn = i;
          bIdListInOrder = 0;
        }else{
          sqlite3ErrorMsg(pParse, "table %S has no column named %s",
              pTabList, 0, pColumn->a[i].zName);
          pParse->checkSchema = 1;
          goto insert_cleanup;
        }
      }
    }
  }






  if( pSelect ){


    int regYield;
    int addrTop;
    int rc;

    regYield = ++pParse->nMem;
    addrTop = sqlite3VdbeCurrentAddr(v) + 1;
    sqlite3VdbeAddOp3(v, 13, regYield, 0, addrTop);
    sqlite3SelectDestInit(&dest, 13, regYield);
    dest.iSdst = bIdListInOrder ? regData : 0;
    dest.nSdst = pTab->nCol;
    rc = sqlite3Select(pParse, pSelect, &dest);
    regFromSelect = dest.iSdst;
    if( rc || db->mallocFailed || pParse->nErr ) goto insert_cleanup;
    sqlite3VdbeEndCoroutine(v, regYield);
    sqlite3VdbeJumpHere(v, addrTop - 1);
    ((void)0);
    nColumn = pSelect->pEList->nExpr;
# 118130 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pTrigger || readsTable(pParse, iDb, pTab) ){
      useTempTable = 1;
    }

    if( useTempTable ){
# 118145 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      int regRec;
      int regTempRowid;
      int addrL;

      srcTab = pParse->nTab++;
      regRec = sqlite3GetTempReg(pParse);
      regTempRowid = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 112, srcTab, nColumn);
      addrL = sqlite3VdbeAddOp1(v, 14, dest.iSDParm); ;
      sqlite3VdbeAddOp3(v, 92, regFromSelect, nColumn, regRec);
      sqlite3VdbeAddOp2(v, 121, srcTab, regTempRowid);
      sqlite3VdbeAddOp3(v, 122, srcTab, regRec, regTempRowid);
      sqlite3VdbeGoto(v, addrL);
      sqlite3VdbeJumpHere(v, addrL);
      sqlite3ReleaseTempReg(pParse, regRec);
      sqlite3ReleaseTempReg(pParse, regTempRowid);
    }
  }else{



    NameContext sNC;
    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    srcTab = -1;
    ((void)0);
    if( pList ){
      nColumn = pList->nExpr;
      if( sqlite3ResolveExprListNames(&sNC, pList) ){
        goto insert_cleanup;
      }
    }else{
      nColumn = 0;
    }
  }





  if( pColumn==0 && nColumn>0 ){
    ipkColumn = pTab->iPKey;
  }




  for(i=0; i<pTab->nCol; i++){
    nHidden += ((((&pTab->aCol[i])->colFlags & 0x0002)!=0) ? 1 : 0);
  }
  if( pColumn==0 && nColumn && nColumn!=(pTab->nCol-nHidden) ){
    sqlite3ErrorMsg(pParse,
       "table %S has %d columns but %d values were supplied",
       pTabList, 0, pTab->nCol-nHidden, nColumn);
    goto insert_cleanup;
  }
  if( pColumn!=0 && nColumn!=pColumn->nId ){
    sqlite3ErrorMsg(pParse, "%d values for %d columns", nColumn, pColumn->nId);
    goto insert_cleanup;
  }



  if( (db->flags & 0x00000080)!=0
   && !pParse->nested
   && !pParse->pTriggerTab
  ){
    regRowCount = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 70, 0, regRowCount);
  }


  if( !isView ){
    int nIdx;
    nIdx = sqlite3OpenTableAndIndices(pParse, pTab, 98, 0, -1, 0,
                                      &iDataCur, &iIdxCur);
    aRegIdx = sqlite3DbMallocRawNN(db, sizeof(int)*(nIdx+2));
    if( aRegIdx==0 ){
      goto insert_cleanup;
    }
    for(i=0, pIdx=pTab->pIndex; i<nIdx; pIdx=pIdx->pNext, i++){
      ((void)0);
      aRegIdx[i] = ++pParse->nMem;
      pParse->nMem += pIdx->nColumn;
    }
    aRegIdx[i] = ++pParse->nMem;
  }

  if( pUpsert ){
    if( ((pTab)->nModuleArg) ){
      sqlite3ErrorMsg(pParse, "UPSERT not implemented for virtual table \"%s\"",
              pTab->zName);
      goto insert_cleanup;
    }
    if( sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget) ){
      goto insert_cleanup;
    }
    pTabList->a[0].iCursor = iDataCur;
    pUpsert->pUpsertSrc = pTabList;
    pUpsert->regData = regData;
    pUpsert->iDataCur = iDataCur;
    pUpsert->iIdxCur = iIdxCur;
    if( pUpsert->pUpsertTarget ){
      sqlite3UpsertAnalyzeTarget(pParse, pTabList, pUpsert);
    }
  }




  if( useTempTable ){
# 118265 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    addrInsTop = sqlite3VdbeAddOp1(v, 36, srcTab); ;
    addrCont = sqlite3VdbeCurrentAddr(v);
  }else if( pSelect ){
# 118276 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    addrInsTop = addrCont = sqlite3VdbeAddOp1(v, 14, dest.iSDParm);
    ;
  }



  endOfLoop = sqlite3VdbeMakeLabel(pParse);
  if( tmask & 1 ){
    int regCols = sqlite3GetTempRange(pParse, pTab->nCol+1);







    if( ipkColumn<0 ){
      sqlite3VdbeAddOp2(v, 70, -1, regCols);
    }else{
      int addr1;
      ((void)0);
      if( useTempTable ){
        sqlite3VdbeAddOp3(v, 90, srcTab, ipkColumn, regCols);
      }else{
        ((void)0);
        sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regCols);
      }
      addr1 = sqlite3VdbeAddOp1(v, 51, regCols); ;
      sqlite3VdbeAddOp2(v, 70, -1, regCols);
      sqlite3VdbeJumpHere(v, addr1);
      sqlite3VdbeAddOp1(v, 15, regCols); ;
    }




    ((void)0);



    for(i=j=0; i<pTab->nCol; i++){
      if( pColumn ){
        for(j=0; j<pColumn->nId; j++){
          if( pColumn->a[j].idx==i ) break;
        }
      }
      if( (!useTempTable && !pList) || (pColumn && j>=pColumn->nId)
            || (pColumn==0 && 0) ){
        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regCols+i+1);
      }else if( useTempTable ){
        sqlite3VdbeAddOp3(v, 90, srcTab, j, regCols+i+1);
      }else{
        ((void)0);
        sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, regCols+i+1);
      }
      if( pColumn==0 && !0 ) j++;
    }






    if( !isView ){
      sqlite3TableAffinity(v, pTab, regCols+1);
    }


    sqlite3CodeRowTrigger(pParse, pTrigger, 123, 0, 1,
        pTab, regCols-pTab->nCol-1, onError, endOfLoop);

    sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol+1);
  }




  if( !isView ){
    if( ((pTab)->nModuleArg) ){

      sqlite3VdbeAddOp2(v, 73, 0, regIns);
    }
    if( ipkColumn>=0 ){
      if( useTempTable ){
        sqlite3VdbeAddOp3(v, 90, srcTab, ipkColumn, regRowid);
      }else if( pSelect ){
        sqlite3VdbeAddOp2(v, 78, regFromSelect+ipkColumn, regRowid);
      }else{
        Expr *pIpk = pList->a[ipkColumn].pExpr;
        if( pIpk->op==117 && !((pTab)->nModuleArg) ){
          sqlite3VdbeAddOp3(v, 121, iDataCur, regRowid, regAutoinc);
          appendFlag = 1;
        }else{
          sqlite3ExprCode(pParse, pList->a[ipkColumn].pExpr, regRowid);
        }
      }



      if( !appendFlag ){
        int addr1;
        if( !((pTab)->nModuleArg) ){
          addr1 = sqlite3VdbeAddOp1(v, 51, regRowid); ;
          sqlite3VdbeAddOp3(v, 121, iDataCur, regRowid, regAutoinc);
          sqlite3VdbeJumpHere(v, addr1);
        }else{
          addr1 = sqlite3VdbeCurrentAddr(v);
          sqlite3VdbeAddOp2(v, 50, regRowid, addr1+2); ;
        }
        sqlite3VdbeAddOp1(v, 15, regRowid); ;
      }
    }else if( ((pTab)->nModuleArg) || withoutRowid ){
      sqlite3VdbeAddOp2(v, 73, 0, regRowid);
    }else{
      sqlite3VdbeAddOp3(v, 121, iDataCur, regRowid, regAutoinc);
      appendFlag = 1;
    }
    autoIncStep(pParse, regAutoinc, regRowid);




    nHidden = 0;
    for(i=0; i<pTab->nCol; i++){
      int iRegStore = regRowid+1+i;
      if( i==pTab->iPKey ){





        sqlite3VdbeAddOp1(v, 74, iRegStore);
        continue;
      }
      if( pColumn==0 ){
        if( (((&pTab->aCol[i])->colFlags & 0x0002)!=0) ){
          j = -1;
          nHidden++;
        }else{
          j = i - nHidden;
        }
      }else{
        for(j=0; j<pColumn->nId; j++){
          if( pColumn->a[j].idx==i ) break;
        }
      }
      if( j<0 || nColumn==0 || (pColumn && j>=pColumn->nId) ){
        sqlite3ExprCodeFactorable(pParse, pTab->aCol[i].pDflt, iRegStore);
      }else if( useTempTable ){
        sqlite3VdbeAddOp3(v, 90, srcTab, j, iRegStore);
      }else if( pSelect ){
        if( regFromSelect!=regData ){
          sqlite3VdbeAddOp2(v, 79, regFromSelect+j, iRegStore);
        }
      }else{
        sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);
      }
    }





    if( ((pTab)->nModuleArg) ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      sqlite3VtabMakeWritable(pParse, pTab);
      sqlite3VdbeAddOp4(v, 10, 1, pTab->nCol+2, regIns, pVTab, (-12));
      sqlite3VdbeChangeP5(v, onError==11 ? 2 : onError);
      sqlite3MayAbort(pParse);
    }else

    {
      int isReplace;
      int bUseSeek;
      sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
          regIns, 0, ipkColumn>=0, onError, endOfLoop, &isReplace, 0, pUpsert
      );
      sqlite3FkCheck(pParse, pTab, 0, regIns, 0, 0);
# 118463 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      bUseSeek = (isReplace==0 || (pTrigger==0 &&
          ((db->flags & 0x00004000)==0 || sqlite3FkReferences(pTab)==0)
      ));
      sqlite3CompleteInsertion(pParse, pTab, iDataCur, iIdxCur,
          regIns, aRegIdx, 0, appendFlag, bUseSeek
      );
    }
  }



  if( regRowCount ){
    sqlite3VdbeAddOp2(v, 83, regRowCount, 1);
  }

  if( pTrigger ){

    sqlite3CodeRowTrigger(pParse, pTrigger, 123, 0, 2,
        pTab, regData-2-pTab->nCol, onError, endOfLoop);
  }




  sqlite3VdbeResolveLabel(v, endOfLoop);
  if( useTempTable ){
    sqlite3VdbeAddOp2(v, 5, srcTab, addrCont); ;
    sqlite3VdbeJumpHere(v, addrInsTop);
    sqlite3VdbeAddOp1(v, 117, srcTab);
  }else if( pSelect ){
    sqlite3VdbeGoto(v, addrCont);
    sqlite3VdbeJumpHere(v, addrInsTop);
  }

insert_end:




  if( pParse->nested==0 && pParse->pTriggerTab==0 ){
    sqlite3AutoincrementEnd(pParse);
  }






  if( regRowCount ){
    sqlite3VdbeAddOp2(v, 81, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows inserted", ((sqlite3_destructor_type)0));
  }

insert_cleanup:
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pList);
  sqlite3UpsertDelete(db, pUpsert);
  sqlite3SelectDelete(db, pSelect);
  sqlite3IdListDelete(db, pColumn);
  sqlite3DbFree(db, aRegIdx);
}
# 118543 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define CKCNSTRNT_COLUMN 0x01
#define CKCNSTRNT_ROWID 0x02






static int checkConstraintExprNode(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==162 ){
    ((void)0);
    if( pExpr->iColumn>=0 ){
      if( pWalker->u.aiCol[pExpr->iColumn]>=0 ){
        pWalker->eCode |= 0x01;
      }
    }else{
      pWalker->eCode |= 0x02;
    }
  }
  return 0;
}
# 118580 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprReferencesUpdatedColumn(
  Expr *pExpr,
  int *aiChng,
  int chngRowid
){
  Walker w;
  memset(&w, 0, sizeof(w));
  w.eCode = 0;
  w.xExprCallback = checkConstraintExprNode;
  w.u.aiCol = aiChng;
  sqlite3WalkExpr(&w, pExpr);
  if( !chngRowid ){
    ;
    w.eCode &= ~0x02;
  }
  ;
  ;
  ;
  ;
  return w.eCode!=0;
}
# 118693 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3GenerateConstraintChecks(
  Parse *pParse,
  Table *pTab,
  int *aRegIdx,
  int iDataCur,
  int iIdxCur,
  int regNewData,
  int regOldData,
  u8 pkChng,
  u8 overrideError,
  int ignoreDest,
  int *pbMayReplace,
  int *aiChng,
  Upsert *pUpsert
){
  Vdbe *v;
  Index *pIdx;
  Index *pPk = 0;
  sqlite3 *db;
  int i;
  int ix;
  int nCol;
  int onError;
  int addr1;
  int seenReplace = 0;
  int nPkField;
  Index *pUpIdx = 0;
  u8 isUpdate;
  u8 bAffinityDone = 0;
  int upsertBypass = 0;
  int upsertJump = 0;
  int ipkTop = 0;
  int ipkBottom = 0;

  isUpdate = regOldData!=0;
  db = pParse->db;
  v = sqlite3GetVdbe(pParse);
  ((void)0);
  ((void)0);
  nCol = pTab->nCol;





  if( (((pTab)->tabFlags & 0x0020)==0) ){
    pPk = 0;
    nPkField = 1;
  }else{
    pPk = sqlite3PrimaryKeyIndex(pTab);
    nPkField = pPk->nKeyCol;
  }


 
                                                                        ;



  for(i=0; i<nCol; i++){
    if( i==pTab->iPKey ){
      continue;
    }
    if( aiChng && aiChng[i]<0 ){

      continue;
    }
    onError = pTab->aCol[i].notNull;
    if( onError==0 ) continue;
    if( overrideError!=11 ){
      onError = overrideError;
    }else if( onError==11 ){
      onError = 2;
    }
    if( onError==5 && pTab->aCol[i].pDflt==0 ){
      onError = 2;
    }
    ((void)0)
                                                      ;
    addr1 = 0;
    switch( onError ){
      case 5: {
        ((void)0);
        addr1 = sqlite3VdbeMakeLabel(pParse);
        sqlite3VdbeAddOp2(v, 51, regNewData+1+i, addr1);
          ;
        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regNewData+1+i);
        sqlite3VdbeAddOp2(v, 51, regNewData+1+i, addr1);
          ;
        onError = 2;


      }
      case 2:
        sqlite3MayAbort(pParse);

      case 1:
      case 3: {
        char *zMsg = sqlite3MPrintf(db, "%s.%s", pTab->zName,
                                    pTab->aCol[i].zName);
        sqlite3VdbeAddOp3(v, 68, (19 | (5<<8)), onError,
                          regNewData+1+i);
        sqlite3VdbeAppendP4(v, zMsg, (-7));
        sqlite3VdbeChangeP5(v, 1);
        ;
        if( addr1 ) sqlite3VdbeResolveLabel(v, addr1);
        break;
      }
      default: {
        ((void)0);
        sqlite3VdbeAddOp2(v, 50, regNewData+1+i, ignoreDest);
        ;
        break;
      }
    }
  }




  if( pTab->pCheck && (db->flags & 0x00000200)==0 ){
    ExprList *pCheck = pTab->pCheck;
    pParse->iSelfTab = -(regNewData+1);
    onError = overrideError!=11 ? overrideError : 2;
    for(i=0; i<pCheck->nExpr; i++){
      int allOk;
      Expr *pExpr = pCheck->a[i].pExpr;
      if( aiChng
       && !sqlite3ExprReferencesUpdatedColumn(pExpr, aiChng, pkChng)
      ){


        continue;
      }
      allOk = sqlite3VdbeMakeLabel(pParse);
      ;
      sqlite3ExprIfTrue(pParse, pExpr, allOk, 0x10);
      if( onError==4 ){
        sqlite3VdbeGoto(v, ignoreDest);
      }else{
        char *zName = pCheck->a[i].zName;
        if( zName==0 ) zName = pTab->zName;
        if( onError==5 ) onError = 2;
        sqlite3HaltConstraint(pParse, (19 | (1<<8)),
                              onError, zName, 0,
                              3);
      }
      sqlite3VdbeResolveLabel(v, allOk);
    }
    pParse->iSelfTab = 0;
  }
# 118875 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pUpsert ){
    if( pUpsert->pUpsertTarget==0 ){


      ((void)0);
      overrideError = 4;
      pUpsert = 0;
    }else if( (pUpIdx = pUpsert->pUpsertIdx)!=0 ){


      upsertJump = sqlite3VdbeAddOp0(v, 11);
      ;
    }
  }




  if( pkChng && pPk==0 ){
    int addrRowidOk = sqlite3VdbeMakeLabel(pParse);


    onError = pTab->keyConf;
    if( overrideError!=11 ){
      onError = overrideError;
    }else if( onError==11 ){
      onError = 2;
    }


    if( pUpsert && pUpsert->pUpsertIdx==0 ){
      if( pUpsert->pUpsertSet==0 ){
        onError = 4;
      }else{
        onError = 6;
      }
    }






    if( onError==5
     && onError!=overrideError
     && pTab->pIndex
    ){
      ipkTop = sqlite3VdbeAddOp0(v, 11)+1;
      ;
    }

    if( isUpdate ){



      sqlite3VdbeAddOp3(v, 53, regNewData, addrRowidOk, regOldData);
      sqlite3VdbeChangeP5(v, 0x90);
      ;
    }



    ;
    ;
    sqlite3VdbeAddOp3(v, 31, iDataCur, addrRowidOk, regNewData);
    ;

    switch( onError ){
      default: {
        onError = 2;

      }
      case 1:
      case 2:
      case 3: {
        ;
        ;
        ;
        sqlite3RowidConstraint(pParse, onError, pTab);
        break;
      }
      case 5: {
# 118979 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        Trigger *pTrigger = 0;
        if( db->flags&0x00002000 ){
          pTrigger = sqlite3TriggersExist(pParse, pTab, 124, 0, 0);
        }
        if( pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0) ){
          sqlite3MultiWrite(pParse);
          sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
                                   regNewData, 1, 0, 5, 1, -1);
        }else{
# 118997 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          if( pTab->pIndex ){
            sqlite3MultiWrite(pParse);
            sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur,0,-1);
          }
        }
        seenReplace = 1;
        break;
      }

      case 6: {
        sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, 0, iDataCur);

      }

      case 4: {
        ;
        sqlite3VdbeGoto(v, ignoreDest);
        break;
      }
    }
    sqlite3VdbeResolveLabel(v, addrRowidOk);
    if( ipkTop ){
      ipkBottom = sqlite3VdbeAddOp0(v, 11);
      sqlite3VdbeJumpHere(v, ipkTop-1);
    }
  }
# 119031 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(ix=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, ix++){
    int regIdx;
    int regR;
    int iThisCur;
    int addrUniqueOk;

    if( aRegIdx[ix]==0 ) continue;
    if( pUpIdx==pIdx ){
      addrUniqueOk = upsertJump+1;
      upsertBypass = sqlite3VdbeGoto(v, 0);
      ;
      sqlite3VdbeJumpHere(v, upsertJump);
    }else{
      addrUniqueOk = sqlite3VdbeMakeLabel(pParse);
    }
    if( bAffinityDone==0 && (pUpIdx==0 || pUpIdx==pIdx) ){
      sqlite3TableAffinity(v, pTab, regNewData+1);
      bAffinityDone = 1;
    }
    ;
    iThisCur = iIdxCur+ix;



    if( pIdx->pPartIdxWhere ){
      sqlite3VdbeAddOp2(v, 73, 0, aRegIdx[ix]);
      pParse->iSelfTab = -(regNewData+1);
      sqlite3ExprIfFalseDup(pParse, pIdx->pPartIdxWhere, addrUniqueOk,
                            0x10);
      pParse->iSelfTab = 0;
    }




    regIdx = aRegIdx[ix]+1;
    for(i=0; i<pIdx->nColumn; i++){
      int iField = pIdx->aiColumn[i];
      int x;
      if( iField==(-2) ){
        pParse->iSelfTab = -(regNewData+1);
        sqlite3ExprCodeCopy(pParse, pIdx->aColExpr->a[i].pExpr, regIdx+i);
        pParse->iSelfTab = 0;
        ;
      }else{
        if( iField==(-1) || iField==pTab->iPKey ){
          x = regNewData;
        }else{
          x = iField + regNewData + 1;
        }
        sqlite3VdbeAddOp2(v, iField<0 ? 80 : 79, x, regIdx+i);
        ;
      }
    }
    sqlite3VdbeAddOp3(v, 92, regIdx, pIdx->nColumn, aRegIdx[ix]);
    ;
# 119097 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( isUpdate && pPk==pIdx && pkChng==0 ){
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }


    onError = pIdx->onError;
    if( onError==0 ){
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }
    if( overrideError!=11 ){
      onError = overrideError;
    }else if( onError==11 ){
      onError = 2;
    }


    if( pUpIdx==pIdx ){
      if( pUpsert->pUpsertSet==0 ){
        onError = 4;
      }else{
        onError = 6;
      }
    }
# 119134 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (ix==0 && pIdx->pNext==0)
     && pPk==pIdx
     && onError==5
     && ( 0==(db->flags&0x00002000) ||
          0==sqlite3TriggersExist(pParse, pTab, 124, 0, 0))
     && ( 0==(db->flags&0x00004000) ||
         (0==pTab->pFKey && 0==sqlite3FkReferences(pTab)))
    ){
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
      continue;
    }



    ;
    sqlite3VdbeAddOp4Int(v, 27, iThisCur, addrUniqueOk,
                         regIdx, pIdx->nKeyCol); ;


    regR = (pIdx==pPk) ? regIdx : sqlite3GetTempRange(pParse, nPkField);
    if( isUpdate || onError==5 ){
      if( (((pTab)->tabFlags & 0x0020)==0) ){
        sqlite3VdbeAddOp2(v, 135, iThisCur, regR);


        if( isUpdate ){
          sqlite3VdbeAddOp3(v, 53, regR, addrUniqueOk, regOldData);
          sqlite3VdbeChangeP5(v, 0x90);
          ;
        }
      }else{
        int x;


        if( pIdx!=pPk ){
          for(i=0; i<pPk->nKeyCol; i++){
            ((void)0);
            x = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);
            sqlite3VdbeAddOp3(v, 90, iThisCur, x, regR+i);
           
                                                             ;
          }
        }
        if( isUpdate ){







          int addrJump = sqlite3VdbeCurrentAddr(v)+pPk->nKeyCol;
          int op = 52;
          int regCmp = (((pIdx)->idxType==2) ? regIdx : regR);

          for(i=0; i<pPk->nKeyCol; i++){
            char *p4 = (char*)sqlite3LocateCollSeq(pParse, pPk->azColl[i]);
            x = pPk->aiColumn[i];
            ((void)0);
            if( i==(pPk->nKeyCol-1) ){
              addrJump = addrUniqueOk;
              op = 53;
            }
            sqlite3VdbeAddOp4(v, op,
                regOldData+1+x, addrJump, regCmp+i, p4, (-2)
            );
            sqlite3VdbeChangeP5(v, 0x90);
            ;
            ;
          }
        }
      }
    }


    ((void)0)
                                                                            ;
    switch( onError ){
      case 1:
      case 2:
      case 3: {
        ;
        ;
        ;
        sqlite3UniqueConstraint(pParse, onError, pIdx);
        break;
      }

      case 6: {
        sqlite3UpsertDoUpdate(pParse, pUpsert, pTab, pIdx, iIdxCur+ix);

      }

      case 4: {
        ;
        sqlite3VdbeGoto(v, ignoreDest);
        break;
      }
      default: {
        Trigger *pTrigger = 0;
        ((void)0);
        if( db->flags&0x00002000 ){
          pTrigger = sqlite3TriggersExist(pParse, pTab, 124, 0, 0);
        }
        if( pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0) ){
          sqlite3MultiWrite(pParse);
        }
        sqlite3GenerateRowDelete(pParse, pTab, pTrigger, iDataCur, iIdxCur,
            regR, nPkField, 0, 5,
            (pIdx==pPk ? 1 : 0), iThisCur);
        seenReplace = 1;
        break;
      }
    }
    if( pUpIdx==pIdx ){
      sqlite3VdbeGoto(v, upsertJump+1);
      sqlite3VdbeJumpHere(v, upsertBypass);
    }else{
      sqlite3VdbeResolveLabel(v, addrUniqueOk);
    }
    if( regR!=regIdx ) sqlite3ReleaseTempRange(pParse, regR, nPkField);
  }


  if( ipkTop ){
    sqlite3VdbeGoto(v, ipkTop);
    ;
    sqlite3VdbeJumpHere(v, ipkBottom);
  }


  if( (((pTab)->tabFlags & 0x0020)==0) ){
    int regRec = aRegIdx[ix];
    sqlite3VdbeAddOp3(v, 92, regNewData+1, pTab->nCol, regRec);
    ;
    if( !bAffinityDone ){
      sqlite3TableAffinity(v, pTab, 0);
    }
  }

  *pbMayReplace = seenReplace;
  ;
}
# 119309 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3CompleteInsertion(
  Parse *pParse,
  Table *pTab,
  int iDataCur,
  int iIdxCur,
  int regNewData,
  int *aRegIdx,
  int update_flags,
  int appendBias,
  int useSeekResult
){
  Vdbe *v;
  Index *pIdx;
  u8 pik_flags;
  int i;

  ((void)0)


   ;

  v = sqlite3GetVdbe(pParse);
  ((void)0);
  ((void)0);
  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){
    if( aRegIdx[i]==0 ) continue;
    if( pIdx->pPartIdxWhere ){
      sqlite3VdbeAddOp2(v, 50, aRegIdx[i], sqlite3VdbeCurrentAddr(v)+2);
      ;
    }
    pik_flags = (useSeekResult ? 0x10 : 0);
    if( ((pIdx)->idxType==2) && !(((pTab)->tabFlags & 0x0020)==0) ){
      ((void)0);
      pik_flags |= 0x01;
      pik_flags |= (update_flags & 0x02);
# 119355 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    }
    sqlite3VdbeAddOp4Int(v, 132, iIdxCur+i, aRegIdx[i],
                         aRegIdx[i]+1,
                         pIdx->uniqNotNull ? pIdx->nKeyCol: pIdx->nColumn);
    sqlite3VdbeChangeP5(v, pik_flags);
  }
  if( !(((pTab)->tabFlags & 0x0020)==0) ) return;
  if( pParse->nested ){
    pik_flags = 0;
  }else{
    pik_flags = 0x01;
    pik_flags |= (update_flags?update_flags:0x20);
  }
  if( appendBias ){
    pik_flags |= 0x08;
  }
  if( useSeekResult ){
    pik_flags |= 0x10;
  }
  sqlite3VdbeAddOp3(v, 122, iDataCur, aRegIdx[i], regNewData);
  if( !pParse->nested ){
    sqlite3VdbeAppendP4(v, pTab, (-6));
  }
  sqlite3VdbeChangeP5(v, pik_flags);
}
# 119402 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3OpenTableAndIndices(
  Parse *pParse,
  Table *pTab,
  int op,
  u8 p5,
  int iBase,
  u8 *aToOpen,
  int *piDataCur,
  int *piIdxCur
){
  int i;
  int iDb;
  int iDataCur;
  Index *pIdx;
  Vdbe *v;

  ((void)0);
  ((void)0);
  if( ((pTab)->nModuleArg) ){



    return 0;
  }
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
  v = sqlite3GetVdbe(pParse);
  ((void)0);
  if( iBase<0 ) iBase = pParse->nTab;
  iDataCur = iBase++;
  if( piDataCur ) *piDataCur = iDataCur;
  if( (((pTab)->tabFlags & 0x0020)==0) && (aToOpen==0 || aToOpen[0]) ){
    sqlite3OpenTable(pParse, iDataCur, iDb, pTab, op);
  }else{
    sqlite3TableLock(pParse, iDb, pTab->tnum, op==98, pTab->zName);
  }
  if( piIdxCur ) *piIdxCur = iBase;
  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){
    int iIdxCur = iBase++;
    ((void)0);
    if( ((pIdx)->idxType==2) && !(((pTab)->tabFlags & 0x0020)==0) ){
      if( piDataCur ) *piDataCur = iIdxCur;
      p5 = 0;
    }
    if( aToOpen==0 || aToOpen[i+1] ){
      sqlite3VdbeAddOp3(v, op, iIdxCur, pIdx->tnum, iDb);
      sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
      sqlite3VdbeChangeP5(v, p5);
      ;
    }
  }
  if( iBase>pParse->nTab ) pParse->nTab = iBase;
  return i;
}
# 119480 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int xferCompatibleIndex(Index *pDest, Index *pSrc){
  int i;
  ((void)0);
  ((void)0);
  if( pDest->nKeyCol!=pSrc->nKeyCol ){
    return 0;
  }
  if( pDest->onError!=pSrc->onError ){
    return 0;
  }
  for(i=0; i<pSrc->nKeyCol; i++){
    if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){
      return 0;
    }
    if( pSrc->aiColumn[i]==(-2) ){
      ((void)0);
      if( sqlite3ExprCompare(0, pSrc->aColExpr->a[i].pExpr,
                             pDest->aColExpr->a[i].pExpr, -1)!=0 ){
        return 0;
      }
    }
    if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){
      return 0;
    }
    if( sqlite3_stricmp(pSrc->azColl[i],pDest->azColl[i])!=0 ){
      return 0;
    }
  }
  if( sqlite3ExprCompare(0, pSrc->pPartIdxWhere, pDest->pPartIdxWhere, -1) ){
    return 0;
  }


  return 1;
}
# 119541 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int xferOptimization(
  Parse *pParse,
  Table *pDest,
  Select *pSelect,
  int onError,
  int iDbDest
){
  sqlite3 *db = pParse->db;
  ExprList *pEList;
  Table *pSrc;
  Index *pSrcIdx, *pDestIdx;
  struct SrcList_item *pItem;
  int i;
  int iDbSrc;
  int iSrc, iDest;
  int addr1, addr2;
  int emptyDestTest = 0;
  int emptySrcTest = 0;
  Vdbe *v;
  int regAutoinc;
  int destHasUniqueIdx = 0;
  int regData, regRowid;

  if( pSelect==0 ){
    return 0;
  }
  if( pParse->pWith || pSelect->pWith ){



    return 0;
  }
  if( sqlite3TriggerList(pParse, pDest) ){
    return 0;
  }

  if( ((pDest)->nModuleArg) ){
    return 0;
  }

  if( onError==11 ){
    if( pDest->iPKey>=0 ) onError = pDest->keyConf;
    if( onError==11 ) onError = 2;
  }
  ((void)0);
  if( pSelect->pSrc->nSrc!=1 ){
    return 0;
  }
  if( pSelect->pSrc->a[0].pSelect ){
    return 0;
  }
  if( pSelect->pWhere ){
    return 0;
  }
  if( pSelect->pOrderBy ){
    return 0;
  }


  if( pSelect->pGroupBy ){
    return 0;
  }
  if( pSelect->pLimit ){
    return 0;
  }
  if( pSelect->pPrior ){
    return 0;
  }
  if( pSelect->selFlags & 0x00001 ){
    return 0;
  }
  pEList = pSelect->pEList;
  ((void)0);
  if( pEList->nExpr!=1 ){
    return 0;
  }
  ((void)0);
  if( pEList->a[0].pExpr->op!=175 ){
    return 0;
  }





  pItem = pSelect->pSrc->a;
  pSrc = sqlite3LocateTableItem(pParse, 0, pItem);
  if( pSrc==0 ){
    return 0;
  }
  if( pSrc->tnum==pDest->tnum && pSrc->pSchema==pDest->pSchema ){
    ;
    return 0;
  }
  if( (((pDest)->tabFlags & 0x0020)==0)!=(((pSrc)->tabFlags & 0x0020)==0) ){
    return 0;
  }

  if( ((pSrc)->nModuleArg) ){
    return 0;
  }

  if( pSrc->pSelect ){
    return 0;
  }
  if( pDest->nCol!=pSrc->nCol ){
    return 0;
  }
  if( pDest->iPKey!=pSrc->iPKey ){
    return 0;
  }
  for(i=0; i<pDest->nCol; i++){
    Column *pDestCol = &pDest->aCol[i];
    Column *pSrcCol = &pSrc->aCol[i];







    if( pDestCol->affinity!=pSrcCol->affinity ){
      return 0;
    }
    if( sqlite3_stricmp(pDestCol->zColl, pSrcCol->zColl)!=0 ){
      return 0;
    }
    if( pDestCol->notNull && !pSrcCol->notNull ){
      return 0;
    }

    if( i>0 ){
      ((void)0);
      ((void)0);
      if( (pDestCol->pDflt==0)!=(pSrcCol->pDflt==0)
       || (pDestCol->pDflt && strcmp(pDestCol->pDflt->u.zToken,
                                       pSrcCol->pDflt->u.zToken)!=0)
      ){
        return 0;
      }
    }
  }
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
    if( ((pDestIdx)->onError!=0) ){
      destHasUniqueIdx = 1;
    }
    for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;
    }
    if( pSrcIdx==0 ){
      return 0;
    }
    if( pSrcIdx->tnum==pDestIdx->tnum && pSrc->pSchema==pDest->pSchema
         && sqlite3FaultSim(411)==0 ){



      return 0;
    }
  }

  if( pDest->pCheck && sqlite3ExprListCompare(pSrc->pCheck,pDest->pCheck,-1) ){
    return 0;
  }
# 119714 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (db->flags & 0x00004000)!=0 && pDest->pFKey!=0 ){
    return 0;
  }

  if( (db->flags & 0x00000080)!=0 ){
    return 0;
  }
# 119729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  iDbSrc = sqlite3SchemaToIndex(db, pSrc->pSchema);
  v = sqlite3GetVdbe(pParse);
  sqlite3CodeVerifySchema(pParse, iDbSrc);
  iSrc = pParse->nTab++;
  iDest = pParse->nTab++;
  regAutoinc = autoIncBegin(pParse, iDbDest, pDest);
  regData = sqlite3GetTempReg(pParse);
  regRowid = sqlite3GetTempReg(pParse);
  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, 98);
  ((void)0);
  if( (db->mDbFlags & 0x0004)==0 && (
      (pDest->iPKey<0 && pDest->pIndex!=0)
   || destHasUniqueIdx
   || (onError!=2 && onError!=1)
  )){
# 119761 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    addr1 = sqlite3VdbeAddOp2(v, 36, iDest, 0); ;
    emptyDestTest = sqlite3VdbeAddOp0(v, 11);
    sqlite3VdbeJumpHere(v, addr1);
  }
  if( (((pSrc)->tabFlags & 0x0020)==0) ){
    u8 insFlags;
    sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, 97);
    emptySrcTest = sqlite3VdbeAddOp2(v, 36, iSrc, 0); ;
    if( pDest->iPKey>=0 ){
      addr1 = sqlite3VdbeAddOp2(v, 128, iSrc, regRowid);
      ;
      addr2 = sqlite3VdbeAddOp3(v, 31, iDest, 0, regRowid);
      ;
      sqlite3RowidConstraint(pParse, onError, pDest);
      sqlite3VdbeJumpHere(v, addr2);
      autoIncStep(pParse, regAutoinc, regRowid);
    }else if( pDest->pIndex==0 && !(db->mDbFlags & 0x0008) ){
      addr1 = sqlite3VdbeAddOp2(v, 121, iDest, regRowid);
    }else{
      addr1 = sqlite3VdbeAddOp2(v, 128, iSrc, regRowid);
      ((void)0);
    }
    sqlite3VdbeAddOp3(v, 127, iSrc, regData, 1);
    if( db->mDbFlags & 0x0004 ){
      sqlite3VdbeAddOp1(v, 130, iDest);
      insFlags = 0x01|0x20|
                           0x08|0x10;
    }else{
      insFlags = 0x01|0x20|0x08;
    }
    sqlite3VdbeAddOp4(v, 122, iDest, regData, regRowid,
                      (char*)pDest, (-6));
    sqlite3VdbeChangeP5(v, insFlags);
    sqlite3VdbeAddOp2(v, 5, iSrc, addr1); ;
    sqlite3VdbeAddOp2(v, 117, iSrc, 0);
    sqlite3VdbeAddOp2(v, 117, iDest, 0);
  }else{
    sqlite3TableLock(pParse, iDbDest, pDest->tnum, 1, pDest->zName);
    sqlite3TableLock(pParse, iDbSrc, pSrc->tnum, 0, pSrc->zName);
  }
  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){
    u8 idxInsFlags = 0;
    for(pSrcIdx=pSrc->pIndex; (pSrcIdx); pSrcIdx=pSrcIdx->pNext){
      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;
    }
    ((void)0);
    sqlite3VdbeAddOp3(v, 97, iSrc, pSrcIdx->tnum, iDbSrc);
    sqlite3VdbeSetP4KeyInfo(pParse, pSrcIdx);
    ;
    sqlite3VdbeAddOp3(v, 98, iDest, pDestIdx->tnum, iDbDest);
    sqlite3VdbeSetP4KeyInfo(pParse, pDestIdx);
    sqlite3VdbeChangeP5(v, 0x01);
    ;
    addr1 = sqlite3VdbeAddOp2(v, 36, iSrc, 0); ;
    sqlite3VdbeAddOp3(v, 127, iSrc, regData, 1);
    if( db->mDbFlags & 0x0004 ){
# 119831 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      for(i=0; i<pSrcIdx->nColumn; i++){
        const char *zColl = pSrcIdx->azColl[i];
        if( sqlite3_stricmp(sqlite3StrBINARY, zColl) ) break;
      }
      if( i==pSrcIdx->nColumn ){
        idxInsFlags = 0x10;
        sqlite3VdbeAddOp1(v, 130, iDest);
      }
    }
    if( !(((pSrc)->tabFlags & 0x0020)==0) && pDestIdx->idxType==2 ){
      idxInsFlags |= 0x01;
    }
    sqlite3VdbeAddOp2(v, 132, iDest, regData);
    sqlite3VdbeChangeP5(v, idxInsFlags|0x08);
    sqlite3VdbeAddOp2(v, 5, iSrc, addr1+1); ;
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp2(v, 117, iSrc, 0);
    sqlite3VdbeAddOp2(v, 117, iDest, 0);
  }
  if( emptySrcTest ) sqlite3VdbeJumpHere(v, emptySrcTest);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regData);
  if( emptyDestTest ){
    sqlite3AutoincrementEnd(pParse);
    sqlite3VdbeAddOp2(v, 69, 0, 0);
    sqlite3VdbeJumpHere(v, emptyDestTest);
    sqlite3VdbeAddOp2(v, 117, iDest, 0);
    return 0;
  }else{
    return 1;
  }
}
# 119896 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_exec(
  sqlite3 *db,
  const char *zSql,
  sqlite3_callback xCallback,
  void *pArg,
  char **pzErrMsg
){
  int rc = 0;
  const char *zLeftover;
  sqlite3_stmt *pStmt = 0;
  char **azCols = 0;
  int callbackIsInit;

  if( !sqlite3SafetyCheckOk(db) ) return sqlite3MisuseError(119909);
  if( zSql==0 ) zSql = "";

  sqlite3_mutex_enter(db->mutex);
  sqlite3Error(db, 0);
  while( rc==0 && zSql[0] ){
    int nCol = 0;
    char **azVals = 0;

    pStmt = 0;
    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, &zLeftover);
    ((void)0);
    if( rc!=0 ){
      continue;
    }
    if( !pStmt ){

      zSql = zLeftover;
      continue;
    }
    callbackIsInit = 0;

    while( 1 ){
      int i;
      rc = sqlite3_step(pStmt);


      if( xCallback && (100==rc ||
          (101==rc && !callbackIsInit
                           && db->flags&0x00000100)) ){
        if( !callbackIsInit ){
          nCol = sqlite3_column_count(pStmt);
          azCols = sqlite3DbMallocRaw(db, (2*nCol+1)*sizeof(const char*));
          if( azCols==0 ){
            goto exec_out;
          }
          for(i=0; i<nCol; i++){
            azCols[i] = (char *)sqlite3_column_name(pStmt, i);


            ((void)0);
          }
          callbackIsInit = 1;
        }
        if( rc==100 ){
          azVals = &azCols[nCol];
          for(i=0; i<nCol; i++){
            azVals[i] = (char *)sqlite3_column_text(pStmt, i);
            if( !azVals[i] && sqlite3_column_type(pStmt, i)!=5 ){
              sqlite3OomFault(db);
              goto exec_out;
            }
          }
          azVals[i] = 0;
        }
        if( xCallback(pArg, nCol, azVals, azCols) ){



          rc = 4;
          sqlite3VdbeFinalize((Vdbe *)pStmt);
          pStmt = 0;
          sqlite3Error(db, 4);
          goto exec_out;
        }
      }

      if( rc!=100 ){
        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);
        pStmt = 0;
        zSql = zLeftover;
        while( (sqlite3CtypeMap[(unsigned char)(zSql[0])]&0x01) ) zSql++;
        break;
      }
    }

    sqlite3DbFree(db, azCols);
    azCols = 0;
  }

exec_out:
  if( pStmt ) sqlite3VdbeFinalize((Vdbe *)pStmt);
  sqlite3DbFree(db, azCols);

  rc = sqlite3ApiExit(db, rc);
  if( rc!=0 && pzErrMsg ){
    *pzErrMsg = sqlite3DbStrDup(0, sqlite3_errmsg(db));
    if( *pzErrMsg==0 ){
      rc = 7;
      sqlite3Error(db, 7);
    }
  }else if( pzErrMsg ){
    *pzErrMsg = 0;
  }

  ((void)0);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 120049 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE3EXT_H 
# 120062 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct sqlite3_api_routines {
  void * (*aggregate_context)(sqlite3_context*,int nBytes);
  int (*aggregate_count)(sqlite3_context*);
  int (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));
  int (*bind_double)(sqlite3_stmt*,int,double);
  int (*bind_int)(sqlite3_stmt*,int,int);
  int (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);
  int (*bind_null)(sqlite3_stmt*,int);
  int (*bind_parameter_count)(sqlite3_stmt*);
  int (*bind_parameter_index)(sqlite3_stmt*,const char*zName);
  const char * (*bind_parameter_name)(sqlite3_stmt*,int);
  int (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));
  int (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));
  int (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);
  int (*busy_handler)(sqlite3*,int(*)(void*,int),void*);
  int (*busy_timeout)(sqlite3*,int ms);
  int (*changes)(sqlite3*);
  int (*close)(sqlite3*);
  int (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,
                           int eTextRep,const char*));
  int (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,
                             int eTextRep,const void*));
  const void * (*column_blob)(sqlite3_stmt*,int iCol);
  int (*column_bytes)(sqlite3_stmt*,int iCol);
  int (*column_bytes16)(sqlite3_stmt*,int iCol);
  int (*column_count)(sqlite3_stmt*pStmt);
  const char * (*column_database_name)(sqlite3_stmt*,int);
  const void * (*column_database_name16)(sqlite3_stmt*,int);
  const char * (*column_decltype)(sqlite3_stmt*,int i);
  const void * (*column_decltype16)(sqlite3_stmt*,int);
  double (*column_double)(sqlite3_stmt*,int iCol);
  int (*column_int)(sqlite3_stmt*,int iCol);
  sqlite_int64 (*column_int64)(sqlite3_stmt*,int iCol);
  const char * (*column_name)(sqlite3_stmt*,int);
  const void * (*column_name16)(sqlite3_stmt*,int);
  const char * (*column_origin_name)(sqlite3_stmt*,int);
  const void * (*column_origin_name16)(sqlite3_stmt*,int);
  const char * (*column_table_name)(sqlite3_stmt*,int);
  const void * (*column_table_name16)(sqlite3_stmt*,int);
  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);
  const void * (*column_text16)(sqlite3_stmt*,int iCol);
  int (*column_type)(sqlite3_stmt*,int iCol);
  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);
  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);
  int (*complete)(const char*sql);
  int (*complete16)(const void*sql);
  int (*create_collation)(sqlite3*,const char*,int,void*,
                           int(*)(void*,int,const void*,int,const void*));
  int (*create_collation16)(sqlite3*,const void*,int,void*,
                             int(*)(void*,int,const void*,int,const void*));
  int (*create_function)(sqlite3*,const char*,int,int,void*,
                          void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
                          void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                          void (*xFinal)(sqlite3_context*));
  int (*create_function16)(sqlite3*,const void*,int,int,void*,
                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                            void (*xFinal)(sqlite3_context*));
  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);
  int (*data_count)(sqlite3_stmt*pStmt);
  sqlite3 * (*db_handle)(sqlite3_stmt*);
  int (*declare_vtab)(sqlite3*,const char*);
  int (*enable_shared_cache)(int);
  int (*errcode)(sqlite3*db);
  const char * (*errmsg)(sqlite3*);
  const void * (*errmsg16)(sqlite3*);
  int (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);
  int (*expired)(sqlite3_stmt*);
  int (*finalize)(sqlite3_stmt*pStmt);
  void (*free)(void*);
  void (*free_table)(char**result);
  int (*get_autocommit)(sqlite3*);
  void * (*get_auxdata)(sqlite3_context*,int);
  int (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);
  int (*global_recover)(void);
  void (*interruptx)(sqlite3*);
  sqlite_int64 (*last_insert_rowid)(sqlite3*);
  const char * (*libversion)(void);
  int (*libversion_number)(void);
  void *(*malloc)(int);
  char * (*mprintf)(const char*,...);
  int (*open)(const char*,sqlite3**);
  int (*open16)(const void*,sqlite3**);
  int (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);
  int (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);
  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);
  void (*progress_handler)(sqlite3*,int,int(*)(void*),void*);
  void *(*realloc)(void*,int);
  int (*reset)(sqlite3_stmt*pStmt);
  void (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_double)(sqlite3_context*,double);
  void (*result_error)(sqlite3_context*,const char*,int);
  void (*result_error16)(sqlite3_context*,const void*,int);
  void (*result_int)(sqlite3_context*,int);
  void (*result_int64)(sqlite3_context*,sqlite_int64);
  void (*result_null)(sqlite3_context*);
  void (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));
  void (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));
  void (*result_value)(sqlite3_context*,sqlite3_value*);
  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);
  int (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,
                         const char*,const char*),void*);
  void (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));
  char * (*xsnprintf)(int,char*,const char*,...);
  int (*step)(sqlite3_stmt*);
  int (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,
                                char const**,char const**,int*,int*,int*);
  void (*thread_cleanup)(void);
  int (*total_changes)(sqlite3*);
  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);
  int (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);
  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,
                                         sqlite_int64),void*);
  void * (*user_data)(sqlite3_context*);
  const void * (*value_blob)(sqlite3_value*);
  int (*value_bytes)(sqlite3_value*);
  int (*value_bytes16)(sqlite3_value*);
  double (*value_double)(sqlite3_value*);
  int (*value_int)(sqlite3_value*);
  sqlite_int64 (*value_int64)(sqlite3_value*);
  int (*value_numeric_type)(sqlite3_value*);
  const unsigned char * (*value_text)(sqlite3_value*);
  const void * (*value_text16)(sqlite3_value*);
  const void * (*value_text16be)(sqlite3_value*);
  const void * (*value_text16le)(sqlite3_value*);
  int (*value_type)(sqlite3_value*);
  char *(*vmprintf)(const char*,va_list);

  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);

  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);
  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);
  int (*clear_bindings)(sqlite3_stmt*);

  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,
                          void (*xDestroy)(void *));

  int (*bind_zeroblob)(sqlite3_stmt*,int,int);
  int (*blob_bytes)(sqlite3_blob*);
  int (*blob_close)(sqlite3_blob*);
  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,
                   int,sqlite3_blob**);
  int (*blob_read)(sqlite3_blob*,void*,int,int);
  int (*blob_write)(sqlite3_blob*,const void*,int,int);
  int (*create_collation_v2)(sqlite3*,const char*,int,void*,
                             int(*)(void*,int,const void*,int,const void*),
                             void(*)(void*));
  int (*file_control)(sqlite3*,const char*,int,void*);
  sqlite3_int64 (*memory_highwater)(int);
  sqlite3_int64 (*memory_used)(void);
  sqlite3_mutex *(*mutex_alloc)(int);
  void (*mutex_enter)(sqlite3_mutex*);
  void (*mutex_free)(sqlite3_mutex*);
  void (*mutex_leave)(sqlite3_mutex*);
  int (*mutex_try)(sqlite3_mutex*);
  int (*open_v2)(const char*,sqlite3**,int,const char*);
  int (*release_memory)(int);
  void (*result_error_nomem)(sqlite3_context*);
  void (*result_error_toobig)(sqlite3_context*);
  int (*sleep)(int);
  void (*soft_heap_limit)(int);
  sqlite3_vfs *(*vfs_find)(const char*);
  int (*vfs_register)(sqlite3_vfs*,int);
  int (*vfs_unregister)(sqlite3_vfs*);
  int (*xthreadsafe)(void);
  void (*result_zeroblob)(sqlite3_context*,int);
  void (*result_error_code)(sqlite3_context*,int);
  int (*test_control)(int, ...);
  void (*randomness)(int,void*);
  sqlite3 *(*context_db_handle)(sqlite3_context*);
  int (*extended_result_codes)(sqlite3*,int);
  int (*limit)(sqlite3*,int,int);
  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);
  const char *(*sql)(sqlite3_stmt*);
  int (*status)(int,int*,int*,int);
  int (*backup_finish)(sqlite3_backup*);
  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);
  int (*backup_pagecount)(sqlite3_backup*);
  int (*backup_remaining)(sqlite3_backup*);
  int (*backup_step)(sqlite3_backup*,int);
  const char *(*compileoption_get)(int);
  int (*compileoption_used)(const char*);
  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,
                            void (*xFunc)(sqlite3_context*,int,sqlite3_value**),
                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                            void (*xFinal)(sqlite3_context*),
                            void(*xDestroy)(void*));
  int (*db_config)(sqlite3*,int,...);
  sqlite3_mutex *(*db_mutex)(sqlite3*);
  int (*db_status)(sqlite3*,int,int*,int*,int);
  int (*extended_errcode)(sqlite3*);
  void (*log)(int,const char*,...);
  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);
  const char *(*sourceid)(void);
  int (*stmt_status)(sqlite3_stmt*,int,int);
  int (*strnicmp)(const char*,const char*,int);
  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);
  int (*wal_autocheckpoint)(sqlite3*,int);
  int (*wal_checkpoint)(sqlite3*,const char*);
  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);
  int (*blob_reopen)(sqlite3_blob*,sqlite3_int64);
  int (*vtab_config)(sqlite3*,int op,...);
  int (*vtab_on_conflict)(sqlite3*);

  int (*close_v2)(sqlite3*);
  const char *(*db_filename)(sqlite3*,const char*);
  int (*db_readonly)(sqlite3*,const char*);
  int (*db_release_memory)(sqlite3*);
  const char *(*errstr)(int);
  int (*stmt_busy)(sqlite3_stmt*);
  int (*stmt_readonly)(sqlite3_stmt*);
  int (*stricmp)(const char*,const char*);
  int (*uri_boolean)(const char*,const char*,int);
  sqlite3_int64 (*uri_int64)(const char*,const char*,sqlite3_int64);
  const char *(*uri_parameter)(const char*,const char*);
  char *(*xvsnprintf)(int,char*,const char*,va_list);
  int (*wal_checkpoint_v2)(sqlite3*,const char*,int,int*,int*);

  int (*auto_extension)(void(*)(void));
  int (*bind_blob64)(sqlite3_stmt*,int,const void*,sqlite3_uint64,
                     void(*)(void*));
  int (*bind_text64)(sqlite3_stmt*,int,const char*,sqlite3_uint64,
                      void(*)(void*),unsigned char);
  int (*cancel_auto_extension)(void(*)(void));
  int (*load_extension)(sqlite3*,const char*,const char*,char**);
  void *(*malloc64)(sqlite3_uint64);
  sqlite3_uint64 (*msize)(void*);
  void *(*realloc64)(void*,sqlite3_uint64);
  void (*reset_auto_extension)(void);
  void (*result_blob64)(sqlite3_context*,const void*,sqlite3_uint64,
                        void(*)(void*));
  void (*result_text64)(sqlite3_context*,const char*,sqlite3_uint64,
                         void(*)(void*), unsigned char);
  int (*strglob)(const char*,const char*);

  sqlite3_value *(*value_dup)(const sqlite3_value*);
  void (*value_free)(sqlite3_value*);
  int (*result_zeroblob64)(sqlite3_context*,sqlite3_uint64);
  int (*bind_zeroblob64)(sqlite3_stmt*, int, sqlite3_uint64);

  unsigned int (*value_subtype)(sqlite3_value*);
  void (*result_subtype)(sqlite3_context*,unsigned int);

  int (*status64)(int,sqlite3_int64*,sqlite3_int64*,int);
  int (*strlike)(const char*,const char*,unsigned int);
  int (*db_cacheflush)(sqlite3*);

  int (*system_errno)(sqlite3*);

  int (*trace_v2)(sqlite3*,unsigned,int(*)(unsigned,void*,void*,void*),void*);
  char *(*expanded_sql)(sqlite3_stmt*);

  void (*set_last_insert_rowid)(sqlite3*,sqlite3_int64);

  int (*prepare_v3)(sqlite3*,const char*,int,unsigned int,
                    sqlite3_stmt**,const char**);
  int (*prepare16_v3)(sqlite3*,const void*,int,unsigned int,
                      sqlite3_stmt**,const void**);
  int (*bind_pointer)(sqlite3_stmt*,int,void*,const char*,void(*)(void*));
  void (*result_pointer)(sqlite3_context*,void*,const char*,void(*)(void*));
  void *(*value_pointer)(sqlite3_value*,const char*);
  int (*vtab_nochange)(sqlite3_context*);
  int (*value_nochange)(sqlite3_value*);
  const char *(*vtab_collation)(sqlite3_index_info*,int);

  int (*keyword_count)(void);
  int (*keyword_name)(int,const char**,int*);
  int (*keyword_check)(const char*,int);
  sqlite3_str *(*str_new)(sqlite3*);
  char *(*str_finish)(sqlite3_str*);
  void (*str_appendf)(sqlite3_str*, const char *zFormat, ...);
  void (*str_vappendf)(sqlite3_str*, const char *zFormat, va_list);
  void (*str_append)(sqlite3_str*, const char *zIn, int N);
  void (*str_appendall)(sqlite3_str*, const char *zIn);
  void (*str_appendchar)(sqlite3_str*, int N, char C);
  void (*str_reset)(sqlite3_str*);
  int (*str_errcode)(sqlite3_str*);
  int (*str_length)(sqlite3_str*);
  char *(*str_value)(sqlite3_str*);

  int (*create_window_function)(sqlite3*,const char*,int,int,void*,
                            void (*xStep)(sqlite3_context*,int,sqlite3_value**),
                            void (*xFinal)(sqlite3_context*),
                            void (*xValue)(sqlite3_context*),
                            void (*xInv)(sqlite3_context*,int,sqlite3_value**),
                            void(*xDestroy)(void*));

  const char *(*normalized_sql)(sqlite3_stmt*);

  int (*stmt_isexplain)(sqlite3_stmt*);
  int (*value_frombind)(sqlite3_value*);

  int (*drop_modules)(sqlite3*,const char**);
};





typedef int (*sqlite3_loadext_entry)(
  sqlite3 *db,
  char **pzErrMsg,
  const sqlite3_api_routines *pThunk
);
# 120663 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_EXTENSION_INIT1 
#define SQLITE_EXTENSION_INIT2(v) (void)v;
#define SQLITE_EXTENSION_INIT3 
# 120681 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqlite3_column_database_name 0
#define sqlite3_column_database_name16 0
#define sqlite3_column_table_name 0
#define sqlite3_column_table_name16 0
#define sqlite3_column_origin_name 0
#define sqlite3_column_origin_name16 0
# 120785 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const sqlite3_api_routines sqlite3Apis = {
  sqlite3_aggregate_context,

  sqlite3_aggregate_count,



  sqlite3_bind_blob,
  sqlite3_bind_double,
  sqlite3_bind_int,
  sqlite3_bind_int64,
  sqlite3_bind_null,
  sqlite3_bind_parameter_count,
  sqlite3_bind_parameter_index,
  sqlite3_bind_parameter_name,
  sqlite3_bind_text,
  sqlite3_bind_text16,
  sqlite3_bind_value,
  sqlite3_busy_handler,
  sqlite3_busy_timeout,
  sqlite3_changes,
  sqlite3_close,
  sqlite3_collation_needed,
  sqlite3_collation_needed16,
  sqlite3_column_blob,
  sqlite3_column_bytes,
  sqlite3_column_bytes16,
  sqlite3_column_count,
  0,
  0,
  sqlite3_column_decltype,
  sqlite3_column_decltype16,
  sqlite3_column_double,
  sqlite3_column_int,
  sqlite3_column_int64,
  sqlite3_column_name,
  sqlite3_column_name16,
  0,
  0,
  0,
  0,
  sqlite3_column_text,
  sqlite3_column_text16,
  sqlite3_column_type,
  sqlite3_column_value,
  sqlite3_commit_hook,
  sqlite3_complete,
  sqlite3_complete16,
  sqlite3_create_collation,
  sqlite3_create_collation16,
  sqlite3_create_function,
  sqlite3_create_function16,
  sqlite3_create_module,
  sqlite3_data_count,
  sqlite3_db_handle,
  sqlite3_declare_vtab,
  sqlite3_enable_shared_cache,
  sqlite3_errcode,
  sqlite3_errmsg,
  sqlite3_errmsg16,
  sqlite3_exec,

  sqlite3_expired,



  sqlite3_finalize,
  sqlite3_free,
  sqlite3_free_table,
  sqlite3_get_autocommit,
  sqlite3_get_auxdata,
  sqlite3_get_table,
  0,
  sqlite3_interrupt,
  sqlite3_last_insert_rowid,
  sqlite3_libversion,
  sqlite3_libversion_number,
  sqlite3_malloc,
  sqlite3_mprintf,
  sqlite3_open,
  sqlite3_open16,
  sqlite3_prepare,
  sqlite3_prepare16,
  sqlite3_profile,
  sqlite3_progress_handler,
  sqlite3_realloc,
  sqlite3_reset,
  sqlite3_result_blob,
  sqlite3_result_double,
  sqlite3_result_error,
  sqlite3_result_error16,
  sqlite3_result_int,
  sqlite3_result_int64,
  sqlite3_result_null,
  sqlite3_result_text,
  sqlite3_result_text16,
  sqlite3_result_text16be,
  sqlite3_result_text16le,
  sqlite3_result_value,
  sqlite3_rollback_hook,
  sqlite3_set_authorizer,
  sqlite3_set_auxdata,
  sqlite3_snprintf,
  sqlite3_step,
  sqlite3_table_column_metadata,

  sqlite3_thread_cleanup,



  sqlite3_total_changes,
  sqlite3_trace,

  sqlite3_transfer_bindings,



  sqlite3_update_hook,
  sqlite3_user_data,
  sqlite3_value_blob,
  sqlite3_value_bytes,
  sqlite3_value_bytes16,
  sqlite3_value_double,
  sqlite3_value_int,
  sqlite3_value_int64,
  sqlite3_value_numeric_type,
  sqlite3_value_text,
  sqlite3_value_text16,
  sqlite3_value_text16be,
  sqlite3_value_text16le,
  sqlite3_value_type,
  sqlite3_vmprintf,
# 120925 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_overload_function,




  sqlite3_prepare_v2,
  sqlite3_prepare16_v2,
  sqlite3_clear_bindings,




  sqlite3_create_module_v2,




  sqlite3_bind_zeroblob,
  sqlite3_blob_bytes,
  sqlite3_blob_close,
  sqlite3_blob_open,
  sqlite3_blob_read,
  sqlite3_blob_write,
  sqlite3_create_collation_v2,
  sqlite3_file_control,
  sqlite3_memory_highwater,
  sqlite3_memory_used,







  sqlite3_mutex_alloc,
  sqlite3_mutex_enter,
  sqlite3_mutex_free,
  sqlite3_mutex_leave,
  sqlite3_mutex_try,

  sqlite3_open_v2,
  sqlite3_release_memory,
  sqlite3_result_error_nomem,
  sqlite3_result_error_toobig,
  sqlite3_sleep,
  sqlite3_soft_heap_limit,
  sqlite3_vfs_find,
  sqlite3_vfs_register,
  sqlite3_vfs_unregister,




  sqlite3_threadsafe,
  sqlite3_result_zeroblob,
  sqlite3_result_error_code,
  sqlite3_test_control,
  sqlite3_randomness,
  sqlite3_context_db_handle,




  sqlite3_extended_result_codes,
  sqlite3_limit,
  sqlite3_next_stmt,
  sqlite3_sql,
  sqlite3_status,




  sqlite3_backup_finish,
  sqlite3_backup_init,
  sqlite3_backup_pagecount,
  sqlite3_backup_remaining,
  sqlite3_backup_step,

  sqlite3_compileoption_get,
  sqlite3_compileoption_used,




  sqlite3_create_function_v2,
  sqlite3_db_config,
  sqlite3_db_mutex,
  sqlite3_db_status,
  sqlite3_extended_errcode,
  sqlite3_log,
  sqlite3_soft_heap_limit64,
  sqlite3_sourceid,
  sqlite3_stmt_status,
  sqlite3_strnicmp,



  0,


  sqlite3_wal_autocheckpoint,
  sqlite3_wal_checkpoint,
  sqlite3_wal_hook,





  sqlite3_blob_reopen,
  sqlite3_vtab_config,
  sqlite3_vtab_on_conflict,
  sqlite3_close_v2,
  sqlite3_db_filename,
  sqlite3_db_readonly,
  sqlite3_db_release_memory,
  sqlite3_errstr,
  sqlite3_stmt_busy,
  sqlite3_stmt_readonly,
  sqlite3_stricmp,
  sqlite3_uri_boolean,
  sqlite3_uri_int64,
  sqlite3_uri_parameter,
  sqlite3_vsnprintf,
  sqlite3_wal_checkpoint_v2,

  sqlite3_auto_extension,
  sqlite3_bind_blob64,
  sqlite3_bind_text64,
  sqlite3_cancel_auto_extension,
  sqlite3_load_extension,
  sqlite3_malloc64,
  sqlite3_msize,
  sqlite3_realloc64,
  sqlite3_reset_auto_extension,
  sqlite3_result_blob64,
  sqlite3_result_text64,
  sqlite3_strglob,

  (sqlite3_value*(*)(const sqlite3_value*))sqlite3_value_dup,
  sqlite3_value_free,
  sqlite3_result_zeroblob64,
  sqlite3_bind_zeroblob64,

  sqlite3_value_subtype,
  sqlite3_result_subtype,

  sqlite3_status64,
  sqlite3_strlike,
  sqlite3_db_cacheflush,

  sqlite3_system_errno,

  sqlite3_trace_v2,
  sqlite3_expanded_sql,

  sqlite3_set_last_insert_rowid,

  sqlite3_prepare_v3,
  sqlite3_prepare16_v3,
  sqlite3_bind_pointer,
  sqlite3_result_pointer,
  sqlite3_value_pointer,

  sqlite3_vtab_nochange,
  sqlite3_value_nochange,
  sqlite3_vtab_collation,

  sqlite3_keyword_count,
  sqlite3_keyword_name,
  sqlite3_keyword_check,
  sqlite3_str_new,
  sqlite3_str_finish,
  sqlite3_str_appendf,
  sqlite3_str_vappendf,
  sqlite3_str_append,
  sqlite3_str_appendall,
  sqlite3_str_appendchar,
  sqlite3_str_reset,
  sqlite3_str_errcode,
  sqlite3_str_length,
  sqlite3_str_value,

  sqlite3_create_window_function,




  0,


  sqlite3_stmt_isexplain,
  sqlite3_value_frombind,


  sqlite3_drop_modules,



};
# 121137 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3LoadExtension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
){
  sqlite3_vfs *pVfs = db->pVfs;
  void *handle;
  sqlite3_loadext_entry xInit;
  char *zErrmsg = 0;
  const char *zEntry;
  char *zAltEntry = 0;
  void **aHandle;
  u64 nMsg = 300 + sqlite3Strlen30(zFile);
  int ii;
  int rc;


  static const char *azEndings[] = {



     "dylib"



  };


  if( pzErrMsg ) *pzErrMsg = 0;
# 121175 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (db->flags & 0x00010000)==0 ){
    if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("not authorized");
    }
    return 1;
  }

  zEntry = zProc ? zProc : "sqlite3_extension_init";

  handle = sqlite3OsDlOpen(pVfs, zFile);

  for(ii=0; ii<((int)(sizeof(azEndings)/sizeof(azEndings[0]))) && handle==0; ii++){
    char *zAltFile = sqlite3_mprintf("%s.%s", zFile, azEndings[ii]);
    if( zAltFile==0 ) return 7;
    handle = sqlite3OsDlOpen(pVfs, zAltFile);
    sqlite3_free(zAltFile);
  }

  if( handle==0 ){
    if( pzErrMsg ){
      *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
      if( zErrmsg ){
        sqlite3_snprintf(nMsg, zErrmsg,
            "unable to open shared library [%s]", zFile);
        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
      }
    }
    return 1;
  }
  xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);
# 121217 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( xInit==0 && zProc==0 ){
    int iFile, iEntry, c;
    int ncFile = sqlite3Strlen30(zFile);
    zAltEntry = sqlite3_malloc64(ncFile+30);
    if( zAltEntry==0 ){
      sqlite3OsDlClose(pVfs, handle);
      return 7;
    }
    memcpy(zAltEntry, "sqlite3_", 8);
    for(iFile=ncFile-1; iFile>=0 && zFile[iFile]!='/'; iFile--){}
    iFile++;
    if( sqlite3_strnicmp(zFile+iFile, "lib", 3)==0 ) iFile += 3;
    for(iEntry=8; (c = zFile[iFile])!=0 && c!='.'; iFile++){
      if( (sqlite3CtypeMap[(unsigned char)(c)]&0x02) ){
        zAltEntry[iEntry++] = (char)sqlite3UpperToLower[(unsigned)c];
      }
    }
    memcpy(zAltEntry+iEntry, "_init", 6);
    zEntry = zAltEntry;
    xInit = (sqlite3_loadext_entry)sqlite3OsDlSym(pVfs, handle, zEntry);
  }
  if( xInit==0 ){
    if( pzErrMsg ){
      nMsg += sqlite3Strlen30(zEntry);
      *pzErrMsg = zErrmsg = sqlite3_malloc64(nMsg);
      if( zErrmsg ){
        sqlite3_snprintf(nMsg, zErrmsg,
            "no entry point [%s] in shared library [%s]", zEntry, zFile);
        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);
      }
    }
    sqlite3OsDlClose(pVfs, handle);
    sqlite3_free(zAltEntry);
    return 1;
  }
  sqlite3_free(zAltEntry);
  rc = xInit(db, &zErrmsg, &sqlite3Apis);
  if( rc ){
    if( rc==(0 | (1<<8)) ) return 0;
    if( pzErrMsg ){
      *pzErrMsg = sqlite3_mprintf("error during initialization: %s", zErrmsg);
    }
    sqlite3_free(zErrmsg);
    sqlite3OsDlClose(pVfs, handle);
    return 1;
  }


  aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1));
  if( aHandle==0 ){
    return 7;
  }
  if( db->nExtension>0 ){
    memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);
  }
  sqlite3DbFree(db, db->aExtension);
  db->aExtension = aHandle;

  db->aExtension[db->nExtension++] = handle;
  return 0;
}
 int sqlite3_load_extension(
  sqlite3 *db,
  const char *zFile,
  const char *zProc,
  char **pzErrMsg
){
  int rc;
  sqlite3_mutex_enter(db->mutex);
  rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





static void sqlite3CloseExtensions(sqlite3 *db){
  int i;
  ((void)0);
  for(i=0; i<db->nExtension; i++){
    sqlite3OsDlClose(db->pVfs, db->aExtension[i]);
  }
  sqlite3DbFree(db, db->aExtension);
}





 int sqlite3_enable_load_extension(sqlite3 *db, int onoff){
  sqlite3_mutex_enter(db->mutex);
  if( onoff ){
    db->flags |= 0x00010000|0x00020000;
  }else{
    db->flags &= ~(u64)(0x00010000|0x00020000);
  }
  sqlite3_mutex_leave(db->mutex);
  return 0;
}
# 121329 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct sqlite3AutoExtList sqlite3AutoExtList;
static struct sqlite3AutoExtList {
  u32 nExt;
  void (**aExt)(void);
} sqlite3Autoext = { 0, 0 };
# 121346 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define wsdAutoextInit 
#define wsdAutoext sqlite3Autoext







 int sqlite3_auto_extension(
  void (*xInit)(void)
){
  int rc = 0;

  rc = sqlite3_initialize();
  if( rc ){
    return rc;
  }else

  {
    u32 i;

    sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

    ;
    sqlite3_mutex_enter(mutex);
    for(i=0; i<sqlite3Autoext.nExt; i++){
      if( sqlite3Autoext.aExt[i]==xInit ) break;
    }
    if( i==sqlite3Autoext.nExt ){
      u64 nByte = (sqlite3Autoext.nExt+1)*sizeof(sqlite3Autoext.aExt[0]);
      void (**aNew)(void);
      aNew = sqlite3_realloc64(sqlite3Autoext.aExt, nByte);
      if( aNew==0 ){
        rc = 7;
      }else{
        sqlite3Autoext.aExt = aNew;
        sqlite3Autoext.aExt[sqlite3Autoext.nExt] = xInit;
        sqlite3Autoext.nExt++;
      }
    }
    sqlite3_mutex_leave(mutex);
    ((void)0);
    return rc;
  }
}
# 121402 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_cancel_auto_extension(
  void (*xInit)(void)
){

  sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

  int i;
  int n = 0;
  ;
  sqlite3_mutex_enter(mutex);
  for(i=(int)sqlite3Autoext.nExt-1; i>=0; i--){
    if( sqlite3Autoext.aExt[i]==xInit ){
      sqlite3Autoext.nExt--;
      sqlite3Autoext.aExt[i] = sqlite3Autoext.aExt[sqlite3Autoext.nExt];
      n++;
      break;
    }
  }
  sqlite3_mutex_leave(mutex);
  return n;
}




 void sqlite3_reset_auto_extension(void){

  if( sqlite3_initialize()==0 )

  {

    sqlite3_mutex *mutex = sqlite3MutexAlloc(2);

    ;
    sqlite3_mutex_enter(mutex);
    sqlite3_free(sqlite3Autoext.aExt);
    sqlite3Autoext.aExt = 0;
    sqlite3Autoext.nExt = 0;
    sqlite3_mutex_leave(mutex);
  }
}






static void sqlite3AutoLoadExtensions(sqlite3 *db){
  u32 i;
  int go = 1;
  int rc;
  sqlite3_loadext_entry xInit;

  ;
  if( sqlite3Autoext.nExt==0 ){

    return;
  }
  for(i=0; go; i++){
    char *zErrmsg;

    sqlite3_mutex *mutex = sqlite3MutexAlloc(2);




    const sqlite3_api_routines *pThunk = &sqlite3Apis;

    sqlite3_mutex_enter(mutex);
    if( i>=sqlite3Autoext.nExt ){
      xInit = 0;
      go = 0;
    }else{
      xInit = (sqlite3_loadext_entry)sqlite3Autoext.aExt[i];
    }
    sqlite3_mutex_leave(mutex);
    zErrmsg = 0;
    if( xInit && (rc = xInit(db, &zErrmsg, pThunk))!=0 ){
      sqlite3ErrorWithMsg(db, rc,
            "automatic extension loading failed: %s", zErrmsg);
      go = 0;
    }
    sqlite3_free(zErrmsg);
  }
}
# 121529 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define PragTyp_HEADER_VALUE 0
#define PragTyp_AUTO_VACUUM 1
#define PragTyp_FLAG 2
#define PragTyp_BUSY_TIMEOUT 3
#define PragTyp_CACHE_SIZE 4
#define PragTyp_CACHE_SPILL 5
#define PragTyp_CASE_SENSITIVE_LIKE 6
#define PragTyp_COLLATION_LIST 7
#define PragTyp_COMPILE_OPTIONS 8
#define PragTyp_DATA_STORE_DIRECTORY 9
#define PragTyp_DATABASE_LIST 10
#define PragTyp_DEFAULT_CACHE_SIZE 11
#define PragTyp_ENCODING 12
#define PragTyp_FOREIGN_KEY_CHECK 13
#define PragTyp_FOREIGN_KEY_LIST 14
#define PragTyp_FUNCTION_LIST 15
#define PragTyp_INCREMENTAL_VACUUM 16
#define PragTyp_INDEX_INFO 17
#define PragTyp_INDEX_LIST 18
#define PragTyp_INTEGRITY_CHECK 19
#define PragTyp_JOURNAL_MODE 20
#define PragTyp_JOURNAL_SIZE_LIMIT 21
#define PragTyp_LOCK_PROXY_FILE 22
#define PragTyp_LOCKING_MODE 23
#define PragTyp_PAGE_COUNT 24
#define PragTyp_MMAP_SIZE 25
#define PragTyp_MODULE_LIST 26
#define PragTyp_OPTIMIZE 27
#define PragTyp_PAGE_SIZE 28
#define PragTyp_PRAGMA_LIST 29
#define PragTyp_SECURE_DELETE 30
#define PragTyp_SHRINK_MEMORY 31
#define PragTyp_SOFT_HEAP_LIMIT 32
#define PragTyp_SYNCHRONOUS 33
#define PragTyp_TABLE_INFO 34
#define PragTyp_TEMP_STORE 35
#define PragTyp_TEMP_STORE_DIRECTORY 36
#define PragTyp_THREADS 37
#define PragTyp_WAL_AUTOCHECKPOINT 38
#define PragTyp_WAL_CHECKPOINT 39
#define PragTyp_ACTIVATE_EXTENSIONS 40
#define PragTyp_KEY 41
#define PragTyp_LOCK_STATUS 42
#define PragTyp_STATS 43


#define PragFlg_NeedSchema 0x01
#define PragFlg_NoColumns 0x02
#define PragFlg_NoColumns1 0x04
#define PragFlg_ReadOnly 0x08
#define PragFlg_Result0 0x10
#define PragFlg_Result1 0x20
#define PragFlg_SchemaOpt 0x40
#define PragFlg_SchemaReq 0x80





static const char *const pragCName[] = {
            "id",
            "seq",
            "table",
            "from",
            "to",
            "on_update",
            "on_delete",
            "match",
            "cid",
            "name",
            "type",
            "notnull",
            "dflt_value",
            "pk",
            "hidden",

            "seqno",
            "cid",
            "name",
            "desc",
            "coll",
            "key",
            "tbl",
            "idx",
            "wdth",
            "hght",
            "flgs",
            "seq",
            "name",
            "unique",
            "origin",
            "partial",
            "table",
            "rowid",
            "parent",
            "fkid",

            "seq",
            "name",
            "file",
            "busy",
            "log",
            "checkpointed",
            "name",
            "builtin",

            "database",
            "status",
            "cache_size",

            "timeout",
};


typedef struct PragmaName {
  const char *const zName;
  u8 ePragTyp;
  u8 mPragFlg;
  u8 iPragCName;
  u8 nPragCName;
  u64 iArg;
} PragmaName;
static const PragmaName aPragmaName[] = {
# 121660 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "application_id",
                   0,
                   0x04|0x10,
                   0, 0,
                   8 },


 { "auto_vacuum",
                   1,
                   0x01|0x10|0x80|0x04,
                   0, 0,
                   0 },



 { "automatic_index",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00008000 },


 { "busy_timeout",
                   3,
                   0x10,
                   46, 1,
                   0 },

 { "cache_size",
                   4,
                   0x01|0x10|0x80|0x04,
                   0, 0,
                   0 },


 { "cache_spill",
                   5,
                   0x10|0x80|0x04,
                   0, 0,
                   0 },


 { "case_sensitive_like",
                   6,
                   0x02,
                   0, 0,
                   0 },

 { "cell_size_check",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00200000 },

 { "checkpoint_fullfsync",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000010 },


 { "collation_list",
                   7,
                   0x10,
                   26, 2,
                   0 },


 { "compile_options",
                   8,
                   0x10,
                   0, 0,
                   0 },


 { "count_changes",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000080 },
# 121749 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "data_version",
                   0,
                   0x08|0x10,
                   0, 0,
                   15 },


 { "database_list",
                   10,
                   0x01|0x10,
                   35, 3,
                   0 },


 { "default_cache_size",
                   11,
                   0x01|0x10|0x80|0x04,
                   45, 1,
                   0 },



 { "defer_foreign_keys",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00080000 },



 { "empty_result_callbacks",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000100 },


 { "encoding",
                   12,
                   0x10|0x04,
                   0, 0,
                   0 },


 { "foreign_key_check",
                   13,
                   0x01|0x10,
                   31, 4,
                   0 },


 { "foreign_key_list",
                   14,
                   0x01|0x20|0x40,
                   0, 8,
                   0 },



 { "foreign_keys",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00004000 },



 { "freelist_count",
                   0,
                   0x08|0x10,
                   0, 0,
                   0 },


 { "full_column_names",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000004 },
 { "fullfsync",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000008 },



 { "function_list",
                   15,
                   0x10,
                   41, 2,
                   0 },
# 121857 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "ignore_check_constraints",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000200 },



 { "incremental_vacuum",
                   16,
                   0x01|0x02,
                   0, 0,
                   0 },


 { "index_info",
                   17,
                   0x01|0x20|0x40,
                   15, 3,
                   0 },
 { "index_list",
                   18,
                   0x01|0x20|0x40,
                   26, 5,
                   0 },
 { "index_xinfo",
                   17,
                   0x01|0x20|0x40,
                   15, 6,
                   1 },


 { "integrity_check",
                   19,
                   0x01|0x10|0x20,
                   0, 0,
                   0 },


 { "journal_mode",
                   20,
                   0x01|0x10|0x80,
                   0, 0,
                   0 },
 { "journal_size_limit",
                   21,
                   0x10|0x80,
                   0, 0,
                   0 },
# 121915 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "legacy_alter_table",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x04000000 },
 { "legacy_file_format",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000002 },


 { "lock_proxy_file",
                   22,
                   0x04,
                   0, 0,
                   0 },
# 121941 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "locking_mode",
                   23,
                   0x10|0x80,
                   0, 0,
                   0 },
 { "max_page_count",
                   24,
                   0x01|0x10|0x80,
                   0, 0,
                   0 },
 { "mmap_size",
                   25,
                   0,
                   0, 0,
                   0 },




 { "module_list",
                   26,
                   0x10,
                   9, 1,
                   0 },



 { "optimize",
                   27,
                   0x20|0x01,
                   0, 0,
                   0 },

 { "page_count",
                   24,
                   0x01|0x10|0x80,
                   0, 0,
                   0 },
 { "page_size",
                   28,
                   0x10|0x80|0x04,
                   0, 0,
                   0 },
# 121995 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "pragma_list",
                   29,
                   0x10,
                   9, 1,
                   0 },


 { "query_only",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00100000 },


 { "quick_check",
                   19,
                   0x01|0x10|0x20,
                   0, 0,
                   0 },


 { "read_uncommitted",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000400 },
 { "recursive_triggers",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00002000 },
# 122035 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "reverse_unordered_selects",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00001000 },


 { "schema_version",
                   0,
                   0x04|0x10,
                   0, 0,
                   1 },


 { "secure_delete",
                   30,
                   0x10,
                   0, 0,
                   0 },


 { "short_column_names",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000040 },

 { "shrink_memory",
                   31,
                   0x02,
                   0, 0,
                   0 },
 { "soft_heap_limit",
                   32,
                   0x10,
                   0, 0,
                   0 },
# 122089 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "synchronous",
                   33,
                   0x01|0x10|0x80|0x04,
                   0, 0,
                   0 },


 { "table_info",
                   34,
                   0x01|0x20|0x40,
                   8, 6,
                   0 },
 { "table_xinfo",
                   34,
                   0x01|0x20|0x40,
                   8, 7,
                   1 },


 { "temp_store",
                   35,
                   0x10|0x04,
                   0, 0,
                   0 },
 { "temp_store_directory",
                   36,
                   0x04,
                   0, 0,
                   0 },
# 122131 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "threads",
                   37,
                   0x10,
                   0, 0,
                   0 },

 { "user_version",
                   0,
                   0x04|0x10,
                   0, 0,
                   6 },
# 122173 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 { "wal_autocheckpoint",
                   38,
                   0,
                   0, 0,
                   0 },
 { "wal_checkpoint",
                   39,
                   0x01,
                   38, 3,
                   0 },


 { "writable_schema",
                   2,
                   0x10|0x04,
                   0, 0,
                   0x00000001|0x08000000 },

};
# 122208 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u8 getSafetyLevel(const char *z, int omitFull, u8 dflt){

  static const char zText[] = "onoffalseyestruextrafull";
  static const u8 iOffset[] = {0, 1, 2, 4, 9, 12, 15, 20};
  static const u8 iLength[] = {2, 2, 3, 5, 3, 4, 5, 4};
  static const u8 iValue[] = {1, 0, 0, 0, 1, 1, 3, 2};

  int i, n;
  if( (sqlite3CtypeMap[(unsigned char)(*z)]&0x04) ){
    return (u8)sqlite3Atoi(z);
  }
  n = sqlite3Strlen30(z);
  for(i=0; i<((int)(sizeof(iLength)/sizeof(iLength[0]))); i++){
    if( iLength[i]==n && sqlite3_strnicmp(&zText[iOffset[i]],z,n)==0
     && (!omitFull || iValue[i]<=1)
    ){
      return iValue[i];
    }
  }
  return dflt;
}




static u8 sqlite3GetBoolean(const char *z, u8 dflt){
  return getSafetyLevel(z,1,dflt)!=0;
}
# 122246 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getLockingMode(const char *z){
  if( z ){
    if( 0==sqlite3StrICmp(z, "exclusive") ) return 1;
    if( 0==sqlite3StrICmp(z, "normal") ) return 0;
  }
  return -1;
}
# 122261 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getAutoVacuum(const char *z){
  int i;
  if( 0==sqlite3StrICmp(z, "none") ) return 0;
  if( 0==sqlite3StrICmp(z, "full") ) return 1;
  if( 0==sqlite3StrICmp(z, "incremental") ) return 2;
  i = sqlite3Atoi(z);
  return (u8)((i>=0&&i<=2)?i:0);
}
# 122277 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int getTempStore(const char *z){
  if( z[0]>='0' && z[0]<='2' ){
    return z[0] - '0';
  }else if( sqlite3StrICmp(z, "file")==0 ){
    return 1;
  }else if( sqlite3StrICmp(z, "memory")==0 ){
    return 2;
  }else{
    return 0;
  }
}







static int invalidateTempStorage(Parse *pParse){
  sqlite3 *db = pParse->db;
  if( db->aDb[1].pBt!=0 ){
    if( !db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt) ){
      sqlite3ErrorMsg(pParse, "temporary storage cannot be changed "
        "from within a transaction");
      return 1;
    }
    sqlite3BtreeClose(db->aDb[1].pBt);
    db->aDb[1].pBt = 0;
    sqlite3ResetAllSchemasOfConnection(db);
  }
  return 0;
}
# 122317 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int changeTempStorage(Parse *pParse, const char *zStorageType){
  int ts = getTempStore(zStorageType);
  sqlite3 *db = pParse->db;
  if( db->temp_store==ts ) return 0;
  if( invalidateTempStorage( pParse ) != 0 ){
    return 1;
  }
  db->temp_store = (u8)ts;
  return 0;
}





static void setPragmaResultColumnNames(
  Vdbe *v,
  const PragmaName *pPragma
){
  u8 n = pPragma->nPragCName;
  sqlite3VdbeSetNumCols(v, n==0 ? 1 : n);
  if( n==0 ){
    sqlite3VdbeSetColName(v, 0, 0, pPragma->zName, ((sqlite3_destructor_type)0));
  }else{
    int i, j;
    for(i=0, j=pPragma->iPragCName; i<n; i++, j++){
      sqlite3VdbeSetColName(v, i, 0, pragCName[j], ((sqlite3_destructor_type)0));
    }
  }
}




static void returnSingleInt(Vdbe *v, i64 value){
  sqlite3VdbeAddOp4Dup8(v, 71, 0, 1, 0, (const u8*)&value, (-14));
  sqlite3VdbeAddOp2(v, 81, 1, 1);
}




static void returnSingleText(
  Vdbe *v,
  const char *zValue
){
  if( zValue ){
    sqlite3VdbeLoadString(v, 1, (const char*)zValue);
    sqlite3VdbeAddOp2(v, 81, 1, 1);
  }
}







static void setAllPagerFlags(sqlite3 *db){
  if( db->autoCommit ){
    Db *pDb = db->aDb;
    int n = db->nDb;
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0)
                                   ;
    ((void)0);
    while( (n--) > 0 ){
      if( pDb->pBt ){
        sqlite3BtreeSetPagerFlags(pDb->pBt,
                 pDb->safety_level | (db->flags & 0x38) );
      }
      pDb++;
    }
  }
}
# 122403 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *actionName(u8 action){
  const char *zName;
  switch( action ){
    case 8: zName = "SET NULL"; break;
    case 9: zName = "SET DEFAULT"; break;
    case 10: zName = "CASCADE"; break;
    case 7: zName = "RESTRICT"; break;
    default: zName = "NO ACTION";
                      ((void)0); break;
  }
  return zName;
}
# 122423 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *sqlite3JournalModename(int eMode){
  static char * const azModeName[] = {
    "delete", "persist", "off", "truncate", "memory"

     , "wal"

  };
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  if( eMode==((int)(sizeof(azModeName)/sizeof(azModeName[0]))) ) return 0;
  return azModeName[eMode];
}




static const PragmaName *pragmaLocate(const char *zName){
  int upr, lwr, mid = 0, rc;
  lwr = 0;
  upr = ((int)(sizeof(aPragmaName)/sizeof(aPragmaName[0])))-1;
  while( lwr<=upr ){
    mid = (lwr+upr)/2;
    rc = sqlite3_stricmp(zName, aPragmaName[mid].zName);
    if( rc==0 ) break;
    if( rc<0 ){
      upr = mid - 1;
    }else{
      lwr = mid + 1;
    }
  }
  return lwr>upr ? 0 : &aPragmaName[mid];
}
# 122469 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int integrityCheckResultRow(Vdbe *v){
  int addr;
  sqlite3VdbeAddOp2(v, 81, 3, 1);
  addr = sqlite3VdbeAddOp3(v, 47, 1, sqlite3VdbeCurrentAddr(v)+2, 1);
  ;
  sqlite3VdbeAddOp0(v, 69);
  return addr;
}
# 122493 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Pragma(
  Parse *pParse,
  Token *pId1,
  Token *pId2,
  Token *pValue,
  int minusFlag
){
  char *zLeft = 0;
  char *zRight = 0;
  const char *zDb = 0;
  Token *pId;
  char *aFcntl[4];
  int iDb;
  int rc;
  sqlite3 *db = pParse->db;
  Db *pDb;
  Vdbe *v = sqlite3GetVdbe(pParse);
  const PragmaName *pPragma;

  if( v==0 ) return;
  sqlite3VdbeRunOnlyOnce(v);
  pParse->nMem = 2;



  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);
  if( iDb<0 ) return;
  pDb = &db->aDb[iDb];




  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){
    return;
  }

  zLeft = sqlite3NameFromToken(db, pId);
  if( !zLeft ) return;
  if( minusFlag ){
    zRight = sqlite3MPrintf(db, "-%T", pValue);
  }else{
    zRight = sqlite3NameFromToken(db, pValue);
  }

  ((void)0);
  zDb = pId2->n>0 ? pDb->zDbSName : 0;
  if( sqlite3AuthCheck(pParse, 19, zLeft, zRight, zDb) ){
    goto pragma_out;
  }
# 122558 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  aFcntl[0] = 0;
  aFcntl[1] = zLeft;
  aFcntl[2] = zRight;
  aFcntl[3] = 0;
  db->busyHandler.nBusy = 0;
  rc = sqlite3_file_control(db, zDb, 14, (void*)aFcntl);
  if( rc==0 ){
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, aFcntl[0], ((sqlite3_destructor_type)-1));
    returnSingleText(v, aFcntl[0]);
    sqlite3_free(aFcntl[0]);
    goto pragma_out;
  }
  if( rc!=12 ){
    if( aFcntl[0] ){
      sqlite3ErrorMsg(pParse, "%s", aFcntl[0]);
      sqlite3_free(aFcntl[0]);
    }
    pParse->nErr++;
    pParse->rc = rc;
    goto pragma_out;
  }


  pPragma = pragmaLocate(zLeft);
  if( pPragma==0 ) goto pragma_out;


  if( (pPragma->mPragFlg & 0x01)!=0 ){
    if( sqlite3ReadSchema(pParse) ) goto pragma_out;
  }


  if( (pPragma->mPragFlg & 0x02)==0
   && ((pPragma->mPragFlg & 0x04)==0 || zRight==0)
  ){
    setPragmaResultColumnNames(v, pPragma);
  }


  switch( pPragma->ePragTyp ){
# 122617 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 11: {
    static const int iLn = 0;
    static const VdbeOpList getCacheSize[] = {
      { 2, 0, 0, 0},
      { 94, 0, 1, 3},
      { 47, 1, 8, 0},
      { 70, 0, 2, 0},
      { 104, 1, 2, 1},
      { 47, 1, 8, 0},
      { 70, 0, 1, 0},
      { 170, 0, 0, 0},
      { 81, 1, 1, 0},
    };
    VdbeOp *aOp;
    sqlite3VdbeUsesBtree(v, iDb);
    if( !zRight ){
      pParse->nMem += 2;
      ;
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(getCacheSize)/sizeof(getCacheSize[0]))), getCacheSize, iLn);
      if( (0) ) break;
      aOp[0].p1 = iDb;
      aOp[1].p1 = iDb;
      aOp[6].p1 = -2000;
    }else{
      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));
      sqlite3BeginWriteOperation(pParse, 0, iDb);
      sqlite3VdbeAddOp3(v, 95, iDb, 3, size);
      ((void)0);
      pDb->pSchema->cache_size = size;
      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
    }
    break;
  }
# 122662 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 28: {
    Btree *pBt = pDb->pBt;
    ((void)0);
    if( !zRight ){
      int size = (pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;
      returnSingleInt(v, size);
    }else{



      db->nextPagesize = sqlite3Atoi(zRight);
      if( 7==sqlite3BtreeSetPageSize(pBt, db->nextPagesize,-1,0) ){
        sqlite3OomFault(db);
      }
    }
    break;
  }
# 122688 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 30: {
    Btree *pBt = pDb->pBt;
    int b = -1;
    ((void)0);
    if( zRight ){
      if( sqlite3_stricmp(zRight, "fast")==0 ){
        b = 2;
      }else{
        b = sqlite3GetBoolean(zRight, 0);
      }
    }
    if( pId2->n==0 && b>=0 ){
      int ii;
      for(ii=0; ii<db->nDb; ii++){
        sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);
      }
    }
    b = sqlite3BtreeSecureDelete(pBt, b);
    returnSingleInt(v, b);
    break;
  }
# 122727 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 24: {
    int iReg;
    sqlite3CodeVerifySchema(pParse, iDb);
    iReg = ++pParse->nMem;
    if( (sqlite3UpperToLower[(unsigned char)(zLeft[0])])=='p' ){
      sqlite3VdbeAddOp2(v, 166, iDb, iReg);
    }else{
      sqlite3VdbeAddOp3(v, 167, iDb, iReg,
                        sqlite3AbsInt32(sqlite3Atoi(zRight)));
    }
    sqlite3VdbeAddOp2(v, 81, iReg, 1);
    break;
  }





  case 23: {
    const char *zRet = "normal";
    int eMode = getLockingMode(zRight);

    if( pId2->n==0 && eMode==-1 ){




      eMode = db->dfltLockMode;
    }else{
      Pager *pPager;
      if( pId2->n==0 ){
# 122766 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        int ii;
        ((void)0);
        for(ii=2; ii<db->nDb; ii++){
          pPager = sqlite3BtreePager(db->aDb[ii].pBt);
          sqlite3PagerLockingMode(pPager, eMode);
        }
        db->dfltLockMode = (u8)eMode;
      }
      pPager = sqlite3BtreePager(pDb->pBt);
      eMode = sqlite3PagerLockingMode(pPager, eMode);
    }

    ((void)0)
                                                   ;
    if( eMode==1 ){
      zRet = "exclusive";
    }
    returnSingleText(v, zRet);
    break;
  }






  case 20: {
    int eMode;
    int ii;

    if( zRight==0 ){


      eMode = (-1);
    }else{
      const char *zMode;
      int n = sqlite3Strlen30(zRight);
      for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){
        if( sqlite3_strnicmp(zRight, zMode, n)==0 ) break;
      }
      if( !zMode ){


        eMode = (-1);
      }
      if( eMode==2 && (db->flags & 0x10000000)!=0 ){


        eMode = (-1);
      }
    }
    if( eMode==(-1) && pId2->n==0 ){

      iDb = 0;
      pId2->n = 1;
    }
    for(ii=db->nDb-1; ii>=0; ii--){
      if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){
        sqlite3VdbeUsesBtree(v, ii);
        sqlite3VdbeAddOp3(v, 7, ii, 1, eMode);
      }
    }
    sqlite3VdbeAddOp2(v, 81, 1, 1);
    break;
  }







  case 21: {
    Pager *pPager = sqlite3BtreePager(pDb->pBt);
    i64 iLimit = -2;
    if( zRight ){
      sqlite3DecOrHexToI64(zRight, &iLimit);
      if( iLimit<-1 ) iLimit = -1;
    }
    iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);
    returnSingleInt(v, iLimit);
    break;
  }
# 122860 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 1: {
    Btree *pBt = pDb->pBt;
    ((void)0);
    if( !zRight ){
      returnSingleInt(v, sqlite3BtreeGetAutoVacuum(pBt));
    }else{
      int eAuto = getAutoVacuum(zRight);
      ((void)0);
      db->nextAutovac = (u8)eAuto;





      rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);
      if( rc==0 && (eAuto==1 || eAuto==2) ){





        static const int iLn = 0;
        static const VdbeOpList setMeta6[] = {
          { 2, 0, 1, 0},
          { 94, 0, 1, 4},
          { 18, 1, 0, 0},
          { 69, 0, 2, 0},
          { 95, 0, 7, 0},
        };
        VdbeOp *aOp;
        int iAddr = sqlite3VdbeCurrentAddr(v);
        ;
        aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(setMeta6)/sizeof(setMeta6[0]))), setMeta6, iLn);
        if( (0) ) break;
        aOp[0].p1 = iDb;
        aOp[1].p1 = iDb;
        aOp[2].p2 = iAddr+4;
        aOp[4].p1 = iDb;
        aOp[4].p3 = eAuto - 1;
        sqlite3VdbeUsesBtree(v, iDb);
      }
    }
    break;
  }
# 122912 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 16: {
    int iLimit, addr;
    if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){
      iLimit = 0x7fffffff;
    }
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    sqlite3VdbeAddOp2(v, 70, iLimit, 1);
    addr = sqlite3VdbeAddOp1(v, 59, iDb); ;
    sqlite3VdbeAddOp1(v, 81, 1);
    sqlite3VdbeAddOp2(v, 83, 1, -1);
    sqlite3VdbeAddOp2(v, 47, 1, addr); ;
    sqlite3VdbeJumpHere(v, addr);
    break;
  }
# 122940 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 4: {
    ((void)0);
    if( !zRight ){
      returnSingleInt(v, pDb->pSchema->cache_size);
    }else{
      int size = sqlite3Atoi(zRight);
      pDb->pSchema->cache_size = size;
      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
    }
    break;
  }
# 122974 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 5: {
    ((void)0);
    if( !zRight ){
      returnSingleInt(v,
         (db->flags & 0x00000020)==0 ? 0 :
            sqlite3BtreeSetSpillSize(pDb->pBt,0));
    }else{
      int size = 1;
      if( sqlite3GetInt32(zRight, &size) ){
        sqlite3BtreeSetSpillSize(pDb->pBt, size);
      }
      if( sqlite3GetBoolean(zRight, size!=0) ){
        db->flags |= 0x00000020;
      }else{
        db->flags &= ~(u64)0x00000020;
      }
      setAllPagerFlags(db);
    }
    break;
  }
# 123009 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 25: {
    sqlite3_int64 sz;

    ((void)0);
    if( zRight ){
      int ii;
      sqlite3DecOrHexToI64(zRight, &sz);
      if( sz<0 ) sz = sqlite3Config.szMmap;
      if( pId2->n==0 ) db->szMmap = sz;
      for(ii=db->nDb-1; ii>=0; ii--){
        if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){
          sqlite3BtreeSetMmapLimit(db->aDb[ii].pBt, sz);
        }
      }
    }
    sz = -1;
    rc = sqlite3_file_control(db, zDb, 18, &sz);




    if( rc==0 ){
      returnSingleInt(v, sz);
    }else if( rc!=12 ){
      pParse->nErr++;
      pParse->rc = rc;
    }
    break;
  }
# 123050 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 35: {
    if( !zRight ){
      returnSingleInt(v, db->temp_store);
    }else{
      changeTempStorage(pParse, zRight);
    }
    break;
  }
# 123069 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 36: {
    if( !zRight ){
      returnSingleText(v, sqlite3_temp_directory);
    }else{

      if( zRight[0] ){
        int res;
        rc = sqlite3OsAccess(db->pVfs, zRight, 1, &res);
        if( rc!=0 || res==0 ){
          sqlite3ErrorMsg(pParse, "not a writable directory");
          goto pragma_out;
        }
      }
      if( 1==0
       || (1==1 && db->temp_store<=1)
       || (1==2 && db->temp_store==1)
      ){
        invalidateTempStorage(pParse);
      }
      sqlite3_free(sqlite3_temp_directory);
      if( zRight[0] ){
        sqlite3_temp_directory = sqlite3_mprintf("%s", zRight);
      }else{
        sqlite3_temp_directory = 0;
      }

    }
    break;
  }
# 123147 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 22: {
    if( !zRight ){
      Pager *pPager = sqlite3BtreePager(pDb->pBt);
      char *proxy_file_path = ((void *)0);
      sqlite3_file *pFile = sqlite3PagerFile(pPager);
      sqlite3OsFileControlHint(pFile, 2,
                           &proxy_file_path);
      returnSingleText(v, proxy_file_path);
    }else{
      Pager *pPager = sqlite3BtreePager(pDb->pBt);
      sqlite3_file *pFile = sqlite3PagerFile(pPager);
      int res;
      if( zRight[0] ){
        res=sqlite3OsFileControl(pFile, 3,
                                     zRight);
      } else {
        res=sqlite3OsFileControl(pFile, 3,
                                     ((void *)0));
      }
      if( res!=0 ){
        sqlite3ErrorMsg(pParse, "failed to set lock proxy file");
        goto pragma_out;
      }
    }
    break;
  }
# 123184 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 33: {
    if( !zRight ){
      returnSingleInt(v, pDb->safety_level-1);
    }else{
      if( !db->autoCommit ){
        sqlite3ErrorMsg(pParse,
            "Safety level may not be changed inside a transaction");
      }else if( iDb!=1 ){
        int iLevel = (getSafetyLevel(zRight,0,1)+1) & 0x07;
        if( iLevel==0 ) iLevel = 1;
        pDb->safety_level = iLevel;
        pDb->bSyncSet = 1;
        setAllPagerFlags(db);
      }
    }
    break;
  }



  case 2: {
    if( zRight==0 ){
      setPragmaResultColumnNames(v, pPragma);
      returnSingleInt(v, (db->flags & pPragma->iArg)!=0 );
    }else{
      u64 mask = pPragma->iArg;
      if( db->autoCommit==0 ){


        mask &= ~(0x00004000);
      }







      if( sqlite3GetBoolean(zRight, 0) ){
        db->flags |= mask;
      }else{
        db->flags &= ~mask;
        if( mask==0x00080000 ) db->nDeferredImmCons = 0;
      }





      sqlite3VdbeAddOp0(v, 158);
      setAllPagerFlags(db);
    }
    break;
  }
# 123254 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 34: if( zRight ){
    Table *pTab;
    pTab = sqlite3LocateTable(pParse, 0x02, zRight, zDb);
    if( pTab ){
      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      int i, k;
      int nHidden = 0;
      Column *pCol;
      Index *pPk = sqlite3PrimaryKeyIndex(pTab);
      pParse->nMem = 7;
      sqlite3CodeVerifySchema(pParse, iTabDb);
      sqlite3ViewGetColumnNames(pParse, pTab);
      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
        int isHidden = (((pCol)->colFlags & 0x0002)!=0);
        if( isHidden && pPragma->iArg==0 ){
          nHidden++;
          continue;
        }
        if( (pCol->colFlags & 0x0001)==0 ){
          k = 0;
        }else if( pPk==0 ){
          k = 1;
        }else{
          for(k=1; k<=pTab->nCol && pPk->aiColumn[k-1]!=i; k++){}
        }
        ((void)0);
        sqlite3VdbeMultiLoad(v, 1, pPragma->iArg ? "issisii" : "issisi",
               i-nHidden,
               pCol->zName,
               sqlite3ColumnType(pCol,""),
               pCol->notNull ? 1 : 0,
               pCol->pDflt ? pCol->pDflt->u.zToken : 0,
               k,
               isHidden);
      }
    }
  }
  break;
# 123320 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 17: if( zRight ){
    Index *pIdx;
    Table *pTab;
    pIdx = sqlite3FindIndex(db, zRight, zDb);
    if( pIdx==0 ){



      pTab = sqlite3LocateTable(pParse, 0x02, zRight, zDb);
      if( pTab && !(((pTab)->tabFlags & 0x0020)==0) ){
        pIdx = sqlite3PrimaryKeyIndex(pTab);
      }
    }
    if( pIdx ){
      int iIdxDb = sqlite3SchemaToIndex(db, pIdx->pSchema);
      int i;
      int mx;
      if( pPragma->iArg ){

        mx = pIdx->nColumn;
        pParse->nMem = 6;
      }else{

        mx = pIdx->nKeyCol;
        pParse->nMem = 3;
      }
      pTab = pIdx->pTable;
      sqlite3CodeVerifySchema(pParse, iIdxDb);
      ((void)0);
      for(i=0; i<mx; i++){
        i16 cnum = pIdx->aiColumn[i];
        sqlite3VdbeMultiLoad(v, 1, "iisX", i, cnum,
                             cnum<0 ? 0 : pTab->aCol[cnum].zName);
        if( pPragma->iArg ){
          sqlite3VdbeMultiLoad(v, 4, "isiX",
            pIdx->aSortOrder[i],
            pIdx->azColl[i],
            i<pIdx->nKeyCol);
        }
        sqlite3VdbeAddOp2(v, 81, 1, pParse->nMem);
      }
    }
  }
  break;

  case 18: if( zRight ){
    Index *pIdx;
    Table *pTab;
    int i;
    pTab = sqlite3FindTable(db, zRight, zDb);
    if( pTab ){
      int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      pParse->nMem = 5;
      sqlite3CodeVerifySchema(pParse, iTabDb);
      for(pIdx=pTab->pIndex, i=0; pIdx; pIdx=pIdx->pNext, i++){
        const char *azOrigin[] = { "c", "u", "pk" };
        sqlite3VdbeMultiLoad(v, 1, "isisi",
           i,
           pIdx->zName,
           ((pIdx)->onError!=0),
           azOrigin[pIdx->idxType],
           pIdx->pPartIdxWhere!=0);
      }
    }
  }
  break;

  case 10: {
    int i;
    pParse->nMem = 3;
    for(i=0; i<db->nDb; i++){
      if( db->aDb[i].pBt==0 ) continue;
      ((void)0);
      sqlite3VdbeMultiLoad(v, 1, "iss",
         i,
         db->aDb[i].zDbSName,
         sqlite3BtreeGetFilename(db->aDb[i].pBt));
    }
  }
  break;

  case 7: {
    int i = 0;
    HashElem *p;
    pParse->nMem = 2;
    for(p=((&db->aCollSeq)->first); p; p=((p)->next)){
      CollSeq *pColl = (CollSeq *)((p)->data);
      sqlite3VdbeMultiLoad(v, 1, "is", i++, pColl->zName);
    }
  }
  break;


  case 15: {
    int i;
    HashElem *j;
    FuncDef *p;
    pParse->nMem = 2;
    for(i=0; i<23; i++){
      for(p=sqlite3BuiltinFunctions.a[i]; p; p=p->u.pHash ){
        if( p->funcFlags & 0x00040000 ) continue;
        sqlite3VdbeMultiLoad(v, 1, "si", p->zName, 1);
      }
    }
    for(j=((&db->aFunc)->first); j; j=((j)->next)){
      p = (FuncDef*)((j)->data);
      sqlite3VdbeMultiLoad(v, 1, "si", p->zName, 0);
    }
  }
  break;


  case 26: {
    HashElem *j;
    pParse->nMem = 1;
    for(j=((&db->aModule)->first); j; j=((j)->next)){
      Module *pMod = (Module*)((j)->data);
      sqlite3VdbeMultiLoad(v, 1, "s", pMod->zName);
    }
  }
  break;


  case 29: {
    int i;
    for(i=0; i<((int)(sizeof(aPragmaName)/sizeof(aPragmaName[0]))); i++){
      sqlite3VdbeMultiLoad(v, 1, "s", aPragmaName[i].zName);
    }
  }
  break;





  case 14: if( zRight ){
    FKey *pFK;
    Table *pTab;
    pTab = sqlite3FindTable(db, zRight, zDb);
    if( pTab ){
      pFK = pTab->pFKey;
      if( pFK ){
        int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
        int i = 0;
        pParse->nMem = 8;
        sqlite3CodeVerifySchema(pParse, iTabDb);
        while(pFK){
          int j;
          for(j=0; j<pFK->nCol; j++){
            sqlite3VdbeMultiLoad(v, 1, "iissssss",
                   i,
                   j,
                   pFK->zTo,
                   pTab->aCol[pFK->aCol[j].iFrom].zName,
                   pFK->aCol[j].zCol,
                   actionName(pFK->aAction[1]),
                   actionName(pFK->aAction[0]),
                   "NONE");
          }
          ++i;
          pFK = pFK->pNextFrom;
        }
      }
    }
  }
  break;




  case 13: {
    FKey *pFK;
    Table *pTab;
    Table *pParent;
    Index *pIdx;
    int i;
    int j;
    HashElem *k;
    int x;
    int regResult;
    int regKey;
    int regRow;
    int addrTop;
    int addrOk;
    int *aiCols;

    regResult = pParse->nMem+1;
    pParse->nMem += 4;
    regKey = ++pParse->nMem;
    regRow = ++pParse->nMem;
    k = ((&db->aDb[iDb].pSchema->tblHash)->first);
    while( k ){
      int iTabDb;
      if( zRight ){
        pTab = sqlite3LocateTable(pParse, 0, zRight, zDb);
        k = 0;
      }else{
        pTab = (Table*)((k)->data);
        k = ((k)->next);
      }
      if( pTab==0 || pTab->pFKey==0 ) continue;
      iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
      sqlite3CodeVerifySchema(pParse, iTabDb);
      sqlite3TableLock(pParse, iTabDb, pTab->tnum, 0, pTab->zName);
      if( pTab->nCol+regRow>pParse->nMem ) pParse->nMem = pTab->nCol + regRow;
      sqlite3OpenTable(pParse, 0, iTabDb, pTab, 97);
      sqlite3VdbeLoadString(v, regResult, pTab->zName);
      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){
        pParent = sqlite3FindTable(db, pFK->zTo, zDb);
        if( pParent==0 ) continue;
        pIdx = 0;
        sqlite3TableLock(pParse, iTabDb, pParent->tnum, 0, pParent->zName);
        x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, 0);
        if( x==0 ){
          if( pIdx==0 ){
            sqlite3OpenTable(pParse, i, iTabDb, pParent, 97);
          }else{
            sqlite3VdbeAddOp3(v, 97, i, pIdx->tnum, iTabDb);
            sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
          }
        }else{
          k = 0;
          break;
        }
      }
      ((void)0);
      if( pFK ) break;
      if( pParse->nTab<i ) pParse->nTab = i;
      addrTop = sqlite3VdbeAddOp1(v, 36, 0); ;
      for(i=1, pFK=pTab->pFKey; pFK; i++, pFK=pFK->pNextFrom){
        pParent = sqlite3FindTable(db, pFK->zTo, zDb);
        pIdx = 0;
        aiCols = 0;
        if( pParent ){
          x = sqlite3FkLocateIndex(pParse, pParent, pFK, &pIdx, &aiCols);
          ((void)0);
        }
        addrOk = sqlite3VdbeMakeLabel(pParse);





        for(j=0; j<pFK->nCol; j++){
          int iCol = aiCols ? aiCols[j] : pFK->aCol[j].iFrom;
          sqlite3ExprCodeGetColumnOfTable(v, pTab, 0, iCol, regRow+j);
          sqlite3VdbeAddOp2(v, 50, regRow+j, addrOk); ;
        }



        if( pIdx ){
          sqlite3VdbeAddOp4(v, 92, regRow, pFK->nCol, regKey,
              sqlite3IndexAffinityStr(db,pIdx), pFK->nCol);
          sqlite3VdbeAddOp4Int(v, 29, i, addrOk, regKey, 0);
          ;
        }else if( pParent ){
          int jmp = sqlite3VdbeCurrentAddr(v)+2;
          sqlite3VdbeAddOp3(v, 30, i, jmp, regRow); ;
          sqlite3VdbeGoto(v, addrOk);
          ((void)0);
        }


        if( (((pTab)->tabFlags & 0x0020)==0) ){
          sqlite3VdbeAddOp2(v, 128, 0, regResult+1);
        }else{
          sqlite3VdbeAddOp2(v, 73, 0, regResult+1);
        }
        sqlite3VdbeMultiLoad(v, regResult+2, "siX", pFK->zTo, i-1);
        sqlite3VdbeAddOp2(v, 81, regResult, 4);
        sqlite3VdbeResolveLabel(v, addrOk);
        sqlite3DbFree(db, aiCols);
      }
      sqlite3VdbeAddOp2(v, 5, 0, addrTop+1); ;
      sqlite3VdbeJumpHere(v, addrTop);
    }
  }
  break;







  case 6: {
    if( zRight ){
      sqlite3RegisterLikeFunctions(db, sqlite3GetBoolean(zRight, 0));
    }
  }
  break;



#define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100
# 123631 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 19: {
    int i, j, addr, mxErr;

    int isQuick = ((sqlite3UpperToLower[(unsigned char)(zLeft[0])])=='q');
# 123645 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
    ((void)0);
    if( pId2->z==0 ) iDb = -1;


    pParse->nMem = 6;


    mxErr = 100;
    if( zRight ){
      sqlite3GetInt32(zRight, &mxErr);
      if( mxErr<=0 ){
        mxErr = 100;
      }
    }
    sqlite3VdbeAddOp2(v, 70, mxErr-1, 1);


    for(i=0; i<db->nDb; i++){
      HashElem *x;
      Hash *pTbls;
      int *aRoot;
      int cnt = 0;
      int mxIdx = 0;

      if( 0 && i==1 ) continue;
      if( iDb>=0 && i!=iDb ) continue;

      sqlite3CodeVerifySchema(pParse, i);






      ((void)0);
      pTbls = &db->aDb[i].pSchema->tblHash;
      for(cnt=0, x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx;
        int nIdx;
        if( (((pTab)->tabFlags & 0x0020)==0) ) cnt++;
        for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){ cnt++; }
        if( nIdx>mxIdx ) mxIdx = nIdx;
      }
      aRoot = sqlite3DbMallocRawNN(db, sizeof(int)*(cnt+1));
      if( aRoot==0 ) break;
      for(cnt=0, x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx;
        if( (((pTab)->tabFlags & 0x0020)==0) ) aRoot[++cnt] = pTab->tnum;
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          aRoot[++cnt] = pIdx->tnum;
        }
      }
      aRoot[0] = cnt;


      pParse->nMem = ((pParse->nMem)>(8+mxIdx)?(pParse->nMem):(8+mxIdx));
      sqlite3ClearTempRegCache(pParse);


      sqlite3VdbeAddOp4(v, 146, 2, cnt, 1, (char*)aRoot,(-15));
      sqlite3VdbeChangeP5(v, (u8)i);
      addr = sqlite3VdbeAddOp1(v, 50, 2); ;
      sqlite3VdbeAddOp4(v, 113, 0, 3, 0,
         sqlite3MPrintf(db, "*** in database %s ***\n", db->aDb[i].zDbSName),
         (-7));
      sqlite3VdbeAddOp3(v, 108, 2, 3, 3);
      integrityCheckResultRow(v);
      sqlite3VdbeJumpHere(v, addr);



      for(x=((pTbls)->first); x; x=((x)->next)){
        Table *pTab = ((x)->data);
        Index *pIdx, *pPk;
        Index *pPrior = 0;
        int loopTop;
        int iDataCur, iIdxCur;
        int r1 = -1;

        if( pTab->tnum<1 ) continue;
        pPk = (((pTab)->tabFlags & 0x0020)==0) ? 0 : sqlite3PrimaryKeyIndex(pTab);
        sqlite3OpenTableAndIndices(pParse, pTab, 97, 0,
                                   1, 0, &iDataCur, &iIdxCur);



        sqlite3VdbeAddOp2(v, 70, 0, 7);
        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
          sqlite3VdbeAddOp2(v, 70, 0, 8+j);
        }
        ((void)0);
        ((void)0);
        sqlite3VdbeAddOp2(v, 36, iDataCur, 0); ;
        loopTop = sqlite3VdbeAddOp2(v, 83, 7, 1);
        if( !isQuick ){

          sqlite3VdbeAddOp3(v, 90, iDataCur, pTab->nCol-1, 3);
          sqlite3VdbeChangeP5(v, 0x80);
        }

        for(j=0; j<pTab->nCol; j++){
          char *zErr;
          int jmp2;
          if( j==pTab->iPKey ) continue;
          if( pTab->aCol[j].notNull==0 ) continue;
          sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, j, 3);
          sqlite3VdbeChangeP5(v, 0x80);
          jmp2 = sqlite3VdbeAddOp1(v, 51, 3); ;
          zErr = sqlite3MPrintf(db, "NULL value in %s.%s", pTab->zName,
                              pTab->aCol[j].zName);
          sqlite3VdbeAddOp4(v, 113, 0, 3, 0, zErr, (-7));
          integrityCheckResultRow(v);
          sqlite3VdbeJumpHere(v, jmp2);
        }

        if( pTab->pCheck && (db->flags & 0x00000200)==0 ){
          ExprList *pCheck = sqlite3ExprListDup(db, pTab->pCheck, 0);
          if( db->mallocFailed==0 ){
            int addrCkFault = sqlite3VdbeMakeLabel(pParse);
            int addrCkOk = sqlite3VdbeMakeLabel(pParse);
            char *zErr;
            int k;
            pParse->iSelfTab = iDataCur + 1;
            for(k=pCheck->nExpr-1; k>0; k--){
              sqlite3ExprIfFalse(pParse, pCheck->a[k].pExpr, addrCkFault, 0);
            }
            sqlite3ExprIfTrue(pParse, pCheck->a[0].pExpr, addrCkOk,
                0x10);
            sqlite3VdbeResolveLabel(v, addrCkFault);
            pParse->iSelfTab = 0;
            zErr = sqlite3MPrintf(db, "CHECK constraint failed in %s",
                pTab->zName);
            sqlite3VdbeAddOp4(v, 113, 0, 3, 0, zErr, (-7));
            integrityCheckResultRow(v);
            sqlite3VdbeResolveLabel(v, addrCkOk);
          }
          sqlite3ExprListDelete(db, pCheck);
        }
        if( !isQuick ){

          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
            int jmp2, jmp3, jmp4, jmp5;
            int ckUniq = sqlite3VdbeMakeLabel(pParse);
            if( pPk==pIdx ) continue;
            r1 = sqlite3GenerateIndexKey(pParse, pIdx, iDataCur, 0, 0, &jmp3,
                                         pPrior, r1);
            pPrior = pIdx;
            sqlite3VdbeAddOp2(v, 83, 8+j, 1);

            jmp2 = sqlite3VdbeAddOp4Int(v, 29, iIdxCur+j, ckUniq, r1,
                                        pIdx->nColumn); ;
            sqlite3VdbeLoadString(v, 3, "row ");
            sqlite3VdbeAddOp3(v, 108, 7, 3, 3);
            sqlite3VdbeLoadString(v, 4, " missing from index ");
            sqlite3VdbeAddOp3(v, 108, 4, 3, 3);
            jmp5 = sqlite3VdbeLoadString(v, 4, pIdx->zName);
            sqlite3VdbeAddOp3(v, 108, 4, 3, 3);
            jmp4 = integrityCheckResultRow(v);
            sqlite3VdbeJumpHere(v, jmp2);



            if( ((pIdx)->onError!=0) ){
              int uniqOk = sqlite3VdbeMakeLabel(pParse);
              int jmp6;
              int kk;
              for(kk=0; kk<pIdx->nKeyCol; kk++){
                int iCol = pIdx->aiColumn[kk];
                ((void)0);
                if( iCol>=0 && pTab->aCol[iCol].notNull ) continue;
                sqlite3VdbeAddOp2(v, 50, r1+kk, uniqOk);
                ;
              }
              jmp6 = sqlite3VdbeAddOp1(v, 5, iIdxCur+j); ;
              sqlite3VdbeGoto(v, uniqOk);
              sqlite3VdbeJumpHere(v, jmp6);
              sqlite3VdbeAddOp4Int(v, 38, iIdxCur+j, uniqOk, r1,
                                   pIdx->nKeyCol); ;
              sqlite3VdbeLoadString(v, 3, "non-unique entry in index ");
              sqlite3VdbeGoto(v, jmp5);
              sqlite3VdbeResolveLabel(v, uniqOk);
            }
            sqlite3VdbeJumpHere(v, jmp4);
            sqlite3ResolvePartIdxLabel(pParse, jmp3);
          }
        }
        sqlite3VdbeAddOp2(v, 5, iDataCur, loopTop); ;
        sqlite3VdbeJumpHere(v, loopTop-1);

        if( !isQuick ){
          sqlite3VdbeLoadString(v, 2, "wrong # of entries in index ");
          for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){
            if( pPk==pIdx ) continue;
            sqlite3VdbeAddOp2(v, 93, iIdxCur+j, 3);
            addr = sqlite3VdbeAddOp3(v, 53, 8+j, 0, 3); ;
            sqlite3VdbeChangeP5(v, 0x90);
            sqlite3VdbeLoadString(v, 4, pIdx->zName);
            sqlite3VdbeAddOp3(v, 108, 4, 2, 3);
            integrityCheckResultRow(v);
            sqlite3VdbeJumpHere(v, addr);
          }
        }

      }
    }
    {
      static const int iLn = 0;
      static const VdbeOpList endCode[] = {
        { 83, 1, 0, 0},
        { 48, 1, 4, 0},
        { 113, 0, 3, 0},
        { 81, 3, 1, 0},
        { 69, 0, 0, 0},
        { 113, 0, 3, 0},
        { 11, 0, 3, 0},
      };
      VdbeOp *aOp;

      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(endCode)/sizeof(endCode[0]))), endCode, iLn);
      if( aOp ){
        aOp[0].p2 = 1-mxErr;
        aOp[2].p4type = (-1);
        aOp[2].p4.z = "ok";
        aOp[5].p4type = (-1);
        aOp[5].p4.z = (char*)sqlite3ErrStr(11);
      }
      sqlite3VdbeChangeP3(v, 0, sqlite3VdbeCurrentAddr(v)-2);
    }
  }
  break;
# 123903 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 12: {
    static const struct EncName {
      char *zName;
      u8 enc;
    } encnames[] = {
      { "UTF8", 1 },
      { "UTF-8", 1 },
      { "UTF-16le", 2 },
      { "UTF-16be", 3 },
      { "UTF16le", 2 },
      { "UTF16be", 3 },
      { "UTF-16", 0 },
      { "UTF16", 0 },
      { 0, 0 }
    };
    const struct EncName *pEnc;
    if( !zRight ){
      if( sqlite3ReadSchema(pParse) ) goto pragma_out;
      ((void)0);
      ((void)0);
      ((void)0);
      returnSingleText(v, encnames[((pParse->db)->enc)].zName);
    }else{





      if(
        !((((db)->aDb[0].pSchema->schemaFlags&(0x0001))==(0x0001))) ||
        (((db)->aDb[0].pSchema->schemaFlags&(0x0004))==(0x0004))
      ){
        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){
          if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){
            ((db)->aDb[0].pSchema->enc) = ((db)->enc) =
                pEnc->enc ? pEnc->enc : 2;
            break;
          }
        }
        if( !pEnc->zName ){
          sqlite3ErrorMsg(pParse, "unsupported encoding: %s", zRight);
        }
      }
    }
  }
  break;
# 123984 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 0: {
    int iCookie = pPragma->iArg;
    sqlite3VdbeUsesBtree(v, iDb);
    if( zRight && (pPragma->mPragFlg & 0x08)==0 ){

      static const VdbeOpList setCookie[] = {
        { 2, 0, 1, 0},
        { 95, 0, 0, 0},
      };
      VdbeOp *aOp;
      ;
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(setCookie)/sizeof(setCookie[0]))), setCookie, 0);
      if( (0) ) break;
      aOp[0].p1 = iDb;
      aOp[1].p1 = iDb;
      aOp[1].p2 = iCookie;
      aOp[1].p3 = sqlite3Atoi(zRight);
    }else{

      static const VdbeOpList readCookie[] = {
        { 2, 0, 0, 0},
        { 94, 0, 1, 0},
        { 81, 1, 1, 0}
      };
      VdbeOp *aOp;
      ;
      aOp = sqlite3VdbeAddOpList(v, ((int)(sizeof(readCookie)/sizeof(readCookie[0]))),readCookie,0);
      if( (0) ) break;
      aOp[0].p1 = iDb;
      aOp[1].p1 = iDb;
      aOp[1].p3 = iCookie;
      sqlite3VdbeReusable(v);
    }
  }
  break;
# 124028 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 8: {
    int i = 0;
    const char *zOpt;
    pParse->nMem = 1;
    while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){
      sqlite3VdbeLoadString(v, 1, zOpt);
      sqlite3VdbeAddOp2(v, 81, 1, 1);
    }
    sqlite3VdbeReusable(v);
  }
  break;
# 124047 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 39: {
    int iBt = (pId2->z?iDb:10);
    int eMode = 0;
    if( zRight ){
      if( sqlite3StrICmp(zRight, "full")==0 ){
        eMode = 1;
      }else if( sqlite3StrICmp(zRight, "restart")==0 ){
        eMode = 2;
      }else if( sqlite3StrICmp(zRight, "truncate")==0 ){
        eMode = 3;
      }
    }
    pParse->nMem = 3;
    sqlite3VdbeAddOp3(v, 6, iBt, eMode, 1);
    sqlite3VdbeAddOp2(v, 81, 1, 3);
  }
  break;
# 124073 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 38: {
    if( zRight ){
      sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));
    }
    returnSingleInt(v,
       db->xWalCallback==sqlite3WalDefaultHook ?
           ((int)(long int)(db->pWalArg)) : 0);
  }
  break;
# 124091 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 31: {
    sqlite3_db_release_memory(db);
    break;
  }
# 124150 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 27: {
    int iDbLast;
    int iTabCur;
    HashElem *k;
    Schema *pSchema;
    Table *pTab;
    Index *pIdx;
    LogEst szThreshold;
    char *zSubSql;
    u32 opMask;

    if( zRight ){
      opMask = (u32)sqlite3Atoi(zRight);
      if( (opMask & 0x02)==0 ) break;
    }else{
      opMask = 0xfffe;
    }
    iTabCur = pParse->nTab++;
    for(iDbLast = zDb?iDb:db->nDb-1; iDb<=iDbLast; iDb++){
      if( iDb==1 ) continue;
      sqlite3CodeVerifySchema(pParse, iDb);
      pSchema = db->aDb[iDb].pSchema;
      for(k=((&pSchema->tblHash)->first); k; k=((k)->next)){
        pTab = (Table*)((k)->data);




        if( (pTab->tabFlags & 0x0100)==0 ) continue;


        szThreshold = pTab->nRowLogEst + 46; ((void)0);
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          if( !pIdx->hasStat1 ){
            szThreshold = 0;
            break;
          }
        }
        if( szThreshold ){
          sqlite3OpenTable(pParse, iTabCur, iDb, pTab, 97);
          sqlite3VdbeAddOp3(v, 33, iTabCur,
                         sqlite3VdbeCurrentAddr(v)+2+(opMask&1), szThreshold);
          ;
        }
        zSubSql = sqlite3MPrintf(db, "ANALYZE \"%w\".\"%w\"",
                                 db->aDb[iDb].zDbSName, pTab->zName);
        if( opMask & 0x01 ){
          int r1 = sqlite3GetTempReg(pParse);
          sqlite3VdbeAddOp4(v, 113, 0, r1, 0, zSubSql, (-7));
          sqlite3VdbeAddOp2(v, 81, r1, 1);
        }else{
          sqlite3VdbeAddOp4(v, 140, 0, 0, 0, zSubSql, (-7));
        }
      }
    }
    sqlite3VdbeAddOp0(v, 158);
    break;
  }
# 124218 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
                                default: {
    ((void)0);
    if( zRight ){
      sqlite3_busy_timeout(db, sqlite3Atoi(zRight));
    }
    returnSingleInt(v, db->busyTimeout);
    break;
  }
# 124238 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 32: {
    sqlite3_int64 N;
    if( zRight && sqlite3DecOrHexToI64(zRight, &N)==0 ){
      sqlite3_soft_heap_limit64(N);
    }
    returnSingleInt(v, sqlite3_soft_heap_limit64(-1));
    break;
  }
# 124254 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  case 37: {
    sqlite3_int64 N;
    if( zRight
     && sqlite3DecOrHexToI64(zRight, &N)==0
     && N>=0
    ){
      sqlite3_limit(db, 11, (int)(N&0x7fffffff));
    }
    returnSingleInt(v, sqlite3_limit(db, 11, -1));
    break;
  }
# 124351 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }






  if( (pPragma->mPragFlg & 0x04) && zRight ){
    ;
  }

pragma_out:
  sqlite3DbFree(db, zLeft);
  sqlite3DbFree(db, zRight);
}





typedef struct PragmaVtab PragmaVtab;
typedef struct PragmaVtabCursor PragmaVtabCursor;
struct PragmaVtab {
  sqlite3_vtab base;
  sqlite3 *db;
  const PragmaName *pName;
  u8 nHidden;
  u8 iHidden;
};
struct PragmaVtabCursor {
  sqlite3_vtab_cursor base;
  sqlite3_stmt *pPragma;
  sqlite_int64 iRowid;
  char *azArg[2];
};




static int pragmaVtabConnect(
  sqlite3 *db,
  void *pAux,
  int argc, const char *const*argv,
  sqlite3_vtab **ppVtab,
  char **pzErr
){
  const PragmaName *pPragma = (const PragmaName*)pAux;
  PragmaVtab *pTab = 0;
  int rc;
  int i, j;
  char cSep = '(';
  StrAccum acc;
  char zBuf[200];

  (void)(argc);
  (void)(argv);
  sqlite3StrAccumInit(&acc, 0, zBuf, sizeof(zBuf), 0);
  sqlite3_str_appendall(&acc, "CREATE TABLE x");
  for(i=0, j=pPragma->iPragCName; i<pPragma->nPragCName; i++, j++){
    sqlite3_str_appendf(&acc, "%c\"%s\"", cSep, pragCName[j]);
    cSep = ',';
  }
  if( i==0 ){
    sqlite3_str_appendf(&acc, "(\"%s\"", pPragma->zName);
    i++;
  }
  j = 0;
  if( pPragma->mPragFlg & 0x20 ){
    sqlite3_str_appendall(&acc, ",arg HIDDEN");
    j++;
  }
  if( pPragma->mPragFlg & (0x40|0x80) ){
    sqlite3_str_appendall(&acc, ",schema HIDDEN");
    j++;
  }
  sqlite3_str_append(&acc, ")", 1);
  sqlite3StrAccumFinish(&acc);
  ((void)0);
  rc = sqlite3_declare_vtab(db, zBuf);
  if( rc==0 ){
    pTab = (PragmaVtab*)sqlite3_malloc(sizeof(PragmaVtab));
    if( pTab==0 ){
      rc = 7;
    }else{
      memset(pTab, 0, sizeof(PragmaVtab));
      pTab->pName = pPragma;
      pTab->db = db;
      pTab->iHidden = i;
      pTab->nHidden = j;
    }
  }else{
    *pzErr = sqlite3_mprintf("%s", sqlite3_errmsg(db));
  }

  *ppVtab = (sqlite3_vtab*)pTab;
  return rc;
}




static int pragmaVtabDisconnect(sqlite3_vtab *pVtab){
  PragmaVtab *pTab = (PragmaVtab*)pVtab;
  sqlite3_free(pTab);
  return 0;
}
# 124465 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pragmaVtabBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){
  PragmaVtab *pTab = (PragmaVtab*)tab;
  const struct sqlite3_index_constraint *pConstraint;
  int i, j;
  int seen[2];

  pIdxInfo->estimatedCost = (double)1;
  if( pTab->nHidden==0 ){ return 0; }
  pConstraint = pIdxInfo->aConstraint;
  seen[0] = 0;
  seen[1] = 0;
  for(i=0; i<pIdxInfo->nConstraint; i++, pConstraint++){
    if( pConstraint->usable==0 ) continue;
    if( pConstraint->op!=2 ) continue;
    if( pConstraint->iColumn < pTab->iHidden ) continue;
    j = pConstraint->iColumn - pTab->iHidden;
    ((void)0);
    seen[j] = i+1;
  }
  if( seen[0]==0 ){
    pIdxInfo->estimatedCost = (double)2147483647;
    pIdxInfo->estimatedRows = 2147483647;
    return 0;
  }
  j = seen[0]-1;
  pIdxInfo->aConstraintUsage[j].argvIndex = 1;
  pIdxInfo->aConstraintUsage[j].omit = 1;
  if( seen[1]==0 ) return 0;
  pIdxInfo->estimatedCost = (double)20;
  pIdxInfo->estimatedRows = 20;
  j = seen[1]-1;
  pIdxInfo->aConstraintUsage[j].argvIndex = 2;
  pIdxInfo->aConstraintUsage[j].omit = 1;
  return 0;
}


static int pragmaVtabOpen(sqlite3_vtab *pVtab, sqlite3_vtab_cursor **ppCursor){
  PragmaVtabCursor *pCsr;
  pCsr = (PragmaVtabCursor*)sqlite3_malloc(sizeof(*pCsr));
  if( pCsr==0 ) return 7;
  memset(pCsr, 0, sizeof(PragmaVtabCursor));
  pCsr->base.pVtab = pVtab;
  *ppCursor = &pCsr->base;
  return 0;
}


static void pragmaVtabCursorClear(PragmaVtabCursor *pCsr){
  int i;
  sqlite3_finalize(pCsr->pPragma);
  pCsr->pPragma = 0;
  for(i=0; i<((int)(sizeof(pCsr->azArg)/sizeof(pCsr->azArg[0]))); i++){
    sqlite3_free(pCsr->azArg[i]);
    pCsr->azArg[i] = 0;
  }
}


static int pragmaVtabClose(sqlite3_vtab_cursor *cur){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)cur;
  pragmaVtabCursorClear(pCsr);
  sqlite3_free(pCsr);
  return 0;
}


static int pragmaVtabNext(sqlite3_vtab_cursor *pVtabCursor){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  int rc = 0;


  pCsr->iRowid++;
  ((void)0);
  if( 100!=sqlite3_step(pCsr->pPragma) ){
    rc = sqlite3_finalize(pCsr->pPragma);
    pCsr->pPragma = 0;
    pragmaVtabCursorClear(pCsr);
  }
  return rc;
}




static int pragmaVtabFilter(
  sqlite3_vtab_cursor *pVtabCursor,
  int idxNum, const char *idxStr,
  int argc, sqlite3_value **argv
){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);
  int rc;
  int i, j;
  StrAccum acc;
  char *zSql;

  (void)(idxNum);
  (void)(idxStr);
  pragmaVtabCursorClear(pCsr);
  j = (pTab->pName->mPragFlg & 0x20)!=0 ? 0 : 1;
  for(i=0; i<argc; i++, j++){
    const char *zText = (const char*)sqlite3_value_text(argv[i]);
    ((void)0);
    ((void)0);
    if( zText ){
      pCsr->azArg[j] = sqlite3_mprintf("%s", zText);
      if( pCsr->azArg[j]==0 ){
        return 7;
      }
    }
  }
  sqlite3StrAccumInit(&acc, 0, 0, 0, pTab->db->aLimit[1]);
  sqlite3_str_appendall(&acc, "PRAGMA ");
  if( pCsr->azArg[1] ){
    sqlite3_str_appendf(&acc, "%Q.", pCsr->azArg[1]);
  }
  sqlite3_str_appendall(&acc, pTab->pName->zName);
  if( pCsr->azArg[0] ){
    sqlite3_str_appendf(&acc, "=%Q", pCsr->azArg[0]);
  }
  zSql = sqlite3StrAccumFinish(&acc);
  if( zSql==0 ) return 7;
  rc = sqlite3_prepare_v2(pTab->db, zSql, -1, &pCsr->pPragma, 0);
  sqlite3_free(zSql);
  if( rc!=0 ){
    pTab->base.zErrMsg = sqlite3_mprintf("%s", sqlite3_errmsg(pTab->db));
    return rc;
  }
  return pragmaVtabNext(pVtabCursor);
}




static int pragmaVtabEof(sqlite3_vtab_cursor *pVtabCursor){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  return (pCsr->pPragma==0);
}




static int pragmaVtabColumn(
  sqlite3_vtab_cursor *pVtabCursor,
  sqlite3_context *ctx,
  int i
){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  PragmaVtab *pTab = (PragmaVtab*)(pVtabCursor->pVtab);
  if( i<pTab->iHidden ){
    sqlite3_result_value(ctx, sqlite3_column_value(pCsr->pPragma, i));
  }else{
    sqlite3_result_text(ctx, pCsr->azArg[i-pTab->iHidden],-1,((sqlite3_destructor_type)-1));
  }
  return 0;
}




static int pragmaVtabRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *p){
  PragmaVtabCursor *pCsr = (PragmaVtabCursor*)pVtabCursor;
  *p = pCsr->iRowid;
  return 0;
}


static const sqlite3_module pragmaVtabModule = {
  0,
  0,
  pragmaVtabConnect,
  pragmaVtabBestIndex,
  pragmaVtabDisconnect,
  0,
  pragmaVtabOpen,
  pragmaVtabClose,
  pragmaVtabFilter,
  pragmaVtabNext,
  pragmaVtabEof,
  pragmaVtabColumn,
  pragmaVtabRowid,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
};






static Module *sqlite3PragmaVtabRegister(sqlite3 *db, const char *zName){
  const PragmaName *pName;
  ((void)0);
  pName = pragmaLocate(zName+7);
  if( pName==0 ) return 0;
  if( (pName->mPragFlg & (0x10|0x20))==0 ) return 0;
  ((void)0);
  return sqlite3VtabCreateModule(db, zName, &pragmaVtabModule, (void*)pName, 0);
}
# 124702 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void corruptSchema(
  InitData *pData,
  const char *zObj,
  const char *zExtra
){
  sqlite3 *db = pData->db;
  if( db->mallocFailed ){
    pData->rc = 7;
  }else if( pData->pzErrMsg[0]!=0 ){

  }else if( pData->mInitFlags & 0x0001 ){
    *pData->pzErrMsg = sqlite3DbStrDup(db, zExtra);
    pData->rc = 1;
  }else if( db->flags & 0x00000001 ){
    pData->rc = sqlite3CorruptError(124716);
  }else{
    char *z;
    if( zObj==0 ) zObj = "?";
    z = sqlite3MPrintf(db, "malformed database schema (%s)", zObj);
    if( zExtra && zExtra[0] ) z = sqlite3MPrintf(db, "%z - %s", z, zExtra);
    *pData->pzErrMsg = z;
    pData->rc = sqlite3CorruptError(124723);
  }
}






static int sqlite3IndexHasDuplicateRootPage(Index *pIndex){
  Index *p;
  for(p=pIndex->pTable->pIndex; p; p=p->pNext){
    if( p->tnum==pIndex->tnum && p!=pIndex ) return 1;
  }
  return 0;
}
# 124754 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){
  InitData *pData = (InitData*)pInit;
  sqlite3 *db = pData->db;
  int iDb = pData->iDb;

  ((void)0);
  (void)(NotUsed),(void)(argc);
  ((void)0);
  (db)->aDb[iDb].pSchema->schemaFlags&=~(0x0004);
  pData->nInitRow++;
  if( db->mallocFailed ){
    corruptSchema(pData, argv[1], 0);
    return 1;
  }

  ((void)0);
  if( argv==0 ) return 0;
  if( argv[3]==0 ){
    corruptSchema(pData, argv[1], 0);
  }else if( sqlite3_strnicmp(argv[4],"create ",7)==0 ){





    int rc;
    u8 saved_iDb = db->init.iDb;
    sqlite3_stmt *pStmt;
    ;

    ((void)0);
    db->init.iDb = iDb;
    db->init.newTnum = sqlite3Atoi(argv[3]);
    db->init.orphanTrigger = 0;
    db->init.azInit = argv;
    sqlite3_prepare(db, argv[4], -1, &pStmt, 0);
    rc = db->errCode;
    ((void)0);
    db->init.iDb = saved_iDb;

    if( 0!=rc ){
      if( db->init.orphanTrigger ){
        ((void)0);
      }else{
        if( rc > pData->rc ) pData->rc = rc;
        if( rc==7 ){
          sqlite3OomFault(db);
        }else if( rc!=9 && (rc&0xFF)!=6 ){
          corruptSchema(pData, argv[1], sqlite3_errmsg(db));
        }
      }
    }
    sqlite3_finalize(pStmt);
  }else if( argv[1]==0 || (argv[4]!=0 && argv[4][0]!=0) ){
    corruptSchema(pData, argv[1], 0);
  }else{






    Index *pIndex;
    pIndex = sqlite3FindIndex(db, argv[1], db->aDb[iDb].zDbSName);
    if( pIndex==0
     || sqlite3GetInt32(argv[3],&pIndex->tnum)==0
     || pIndex->tnum<2
     || sqlite3IndexHasDuplicateRootPage(pIndex)
    ){
      corruptSchema(pData, argv[1], pIndex?"invalid rootpage":"orphan index");
    }
  }
  return 0;
}
# 124837 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg, u32 mFlags){
  int rc;
  int i;

  int size;

  Db *pDb;
  char const *azArg[6];
  int meta[5];
  InitData initData;
  const char *zMasterName;
  int openedTransaction = 0;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  db->init.busy = 1;






  azArg[0] = "table";
  azArg[1] = zMasterName = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
  azArg[2] = azArg[1];
  azArg[3] = "1";
  azArg[4] = "CREATE TABLE x(type text,name text,tbl_name text,"
                            "rootpage int,sql text)";
  azArg[5] = 0;
  initData.db = db;
  initData.iDb = iDb;
  initData.rc = 0;
  initData.pzErrMsg = pzErrMsg;
  initData.mInitFlags = mFlags;
  initData.nInitRow = 0;
  sqlite3InitCallback(&initData, 5, (char **)azArg, 0);
  if( initData.rc ){
    rc = initData.rc;
    goto error_out;
  }



  pDb = &db->aDb[iDb];
  if( pDb->pBt==0 ){
    ((void)0);
    (db)->aDb[1].pSchema->schemaFlags|=(0x0001);
    rc = 0;
    goto error_out;
  }




  sqlite3BtreeEnter(pDb->pBt);
  if( !sqlite3BtreeIsInReadTrans(pDb->pBt) ){
    rc = sqlite3BtreeBeginTrans(pDb->pBt, 0, 0);
    if( rc!=0 ){
      sqlite3SetString(pzErrMsg, db, sqlite3ErrStr(rc));
      goto initone_error_out;
    }
    openedTransaction = 1;
  }
# 124922 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=0; i<((int)(sizeof(meta)/sizeof(meta[0]))); i++){
    sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]);
  }
  if( (db->flags & 0x02000000)!=0 ){
    memset(meta, 0, sizeof(meta));
  }
  pDb->pSchema->schema_cookie = meta[1 -1];






  if( meta[5 -1] ){
    if( iDb==0 ){

      u8 encoding;

      encoding = (u8)meta[5 -1] & 3;
      if( encoding==0 ) encoding = 1;
      ((db)->enc) = encoding;



    }else{

      if( meta[5 -1]!=((db)->enc) ){
        sqlite3SetString(pzErrMsg, db, "attached databases must use the same"
            " text encoding as main database");
        rc = 1;
        goto initone_error_out;
      }
    }
  }else{
    (db)->aDb[iDb].pSchema->schemaFlags|=(0x0004);
  }
  pDb->pSchema->enc = ((db)->enc);

  if( pDb->pSchema->cache_size==0 ){

    size = sqlite3AbsInt32(meta[3 -1]);
    if( size==0 ){ size = -2000; }
    pDb->pSchema->cache_size = size;



    sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);
  }







  pDb->pSchema->file_format = (u8)meta[2 -1];
  if( pDb->pSchema->file_format==0 ){
    pDb->pSchema->file_format = 1;
  }
  if( pDb->pSchema->file_format>4 ){
    sqlite3SetString(pzErrMsg, db, "unsupported file format");
    rc = 1;
    goto initone_error_out;
  }






  if( iDb==0 && meta[2 -1]>=4 ){
    db->flags &= ~(u64)0x00000002;
  }



  ((void)0);
  {
    char *zSql;
    zSql = sqlite3MPrintf(db,
        "SELECT*FROM\"%w\".%s ORDER BY rowid",
        db->aDb[iDb].zDbSName, zMasterName);

    {
      sqlite3_xauth xAuth;
      xAuth = db->xAuth;
      db->xAuth = 0;

      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);

      db->xAuth = xAuth;
    }

    if( rc==0 ) rc = initData.rc;
    sqlite3DbFree(db, zSql);

    if( rc==0 ){
      sqlite3AnalysisLoad(db, iDb);
    }

  }
  if( db->mallocFailed ){
    rc = 7;
    sqlite3ResetAllSchemasOfConnection(db);
  }
  if( rc==0 || (db->flags&0x08000000)){
# 125036 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    (db)->aDb[iDb].pSchema->schemaFlags|=(0x0001);
    rc = 0;
  }





initone_error_out:
  if( openedTransaction ){
    sqlite3BtreeCommit(pDb->pBt);
  }
  sqlite3BtreeLeave(pDb->pBt);

error_out:
  if( rc ){
    if( rc==7 || rc==(10 | (12<<8)) ){
      sqlite3OomFault(db);
    }
    sqlite3ResetOneSchema(db, iDb);
  }
  db->init.busy = 0;
  return rc;
}
# 125071 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Init(sqlite3 *db, char **pzErrMsg){
  int i, rc;
  int commit_internal = !(db->mDbFlags&0x0001);

  ((void)0);
  ((void)0);
  ((void)0);
  ((db)->enc) = ((db)->aDb[0].pSchema->enc);
  ((void)0);

  if( !(((db)->aDb[0].pSchema->schemaFlags&(0x0001))==(0x0001)) ){
    rc = sqlite3InitOne(db, 0, pzErrMsg, 0);
    if( rc ) return rc;
  }

  for(i=db->nDb-1; i>0; i--){
    ((void)0);
    if( !(((db)->aDb[i].pSchema->schemaFlags&(0x0001))==(0x0001)) ){
      rc = sqlite3InitOne(db, i, pzErrMsg, 0);
      if( rc ) return rc;
    }
  }
  if( commit_internal ){
    sqlite3CommitInternalChanges(db);
  }
  return 0;
}





static int sqlite3ReadSchema(Parse *pParse){
  int rc = 0;
  sqlite3 *db = pParse->db;
  ((void)0);
  if( !db->init.busy ){
    rc = sqlite3Init(db, &pParse->zErrMsg);
    if( rc!=0 ){
      pParse->rc = rc;
      pParse->nErr++;
    }else if( db->noSharedCache ){
      db->mDbFlags |= 0x0010;
    }
  }
  return rc;
}







static void schemaIsValid(Parse *pParse){
  sqlite3 *db = pParse->db;
  int iDb;
  int rc;
  int cookie;

  ((void)0);
  ((void)0);
  for(iDb=0; iDb<db->nDb; iDb++){
    int openedTransaction = 0;
    Btree *pBt = db->aDb[iDb].pBt;
    if( pBt==0 ) continue;




    if( !sqlite3BtreeIsInReadTrans(pBt) ){
      rc = sqlite3BtreeBeginTrans(pBt, 0, 0);
      if( rc==7 || rc==(10 | (12<<8)) ){
        sqlite3OomFault(db);
      }
      if( rc!=0 ) return;
      openedTransaction = 1;
    }




    sqlite3BtreeGetMeta(pBt, 1, (u32 *)&cookie);
    ((void)0);
    if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){
      sqlite3ResetOneSchema(db, iDb);
      pParse->rc = 17;
    }


    if( openedTransaction ){
      sqlite3BtreeCommit(pBt);
    }
  }
}
# 125174 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){
  int i = -1000000;
# 125187 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( pSchema ){
    for(i=0; 1; i++){
      ((void)0);
      if( db->aDb[i].pSchema==pSchema ){
        break;
      }
    }
    ((void)0);
  }
  return i;
}




static void sqlite3ParserReset(Parse *pParse){
  sqlite3 *db = pParse->db;
  sqlite3DbFree(db, pParse->aLabel);
  sqlite3ExprListDelete(db, pParse->pConstExpr);
  if( db ){
    ((void)0);
    db->lookaside.bDisable -= pParse->disableLookaside;
  }
  pParse->disableLookaside = 0;
}




static int sqlite3Prepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  u32 prepFlags,
  Vdbe *pReprepare,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  char *zErrMsg = 0;
  int rc = 0;
  int i;
  Parse sParse;

  memset(&sParse, 0, __builtin_offsetof(Parse,aTempReg));
  memset((((char*)(&sParse))+__builtin_offsetof(Parse,sLastToken)), 0, (sizeof(Parse)-__builtin_offsetof(Parse,sLastToken)));
  sParse.pReprepare = pReprepare;
  ((void)0);

  ((void)0);




  if( prepFlags & 0x01 ){
    sParse.disableLookaside++;
    db->lookaside.bDisable++;
  }
  sParse.disableVtab = (prepFlags & 0x04)!=0;
# 125270 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=0; i<db->nDb; i++) {
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      ((void)0);
      rc = sqlite3BtreeSchemaLocked(pBt);
      if( rc ){
        const char *zDb = db->aDb[i].zDbSName;
        sqlite3ErrorWithMsg(db, rc, "database schema is locked: %s", zDb);
        ;
        goto end_prepare;
      }
    }
  }

  sqlite3VtabUnlockList(db);

  sParse.db = db;
  if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){
    char *zSqlCopy;
    int mxLen = db->aLimit[1];
    ;
    ;
    if( nBytes>mxLen ){
      sqlite3ErrorWithMsg(db, 18, "statement too long");
      rc = sqlite3ApiExit(db, 18);
      goto end_prepare;
    }
    zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);
    if( zSqlCopy ){
      sqlite3RunParser(&sParse, zSqlCopy, &zErrMsg);
      sParse.zTail = &zSql[sParse.zTail-zSqlCopy];
      sqlite3DbFree(db, zSqlCopy);
    }else{
      sParse.zTail = &zSql[nBytes];
    }
  }else{
    sqlite3RunParser(&sParse, zSql, &zErrMsg);
  }
  ((void)0);

  if( sParse.rc==101 ) sParse.rc = 0;
  if( sParse.checkSchema ){
    schemaIsValid(&sParse);
  }
  if( db->mallocFailed ){
    sParse.rc = 7;
  }
  if( pzTail ){
    *pzTail = sParse.zTail;
  }
  rc = sParse.rc;





  if( sParse.explain && rc==0 && (sParse.pVdbe) ){
    static const char * const azColName[] = {
       "addr", "opcode", "p1", "p2", "p3", "p4", "p5", "comment",
       "id", "parent", "notused", "detail"
    };
    int iFirst, mx;
    if( sParse.explain==2 ){
      sqlite3VdbeSetNumCols(sParse.pVdbe, 4);
      iFirst = 8;
      mx = 12;
    }else{
      sqlite3VdbeSetNumCols(sParse.pVdbe, 8);
      iFirst = 0;
      mx = 8;
    }
    for(i=iFirst; i<mx; i++){
      sqlite3VdbeSetColName(sParse.pVdbe, i-iFirst, 0,
                            azColName[i], ((sqlite3_destructor_type)0));
    }
  }


  if( db->init.busy==0 ){
    sqlite3VdbeSetSql(sParse.pVdbe, zSql, (int)(sParse.zTail-zSql), prepFlags);
  }
  if( rc!=0 || db->mallocFailed ){
    if( sParse.pVdbe ) sqlite3VdbeFinalize(sParse.pVdbe);
    ((void)0);
  }else{
    *ppStmt = (sqlite3_stmt*)sParse.pVdbe;
  }

  if( zErrMsg ){
    sqlite3ErrorWithMsg(db, rc, "%s", zErrMsg);
    sqlite3DbFree(db, zErrMsg);
  }else{
    sqlite3Error(db, rc);
  }


  while( sParse.pTriggerPrg ){
    TriggerPrg *pT = sParse.pTriggerPrg;
    sParse.pTriggerPrg = pT->pNext;
    sqlite3DbFree(db, pT);
  }

end_prepare:

  sqlite3ParserReset(&sParse);
  return rc;
}
static int sqlite3LockAndPrepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  u32 prepFlags,
  Vdbe *pOld,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;
  int cnt = 0;




  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){
    return sqlite3MisuseError(125394);
  }
  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  do{



    rc = sqlite3Prepare(db, zSql, nBytes, prepFlags, pOld, ppStmt, pzTail);
    ((void)0);
  }while( rc==(1 | (2<<8))
       || (rc==17 && (sqlite3ResetOneSchema(db,-1), cnt++)==0) );
  sqlite3BtreeLeaveAll(db);
  rc = sqlite3ApiExit(db, rc);
  ((void)0);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 125422 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Reprepare(Vdbe *p){
  int rc;
  sqlite3_stmt *pNew;
  const char *zSql;
  sqlite3 *db;
  u8 prepFlags;

  ((void)0);
  zSql = sqlite3_sql((sqlite3_stmt *)p);
  ((void)0);
  db = sqlite3VdbeDb(p);
  ((void)0);
  prepFlags = sqlite3VdbePrepareFlags(p);
  rc = sqlite3LockAndPrepare(db, zSql, -1, prepFlags, p, &pNew, 0);
  if( rc ){
    if( rc==7 ){
      sqlite3OomFault(db);
    }
    ((void)0);
    return rc;
  }else{
    ((void)0);
  }
  sqlite3VdbeSwap((Vdbe*)pNew, p);
  sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);
  sqlite3VdbeResetStepResult((Vdbe*)pNew);
  sqlite3VdbeFinalize((Vdbe*)pNew);
  return 0;
}
# 125461 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_prepare(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;
  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);
  ((void)0);
  return rc;
}
 int sqlite3_prepare_v2(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;





  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0x80,0,
                             ppStmt,pzTail);
  ((void)0);
  return rc;
}
 int sqlite3_prepare_v3(
  sqlite3 *db,
  const char *zSql,
  int nBytes,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const char **pzTail
){
  int rc;







  rc = sqlite3LockAndPrepare(db,zSql,nBytes,
                 0x80|(prepFlags&0x0f),
                 0,ppStmt,pzTail);
  ((void)0);
  return rc;
}






static int sqlite3Prepare16(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  u32 prepFlags,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){




  char *zSql8;
  const char *zTail8 = 0;
  int rc = 0;




  *ppStmt = 0;
  if( !sqlite3SafetyCheckOk(db)||zSql==0 ){
    return sqlite3MisuseError(125540);
  }
  if( nBytes>=0 ){
    int sz;
    const char *z = (const char*)zSql;
    for(sz=0; sz<nBytes && (z[sz]!=0 || z[sz+1]!=0); sz += 2){}
    nBytes = sz;
  }
  sqlite3_mutex_enter(db->mutex);
  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, 2);
  if( zSql8 ){
    rc = sqlite3LockAndPrepare(db, zSql8, -1, prepFlags, 0, ppStmt, &zTail8);
  }

  if( zTail8 && pzTail ){





    int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));
    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);
  }
  sqlite3DbFree(db, zSql8);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 125577 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_prepare16(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);
  ((void)0);
  return rc;
}
 int sqlite3_prepare16_v2(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,0x80,ppStmt,pzTail);
  ((void)0);
  return rc;
}
 int sqlite3_prepare16_v3(
  sqlite3 *db,
  const void *zSql,
  int nBytes,
  unsigned int prepFlags,
  sqlite3_stmt **ppStmt,
  const void **pzTail
){
  int rc;
  rc = sqlite3Prepare16(db,zSql,nBytes,
         0x80|(prepFlags&0x0f),
         ppStmt,pzTail);
  ((void)0);
  return rc;
}
# 125647 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SELECTTRACE(K,P,S,X) 
# 125656 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct DistinctCtx DistinctCtx;
struct DistinctCtx {
  u8 isTnct;
  u8 eTnctType;
  int tabTnct;
  int addrTnct;
};
# 125682 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct SortCtx SortCtx;
struct SortCtx {
  ExprList *pOrderBy;
  int nOBSat;
  int iECursor;
  int regReturn;
  int labelBkOut;
  int addrSortIndex;
  int labelDone;
  int labelOBLopt;
  u8 sortFlags;
# 125701 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  struct RowLoadInfo *pDeferredRowLoad;
};
#define SORTFLAG_UseSorter 0x01





static void clearSelect(sqlite3 *db, Select *p, int bFree){
  while( p ){
    Select *pPrior = p->pPrior;
    sqlite3ExprListDelete(db, p->pEList);
    sqlite3SrcListDelete(db, p->pSrc);
    sqlite3ExprDelete(db, p->pWhere);
    sqlite3ExprListDelete(db, p->pGroupBy);
    sqlite3ExprDelete(db, p->pHaving);
    sqlite3ExprListDelete(db, p->pOrderBy);
    sqlite3ExprDelete(db, p->pLimit);

    if( (p->pWinDefn) ){
      sqlite3WindowListDelete(db, p->pWinDefn);
    }
    ((void)0);

    if( (p->pWith) ) sqlite3WithDelete(db, p->pWith);
    if( bFree ) sqlite3DbFreeNN(db, p);
    p = pPrior;
    bFree = 1;
  }
}




static void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){
  pDest->eDest = (u8)eDest;
  pDest->iSDParm = iParm;
  pDest->zAffSdst = 0;
  pDest->iSdst = 0;
  pDest->nSdst = 0;
}






static Select *sqlite3SelectNew(
  Parse *pParse,
  ExprList *pEList,
  SrcList *pSrc,
  Expr *pWhere,
  ExprList *pGroupBy,
  Expr *pHaving,
  ExprList *pOrderBy,
  u32 selFlags,
  Expr *pLimit
){
  Select *pNew;
  Select standin;
  pNew = sqlite3DbMallocRawNN(pParse->db, sizeof(*pNew) );
  if( pNew==0 ){
    ((void)0);
    pNew = &standin;
  }
  if( pEList==0 ){
    pEList = sqlite3ExprListAppend(pParse, 0,
                                   sqlite3Expr(pParse->db,175,0));
  }
  pNew->pEList = pEList;
  pNew->op = 134;
  pNew->selFlags = selFlags;
  pNew->iLimit = 0;
  pNew->iOffset = 0;
  pNew->selId = ++pParse->nSelect;
  pNew->addrOpenEphm[0] = -1;
  pNew->addrOpenEphm[1] = -1;
  pNew->nSelectRow = 0;
  if( pSrc==0 ) pSrc = sqlite3DbMallocZero(pParse->db, sizeof(*pSrc));
  pNew->pSrc = pSrc;
  pNew->pWhere = pWhere;
  pNew->pGroupBy = pGroupBy;
  pNew->pHaving = pHaving;
  pNew->pOrderBy = pOrderBy;
  pNew->pPrior = 0;
  pNew->pNext = 0;
  pNew->pLimit = pLimit;
  pNew->pWith = 0;

  pNew->pWin = 0;
  pNew->pWinDefn = 0;

  if( pParse->db->mallocFailed ) {
    clearSelect(pParse->db, pNew, pNew!=&standin);
    pNew = 0;
  }else{
    ((void)0);
  }
  ((void)0);
  return pNew;
}





static void sqlite3SelectDelete(sqlite3 *db, Select *p){
  if( (p) ) clearSelect(db, p, 1);
}




static Select *findRightmost(Select *p){
  while( p->pNext ) p = p->pNext;
  return p;
}
# 125836 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){
  int jointype = 0;
  Token *apAll[3];
  Token *p;

  static const char zKeyText[] = "naturaleftouterightfullinnercross";
  static const struct {
    u8 i;
    u8 nChar;
    u8 code;
  } aKeyword[] = {
                  { 0, 7, 0x0004 },
                  { 6, 4, 0x0008|0x0020 },
                  { 10, 5, 0x0020 },
                  { 14, 5, 0x0010|0x0020 },
                  { 19, 4, 0x0008|0x0010|0x0020 },
                  { 23, 5, 0x0001 },
                  { 28, 5, 0x0001|0x0002 },
  };
  int i, j;
  apAll[0] = pA;
  apAll[1] = pB;
  apAll[2] = pC;
  for(i=0; i<3 && apAll[i]; i++){
    p = apAll[i];
    for(j=0; j<((int)(sizeof(aKeyword)/sizeof(aKeyword[0]))); j++){
      if( p->n==aKeyword[j].nChar
          && sqlite3_strnicmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){
        jointype |= aKeyword[j].code;
        break;
      }
    }
    ;
    if( j>=((int)(sizeof(aKeyword)/sizeof(aKeyword[0]))) ){
      jointype |= 0x0040;
      break;
    }
  }
  if(
     (jointype & (0x0001|0x0020))==(0x0001|0x0020) ||
     (jointype & 0x0040)!=0
  ){
    const char *zSp = " ";
    ((void)0);
    if( pC==0 ){ zSp++; }
    sqlite3ErrorMsg(pParse, "unknown or unsupported join type: "
       "%T %T%s%T", pA, pB, zSp, pC);
    jointype = 0x0001;
  }else if( (jointype & 0x0020)!=0
         && (jointype & (0x0008|0x0010))!=0x0008 ){
    sqlite3ErrorMsg(pParse,
      "RIGHT and FULL OUTER JOINs are not currently supported");
    jointype = 0x0001;
  }
  return jointype;
}





static int columnIndex(Table *pTab, const char *zCol){
  int i;
  for(i=0; i<pTab->nCol; i++){
    if( sqlite3StrICmp(pTab->aCol[i].zName, zCol)==0 ) return i;
  }
  return -1;
}
# 125914 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int tableAndColumnIndex(
  SrcList *pSrc,
  int N,
  const char *zCol,
  int *piTab,
  int *piCol
){
  int i;
  int iCol;

  ((void)0);
  for(i=0; i<N; i++){
    iCol = columnIndex(pSrc->a[i].pTab, zCol);
    if( iCol>=0 ){
      if( piTab ){
        *piTab = i;
        *piCol = iCol;
      }
      return 1;
    }
  }
  return 0;
}
# 125949 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void addWhereTerm(
  Parse *pParse,
  SrcList *pSrc,
  int iLeft,
  int iColLeft,
  int iRight,
  int iColRight,
  int isOuterJoin,
  Expr **ppWhere
){
  sqlite3 *db = pParse->db;
  Expr *pE1;
  Expr *pE2;
  Expr *pEq;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);

  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);
  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);

  pEq = sqlite3PExpr(pParse, 53, pE1, pE2);
  if( pEq && isOuterJoin ){
    (pEq)->flags|=(0x000001);
    ((void)0);
    ;
    pEq->iRightJoinTable = (i16)pE2->iTable;
  }
  *ppWhere = sqlite3ExprAnd(pParse, *ppWhere, pEq);
}
# 126008 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void setJoinExpr(Expr *p, int iTable){
  while( p ){
    (p)->flags|=(0x000001);
    ((void)0);
    ;
    p->iRightJoinTable = (i16)iTable;
    if( p->op==167 && p->x.pList ){
      int i;
      for(i=0; i<p->x.pList->nExpr; i++){
        setJoinExpr(p->x.pList->a[i].pExpr, iTable);
      }
    }
    setJoinExpr(p->pLeft, iTable);
    p = p->pRight;
  }
}







static void unsetJoinExpr(Expr *p, int iTable){
  while( p ){
    if( (((p)->flags&(0x000001))!=0)
     && (iTable<0 || p->iRightJoinTable==iTable) ){
      (p)->flags&=~(0x000001);
    }
    if( p->op==167 && p->x.pList ){
      int i;
      for(i=0; i<p->x.pList->nExpr; i++){
        unsetJoinExpr(p->x.pList->a[i].pExpr, iTable);
      }
    }
    unsetJoinExpr(p->pLeft, iTable);
    p = p->pRight;
  }
}
# 126062 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqliteProcessJoin(Parse *pParse, Select *p){
  SrcList *pSrc;
  int i, j;
  struct SrcList_item *pLeft;
  struct SrcList_item *pRight;

  pSrc = p->pSrc;
  pLeft = &pSrc->a[0];
  pRight = &pLeft[1];
  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){
    Table *pRightTab = pRight->pTab;
    int isOuter;

    if( (pLeft->pTab==0 || pRightTab==0) ) continue;
    isOuter = (pRight->fg.jointype & 0x0020)!=0;




    if( pRight->fg.jointype & 0x0004 ){
      if( pRight->pOn || pRight->pUsing ){
        sqlite3ErrorMsg(pParse, "a NATURAL join may not have "
           "an ON or USING clause", 0);
        return 1;
      }
      for(j=0; j<pRightTab->nCol; j++){
        char *zName;
        int iLeft;
        int iLeftCol;

        zName = pRightTab->aCol[j].zName;
        if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol) ){
          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,
                       isOuter, &p->pWhere);
        }
      }
    }



    if( pRight->pOn && pRight->pUsing ){
      sqlite3ErrorMsg(pParse, "cannot have both ON and USING "
        "clauses in the same join");
      return 1;
    }




    if( pRight->pOn ){
      if( isOuter ) setJoinExpr(pRight->pOn, pRight->iCursor);
      p->pWhere = sqlite3ExprAnd(pParse, p->pWhere, pRight->pOn);
      pRight->pOn = 0;
    }
# 126124 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pRight->pUsing ){
      IdList *pList = pRight->pUsing;
      for(j=0; j<pList->nId; j++){
        char *zName;
        int iLeft;
        int iLeftCol;
        int iRightCol;

        zName = pList->a[j].zName;
        iRightCol = columnIndex(pRightTab, zName);
        if( iRightCol<0
         || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol)
        ){
          sqlite3ErrorMsg(pParse, "cannot join using column %s - column "
            "not present in both tables", zName);
          return 1;
        }
        addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,
                     isOuter, &p->pWhere);
      }
    }
  }
  return 0;
}





typedef struct RowLoadInfo RowLoadInfo;
struct RowLoadInfo {
  int regResult;
  u8 ecelFlags;




};





static void innerLoopLoadRow(
  Parse *pParse,
  Select *pSelect,
  RowLoadInfo *pInfo
){
  sqlite3ExprCodeExprList(pParse, pSelect->pEList, pInfo->regResult,
                          0, pInfo->ecelFlags);






}







static int makeSorterRecord(
  Parse *pParse,
  SortCtx *pSort,
  Select *pSelect,
  int regBase,
  int nBase
){
  int nOBSat = pSort->nOBSat;
  Vdbe *v = pParse->pVdbe;
  int regOut = ++pParse->nMem;
  if( pSort->pDeferredRowLoad ){
    innerLoopLoadRow(pParse, pSelect, pSort->pDeferredRowLoad);
  }
  sqlite3VdbeAddOp3(v, 92, regBase+nOBSat, nBase-nOBSat, regOut);
  return regOut;
}





static void pushOntoSorter(
  Parse *pParse,
  SortCtx *pSort,
  Select *pSelect,
  int regData,
  int regOrigData,
  int nData,
  int nPrefixReg
){
  Vdbe *v = pParse->pVdbe;
  int bSeq = ((pSort->sortFlags & 0x01)==0);
  int nExpr = pSort->pOrderBy->nExpr;
  int nBase = nExpr + bSeq + nData;
  int regBase;
  int regRecord = 0;
  int nOBSat = pSort->nOBSat;
  int op;
  int iLimit;
  int iSkip = 0;

  ((void)0);
# 126244 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);

  if( nPrefixReg ){
    ((void)0);
    regBase = regData - nPrefixReg;
  }else{
    regBase = pParse->nMem + 1;
    pParse->nMem += nBase;
  }
  ((void)0);
  iLimit = pSelect->iOffset ? pSelect->iOffset+1 : pSelect->iLimit;
  pSort->labelDone = sqlite3VdbeMakeLabel(pParse);
  sqlite3ExprCodeExprList(pParse, pSort->pOrderBy, regBase, regOrigData,
                          0x01 | (regOrigData? 0x04 : 0));
  if( bSeq ){
    sqlite3VdbeAddOp2(v, 120, pSort->iECursor, regBase+nExpr);
  }
  if( nPrefixReg==0 && nData>0 ){
    sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+bSeq, nData);
  }
  if( nOBSat>0 ){
    int regPrevKey;
    int addrFirst;
    int addrJmp;
    VdbeOp *pOp;
    int nKey;
    KeyInfo *pKI;

    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
    regPrevKey = pParse->nMem+1;
    pParse->nMem += pSort->nOBSat;
    nKey = nExpr - pSort->nOBSat + bSeq;
    if( bSeq ){
      addrFirst = sqlite3VdbeAddOp1(v, 20, regBase+nExpr);
    }else{
      addrFirst = sqlite3VdbeAddOp1(v, 115, pSort->iECursor);
    }
    ;
    sqlite3VdbeAddOp3(v, 87, regPrevKey, regBase, pSort->nOBSat);
    pOp = sqlite3VdbeGetOp(v, pSort->addrSortIndex);
    if( pParse->db->mallocFailed ) return;
    pOp->p2 = nKey + nData;
    pKI = pOp->p4.pKeyInfo;
    memset(pKI->aSortFlags, 0, pKI->nKeyField);
    sqlite3VdbeChangeP4(v, -1, (char*)pKI, (-9));
    ;
    pOp->p4.pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pSort->pOrderBy,nOBSat,
                                           pKI->nAllField-pKI->nKeyField-1);
    addrJmp = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp3(v, 16, addrJmp+1, 0, addrJmp+1); ;
    pSort->labelBkOut = sqlite3VdbeMakeLabel(pParse);
    pSort->regReturn = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 12, pSort->regReturn, pSort->labelBkOut);
    sqlite3VdbeAddOp1(v, 138, pSort->iECursor);
    if( iLimit ){
      sqlite3VdbeAddOp2(v, 20, iLimit, pSort->labelDone);
      ;
    }
    sqlite3VdbeJumpHere(v, addrFirst);
    sqlite3ExprCodeMove(pParse, regBase, regPrevKey, pSort->nOBSat);
    sqlite3VdbeJumpHere(v, addrJmp);
  }
  if( iLimit ){
# 126322 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    int iCsr = pSort->iECursor;
    sqlite3VdbeAddOp2(v, 48, iLimit, sqlite3VdbeCurrentAddr(v)+4);
    ;
    sqlite3VdbeAddOp2(v, 32, iCsr, 0);
    iSkip = sqlite3VdbeAddOp4Int(v, 37,
                                 iCsr, 0, regBase+nOBSat, nExpr-nOBSat);
    ;
    sqlite3VdbeAddOp1(v, 123, iCsr);
  }
  if( regRecord==0 ){
    regRecord = makeSorterRecord(pParse, pSort, pSelect, regBase, nBase);
  }
  if( pSort->sortFlags & 0x01 ){
    op = 131;
  }else{
    op = 132;
  }
  sqlite3VdbeAddOp4Int(v, op, pSort->iECursor, regRecord,
                       regBase+nOBSat, nBase-nOBSat);
  if( iSkip ){
    sqlite3VdbeChangeP2(v, iSkip,
         pSort->labelOBLopt ? pSort->labelOBLopt : sqlite3VdbeCurrentAddr(v));
  }
}




static void codeOffset(
  Vdbe *v,
  int iOffset,
  int iContinue
){
  if( iOffset>0 ){
    sqlite3VdbeAddOp3(v, 47, iOffset, iContinue, 1); ;
    ;
  }
}
# 126370 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void codeDistinct(
  Parse *pParse,
  int iTab,
  int addrRepeat,
  int N,
  int iMem
){
  Vdbe *v;
  int r1;

  v = pParse->pVdbe;
  r1 = sqlite3GetTempReg(pParse);
  sqlite3VdbeAddOp4Int(v, 29, iTab, addrRepeat, iMem, N); ;
  sqlite3VdbeAddOp3(v, 92, iMem, N, r1);
  sqlite3VdbeAddOp4Int(v, 132, iTab, r1, iMem, N);
  sqlite3VdbeChangeP5(v, 0x10);
  sqlite3ReleaseTempReg(pParse, r1);
}
# 126479 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void selectInnerLoop(
  Parse *pParse,
  Select *p,
  int srcTab,
  SortCtx *pSort,
  DistinctCtx *pDistinct,
  SelectDest *pDest,
  int iContinue,
  int iBreak
){
  Vdbe *v = pParse->pVdbe;
  int i;
  int hasDistinct;
  int eDest = pDest->eDest;
  int iParm = pDest->iSDParm;
  int nResultCol;
  int nPrefixReg = 0;
  RowLoadInfo sRowLoadInfo;






  int regResult;
  int regOrig;

  ((void)0);
  ((void)0);
  hasDistinct = pDistinct ? pDistinct->eTnctType : 0;
  if( pSort && pSort->pOrderBy==0 ) pSort = 0;
  if( pSort==0 && !hasDistinct ){
    ((void)0);
    codeOffset(v, p->iOffset, iContinue);
  }



  nResultCol = p->pEList->nExpr;

  if( pDest->iSdst==0 ){
    if( pSort ){
      nPrefixReg = pSort->pOrderBy->nExpr;
      if( !(pSort->sortFlags & 0x01) ) nPrefixReg++;
      pParse->nMem += nPrefixReg;
    }
    pDest->iSdst = pParse->nMem+1;
    pParse->nMem += nResultCol;
  }else if( pDest->iSdst+nResultCol > pParse->nMem ){





    pParse->nMem += nResultCol;
  }
  pDest->nSdst = nResultCol;
  regOrig = regResult = pDest->iSdst;
  if( srcTab>=0 ){
    for(i=0; i<nResultCol; i++){
      sqlite3VdbeAddOp3(v, 90, srcTab, i, regResult+i);
      ;
    }
  }else if( eDest!=3 ){






    u8 ecelFlags;
    ExprList *pEList;
    if( eDest==10 || eDest==9 || eDest==13 ){
      ecelFlags = 0x01;
    }else{
      ecelFlags = 0;
    }
    if( pSort && hasDistinct==0 && eDest!=12 && eDest!=14 ){






      ecelFlags |= (0x08|0x04);

      for(i=pSort->nOBSat; i<pSort->pOrderBy->nExpr; i++){
        int j;
        if( (j = pSort->pOrderBy->a[i].u.x.iOrderByCol)>0 ){
          p->pEList->a[j-1].u.x.iOrderByCol = i+1-pSort->nOBSat;
        }
      }
# 126588 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      pEList = p->pEList;
      for(i=0; i<pEList->nExpr; i++){
        if( pEList->a[i].u.x.iOrderByCol>0



        ){
          nResultCol--;
          regOrig = 0;
        }
      }

      ;
      ;
      ;
      ;
      ;
      ((void)0)
                                                         ;
    }
    sRowLoadInfo.regResult = regResult;
    sRowLoadInfo.ecelFlags = ecelFlags;





    if( p->iLimit
     && (ecelFlags & 0x08)!=0
     && nPrefixReg>0
    ){
      ((void)0);
      ((void)0);
      pSort->pDeferredRowLoad = &sRowLoadInfo;
      regOrig = 0;
    }else{
      innerLoopLoadRow(pParse, p, &sRowLoadInfo);
    }
  }





  if( hasDistinct ){
    switch( pDistinct->eTnctType ){
      case 2: {
        VdbeOp *pOp;
        int iJump;
        int regPrev;


        regPrev = pParse->nMem+1;
        pParse->nMem += nResultCol;







        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
        pOp = sqlite3VdbeGetOp(v, pDistinct->addrTnct);
        pOp->opcode = 73;
        pOp->p1 = 1;
        pOp->p2 = regPrev;

        iJump = sqlite3VdbeCurrentAddr(v) + nResultCol;
        for(i=0; i<nResultCol; i++){
          CollSeq *pColl = sqlite3ExprCollSeq(pParse, p->pEList->a[i].pExpr);
          if( i<nResultCol-1 ){
            sqlite3VdbeAddOp3(v, 52, regResult+i, iJump, regPrev+i);
            ;
          }else{
            sqlite3VdbeAddOp3(v, 53, regResult+i, iContinue, regPrev+i);
            ;
           }
          sqlite3VdbeChangeP4(v, -1, (const char *)pColl, (-2));
          sqlite3VdbeChangeP5(v, 0x80);
        }
        ((void)0);
        sqlite3VdbeAddOp3(v, 78, regResult, regPrev, nResultCol-1);
        break;
      }

      case 1: {
        sqlite3VdbeChangeToNoop(v, pDistinct->addrTnct);
        break;
      }

      default: {
        ((void)0);
        codeDistinct(pParse, pDistinct->tabTnct, iContinue, nResultCol,
                     regResult);
        break;
      }
    }
    if( pSort==0 ){
      codeOffset(v, p->iOffset, iContinue);
    }
  }

  switch( eDest ){




    case 1: {
      int r1;
      r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 92, regResult, nResultCol, r1);
      sqlite3VdbeAddOp4Int(v, 132, iParm, r1, regResult, nResultCol);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }





    case 2: {
      sqlite3VdbeAddOp3(v, 133, iParm, regResult, nResultCol);
      break;
    }




    case 5:
    case 6:
    case 14:
    case 12: {
      int r1 = sqlite3GetTempRange(pParse, nPrefixReg+1);
      ;
      ;
      ;
      ;
      sqlite3VdbeAddOp3(v, 92, regResult, nResultCol, r1+nPrefixReg);

      if( eDest==6 ){





        int addr = sqlite3VdbeCurrentAddr(v) + 4;
        sqlite3VdbeAddOp4Int(v, 29, iParm+1, addr, r1, 0);
        ;
        sqlite3VdbeAddOp4Int(v, 132, iParm+1, r1,regResult,nResultCol);
        ((void)0);
      }

      if( pSort ){
        ((void)0);
        pushOntoSorter(pParse, pSort, p, r1+nPrefixReg, regOrig, 1, nPrefixReg);
      }else{
        int r2 = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 121, iParm, r2);
        sqlite3VdbeAddOp3(v, 122, iParm, r1, r2);
        sqlite3VdbeChangeP5(v, 0x08);
        sqlite3ReleaseTempReg(pParse, r2);
      }
      sqlite3ReleaseTempRange(pParse, r1, nPrefixReg+1);
      break;
    }






    case 11: {
      if( pSort ){




        pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
      }else{
        int r1 = sqlite3GetTempReg(pParse);
        ((void)0);
        sqlite3VdbeAddOp4(v, 92, regResult, nResultCol,
            r1, pDest->zAffSdst, nResultCol);
        sqlite3VdbeAddOp4Int(v, 132, iParm, r1, regResult, nResultCol);
        sqlite3ReleaseTempReg(pParse, r1);
      }
      break;
    }



    case 3: {
      sqlite3VdbeAddOp2(v, 70, 1, iParm);

      break;
    }





    case 10: {
      if( pSort ){
        ((void)0);
        pushOntoSorter(
            pParse, pSort, p, regResult, regOrig, nResultCol, nPrefixReg);
      }else{
        ((void)0);
        ((void)0);

      }
      break;
    }


    case 13:
    case 9: {
      ;
      ;
      if( pSort ){
        pushOntoSorter(pParse, pSort, p, regResult, regOrig, nResultCol,
                       nPrefixReg);
      }else if( eDest==13 ){
        sqlite3VdbeAddOp1(v, 14, pDest->iSDParm);
      }else{
        sqlite3VdbeAddOp2(v, 81, regResult, nResultCol);
      }
      break;
    }
# 126826 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 8:
    case 7: {
      int nKey;
      int r1, r2, r3;
      int addrTest = 0;
      ExprList *pSO;
      pSO = pDest->pOrderBy;
      ((void)0);
      nKey = pSO->nExpr;
      r1 = sqlite3GetTempReg(pParse);
      r2 = sqlite3GetTempRange(pParse, nKey+2);
      r3 = r2+nKey+1;
      if( eDest==8 ){



        addrTest = sqlite3VdbeAddOp4Int(v, 29, iParm+1, 0,
                                        regResult, nResultCol);
        ;
      }
      sqlite3VdbeAddOp3(v, 92, regResult, nResultCol, r3);
      if( eDest==8 ){
        sqlite3VdbeAddOp2(v, 132, iParm+1, r3);
        sqlite3VdbeChangeP5(v, 0x10);
      }
      for(i=0; i<nKey; i++){
        sqlite3VdbeAddOp2(v, 79,
                          regResult + pSO->a[i].u.x.iOrderByCol - 1,
                          r2+i);
      }
      sqlite3VdbeAddOp2(v, 120, iParm, r2+nKey);
      sqlite3VdbeAddOp3(v, 92, r2, nKey+2, r1);
      sqlite3VdbeAddOp4Int(v, 132, iParm, r1, r2, nKey+2);
      if( addrTest ) sqlite3VdbeJumpHere(v, addrTest);
      sqlite3ReleaseTempReg(pParse, r1);
      sqlite3ReleaseTempRange(pParse, r2, nKey+2);
      break;
    }
# 126874 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    default: {
      ((void)0);
      break;
    }

  }





  if( pSort==0 && p->iLimit ){
    sqlite3VdbeAddOp2(v, 49, p->iLimit, iBreak); ;
  }
}





static KeyInfo *sqlite3KeyInfoAlloc(sqlite3 *db, int N, int X){
  int nExtra = (N+X)*(sizeof(CollSeq*)+1) - sizeof(CollSeq*);
  KeyInfo *p = sqlite3DbMallocRawNN(db, sizeof(KeyInfo) + nExtra);
  if( p ){
    p->aSortFlags = (u8*)&p->aColl[N+X];
    p->nKeyField = (u16)N;
    p->nAllField = (u16)(N+X);
    p->enc = ((db)->enc);
    p->db = db;
    p->nRef = 1;
    memset(&p[1], 0, nExtra);
  }else{
    sqlite3OomFault(db);
  }
  return p;
}




static void sqlite3KeyInfoUnref(KeyInfo *p){
  if( p ){
    ((void)0);
    p->nRef--;
    if( p->nRef==0 ) sqlite3DbFreeNN(p->db, p);
  }
}




static KeyInfo *sqlite3KeyInfoRef(KeyInfo *p){
  if( p ){
    ((void)0);
    p->nRef++;
  }
  return p;
}
# 126957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static KeyInfo *sqlite3KeyInfoFromExprList(
  Parse *pParse,
  ExprList *pList,
  int iStart,
  int nExtra
){
  int nExpr;
  KeyInfo *pInfo;
  struct ExprList_item *pItem;
  sqlite3 *db = pParse->db;
  int i;

  nExpr = pList->nExpr;
  pInfo = sqlite3KeyInfoAlloc(db, nExpr-iStart, nExtra+1);
  if( pInfo ){
    ((void)0);
    for(i=iStart, pItem=pList->a+iStart; i<nExpr; i++, pItem++){
      pInfo->aColl[i-iStart] = sqlite3ExprNNCollSeq(pParse, pItem->pExpr);
      pInfo->aSortFlags[i-iStart] = pItem->sortFlags;
    }
  }
  return pInfo;
}




static const char *selectOpName(int id){
  char *z;
  switch( id ){
    case 131: z = "UNION ALL"; break;
    case 133: z = "INTERSECT"; break;
    case 132: z = "EXCEPT"; break;
    default: z = "UNION"; break;
  }
  return z;
}
# 127006 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void explainTempTable(Parse *pParse, const char *zUsage){
  sqlite3VdbeExplain (pParse, 0, "USE TEMP B-TREE FOR %s", zUsage);
}
# 127017 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define explainSetInteger(a,b) a = b
# 127032 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void generateSortTail(
  Parse *pParse,
  Select *p,
  SortCtx *pSort,
  int nColumn,
  SelectDest *pDest
){
  Vdbe *v = pParse->pVdbe;
  int addrBreak = pSort->labelDone;
  int addrContinue = sqlite3VdbeMakeLabel(pParse);
  int addr;
  int addrOnce = 0;
  int iTab;
  ExprList *pOrderBy = pSort->pOrderBy;
  int eDest = pDest->eDest;
  int iParm = pDest->iSDParm;
  int regRow;
  int regRowid;
  int iCol;
  int nKey;
  int iSortTab;
  int i;
  int bSeq;
  int nRefKey = 0;
  struct ExprList_item *aOutEx = p->pEList->a;

  ((void)0);
  if( pSort->labelBkOut ){
    sqlite3VdbeAddOp2(v, 12, pSort->regReturn, pSort->labelBkOut);
    sqlite3VdbeGoto(v, addrBreak);
    sqlite3VdbeResolveLabel(v, pSort->labelBkOut);
  }
# 127075 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  iTab = pSort->iECursor;
  if( eDest==9 || eDest==13 || eDest==10 ){
    regRowid = 0;
    regRow = pDest->iSdst;
  }else{
    regRowid = sqlite3GetTempReg(pParse);
    if( eDest==12 || eDest==14 ){
      regRow = sqlite3GetTempReg(pParse);
      nColumn = 0;
    }else{
      regRow = sqlite3GetTempRange(pParse, nColumn);
    }
  }
  nKey = pOrderBy->nExpr - pSort->nOBSat;
  if( pSort->sortFlags & 0x01 ){
    int regSortOut = ++pParse->nMem;
    iSortTab = pParse->nTab++;
    if( pSort->labelBkOut ){
      addrOnce = sqlite3VdbeAddOp0(v, 17); ;
    }
    sqlite3VdbeAddOp3(v, 116, iSortTab, regSortOut,
        nKey+1+nColumn+nRefKey);
    if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);
    addr = 1 + sqlite3VdbeAddOp2(v, 34, iTab, addrBreak);
    ;
    codeOffset(v, p->iOffset, addrContinue);
    sqlite3VdbeAddOp3(v, 126, iTab, regSortOut, iSortTab);
    bSeq = 0;
  }else{
    addr = 1 + sqlite3VdbeAddOp2(v, 35, iTab, addrBreak); ;
    codeOffset(v, p->iOffset, addrContinue);
    iSortTab = iTab;
    bSeq = 1;
  }
  for(i=0, iCol=nKey+bSeq-1; i<nColumn; i++){



    if( aOutEx[i].u.x.iOrderByCol==0 ) iCol++;
  }
# 127146 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=nColumn-1; i>=0; i--){





    {
      int iRead;
      if( aOutEx[i].u.x.iOrderByCol ){
        iRead = aOutEx[i].u.x.iOrderByCol-1;
      }else{
        iRead = iCol--;
      }
      sqlite3VdbeAddOp3(v, 90, iSortTab, iRead, regRow+i);
      ;
    }
  }
  switch( eDest ){
    case 14:
    case 12: {
      sqlite3VdbeAddOp3(v, 90, iSortTab, nKey+bSeq, regRow);
      sqlite3VdbeAddOp2(v, 121, iParm, regRowid);
      sqlite3VdbeAddOp3(v, 122, iParm, regRow, regRowid);
      sqlite3VdbeChangeP5(v, 0x08);
      break;
    }

    case 11: {
      ((void)0);
      sqlite3VdbeAddOp4(v, 92, regRow, nColumn, regRowid,
                        pDest->zAffSdst, nColumn);
      sqlite3VdbeAddOp4Int(v, 132, iParm, regRowid, regRow, nColumn);
      break;
    }
    case 10: {

      break;
    }

    default: {
      ((void)0);
      ;
      ;
      if( eDest==9 ){
        sqlite3VdbeAddOp2(v, 81, pDest->iSdst, nColumn);
      }else{
        sqlite3VdbeAddOp1(v, 14, pDest->iSDParm);
      }
      break;
    }
  }
  if( regRowid ){
    if( eDest==11 ){
      sqlite3ReleaseTempRange(pParse, regRow, nColumn);
    }else{
      sqlite3ReleaseTempReg(pParse, regRow);
    }
    sqlite3ReleaseTempReg(pParse, regRowid);
  }


  sqlite3VdbeResolveLabel(v, addrContinue);
  if( pSort->sortFlags & 0x01 ){
    sqlite3VdbeAddOp2(v, 3, iTab, addr); ;
  }else{
    sqlite3VdbeAddOp2(v, 5, iTab, addr); ;
  }
  if( pSort->regReturn ) sqlite3VdbeAddOp1(v, 66, pSort->regReturn);
  sqlite3VdbeResolveLabel(v, addrBreak);
}
# 127244 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define columnType(A,B,C,D,E) columnTypeImpl(A,B)

static const char *columnTypeImpl(
  NameContext *pNC,

  Expr *pExpr






){
  char const *zType = 0;
  int j;






  ((void)0);
  ((void)0);
  switch( pExpr->op ){
    case 162: {




      Table *pTab = 0;
      Select *pS = 0;
      int iCol = pExpr->iColumn;
      while( pNC && !pTab ){
        SrcList *pTabList = pNC->pSrcList;
        for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);
        if( j<pTabList->nSrc ){
          pTab = pTabList->a[j].pTab;
          pS = pTabList->a[j].pSelect;
        }else{
          pNC = pNC->pNext;
        }
      }

      if( pTab==0 ){
# 127305 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        break;
      }

      ((void)0);
      if( pS ){




        if( iCol>=0 && iCol<pS->pEList->nExpr ){




          NameContext sNC;
          Expr *p = pS->pEList->a[iCol].pExpr;
          sNC.pSrcList = pS->pSrc;
          sNC.pNext = pNC;
          sNC.pParse = pNC->pParse;
          zType = columnTypeImpl(&sNC,p);
        }
      }else{

        ((void)0);
# 127345 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        ((void)0);
        if( iCol<0 ){
          zType = "INTEGER";
        }else{
          zType = sqlite3ColumnType(&pTab->aCol[iCol],0);
        }

      }
      break;
    }

    case 134: {




      NameContext sNC;
      Select *pS = pExpr->x.pSelect;
      Expr *p = pS->pEList->a[0].pExpr;
      ((void)0);
      sNC.pSrcList = pS->pSrc;
      sNC.pNext = pNC;
      sNC.pParse = pNC->pParse;
      zType = columnTypeImpl(&sNC,p);
      break;
    }

  }
# 127382 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return zType;
}





static void generateColumnTypes(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pEList
){

  Vdbe *v = pParse->pVdbe;
  int i;
  NameContext sNC;
  sNC.pSrcList = pTabList;
  sNC.pParse = pParse;
  sNC.pNext = 0;
  for(i=0; i<pEList->nExpr; i++){
    Expr *p = pEList->a[i].pExpr;
    const char *zType;
# 127418 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    zType = columnTypeImpl(&sNC,p);

    sqlite3VdbeSetColName(v, i, 1, zType, ((sqlite3_destructor_type)-1));
  }

}
# 127456 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void generateColumnNames(
  Parse *pParse,
  Select *pSelect
){
  Vdbe *v = pParse->pVdbe;
  int i;
  Table *pTab;
  SrcList *pTabList;
  ExprList *pEList;
  sqlite3 *db = pParse->db;
  int fullName;
  int srcName;



  if( pParse->explain ){
    return;
  }


  if( pParse->colNamesSet ) return;

  while( pSelect->pPrior ) pSelect = pSelect->pPrior;
  ;
  pTabList = pSelect->pSrc;
  pEList = pSelect->pEList;
  ((void)0);
  ((void)0);
  pParse->colNamesSet = 1;
  fullName = (db->flags & 0x00000004)!=0;
  srcName = (db->flags & 0x00000040)!=0 || fullName;
  sqlite3VdbeSetNumCols(v, pEList->nExpr);
  for(i=0; i<pEList->nExpr; i++){
    Expr *p = pEList->a[i].pExpr;

    ((void)0);
    ((void)0);
    ((void)0);
    if( pEList->a[i].zName ){

      char *zName = pEList->a[i].zName;
      sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type)-1));
    }else if( srcName && p->op==162 ){
      char *zCol;
      int iCol = p->iColumn;
      pTab = p->y.pTab;
      ((void)0);
      if( iCol<0 ) iCol = pTab->iPKey;
      ((void)0);
      if( iCol<0 ){
        zCol = "rowid";
      }else{
        zCol = pTab->aCol[iCol].zName;
      }
      if( fullName ){
        char *zName = 0;
        zName = sqlite3MPrintf(db, "%s.%s", pTab->zName, zCol);
        sqlite3VdbeSetColName(v, i, 0, zName, ((sqlite3_destructor_type)sqlite3MallocSize));
      }else{
        sqlite3VdbeSetColName(v, i, 0, zCol, ((sqlite3_destructor_type)-1));
      }
    }else{
      const char *z = pEList->a[i].zSpan;
      z = z==0 ? sqlite3MPrintf(db, "column%d", i+1) : sqlite3DbStrDup(db, z);
      sqlite3VdbeSetColName(v, i, 0, z, ((sqlite3_destructor_type)sqlite3MallocSize));
    }
  }
  generateColumnTypes(pParse, pTabList, pEList);
}
# 127548 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ColumnsFromExprList(
  Parse *pParse,
  ExprList *pEList,
  i16 *pnCol,
  Column **paCol
){
  sqlite3 *db = pParse->db;
  int i, j;
  u32 cnt;
  Column *aCol, *pCol;
  int nCol;
  char *zName;
  int nName;
  Hash ht;

  sqlite3HashInit(&ht);
  if( pEList ){
    nCol = pEList->nExpr;
    aCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);
    ;
    if( nCol>32767 ) nCol = 32767;
  }else{
    nCol = 0;
    aCol = 0;
  }
  ((void)0);
  *pnCol = nCol;
  *paCol = aCol;

  for(i=0, pCol=aCol; i<nCol && !db->mallocFailed; i++, pCol++){


    if( (zName = pEList->a[i].zName)!=0 ){

    }else{
      Expr *pColExpr = sqlite3ExprSkipCollateAndLikely(pEList->a[i].pExpr);
      while( pColExpr->op==137 ){
        pColExpr = pColExpr->pRight;
        ((void)0);
      }
      if( pColExpr->op==162 ){

        int iCol = pColExpr->iColumn;
        Table *pTab = pColExpr->y.pTab;
        ((void)0);
        if( iCol<0 ) iCol = pTab->iPKey;
        zName = iCol>=0 ? pTab->aCol[iCol].zName : "rowid";
      }else if( pColExpr->op==59 ){
        ((void)0);
        zName = pColExpr->u.zToken;
      }else{

        zName = pEList->a[i].zSpan;
      }
    }
    if( zName ){
      zName = sqlite3DbStrDup(db, zName);
    }else{
      zName = sqlite3MPrintf(db,"column%d",i+1);
    }




    cnt = 0;
    while( zName && sqlite3HashFind(&ht, zName)!=0 ){
      nName = sqlite3Strlen30(zName);
      if( nName>0 ){
        for(j=nName-1; j>0 && (sqlite3CtypeMap[(unsigned char)(zName[j])]&0x04); j--){}
        if( zName[j]==':' ) nName = j;
      }
      zName = sqlite3MPrintf(db, "%.*z:%u", nName, zName, ++cnt);
      if( cnt>3 ) sqlite3_randomness(sizeof(cnt), &cnt);
    }
    pCol->zName = zName;
    ;
    if( zName && sqlite3HashInsert(&ht, zName, pCol)==pCol ){
      sqlite3OomFault(db);
    }
  }
  sqlite3HashClear(&ht);
  if( db->mallocFailed ){
    for(j=0; j<i; j++){
      sqlite3DbFree(db, aCol[j].zName);
    }
    sqlite3DbFree(db, aCol);
    *paCol = 0;
    *pnCol = 0;
    return 7;
  }
  return 0;
}
# 127652 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SelectAddColumnTypeAndCollation(
  Parse *pParse,
  Table *pTab,
  Select *pSelect,
  char aff
){
  sqlite3 *db = pParse->db;
  NameContext sNC;
  Column *pCol;
  CollSeq *pColl;
  int i;
  Expr *p;
  struct ExprList_item *a;

  ((void)0);
  ((void)0);
  ((void)0);
  if( db->mallocFailed ) return;
  memset(&sNC, 0, sizeof(sNC));
  sNC.pSrcList = pSelect->pSrc;
  a = pSelect->pEList->a;
  for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){
    const char *zType;
    int n, m;
    p = a[i].pExpr;
    zType = columnTypeImpl(&sNC,p);

    pCol->affinity = sqlite3ExprAffinity(p);
    if( zType ){
      m = sqlite3Strlen30(zType);
      n = sqlite3Strlen30(pCol->zName);
      pCol->zName = sqlite3DbReallocOrFree(db, pCol->zName, n+m+2);
      if( pCol->zName ){
        memcpy(&pCol->zName[n+1], zType, m+1);
        pCol->colFlags |= 0x0004;
      }
    }
    if( pCol->affinity<=0x40 ) pCol->affinity = aff;
    pColl = sqlite3ExprCollSeq(pParse, p);
    if( pColl && pCol->zColl==0 ){
      pCol->zColl = sqlite3DbStrDup(db, pColl->zName);
    }
  }
  pTab->szTabRow = 1;
}





static Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect, char aff){
  Table *pTab;
  sqlite3 *db = pParse->db;
  u64 savedFlags;

  savedFlags = db->flags;
  db->flags &= ~(u64)0x00000004;
  db->flags |= 0x00000040;
  sqlite3SelectPrep(pParse, pSelect, 0);
  db->flags = savedFlags;
  if( pParse->nErr ) return 0;
  while( pSelect->pPrior ) pSelect = pSelect->pPrior;
  pTab = sqlite3DbMallocZero(db, sizeof(Table) );
  if( pTab==0 ){
    return 0;
  }
  pTab->nTabRef = 1;
  pTab->zName = 0;
  pTab->nRowLogEst = 200; ((void)0);
  sqlite3ColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);
  sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSelect, aff);
  pTab->iPKey = -1;
  if( db->mallocFailed ){
    sqlite3DeleteTable(db, pTab);
    return 0;
  }
  return pTab;
}





static Vdbe *sqlite3GetVdbe(Parse *pParse){
  if( pParse->pVdbe ){
    return pParse->pVdbe;
  }
  if( pParse->pToplevel==0
   && (((pParse->db)->dbOptFlags&(0x0008))==0)
  ){
    pParse->okConstFactor = 1;
  }
  return sqlite3VdbeCreate(pParse);
}
# 127771 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){
  Vdbe *v = 0;
  int iLimit = 0;
  int iOffset;
  int n;
  Expr *pLimit = p->pLimit;

  if( p->iLimit ) return;







  if( pLimit ){
    ((void)0);
    ((void)0);
    p->iLimit = iLimit = ++pParse->nMem;
    v = sqlite3GetVdbe(pParse);
    ((void)0);
    if( sqlite3ExprIsInteger(pLimit->pLeft, &n) ){
      sqlite3VdbeAddOp2(v, 70, n, iLimit);
      ;
      if( n==0 ){
        sqlite3VdbeGoto(v, iBreak);
      }else if( n>=0 && p->nSelectRow>sqlite3LogEst((u64)n) ){
        p->nSelectRow = sqlite3LogEst((u64)n);
        p->selFlags |= 0x04000;
      }
    }else{
      sqlite3ExprCode(pParse, pLimit->pLeft, iLimit);
      sqlite3VdbeAddOp1(v, 15, iLimit); ;
      ;
      sqlite3VdbeAddOp2(v, 20, iLimit, iBreak); ;
    }
    if( pLimit->pRight ){
      p->iOffset = iOffset = ++pParse->nMem;
      pParse->nMem++;
      sqlite3ExprCode(pParse, pLimit->pRight, iOffset);
      sqlite3VdbeAddOp1(v, 15, iOffset); ;
      ;
      sqlite3VdbeAddOp3(v, 152, iLimit, iOffset+1, iOffset);
      ;
    }
  }
}
# 127828 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){
  CollSeq *pRet;
  if( p->pPrior ){
    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);
  }else{
    pRet = 0;
  }
  ((void)0);



  if( pRet==0 && (iCol<p->pEList->nExpr) ){
    pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);
  }
  return pRet;
}
# 127854 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static KeyInfo *multiSelectOrderByKeyInfo(Parse *pParse, Select *p, int nExtra){
  ExprList *pOrderBy = p->pOrderBy;
  int nOrderBy = p->pOrderBy->nExpr;
  sqlite3 *db = pParse->db;
  KeyInfo *pRet = sqlite3KeyInfoAlloc(db, nOrderBy+nExtra, 1);
  if( pRet ){
    int i;
    for(i=0; i<nOrderBy; i++){
      struct ExprList_item *pItem = &pOrderBy->a[i];
      Expr *pTerm = pItem->pExpr;
      CollSeq *pColl;

      if( pTerm->flags & 0x000100 ){
        pColl = sqlite3ExprCollSeq(pParse, pTerm);
      }else{
        pColl = multiSelectCollSeq(pParse, p, pItem->u.x.iOrderByCol-1);
        if( pColl==0 ) pColl = db->pDfltColl;
        pOrderBy->a[i].pExpr =
          sqlite3ExprAddCollateString(pParse, pTerm, pColl->zName);
      }
      ((void)0);
      pRet->aColl[i] = pColl;
      pRet->aSortFlags[i] = pOrderBy->a[i].sortFlags;
    }
  }

  return pRet;
}
# 127920 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void generateWithRecursiveQuery(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  SrcList *pSrc = p->pSrc;
  int nCol = p->pEList->nExpr;
  Vdbe *v = pParse->pVdbe;
  Select *pSetup = p->pPrior;
  int addrTop;
  int addrCont, addrBreak;
  int iCurrent = 0;
  int regCurrent;
  int iQueue;
  int iDistinct = 0;
  int eDest = 5;
  SelectDest destQueue;
  int i;
  int rc;
  ExprList *pOrderBy;
  Expr *pLimit;
  int regLimit, regOffset;


  if( p->pWin ){
    sqlite3ErrorMsg(pParse, "cannot use window functions in recursive queries");
    return;
  }



  if( sqlite3AuthCheck(pParse, 33, 0, 0, 0) ) return;


  addrBreak = sqlite3VdbeMakeLabel(pParse);
  p->nSelectRow = 320;
  computeLimitRegisters(pParse, p, addrBreak);
  pLimit = p->pLimit;
  regLimit = p->iLimit;
  regOffset = p->iOffset;
  p->pLimit = 0;
  p->iLimit = p->iOffset = 0;
  pOrderBy = p->pOrderBy;


  for(i=0; (i<pSrc->nSrc); i++){
    if( pSrc->a[i].fg.isRecursive ){
      iCurrent = pSrc->a[i].iCursor;
      break;
    }
  }




  iQueue = pParse->nTab++;
  if( p->op==130 ){
    eDest = pOrderBy ? 8 : 6;
    iDistinct = pParse->nTab++;
  }else{
    eDest = pOrderBy ? 7 : 5;
  }
  sqlite3SelectDestInit(&destQueue, eDest, iQueue);


  regCurrent = ++pParse->nMem;
  sqlite3VdbeAddOp3(v, 116, iCurrent, regCurrent, nCol);
  if( pOrderBy ){
    KeyInfo *pKeyInfo = multiSelectOrderByKeyInfo(pParse, p, 1);
    sqlite3VdbeAddOp4(v, 112, iQueue, pOrderBy->nExpr+2, 0,
                      (char*)pKeyInfo, (-9));
    destQueue.pOrderBy = pOrderBy;
  }else{
    sqlite3VdbeAddOp2(v, 112, iQueue, nCol);
  }
  ;
  if( iDistinct ){
    p->addrOpenEphm[0] = sqlite3VdbeAddOp2(v, 112, iDistinct, 0);
    p->selFlags |= 0x00020;
  }


  p->pOrderBy = 0;


  pSetup->pNext = 0;
  sqlite3VdbeExplain (pParse, 1, "SETUP");
  rc = sqlite3Select(pParse, pSetup, &destQueue);
  pSetup->pNext = p;
  if( rc ) goto end_of_recursive_query;


  addrTop = sqlite3VdbeAddOp2(v, 36, iQueue, addrBreak); ;


  sqlite3VdbeAddOp1(v, 129, iCurrent);
  if( pOrderBy ){
    sqlite3VdbeAddOp3(v, 90, iQueue, pOrderBy->nExpr+1, regCurrent);
  }else{
    sqlite3VdbeAddOp2(v, 127, iQueue, regCurrent);
  }
  sqlite3VdbeAddOp1(v, 123, iQueue);


  addrCont = sqlite3VdbeMakeLabel(pParse);
  codeOffset(v, regOffset, addrCont);
  selectInnerLoop(pParse, p, iCurrent,
      0, 0, pDest, addrCont, addrBreak);
  if( regLimit ){
    sqlite3VdbeAddOp2(v, 49, regLimit, addrBreak);
    ;
  }
  sqlite3VdbeResolveLabel(v, addrCont);




  if( p->selFlags & 0x00008 ){
    sqlite3ErrorMsg(pParse, "recursive aggregate queries not supported");
  }else{
    p->pPrior = 0;
    sqlite3VdbeExplain (pParse, 1, "RECURSIVE STEP");
    sqlite3Select(pParse, p, &destQueue);
    ((void)0);
    p->pPrior = pSetup;
  }


  sqlite3VdbeGoto(v, addrTop);
  sqlite3VdbeResolveLabel(v, addrBreak);

end_of_recursive_query:
  sqlite3ExprListDelete(pParse->db, p->pOrderBy);
  p->pOrderBy = pOrderBy;
  p->pLimit = pLimit;
  return;
}



static int multiSelectOrderBy(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
);
# 128082 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int multiSelectValues(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int nRow = 1;
  int rc = 0;
  int bShowAll = p->pLimit==0;
  ((void)0);
  do{
    ((void)0);
    ((void)0);
    ((void)0);
    if( p->pPrior==0 ) break;
    ((void)0);
    p = p->pPrior;
    nRow += bShowAll;
  }while(1);
  sqlite3VdbeExplain (pParse, 0, "SCAN %d CONSTANT ROW%s", nRow, nRow==1 ? "" : "S")
                                        ;
  while( p ){
    selectInnerLoop(pParse, p, -1, 0, 0, pDest, 1, 1);
    if( !bShowAll ) break;
    p->nSelectRow = nRow;
    p = p->pNext;
  }
  return rc;
}
# 128142 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int multiSelect(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int rc = 0;
  Select *pPrior;
  Vdbe *v;
  SelectDest dest;
  Select *pDelete = 0;
  sqlite3 *db;




  ((void)0);
  ((void)0);
  ((void)0);
  db = pParse->db;
  pPrior = p->pPrior;
  dest = *pDest;
  if( pPrior->pOrderBy || pPrior->pLimit ){
    sqlite3ErrorMsg(pParse,"%s clause should come after %s not before",
      pPrior->pOrderBy!=0 ? "ORDER BY" : "LIMIT", selectOpName(p->op));
    rc = 1;
    goto multi_select_end;
  }

  v = sqlite3GetVdbe(pParse);
  ((void)0);



  if( dest.eDest==12 ){
    ((void)0);
    sqlite3VdbeAddOp2(v, 112, dest.iSDParm, p->pEList->nExpr);
    dest.eDest = 14;
  }



  if( p->selFlags & 0x00400 ){
    rc = multiSelectValues(pParse, p, &dest);
    goto multi_select_end;
  }




  ((void)0);
  ((void)0);


  if( p->selFlags & 0x02000 ){
    generateWithRecursiveQuery(pParse, p, &dest);
  }else




  if( p->pOrderBy ){
    return multiSelectOrderBy(pParse, p, pDest);
  }else{


    if( pPrior->pPrior==0 ){
      sqlite3VdbeExplain (pParse, 1, "COMPOUND QUERY");
      sqlite3VdbeExplain (pParse, 1, "LEFT-MOST SUBQUERY");
    }




    switch( p->op ){
      case 131: {
        int addr = 0;
        int nLimit;
        ((void)0);
        pPrior->iLimit = p->iLimit;
        pPrior->iOffset = p->iOffset;
        pPrior->pLimit = p->pLimit;
        rc = sqlite3Select(pParse, pPrior, &dest);
        p->pLimit = 0;
        if( rc ){
          goto multi_select_end;
        }
        p->pPrior = 0;
        p->iLimit = pPrior->iLimit;
        p->iOffset = pPrior->iOffset;
        if( p->iLimit ){
          addr = sqlite3VdbeAddOp1(v, 20, p->iLimit); ;
          ;
          if( p->iOffset ){
            sqlite3VdbeAddOp3(v, 152,
                              p->iLimit, p->iOffset+1, p->iOffset);
          }
        }
        sqlite3VdbeExplain (pParse, 1, "UNION ALL");
        rc = sqlite3Select(pParse, p, &dest);
        ;
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
        if( pPrior->pLimit
         && sqlite3ExprIsInteger(pPrior->pLimit->pLeft, &nLimit)
         && nLimit>0 && p->nSelectRow > sqlite3LogEst((u64)nLimit)
        ){
          p->nSelectRow = sqlite3LogEst((u64)nLimit);
        }
        if( addr ){
          sqlite3VdbeJumpHere(v, addr);
        }
        break;
      }
      case 132:
      case 130: {
        int unionTab;
        u8 op = 0;
        int priorOp;
        Expr *pLimit;
        int addr;
        SelectDest uniondest;

        ;
        ;
        priorOp = 1;
        if( dest.eDest==priorOp ){



          ((void)0);
          unionTab = dest.iSDParm;
        }else{



          unionTab = pParse->nTab++;
          ((void)0);
          addr = sqlite3VdbeAddOp2(v, 112, unionTab, 0);
          ((void)0);
          p->addrOpenEphm[0] = addr;
          findRightmost(p)->selFlags |= 0x00020;
          ((void)0);
        }



        ((void)0);
        sqlite3SelectDestInit(&uniondest, priorOp, unionTab);
        rc = sqlite3Select(pParse, pPrior, &uniondest);
        if( rc ){
          goto multi_select_end;
        }



        if( p->op==132 ){
          op = 2;
        }else{
          ((void)0);
          op = 1;
        }
        p->pPrior = 0;
        pLimit = p->pLimit;
        p->pLimit = 0;
        uniondest.eDest = op;
        sqlite3VdbeExplain (pParse, 1, "%s USING TEMP B-TREE", selectOpName(p->op))
                                               ;
        rc = sqlite3Select(pParse, p, &uniondest);
        ;


        sqlite3ExprListDelete(db, p->pOrderBy);
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        p->pOrderBy = 0;
        if( p->op==130 ){
          p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
        }
        sqlite3ExprDelete(db, p->pLimit);
        p->pLimit = pLimit;
        p->iLimit = 0;
        p->iOffset = 0;




        ((void)0);
        if( dest.eDest!=priorOp ){
          int iCont, iBreak, iStart;
          ((void)0);
          iBreak = sqlite3VdbeMakeLabel(pParse);
          iCont = sqlite3VdbeMakeLabel(pParse);
          computeLimitRegisters(pParse, p, iBreak);
          sqlite3VdbeAddOp2(v, 36, unionTab, iBreak); ;
          iStart = sqlite3VdbeCurrentAddr(v);
          selectInnerLoop(pParse, p, unionTab,
                          0, 0, &dest, iCont, iBreak);
          sqlite3VdbeResolveLabel(v, iCont);
          sqlite3VdbeAddOp2(v, 5, unionTab, iStart); ;
          sqlite3VdbeResolveLabel(v, iBreak);
          sqlite3VdbeAddOp2(v, 117, unionTab, 0);
        }
        break;
      }
      default: ((void)0); {
        int tab1, tab2;
        int iCont, iBreak, iStart;
        Expr *pLimit;
        int addr;
        SelectDest intersectdest;
        int r1;





        tab1 = pParse->nTab++;
        tab2 = pParse->nTab++;
        ((void)0);

        addr = sqlite3VdbeAddOp2(v, 112, tab1, 0);
        ((void)0);
        p->addrOpenEphm[0] = addr;
        findRightmost(p)->selFlags |= 0x00020;
        ((void)0);



        sqlite3SelectDestInit(&intersectdest, 1, tab1);
        rc = sqlite3Select(pParse, pPrior, &intersectdest);
        if( rc ){
          goto multi_select_end;
        }



        addr = sqlite3VdbeAddOp2(v, 112, tab2, 0);
        ((void)0);
        p->addrOpenEphm[1] = addr;
        p->pPrior = 0;
        pLimit = p->pLimit;
        p->pLimit = 0;
        intersectdest.iSDParm = tab2;
        sqlite3VdbeExplain (pParse, 1, "%s USING TEMP B-TREE", selectOpName(p->op))
                                               ;
        rc = sqlite3Select(pParse, p, &intersectdest);
        ;
        pDelete = p->pPrior;
        p->pPrior = pPrior;
        if( p->nSelectRow>pPrior->nSelectRow ){
          p->nSelectRow = pPrior->nSelectRow;
        }
        sqlite3ExprDelete(db, p->pLimit);
        p->pLimit = pLimit;




        ((void)0);
        iBreak = sqlite3VdbeMakeLabel(pParse);
        iCont = sqlite3VdbeMakeLabel(pParse);
        computeLimitRegisters(pParse, p, iBreak);
        sqlite3VdbeAddOp2(v, 36, tab1, iBreak); ;
        r1 = sqlite3GetTempReg(pParse);
        iStart = sqlite3VdbeAddOp2(v, 127, tab1, r1);
        sqlite3VdbeAddOp4Int(v, 28, tab2, iCont, r1, 0);
        ;
        sqlite3ReleaseTempReg(pParse, r1);
        selectInnerLoop(pParse, p, tab1,
                        0, 0, &dest, iCont, iBreak);
        sqlite3VdbeResolveLabel(v, iCont);
        sqlite3VdbeAddOp2(v, 5, tab1, iStart); ;
        sqlite3VdbeResolveLabel(v, iBreak);
        sqlite3VdbeAddOp2(v, 117, tab2, 0);
        sqlite3VdbeAddOp2(v, 117, tab1, 0);
        break;
      }
    }


    if( p->pNext==0 ){
      sqlite3VdbeExplainPop(pParse);
    }

  }
# 128438 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( p->selFlags & 0x00020 ){
    int i;
    KeyInfo *pKeyInfo;
    Select *pLoop;
    CollSeq **apColl;
    int nCol;

    ((void)0);
    nCol = p->pEList->nExpr;
    pKeyInfo = sqlite3KeyInfoAlloc(db, nCol, 1);
    if( !pKeyInfo ){
      rc = 7;
      goto multi_select_end;
    }
    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){
      *apColl = multiSelectCollSeq(pParse, p, i);
      if( 0==*apColl ){
        *apColl = db->pDfltColl;
      }
    }

    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){
      for(i=0; i<2; i++){
        int addr = pLoop->addrOpenEphm[i];
        if( addr<0 ){


          ((void)0);
          break;
        }
        sqlite3VdbeChangeP2(v, addr, nCol);
        sqlite3VdbeChangeP4(v, addr, (char*)sqlite3KeyInfoRef(pKeyInfo),
                            (-9));
        pLoop->addrOpenEphm[i] = -1;
      }
    }
    sqlite3KeyInfoUnref(pKeyInfo);
  }

multi_select_end:
  pDest->iSdst = dest.iSdst;
  pDest->nSdst = dest.nSdst;
  sqlite3SelectDelete(db, pDelete);
  return rc;
}






static void sqlite3SelectWrongNumTermsError(Parse *pParse, Select *p){
  if( p->selFlags & 0x00200 ){
    sqlite3ErrorMsg(pParse, "all VALUES must have the same number of terms");
  }else{
    sqlite3ErrorMsg(pParse, "SELECTs to the left and right of %s"
      " do not have the same number of result columns", selectOpName(p->op));
  }
}
# 128518 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int generateOutputSubroutine(
  Parse *pParse,
  Select *p,
  SelectDest *pIn,
  SelectDest *pDest,
  int regReturn,
  int regPrev,
  KeyInfo *pKeyInfo,
  int iBreak
){
  Vdbe *v = pParse->pVdbe;
  int iContinue;
  int addr;

  addr = sqlite3VdbeCurrentAddr(v);
  iContinue = sqlite3VdbeMakeLabel(pParse);



  if( regPrev ){
    int addr1, addr2;
    addr1 = sqlite3VdbeAddOp1(v, 20, regPrev); ;
    addr2 = sqlite3VdbeAddOp4(v, 87, pIn->iSdst, regPrev+1, pIn->nSdst,
                              (char*)sqlite3KeyInfoRef(pKeyInfo), (-9));
    sqlite3VdbeAddOp3(v, 16, addr2+2, iContinue, addr2+2); ;
    sqlite3VdbeJumpHere(v, addr1);
    sqlite3VdbeAddOp3(v, 78, pIn->iSdst, regPrev+1, pIn->nSdst-1);
    sqlite3VdbeAddOp2(v, 70, 1, regPrev);
  }
  if( pParse->db->mallocFailed ) return 0;



  codeOffset(v, p->iOffset, iContinue);

  ((void)0);
  ((void)0);
  switch( pDest->eDest ){


    case 12: {
      int r1 = sqlite3GetTempReg(pParse);
      int r2 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp3(v, 92, pIn->iSdst, pIn->nSdst, r1);
      sqlite3VdbeAddOp2(v, 121, pDest->iSDParm, r2);
      sqlite3VdbeAddOp3(v, 122, pDest->iSDParm, r1, r2);
      sqlite3VdbeChangeP5(v, 0x08);
      sqlite3ReleaseTempReg(pParse, r2);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }




    case 11: {
      int r1;
      ;
      r1 = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp4(v, 92, pIn->iSdst, pIn->nSdst,
          r1, pDest->zAffSdst, pIn->nSdst);
      sqlite3VdbeAddOp4Int(v, 132, pDest->iSDParm, r1,
                           pIn->iSdst, pIn->nSdst);
      sqlite3ReleaseTempReg(pParse, r1);
      break;
    }






    case 10: {
      if( pParse->nErr==0 ){
        ;
        sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSDParm, pIn->nSdst);
      }

      break;
    }





    case 13: {
      if( pDest->iSdst==0 ){
        pDest->iSdst = sqlite3GetTempRange(pParse, pIn->nSdst);
        pDest->nSdst = pIn->nSdst;
      }
      sqlite3ExprCodeMove(pParse, pIn->iSdst, pDest->iSdst, pIn->nSdst);
      sqlite3VdbeAddOp1(v, 14, pDest->iSDParm);
      break;
    }
# 128621 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    default: {
      ((void)0);
      sqlite3VdbeAddOp2(v, 81, pIn->iSdst, pIn->nSdst);
      break;
    }
  }



  if( p->iLimit ){
    sqlite3VdbeAddOp2(v, 49, p->iLimit, iBreak); ;
  }



  sqlite3VdbeResolveLabel(v, iContinue);
  sqlite3VdbeAddOp1(v, 66, regReturn);

  return addr;
}
# 128728 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int multiSelectOrderBy(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int i, j;
  Select *pPrior;
  Vdbe *v;
  SelectDest destA;
  SelectDest destB;
  int regAddrA;
  int regAddrB;
  int addrSelectA;
  int addrSelectB;
  int regOutA;
  int regOutB;
  int addrOutA;
  int addrOutB = 0;
  int addrEofA;
  int addrEofA_noB;
  int addrEofB;
  int addrAltB;
  int addrAeqB;
  int addrAgtB;
  int regLimitA;
  int regLimitB;
  int regPrev;
  int savedLimit;
  int savedOffset;
  int labelCmpr;
  int labelEnd;
  int addr1;
  int op;
  KeyInfo *pKeyDup = 0;
  KeyInfo *pKeyMerge;
  sqlite3 *db;
  ExprList *pOrderBy;
  int nOrderBy;
  int *aPermute;

  ((void)0);
  ((void)0);
  db = pParse->db;
  v = pParse->pVdbe;
  ((void)0);
  labelEnd = sqlite3VdbeMakeLabel(pParse);
  labelCmpr = sqlite3VdbeMakeLabel(pParse);




  op = p->op;
  pPrior = p->pPrior;
  ((void)0);
  pOrderBy = p->pOrderBy;
  ((void)0);
  nOrderBy = pOrderBy->nExpr;





  if( op!=131 ){
    for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){
      struct ExprList_item *pItem;
      for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){
        ((void)0);
        if( pItem->u.x.iOrderByCol==i ) break;
      }
      if( j==nOrderBy ){
        Expr *pNew = sqlite3Expr(db, 150, 0);
        if( pNew==0 ) return 7;
        pNew->flags |= 0x000400;
        pNew->u.iValue = i;
        p->pOrderBy = pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);
        if( pOrderBy ) pOrderBy->a[nOrderBy++].u.x.iOrderByCol = (u16)i;
      }
    }
  }
# 128815 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  aPermute = sqlite3DbMallocRawNN(db, sizeof(int)*(nOrderBy + 1));
  if( aPermute ){
    struct ExprList_item *pItem;
    aPermute[0] = nOrderBy;
    for(i=1, pItem=pOrderBy->a; i<=nOrderBy; i++, pItem++){
      ((void)0);
      ((void)0);
      aPermute[i] = pItem->u.x.iOrderByCol - 1;
    }
    pKeyMerge = multiSelectOrderByKeyInfo(pParse, p, 1);
  }else{
    pKeyMerge = 0;
  }



  p->pOrderBy = pOrderBy;
  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);





  if( op==131 ){
    regPrev = 0;
  }else{
    int nExpr = p->pEList->nExpr;
    ((void)0);
    regPrev = pParse->nMem+1;
    pParse->nMem += nExpr+1;
    sqlite3VdbeAddOp2(v, 70, 0, regPrev);
    pKeyDup = sqlite3KeyInfoAlloc(db, nExpr, 1);
    if( pKeyDup ){
      ((void)0);
      for(i=0; i<nExpr; i++){
        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);
        pKeyDup->aSortFlags[i] = 0;
      }
    }
  }



  p->pPrior = 0;
  pPrior->pNext = 0;
  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, "ORDER");
  if( pPrior->pPrior==0 ){
    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, "ORDER");
  }


  computeLimitRegisters(pParse, p, labelEnd);
  if( p->iLimit && op==131 ){
    regLimitA = ++pParse->nMem;
    regLimitB = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 78, p->iOffset ? p->iOffset+1 : p->iLimit,
                                  regLimitA);
    sqlite3VdbeAddOp2(v, 78, regLimitA, regLimitB);
  }else{
    regLimitA = regLimitB = 0;
  }
  sqlite3ExprDelete(db, p->pLimit);
  p->pLimit = 0;

  regAddrA = ++pParse->nMem;
  regAddrB = ++pParse->nMem;
  regOutA = ++pParse->nMem;
  regOutB = ++pParse->nMem;
  sqlite3SelectDestInit(&destA, 13, regAddrA);
  sqlite3SelectDestInit(&destB, 13, regAddrB);

  sqlite3VdbeExplain (pParse, 1, "MERGE (%s)", selectOpName(p->op));




  addrSelectA = sqlite3VdbeCurrentAddr(v) + 1;
  addr1 = sqlite3VdbeAddOp3(v, 13, regAddrA, 0, addrSelectA);
  ;
  pPrior->iLimit = regLimitA;
  sqlite3VdbeExplain (pParse, 1, "LEFT");
  sqlite3Select(pParse, pPrior, &destA);
  sqlite3VdbeEndCoroutine(v, regAddrA);
  sqlite3VdbeJumpHere(v, addr1);




  addrSelectB = sqlite3VdbeCurrentAddr(v) + 1;
  addr1 = sqlite3VdbeAddOp3(v, 13, regAddrB, 0, addrSelectB);
  ;
  savedLimit = p->iLimit;
  savedOffset = p->iOffset;
  p->iLimit = regLimitB;
  p->iOffset = 0;
  sqlite3VdbeExplain (pParse, 1, "RIGHT");
  sqlite3Select(pParse, p, &destB);
  p->iLimit = savedLimit;
  p->iOffset = savedOffset;
  sqlite3VdbeEndCoroutine(v, regAddrB);




  ;
  addrOutA = generateOutputSubroutine(pParse,
                 p, &destA, pDest, regOutA,
                 regPrev, pKeyDup, labelEnd);




  if( op==131 || op==130 ){
    ;
    addrOutB = generateOutputSubroutine(pParse,
                 p, &destB, pDest, regOutB,
                 regPrev, pKeyDup, labelEnd);
  }
  sqlite3KeyInfoUnref(pKeyDup);




  if( op==132 || op==133 ){
    addrEofA_noB = addrEofA = labelEnd;
  }else{
    ;
    addrEofA = sqlite3VdbeAddOp2(v, 12, regOutB, addrOutB);
    addrEofA_noB = sqlite3VdbeAddOp2(v, 14, regAddrB, labelEnd);
                                     ;
    sqlite3VdbeGoto(v, addrEofA);
    p->nSelectRow = sqlite3LogEstAdd(p->nSelectRow, pPrior->nSelectRow);
  }




  if( op==133 ){
    addrEofB = addrEofA;
    if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;
  }else{
    ;
    addrEofB = sqlite3VdbeAddOp2(v, 12, regOutA, addrOutA);
    sqlite3VdbeAddOp2(v, 14, regAddrA, labelEnd); ;
    sqlite3VdbeGoto(v, addrEofB);
  }



  ;
  addrAltB = sqlite3VdbeAddOp2(v, 12, regOutA, addrOutA);
  sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA); ;
  sqlite3VdbeGoto(v, labelCmpr);



  if( op==131 ){
    addrAeqB = addrAltB;
  }else if( op==133 ){
    addrAeqB = addrAltB;
    addrAltB++;
  }else{
    ;
    addrAeqB =
    sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA); ;
    sqlite3VdbeGoto(v, labelCmpr);
  }



  ;
  addrAgtB = sqlite3VdbeCurrentAddr(v);
  if( op==131 || op==130 ){
    sqlite3VdbeAddOp2(v, 12, regOutB, addrOutB);
  }
  sqlite3VdbeAddOp2(v, 14, regAddrB, addrEofB); ;
  sqlite3VdbeGoto(v, labelCmpr);



  sqlite3VdbeJumpHere(v, addr1);
  sqlite3VdbeAddOp2(v, 14, regAddrA, addrEofA_noB); ;
  sqlite3VdbeAddOp2(v, 14, regAddrB, addrEofB); ;



  sqlite3VdbeResolveLabel(v, labelCmpr);
  sqlite3VdbeAddOp4(v, 86, 0, 0, 0, (char*)aPermute, (-15));
  sqlite3VdbeAddOp4(v, 87, destA.iSdst, destB.iSdst, nOrderBy,
                         (char*)pKeyMerge, (-9));
  sqlite3VdbeChangeP5(v, 0x01);
  sqlite3VdbeAddOp3(v, 16, addrAltB, addrAeqB, addrAgtB); ;



  sqlite3VdbeResolveLabel(v, labelEnd);



  if( p->pPrior ){
    sqlite3SelectDelete(db, p->pPrior);
  }
  p->pPrior = pPrior;
  pPrior->pNext = p;



  sqlite3VdbeExplainPop(pParse);
  return pParse->nErr!=0;
}
# 129035 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct SubstContext {
  Parse *pParse;
  int iTable;
  int iNewTable;
  int isLeftJoin;
  ExprList *pEList;
} SubstContext;


static void substExprList(SubstContext*, ExprList*);
static void substSelect(SubstContext*, Select*, int);
# 129060 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *substExpr(
  SubstContext *pSubst,
  Expr *pExpr
){
  if( pExpr==0 ) return 0;
  if( (((pExpr)->flags&(0x000001))!=0)
   && pExpr->iRightJoinTable==pSubst->iTable
  ){
    pExpr->iRightJoinTable = pSubst->iNewTable;
  }
  if( pExpr->op==162 && pExpr->iTable==pSubst->iTable ){
    if( pExpr->iColumn<0 ){
      pExpr->op = 117;
    }else{
      Expr *pNew;
      Expr *pCopy = pSubst->pEList->a[pExpr->iColumn].pExpr;
      Expr ifNullRow;
      ((void)0);
      ((void)0);
      if( sqlite3ExprIsVector(pCopy) ){
        sqlite3VectorErrorMsg(pSubst->pParse, pCopy);
      }else{
        sqlite3 *db = pSubst->pParse->db;
        if( pSubst->isLeftJoin && pCopy->op!=162 ){
          memset(&ifNullRow, 0, sizeof(ifNullRow));
          ifNullRow.op = 174;
          ifNullRow.pLeft = pCopy;
          ifNullRow.iTable = pSubst->iNewTable;
          pCopy = &ifNullRow;
        }
        ;
        pNew = sqlite3ExprDup(db, pCopy, 0);
        if( pNew && pSubst->isLeftJoin ){
          (pNew)->flags|=(0x100000);
        }
        if( pNew && (((pExpr)->flags&(0x000001))!=0) ){
          pNew->iRightJoinTable = pExpr->iRightJoinTable;
          (pNew)->flags|=(0x000001);
        }
        sqlite3ExprDelete(db, pExpr);
        pExpr = pNew;



        if( pExpr ){
          if( pExpr->op!=162 && pExpr->op!=109 ){
            CollSeq *pColl = sqlite3ExprCollSeq(pSubst->pParse, pExpr);
            pExpr = sqlite3ExprAddCollateString(pSubst->pParse, pExpr,
                (pColl ? pColl->zName : "BINARY")
            );
          }
          (pExpr)->flags&=~(0x000100);
        }
      }
    }
  }else{
    if( pExpr->op==174 && pExpr->iTable==pSubst->iTable ){
      pExpr->iTable = pSubst->iNewTable;
    }
    pExpr->pLeft = substExpr(pSubst, pExpr->pLeft);
    pExpr->pRight = substExpr(pSubst, pExpr->pRight);
    if( (((pExpr)->flags&(0x000800))!=0) ){
      substSelect(pSubst, pExpr->x.pSelect, 1);
    }else{
      substExprList(pSubst, pExpr->x.pList);
    }

    if( (((pExpr)->flags&(0x1000000))!=0) ){
      Window *pWin = pExpr->y.pWin;
      pWin->pFilter = substExpr(pSubst, pWin->pFilter);
      substExprList(pSubst, pWin->pPartition);
      substExprList(pSubst, pWin->pOrderBy);
    }

  }
  return pExpr;
}
static void substExprList(
  SubstContext *pSubst,
  ExprList *pList
){
  int i;
  if( pList==0 ) return;
  for(i=0; i<pList->nExpr; i++){
    pList->a[i].pExpr = substExpr(pSubst, pList->a[i].pExpr);
  }
}
static void substSelect(
  SubstContext *pSubst,
  Select *p,
  int doPrior
){
  SrcList *pSrc;
  struct SrcList_item *pItem;
  int i;
  if( !p ) return;
  do{
    substExprList(pSubst, p->pEList);
    substExprList(pSubst, p->pGroupBy);
    substExprList(pSubst, p->pOrderBy);
    p->pHaving = substExpr(pSubst, p->pHaving);
    p->pWhere = substExpr(pSubst, p->pWhere);
    pSrc = p->pSrc;
    ((void)0);
    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){
      substSelect(pSubst, pItem->pSelect, 1);
      if( pItem->fg.isTabFunc ){
        substExprList(pSubst, pItem->u1.pFuncArg);
      }
    }
  }while( doPrior && (p = p->pPrior)!=0 );
}
# 129328 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int flattenSubquery(
  Parse *pParse,
  Select *p,
  int iFrom,
  int isAgg
){
  const char *zSavedAuthContext = pParse->zAuthContext;
  Select *pParent;
  Select *pSub;
  Select *pSub1;
  SrcList *pSrc;
  SrcList *pSubSrc;
  int iParent;
  int iNewParent = -1;
  int isLeftJoin = 0;
  int i;
  Expr *pWhere;
  struct SrcList_item *pSubitem;
  sqlite3 *db = pParse->db;



  ((void)0);
  ((void)0);
  if( (((db)->dbOptFlags&(0x0001))!=0) ) return 0;
  pSrc = p->pSrc;
  ((void)0);
  pSubitem = &pSrc->a[iFrom];
  iParent = pSubitem->iCursor;
  pSub = pSubitem->pSelect;
  ((void)0);


  if( p->pWin || pSub->pWin ) return 0;


  pSubSrc = pSub->pSrc;
  ((void)0);





  if( pSub->pLimit && p->pLimit ) return 0;
  if( pSub->pLimit && pSub->pLimit->pRight ) return 0;
  if( (p->selFlags & 0x00100)!=0 && pSub->pLimit ){
    return 0;
  }
  if( pSubSrc->nSrc==0 ) return 0;
  if( pSub->selFlags & 0x00001 ) return 0;
  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){
     return 0;
  }
  if( p->pOrderBy && pSub->pOrderBy ){
     return 0;
  }
  if( isAgg && pSub->pOrderBy ) return 0;
  if( pSub->pLimit && p->pWhere ) return 0;
  if( pSub->pLimit && (p->selFlags & 0x00001)!=0 ){
     return 0;
  }
  if( pSub->selFlags & (0x02000) ){
    return 0;
  }
# 129413 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (pSubitem->fg.jointype & 0x0020)!=0 ){
    isLeftJoin = 1;
    if( pSubSrc->nSrc>1 || isAgg || ((pSubSrc->a[0].pTab)->nModuleArg) ){

      return 0;
    }
  }
# 129435 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pSub->pPrior ){
    if( pSub->pOrderBy ){
      return 0;
    }
    if( isAgg || (p->selFlags & 0x00001)!=0 || pSrc->nSrc!=1 ){
      return 0;
    }
    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){
      ;
      ;
      ((void)0);
      ((void)0);
      if( (pSub1->selFlags & (0x00001|0x00008))!=0
       || (pSub1->pPrior && pSub1->op!=131)
       || pSub1->pSrc->nSrc<1
      ){
        return 0;
      }
      ;
    }


    if( p->pOrderBy ){
      int ii;
      for(ii=0; ii<p->pOrderBy->nExpr; ii++){
        if( p->pOrderBy->a[ii].u.x.iOrderByCol==0 ) return 0;
      }
    }
  }







  ((void)0);


 
                                             ;


  pParse->zAuthContext = pSubitem->zName;
  sqlite3AuthCheck(pParse, 21, 0, 0, 0);
  ;
  pParse->zAuthContext = zSavedAuthContext;
# 129516 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){
    Select *pNew;
    ExprList *pOrderBy = p->pOrderBy;
    Expr *pLimit = p->pLimit;
    Select *pPrior = p->pPrior;
    p->pOrderBy = 0;
    p->pSrc = 0;
    p->pPrior = 0;
    p->pLimit = 0;
    pNew = sqlite3SelectDup(db, p, 0);
    p->pLimit = pLimit;
    p->pOrderBy = pOrderBy;
    p->pSrc = pSrc;
    p->op = 131;
    if( pNew==0 ){
      p->pPrior = pPrior;
    }else{
      pNew->pPrior = pPrior;
      if( pPrior ) pPrior->pNext = pNew;
      pNew->pNext = p;
      p->pPrior = pNew;
     
                                                                   ;
    }
    if( db->mallocFailed ) return 1;
  }




  pSub = pSub1 = pSubitem->pSelect;




  sqlite3DbFree(db, pSubitem->zDatabase);
  sqlite3DbFree(db, pSubitem->zName);
  sqlite3DbFree(db, pSubitem->zAlias);
  pSubitem->zDatabase = 0;
  pSubitem->zName = 0;
  pSubitem->zAlias = 0;
  pSubitem->pSelect = 0;
# 129566 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (pSubitem->pTab!=0) ){
    Table *pTabToDel = pSubitem->pTab;
    if( pTabToDel->nTabRef==1 ){
      Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
      pTabToDel->pNextZombie = pToplevel->pZombieTab;
      pToplevel->pZombieTab = pTabToDel;
    }else{
      pTabToDel->nTabRef--;
    }
    pSubitem->pTab = 0;
  }
# 129591 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){
    int nSubSrc;
    u8 jointype = 0;
    ((void)0);
    pSubSrc = pSub->pSrc;
    nSubSrc = pSubSrc->nSrc;
    pSrc = pParent->pSrc;

    if( pSrc ){
      ((void)0);
      jointype = pSubitem->fg.jointype;
    }else{
      ((void)0);
      pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
      if( pSrc==0 ) break;
      pParent->pSrc = pSrc;
    }
# 129624 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( nSubSrc>1 ){
      pSrc = sqlite3SrcListEnlarge(pParse, pSrc, nSubSrc-1,iFrom+1);
      if( pSrc==0 ) break;
      pParent->pSrc = pSrc;
    }




    for(i=0; i<nSubSrc; i++){
      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);
      ((void)0);
      pSrc->a[i+iFrom] = pSubSrc->a[i];
      iNewParent = pSubSrc->a[i].iCursor;
      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));
    }
    pSrc->a[iFrom].fg.jointype = jointype;
# 129654 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pSub->pOrderBy ){
# 129665 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      ExprList *pOrderBy = pSub->pOrderBy;
      for(i=0; i<pOrderBy->nExpr; i++){
        pOrderBy->a[i].u.x.iOrderByCol = 0;
      }
      ((void)0);
      pParent->pOrderBy = pOrderBy;
      pSub->pOrderBy = 0;
    }
    pWhere = pSub->pWhere;
    pSub->pWhere = 0;
    if( isLeftJoin>0 ){
      setJoinExpr(pWhere, iNewParent);
    }
    pParent->pWhere = sqlite3ExprAnd(pParse, pWhere, pParent->pWhere);
    if( db->mallocFailed==0 ){
      SubstContext x;
      x.pParse = pParse;
      x.iTable = iParent;
      x.iNewTable = iNewParent;
      x.isLeftJoin = isLeftJoin;
      x.pEList = pSub->pEList;
      substSelect(&x, pParent, 0);
    }



    pParent->selFlags |= pSub->selFlags & 0x00100;
    ((void)0);







    if( pSub->pLimit ){
      pParent->pLimit = pSub->pLimit;
      pSub->pLimit = 0;
    }
  }




  sqlite3SelectDelete(db, pSub1);
# 129718 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return 1;
}






typedef struct WhereConst WhereConst;
struct WhereConst {
  Parse *pParse;
  int nConst;
  int nChng;
  Expr **apExpr;
};





static void constInsert(
  WhereConst *pConst,
  Expr *pColumn,
  Expr *pValue
){
  int i;
  ((void)0);



  for(i=0; i<pConst->nConst; i++){
    const Expr *pExpr = pConst->apExpr[i*2];
    ((void)0);
    if( pExpr->iTable==pColumn->iTable
     && pExpr->iColumn==pColumn->iColumn
    ){
      return;
    }
  }

  pConst->nConst++;
  pConst->apExpr = sqlite3DbReallocOrFree(pConst->pParse->db, pConst->apExpr,
                         pConst->nConst*2*sizeof(Expr*));
  if( pConst->apExpr==0 ){
    pConst->nConst = 0;
  }else{
    if( (((pValue)->flags&(0x000008))!=0) ) pValue = pValue->pLeft;
    pConst->apExpr[pConst->nConst*2-2] = pColumn;
    pConst->apExpr[pConst->nConst*2-1] = pValue;
  }
}







static void findConstInWhere(WhereConst *pConst, Expr *pExpr){
  Expr *pRight, *pLeft;
  if( pExpr==0 ) return;
  if( (((pExpr)->flags&(0x000001))!=0) ) return;
  if( pExpr->op==44 ){
    findConstInWhere(pConst, pExpr->pRight);
    findConstInWhere(pConst, pExpr->pLeft);
    return;
  }
  if( pExpr->op!=53 ) return;
  pRight = pExpr->pRight;
  pLeft = pExpr->pLeft;
  ((void)0);
  ((void)0);
  if( pRight->op==162
   && !(((pRight)->flags&(0x000008))!=0)
   && sqlite3ExprIsConstant(pLeft)
   && sqlite3IsBinary(sqlite3BinaryCompareCollSeq(pConst->pParse,pLeft,pRight))
  ){
    constInsert(pConst, pRight, pLeft);
  }else
  if( pLeft->op==162
   && !(((pLeft)->flags&(0x000008))!=0)
   && sqlite3ExprIsConstant(pRight)
   && sqlite3IsBinary(sqlite3BinaryCompareCollSeq(pConst->pParse,pLeft,pRight))
  ){
    constInsert(pConst, pLeft, pRight);
  }
}







static int propagateConstantExprRewrite(Walker *pWalker, Expr *pExpr){
  int i;
  WhereConst *pConst;
  if( pExpr->op!=162 ) return 0;
  if( (((pExpr)->flags&(0x000008))!=0) ) return 0;
  pConst = pWalker->u.pConst;
  for(i=0; i<pConst->nConst; i++){
    Expr *pColumn = pConst->apExpr[i*2];
    if( pColumn==pExpr ) continue;
    if( pColumn->iTable!=pExpr->iTable ) continue;
    if( pColumn->iColumn!=pExpr->iColumn ) continue;

    pConst->nChng++;
    (pExpr)->flags&=~(0x800000);
    (pExpr)->flags|=(0x000008);
    ((void)0);
    pExpr->pLeft = sqlite3ExprDup(pConst->pParse->db, pConst->apExpr[i*2+1], 0);
    break;
  }
  return 1;
}
# 129871 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int propagateConstants(
  Parse *pParse,
  Select *p
){
  WhereConst x;
  Walker w;
  int nChng = 0;
  x.pParse = pParse;
  do{
    x.nConst = 0;
    x.nChng = 0;
    x.apExpr = 0;
    findConstInWhere(&x, p->pWhere);
    if( x.nConst ){
      memset(&w, 0, sizeof(w));
      w.pParse = pParse;
      w.xExprCallback = propagateConstantExprRewrite;
      w.xSelectCallback = sqlite3SelectWalkNoop;
      w.xSelectCallback2 = 0;
      w.walkerDepth = 0;
      w.u.pConst = &x;
      sqlite3WalkExpr(&w, p->pWhere);
      sqlite3DbFree(x.pParse->db, x.apExpr);
      nChng += x.nChng;
    }
  }while( x.nChng );
  return nChng;
}
# 129954 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int pushDownWhereTerms(
  Parse *pParse,
  Select *pSubq,
  Expr *pWhere,
  int iCursor,
  int isLeftJoin
){
  Expr *pNew;
  int nChng = 0;
  if( pWhere==0 ) return 0;
  if( pSubq->selFlags & 0x02000 ) return 0;


  if( pSubq->pWin ) return 0;
# 129983 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pSubq->pLimit!=0 ){
    return 0;
  }
  while( pWhere->op==44 ){
    nChng += pushDownWhereTerms(pParse, pSubq, pWhere->pRight,
                                iCursor, isLeftJoin);
    pWhere = pWhere->pLeft;
  }
  if( isLeftJoin
   && ((((pWhere)->flags&(0x000001))!=0)==0
         || pWhere->iRightJoinTable!=iCursor)
  ){
    return 0;
  }
  if( (((pWhere)->flags&(0x000001))!=0) && pWhere->iRightJoinTable!=iCursor ){
    return 0;
  }
  if( sqlite3ExprIsTableConstant(pWhere, iCursor) ){
    nChng++;
    while( pSubq ){
      SubstContext x;
      pNew = sqlite3ExprDup(pParse->db, pWhere, 0);
      unsetJoinExpr(pNew, -1);
      x.pParse = pParse;
      x.iTable = iCursor;
      x.iNewTable = iCursor;
      x.isLeftJoin = 0;
      x.pEList = pSubq->pEList;
      pNew = substExpr(&x, pNew);
      if( pSubq->selFlags & 0x00008 ){
        pSubq->pHaving = sqlite3ExprAnd(pParse, pSubq->pHaving, pNew);
      }else{
        pSubq->pWhere = sqlite3ExprAnd(pParse, pSubq->pWhere, pNew);
      }
      pSubq = pSubq->pPrior;
    }
  }
  return nChng;
}
# 130040 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u8 minMaxQuery(sqlite3 *db, Expr *pFunc, ExprList **ppMinMax){
  int eRet = 0x0000;
  ExprList *pEList = pFunc->x.pList;
  const char *zFunc;
  ExprList *pOrderBy;
  u8 sortFlags;

  ((void)0);
  ((void)0);
  ((void)0);
  if( pEList==0 || pEList->nExpr!=1 || (((pFunc)->flags&(0x1000000))!=0) ){
    return eRet;
  }
  zFunc = pFunc->u.zToken;
  if( sqlite3StrICmp(zFunc, "min")==0 ){
    eRet = 0x0001;
    sortFlags = 0x02;
  }else if( sqlite3StrICmp(zFunc, "max")==0 ){
    eRet = 0x0002;
    sortFlags = 0x01;
  }else{
    return eRet;
  }
  *ppMinMax = pOrderBy = sqlite3ExprListDup(db, pEList, 0);
  ((void)0);
  if( pOrderBy ) pOrderBy->a[0].sortFlags = sortFlags;
  return eRet;
}
# 130080 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Table *isSimpleCount(Select *p, AggInfo *pAggInfo){
  Table *pTab;
  Expr *pExpr;

  ((void)0);

  if( p->pWhere || p->pEList->nExpr!=1
   || p->pSrc->nSrc!=1 || p->pSrc->a[0].pSelect
  ){
    return 0;
  }
  pTab = p->pSrc->a[0].pTab;
  pExpr = p->pEList->a[0].pExpr;
  ((void)0);

  if( ((pTab)->nModuleArg) ) return 0;
  if( pExpr->op!=163 ) return 0;
  if( (pAggInfo->nFunc==0) ) return 0;
  if( (pAggInfo->aFunc[0].pFunc->funcFlags&0x0100)==0 ) return 0;
  if( (((pExpr)->flags&(0x000002|0x1000000))!=0) ) return 0;

  return pTab;
}
# 130111 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->pTab && pFrom->fg.isIndexedBy ){
    Table *pTab = pFrom->pTab;
    char *zIndexedBy = pFrom->u1.zIndexedBy;
    Index *pIdx;
    for(pIdx=pTab->pIndex;
        pIdx && sqlite3StrICmp(pIdx->zName, zIndexedBy);
        pIdx=pIdx->pNext
    );
    if( !pIdx ){
      sqlite3ErrorMsg(pParse, "no such index: %s", zIndexedBy, 0);
      pParse->checkSchema = 1;
      return 1;
    }
    pFrom->pIBIndex = pIdx;
  }
  return 0;
}
# 130150 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int convertCompoundSelectToSubquery(Walker *pWalker, Select *p){
  int i;
  Select *pNew;
  Select *pX;
  sqlite3 *db;
  struct ExprList_item *a;
  SrcList *pNewSrc;
  Parse *pParse;
  Token dummy;

  if( p->pPrior==0 ) return 0;
  if( p->pOrderBy==0 ) return 0;
  for(pX=p; pX && (pX->op==131 || pX->op==134); pX=pX->pPrior){}
  if( pX==0 ) return 0;
  a = p->pOrderBy->a;
  for(i=p->pOrderBy->nExpr-1; i>=0; i--){
    if( a[i].pExpr->flags & 0x000100 ) break;
  }
  if( i<0 ) return 0;



  pParse = pWalker->pParse;
  db = pParse->db;
  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );
  if( pNew==0 ) return 2;
  memset(&dummy, 0, sizeof(dummy));
  pNewSrc = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&dummy,pNew,0,0);
  if( pNewSrc==0 ) return 2;
  *pNew = *p;
  p->pSrc = pNewSrc;
  p->pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, 175, 0));
  p->op = 134;
  p->pWhere = 0;
  pNew->pGroupBy = 0;
  pNew->pHaving = 0;
  pNew->pOrderBy = 0;
  p->pPrior = 0;
  p->pNext = 0;
  p->pWith = 0;
  p->selFlags &= ~0x00100;
  ((void)0);
  p->selFlags |= 0x10000;
  ((void)0);
  pNew->pPrior->pNext = pNew;
  pNew->pLimit = 0;
  return 0;
}






static int cannotBeFunction(Parse *pParse, struct SrcList_item *pFrom){
  if( pFrom->fg.isTabFunc ){
    sqlite3ErrorMsg(pParse, "'%s' is not a function", pFrom->zName);
    return 1;
  }
  return 0;
}
# 130223 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static struct Cte *searchWith(
  With *pWith,
  struct SrcList_item *pItem,
  With **ppContext
){
  const char *zName;
  if( pItem->zDatabase==0 && (zName = pItem->zName)!=0 ){
    With *p;
    for(p=pWith; p; p=p->pOuter){
      int i;
      for(i=0; i<p->nCte; i++){
        if( sqlite3StrICmp(zName, p->a[i].zName)==0 ){
          *ppContext = p;
          return &p->a[i];
        }
      }
    }
  }
  return 0;
}
# 130254 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WithPush(Parse *pParse, With *pWith, u8 bFree){
  ((void)0);
  if( pWith ){
    ((void)0);
    pWith->pOuter = pParse->pWith;
    pParse->pWith = pWith;
    if( bFree ) pParse->pWithToFree = pWith;
  }
}
# 130279 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int withExpand(
  Walker *pWalker,
  struct SrcList_item *pFrom
){
  Parse *pParse = pWalker->pParse;
  sqlite3 *db = pParse->db;
  struct Cte *pCte;
  With *pWith;

  ((void)0);

  pCte = searchWith(pParse->pWith, pFrom, &pWith);
  if( pCte ){
    Table *pTab;
    ExprList *pEList;
    Select *pSel;
    Select *pLeft;
    int bMayRecursive;
    With *pSavedWith;





    if( pCte->zCteErr ){
      sqlite3ErrorMsg(pParse, pCte->zCteErr, pCte->zName);
      return 1;
    }
    if( cannotBeFunction(pParse, pFrom) ) return 1;

    ((void)0);
    pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));
    if( pTab==0 ) return 2;
    pTab->nTabRef = 1;
    pTab->zName = sqlite3DbStrDup(db, pCte->zName);
    pTab->iPKey = -1;
    pTab->nRowLogEst = 200; ((void)0);
    pTab->tabFlags |= 0x0002 | 0x0040;
    pFrom->pSelect = sqlite3SelectDup(db, pCte->pSelect, 0);
    if( db->mallocFailed ) return 7;
    ((void)0);


    pSel = pFrom->pSelect;
    bMayRecursive = ( pSel->op==131 || pSel->op==130 );
    if( bMayRecursive ){
      int i;
      SrcList *pSrc = pFrom->pSelect->pSrc;
      for(i=0; i<pSrc->nSrc; i++){
        struct SrcList_item *pItem = &pSrc->a[i];
        if( pItem->zDatabase==0
         && pItem->zName!=0
         && 0==sqlite3StrICmp(pItem->zName, pCte->zName)
          ){
          pItem->pTab = pTab;
          pItem->fg.isRecursive = 1;
          pTab->nTabRef++;
          pSel->selFlags |= 0x02000;
        }
      }
    }


    if( pTab->nTabRef>2 ){
      sqlite3ErrorMsg(
          pParse, "multiple references to recursive table: %s", pCte->zName
      );
      return 1;
    }
    ((void)0)
                                                                 ;

    pCte->zCteErr = "circular reference: %s";
    pSavedWith = pParse->pWith;
    pParse->pWith = pWith;
    if( bMayRecursive ){
      Select *pPrior = pSel->pPrior;
      ((void)0);
      pPrior->pWith = pSel->pWith;
      sqlite3WalkSelect(pWalker, pPrior);
      pPrior->pWith = 0;
    }else{
      sqlite3WalkSelect(pWalker, pSel);
    }
    pParse->pWith = pWith;

    for(pLeft=pSel; pLeft->pPrior; pLeft=pLeft->pPrior);
    pEList = pLeft->pEList;
    if( pCte->pCols ){
      if( pEList && pEList->nExpr!=pCte->pCols->nExpr ){
        sqlite3ErrorMsg(pParse, "table %s has %d values for %d columns",
            pCte->zName, pEList->nExpr, pCte->pCols->nExpr
        );
        pParse->pWith = pSavedWith;
        return 1;
      }
      pEList = pCte->pCols;
    }

    sqlite3ColumnsFromExprList(pParse, pEList, &pTab->nCol, &pTab->aCol);
    if( bMayRecursive ){
      if( pSel->selFlags & 0x02000 ){
        pCte->zCteErr = "multiple recursive references: %s";
      }else{
        pCte->zCteErr = "recursive reference in a subquery: %s";
      }
      sqlite3WalkSelect(pWalker, pSel);
    }
    pCte->zCteErr = 0;
    pParse->pWith = pSavedWith;
  }

  return 0;
}
# 130404 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void selectPopWith(Walker *pWalker, Select *p){
  Parse *pParse = pWalker->pParse;
  if( (pParse->pWith) && p->pPrior==0 ){
    With *pWith = findRightmost(p)->pWith;
    if( pWith!=0 ){
      ((void)0);
      pParse->pWith = pWith->pOuter;
    }
  }
}
# 130425 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExpandSubquery(Parse *pParse, struct SrcList_item *pFrom){
  Select *pSel = pFrom->pSelect;
  Table *pTab;

  ((void)0);
  pFrom->pTab = pTab = sqlite3DbMallocZero(pParse->db, sizeof(Table));
  if( pTab==0 ) return 7;
  pTab->nTabRef = 1;
  if( pFrom->zAlias ){
    pTab->zName = sqlite3DbStrDup(pParse->db, pFrom->zAlias);
  }else{
    pTab->zName = sqlite3MPrintf(pParse->db, "subquery_%u", pSel->selId);
  }
  while( pSel->pPrior ){ pSel = pSel->pPrior; }
  sqlite3ColumnsFromExprList(pParse, pSel->pEList,&pTab->nCol,&pTab->aCol);
  pTab->iPKey = -1;
  pTab->nRowLogEst = 200; ((void)0);
  pTab->tabFlags |= 0x0002;

  return pParse->nErr ? 1 : 0;
}
# 130471 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int selectExpander(Walker *pWalker, Select *p){
  Parse *pParse = pWalker->pParse;
  int i, j, k;
  SrcList *pTabList;
  ExprList *pEList;
  struct SrcList_item *pFrom;
  sqlite3 *db = pParse->db;
  Expr *pE, *pRight, *pExpr;
  u16 selFlags = p->selFlags;
  u32 elistFlags = 0;

  p->selFlags |= 0x00040;
  if( db->mallocFailed ){
    return 2;
  }
  ((void)0);
  if( (selFlags & 0x00040)!=0 ){
    return 1;
  }
  if( pWalker->eCode ){

    p->selId = ++pParse->nSelect;
  }
  pTabList = p->pSrc;
  pEList = p->pEList;
  sqlite3WithPush(pParse, p->pWith, 0);




  sqlite3SrcListAssignCursors(pParse, pTabList);





  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
    Table *pTab;
    ((void)0);
    if( pFrom->fg.isRecursive ) continue;
    ((void)0);

    if( withExpand(pWalker, pFrom) ) return 2;
    if( pFrom->pTab ) {} else

    if( pFrom->zName==0 ){

      Select *pSel = pFrom->pSelect;

      ((void)0);
      ((void)0);
      if( sqlite3WalkSelect(pWalker, pSel) ) return 2;
      if( sqlite3ExpandSubquery(pParse, pFrom) ) return 2;

    }else{

      ((void)0);
      pFrom->pTab = pTab = sqlite3LocateTableItem(pParse, 0, pFrom);
      if( pTab==0 ) return 2;
      if( pTab->nTabRef>=0xffff ){
        sqlite3ErrorMsg(pParse, "too many references to \"%s\": max 65535",
           pTab->zName);
        pFrom->pTab = 0;
        return 2;
      }
      pTab->nTabRef++;
      if( !((pTab)->nModuleArg) && cannotBeFunction(pParse, pFrom) ){
        return 2;
      }

      if( ((pTab)->nModuleArg) || pTab->pSelect ){
        i16 nCol;
        u8 eCodeOrig = pWalker->eCode;
        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return 2;
        ((void)0);
        if( pTab->pSelect && (db->flags & 0x80000000)==0 ){
          sqlite3ErrorMsg(pParse, "access to view \"%s\" prohibited",
              pTab->zName);
        }
        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);
        nCol = pTab->nCol;
        pTab->nCol = -1;
        pWalker->eCode = 1;
        sqlite3WalkSelect(pWalker, pFrom->pSelect);
        pWalker->eCode = eCodeOrig;
        pTab->nCol = nCol;
      }

    }


    if( sqlite3IndexedByLookup(pParse, pFrom) ){
      return 2;
    }
  }



  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){
    return 2;
  }
# 130584 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(k=0; k<pEList->nExpr; k++){
    pE = pEList->a[k].pExpr;
    if( pE->op==175 ) break;
    ((void)0);
    ((void)0);
    if( pE->op==137 && pE->pRight->op==175 ) break;
    elistFlags |= pE->flags;
  }
  if( k<pEList->nExpr ){





    struct ExprList_item *a = pEList->a;
    ExprList *pNew = 0;
    int flags = pParse->db->flags;
    int longNames = (flags & 0x00000004)!=0
                      && (flags & 0x00000040)==0;

    for(k=0; k<pEList->nExpr; k++){
      pE = a[k].pExpr;
      elistFlags |= pE->flags;
      pRight = pE->pRight;
      ((void)0);
      if( pE->op!=175
       && (pE->op!=137 || pRight->op!=175)
      ){


        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);
        if( pNew ){
          pNew->a[pNew->nExpr-1].zName = a[k].zName;
          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;
          a[k].zName = 0;
          a[k].zSpan = 0;
        }
        a[k].pExpr = 0;
      }else{


        int tableSeen = 0;
        char *zTName = 0;
        if( pE->op==137 ){
          ((void)0);
          ((void)0);
          zTName = pE->pLeft->u.zToken;
        }
        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
          Table *pTab = pFrom->pTab;
          Select *pSub = pFrom->pSelect;
          char *zTabName = pFrom->zAlias;
          const char *zSchemaName = 0;
          int iDb;
          if( zTabName==0 ){
            zTabName = pTab->zName;
          }
          if( db->mallocFailed ) break;
          if( pSub==0 || (pSub->selFlags & 0x00800)==0 ){
            pSub = 0;
            if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){
              continue;
            }
            iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
            zSchemaName = iDb>=0 ? db->aDb[iDb].zDbSName : "*";
          }
          for(j=0; j<pTab->nCol; j++){
            char *zName = pTab->aCol[j].zName;
            char *zColname;
            char *zToFree;
            Token sColname;

            ((void)0);
            if( zTName && pSub
             && sqlite3MatchSpanName(pSub->pEList->a[j].zSpan, 0, zTName, 0)==0
            ){
              continue;
            }





            if( (p->selFlags & 0x20000)==0
             && (((&pTab->aCol[j])->colFlags & 0x0002)!=0)
            ){
              continue;
            }
            tableSeen = 1;

            if( i>0 && zTName==0 ){
              if( (pFrom->fg.jointype & 0x0004)!=0
                && tableAndColumnIndex(pTabList, i, zName, 0, 0)
              ){


                continue;
              }
              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){


                continue;
              }
            }
            pRight = sqlite3Expr(db, 59, zName);
            zColname = zName;
            zToFree = 0;
            if( longNames || pTabList->nSrc>1 ){
              Expr *pLeft;
              pLeft = sqlite3Expr(db, 59, zTabName);
              pExpr = sqlite3PExpr(pParse, 137, pLeft, pRight);
              if( zSchemaName ){
                pLeft = sqlite3Expr(db, 59, zSchemaName);
                pExpr = sqlite3PExpr(pParse, 137, pLeft, pExpr);
              }
              if( longNames ){
                zColname = sqlite3MPrintf(db, "%s.%s", zTabName, zName);
                zToFree = zColname;
              }
            }else{
              pExpr = pRight;
            }
            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);
            sqlite3TokenInit(&sColname, zColname);
            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);
            if( pNew && (p->selFlags & 0x00800)!=0 ){
              struct ExprList_item *pX = &pNew->a[pNew->nExpr-1];
              if( pSub ){
                pX->zSpan = sqlite3DbStrDup(db, pSub->pEList->a[j].zSpan);
                ;
              }else{
                pX->zSpan = sqlite3MPrintf(db, "%s.%s.%s",
                                           zSchemaName, zTabName, zColname);
                ;
              }
              pX->bSpanIsTab = 1;
            }
            sqlite3DbFree(db, zToFree);
          }
        }
        if( !tableSeen ){
          if( zTName ){
            sqlite3ErrorMsg(pParse, "no such table: %s", zTName);
          }else{
            sqlite3ErrorMsg(pParse, "no tables specified");
          }
        }
      }
    }
    sqlite3ExprListDelete(db, pEList);
    p->pEList = pNew;
  }
  if( p->pEList ){
    if( p->pEList->nExpr>db->aLimit[2] ){
      sqlite3ErrorMsg(pParse, "too many columns in result set");
      return 2;
    }
    if( (elistFlags & (0x000004|0x200000))!=0 ){
      p->selFlags |= 0x40000;
    }
  }
  return 0;
}
# 130757 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ExprWalkNoop(Walker *NotUsed, Expr *NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}





static int sqlite3SelectWalkNoop(Walker *NotUsed, Select *NotUsed2){
  (void)(NotUsed),(void)(NotUsed2);
  return 0;
}
# 130794 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SelectExpand(Parse *pParse, Select *pSelect){
  Walker w;
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.pParse = pParse;
  if( (pParse->hasCompound) ){
    w.xSelectCallback = convertCompoundSelectToSubquery;
    w.xSelectCallback2 = 0;
    sqlite3WalkSelect(&w, pSelect);
  }
  w.xSelectCallback = selectExpander;
  w.xSelectCallback2 = selectPopWith;
  w.eCode = 0;
  sqlite3WalkSelect(&w, pSelect);
}
# 130824 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){
  Parse *pParse;
  int i;
  SrcList *pTabList;
  struct SrcList_item *pFrom;

  ((void)0);
  if( p->selFlags & 0x00080 ) return;
  p->selFlags |= 0x00080;
  pParse = pWalker->pParse;
  pTabList = p->pSrc;
  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){
    Table *pTab = pFrom->pTab;
    ((void)0);
    if( (pTab->tabFlags & 0x0002)!=0 ){

      Select *pSel = pFrom->pSelect;
      if( pSel ){
        while( pSel->pPrior ) pSel = pSel->pPrior;
        sqlite3SelectAddColumnTypeAndCollation(pParse, pTab, pSel,
                                               0x40);
      }
    }
  }
}
# 130859 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){

  Walker w;
  w.xSelectCallback = sqlite3SelectWalkNoop;
  w.xSelectCallback2 = selectAddSubqueryTypeInfo;
  w.xExprCallback = sqlite3ExprWalkNoop;
  w.pParse = pParse;
  sqlite3WalkSelect(&w, pSelect);

}
# 130883 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3SelectPrep(
  Parse *pParse,
  Select *p,
  NameContext *pOuterNC
){
  ((void)0);
  if( pParse->db->mallocFailed ) return;
  if( p->selFlags & 0x00080 ) return;
  sqlite3SelectExpand(pParse, p);
  if( pParse->nErr || pParse->db->mallocFailed ) return;
  sqlite3ResolveSelectNames(pParse, p, pOuterNC);
  if( pParse->nErr || pParse->db->mallocFailed ) return;
  sqlite3SelectAddTypeInfo(pParse, p);
}
# 130906 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pFunc;
  int nReg = pAggInfo->nFunc + pAggInfo->nColumn;
  if( nReg==0 ) return;
# 130925 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3VdbeAddOp3(v, 73, 0, pAggInfo->mnReg, pAggInfo->mxReg);
  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){
    if( pFunc->iDistinct>=0 ){
      Expr *pE = pFunc->pExpr;
      ((void)0);
      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){
        sqlite3ErrorMsg(pParse, "DISTINCT aggregates must have exactly one "
           "argument");
        pFunc->iDistinct = -1;
      }else{
        KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pE->x.pList,0,0);
        sqlite3VdbeAddOp4(v, 112, pFunc->iDistinct, 0, 0,
                          (char*)pKeyInfo, (-9));
      }
    }
  }
}





static void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  struct AggInfo_func *pF;
  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
    ExprList *pList = pF->pExpr->x.pList;
    ((void)0);
    sqlite3VdbeAddOp2(v, 157, pF->iMem, pList ? pList->nExpr : 0);
    sqlite3VdbeAppendP4(v, pF->pFunc, (-8));
  }
}
# 130969 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void updateAccumulator(Parse *pParse, int regAcc, AggInfo *pAggInfo){
  Vdbe *v = pParse->pVdbe;
  int i;
  int regHit = 0;
  int addrHitTest = 0;
  struct AggInfo_func *pF;
  struct AggInfo_col *pC;

  pAggInfo->directMode = 1;
  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){
    int nArg;
    int addrNext = 0;
    int regAgg;
    ExprList *pList = pF->pExpr->x.pList;
    ((void)0);
    ((void)0);
    if( (((pF->pExpr)->flags&(0x1000000))!=0) ){
      Expr *pFilter = pF->pExpr->y.pWin->pFilter;
      if( pAggInfo->nAccumulator
       && (pF->pFunc->funcFlags & 0x0020)
      ){
        if( regHit==0 ) regHit = ++pParse->nMem;







        sqlite3VdbeAddOp2(v, 78, regAcc, regHit);
      }
      addrNext = sqlite3VdbeMakeLabel(pParse);
      sqlite3ExprIfFalse(pParse, pFilter, addrNext, 0x10);
    }
    if( pList ){
      nArg = pList->nExpr;
      regAgg = sqlite3GetTempRange(pParse, nArg);
      sqlite3ExprCodeExprList(pParse, pList, regAgg, 0, 0x01);
    }else{
      nArg = 0;
      regAgg = 0;
    }
    if( pF->iDistinct>=0 ){
      if( addrNext==0 ){
        addrNext = sqlite3VdbeMakeLabel(pParse);
      }
      ;
      ;
      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);
    }
    if( pF->pFunc->funcFlags & 0x0020 ){
      CollSeq *pColl = 0;
      struct ExprList_item *pItem;
      int j;
      ((void)0);
      for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){
        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);
      }
      if( !pColl ){
        pColl = pParse->db->pDfltColl;
      }
      if( regHit==0 && pAggInfo->nAccumulator ) regHit = ++pParse->nMem;
      sqlite3VdbeAddOp4(v, 82, regHit, 0, 0, (char *)pColl, (-2));
    }
    sqlite3VdbeAddOp3(v, 154, 0, regAgg, pF->iMem);
    sqlite3VdbeAppendP4(v, pF->pFunc, (-8));
    sqlite3VdbeChangeP5(v, (u8)nArg);
    sqlite3ReleaseTempRange(pParse, regAgg, nArg);
    if( addrNext ){
      sqlite3VdbeResolveLabel(v, addrNext);
    }
  }
  if( regHit==0 && pAggInfo->nAccumulator ){
    regHit = regAcc;
  }
  if( regHit ){
    addrHitTest = sqlite3VdbeAddOp1(v, 18, regHit); ;
  }
  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){
    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);
  }

  pAggInfo->directMode = 0;
  if( addrHitTest ){
    sqlite3VdbeJumpHere(v, addrHitTest);
  }
}






static void explainSimpleCount(
  Parse *pParse,
  Table *pTab,
  Index *pIdx
){
  if( pParse->explain==2 ){
    int bCover = (pIdx!=0 && ((((pTab)->tabFlags & 0x0020)==0) || !((pIdx)->idxType==2)));
    sqlite3VdbeExplain(pParse, 0, "SCAN TABLE %s%s%s",
        pTab->zName,
        bCover ? " USING COVERING INDEX " : "",
        bCover ? pIdx->zName : ""
    );
  }
}
# 131091 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int havingToWhereExprCb(Walker *pWalker, Expr *pExpr){
  if( pExpr->op!=44 ){
    Select *pS = pWalker->u.pSelect;
    if( sqlite3ExprIsConstantOrGroupBy(pWalker->pParse, pExpr, pS->pGroupBy) ){
      sqlite3 *db = pWalker->pParse->db;
      Expr *pNew = sqlite3Expr(db, 150, "1");
      if( pNew ){
        Expr *pWhere = pS->pWhere;
        {Expr t=*pNew; *pNew=*pExpr; *pExpr=t;};
        pNew = sqlite3ExprAnd(pWalker->pParse, pWhere, pNew);
        pS->pWhere = pNew;
        pWalker->eCode = 1;
      }
    }
    return 1;
  }
  return 0;
}
# 131125 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void havingToWhere(Parse *pParse, Select *p){
  Walker sWalker;
  memset(&sWalker, 0, sizeof(sWalker));
  sWalker.pParse = pParse;
  sWalker.xExprCallback = havingToWhereExprCb;
  sWalker.u.pSelect = p;
  sqlite3WalkExpr(&sWalker, p->pHaving);






}






static struct SrcList_item *isSelfJoinView(
  SrcList *pTabList,
  struct SrcList_item *pThis
){
  struct SrcList_item *pItem;
  for(pItem = pTabList->a; pItem<pThis; pItem++){
    Select *pS1;
    if( pItem->pSelect==0 ) continue;
    if( pItem->fg.viaCoroutine ) continue;
    if( pItem->zName==0 ) continue;
    ((void)0);
    ((void)0);
    if( pItem->pTab->pSchema!=pThis->pTab->pSchema ) continue;
    if( sqlite3_stricmp(pItem->zName, pThis->zName)!=0 ) continue;
    pS1 = pItem->pSelect;
    if( pItem->pTab->pSchema==0 && pThis->pSelect->selId!=pS1->selId ){


      continue;
    }
    if( sqlite3ExprCompare(0, pThis->pSelect->pWhere, pS1->pWhere, -1)
     || sqlite3ExprCompare(0, pThis->pSelect->pHaving, pS1->pHaving, -1)
    ){


      continue;
    }
    return pItem;
  }
  return 0;
}
# 131277 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Select(
  Parse *pParse,
  Select *p,
  SelectDest *pDest
){
  int i, j;
  WhereInfo *pWInfo;
  Vdbe *v;
  int isAgg;
  ExprList *pEList = 0;
  SrcList *pTabList;
  Expr *pWhere;
  ExprList *pGroupBy;
  Expr *pHaving;
  int rc = 1;
  DistinctCtx sDistinct;
  SortCtx sSort;
  AggInfo sAggInfo;
  int iEnd;
  sqlite3 *db;
  ExprList *pMinMaxOrderBy = 0;
  u8 minMaxFlag;

  db = pParse->db;
  v = sqlite3GetVdbe(pParse);
  if( p==0 || db->mallocFailed || pParse->nErr ){
    return 1;
  }
  if( sqlite3AuthCheck(pParse, 21, 0, 0, 0) ) return 1;
  memset(&sAggInfo, 0, sizeof(sAggInfo));







  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( ((pDest->eDest)<=8) ){
    ((void)0)


                                                                 ;


    sqlite3ExprListDelete(db, p->pOrderBy);
    p->pOrderBy = 0;
    p->selFlags &= ~0x00001;
  }
  sqlite3SelectPrep(pParse, p, 0);
  if( pParse->nErr || db->mallocFailed ){
    goto select_end;
  }
  ((void)0);







  if( pDest->eDest==9 ){
    generateColumnNames(pParse, p);
  }


  if( sqlite3WindowRewrite(pParse, p) ){
    goto select_end;
  }







  pTabList = p->pSrc;
  isAgg = (p->selFlags & 0x00008)!=0;
  memset(&sSort, 0, sizeof(sSort));
  sSort.pOrderBy = p->pOrderBy;





  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){
    struct SrcList_item *pItem = &pTabList->a[i];
    Select *pSub = pItem->pSelect;
    Table *pTab = pItem->pTab;




    if( (pItem->fg.jointype & 0x0008)!=0
     && sqlite3ExprImpliesNonNullRow(p->pWhere, pItem->iCursor)
     && (((db)->dbOptFlags&(0x2000))==0)
    ){
     
                                                                ;
      pItem->fg.jointype &= ~(0x0008|0x0020);
      unsetJoinExpr(p->pWhere, pItem->iCursor);
    }


    if( pSub==0 ) continue;



    if( pTab->nCol!=pSub->pEList->nExpr ){
      sqlite3ErrorMsg(pParse, "expected %d columns for '%s' but got %d",
                      pTab->nCol, pTab->zName, pSub->pEList->nExpr);
      goto select_end;
    }
# 131401 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (pSub->selFlags & 0x00008)!=0 ) continue;
    ((void)0);
# 131422 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pSub->pOrderBy!=0
     && i==0
     && (p->selFlags & 0x40000)!=0
     && (pTabList->nSrc==1
         || (pTabList->a[1].fg.jointype&(0x0008|0x0002))!=0)
    ){
      continue;
    }

    if( flattenSubquery(pParse, p, i, isAgg) ){
      if( pParse->nErr ) goto select_end;

      i = -1;
    }
    pTabList = p->pSrc;
    if( db->mallocFailed ) goto select_end;
    if( !((pDest->eDest)<=8) ){
      sSort.pOrderBy = p->pOrderBy;
    }
  }






  if( p->pPrior ){
    rc = multiSelect(pParse, p, pDest);






    if( p->pNext==0 ) sqlite3VdbeExplainPop(pParse);
    return rc;
  }







  if( pTabList->nSrc>1
   && (((db)->dbOptFlags&(0x8000))==0)
   && propagateConstants(pParse, p)
  ){






  }else{
    ;
  }
# 131494 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(i=0; i<pTabList->nSrc; i++){
    struct SrcList_item *pItem = &pTabList->a[i];
    SelectDest dest;
    Select *pSub;

    const char *zSavedAuthContext;
# 131518 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pItem->colUsed==0 && pItem->zName!=0 ){
      sqlite3AuthCheck(pParse, 20, pItem->zName, "", pItem->zDatabase);
    }




    pSub = pItem->pSelect;
    if( pSub==0 ) continue;
# 131540 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ;
# 131549 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pParse->nHeight += sqlite3SelectExprHeight(p);




    if( (((db)->dbOptFlags&(0x1000))==0)
     && pushDownWhereTerms(pParse, pSub, p->pWhere, pItem->iCursor,
                           (pItem->fg.jointype & 0x0020)!=0)
    ){







    }else{
      ;
    }

    zSavedAuthContext = pParse->zAuthContext;
    pParse->zAuthContext = pItem->zName;
# 131581 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( i==0
     && (pTabList->nSrc==1
            || (pTabList->a[1].fg.jointype&(0x0008|0x0002))!=0)
    ){



      int addrTop = sqlite3VdbeCurrentAddr(v)+1;

      pItem->regReturn = ++pParse->nMem;
      sqlite3VdbeAddOp3(v, 13, pItem->regReturn, 0, addrTop);
      ;
      pItem->addrFillSub = addrTop;
      sqlite3SelectDestInit(&dest, 13, pItem->regReturn);
      sqlite3VdbeExplain (pParse, 1, "CO-ROUTINE %u", pSub->selId);
      sqlite3Select(pParse, pSub, &dest);
      pItem->pTab->nRowLogEst = pSub->nSelectRow;
      pItem->fg.viaCoroutine = 1;
      pItem->regResult = dest.iSdst;
      sqlite3VdbeEndCoroutine(v, pItem->regReturn);
      sqlite3VdbeJumpHere(v, addrTop-1);
      sqlite3ClearTempRegCache(pParse);
    }else{





      int topAddr;
      int onceAddr = 0;
      int retAddr;
      struct SrcList_item *pPrior;

      ;
      pItem->regReturn = ++pParse->nMem;
      topAddr = sqlite3VdbeAddOp2(v, 70, 0, pItem->regReturn);
      pItem->addrFillSub = topAddr+1;
      if( pItem->fg.isCorrelated==0 ){



        onceAddr = sqlite3VdbeAddOp0(v, 17); ;
        ;
      }else{
        ;
      }
      pPrior = isSelfJoinView(pTabList, pItem);
      if( pPrior ){
        sqlite3VdbeAddOp2(v, 109, pItem->iCursor, pPrior->iCursor);
        ((void)0);
        pSub->nSelectRow = pPrior->pSelect->nSelectRow;
      }else{
        sqlite3SelectDestInit(&dest, 12, pItem->iCursor);
        sqlite3VdbeExplain (pParse, 1, "MATERIALIZE %u", pSub->selId);
        sqlite3Select(pParse, pSub, &dest);
      }
      pItem->pTab->nRowLogEst = pSub->nSelectRow;
      if( onceAddr ) sqlite3VdbeJumpHere(v, onceAddr);
      retAddr = sqlite3VdbeAddOp1(v, 66, pItem->regReturn);
      ;
      sqlite3VdbeChangeP1(v, topAddr, retAddr);
      sqlite3ClearTempRegCache(pParse);
    }
    if( db->mallocFailed ) goto select_end;
    pParse->nHeight -= sqlite3SelectExprHeight(p);
    pParse->zAuthContext = zSavedAuthContext;

  }



  pEList = p->pEList;
  pWhere = p->pWhere;
  pGroupBy = p->pGroupBy;
  pHaving = p->pHaving;
  sDistinct.isTnct = (p->selFlags & 0x00001)!=0;
# 131680 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (p->selFlags & (0x00001|0x00008))==0x00001
   && sqlite3ExprListCompare(sSort.pOrderBy, pEList, -1)==0
  ){
    p->selFlags &= ~0x00001;
    pGroupBy = p->pGroupBy = sqlite3ExprListDup(db, pEList, 0);



    ((void)0);







  }
# 131706 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( sSort.pOrderBy ){
    KeyInfo *pKeyInfo;
    pKeyInfo = sqlite3KeyInfoFromExprList(
        pParse, sSort.pOrderBy, 0, pEList->nExpr);
    sSort.iECursor = pParse->nTab++;
    sSort.addrSortIndex =
      sqlite3VdbeAddOp4(v, 112,
          sSort.iECursor, sSort.pOrderBy->nExpr+1+pEList->nExpr, 0,
          (char*)pKeyInfo, (-9)
      );
  }else{
    sSort.addrSortIndex = -1;
  }



  if( pDest->eDest==12 ){
    sqlite3VdbeAddOp2(v, 112, pDest->iSDParm, pEList->nExpr);
  }



  iEnd = sqlite3VdbeMakeLabel(pParse);
  if( (p->selFlags & 0x04000)==0 ){
    p->nSelectRow = 320;
  }
  computeLimitRegisters(pParse, p, iEnd);
  if( p->iLimit==0 && sSort.addrSortIndex>=0 ){
    sqlite3VdbeChangeOpcode(v, sSort.addrSortIndex, 114);
    sSort.sortFlags |= 0x01;
  }



  if( p->selFlags & 0x00001 ){
    sDistinct.tabTnct = pParse->nTab++;
    sDistinct.addrTnct = sqlite3VdbeAddOp4(v, 112,
                       sDistinct.tabTnct, 0, 0,
                       (char*)sqlite3KeyInfoFromExprList(pParse, p->pEList,0,0),
                       (-9));
    sqlite3VdbeChangeP5(v, 8);
    sDistinct.eTnctType = 3;
  }else{
    sDistinct.eTnctType = 0;
  }

  if( !isAgg && pGroupBy==0 ){

    u16 wctrlFlags = (sDistinct.isTnct ? 0x0100 : 0)
                   | (p->selFlags & 0x04000);

    Window *pWin = p->pWin;
    if( pWin ){
      sqlite3WindowCodeInit(pParse, pWin);
    }

    ((void)0);



    ;
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, sSort.pOrderBy,
                               p->pEList, wctrlFlags, p->nSelectRow);
    if( pWInfo==0 ) goto select_end;
    if( sqlite3WhereOutputRowCount(pWInfo) < p->nSelectRow ){
      p->nSelectRow = sqlite3WhereOutputRowCount(pWInfo);
    }
    if( sDistinct.isTnct && sqlite3WhereIsDistinct(pWInfo) ){
      sDistinct.eTnctType = sqlite3WhereIsDistinct(pWInfo);
    }
    if( sSort.pOrderBy ){
      sSort.nOBSat = sqlite3WhereIsOrdered(pWInfo);
      sSort.labelOBLopt = sqlite3WhereOrderByLimitOptLabel(pWInfo);
      if( sSort.nOBSat==sSort.pOrderBy->nExpr ){
        sSort.pOrderBy = 0;
      }
    }





    if( sSort.addrSortIndex>=0 && sSort.pOrderBy==0 ){
      sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
    }

    ((void)0);

    if( pWin ){
      int addrGosub = sqlite3VdbeMakeLabel(pParse);
      int iCont = sqlite3VdbeMakeLabel(pParse);
      int iBreak = sqlite3VdbeMakeLabel(pParse);
      int regGosub = ++pParse->nMem;

      sqlite3WindowCodeStep(pParse, p, pWInfo, regGosub, addrGosub);

      sqlite3VdbeAddOp2(v, 11, 0, iBreak);
      sqlite3VdbeResolveLabel(v, addrGosub);
      ;
      sSort.labelOBLopt = 0;
      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest, iCont, iBreak);
      sqlite3VdbeResolveLabel(v, iCont);
      sqlite3VdbeAddOp1(v, 66, regGosub);
      ;
      sqlite3VdbeResolveLabel(v, iBreak);
    }else

    {

      selectInnerLoop(pParse, p, -1, &sSort, &sDistinct, pDest,
          sqlite3WhereContinueLabel(pWInfo),
          sqlite3WhereBreakLabel(pWInfo));



      sqlite3WhereEnd(pWInfo);
    }
  }else{


    NameContext sNC;
    int iAMem;
    int iBMem;
    int iUseFlag;


    int iAbortFlag;
    int groupBySort;
    int addrEnd;
    int sortPTab = 0;
    int sortOut = 0;
    int orderByGrp = 0;




    if( pGroupBy ){
      int k;
      struct ExprList_item *pItem;

      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){
        pItem->u.x.iAlias = 0;
      }
      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){
        pItem->u.x.iAlias = 0;
      }
      ((void)0);
      if( p->nSelectRow>66 ) p->nSelectRow = 66;
# 131863 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( sSort.pOrderBy && pGroupBy->nExpr==sSort.pOrderBy->nExpr ){
        int ii;





        for(ii=0; ii<pGroupBy->nExpr; ii++){
          u8 sortFlags = sSort.pOrderBy->a[ii].sortFlags & 0x01;
          pGroupBy->a[ii].sortFlags = sortFlags;
        }
        if( sqlite3ExprListCompare(pGroupBy, sSort.pOrderBy, -1)==0 ){
          orderByGrp = 1;
        }
      }
    }else{
      ((void)0);
      p->nSelectRow = 0;
    }


    addrEnd = sqlite3VdbeMakeLabel(pParse);





    memset(&sNC, 0, sizeof(sNC));
    sNC.pParse = pParse;
    sNC.pSrcList = pTabList;
    sNC.uNC.pAggInfo = &sAggInfo;
   
    sAggInfo.mnReg = pParse->nMem+1;
    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr : 0;
    sAggInfo.pGroupBy = pGroupBy;
    sqlite3ExprAnalyzeAggList(&sNC, pEList);
    sqlite3ExprAnalyzeAggList(&sNC, sSort.pOrderBy);
    if( pHaving ){
      if( pGroupBy ){
        ((void)0);
        ((void)0);
        ((void)0);
        havingToWhere(pParse, p);
        pWhere = p->pWhere;
      }
      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);
    }
    sAggInfo.nAccumulator = sAggInfo.nColumn;
    if( p->pGroupBy==0 && p->pHaving==0 && sAggInfo.nFunc==1 ){
      minMaxFlag = minMaxQuery(db, sAggInfo.aFunc[0].pExpr, &pMinMaxOrderBy);
    }else{
      minMaxFlag = 0x0000;
    }
    for(i=0; i<sAggInfo.nFunc; i++){
      Expr *pExpr = sAggInfo.aFunc[i].pExpr;
      ((void)0);
      sNC.ncFlags |= 0x0008;
      sqlite3ExprAnalyzeAggList(&sNC, pExpr->x.pList);

      ((void)0);
      if( (((pExpr)->flags&(0x1000000))!=0) ){
        sqlite3ExprAnalyzeAggregates(&sNC, pExpr->y.pWin->pFilter);
      }

      sNC.ncFlags &= ~0x0008;
    }
    sAggInfo.mxReg = pParse->nMem;
    if( db->mallocFailed ) goto select_end;
# 131953 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pGroupBy ){
      KeyInfo *pKeyInfo;
      int addr1;
      int addrOutputRow;
      int regOutputRow;
      int addrSetAbort;
      int addrTopOfLoop;
      int addrSortingIdx;
      int addrReset;
      int regReset;






      sAggInfo.sortingIdx = pParse->nTab++;
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse,pGroupBy,0,sAggInfo.nColumn);
      addrSortingIdx = sqlite3VdbeAddOp4(v, 114,
          sAggInfo.sortingIdx, sAggInfo.nSortingColumn,
          0, (char*)pKeyInfo, (-9));



      iUseFlag = ++pParse->nMem;
      iAbortFlag = ++pParse->nMem;
      regOutputRow = ++pParse->nMem;
      addrOutputRow = sqlite3VdbeMakeLabel(pParse);
      regReset = ++pParse->nMem;
      addrReset = sqlite3VdbeMakeLabel(pParse);
      iAMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      iBMem = pParse->nMem + 1;
      pParse->nMem += pGroupBy->nExpr;
      sqlite3VdbeAddOp2(v, 70, 0, iAbortFlag);
      ;
      sqlite3VdbeAddOp3(v, 73, 0, iAMem, iAMem+pGroupBy->nExpr-1);






      sqlite3VdbeAddOp2(v, 12, regReset, addrReset);
      ;
      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pGroupBy, 0,
          0x0040 | (orderByGrp ? 0x0200 : 0), 0
      );
      if( pWInfo==0 ) goto select_end;
      if( sqlite3WhereIsOrdered(pWInfo)==pGroupBy->nExpr ){




        groupBySort = 0;
      }else{





        int regBase;
        int regRecord;
        int nCol;
        int nGroupBy;

        explainTempTable(pParse,
            (sDistinct.isTnct && (p->selFlags&0x00001)==0) ?
                    "DISTINCT" : "GROUP BY");

        groupBySort = 1;
        nGroupBy = pGroupBy->nExpr;
        nCol = nGroupBy;
        j = nGroupBy;
        for(i=0; i<sAggInfo.nColumn; i++){
          if( sAggInfo.aCol[i].iSorterColumn>=j ){
            nCol++;
            j++;
          }
        }
        regBase = sqlite3GetTempRange(pParse, nCol);
        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0, 0);
        j = nGroupBy;
        for(i=0; i<sAggInfo.nColumn; i++){
          struct AggInfo_col *pCol = &sAggInfo.aCol[i];
          if( pCol->iSorterColumn>=j ){
            int r1 = j + regBase;
            sqlite3ExprCodeGetColumnOfTable(v,
                               pCol->pTab, pCol->iTable, pCol->iColumn, r1);
            j++;
          }
        }
        regRecord = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 92, regBase, nCol, regRecord);
        sqlite3VdbeAddOp2(v, 131, sAggInfo.sortingIdx, regRecord);
        sqlite3ReleaseTempReg(pParse, regRecord);
        sqlite3ReleaseTempRange(pParse, regBase, nCol);
        sqlite3WhereEnd(pWInfo);
        sAggInfo.sortingIdxPTab = sortPTab = pParse->nTab++;
        sortOut = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 116, sortPTab, sortOut, nCol);
        sqlite3VdbeAddOp2(v, 34, sAggInfo.sortingIdx, addrEnd);
        ; ;
        sAggInfo.useSortingIdx = 1;
      }
# 132066 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( orderByGrp && (((db)->dbOptFlags&(0x0004))==0)
       && (groupBySort || sqlite3WhereIsSorted(pWInfo))
      ){
        sSort.pOrderBy = 0;
        sqlite3VdbeChangeToNoop(v, sSort.addrSortIndex);
      }






      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);
      if( groupBySort ){
        sqlite3VdbeAddOp3(v, 126, sAggInfo.sortingIdx,
                          sortOut, sortPTab);
      }
      for(j=0; j<pGroupBy->nExpr; j++){
        if( groupBySort ){
          sqlite3VdbeAddOp3(v, 90, sortPTab, j, iBMem+j);
        }else{
          sAggInfo.directMode = 1;
          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);
        }
      }
      sqlite3VdbeAddOp4(v, 87, iAMem, iBMem, pGroupBy->nExpr,
                          (char*)sqlite3KeyInfoRef(pKeyInfo), (-9));
      addr1 = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp3(v, 16, addr1+1, 0, addr1+1); ;
# 132105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);
      sqlite3VdbeAddOp2(v, 12, regOutputRow, addrOutputRow);
      ;
      sqlite3VdbeAddOp2(v, 47, iAbortFlag, addrEnd); ;
      ;
      sqlite3VdbeAddOp2(v, 12, regReset, addrReset);
      ;




      sqlite3VdbeJumpHere(v, addr1);
      updateAccumulator(pParse, iUseFlag, &sAggInfo);
      sqlite3VdbeAddOp2(v, 70, 1, iUseFlag);
      ;



      if( groupBySort ){
        sqlite3VdbeAddOp2(v, 3, sAggInfo.sortingIdx, addrTopOfLoop);
        ;
      }else{
        sqlite3WhereEnd(pWInfo);
        sqlite3VdbeChangeToNoop(v, addrSortingIdx);
      }



      sqlite3VdbeAddOp2(v, 12, regOutputRow, addrOutputRow);
      ;



      sqlite3VdbeGoto(v, addrEnd);
# 132147 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      addrSetAbort = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 70, 1, iAbortFlag);
      ;
      sqlite3VdbeAddOp1(v, 66, regOutputRow);
      sqlite3VdbeResolveLabel(v, addrOutputRow);
      addrOutputRow = sqlite3VdbeCurrentAddr(v);
      sqlite3VdbeAddOp2(v, 47, iUseFlag, addrOutputRow+2);
      ;
      ;
      sqlite3VdbeAddOp1(v, 66, regOutputRow);
      finalizeAggFunctions(pParse, &sAggInfo);
      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, 0x10);
      selectInnerLoop(pParse, p, -1, &sSort,
                      &sDistinct, pDest,
                      addrOutputRow+1, addrSetAbort);
      sqlite3VdbeAddOp1(v, 66, regOutputRow);
      ;



      sqlite3VdbeResolveLabel(v, addrReset);
      resetAccumulator(pParse, &sAggInfo);
      sqlite3VdbeAddOp2(v, 70, 0, iUseFlag);
      ;
      sqlite3VdbeAddOp1(v, 66, regReset);

    }
    else {

      Table *pTab;
      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){
# 132191 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);
        const int iCsr = pParse->nTab++;
        Index *pIdx;
        KeyInfo *pKeyInfo = 0;
        Index *pBest = 0;
        int iRoot = pTab->tnum;

        sqlite3CodeVerifySchema(pParse, iDb);
        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
# 132210 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        if( !(((pTab)->tabFlags & 0x0020)==0) ) pBest = sqlite3PrimaryKeyIndex(pTab);
        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
          if( pIdx->bUnordered==0
           && pIdx->szIdxRow<pTab->szTabRow
           && pIdx->pPartIdxWhere==0
           && (!pBest || pIdx->szIdxRow<pBest->szIdxRow)
          ){
            pBest = pIdx;
          }
        }
        if( pBest ){
          iRoot = pBest->tnum;
          pKeyInfo = sqlite3KeyInfoOfIndex(pParse, pBest);
        }


        sqlite3VdbeAddOp4Int(v, 97, iCsr, iRoot, iDb, 1);
        if( pKeyInfo ){
          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, (-9));
        }
        sqlite3VdbeAddOp2(v, 93, iCsr, sAggInfo.aFunc[0].iMem);
        sqlite3VdbeAddOp1(v, 117, iCsr);
        explainSimpleCount(pParse, pTab, pBest);
      }else

      {
        int regAcc = 0;
# 132247 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        if( sAggInfo.nAccumulator ){
          for(i=0; i<sAggInfo.nFunc; i++){
            if( (((sAggInfo.aFunc[i].pExpr)->flags&(0x1000000))!=0) ) continue;
            if( sAggInfo.aFunc[i].pFunc->funcFlags&0x0020 ) break;
          }
          if( i==sAggInfo.nFunc ){
            regAcc = ++pParse->nMem;
            sqlite3VdbeAddOp2(v, 70, 0, regAcc);
          }
        }





        ((void)0);
        resetAccumulator(pParse, &sAggInfo);






        ((void)0);
        ((void)0);

        ;
        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, pMinMaxOrderBy,
                                   0, minMaxFlag, 0);
        if( pWInfo==0 ){
          goto select_end;
        }
        updateAccumulator(pParse, regAcc, &sAggInfo);
        if( regAcc ) sqlite3VdbeAddOp2(v, 70, 1, regAcc);
        if( sqlite3WhereIsOrdered(pWInfo)>0 ){
          sqlite3VdbeGoto(v, sqlite3WhereBreakLabel(pWInfo));
         
                                                             ;
        }
        sqlite3WhereEnd(pWInfo);
        finalizeAggFunctions(pParse, &sAggInfo);
      }

      sSort.pOrderBy = 0;
      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, 0x10);
      selectInnerLoop(pParse, p, -1, 0, 0,
                      pDest, addrEnd, addrEnd);
    }
    sqlite3VdbeResolveLabel(v, addrEnd);

  }

  if( sDistinct.eTnctType==3 ){
    explainTempTable(pParse, "DISTINCT");
  }




  if( sSort.pOrderBy ){
    explainTempTable(pParse,
                     sSort.nOBSat>0 ? "RIGHT PART OF ORDER BY":"ORDER BY");
    ((void)0);
    generateSortTail(pParse, p, &sSort, pEList->nExpr, pDest);
  }



  sqlite3VdbeResolveLabel(v, iEnd);



  rc = (pParse->nErr>0);




select_end:
  sqlite3ExprListDelete(db, pMinMaxOrderBy);
  sqlite3DbFree(db, sAggInfo.aCol);
  sqlite3DbFree(db, sAggInfo.aFunc);






  sqlite3VdbeExplainPop(pParse);
  return rc;
}
# 132366 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct TabResult {
  char **azResult;
  char *zErrMsg;
  u32 nAlloc;
  u32 nRow;
  u32 nColumn;
  u32 nData;
  int rc;
} TabResult;






static int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){
  TabResult *p = (TabResult*)pArg;
  int need;
  int i;
  char *z;




  if( p->nRow==0 && argv!=0 ){
    need = nCol*2;
  }else{
    need = nCol;
  }
  if( p->nData + need > p->nAlloc ){
    char **azNew;
    p->nAlloc = p->nAlloc*2 + need;
    azNew = sqlite3_realloc64( p->azResult, sizeof(char*)*p->nAlloc );
    if( azNew==0 ) goto malloc_failed;
    p->azResult = azNew;
  }




  if( p->nRow==0 ){
    p->nColumn = nCol;
    for(i=0; i<nCol; i++){
      z = sqlite3_mprintf("%s", colv[i]);
      if( z==0 ) goto malloc_failed;
      p->azResult[p->nData++] = z;
    }
  }else if( (int)p->nColumn!=nCol ){
    sqlite3_free(p->zErrMsg);
    p->zErrMsg = sqlite3_mprintf(
       "sqlite3_get_table() called with two or more incompatible queries"
    );
    p->rc = 1;
    return 1;
  }



  if( argv!=0 ){
    for(i=0; i<nCol; i++){
      if( argv[i]==0 ){
        z = 0;
      }else{
        int n = sqlite3Strlen30(argv[i])+1;
        z = sqlite3_malloc64( n );
        if( z==0 ) goto malloc_failed;
        memcpy(z, argv[i], n);
      }
      p->azResult[p->nData++] = z;
    }
    p->nRow++;
  }
  return 0;

malloc_failed:
  p->rc = 7;
  return 1;
}
# 132455 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_get_table(
  sqlite3 *db,
  const char *zSql,
  char ***pazResult,
  int *pnRow,
  int *pnColumn,
  char **pzErrMsg
){
  int rc;
  TabResult res;




  *pazResult = 0;
  if( pnColumn ) *pnColumn = 0;
  if( pnRow ) *pnRow = 0;
  if( pzErrMsg ) *pzErrMsg = 0;
  res.zErrMsg = 0;
  res.nRow = 0;
  res.nColumn = 0;
  res.nData = 1;
  res.nAlloc = 20;
  res.rc = 0;
  res.azResult = sqlite3_malloc64(sizeof(char*)*res.nAlloc );
  if( res.azResult==0 ){
     db->errCode = 7;
     return 7;
  }
  res.azResult[0] = 0;
  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);
  ((void)0);
  res.azResult[0] = ((void*)(long int)(res.nData));
  if( (rc&0xff)==4 ){
    sqlite3_free_table(&res.azResult[1]);
    if( res.zErrMsg ){
      if( pzErrMsg ){
        sqlite3_free(*pzErrMsg);
        *pzErrMsg = sqlite3_mprintf("%s",res.zErrMsg);
      }
      sqlite3_free(res.zErrMsg);
    }
    db->errCode = res.rc;
    return res.rc;
  }
  sqlite3_free(res.zErrMsg);
  if( rc!=0 ){
    sqlite3_free_table(&res.azResult[1]);
    return rc;
  }
  if( res.nAlloc>res.nData ){
    char **azNew;
    azNew = sqlite3_realloc64( res.azResult, sizeof(char*)*res.nData );
    if( azNew==0 ){
      sqlite3_free_table(&res.azResult[1]);
      db->errCode = 7;
      return 7;
    }
    res.azResult = azNew;
  }
  *pazResult = &res.azResult[1];
  if( pnColumn ) *pnColumn = res.nColumn;
  if( pnRow ) *pnRow = res.nRow;
  return rc;
}




 void sqlite3_free_table(
  char **azResult
){
  if( azResult ){
    int i, n;
    azResult--;
    ((void)0);
    n = ((int)(long int)(azResult[0]));
    for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }
    sqlite3_free(azResult);
  }
}
# 132559 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep){
  while( pTriggerStep ){
    TriggerStep * pTmp = pTriggerStep;
    pTriggerStep = pTriggerStep->pNext;

    sqlite3ExprDelete(db, pTmp->pWhere);
    sqlite3ExprListDelete(db, pTmp->pExprList);
    sqlite3SelectDelete(db, pTmp->pSelect);
    sqlite3IdListDelete(db, pTmp->pIdList);
    sqlite3UpsertDelete(db, pTmp->pUpsert);
    sqlite3DbFree(db, pTmp->zSpan);

    sqlite3DbFree(db, pTmp);
  }
}
# 132589 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab){
  Schema * const pTmpSchema = pParse->db->aDb[1].pSchema;
  Trigger *pList = 0;

  if( pParse->disableTriggers ){
    return 0;
  }

  if( pTmpSchema!=pTab->pSchema ){
    HashElem *p;
    ((void)0);
    for(p=((&pTmpSchema->trigHash)->first); p; p=((p)->next)){
      Trigger *pTrig = (Trigger *)((p)->data);
      if( pTrig->pTabSchema==pTab->pSchema
       && 0==sqlite3StrICmp(pTrig->table, pTab->zName)
      ){
        pTrig->pNext = (pList ? pList : pTab->pTrigger);
        pList = pTrig;
      }
    }
  }

  return (pList ? pList : pTab->pTrigger);
}
# 132622 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3BeginTrigger(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  int tr_tm,
  int op,
  IdList *pColumns,
  SrcList *pTableName,
  Expr *pWhen,
  int isTemp,
  int noErr
){
  Trigger *pTrigger = 0;
  Table *pTab;
  char *zName = 0;
  sqlite3 *db = pParse->db;
  int iDb;
  Token *pName;
  DbFixer sFix;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( isTemp ){

    if( pName2->n>0 ){
      sqlite3ErrorMsg(pParse, "temporary trigger may not have qualified name");
      goto trigger_cleanup;
    }
    iDb = 1;
    pName = pName1;
  }else{

    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);
    if( iDb<0 ){
      goto trigger_cleanup;
    }
  }
  if( !pTableName || db->mallocFailed ){
    goto trigger_cleanup;
  }
# 132673 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( db->init.busy && iDb!=1 ){
    sqlite3DbFree(db, pTableName->a[0].zDatabase);
    pTableName->a[0].zDatabase = 0;
  }






  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if( db->init.busy==0 && pName2->n==0 && pTab
        && pTab->pSchema==db->aDb[1].pSchema ){
    iDb = 1;
  }


  if( db->mallocFailed ) goto trigger_cleanup;
  ((void)0);
  sqlite3FixInit(&sFix, pParse, iDb, "trigger", pName);
  if( sqlite3FixSrcList(&sFix, pTableName) ){
    goto trigger_cleanup;
  }
  pTab = sqlite3SrcListLookup(pParse, pTableName);
  if( !pTab ){

    if( db->init.iDb==1 ){
# 132708 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      db->init.orphanTrigger = 1;
    }
    goto trigger_cleanup;
  }
  if( ((pTab)->nModuleArg) ){
    sqlite3ErrorMsg(pParse, "cannot create triggers on virtual tables");
    goto trigger_cleanup;
  }



  zName = sqlite3NameFromToken(db, pName);
  if( zName==0 ){
    ((void)0);
    goto trigger_cleanup;
  }
  if( sqlite3CheckObjectName(pParse, zName, "trigger", pTab->zName) ){
    goto trigger_cleanup;
  }
  ((void)0);
  if( !(pParse->eParseMode>=2) ){
    if( sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash),zName) ){
      if( !noErr ){
        sqlite3ErrorMsg(pParse, "trigger %T already exists", pName);
      }else{
        ((void)0);
        sqlite3CodeVerifySchema(pParse, iDb);
      }
      goto trigger_cleanup;
    }
  }


  if( sqlite3_strnicmp(pTab->zName, "sqlite_", 7)==0 ){
    sqlite3ErrorMsg(pParse, "cannot create trigger on system table");
    goto trigger_cleanup;
  }




  if( pTab->pSelect && tr_tm!=65 ){
    sqlite3ErrorMsg(pParse, "cannot create %s trigger on view: %S",
        (tr_tm == 33)?"BEFORE":"AFTER", pTableName, 0);
    goto trigger_cleanup;
  }
  if( !pTab->pSelect && tr_tm==65 ){
    sqlite3ErrorMsg(pParse, "cannot create INSTEAD OF"
        " trigger on table: %S", pTableName, 0);
    goto trigger_cleanup;
  }


  if( !(pParse->eParseMode>=2) ){
    int iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    int code = 7;
    const char *zDb = db->aDb[iTabDb].zDbSName;
    const char *zDbTrig = isTemp ? db->aDb[1].zDbSName : zDb;
    if( iTabDb==1 || isTemp ) code = 5;
    if( sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig) ){
      goto trigger_cleanup;
    }
    if( sqlite3AuthCheck(pParse, 18, ((!0)&&(iTabDb==1)?"sqlite_temp_master":"sqlite_master"),0,zDb)){
      goto trigger_cleanup;
    }
  }







  if (tr_tm == 65){
    tr_tm = 33;
  }


  pTrigger = (Trigger*)sqlite3DbMallocZero(db, sizeof(Trigger));
  if( pTrigger==0 ) goto trigger_cleanup;
  pTrigger->zName = zName;
  zName = 0;
  pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);
  pTrigger->pSchema = db->aDb[iDb].pSchema;
  pTrigger->pTabSchema = pTab->pSchema;
  pTrigger->op = (u8)op;
  pTrigger->tr_tm = tr_tm==33 ? 1 : 2;
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameTokenRemap(pParse, pTrigger->table, pTableName->a[0].zName);
    pTrigger->pWhen = pWhen;
    pWhen = 0;
  }else{
    pTrigger->pWhen = sqlite3ExprDup(db, pWhen, 0x0001);
  }
  pTrigger->pColumns = pColumns;
  pColumns = 0;
  ((void)0);
  pParse->pNewTrigger = pTrigger;

trigger_cleanup:
  sqlite3DbFree(db, zName);
  sqlite3SrcListDelete(db, pTableName);
  sqlite3IdListDelete(db, pColumns);
  sqlite3ExprDelete(db, pWhen);
  if( !pParse->pNewTrigger ){
    sqlite3DeleteTrigger(db, pTrigger);
  }else{
    ((void)0);
  }
}





static void sqlite3FinishTrigger(
  Parse *pParse,
  TriggerStep *pStepList,
  Token *pAll
){
  Trigger *pTrig = pParse->pNewTrigger;
  char *zName;
  sqlite3 *db = pParse->db;
  DbFixer sFix;
  int iDb;
  Token nameToken;

  pParse->pNewTrigger = 0;
  if( (pParse->nErr) || !pTrig ) goto triggerfinish_cleanup;
  zName = pTrig->zName;
  iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);
  pTrig->step_list = pStepList;
  while( pStepList ){
    pStepList->pTrig = pTrig;
    pStepList = pStepList->pNext;
  }
  sqlite3TokenInit(&nameToken, pTrig->zName);
  sqlite3FixInit(&sFix, pParse, iDb, "trigger", &nameToken);
  if( sqlite3FixTriggerStep(&sFix, pTrig->step_list)
   || sqlite3FixExpr(&sFix, pTrig->pWhen)
  ){
    goto triggerfinish_cleanup;
  }


  if( (pParse->eParseMode>=2) ){
    ((void)0);
    pParse->pNewTrigger = pTrig;
    pTrig = 0;
  }else





  if( !db->init.busy ){
    Vdbe *v;
    char *z;


    v = sqlite3GetVdbe(pParse);
    if( v==0 ) goto triggerfinish_cleanup;
    sqlite3BeginWriteOperation(pParse, 0, iDb);
    z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n);
    ;
    sqlite3NestedParse(pParse,
       "INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')",
       db->aDb[iDb].zDbSName, "sqlite_master", zName,
       pTrig->table, z);
    sqlite3DbFree(db, z);
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddParseSchemaOp(v, iDb,
        sqlite3MPrintf(db, "type='trigger' AND name='%q'", zName));
  }

  if( db->init.busy ){
    Trigger *pLink = pTrig;
    Hash *pHash = &db->aDb[iDb].pSchema->trigHash;
    ((void)0);
    ((void)0);
    pTrig = sqlite3HashInsert(pHash, zName, pTrig);
    if( pTrig ){
      sqlite3OomFault(db);
    }else if( pLink->pSchema==pLink->pTabSchema ){
      Table *pTab;
      pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table);
      ((void)0);
      pLink->pNext = pTab->pTrigger;
      pTab->pTrigger = pLink;
    }
  }

triggerfinish_cleanup:
  sqlite3DeleteTrigger(db, pTrig);
  ((void)0);
  sqlite3DeleteTriggerStep(db, pStepList);
}





static char *triggerSpanDup(sqlite3 *db, const char *zStart, const char *zEnd){
  char *z = sqlite3DbSpanDup(db, zStart, zEnd);
  int i;
  if( z ) for(i=0; z[i]; i++) if( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x01) ) z[i] = ' ';
  return z;
}
# 132924 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static TriggerStep *sqlite3TriggerSelectStep(
  sqlite3 *db,
  Select *pSelect,
  const char *zStart,
  const char *zEnd
){
  TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep));
  if( pTriggerStep==0 ) {
    sqlite3SelectDelete(db, pSelect);
    return 0;
  }
  pTriggerStep->op = 134;
  pTriggerStep->pSelect = pSelect;
  pTriggerStep->orconf = 11;
  pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);
  return pTriggerStep;
}







static TriggerStep *triggerStepAllocate(
  Parse *pParse,
  u8 op,
  Token *pName,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n + 1);
  if( pTriggerStep ){
    char *z = (char*)&pTriggerStep[1];
    memcpy(z, pName->z, pName->n);
    sqlite3Dequote(z);
    pTriggerStep->zTarget = z;
    pTriggerStep->op = op;
    pTriggerStep->zSpan = triggerSpanDup(db, zStart, zEnd);
    if( (pParse->eParseMode>=2) ){
      sqlite3RenameTokenMap(pParse, pTriggerStep->zTarget, pName);
    }
  }
  return pTriggerStep;
}
# 132980 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static TriggerStep *sqlite3TriggerInsertStep(
  Parse *pParse,
  Token *pTableName,
  IdList *pColumn,
  Select *pSelect,
  u8 orconf,
  Upsert *pUpsert,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  ((void)0);

  pTriggerStep = triggerStepAllocate(pParse, 123, pTableName,zStart,zEnd);
  if( pTriggerStep ){
    if( (pParse->eParseMode>=2) ){
      pTriggerStep->pSelect = pSelect;
      pSelect = 0;
    }else{
      pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, 0x0001);
    }
    pTriggerStep->pIdList = pColumn;
    pTriggerStep->pUpsert = pUpsert;
    pTriggerStep->orconf = orconf;
    if( pUpsert ){
      sqlite3HasExplicitNulls(pParse, pUpsert->pUpsertTarget);
    }
  }else{
    ;
    sqlite3IdListDelete(db, pColumn);
    ;
    sqlite3UpsertDelete(db, pUpsert);
  }
  sqlite3SelectDelete(db, pSelect);

  return pTriggerStep;
}






static TriggerStep *sqlite3TriggerUpdateStep(
  Parse *pParse,
  Token *pTableName,
  ExprList *pEList,
  Expr *pWhere,
  u8 orconf,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  pTriggerStep = triggerStepAllocate(pParse, 125, pTableName,zStart,zEnd);
  if( pTriggerStep ){
    if( (pParse->eParseMode>=2) ){
      pTriggerStep->pExprList = pEList;
      pTriggerStep->pWhere = pWhere;
      pEList = 0;
      pWhere = 0;
    }else{
      pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, 0x0001);
      pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
    }
    pTriggerStep->orconf = orconf;
  }
  sqlite3ExprListDelete(db, pEList);
  sqlite3ExprDelete(db, pWhere);
  return pTriggerStep;
}






static TriggerStep *sqlite3TriggerDeleteStep(
  Parse *pParse,
  Token *pTableName,
  Expr *pWhere,
  const char *zStart,
  const char *zEnd
){
  sqlite3 *db = pParse->db;
  TriggerStep *pTriggerStep;

  pTriggerStep = triggerStepAllocate(pParse, 124, pTableName,zStart,zEnd);
  if( pTriggerStep ){
    if( (pParse->eParseMode>=2) ){
      pTriggerStep->pWhere = pWhere;
      pWhere = 0;
    }else{
      pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, 0x0001);
    }
    pTriggerStep->orconf = 11;
  }
  sqlite3ExprDelete(db, pWhere);
  return pTriggerStep;
}




static void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger){
  if( pTrigger==0 ) return;
  sqlite3DeleteTriggerStep(db, pTrigger->step_list);
  sqlite3DbFree(db, pTrigger->zName);
  sqlite3DbFree(db, pTrigger->table);
  sqlite3ExprDelete(db, pTrigger->pWhen);
  sqlite3IdListDelete(db, pTrigger->pColumns);
  sqlite3DbFree(db, pTrigger);
}
# 133105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){
  Trigger *pTrigger = 0;
  int i;
  const char *zDb;
  const char *zName;
  sqlite3 *db = pParse->db;

  if( db->mallocFailed ) goto drop_trigger_cleanup;
  if( 0!=sqlite3ReadSchema(pParse) ){
    goto drop_trigger_cleanup;
  }

  ((void)0);
  zDb = pName->a[0].zDatabase;
  zName = pName->a[0].zName;
  ((void)0);
  for(i=0; i<db->nDb; i++){
    int j = (i<2) ? i^1 : i;
    if( zDb && sqlite3StrICmp(db->aDb[j].zDbSName, zDb) ) continue;
    ((void)0);
    pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName);
    if( pTrigger ) break;
  }
  if( !pTrigger ){
    if( !noErr ){
      sqlite3ErrorMsg(pParse, "no such trigger: %S", pName, 0);
    }else{
      sqlite3CodeVerifyNamedSchema(pParse, zDb);
    }
    pParse->checkSchema = 1;
    goto drop_trigger_cleanup;
  }
  sqlite3DropTriggerPtr(pParse, pTrigger);

drop_trigger_cleanup:
  sqlite3SrcListDelete(db, pName);
}





static Table *tableOfTrigger(Trigger *pTrigger){
  return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table);
}





static void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){
  Table *pTable;
  Vdbe *v;
  sqlite3 *db = pParse->db;
  int iDb;

  iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);
  ((void)0);
  pTable = tableOfTrigger(pTrigger);
  ((void)0);

  if( pTable ){
    int code = 16;
    const char *zDb = db->aDb[iDb].zDbSName;
    const char *zTab = ((!0)&&(iDb==1)?"sqlite_temp_master":"sqlite_master");
    if( iDb==1 ) code = 14;
    if( sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||
      sqlite3AuthCheck(pParse, 9, zTab, 0, zDb) ){
      return;
    }
  }




  if( (v = sqlite3GetVdbe(pParse))!=0 ){
    sqlite3NestedParse(pParse,
       "DELETE FROM %Q.%s WHERE name=%Q AND type='trigger'",
       db->aDb[iDb].zDbSName, "sqlite_master", pTrigger->zName
    );
    sqlite3ChangeCookie(pParse, iDb);
    sqlite3VdbeAddOp4(v, 145, iDb, 0, 0, pTrigger->zName, 0);
  }
}




static void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){
  Trigger *pTrigger;
  Hash *pHash;

  ((void)0);
  pHash = &(db->aDb[iDb].pSchema->trigHash);
  pTrigger = sqlite3HashInsert(pHash, zName, 0);
  if( (pTrigger) ){
    if( pTrigger->pSchema==pTrigger->pTabSchema ){
      Table *pTab = tableOfTrigger(pTrigger);
      if( pTab ){
        Trigger **pp;
        for(pp=&pTab->pTrigger; *pp!=pTrigger; pp=&((*pp)->pNext));
        *pp = (*pp)->pNext;
      }
    }
    sqlite3DeleteTrigger(db, pTrigger);
    db->mDbFlags |= 0x0001;
  }
}
# 133223 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int checkColumnOverlap(IdList *pIdList, ExprList *pEList){
  int e;
  if( pIdList==0 || (pEList==0) ) return 1;
  for(e=0; e<pEList->nExpr; e++){
    if( sqlite3IdListIndex(pIdList, pEList->a[e].zName)>=0 ) return 1;
  }
  return 0;
}







static Trigger *sqlite3TriggersExist(
  Parse *pParse,
  Table *pTab,
  int op,
  ExprList *pChanges,
  int *pMask
){
  int mask = 0;
  Trigger *pList = 0;
  Trigger *p;

  if( (pParse->db->flags & 0x00040000)!=0 ){
    pList = sqlite3TriggerList(pParse, pTab);
  }
  ((void)0);
  for(p=pList; p; p=p->pNext){
    if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){
      mask |= p->tr_tm;
    }
  }
  if( pMask ){
    *pMask = mask;
  }
  return (mask ? pList : 0);
}
# 133274 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static SrcList *targetSrcList(
  Parse *pParse,
  TriggerStep *pStep
){
  sqlite3 *db = pParse->db;
  int iDb;
  SrcList *pSrc;

  pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
  if( pSrc ){
    ((void)0);
    pSrc->a[pSrc->nSrc-1].zName = sqlite3DbStrDup(db, pStep->zTarget);
    iDb = sqlite3SchemaToIndex(db, pStep->pTrig->pSchema);
    if( iDb==0 || iDb>=2 ){
      const char *zDb;
      ((void)0);
      zDb = db->aDb[iDb].zDbSName;
      pSrc->a[pSrc->nSrc-1].zDatabase = sqlite3DbStrDup(db, zDb);
    }
  }
  return pSrc;
}





static int codeTriggerProgram(
  Parse *pParse,
  TriggerStep *pStepList,
  int orconf
){
  TriggerStep *pStep;
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;

  ((void)0);
  ((void)0);
  ((void)0);
  for(pStep=pStepList; pStep; pStep=pStep->pNext){
# 133327 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pParse->eOrconf = (orconf==11)?pStep->orconf:(u8)orconf;
    ((void)0);


    if( pStep->zSpan ){
      sqlite3VdbeAddOp4(v, 168, 0x7fffffff, 1, 0,
                        sqlite3MPrintf(db, "-- %s", pStep->zSpan),
                        (-7));
    }


    switch( pStep->op ){
      case 125: {
        sqlite3Update(pParse,
          targetSrcList(pParse, pStep),
          sqlite3ExprListDup(db, pStep->pExprList, 0),
          sqlite3ExprDup(db, pStep->pWhere, 0),
          pParse->eOrconf, 0, 0, 0
        );
        break;
      }
      case 123: {
        sqlite3Insert(pParse,
          targetSrcList(pParse, pStep),
          sqlite3SelectDup(db, pStep->pSelect, 0),
          sqlite3IdListDup(db, pStep->pIdList),
          pParse->eOrconf,
          sqlite3UpsertDup(db, pStep->pUpsert)
        );
        break;
      }
      case 124: {
        sqlite3DeleteFrom(pParse,
          targetSrcList(pParse, pStep),
          sqlite3ExprDup(db, pStep->pWhere, 0), 0, 0
        );
        break;
      }
      default: ((void)0); {
        SelectDest sDest;
        Select *pSelect = sqlite3SelectDup(db, pStep->pSelect, 0);
        sqlite3SelectDestInit(&sDest, 4, 0);
        sqlite3Select(pParse, pSelect, &sDest);
        sqlite3SelectDelete(db, pSelect);
        break;
      }
    }
    if( pStep->op!=134 ){
      sqlite3VdbeAddOp0(v, 124);
    }
  }

  return 0;
}
# 133405 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void transferParseError(Parse *pTo, Parse *pFrom){
  ((void)0);
  ((void)0);
  if( pTo->nErr==0 ){
    pTo->zErrMsg = pFrom->zErrMsg;
    pTo->nErr = pFrom->nErr;
    pTo->rc = pFrom->rc;
  }else{
    sqlite3DbFree(pFrom->db, pFrom->zErrMsg);
  }
}





static TriggerPrg *codeRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  Table *pTab,
  int orconf
){
  Parse *pTop = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  sqlite3 *db = pParse->db;
  TriggerPrg *pPrg;
  Expr *pWhen = 0;
  Vdbe *v;
  NameContext sNC;
  SubProgram *pProgram = 0;
  Parse *pSubParse;
  int iEndTrigger = 0;

  ((void)0);
  ((void)0);




  pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg));
  if( !pPrg ) return 0;
  pPrg->pNext = pTop->pTriggerPrg;
  pTop->pTriggerPrg = pPrg;
  pPrg->pProgram = pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram));
  if( !pProgram ) return 0;
  sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);
  pPrg->pTrigger = pTrigger;
  pPrg->orconf = orconf;
  pPrg->aColmask[0] = 0xffffffff;
  pPrg->aColmask[1] = 0xffffffff;



  pSubParse = sqlite3DbMallocZero(db,sizeof(Parse));
  if( !pSubParse ) return 0;
  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pSubParse;
  pSubParse->db = db;
  pSubParse->pTriggerTab = pTab;
  pSubParse->pToplevel = pTop;
  pSubParse->zAuthContext = pTrigger->zName;
  pSubParse->eTriggerOp = pTrigger->op;
  pSubParse->nQueryLoop = pParse->nQueryLoop;
  pSubParse->disableVtab = pParse->disableVtab;

  v = sqlite3GetVdbe(pSubParse);
  if( v ){
   






      ;

    if( pTrigger->zName ){
      sqlite3VdbeChangeP4(v, -1,
        sqlite3MPrintf(db, "-- TRIGGER %s", pTrigger->zName), (-7)
      );
    }





    if( pTrigger->pWhen ){
      pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);
      if( 0==sqlite3ResolveExprNames(&sNC, pWhen)
       && db->mallocFailed==0
      ){
        iEndTrigger = sqlite3VdbeMakeLabel(pSubParse);
        sqlite3ExprIfFalse(pSubParse, pWhen, iEndTrigger, 0x10);
      }
      sqlite3ExprDelete(db, pWhen);
    }


    codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);


    if( iEndTrigger ){
      sqlite3VdbeResolveLabel(v, iEndTrigger);
    }
    sqlite3VdbeAddOp0(v, 69);
    ;

    transferParseError(pParse, pSubParse);
    if( db->mallocFailed==0 && pParse->nErr==0 ){
      pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop->nMaxArg);
    }
    pProgram->nMem = pSubParse->nMem;
    pProgram->nCsr = pSubParse->nTab;
    pProgram->token = (void *)pTrigger;
    pPrg->aColmask[0] = pSubParse->oldmask;
    pPrg->aColmask[1] = pSubParse->newmask;
    sqlite3VdbeDelete(v);
  }

  ((void)0);
  ((void)0);
  sqlite3ParserReset(pSubParse);
  sqlite3DbFree(db,pSubParse);

  return pPrg;
}







static TriggerPrg *getRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  Table *pTab,
  int orconf
){
  Parse *pRoot = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  TriggerPrg *pPrg;

  ((void)0);





  for(pPrg=pRoot->pTriggerPrg;
      pPrg && (pPrg->pTrigger!=pTrigger || pPrg->orconf!=orconf);
      pPrg=pPrg->pNext
  );


  if( !pPrg ){
    pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);
  }

  return pPrg;
}







static void sqlite3CodeRowTriggerDirect(
  Parse *pParse,
  Trigger *p,
  Table *pTab,
  int reg,
  int orconf,
  int ignoreJump
){
  Vdbe *v = sqlite3GetVdbe(pParse);
  TriggerPrg *pPrg;
  pPrg = getRowTrigger(pParse, p, pTab, orconf);
  ((void)0);



  if( pPrg ){
    int bRecursive = (p->zName && 0==(pParse->db->flags&0x00002000));

    sqlite3VdbeAddOp4(v, 45, reg, ignoreJump, ++pParse->nMem,
                      (const char *)pPrg->pProgram, (-4));
   
                                                                            ;






    sqlite3VdbeChangeP5(v, (u8)bRecursive);
  }
}
# 133643 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3CodeRowTrigger(
  Parse *pParse,
  Trigger *pTrigger,
  int op,
  ExprList *pChanges,
  int tr_tm,
  Table *pTab,
  int reg,
  int orconf,
  int ignoreJump
){
  Trigger *p;

  ((void)0);
  ((void)0);
  ((void)0);

  for(p=pTrigger; p; p=p->pNext){




    ((void)0);
    ((void)0);
    ((void)0)
                                                    ;


    if( p->op==op
     && p->tr_tm==tr_tm
     && checkColumnOverlap(p->pColumns, pChanges)
    ){
      sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);
    }
  }
}
# 133705 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u32 sqlite3TriggerColmask(
  Parse *pParse,
  Trigger *pTrigger,
  ExprList *pChanges,
  int isNew,
  int tr_tm,
  Table *pTab,
  int orconf
){
  const int op = pChanges ? 125 : 124;
  u32 mask = 0;
  Trigger *p;

  ((void)0);
  for(p=pTrigger; p; p=p->pNext){
    if( p->op==op && (tr_tm&p->tr_tm)
     && checkColumnOverlap(p->pColumns,pChanges)
    ){
      TriggerPrg *pPrg;
      pPrg = getRowTrigger(pParse, p, pTab, orconf);
      if( pPrg ){
        mask |= pPrg->aColmask[isNew];
      }
    }
  }

  return mask;
}
# 133756 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void updateVirtualTable(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  ExprList *pChanges,
  Expr *pRowidExpr,
  int *aXRef,
  Expr *pWhere,
  int onError
);
# 133798 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){
  ((void)0);
  if( !pTab->pSelect ){
    sqlite3_value *pValue = 0;
    u8 enc = ((sqlite3VdbeDb(v))->enc);
    Column *pCol = &pTab->aCol[i];
    ;
    ((void)0);
    sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc,
                         pCol->affinity, &pValue);
    if( pValue ){
      sqlite3VdbeAppendP4(v, pValue, (-11));
    }
  }

  if( pTab->aCol[i].affinity==0x45 ){
    sqlite3VdbeAddOp1(v, 84, iReg);
  }

}
# 133830 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int indexColumnIsBeingUpdated(
  Index *pIdx,
  int iCol,
  int *aXRef,
  int chngRowid
){
  i16 iIdxCol = pIdx->aiColumn[iCol];
  ((void)0);
  if( iIdxCol>=0 ){
    return aXRef[iIdxCol]>=0;
  }
  ((void)0);
  ((void)0);
  ((void)0);
  return sqlite3ExprReferencesUpdatedColumn(pIdx->aColExpr->a[iCol].pExpr,
                                            aXRef,chngRowid);
}
# 133860 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int indexWhereClauseMightChange(
  Index *pIdx,
  int *aXRef,
  int chngRowid
){
  if( pIdx->pPartIdxWhere==0 ) return 0;
  return sqlite3ExprReferencesUpdatedColumn(pIdx->pPartIdxWhere,
                                            aXRef, chngRowid);
}
# 133877 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Update(
  Parse *pParse,
  SrcList *pTabList,
  ExprList *pChanges,
  Expr *pWhere,
  int onError,
  ExprList *pOrderBy,
  Expr *pLimit,
  Upsert *pUpsert
){
  int i, j;
  Table *pTab;
  int addrTop = 0;
  WhereInfo *pWInfo;
  Vdbe *v;
  Index *pIdx;
  Index *pPk;
  int nIdx;
  int nAllIdx;
  int iBaseCur;
  int iDataCur;
  int iIdxCur;
  sqlite3 *db;
  int *aRegIdx = 0;
  int *aXRef = 0;


  u8 *aToOpen;
  u8 chngPk;
  u8 chngRowid;
  u8 chngKey;
  Expr *pRowidExpr = 0;
  AuthContext sContext;
  NameContext sNC;
  int iDb;
  int eOnePass;
  int hasFK;
  int labelBreak;
  int labelContinue;
  int flags;


  int isView;
  Trigger *pTrigger;
  int tmask;

  int newmask;
  int iEph = 0;
  int nKey = 0;
  int aiCurOnePass[2];
  int addrOpen = 0;
  int iPk = 0;
  i16 nPk = 0;
  int bReplace = 0;


  int regRowCount = 0;
  int regOldRowid = 0;
  int regNewRowid = 0;
  int regNew = 0;
  int regOld = 0;
  int regRowSet = 0;
  int regKey = 0;

  memset(&sContext, 0, sizeof(sContext));
  db = pParse->db;
  if( pParse->nErr || db->mallocFailed ){
    goto update_cleanup;
  }
  ((void)0);



  pTab = sqlite3SrcListLookup(pParse, pTabList);
  if( pTab==0 ) goto update_cleanup;
  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);





  pTrigger = sqlite3TriggersExist(pParse, pTab, 125, pChanges, &tmask);
  isView = pTab->pSelect!=0;
  ((void)0);
# 133981 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( sqlite3ViewGetColumnNames(pParse, pTab) ){
    goto update_cleanup;
  }
  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){
    goto update_cleanup;
  }






  iBaseCur = iDataCur = pParse->nTab++;
  iIdxCur = iDataCur+1;
  pPk = (((pTab)->tabFlags & 0x0020)==0) ? 0 : sqlite3PrimaryKeyIndex(pTab);
  ;
  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){
    if( pPk==pIdx ){
      iDataCur = pParse->nTab;
    }
    pParse->nTab++;
  }
  if( pUpsert ){

    iDataCur = pUpsert->iDataCur;
    iIdxCur = pUpsert->iIdxCur;
    pParse->nTab = iBaseCur;
  }
  pTabList->a[0].iCursor = iDataCur;




  aXRef = sqlite3DbMallocRawNN(db, sizeof(int) * (pTab->nCol+nIdx+1) + nIdx+2 );
  if( aXRef==0 ) goto update_cleanup;
  aRegIdx = aXRef+pTab->nCol;
  aToOpen = (u8*)(aRegIdx+nIdx+1);
  memset(aToOpen, 1, nIdx+1);
  aToOpen[nIdx+1] = 0;
  for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;


  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  sNC.uNC.pUpsert = pUpsert;
  sNC.ncFlags = 0x0200;







  chngRowid = chngPk = 0;
  for(i=0; i<pChanges->nExpr; i++){
    if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){
      goto update_cleanup;
    }
    for(j=0; j<pTab->nCol; j++){
      if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zName)==0 ){
        if( j==pTab->iPKey ){
          chngRowid = 1;
          pRowidExpr = pChanges->a[i].pExpr;
        }else if( pPk && (pTab->aCol[j].colFlags & 0x0001)!=0 ){
          chngPk = 1;
        }
        aXRef[j] = i;
        break;
      }
    }
    if( j>=pTab->nCol ){
      if( pPk==0 && sqlite3IsRowid(pChanges->a[i].zName) ){
        j = -1;
        chngRowid = 1;
        pRowidExpr = pChanges->a[i].pExpr;
      }else{
        sqlite3ErrorMsg(pParse, "no such column: %s", pChanges->a[i].zName);
        pParse->checkSchema = 1;
        goto update_cleanup;
      }
    }

    {
      int rc;
      rc = sqlite3AuthCheck(pParse, 23, pTab->zName,
                            j<0 ? "ROWID" : pTab->aCol[j].zName,
                            db->aDb[iDb].zDbSName);
      if( rc==1 ){
        goto update_cleanup;
      }else if( rc==2 ){
        aXRef[j] = -1;
      }
    }

  }
  ((void)0);
  ((void)0);
  ((void)0);
  chngKey = chngRowid + chngPk;






  pTabList->a[0].colUsed = ((pTab)->nModuleArg) ? ((Bitmask)-1) : 0;

  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngKey);





  if( onError==5 ) bReplace = 1;
  for(nAllIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nAllIdx++){
    int reg;
    if( chngKey || hasFK>1 || pIdx==pPk
     || indexWhereClauseMightChange(pIdx,aXRef,chngRowid)
    ){
      reg = ++pParse->nMem;
      pParse->nMem += pIdx->nColumn;
    }else{
      reg = 0;
      for(i=0; i<pIdx->nKeyCol; i++){
        if( indexColumnIsBeingUpdated(pIdx, i, aXRef, chngRowid) ){
          reg = ++pParse->nMem;
          pParse->nMem += pIdx->nColumn;
          if( onError==11 && pIdx->onError==5 ){
            bReplace = 1;
          }
          break;
        }
      }
    }
    if( reg==0 ) aToOpen[nAllIdx+1] = 0;
    aRegIdx[nAllIdx] = reg;
  }
  aRegIdx[nAllIdx] = ++pParse->nMem;
  if( bReplace ){


    memset(aToOpen, 1, nIdx+1);
  }


  v = sqlite3GetVdbe(pParse);
  if( v==0 ) goto update_cleanup;
  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);
  sqlite3BeginWriteOperation(pParse, pTrigger || hasFK, iDb);


  if( !((pTab)->nModuleArg) ){





    ((void)0);
    regRowSet = aRegIdx[nAllIdx];
    regOldRowid = regNewRowid = ++pParse->nMem;
    if( chngPk || pTrigger || hasFK ){
      regOld = pParse->nMem + 1;
      pParse->nMem += pTab->nCol;
    }
    if( chngKey || pTrigger || hasFK ){
      regNewRowid = ++pParse->nMem;
    }
    regNew = pParse->nMem + 1;
    pParse->nMem += pTab->nCol;
  }


  if( isView ){
    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);
  }





  if( isView ){
    sqlite3MaterializeView(pParse, pTab,
        pWhere, pOrderBy, pLimit, iDataCur
    );
    pOrderBy = 0;
    pLimit = 0;
  }





  if( sqlite3ResolveExprNames(&sNC, pWhere) ){
    goto update_cleanup;
  }



  if( ((pTab)->nModuleArg) ){
    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,
                       pWhere, onError);
    goto update_cleanup;
  }



  labelContinue = labelBreak = sqlite3VdbeMakeLabel(pParse);



  if( (db->flags&0x00000080)!=0
   && !pParse->pTriggerTab
   && !pParse->nested
   && pUpsert==0
  ){
    regRowCount = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 70, 0, regRowCount);
  }

  if( (((pTab)->tabFlags & 0x0020)==0) ){
    sqlite3VdbeAddOp3(v, 73, 0, regRowSet, regOldRowid);
  }else{
    ((void)0);
    nPk = pPk->nKeyCol;
    iPk = pParse->nMem+1;
    pParse->nMem += nPk;
    regKey = ++pParse->nMem;
    if( pUpsert==0 ){
      iEph = pParse->nTab++;
        sqlite3VdbeAddOp3(v, 73, 0, iPk, iPk+nPk-1);
      addrOpen = sqlite3VdbeAddOp2(v, 112, iEph, nPk);
      sqlite3VdbeSetP4KeyInfo(pParse, pPk);
    }
  }

  if( pUpsert ){





    pWInfo = 0;
    eOnePass = 1;
    sqlite3ExprIfFalse(pParse, pWhere, labelBreak, 0x10);
  }else{







    flags = 0x0004|0x1000;
    if( !pParse->nested && !pTrigger && !hasFK && !chngKey && !bReplace ){
      flags |= 0x0008;
    }
    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, 0, 0, flags, iIdxCur);
    if( pWInfo==0 ) goto update_cleanup;
# 134251 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    eOnePass = sqlite3WhereOkOnePass(pWInfo, aiCurOnePass);
    if( eOnePass!=1 ){
      sqlite3MultiWrite(pParse);
      if( eOnePass==2 ){
        int iCur = aiCurOnePass[1];
        if( iCur>=0 && iCur!=iDataCur && aToOpen[iCur-iBaseCur] ){
          eOnePass = 0;
        }
        ((void)0);
      }
    }
  }

  if( (((pTab)->tabFlags & 0x0020)==0) ){



    sqlite3VdbeAddOp2(v, 128, iDataCur, regOldRowid);
    if( eOnePass==0 ){

      aRegIdx[nAllIdx] = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 147, regRowSet, regOldRowid);
    }
  }else{





    for(i=0; i<nPk; i++){
      ((void)0);
      sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur,pPk->aiColumn[i],iPk+i);
    }
    if( eOnePass ){
      if( addrOpen ) sqlite3VdbeChangeToNoop(v, addrOpen);
      nKey = nPk;
      regKey = iPk;
    }else{
      sqlite3VdbeAddOp4(v, 92, iPk, nPk, regKey,
                        sqlite3IndexAffinityStr(db, pPk), nPk);
      sqlite3VdbeAddOp4Int(v, 132, iEph, regKey, iPk, nPk);
    }
  }

  if( pUpsert==0 ){
    if( eOnePass!=2 ){
      sqlite3WhereEnd(pWInfo);
    }

    if( !isView ){
      int addrOnce = 0;


      if( eOnePass!=0 ){
        if( aiCurOnePass[0]>=0 ) aToOpen[aiCurOnePass[0]-iBaseCur] = 0;
        if( aiCurOnePass[1]>=0 ) aToOpen[aiCurOnePass[1]-iBaseCur] = 0;
      }

      if( eOnePass==2 && (nIdx-(aiCurOnePass[1]>=0))>0 ){
        addrOnce = sqlite3VdbeAddOp0(v, 17); ;
      }
      sqlite3OpenTableAndIndices(pParse, pTab, 98, 0, iBaseCur,
                                 aToOpen, 0, 0);
      if( addrOnce ) sqlite3VdbeJumpHere(v, addrOnce);
    }


    if( eOnePass!=0 ){
      if( !isView && aiCurOnePass[0]!=iDataCur && aiCurOnePass[1]!=iDataCur ){
        ((void)0);
        sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelBreak, regKey,nKey);
        ;
      }
      if( eOnePass!=1 ){
        labelContinue = sqlite3VdbeMakeLabel(pParse);
      }
      sqlite3VdbeAddOp2(v, 50, pPk ? regKey : regOldRowid, labelBreak);
      ;
      ;
    }else if( pPk ){
      labelContinue = sqlite3VdbeMakeLabel(pParse);
      sqlite3VdbeAddOp2(v, 36, iEph, labelBreak); ;
      addrTop = sqlite3VdbeAddOp2(v, 127, iEph, regKey);
      sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue, regKey, 0);
      ;
    }else{
      labelContinue = sqlite3VdbeAddOp3(v, 41, regRowSet,labelBreak,
                               regOldRowid);
      ;
      sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);
      ;
    }
  }





  ((void)0);
  if( chngRowid ){
    sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);
    sqlite3VdbeAddOp1(v, 15, regNewRowid); ;
  }



  if( chngPk || hasFK || pTrigger ){
    u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);
    oldmask |= sqlite3TriggerColmask(pParse,
        pTrigger, pChanges, 0, 1|2, pTab, onError
    );
    for(i=0; i<pTab->nCol; i++){
      if( oldmask==0xffffffff
       || (i<32 && (oldmask & (((unsigned int)1)<<(i)))!=0)
       || (pTab->aCol[i].colFlags & 0x0001)!=0
      ){
        ;
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regOld+i);
      }else{
        sqlite3VdbeAddOp2(v, 73, 0, regOld+i);
      }
    }
    if( chngRowid==0 && pPk==0 ){
      sqlite3VdbeAddOp2(v, 78, regOldRowid, regNewRowid);
    }
  }
# 134391 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  newmask = sqlite3TriggerColmask(
      pParse, pTrigger, pChanges, 1, 1, pTab, onError
  );
  for(i=0; i<pTab->nCol; i++){
    if( i==pTab->iPKey ){
      sqlite3VdbeAddOp2(v, 73, 0, regNew+i);
    }else{
      j = aXRef[i];
      if( j>=0 ){
        sqlite3ExprCode(pParse, pChanges->a[j].pExpr, regNew+i);
      }else if( 0==(tmask&1) || i>31 || (newmask & (((unsigned int)1)<<(i))) ){





        ;
        ;
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew+i);
      }else{
        sqlite3VdbeAddOp2(v, 73, 0, regNew+i);
      }
    }
  }




  if( tmask&1 ){
    sqlite3TableAffinity(v, pTab, regNew);
    sqlite3CodeRowTrigger(pParse, pTrigger, 125, pChanges,
        1, pTab, regOldRowid, onError, labelContinue);







    if( pPk ){
      sqlite3VdbeAddOp4Int(v, 28, iDataCur, labelContinue,regKey,nKey);
      ;
    }else{
      sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue, regOldRowid);
      ;
    }
# 134447 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    for(i=0; i<pTab->nCol; i++){
      if( aXRef[i]<0 && i!=pTab->iPKey ){
        sqlite3ExprCodeGetColumnOfTable(v, pTab, iDataCur, i, regNew+i);
      }
    }
  }

  if( !isView ){

    ((void)0);
    sqlite3GenerateConstraintChecks(pParse, pTab, aRegIdx, iDataCur, iIdxCur,
        regNewRowid, regOldRowid, chngKey, onError, labelContinue, &bReplace,
        aXRef, 0);




    if( bReplace || chngKey ){
      if( pPk ){
        sqlite3VdbeAddOp4Int(v, 28,iDataCur,labelContinue,regKey,nKey);
      }else{
        sqlite3VdbeAddOp3(v, 31, iDataCur, labelContinue,regOldRowid);
      }
      ;
    }


    if( hasFK ){
      sqlite3FkCheck(pParse, pTab, regOldRowid, 0, aXRef, chngKey);
    }


    sqlite3GenerateRowIndexDelete(pParse, pTab, iDataCur, iIdxCur, aRegIdx, -1);
# 134490 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ((void)0);
# 134504 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( hasFK>1 || chngKey ){
      sqlite3VdbeAddOp2(v, 123, iDataCur, 0);
    }


    if( hasFK ){
      sqlite3FkCheck(pParse, pTab, 0, regNewRowid, aXRef, chngKey);
    }


    sqlite3CompleteInsertion(
        pParse, pTab, iDataCur, iIdxCur, regNewRowid, aRegIdx,
        0x04 | (eOnePass==2 ? 0x02 : 0),
        0, 0
    );




    if( hasFK ){
      sqlite3FkActions(pParse, pTab, pChanges, regOldRowid, aXRef, chngKey);
    }
  }



  if( regRowCount ){
    sqlite3VdbeAddOp2(v, 83, regRowCount, 1);
  }

  sqlite3CodeRowTrigger(pParse, pTrigger, 125, pChanges,
      2, pTab, regOldRowid, onError, labelContinue);




  if( eOnePass==1 ){

  }else if( eOnePass==2 ){
    sqlite3VdbeResolveLabel(v, labelContinue);
    sqlite3WhereEnd(pWInfo);
  }else if( pPk ){
    sqlite3VdbeResolveLabel(v, labelContinue);
    sqlite3VdbeAddOp2(v, 5, iEph, addrTop); ;
  }else{
    sqlite3VdbeGoto(v, labelContinue);
  }
  sqlite3VdbeResolveLabel(v, labelBreak);





  if( pParse->nested==0 && pParse->pTriggerTab==0 && pUpsert==0 ){
    sqlite3AutoincrementEnd(pParse);
  }





  if( regRowCount ){
    sqlite3VdbeAddOp2(v, 81, regRowCount, 1);
    sqlite3VdbeSetNumCols(v, 1);
    sqlite3VdbeSetColName(v, 0, 0, "rows updated", ((sqlite3_destructor_type)0));
  }

update_cleanup:
  sqlite3AuthContextPop(&sContext);
  sqlite3DbFree(db, aXRef);
  sqlite3SrcListDelete(db, pTabList);
  sqlite3ExprListDelete(db, pChanges);
  sqlite3ExprDelete(db, pWhere);




  return;
}
# 134615 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void updateVirtualTable(
  Parse *pParse,
  SrcList *pSrc,
  Table *pTab,
  ExprList *pChanges,
  Expr *pRowid,
  int *aXRef,
  Expr *pWhere,
  int onError
){
  Vdbe *v = pParse->pVdbe;
  int ephemTab;
  int i;
  sqlite3 *db = pParse->db;
  const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);
  WhereInfo *pWInfo;
  int nArg = 2 + pTab->nCol;
  int regArg;
  int regRec;
  int regRowid;
  int iCsr = pSrc->a[0].iCursor;
  int aDummy[2];
  int eOnePass;
  int addr;




  ((void)0);
  ephemTab = pParse->nTab++;
  addr= sqlite3VdbeAddOp2(v, 112, ephemTab, nArg);
  regArg = pParse->nMem + 1;
  pParse->nMem += nArg;
  regRec = ++pParse->nMem;
  regRowid = ++pParse->nMem;


  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0,0,0x0004,0);
  if( pWInfo==0 ) return;


  for(i=0; i<pTab->nCol; i++){
    if( aXRef[i]>=0 ){
      sqlite3ExprCode(pParse, pChanges->a[aXRef[i]].pExpr, regArg+2+i);
    }else{
      sqlite3VdbeAddOp3(v, 164, iCsr, i, regArg+2+i);
      sqlite3VdbeChangeP5(v, 0x01);
    }
  }
  if( (((pTab)->tabFlags & 0x0020)==0) ){
    sqlite3VdbeAddOp2(v, 128, iCsr, regArg);
    if( pRowid ){
      sqlite3ExprCode(pParse, pRowid, regArg+1);
    }else{
      sqlite3VdbeAddOp2(v, 128, iCsr, regArg+1);
    }
  }else{
    Index *pPk;
    i16 iPk;
    pPk = sqlite3PrimaryKeyIndex(pTab);
    ((void)0);
    ((void)0);
    iPk = pPk->aiColumn[0];
    sqlite3VdbeAddOp3(v, 164, iCsr, iPk, regArg);
    sqlite3VdbeAddOp2(v, 79, regArg+2+iPk, regArg+1);
  }

  eOnePass = sqlite3WhereOkOnePass(pWInfo, aDummy);


  ((void)0);

  if( eOnePass ){


    sqlite3VdbeChangeToNoop(v, addr);
    sqlite3VdbeAddOp1(v, 117, iCsr);
  }else{


    sqlite3MultiWrite(pParse);
    sqlite3VdbeAddOp3(v, 92, regArg, nArg, regRec);





    sqlite3VdbeAddOp2(v, 121, ephemTab, regRowid);
    sqlite3VdbeAddOp3(v, 122, ephemTab, regRec, regRowid);
  }


  if( eOnePass==0 ){

    sqlite3WhereEnd(pWInfo);


    addr = sqlite3VdbeAddOp1(v, 36, ephemTab); ;



    for(i=0; i<nArg; i++){
      sqlite3VdbeAddOp3(v, 90, ephemTab, i, regArg+i);
    }
  }
  sqlite3VtabMakeWritable(pParse, pTab);
  sqlite3VdbeAddOp4(v, 10, 0, nArg, regArg, pVTab, (-12));
  sqlite3VdbeChangeP5(v, onError==11 ? 2 : onError);
  sqlite3MayAbort(pParse);



  if( eOnePass==0 ){
    sqlite3VdbeAddOp2(v, 5, ephemTab, addr+1); ;
    sqlite3VdbeJumpHere(v, addr);
    sqlite3VdbeAddOp2(v, 117, ephemTab, 0);
  }else{
    sqlite3WhereEnd(pWInfo);
  }
}
# 134759 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3UpsertDelete(sqlite3 *db, Upsert *p){
  if( p ){
    sqlite3ExprListDelete(db, p->pUpsertTarget);
    sqlite3ExprDelete(db, p->pUpsertTargetWhere);
    sqlite3ExprListDelete(db, p->pUpsertSet);
    sqlite3ExprDelete(db, p->pUpsertWhere);
    sqlite3DbFree(db, p);
  }
}




static Upsert *sqlite3UpsertDup(sqlite3 *db, Upsert *p){
  if( p==0 ) return 0;
  return sqlite3UpsertNew(db,
           sqlite3ExprListDup(db, p->pUpsertTarget, 0),
           sqlite3ExprDup(db, p->pUpsertTargetWhere, 0),
           sqlite3ExprListDup(db, p->pUpsertSet, 0),
           sqlite3ExprDup(db, p->pUpsertWhere, 0)
         );
}




static Upsert *sqlite3UpsertNew(
  sqlite3 *db,
  ExprList *pTarget,
  Expr *pTargetWhere,
  ExprList *pSet,
  Expr *pWhere
){
  Upsert *pNew;
  pNew = sqlite3DbMallocRaw(db, sizeof(Upsert));
  if( pNew==0 ){
    sqlite3ExprListDelete(db, pTarget);
    sqlite3ExprDelete(db, pTargetWhere);
    sqlite3ExprListDelete(db, pSet);
    sqlite3ExprDelete(db, pWhere);
    return 0;
  }else{
    pNew->pUpsertTarget = pTarget;
    pNew->pUpsertTargetWhere = pTargetWhere;
    pNew->pUpsertSet = pSet;
    pNew->pUpsertWhere = pWhere;
    pNew->pUpsertIdx = 0;
  }
  return pNew;
}
# 134817 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3UpsertAnalyzeTarget(
  Parse *pParse,
  SrcList *pTabList,
  Upsert *pUpsert
){
  Table *pTab;
  int rc;
  int iCursor;
  Index *pIdx;
  ExprList *pTarget;
  Expr *pTerm;
  NameContext sNC;
  Expr sCol[2];

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);





  memset(&sNC, 0, sizeof(sNC));
  sNC.pParse = pParse;
  sNC.pSrcList = pTabList;
  rc = sqlite3ResolveExprListNames(&sNC, pUpsert->pUpsertTarget);
  if( rc ) return rc;
  rc = sqlite3ResolveExprNames(&sNC, pUpsert->pUpsertTargetWhere);
  if( rc ) return rc;


  pTab = pTabList->a[0].pTab;
  pTarget = pUpsert->pUpsertTarget;
  iCursor = pTabList->a[0].iCursor;
  if( (((pTab)->tabFlags & 0x0020)==0)
   && pTarget->nExpr==1
   && (pTerm = pTarget->a[0].pExpr)->op==162
   && pTerm->iColumn==(-1)
  ){

    ((void)0);
    return 0;
  }







  memset(sCol, 0, sizeof(sCol));
  sCol[0].op = 109;
  sCol[0].pLeft = &sCol[1];
  sCol[1].op = 162;
  sCol[1].iTable = pTabList->a[0].iCursor;


  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    int ii, jj, nn;
    if( !((pIdx)->onError!=0) ) continue;
    if( pTarget->nExpr!=pIdx->nKeyCol ) continue;
    if( pIdx->pPartIdxWhere ){
      if( pUpsert->pUpsertTargetWhere==0 ) continue;
      if( sqlite3ExprCompare(pParse, pUpsert->pUpsertTargetWhere,
                             pIdx->pPartIdxWhere, iCursor)!=0 ){
        continue;
      }
    }
    nn = pIdx->nKeyCol;
    for(ii=0; ii<nn; ii++){
      Expr *pExpr;
      sCol[0].u.zToken = (char*)pIdx->azColl[ii];
      if( pIdx->aiColumn[ii]==(-2) ){
        ((void)0);
        ((void)0);
        pExpr = pIdx->aColExpr->a[ii].pExpr;
        if( pExpr->op!=109 ){
          sCol[0].pLeft = pExpr;
          pExpr = &sCol[0];
        }
      }else{
        sCol[0].pLeft = &sCol[1];
        sCol[1].iColumn = pIdx->aiColumn[ii];
        pExpr = &sCol[0];
      }
      for(jj=0; jj<nn; jj++){
        if( sqlite3ExprCompare(pParse, pTarget->a[jj].pExpr, pExpr,iCursor)<2 ){
          break;
        }
      }
      if( jj>=nn ){

        break;
      }
    }
    if( ii<nn ){


      continue;
    }
    pUpsert->pUpsertIdx = pIdx;
    return 0;
  }
  sqlite3ErrorMsg(pParse, "ON CONFLICT clause does not match any "
                          "PRIMARY KEY or UNIQUE constraint");
  return 1;
}
# 134935 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3UpsertDoUpdate(
  Parse *pParse,
  Upsert *pUpsert,
  Table *pTab,
  Index *pIdx,
  int iCur
){
  Vdbe *v = pParse->pVdbe;
  sqlite3 *db = pParse->db;
  SrcList *pSrc;
  int iDataCur;
  int i;

  ((void)0);
  ((void)0);
  ;
  iDataCur = pUpsert->iDataCur;
  if( pIdx && iCur!=iDataCur ){
    if( (((pTab)->tabFlags & 0x0020)==0) ){
      int regRowid = sqlite3GetTempReg(pParse);
      sqlite3VdbeAddOp2(v, 135, iCur, regRowid);
      sqlite3VdbeAddOp3(v, 30, iDataCur, 0, regRowid);
      ;
      sqlite3ReleaseTempReg(pParse, regRowid);
    }else{
      Index *pPk = sqlite3PrimaryKeyIndex(pTab);
      int nPk = pPk->nKeyCol;
      int iPk = pParse->nMem+1;
      pParse->nMem += nPk;
      for(i=0; i<nPk; i++){
        int k;
        ((void)0);
        k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[i]);
        sqlite3VdbeAddOp3(v, 90, iCur, k, iPk+i);
       
                                                        ;
      }
      ;
      i = sqlite3VdbeAddOp4Int(v, 29, iDataCur, 0, iPk, nPk);
      ;
      sqlite3VdbeAddOp4(v, 69, 11, 2, 0,
            "corrupt database", (-1));
      sqlite3VdbeJumpHere(v, i);
    }
  }


  pSrc = sqlite3SrcListDup(db, pUpsert->pUpsertSrc, 0);

  for(i=0; i<pTab->nCol; i++){
    if( pTab->aCol[i].affinity==0x45 ){
      sqlite3VdbeAddOp1(v, 84, pUpsert->regData+i);
    }
  }
  sqlite3Update(pParse, pSrc, pUpsert->pUpsertSet,
      pUpsert->pUpsertWhere, 2, 0, 0, pUpsert);
  pUpsert->pUpsertSet = 0;
  pUpsert->pUpsertWhere = 0;
  ;
}
# 135031 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){
  sqlite3_stmt *pStmt;
  int rc;


  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);
  if( rc!=0 ) return rc;
  while( 100==(rc = sqlite3_step(pStmt)) ){
    const char *zSubSql = (const char*)sqlite3_column_text(pStmt,0);
    ((void)0);





    if( zSubSql
     && (strncmp(zSubSql,"CRE",3)==0 || strncmp(zSubSql,"INS",3)==0)
    ){
      rc = execSql(db, pzErrMsg, zSubSql);
      if( rc!=0 ) break;
    }
  }
  ((void)0);
  if( rc==101 ) rc = 0;
  if( rc ){
    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));
  }
  (void)sqlite3_finalize(pStmt);
  return rc;
}
static int execSqlF(sqlite3 *db, char **pzErrMsg, const char *zSql, ...){
  char *z;
  va_list ap;
  int rc;
  ( ap = (va_list)( &(zSql) ) + ( (sizeof(zSql) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  z = sqlite3VMPrintf(db, zSql, ap);
  ( ap = (va_list)0 );
  if( z==0 ) return 7;
  rc = execSql(db, pzErrMsg, z);
  sqlite3DbFree(db, z);
  return rc;
}
# 135104 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Vacuum(Parse *pParse, Token *pNm, Expr *pInto){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int iDb = 0;
  if( v==0 ) goto build_vacuum_end;
  if( pParse->nErr ) goto build_vacuum_end;
  if( pNm ){



    iDb = sqlite3TwoPartName(pParse, pNm, pNm, &pNm);
    if( iDb<0 ) goto build_vacuum_end;
# 135124 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }
  if( iDb!=1 ){
    int iIntoReg = 0;
    if( pInto && sqlite3ResolveSelfReference(pParse,0,0,pInto,0)==0 ){
      iIntoReg = ++pParse->nMem;
      sqlite3ExprCode(pParse, pInto, iIntoReg);
    }
    sqlite3VdbeAddOp2(v, 8, iDb, iIntoReg);
    sqlite3VdbeUsesBtree(v, iDb);
  }
build_vacuum_end:
  sqlite3ExprDelete(pParse->db, pInto);
  return;
}




static __attribute__((noinline)) int sqlite3RunVacuum(
  char **pzErrMsg,
  sqlite3 *db,
  int iDb,
  sqlite3_value *pOut
){
  int rc = 0;
  Btree *pMain;
  Btree *pTemp;
  u32 saved_mDbFlags;
  u64 saved_flags;
  int saved_nChange;
  int saved_nTotalChange;
  u32 saved_openFlags;
  u8 saved_mTrace;
  Db *pDb = 0;
  int isMemDb;
  int nRes;
  int nDb;
  const char *zDbMain;
  const char *zOut;

  if( !db->autoCommit ){
    sqlite3SetString(pzErrMsg, db, "cannot VACUUM from within a transaction");
    return 1;
  }
  if( db->nVdbeActive>1 ){
    sqlite3SetString(pzErrMsg, db,"cannot VACUUM - SQL statements in progress");
    return 1;
  }
  saved_openFlags = db->openFlags;
  if( pOut ){
    if( sqlite3_value_type(pOut)!=3 ){
      sqlite3SetString(pzErrMsg, db, "non-text filename");
      return 1;
    }
    zOut = (const char*)sqlite3_value_text(pOut);
    db->openFlags &= ~0x00000001;
    db->openFlags |= 0x00000004|0x00000002;
  }else{
    zOut = "";
  }




  saved_flags = db->flags;
  saved_mDbFlags = db->mDbFlags;
  saved_nChange = db->nChange;
  saved_nTotalChange = db->nTotalChange;
  saved_mTrace = db->mTrace;
  db->flags |= 0x00000001 | 0x00000200;
  db->mDbFlags |= 0x0002 | 0x0004;
  db->flags &= ~(u64)(0x00004000 | 0x00001000
                   | 0x10000000 | 0x00000080);
  db->mTrace = 0;

  zDbMain = db->aDb[iDb].zDbSName;
  pMain = db->aDb[iDb].pBt;
  isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));
# 135217 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  nDb = db->nDb;
  rc = execSqlF(db, pzErrMsg, "ATTACH %Q AS vacuum_db", zOut);
  db->openFlags = saved_openFlags;
  if( rc!=0 ) goto end_of_vacuum;
  ((void)0);
  pDb = &db->aDb[nDb];
  ((void)0);
  pTemp = pDb->pBt;
  if( pOut ){
    sqlite3_file *id = sqlite3PagerFile(sqlite3BtreePager(pTemp));
    i64 sz = 0;
    if( id->pMethods!=0 && (sqlite3OsFileSize(id, &sz)!=0 || sz>0) ){
      rc = 1;
      sqlite3SetString(pzErrMsg, db, "output file already exists");
      goto end_of_vacuum;
    }
    db->mDbFlags |= 0x0008;
  }
  nRes = sqlite3BtreeGetOptimalReserve(pMain);
# 135248 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3BtreeSetCacheSize(pTemp, db->aDb[iDb].pSchema->cache_size);
  sqlite3BtreeSetSpillSize(pTemp, sqlite3BtreeSetSpillSize(pMain,0));
  sqlite3BtreeSetPagerFlags(pTemp, 0x01|0x20);





  rc = execSql(db, pzErrMsg, "BEGIN");
  if( rc!=0 ) goto end_of_vacuum;
  rc = sqlite3BtreeBeginTrans(pMain, pOut==0 ? 2 : 0, 0);
  if( rc!=0 ) goto end_of_vacuum;


  if( sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))
                                               ==5 ){
    db->nextPagesize = 0;
  }

  if( sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0)
   || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0))
   || (db->mallocFailed)
  ){
    rc = 7;
    goto end_of_vacuum;
  }


  sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac>=0 ? db->nextAutovac :
                                           sqlite3BtreeGetAutoVacuum(pMain));





  db->init.iDb = nDb;
  rc = execSqlF(db, pzErrMsg,
      "SELECT sql FROM \"%w\".sqlite_master"
      " WHERE type='table'AND name<>'sqlite_sequence'"
      " AND coalesce(rootpage,1)>0",
      zDbMain
  );
  if( rc!=0 ) goto end_of_vacuum;
  rc = execSqlF(db, pzErrMsg,
      "SELECT sql FROM \"%w\".sqlite_master"
      " WHERE type='index'",
      zDbMain
  );
  if( rc!=0 ) goto end_of_vacuum;
  db->init.iDb = 0;





  rc = execSqlF(db, pzErrMsg,
      "SELECT'INSERT INTO vacuum_db.'||quote(name)"
      "||' SELECT*FROM\"%w\".'||quote(name)"
      "FROM vacuum_db.sqlite_master "
      "WHERE type='table'AND coalesce(rootpage,1)>0",
      zDbMain
  );
  ((void)0);
  db->mDbFlags &= ~0x0004;
  if( rc!=0 ) goto end_of_vacuum;






  rc = execSqlF(db, pzErrMsg,
      "INSERT INTO vacuum_db.sqlite_master"
      " SELECT*FROM \"%w\".sqlite_master"
      " WHERE type IN('view','trigger')"
      " OR(type='table'AND rootpage=0)",
      zDbMain
  );
  if( rc ) goto end_of_vacuum;







  {
    u32 meta;
    int i;







    static const unsigned char aCopy[] = {
       1, 1,
       3, 0,
       5, 0,
       6, 0,
       8, 0,
    };

    ((void)0);
    ((void)0);


    for(i=0; i<((int)(sizeof(aCopy)/sizeof(aCopy[0]))); i+=2){


      sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);
      rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta+aCopy[i+1]);
      if( (rc!=0) ) goto end_of_vacuum;
    }

    if( pOut==0 ){
      rc = sqlite3BtreeCopyFile(pMain, pTemp);
    }
    if( rc!=0 ) goto end_of_vacuum;
    rc = sqlite3BtreeCommit(pTemp);
    if( rc!=0 ) goto end_of_vacuum;

    if( pOut==0 ){
      sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));
    }

  }

  ((void)0);
  if( pOut==0 ){
    rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes,1);
  }

end_of_vacuum:

  db->init.iDb = 0;
  db->mDbFlags = saved_mDbFlags;
  db->flags = saved_flags;
  db->nChange = saved_nChange;
  db->nTotalChange = saved_nTotalChange;
  db->mTrace = saved_mTrace;
  sqlite3BtreeSetPageSize(pMain, -1, -1, 1);
# 135399 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  db->autoCommit = 1;

  if( pDb ){
    sqlite3BtreeClose(pDb->pBt);
    pDb->pBt = 0;
    pDb->pSchema = 0;
  }



  sqlite3ResetAllSchemasOfConnection(db);

  return rc;
}
# 135441 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct VtabCtx {
  VTable *pVTable;
  Table *pTab;
  VtabCtx *pPrior;
  int bDeclared;
};
# 135456 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Module *sqlite3VtabCreateModule(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){
  Module *pMod;
  Module *pDel;
  char *zCopy;
  if( pModule==0 ){
    zCopy = (char*)zName;
    pMod = 0;
  }else{
    int nName = sqlite3Strlen30(zName);
    pMod = (Module *)sqlite3Malloc(sizeof(Module) + nName + 1);
    if( pMod==0 ){
      sqlite3OomFault(db);
      return 0;
    }
    zCopy = (char *)(&pMod[1]);
    memcpy(zCopy, zName, nName+1);
    pMod->zName = zCopy;
    pMod->pModule = pModule;
    pMod->pAux = pAux;
    pMod->xDestroy = xDestroy;
    pMod->pEpoTab = 0;
    pMod->nRefModule = 1;
  }
  pDel = (Module *)sqlite3HashInsert(&db->aModule,zCopy,(void*)pMod);
  if( pDel ){
    if( pDel==pMod ){
      sqlite3OomFault(db);
      sqlite3DbFree(db, pDel);
      pMod = 0;
    }else{
      sqlite3VtabEponymousTableClear(db, pDel);
      sqlite3VtabModuleUnref(db, pDel);
    }
  }
  return pMod;
}






static int createModule(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){
  int rc = 0;

  sqlite3_mutex_enter(db->mutex);
  (void)sqlite3VtabCreateModule(db, zName, pModule, pAux, xDestroy);
  rc = sqlite3ApiExit(db, rc);
  if( rc!=0 && xDestroy ) xDestroy(pAux);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





 int sqlite3_create_module(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux
){



  return createModule(db, zName, pModule, pAux, 0);
}




 int sqlite3_create_module_v2(
  sqlite3 *db,
  const char *zName,
  const sqlite3_module *pModule,
  void *pAux,
  void (*xDestroy)(void *)
){



  return createModule(db, zName, pModule, pAux, xDestroy);
}





 int sqlite3_drop_modules(sqlite3 *db, const char** azNames){
  HashElem *pThis, *pNext;



  for(pThis=((&db->aModule)->first); pThis; pThis=pNext){
    Module *pMod = (Module*)((pThis)->data);
    pNext = ((pThis)->next);
    if( azNames ){
      int ii;
      for(ii=0; azNames[ii]!=0 && strcmp(azNames[ii],pMod->zName)!=0; ii++){}
      if( azNames[ii]!=0 ) continue;
    }
    createModule(db, pMod->zName, 0, 0, 0);
  }
  return 0;
}





static void sqlite3VtabModuleUnref(sqlite3 *db, Module *pMod){
  ((void)0);
  pMod->nRefModule--;
  if( pMod->nRefModule==0 ){
    if( pMod->xDestroy ){
      pMod->xDestroy(pMod->pAux);
    }
    ((void)0);
    sqlite3DbFree(db, pMod);
  }
}
# 135599 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VtabLock(VTable *pVTab){
  pVTab->nRef++;
}







static VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){
  VTable *pVtab;
  ((void)0);
  for(pVtab=pTab->pVTable; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);
  return pVtab;
}





static void sqlite3VtabUnlock(VTable *pVTab){
  sqlite3 *db = pVTab->db;

  ((void)0);
  ((void)0);
  ((void)0);

  pVTab->nRef--;
  if( pVTab->nRef==0 ){
    sqlite3_vtab *p = pVTab->pVtab;
    sqlite3VtabModuleUnref(pVTab->db, pVTab->pMod);
    if( p ){
      p->pModule->xDisconnect(p);
    }
    sqlite3DbFree(db, pVTab);
  }
}
# 135645 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static VTable *vtabDisconnectAll(sqlite3 *db, Table *p){
  VTable *pRet = 0;
  VTable *pVTable = p->pVTable;
  p->pVTable = 0;







  ((void)0);

  while( pVTable ){
    sqlite3 *db2 = pVTable->db;
    VTable *pNext = pVTable->pNext;
    ((void)0);
    if( db2==db ){
      pRet = pVTable;
      p->pVTable = pRet;
      pRet->pNext = 0;
    }else{
      pVTable->pNext = db2->pDisconnect;
      db2->pDisconnect = pVTable;
    }
    pVTable = pNext;
  }

  ((void)0);
  return pRet;
}
# 135685 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VtabDisconnect(sqlite3 *db, Table *p){
  VTable **ppVTab;

  ((void)0);
  ((void)0);
  ((void)0);

  for(ppVTab=&p->pVTable; *ppVTab; ppVTab=&(*ppVTab)->pNext){
    if( (*ppVTab)->db==db ){
      VTable *pVTab = *ppVTab;
      *ppVTab = pVTab->pNext;
      sqlite3VtabUnlock(pVTab);
      break;
    }
  }
}
# 135723 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VtabUnlockList(sqlite3 *db){
  VTable *p = db->pDisconnect;
  db->pDisconnect = 0;

  ((void)0);
  ((void)0);

  if( p ){
    sqlite3ExpirePreparedStatements(db, 0);
    do {
      VTable *pNext = p->pNext;
      sqlite3VtabUnlock(p);
      p = pNext;
    }while( p );
  }
}
# 135754 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3VtabClear(sqlite3 *db, Table *p){
  if( !db || db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);
  if( p->azModuleArg ){
    int i;
    for(i=0; i<p->nModuleArg; i++){
      if( i!=1 ) sqlite3DbFree(db, p->azModuleArg[i]);
    }
    sqlite3DbFree(db, p->azModuleArg);
  }
}







static void addModuleArgument(Parse *pParse, Table *pTable, char *zArg){
  sqlite3_int64 nBytes = sizeof(char *)*(2+pTable->nModuleArg);
  char **azModuleArg;
  sqlite3 *db = pParse->db;
  if( pTable->nModuleArg+3>=db->aLimit[2] ){
    sqlite3ErrorMsg(pParse, "too many columns on %s", pTable->zName);
  }
  azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);
  if( azModuleArg==0 ){
    sqlite3DbFree(db, zArg);
  }else{
    int i = pTable->nModuleArg++;
    azModuleArg[i] = zArg;
    azModuleArg[i+1] = 0;
    pTable->azModuleArg = azModuleArg;
  }
}






static void sqlite3VtabBeginParse(
  Parse *pParse,
  Token *pName1,
  Token *pName2,
  Token *pModuleName,
  int ifNotExists
){
  Table *pTable;
  sqlite3 *db;

  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, ifNotExists);
  pTable = pParse->pNewTable;
  if( pTable==0 ) return;
  ((void)0);

  db = pParse->db;

  ((void)0);
  addModuleArgument(pParse, pTable, sqlite3NameFromToken(db, pModuleName));
  addModuleArgument(pParse, pTable, 0);
  addModuleArgument(pParse, pTable, sqlite3DbStrDup(db, pTable->zName));
  ((void)0)

   ;
  pParse->sNameToken.n = (int)(
      &pModuleName->z[pModuleName->n] - pParse->sNameToken.z
  );







  if( pTable->azModuleArg ){
    int iDb = sqlite3SchemaToIndex(db, pTable->pSchema);
    ((void)0);
    sqlite3AuthCheck(pParse, 29, pTable->zName,
            pTable->azModuleArg[0], pParse->db->aDb[iDb].zDbSName);
  }

}






static void addArgumentToVtab(Parse *pParse){
  if( pParse->sArg.z && pParse->pNewTable ){
    const char *z = (const char*)pParse->sArg.z;
    int n = pParse->sArg.n;
    sqlite3 *db = pParse->db;
    addModuleArgument(pParse, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));
  }
}





static void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){
  Table *pTab = pParse->pNewTable;
  sqlite3 *db = pParse->db;

  if( pTab==0 ) return;
  addArgumentToVtab(pParse);
  pParse->sArg.z = 0;
  if( pTab->nModuleArg<1 ) return;







  if( !db->init.busy ){
    char *zStmt;
    char *zWhere;
    int iDb;
    int iReg;
    Vdbe *v;


    if( pEnd ){
      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;
    }
    zStmt = sqlite3MPrintf(db, "CREATE VIRTUAL TABLE %T", &pParse->sNameToken);
# 135891 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    sqlite3NestedParse(pParse,
      "UPDATE %Q.%s "
         "SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q "
       "WHERE rowid=#%d",
      db->aDb[iDb].zDbSName, "sqlite_master",
      pTab->zName,
      pTab->zName,
      zStmt,
      pParse->regRowid
    );
    sqlite3DbFree(db, zStmt);
    v = sqlite3GetVdbe(pParse);
    sqlite3ChangeCookie(pParse, iDb);

    sqlite3VdbeAddOp0(v, 158);
    zWhere = sqlite3MPrintf(db, "name='%q' AND type='table'", pTab->zName);
    sqlite3VdbeAddParseSchemaOp(v, iDb, zWhere);

    iReg = ++pParse->nMem;
    sqlite3VdbeLoadString(v, iReg, pTab->zName);
    sqlite3VdbeAddOp2(v, 161, iDb, iReg);
  }






  else {
    Table *pOld;
    Schema *pSchema = pTab->pSchema;
    const char *zName = pTab->zName;
    ((void)0);
    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, pTab);
    if( pOld ){
      sqlite3OomFault(db);
      ((void)0);
      return;
    }
    pParse->pNewTable = 0;
  }
}





static void sqlite3VtabArgInit(Parse *pParse){
  addArgumentToVtab(pParse);
  pParse->sArg.z = 0;
  pParse->sArg.n = 0;
}





static void sqlite3VtabArgExtend(Parse *pParse, Token *p){
  Token *pArg = &pParse->sArg;
  if( pArg->z==0 ){
    pArg->z = p->z;
    pArg->n = p->n;
  }else{
    ((void)0);
    pArg->n = (int)(&p->z[p->n] - pArg->z);
  }
}






static int vtabCallConstructor(
  sqlite3 *db,
  Table *pTab,
  Module *pMod,
  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),
  char **pzErr
){
  VtabCtx sCtx;
  VTable *pVTable;
  int rc;
  const char *const*azArg = (const char *const*)pTab->azModuleArg;
  int nArg = pTab->nModuleArg;
  char *zErr = 0;
  char *zModuleName;
  int iDb;
  VtabCtx *pCtx;


  for(pCtx=db->pVtabCtx; pCtx; pCtx=pCtx->pPrior){
    if( pCtx->pTab==pTab ){
      *pzErr = sqlite3MPrintf(db,
          "vtable constructor called recursively: %s", pTab->zName
      );
      return 6;
    }
  }

  zModuleName = sqlite3DbStrDup(db, pTab->zName);
  if( !zModuleName ){
    return 7;
  }

  pVTable = sqlite3MallocZero(sizeof(VTable));
  if( !pVTable ){
    sqlite3OomFault(db);
    sqlite3DbFree(db, zModuleName);
    return 7;
  }
  pVTable->db = db;
  pVTable->pMod = pMod;

  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
  pTab->azModuleArg[1] = db->aDb[iDb].zDbSName;


  ((void)0);
  ((void)0);
  sCtx.pTab = pTab;
  sCtx.pVTable = pVTable;
  sCtx.pPrior = db->pVtabCtx;
  sCtx.bDeclared = 0;
  db->pVtabCtx = &sCtx;
  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);
  db->pVtabCtx = sCtx.pPrior;
  if( rc==7 ) sqlite3OomFault(db);
  ((void)0);

  if( 0!=rc ){
    if( zErr==0 ){
      *pzErr = sqlite3MPrintf(db, "vtable constructor failed: %s", zModuleName);
    }else {
      *pzErr = sqlite3MPrintf(db, "%s", zErr);
      sqlite3_free(zErr);
    }
    sqlite3DbFree(db, pVTable);
  }else if( (pVTable->pVtab) ){


    memset(pVTable->pVtab, 0, sizeof(pVTable->pVtab[0]));
    pVTable->pVtab->pModule = pMod->pModule;
    pMod->nRefModule++;
    pVTable->nRef = 1;
    if( sCtx.bDeclared==0 ){
      const char *zFormat = "vtable constructor did not declare schema: %s";
      *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);
      sqlite3VtabUnlock(pVTable);
      rc = 1;
    }else{
      int iCol;
      u8 oooHidden = 0;





      pVTable->pNext = pTab->pVTable;
      pTab->pVTable = pVTable;

      for(iCol=0; iCol<pTab->nCol; iCol++){
        char *zType = sqlite3ColumnType(&pTab->aCol[iCol], "");
        int nType;
        int i = 0;
        nType = sqlite3Strlen30(zType);
        for(i=0; i<nType; i++){
          if( 0==sqlite3_strnicmp("hidden", &zType[i], 6)
           && (i==0 || zType[i-1]==' ')
           && (zType[i+6]=='\0' || zType[i+6]==' ')
          ){
            break;
          }
        }
        if( i<nType ){
          int j;
          int nDel = 6 + (zType[i+6] ? 1 : 0);
          for(j=i; (j+nDel)<=nType; j++){
            zType[j] = zType[j+nDel];
          }
          if( zType[i]=='\0' && i>0 ){
            ((void)0);
            zType[i-1] = '\0';
          }
          pTab->aCol[iCol].colFlags |= 0x0002;
          oooHidden = 0x0080;
        }else{
          pTab->tabFlags |= oooHidden;
        }
      }
    }
  }

  sqlite3DbFree(db, zModuleName);
  return rc;
}
# 136096 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){
  sqlite3 *db = pParse->db;
  const char *zMod;
  Module *pMod;
  int rc;

  ((void)0);
  if( !((pTab)->nModuleArg) || sqlite3GetVTable(db, pTab) ){
    return 0;
  }


  zMod = pTab->azModuleArg[0];
  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);

  if( !pMod ){
    const char *zModule = pTab->azModuleArg[0];
    sqlite3ErrorMsg(pParse, "no such module: %s", zModule);
    rc = 1;
  }else{
    char *zErr = 0;
    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);
    if( rc!=0 ){
      sqlite3ErrorMsg(pParse, "%s", zErr);
      pParse->rc = rc;
    }
    sqlite3DbFree(db, zErr);
  }

  return rc;
}




static int growVTrans(sqlite3 *db){
  const int ARRAY_INCR = 5;


  if( (db->nVTrans%ARRAY_INCR)==0 ){
    VTable **aVTrans;
    sqlite3_int64 nBytes = sizeof(sqlite3_vtab*)*
                                 ((sqlite3_int64)db->nVTrans + ARRAY_INCR);
    aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);
    if( !aVTrans ){
      return 7;
    }
    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);
    db->aVTrans = aVTrans;
  }

  return 0;
}





static void addToVTrans(sqlite3 *db, VTable *pVTab){

  db->aVTrans[db->nVTrans++] = pVTab;
  sqlite3VtabLock(pVTab);
}
# 136168 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){
  int rc = 0;
  Table *pTab;
  Module *pMod;
  const char *zMod;

  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
  ((void)0);


  zMod = pTab->azModuleArg[0];
  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod);





  if( pMod==0 || pMod->pModule->xCreate==0 || pMod->pModule->xDestroy==0 ){
    *pzErr = sqlite3MPrintf(db, "no such module: %s", zMod);
    rc = 1;
  }else{
    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);
  }



  if( rc==0 && (sqlite3GetVTable(db, pTab)) ){
    rc = growVTrans(db);
    if( rc==0 ){
      addToVTrans(db, sqlite3GetVTable(db, pTab));
    }
  }

  return rc;
}






 int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){
  VtabCtx *pCtx;
  int rc = 0;
  Table *pTab;
  char *zErr = 0;
  Parse sParse;






  sqlite3_mutex_enter(db->mutex);
  pCtx = db->pVtabCtx;
  if( !pCtx || pCtx->bDeclared ){
    sqlite3Error(db, 21);
    sqlite3_mutex_leave(db->mutex);
    return sqlite3MisuseError(136226);
  }
  pTab = pCtx->pTab;
  ((void)0);

  memset(&sParse, 0, sizeof(sParse));
  sParse.eParseMode = 1;
  sParse.db = db;
  sParse.nQueryLoop = 1;
  if( 0==sqlite3RunParser(&sParse, zCreateTable, &zErr)
   && sParse.pNewTable
   && !db->mallocFailed
   && !sParse.pNewTable->pSelect
   && !((sParse.pNewTable)->nModuleArg)
  ){
    if( !pTab->aCol ){
      Table *pNew = sParse.pNewTable;
      Index *pIdx;
      pTab->aCol = pNew->aCol;
      pTab->nCol = pNew->nCol;
      pTab->tabFlags |= pNew->tabFlags & (0x0020|0x0040);
      pNew->nCol = 0;
      pNew->aCol = 0;
      ((void)0);
      ((void)0);
      if( !(((pNew)->tabFlags & 0x0020)==0)
       && pCtx->pVTable->pMod->pModule->xUpdate!=0
       && sqlite3PrimaryKeyIndex(pNew)->nKeyCol!=1
      ){


        rc = 1;
      }
      pIdx = pNew->pIndex;
      if( pIdx ){
        ((void)0);
        pTab->pIndex = pIdx;
        pNew->pIndex = 0;
        pIdx->pTable = pTab;
      }
    }
    pCtx->bDeclared = 1;
  }else{
    sqlite3ErrorWithMsg(db, 1, (zErr ? "%s" : 0), zErr);
    sqlite3DbFree(db, zErr);
    rc = 1;
  }
  sParse.eParseMode = 0;

  if( sParse.pVdbe ){
    sqlite3VdbeFinalize(sParse.pVdbe);
  }
  sqlite3DeleteTable(db, sParse.pNewTable);
  sqlite3ParserReset(&sParse);

  ((void)0);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 136294 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){
  int rc = 0;
  Table *pTab;

  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zDbSName);
  if( pTab!=0 && (pTab->pVTable!=0) ){
    VTable *p;
    int (*xDestroy)(sqlite3_vtab *);
    for(p=pTab->pVTable; p; p=p->pNext){
      ((void)0);
      if( p->pVtab->nRef>0 ){
        return 6;
      }
    }
    p = vtabDisconnectAll(db, pTab);
    xDestroy = p->pMod->pModule->xDestroy;
    ((void)0);
    pTab->nTabRef++;
    rc = xDestroy(p->pVtab);

    if( rc==0 ){
      ((void)0);
      p->pVtab = 0;
      pTab->pVTable = 0;
      sqlite3VtabUnlock(p);
    }
    sqlite3DeleteTable(db, pTab);
  }

  return rc;
}
# 136334 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void callFinaliser(sqlite3 *db, int offset){
  int i;
  if( db->aVTrans ){
    VTable **aVTrans = db->aVTrans;
    db->aVTrans = 0;
    for(i=0; i<db->nVTrans; i++){
      VTable *pVTab = aVTrans[i];
      sqlite3_vtab *p = pVTab->pVtab;
      if( p ){
        int (*x)(sqlite3_vtab *);
        x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);
        if( x ) x(p);
      }
      pVTab->iSavepoint = 0;
      sqlite3VtabUnlock(pVTab);
    }
    sqlite3DbFree(db, aVTrans);
    db->nVTrans = 0;
  }
}
# 136362 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VtabSync(sqlite3 *db, Vdbe *p){
  int i;
  int rc = 0;
  VTable **aVTrans = db->aVTrans;

  db->aVTrans = 0;
  for(i=0; rc==0 && i<db->nVTrans; i++){
    int (*x)(sqlite3_vtab *);
    sqlite3_vtab *pVtab = aVTrans[i]->pVtab;
    if( pVtab && (x = pVtab->pModule->xSync)!=0 ){
      rc = x(pVtab);
      sqlite3VtabImportErrmsg(p, pVtab);
    }
  }
  db->aVTrans = aVTrans;
  return rc;
}





static int sqlite3VtabRollback(sqlite3 *db){
  callFinaliser(db, __builtin_offsetof(sqlite3_module,xRollback));
  return 0;
}





static int sqlite3VtabCommit(sqlite3 *db){
  callFinaliser(db, __builtin_offsetof(sqlite3_module,xCommit));
  return 0;
}
# 136406 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){
  int rc = 0;
  const sqlite3_module *pModule;






  if( ((db)->nVTrans>0 && (db)->aVTrans==0) ){
    return 6;
  }
  if( !pVTab ){
    return 0;
  }
  pModule = pVTab->pVtab->pModule;

  if( pModule->xBegin ){
    int i;


    for(i=0; i<db->nVTrans; i++){
      if( db->aVTrans[i]==pVTab ){
        return 0;
      }
    }



    rc = growVTrans(db);
    if( rc==0 ){
      rc = pModule->xBegin(pVTab->pVtab);
      if( rc==0 ){
        int iSvpt = db->nStatement + db->nSavepoint;
        addToVTrans(db, pVTab);
        if( iSvpt && pModule->xSavepoint ){
          pVTab->iSavepoint = iSvpt;
          rc = pModule->xSavepoint(pVTab->pVtab, iSvpt-1);
        }
      }
    }
  }
  return rc;
}
# 136466 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VtabSavepoint(sqlite3 *db, int op, int iSavepoint){
  int rc = 0;

  ((void)0);
  ((void)0);
  if( db->aVTrans ){
    int i;
    for(i=0; rc==0 && i<db->nVTrans; i++){
      VTable *pVTab = db->aVTrans[i];
      const sqlite3_module *pMod = pVTab->pMod->pModule;
      if( pVTab->pVtab && pMod->iVersion>=2 ){
        int (*xMethod)(sqlite3_vtab *, int);
        sqlite3VtabLock(pVTab);
        switch( op ){
          case 0:
            xMethod = pMod->xSavepoint;
            pVTab->iSavepoint = iSavepoint+1;
            break;
          case 2:
            xMethod = pMod->xRollbackTo;
            break;
          default:
            xMethod = pMod->xRelease;
            break;
        }
        if( xMethod && pVTab->iSavepoint>iSavepoint ){
          rc = xMethod(pVTab->pVtab, iSavepoint);
        }
        sqlite3VtabUnlock(pVTab);
      }
    }
  }
  return rc;
}
# 136514 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static FuncDef *sqlite3VtabOverloadFunction(
  sqlite3 *db,
  FuncDef *pDef,
  int nArg,
  Expr *pExpr
){
  Table *pTab;
  sqlite3_vtab *pVtab;
  sqlite3_module *pMod;
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**) = 0;
  void *pArg = 0;
  FuncDef *pNew;
  int rc = 0;


  if( (pExpr==0) ) return pDef;
  if( pExpr->op!=162 ) return pDef;
  pTab = pExpr->y.pTab;
  if( pTab==0 ) return pDef;
  if( !((pTab)->nModuleArg) ) return pDef;
  pVtab = sqlite3GetVTable(db, pTab)->pVtab;
  ((void)0);
  ((void)0);
  pMod = (sqlite3_module *)pVtab->pModule;
  if( pMod->xFindFunction==0 ) return pDef;
# 136556 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  rc = pMod->xFindFunction(pVtab, nArg, pDef->zName, &xSFunc, &pArg);
  if( rc==0 ){
    return pDef;
  }



  pNew = sqlite3DbMallocZero(db, sizeof(*pNew)
                             + sqlite3Strlen30(pDef->zName) + 1);
  if( pNew==0 ){
    return pDef;
  }
  *pNew = *pDef;
  pNew->zName = (const char*)&pNew[1];
  memcpy((char*)&pNew[1], pDef->zName, sqlite3Strlen30(pDef->zName)+1);
  pNew->xSFunc = xSFunc;
  pNew->pUserData = pArg;
  pNew->funcFlags |= 0x0010;
  return pNew;
}







static void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){
  Parse *pToplevel = ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse));
  int i, n;
  Table **apVtabLock;

  ((void)0);
  for(i=0; i<pToplevel->nVtabLock; i++){
    if( pTab==pToplevel->apVtabLock[i] ) return;
  }
  n = (pToplevel->nVtabLock+1)*sizeof(pToplevel->apVtabLock[0]);
  apVtabLock = sqlite3_realloc64(pToplevel->apVtabLock, n);
  if( apVtabLock ){
    pToplevel->apVtabLock = apVtabLock;
    pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;
  }else{
    sqlite3OomFault(pToplevel->db);
  }
}
# 136616 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3VtabEponymousTableInit(Parse *pParse, Module *pMod){
  const sqlite3_module *pModule = pMod->pModule;
  Table *pTab;
  char *zErr = 0;
  int rc;
  sqlite3 *db = pParse->db;
  if( pMod->pEpoTab ) return 1;
  if( pModule->xCreate!=0 && pModule->xCreate!=pModule->xConnect ) return 0;
  pTab = sqlite3DbMallocZero(db, sizeof(Table));
  if( pTab==0 ) return 0;
  pTab->zName = sqlite3DbStrDup(db, pMod->zName);
  if( pTab->zName==0 ){
    sqlite3DbFree(db, pTab);
    return 0;
  }
  pMod->pEpoTab = pTab;
  pTab->nTabRef = 1;
  pTab->pSchema = db->aDb[0].pSchema;
  ((void)0);
  pTab->iPKey = -1;
  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));
  addModuleArgument(pParse, pTab, 0);
  addModuleArgument(pParse, pTab, sqlite3DbStrDup(db, pTab->zName));
  rc = vtabCallConstructor(db, pTab, pMod, pModule->xConnect, &zErr);
  if( rc ){
    sqlite3ErrorMsg(pParse, "%s", zErr);
    sqlite3DbFree(db, zErr);
    sqlite3VtabEponymousTableClear(db, pMod);
    return 0;
  }
  return 1;
}





static void sqlite3VtabEponymousTableClear(sqlite3 *db, Module *pMod){
  Table *pTab = pMod->pEpoTab;
  if( pTab!=0 ){



    pTab->tabFlags |= 0x0002;
    sqlite3DeleteTable(db, pTab);
    pMod->pEpoTab = 0;
  }
}
# 136672 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_vtab_on_conflict(sqlite3 *db){
  static const unsigned char aMap[] = {
    1, 4, 3, 2, 5
  };



  ((void)0);
  ((void)0);
  ((void)0);
  return (int)aMap[db->vtabOnConflict-1];
}






 int sqlite3_vtab_config(sqlite3 *db, int op, ...){
  va_list ap;
  int rc = 0;




  sqlite3_mutex_enter(db->mutex);
  ( ap = (va_list)( &(op) ) + ( (sizeof(op) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  switch( op ){
    case 1: {
      VtabCtx *p = db->pVtabCtx;
      if( !p ){
        rc = sqlite3MisuseError(136703);
      }else{
        ((void)0);
        p->pVTable->bConstraint = (u8)( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      }
      break;
    }
    default:
      rc = sqlite3MisuseError(136711);
      break;
  }
  ( ap = (va_list)0 );

  if( rc!=0 ) sqlite3Error(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 136764 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_WHEREINT_H 
# 136777 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WHERETRACE(K,X) 




typedef struct WhereClause WhereClause;
typedef struct WhereMaskSet WhereMaskSet;
typedef struct WhereOrInfo WhereOrInfo;
typedef struct WhereAndInfo WhereAndInfo;
typedef struct WhereLevel WhereLevel;
typedef struct WhereLoop WhereLoop;
typedef struct WherePath WherePath;
typedef struct WhereTerm WhereTerm;
typedef struct WhereLoopBuilder WhereLoopBuilder;
typedef struct WhereScan WhereScan;
typedef struct WhereOrCost WhereOrCost;
typedef struct WhereOrSet WhereOrSet;
# 136810 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WhereLevel {
  int iLeftJoin;
  int iTabCur;
  int iIdxCur;
  int addrBrk;
  int addrNxt;
  int addrSkip;
  int addrCont;
  int addrFirst;
  int addrBody;
  int regBignull;
  int addrBignull;

  u32 iLikeRepCntr;
  int addrLikeRep;

  u8 iFrom;
  u8 op, p3, p5;
  int p1, p2;
  union {
    struct {
      int nIn;
      struct InLoop {
        int iCur;
        int addrInTop;
        int iBase;
        int nPrefix;
        u8 eEndLoopOp;
      } *aInLoop;
    } in;
    Index *pCovidx;
  } u;
  struct WhereLoop *pWLoop;
  Bitmask notReady;



};
# 136863 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WhereLoop {
  Bitmask prereq;
  Bitmask maskSelf;



  u8 iTab;
  u8 iSortIdx;
  LogEst rSetup;
  LogEst rRun;
  LogEst nOut;
  union {
    struct {
      u16 nEq;
      u16 nBtm;
      u16 nTop;
      u16 nDistinctCol;
      Index *pIndex;
    } btree;
    struct {
      int idxNum;
      u8 needFree;
      i8 isOrdered;
      u16 omitMask;
      char *idxStr;
    } vtab;
  } u;
  u32 wsFlags;
  u16 nLTerm;
  u16 nSkip;

#define WHERE_LOOP_XFER_SZ offsetof(WhereLoop,nLSlot)
  u16 nLSlot;
  WhereTerm **aLTerm;
  WhereLoop *pNextLoop;
  WhereTerm *aLTermSpace[3];
};





struct WhereOrCost {
  Bitmask prereq;
  LogEst rRun;
  LogEst nOut;
};





#define N_OR_COST 3
struct WhereOrSet {
  u16 n;
  WhereOrCost a[3];
};
# 136939 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WherePath {
  Bitmask maskLoop;
  Bitmask revLoop;
  LogEst nRow;
  LogEst rCost;
  LogEst rUnsorted;
  i8 isOrdered;
  WhereLoop **aLoop;
};
# 137000 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WhereTerm {
  Expr *pExpr;
  WhereClause *pWC;
  LogEst truthProb;
  u16 wtFlags;
  u16 eOperator;
  u8 nChild;
  u8 eMatchOp;
  int iParent;
  int leftCursor;
  int iField;
  union {
    int leftColumn;
    WhereOrInfo *pOrInfo;
    WhereAndInfo *pAndInfo;
  } u;
  Bitmask prereqRight;
  Bitmask prereqAll;
};




#define TERM_DYNAMIC 0x01
#define TERM_VIRTUAL 0x02
#define TERM_CODED 0x04
#define TERM_COPIED 0x08
#define TERM_ORINFO 0x10
#define TERM_ANDINFO 0x20
#define TERM_OR_OK 0x40



#define TERM_VNULL 0x00

#define TERM_LIKEOPT 0x100
#define TERM_LIKECOND 0x200
#define TERM_LIKE 0x400
#define TERM_IS 0x800
#define TERM_VARSELECT 0x1000
#define TERM_NOPARTIDX 0x2000





struct WhereScan {
  WhereClause *pOrigWC;
  WhereClause *pWC;
  const char *zCollName;
  Expr *pIdxExpr;
  char idxaff;
  unsigned char nEquiv;
  unsigned char iEquiv;
  u32 opMask;
  int k;
  int aiCur[11];
  i16 aiColumn[11];
};
# 137072 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WhereClause {
  WhereInfo *pWInfo;
  WhereClause *pOuter;
  u8 op;
  u8 hasOr;
  int nTerm;
  int nSlot;
  WhereTerm *a;



  WhereTerm aStatic[8];

};





struct WhereOrInfo {
  WhereClause wc;
  Bitmask indexable;
};





struct WhereAndInfo {
  WhereClause wc;
};
# 137130 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WhereMaskSet {
  int bVarSelect;
  int n;
  int ix[((int)(sizeof(Bitmask)*8))];
};




#define initMaskSet(P) (P)->n=0





struct WhereLoopBuilder {
  WhereInfo *pWInfo;
  WhereClause *pWC;
  ExprList *pOrderBy;
  WhereLoop *pNew;
  WhereOrSet *pOrSet;




  unsigned int bldFlags;
  unsigned int iPlanLimit;
};


#define SQLITE_BLDF_INDEXED 0x0001
#define SQLITE_BLDF_UNIQUE 0x0002
# 137177 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_QUERY_PLANNER_LIMIT 20000


#define SQLITE_QUERY_PLANNER_LIMIT_INCR 1000
# 137193 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WhereInfo {
  Parse *pParse;
  SrcList *pTabList;
  ExprList *pOrderBy;
  ExprList *pResultSet;
  Expr *pWhere;
  LogEst iLimit;
  int aiCurOnePass[2];
  int iContinue;
  int iBreak;
  int savedNQueryLoop;
  u16 wctrlFlags;
  u8 nLevel;
  i8 nOBSat;
  u8 sorted;
  u8 eOnePass;
  u8 untestedTerms;
  u8 eDistinct;
  u8 bOrderedInnerLoop;
  int iTop;
  WhereLoop *pLoops;
  Bitmask revMask;
  LogEst nRowOut;
  WhereClause sWC;
  WhereMaskSet sMaskSet;
  WhereLevel a[1];
};






static Bitmask sqlite3WhereGetMask(WhereMaskSet*,int);



static WhereTerm *sqlite3WhereFindTerm(
  WhereClause *pWC,
  int iCur,
  int iColumn,
  Bitmask notReady,
  u32 op,
  Index *pIdx
);



static int sqlite3WhereExplainOneScan(
  Parse *pParse,
  SrcList *pTabList,
  WhereLevel *pLevel,
  u16 wctrlFlags
);
# 137258 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqlite3WhereAddScanStatus(a,b,c,d) ((void)d)

static Bitmask sqlite3WhereCodeOneLoopStart(
  Parse *pParse,
  Vdbe *v,
  WhereInfo *pWInfo,
  int iLevel,
  WhereLevel *pLevel,
  Bitmask notReady
);


static void sqlite3WhereClauseInit(WhereClause*,WhereInfo*);
static void sqlite3WhereClauseClear(WhereClause*);
static void sqlite3WhereSplit(WhereClause*,Expr*,u8);
static Bitmask sqlite3WhereExprUsage(WhereMaskSet*, Expr*);
static Bitmask sqlite3WhereExprUsageNN(WhereMaskSet*, Expr*);
static Bitmask sqlite3WhereExprListUsage(WhereMaskSet*, ExprList*);
static void sqlite3WhereExprAnalyze(SrcList*, WhereClause*);
static void sqlite3WhereTabFuncArgs(Parse*, struct SrcList_item*, WhereClause*);
# 137296 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WO_IN 0x0001
#define WO_EQ 0x0002
#define WO_LT (WO_EQ<<(TK_LT-TK_EQ))
#define WO_LE (WO_EQ<<(TK_LE-TK_EQ))
#define WO_GT (WO_EQ<<(TK_GT-TK_EQ))
#define WO_GE (WO_EQ<<(TK_GE-TK_EQ))
#define WO_AUX 0x0040
#define WO_IS 0x0080
#define WO_ISNULL 0x0100
#define WO_OR 0x0200
#define WO_AND 0x0400
#define WO_EQUIV 0x0800
#define WO_NOOP 0x1000

#define WO_ALL 0x1fff
#define WO_SINGLE 0x01ff






#define WHERE_COLUMN_EQ 0x00000001
#define WHERE_COLUMN_RANGE 0x00000002
#define WHERE_COLUMN_IN 0x00000004
#define WHERE_COLUMN_NULL 0x00000008
#define WHERE_CONSTRAINT 0x0000000f
#define WHERE_TOP_LIMIT 0x00000010
#define WHERE_BTM_LIMIT 0x00000020
#define WHERE_BOTH_LIMIT 0x00000030
#define WHERE_IDX_ONLY 0x00000040
#define WHERE_IPK 0x00000100
#define WHERE_INDEXED 0x00000200
#define WHERE_VIRTUALTABLE 0x00000400
#define WHERE_IN_ABLE 0x00000800
#define WHERE_ONEROW 0x00001000
#define WHERE_MULTI_OR 0x00002000
#define WHERE_AUTO_INDEX 0x00004000
#define WHERE_SKIPSCAN 0x00008000
#define WHERE_UNQ_WANTED 0x00010000
#define WHERE_PARTIALIDX 0x00020000
#define WHERE_IN_EARLYOUT 0x00040000
#define WHERE_BIGNULL_SORT 0x00080000
# 137350 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *explainIndexColumnName(Index *pIdx, int i){
  i = pIdx->aiColumn[i];
  if( i==(-2) ) return "<expr>";
  if( i==(-1) ) return "rowid";
  return pIdx->pTable->aCol[i].zName;
}
# 137365 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void explainAppendTerm(
  StrAccum *pStr,
  Index *pIdx,
  int nTerm,
  int iTerm,
  int bAnd,
  const char *zOp
){
  int i;

  ((void)0);
  if( bAnd ) sqlite3_str_append(pStr, " AND ", 5);

  if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);
  for(i=0; i<nTerm; i++){
    if( i ) sqlite3_str_append(pStr, ",", 1);
    sqlite3_str_appendall(pStr, explainIndexColumnName(pIdx, iTerm+i));
  }
  if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1);

  sqlite3_str_append(pStr, zOp, 1);

  if( nTerm>1 ) sqlite3_str_append(pStr, "(", 1);
  for(i=0; i<nTerm; i++){
    if( i ) sqlite3_str_append(pStr, ",", 1);
    sqlite3_str_append(pStr, "?", 1);
  }
  if( nTerm>1 ) sqlite3_str_append(pStr, ")", 1);
}
# 137409 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void explainIndexRange(StrAccum *pStr, WhereLoop *pLoop){
  Index *pIndex = pLoop->u.btree.pIndex;
  u16 nEq = pLoop->u.btree.nEq;
  u16 nSkip = pLoop->nSkip;
  int i, j;

  if( nEq==0 && (pLoop->wsFlags&(0x00000020|0x00000010))==0 ) return;
  sqlite3_str_append(pStr, " (", 2);
  for(i=0; i<nEq; i++){
    const char *z = explainIndexColumnName(pIndex, i);
    if( i ) sqlite3_str_append(pStr, " AND ", 5);
    sqlite3_str_appendf(pStr, i>=nSkip ? "%s=?" : "ANY(%s)", z);
  }

  j = i;
  if( pLoop->wsFlags&0x00000020 ){
    explainAppendTerm(pStr, pIndex, pLoop->u.btree.nBtm, j, i, ">");
    i = 1;
  }
  if( pLoop->wsFlags&0x00000010 ){
    explainAppendTerm(pStr, pIndex, pLoop->u.btree.nTop, j, i, "<");
  }
  sqlite3_str_append(pStr, ")", 1);
}
# 137443 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WhereExplainOneScan(
  Parse *pParse,
  SrcList *pTabList,
  WhereLevel *pLevel,
  u16 wctrlFlags
){
  int ret = 0;

  if( ((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->explain==2 )

  {
    struct SrcList_item *pItem = &pTabList->a[pLevel->iFrom];
    Vdbe *v = pParse->pVdbe;
    sqlite3 *db = pParse->db;
    int isSearch;
    WhereLoop *pLoop;
    u32 flags;
    char *zMsg;
    StrAccum str;
    char zBuf[100];

    pLoop = pLevel->pWLoop;
    flags = pLoop->wsFlags;
    if( (flags&0x00002000) || (wctrlFlags&0x0020) ) return 0;

    isSearch = (flags&(0x00000020|0x00000010))!=0
            || ((flags&0x00000400)==0 && (pLoop->u.btree.nEq>0))
            || (wctrlFlags&(0x0001|0x0002));

    sqlite3StrAccumInit(&str, db, zBuf, sizeof(zBuf), 1000000000);
    sqlite3_str_appendall(&str, isSearch ? "SEARCH" : "SCAN");
    if( pItem->pSelect ){
      sqlite3_str_appendf(&str, " SUBQUERY %u", pItem->pSelect->selId);
    }else{
      sqlite3_str_appendf(&str, " TABLE %s", pItem->zName);
    }

    if( pItem->zAlias ){
      sqlite3_str_appendf(&str, " AS %s", pItem->zAlias);
    }
    if( (flags & (0x00000100|0x00000400))==0 ){
      const char *zFmt = 0;
      Index *pIdx;

      ((void)0);
      pIdx = pLoop->u.btree.pIndex;
      ((void)0);
      if( !(((pItem->pTab)->tabFlags & 0x0020)==0) && ((pIdx)->idxType==2) ){
        if( isSearch ){
          zFmt = "PRIMARY KEY";
        }
      }else if( flags & 0x00020000 ){
        zFmt = "AUTOMATIC PARTIAL COVERING INDEX";
      }else if( flags & 0x00004000 ){
        zFmt = "AUTOMATIC COVERING INDEX";
      }else if( flags & 0x00000040 ){
        zFmt = "COVERING INDEX %s";
      }else{
        zFmt = "INDEX %s";
      }
      if( zFmt ){
        sqlite3_str_append(&str, " USING ", 7);
        sqlite3_str_appendf(&str, zFmt, pIdx->zName);
        explainIndexRange(&str, pLoop);
      }
    }else if( (flags & 0x00000100)!=0 && (flags & 0x0000000f)!=0 ){
      const char *zRangeOp;
      if( flags&(0x00000001|0x00000004) ){
        zRangeOp = "=";
      }else if( (flags&0x00000030)==0x00000030 ){
        zRangeOp = ">? AND rowid<";
      }else if( flags&0x00000020 ){
        zRangeOp = ">";
      }else{
        ((void)0);
        zRangeOp = "<";
      }
      sqlite3_str_appendf(&str,
          " USING INTEGER PRIMARY KEY (rowid%s?)",zRangeOp);
    }

    else if( (flags & 0x00000400)!=0 ){
      sqlite3_str_appendf(&str, " VIRTUAL TABLE INDEX %d:%s",
                  pLoop->u.vtab.idxNum, pLoop->u.vtab.idxStr);
    }
# 137537 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    zMsg = sqlite3StrAccumFinish(&str);
    ;
    ret = sqlite3VdbeAddOp4(v, 171, sqlite3VdbeCurrentAddr(v),
                            pParse->addrExplain, 0, zMsg,(-7));
  }
  return ret;
}
# 137618 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){
  int nLoop = 0;
  ((void)0);
  while( (pTerm->wtFlags & 0x04)==0
      && (pLevel->iLeftJoin==0 || (((pTerm->pExpr)->flags&(0x000001))!=0))
      && (pLevel->notReady & pTerm->prereqAll)==0
  ){
    if( nLoop && (pTerm->wtFlags & 0x400)!=0 ){
      pTerm->wtFlags |= 0x200;
    }else{
      pTerm->wtFlags |= 0x04;
    }
    if( pTerm->iParent<0 ) break;
    pTerm = &pTerm->pWC->a[pTerm->iParent];
    ((void)0);
    pTerm->nChild--;
    if( pTerm->nChild!=0 ) break;
    nLoop++;
  }
}
# 137650 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){
  Vdbe *v = pParse->pVdbe;
  if( zAff==0 ){
    ((void)0);
    return;
  }
  ((void)0);




  ((void)0);
  while( n>0 && zAff[0]<=0x41 ){
    n--;
    base++;
    zAff++;
  }
  while( n>1 && zAff[n-1]<=0x41 ){
    n--;
  }


  if( n>0 ){
    sqlite3VdbeAddOp4(v, 91, base, n, 0, zAff, n);
  }
}
# 137687 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void updateRangeAffinityStr(
  Expr *pRight,
  int n,
  char *zAff
){
  int i;
  for(i=0; i<n; i++){
    Expr *p = sqlite3VectorFieldSubexpr(pRight, i);
    if( sqlite3CompareAffinity(p, zAff[i])==0x41
     || sqlite3ExprNeedsNoAffinityChange(p, zAff[i])
    ){
      zAff[i] = 0x41;
    }
  }
}
# 137733 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *removeUnindexableInClauseTerms(
  Parse *pParse,
  int iEq,
  WhereLoop *pLoop,
  Expr *pX
){
  sqlite3 *db = pParse->db;
  Expr *pNew = sqlite3ExprDup(db, pX, 0);
  if( db->mallocFailed==0 ){
    ExprList *pOrigRhs = pNew->x.pSelect->pEList;
    ExprList *pOrigLhs = pNew->pLeft->x.pList;
    ExprList *pRhs = 0;
    ExprList *pLhs = 0;
    int i;
    Select *pSelect;

    for(i=iEq; i<pLoop->nLTerm; i++){
      if( pLoop->aLTerm[i]->pExpr==pX ){
        int iField = pLoop->aLTerm[i]->iField - 1;
        if( pOrigRhs->a[iField].pExpr==0 ) continue;
        pRhs = sqlite3ExprListAppend(pParse, pRhs, pOrigRhs->a[iField].pExpr);
        pOrigRhs->a[iField].pExpr = 0;
        ((void)0);
        pLhs = sqlite3ExprListAppend(pParse, pLhs, pOrigLhs->a[iField].pExpr);
        pOrigLhs->a[iField].pExpr = 0;
      }
    }
    sqlite3ExprListDelete(db, pOrigRhs);
    sqlite3ExprListDelete(db, pOrigLhs);
    pNew->pLeft->x.pList = pLhs;
    pNew->x.pSelect->pEList = pRhs;
    if( pLhs && pLhs->nExpr==1 ){



      Expr *p = pLhs->a[0].pExpr;
      pLhs->a[0].pExpr = 0;
      sqlite3ExprDelete(db, pNew->pLeft);
      pNew->pLeft = p;
    }
    pSelect = pNew->x.pSelect;
    if( pSelect->pOrderBy ){







      ExprList *pOrderBy = pSelect->pOrderBy;
      for(i=0; i<pOrderBy->nExpr; i++){
        pOrderBy->a[i].u.x.iOrderByCol = 0;
      }
    }







  }
  return pNew;
}
# 137814 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int codeEqualityTerm(
  Parse *pParse,
  WhereTerm *pTerm,
  WhereLevel *pLevel,
  int iEq,
  int bRev,
  int iTarget
){
  Expr *pX = pTerm->pExpr;
  Vdbe *v = pParse->pVdbe;
  int iReg;

  ((void)0);
  ((void)0);
  if( pX->op==53 || pX->op==45 ){
    iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);
  }else if( pX->op==50 ){
    iReg = iTarget;
    sqlite3VdbeAddOp2(v, 73, 0, iReg);

  }else{
    int eType = 5;
    int iTab;
    struct InLoop *pIn;
    WhereLoop *pLoop = pLevel->pWLoop;
    int i;
    int nEq = 0;
    int *aiMap = 0;

    if( (pLoop->wsFlags & 0x00000400)==0
      && pLoop->u.btree.pIndex!=0
      && pLoop->u.btree.pIndex->aSortOrder[iEq]
    ){
      ;
      ;
      bRev = !bRev;
    }
    ((void)0);
    iReg = iTarget;

    for(i=0; i<iEq; i++){
      if( pLoop->aLTerm[i] && pLoop->aLTerm[i]->pExpr==pX ){
        disableTerm(pLevel, pTerm);
        return iTarget;
      }
    }
    for(i=iEq;i<pLoop->nLTerm; i++){
      ((void)0);
      if( pLoop->aLTerm[i]->pExpr==pX ) nEq++;
    }

    iTab = 0;
    if( (pX->flags & 0x000800)==0 || pX->x.pSelect->pEList->nExpr==1 ){
      eType = sqlite3FindInIndex(pParse, pX, 0x0004, 0, 0, &iTab);
    }else{
      sqlite3 *db = pParse->db;
      pX = removeUnindexableInClauseTerms(pParse, iEq, pLoop, pX);

      if( !db->mallocFailed ){
        aiMap = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*nEq);
        eType = sqlite3FindInIndex(pParse, pX, 0x0004, 0, aiMap, &iTab);
        pTerm->pExpr->iTable = iTab;
      }
      sqlite3ExprDelete(db, pX);
      pX = pTerm->pExpr;
    }

    if( eType==4 ){
      ;
      bRev = !bRev;
    }
    sqlite3VdbeAddOp2(v, bRev ? 32 : 36, iTab, 0);
    ;
    ;
    ((void)0);

    pLoop->wsFlags |= 0x00000800;
    if( pLevel->u.in.nIn==0 ){
      pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);
    }

    i = pLevel->u.in.nIn;
    pLevel->u.in.nIn += nEq;
    pLevel->u.in.aInLoop =
       sqlite3DbReallocOrFree(pParse->db, pLevel->u.in.aInLoop,
                              sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);
    pIn = pLevel->u.in.aInLoop;
    if( pIn ){
      int iMap = 0;
      pIn += i;
      for(i=iEq;i<pLoop->nLTerm; i++){
        if( pLoop->aLTerm[i]->pExpr==pX ){
          int iOut = iReg + i - iEq;
          if( eType==1 ){
            pIn->addrInTop = sqlite3VdbeAddOp2(v, 128, iTab, iOut);
          }else{
            int iCol = aiMap ? aiMap[iMap++] : 0;
            pIn->addrInTop = sqlite3VdbeAddOp3(v,90,iTab, iCol, iOut);
          }
          sqlite3VdbeAddOp1(v, 50, iOut); ;
          if( i==iEq ){
            pIn->iCur = iTab;
            pIn->eEndLoopOp = bRev ? 4 : 5;
            if( iEq>0 && (pLoop->wsFlags & 0x00000400)==0 ){
              pIn->iBase = iReg - i;
              pIn->nPrefix = i;
              pLoop->wsFlags |= 0x00040000;
            }else{
              pIn->nPrefix = 0;
            }
          }else{
            pIn->eEndLoopOp = 170;
          }
          pIn++;
        }
      }
    }else{
      pLevel->u.in.nIn = 0;
    }
    sqlite3DbFree(pParse->db, aiMap);

  }
  disableTerm(pLevel, pTerm);
  return iReg;
}
# 137985 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int codeAllEqualityTerms(
  Parse *pParse,
  WhereLevel *pLevel,
  int bRev,
  int nExtraReg,
  char **pzAff
){
  u16 nEq;
  u16 nSkip;
  Vdbe *v = pParse->pVdbe;
  Index *pIdx;
  WhereTerm *pTerm;
  WhereLoop *pLoop;
  int j;
  int regBase;
  int nReg;
  char *zAff;


  pLoop = pLevel->pWLoop;
  ((void)0);
  nEq = pLoop->u.btree.nEq;
  nSkip = pLoop->nSkip;
  pIdx = pLoop->u.btree.pIndex;
  ((void)0);



  regBase = pParse->nMem + 1;
  nReg = pLoop->u.btree.nEq + nExtraReg;
  pParse->nMem += nReg;

  zAff = sqlite3DbStrDup(pParse->db,sqlite3IndexAffinityStr(pParse->db,pIdx));
  ((void)0);

  if( nSkip ){
    int iIdxCur = pLevel->iIdxCur;
    sqlite3VdbeAddOp1(v, (bRev?32:36), iIdxCur);
    ;
    ;
    ;
    j = sqlite3VdbeAddOp0(v, 11);
    pLevel->addrSkip = sqlite3VdbeAddOp4Int(v, (bRev?22:25),
                            iIdxCur, 0, regBase, nSkip);
    ;
    ;
    sqlite3VdbeJumpHere(v, j);
    for(j=0; j<nSkip; j++){
      sqlite3VdbeAddOp3(v, 90, iIdxCur, j, regBase+j);
      ;
      ;
    }
  }



  ((void)0);
  for(j=nSkip; j<nEq; j++){
    int r1;
    pTerm = pLoop->aLTerm[j];
    ((void)0);


    ;
    ;
    r1 = codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, regBase+j);
    if( r1!=regBase+j ){
      if( nReg==1 ){
        sqlite3ReleaseTempReg(pParse, regBase);
        regBase = r1;
      }else{
        sqlite3VdbeAddOp2(v, 79, r1, regBase+j);
      }
    }
    if( pTerm->eOperator & 0x0001 ){
      if( pTerm->pExpr->flags & 0x000800 ){




        if( zAff ) zAff[j] = 0x41;
      }
    }else if( (pTerm->eOperator & 0x0100)==0 ){
      Expr *pRight = pTerm->pExpr->pRight;
      if( (pTerm->wtFlags & 0x800)==0 && sqlite3ExprCanBeNull(pRight) ){
        sqlite3VdbeAddOp2(v, 50, regBase+j, pLevel->addrBrk);
        ;
      }
      if( zAff ){
        if( sqlite3CompareAffinity(pRight, zAff[j])==0x41 ){
          zAff[j] = 0x41;
        }
        if( sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j]) ){
          zAff[j] = 0x41;
        }
      }
    }
  }
  *pzAff = zAff;
  return regBase;
}
# 138105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void whereLikeOptimizationStringFixup(
  Vdbe *v,
  WhereLevel *pLevel,
  WhereTerm *pTerm
){
  if( pTerm->wtFlags & 0x100 ){
    VdbeOp *pOp;
    ((void)0);
    pOp = sqlite3VdbeGetOp(v, -1);
    ((void)0);
    ((void)0)
                                                             ;
    pOp->p3 = (int)(pLevel->iLikeRepCntr>>1);
    pOp->p5 = (u8)(pLevel->iLikeRepCntr&1);
  }
}
# 138336 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define codeCursorHint(A,B,C,D) 
# 138357 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void codeDeferredSeek(
  WhereInfo *pWInfo,
  Index *pIdx,
  int iCur,
  int iIdxCur
){
  Parse *pParse = pWInfo->pParse;
  Vdbe *v = pParse->pVdbe;

  ((void)0);
  ((void)0);

  sqlite3VdbeAddOp3(v, 134, iIdxCur, 0, iCur);
  if( (pWInfo->wctrlFlags & 0x0020)
   && (((pParse)->pToplevel ? (pParse)->pToplevel : (pParse))->writeMask)==0
  ){
    int i;
    Table *pTab = pIdx->pTable;
    int *ai = (int*)sqlite3DbMallocZero(pParse->db, sizeof(int)*(pTab->nCol+1));
    if( ai ){
      ai[0] = pTab->nCol;
      for(i=0; i<pIdx->nColumn-1; i++){
        ((void)0);
        if( pIdx->aiColumn[i]>=0 ) ai[pIdx->aiColumn[i]+1] = i+1;
      }
      sqlite3VdbeChangeP4(v, -1, (char*)ai, (-15));
    }
  }
}
# 138396 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void codeExprOrVector(Parse *pParse, Expr *p, int iReg, int nReg){
  ((void)0);
  if( p && sqlite3ExprIsVector(p) ){

    if( (p->flags & 0x000800) ){
      Vdbe *v = pParse->pVdbe;
      int iSelect;
      ((void)0);
      iSelect = sqlite3CodeSubselect(pParse, p);
      sqlite3VdbeAddOp3(v, 78, iSelect, iReg, nReg-1);
    }else

    {
      int i;
      ExprList *pList = p->x.pList;
      ((void)0);
      for(i=0; i<nReg; i++){
        sqlite3ExprCode(pParse, pList->a[i].pExpr, iReg+i);
      }
    }
  }else{
    ((void)0);
    sqlite3ExprCode(pParse, p, iReg);
  }
}





typedef struct IdxExprTrans {
  Expr *pIdxExpr;
  int iTabCur;
  int iIdxCur;
  int iIdxCol;
} IdxExprTrans;







static int whereIndexExprTransNode(Walker *p, Expr *pExpr){
  IdxExprTrans *pX = p->u.pIdxTrans;
  if( sqlite3ExprCompare(0, pExpr, pX->pIdxExpr, pX->iTabCur)==0 ){
    pExpr->affExpr = sqlite3ExprAffinity(pExpr);
    pExpr->op = 162;
    pExpr->iTable = pX->iIdxCur;
    pExpr->iColumn = pX->iIdxCol;
    pExpr->y.pTab = 0;
    return 1;
  }else{
    return 0;
  }
}






static void whereIndexExprTrans(
  Index *pIdx,
  int iTabCur,
  int iIdxCur,
  WhereInfo *pWInfo
){
  int iIdxCol;
  ExprList *aColExpr;
  Walker w;
  IdxExprTrans x;
  aColExpr = pIdx->aColExpr;
  if( aColExpr==0 ) return;
  memset(&w, 0, sizeof(w));
  w.xExprCallback = whereIndexExprTransNode;
  w.u.pIdxTrans = &x;
  x.iTabCur = iTabCur;
  x.iIdxCur = iIdxCur;
  for(iIdxCol=0; iIdxCol<aColExpr->nExpr; iIdxCol++){
    if( pIdx->aiColumn[iIdxCol]!=(-2) ) continue;
    ((void)0);
    x.iIdxCol = iIdxCol;
    x.pIdxExpr = aColExpr->a[iIdxCol].pExpr;
    sqlite3WalkExpr(&w, pWInfo->pWhere);
    sqlite3WalkExprList(&w, pWInfo->pOrderBy);
    sqlite3WalkExprList(&w, pWInfo->pResultSet);
  }
}
# 138493 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void whereApplyPartialIndexConstraints(
  Expr *pTruth,
  int iTabCur,
  WhereClause *pWC
){
  int i;
  WhereTerm *pTerm;
  while( pTruth->op==44 ){
    whereApplyPartialIndexConstraints(pTruth->pLeft, iTabCur, pWC);
    pTruth = pTruth->pRight;
  }
  for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    Expr *pExpr;
    if( pTerm->wtFlags & 0x04 ) continue;
    pExpr = pTerm->pExpr;
    if( sqlite3ExprCompare(0, pExpr, pTruth, iTabCur)==0 ){
      pTerm->wtFlags |= 0x04;
    }
  }
}





static Bitmask sqlite3WhereCodeOneLoopStart(
  Parse *pParse,
  Vdbe *v,
  WhereInfo *pWInfo,
  int iLevel,
  WhereLevel *pLevel,
  Bitmask notReady
){
  int j, k;
  int iCur;
  int addrNxt;
  int bRev;
  WhereLoop *pLoop;
  WhereClause *pWC;
  WhereTerm *pTerm;
  sqlite3 *db;
  struct SrcList_item *pTabItem;
  int addrBrk;
  int addrHalt;
  int addrCont;
  int iRowidReg = 0;
  int iReleaseReg = 0;
  Index *pIdx = 0;
  int iLoop;

  pWC = &pWInfo->sWC;
  db = pParse->db;
  pLoop = pLevel->pWLoop;
  pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];
  iCur = pTabItem->iCursor;
  pLevel->notReady = notReady & ~sqlite3WhereGetMask(&pWInfo->sMaskSet, iCur);
  bRev = (pWInfo->revMask>>iLevel)&1;
  ;
# 138562 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(pParse);
  addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(pParse);





  ((void)0)

   ;
  if( pLevel->iFrom>0 && (pTabItem[0].fg.jointype & 0x0008)!=0 ){
    pLevel->iLeftJoin = ++pParse->nMem;
    sqlite3VdbeAddOp2(v, 70, 0, pLevel->iLeftJoin);
    ;
  }



  for(j=iLevel; j>0 && pWInfo->a[j].iLeftJoin==0; j--){}
  addrHalt = pWInfo->a[j].addrBrk;


  if( pTabItem->fg.viaCoroutine ){
    int regYield = pTabItem->regReturn;
    sqlite3VdbeAddOp3(v, 13, regYield, 0, pTabItem->addrFillSub);
    pLevel->p2 = sqlite3VdbeAddOp2(v, 14, regYield, addrBrk);
    ;
    ;
    pLevel->op = 11;
  }else


  if( (pLoop->wsFlags & 0x00000400)!=0 ){



    int iReg;
    int addrNotFound;
    int nConstraint = pLoop->nLTerm;
    int iIn;

    iReg = sqlite3GetTempRange(pParse, nConstraint+2);
    addrNotFound = pLevel->addrBrk;
    for(j=0; j<nConstraint; j++){
      int iTarget = iReg+j+2;
      pTerm = pLoop->aLTerm[j];
      if( (pTerm==0) ) continue;
      if( pTerm->eOperator & 0x0001 ){
        codeEqualityTerm(pParse, pTerm, pLevel, j, bRev, iTarget);
        addrNotFound = pLevel->addrNxt;
      }else{
        Expr *pRight = pTerm->pExpr->pRight;
        codeExprOrVector(pParse, pRight, iTarget, 1);
      }
    }
    sqlite3VdbeAddOp2(v, 70, pLoop->u.vtab.idxNum, iReg);
    sqlite3VdbeAddOp2(v, 70, nConstraint, iReg+1);
    sqlite3VdbeAddOp4(v, 9, iCur, addrNotFound, iReg,
                      pLoop->u.vtab.idxStr,
                      pLoop->u.vtab.needFree ? (-7) : (-1));
    ;
    pLoop->u.vtab.needFree = 0;
    pLevel->p1 = iCur;
    pLevel->op = pWInfo->eOnePass ? 170 : 60;
    pLevel->p2 = sqlite3VdbeCurrentAddr(v);
    iIn = pLevel->u.in.nIn;
    for(j=nConstraint-1; j>=0; j--){
      pTerm = pLoop->aLTerm[j];
      if( j<16 && (pLoop->u.vtab.omitMask>>j)&1 ){
        disableTerm(pLevel, pTerm);
      }else if( (pTerm->eOperator & 0x0001)!=0 ){
        Expr *pCompare;
        Expr *pRight;
        VdbeOp *pOp;





        ((void)0);
        if( !db->mallocFailed ){
          ((void)0);
          pOp = sqlite3VdbeGetOp(v, pLevel->u.in.aInLoop[--iIn].addrInTop);
          ((void)0);
          ((void)0);
          ((void)0);
          ;
          sqlite3VdbeAddOp3(v, pOp->opcode, pOp->p1, pOp->p2, pOp->p3);
        }



        pCompare = sqlite3PExpr(pParse, 53, 0, 0);
        ((void)0);
        if( pCompare ){
          pCompare->pLeft = pTerm->pExpr->pLeft;
          pCompare->pRight = pRight = sqlite3Expr(db, 171, 0);
          if( pRight ){
            pRight->iTable = iReg+j+2;
            sqlite3ExprIfFalse(pParse, pCompare, pLevel->addrCont, 0);
          }
          pCompare->pLeft = 0;
          sqlite3ExprDelete(db, pCompare);
        }
      }
    }







  }else


  if( (pLoop->wsFlags & 0x00000100)!=0
   && (pLoop->wsFlags & (0x00000004|0x00000001))!=0
  ){





    ((void)0);
    pTerm = pLoop->aLTerm[0];
    ((void)0);
    ((void)0);
    ;
    iReleaseReg = ++pParse->nMem;
    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, 0, bRev, iReleaseReg);
    if( iRowidReg!=iReleaseReg ) sqlite3ReleaseTempReg(pParse, iReleaseReg);
    addrNxt = pLevel->addrNxt;
    sqlite3VdbeAddOp3(v, 30, iCur, addrNxt, iRowidReg);
    ;
    pLevel->op = 170;
    if( (pTerm->prereqAll & pLevel->notReady)==0 ){
      pTerm->wtFlags |= 0x04;
    }
  }else if( (pLoop->wsFlags & 0x00000100)!=0
         && (pLoop->wsFlags & 0x00000002)!=0
  ){


    int testOp = 170;
    int start;
    int memEndValue = 0;
    WhereTerm *pStart, *pEnd;

    j = 0;
    pStart = pEnd = 0;
    if( pLoop->wsFlags & 0x00000020 ) pStart = pLoop->aLTerm[j++];
    if( pLoop->wsFlags & 0x00000010 ) pEnd = pLoop->aLTerm[j++];
    ((void)0);
    if( bRev ){
      pTerm = pStart;
      pStart = pEnd;
      pEnd = pTerm;
    }
    ;
    if( pStart ){
      Expr *pX;
      int r1, rTemp;
      int op;




      const u8 aMoveOp[] = {
                        25,
                        23,
                        22,
                        24
      };
      ((void)0);
      ((void)0);
      ((void)0);

      ((void)0);
      ;
      pX = pStart->pExpr;
      ((void)0);
      ;
      if( sqlite3ExprIsVector(pX->pRight) ){
        r1 = rTemp = sqlite3GetTempReg(pParse);
        codeExprOrVector(pParse, pX->pRight, r1, 1);
        ;
        ;
        ;
        ;
        op = aMoveOp[((pX->op - 54 - 1) & 0x3) | 0x1];
        ((void)0);
        ((void)0);
        ((void)0);
        ((void)0);
      }else{
        r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);
        disableTerm(pLevel, pStart);
        op = aMoveOp[(pX->op - 54)];
      }
      sqlite3VdbeAddOp3(v, op, iCur, addrBrk, r1);
      ;
      ;
      ;
      ;
      ;
      sqlite3ReleaseTempReg(pParse, rTemp);
    }else{
      sqlite3VdbeAddOp2(v, bRev ? 32 : 36, iCur, addrHalt);
      ;
      ;
    }
    if( pEnd ){
      Expr *pX;
      pX = pEnd->pExpr;
      ((void)0);
      ((void)0);
      ;
      ;
      memEndValue = ++pParse->nMem;
      codeExprOrVector(pParse, pX->pRight, memEndValue, 1);
      if( 0==sqlite3ExprIsVector(pX->pRight)
       && (pX->op==56 || pX->op==54)
      ){
        testOp = bRev ? 55 : 57;
      }else{
        testOp = bRev ? 56 : 54;
      }
      if( 0==sqlite3ExprIsVector(pX->pRight) ){
        disableTerm(pLevel, pEnd);
      }
    }
    start = sqlite3VdbeCurrentAddr(v);
    pLevel->op = bRev ? 4 : 5;
    pLevel->p1 = iCur;
    pLevel->p2 = start;
    ((void)0);
    if( testOp!=170 ){
      iRowidReg = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 128, iCur, iRowidReg);
      sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);
      ;
      ;
      ;
      ;
      sqlite3VdbeChangeP5(v, 0x43 | 0x10);
    }
  }else if( pLoop->wsFlags & 0x00000200 ){
# 138841 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    static const u8 aStartOp[] = {
      0,
      0,
      36,
      32,
      25,
      22,
      24,
      23
    };
    static const u8 aEndOp[] = {
      40,
      38,
      37,
      39,
    };
    u16 nEq = pLoop->u.btree.nEq;
    u16 nBtm = pLoop->u.btree.nBtm;
    u16 nTop = pLoop->u.btree.nTop;
    int regBase;
    WhereTerm *pRangeStart = 0;
    WhereTerm *pRangeEnd = 0;
    int startEq;
    int endEq;
    int start_constraints;
    int nConstraint;
    int iIdxCur;
    int nExtraReg = 0;
    int op;
    char *zStartAff;
    char *zEndAff = 0;
    u8 bSeekPastNull = 0;
    u8 bStopAtNull = 0;
    int omitTable;
    int regBignull = 0;

    pIdx = pLoop->u.btree.pIndex;
    iIdxCur = pLevel->iIdxCur;
    ((void)0);




    j = nEq;
    if( pLoop->wsFlags & 0x00000020 ){
      pRangeStart = pLoop->aLTerm[j++];
      nExtraReg = ((nExtraReg)>(pLoop->u.btree.nBtm)?(nExtraReg):(pLoop->u.btree.nBtm));

      ((void)0)
                                                     ;
    }
    if( pLoop->wsFlags & 0x00000010 ){
      pRangeEnd = pLoop->aLTerm[j++];
      nExtraReg = ((nExtraReg)>(pLoop->u.btree.nTop)?(nExtraReg):(pLoop->u.btree.nTop));

      if( (pRangeEnd->wtFlags & 0x100)!=0 ){
        ((void)0);
        ((void)0);
        pLevel->iLikeRepCntr = (u32)++pParse->nMem;
        sqlite3VdbeAddOp2(v, 70, 1, (int)pLevel->iLikeRepCntr);
        ;
        pLevel->addrLikeRep = sqlite3VdbeCurrentAddr(v);


        ;
        ;
        ((void)0);
        pLevel->iLikeRepCntr <<=1;
        pLevel->iLikeRepCntr |= bRev ^ (pIdx->aSortOrder[nEq]==1);
      }

      if( pRangeStart==0 ){
        j = pIdx->aiColumn[nEq];
        if( (j>=0 && pIdx->pTable->aCol[j].notNull==0) || j==(-2) ){
          bSeekPastNull = 1;
        }
      }
    }
    ((void)0);
# 138928 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (pLoop->wsFlags & (0x00000010|0x00000020))==0
     && (pLoop->wsFlags & 0x00080000)!=0
    ){
      ((void)0);
      ((void)0);
      ((void)0);
      nExtraReg = 1;
      bSeekPastNull = 1;
      pLevel->regBignull = regBignull = ++pParse->nMem;
      pLevel->addrBignull = sqlite3VdbeMakeLabel(pParse);
    }





    if( (nEq<pIdx->nKeyCol && bRev==(pIdx->aSortOrder[nEq]==0))
     || (bRev && pIdx->nKeyCol==nEq)
    ){
      {WhereTerm * t=pRangeEnd; pRangeEnd=pRangeStart; pRangeStart=t;};
      {u8 t=bSeekPastNull; bSeekPastNull=bStopAtNull; bStopAtNull=t;};
      {u8 t=nBtm; nBtm=nTop; nTop=t;};
    }





    ;
    regBase = codeAllEqualityTerms(pParse,pLevel,bRev,nExtraReg,&zStartAff);
    ((void)0);
    if( zStartAff && nTop ){
      zEndAff = sqlite3DbStrDup(db, &zStartAff[nEq]);
    }
    addrNxt = (regBignull ? pLevel->addrBignull : pLevel->addrNxt);

    ;
    ;
    ;
    ;
    startEq = !pRangeStart || pRangeStart->eOperator & ((0x0002<<(55 -53))|(0x0002<<(57 -53)));
    endEq = !pRangeEnd || pRangeEnd->eOperator & ((0x0002<<(55 -53))|(0x0002<<(57 -53)));
    start_constraints = pRangeStart || nEq>0;


    nConstraint = nEq;
    if( pRangeStart ){
      Expr *pRight = pRangeStart->pExpr->pRight;
      codeExprOrVector(pParse, pRight, regBase+nEq, nBtm);
      whereLikeOptimizationStringFixup(v, pLevel, pRangeStart);
      if( (pRangeStart->wtFlags & 0x00)==0
       && sqlite3ExprCanBeNull(pRight)
      ){
        sqlite3VdbeAddOp2(v, 50, regBase+nEq, addrNxt);
        ;
      }
      if( zStartAff ){
        updateRangeAffinityStr(pRight, nBtm, &zStartAff[nEq]);
      }
      nConstraint += nBtm;
      ;
      if( sqlite3ExprIsVector(pRight)==0 ){
        disableTerm(pLevel, pRangeStart);
      }else{
        startEq = 1;
      }
      bSeekPastNull = 0;
    }else if( bSeekPastNull ){
      startEq = 0;
      sqlite3VdbeAddOp2(v, 73, 0, regBase+nEq);
      start_constraints = 1;
      nConstraint++;
    }else if( regBignull ){
      sqlite3VdbeAddOp2(v, 73, 0, regBase+nEq);
      start_constraints = 1;
      nConstraint++;
    }
    codeApplyAffinity(pParse, regBase, nConstraint - bSeekPastNull, zStartAff);
    if( pLoop->nSkip>0 && nConstraint==pLoop->nSkip ){



    }else{
      if( pLoop->wsFlags & 0x00040000 ){
        sqlite3VdbeAddOp1(v, 119, iIdxCur);
      }
      if( regBignull ){
        sqlite3VdbeAddOp2(v, 70, 1, regBignull);
        ;
      }

      op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];
      ((void)0);
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
      ;
      ; ;
      ; ;
      ; ;
      ; ;
      ; ;
      ; ;

      ((void)0);
      if( regBignull ){
        ((void)0);
        ((void)0);
        ((void)0);
        sqlite3VdbeAddOp2(v, 11, 0, sqlite3VdbeCurrentAddr(v)+2);
        op = aStartOp[(nConstraint>1)*4 + 2 + bRev];
        sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,
                             nConstraint-startEq);
        ;
        ; ;
        ; ;
        ; ;
        ; ;
        ((void)0);
      }
    }




    nConstraint = nEq;
    if( pRangeEnd ){
      Expr *pRight = pRangeEnd->pExpr->pRight;
      codeExprOrVector(pParse, pRight, regBase+nEq, nTop);
      whereLikeOptimizationStringFixup(v, pLevel, pRangeEnd);
      if( (pRangeEnd->wtFlags & 0x00)==0
       && sqlite3ExprCanBeNull(pRight)
      ){
        sqlite3VdbeAddOp2(v, 50, regBase+nEq, addrNxt);
        ;
      }
      if( zEndAff ){
        updateRangeAffinityStr(pRight, nTop, zEndAff);
        codeApplyAffinity(pParse, regBase+nEq, nTop, zEndAff);
      }else{
        ((void)0);
      }
      nConstraint += nTop;
      ;

      if( sqlite3ExprIsVector(pRight)==0 ){
        disableTerm(pLevel, pRangeEnd);
      }else{
        endEq = 1;
      }
    }else if( bStopAtNull ){
      if( regBignull==0 ){
        sqlite3VdbeAddOp2(v, 73, 0, regBase+nEq);
        endEq = 0;
      }
      nConstraint++;
    }
    sqlite3DbFree(db, zStartAff);
    sqlite3DbFree(db, zEndAff);


    pLevel->p2 = sqlite3VdbeCurrentAddr(v);


    if( nConstraint ){
      if( regBignull ){

        sqlite3VdbeAddOp2(v, 20, regBignull, sqlite3VdbeCurrentAddr(v)+3);
        ;
        ;
      }
      op = aEndOp[bRev*2 + endEq];
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);
      ; ;
      ; ;
      ; ;
      ; ;
    }
    if( regBignull ){


      ((void)0);
      ((void)0);
      ((void)0);
      sqlite3VdbeAddOp2(v, 18, regBignull, sqlite3VdbeCurrentAddr(v)+2);
      ;
      ;
      op = aEndOp[bRev*2 + bSeekPastNull];
      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase,
                           nConstraint+bSeekPastNull);
      ; ;
      ; ;
      ; ;
      ; ;
    }

    if( pLoop->wsFlags & 0x00040000 ){
      sqlite3VdbeAddOp2(v, 119, iIdxCur, 1);
    }


    omitTable = (pLoop->wsFlags & 0x00000040)!=0
           && (pWInfo->wctrlFlags & 0x0020)==0;
    if( omitTable ){

    }else if( (((pIdx->pTable)->tabFlags & 0x0020)==0) ){
      if( (pWInfo->wctrlFlags & 0x0400) || (
          (pWInfo->wctrlFlags & 0x1000)
       && (pWInfo->eOnePass==1)
      )){
        iRowidReg = ++pParse->nMem;
        sqlite3VdbeAddOp2(v, 135, iIdxCur, iRowidReg);
        sqlite3VdbeAddOp3(v, 31, iCur, 0, iRowidReg);
        ;
      }else{
        codeDeferredSeek(pWInfo, pIdx, iCur, iIdxCur);
      }
    }else if( iCur!=iIdxCur ){
      Index *pPk = sqlite3PrimaryKeyIndex(pIdx->pTable);
      iRowidReg = sqlite3GetTempRange(pParse, pPk->nKeyCol);
      for(j=0; j<pPk->nKeyCol; j++){
        k = sqlite3ColumnOfIndex(pIdx, pPk->aiColumn[j]);
        sqlite3VdbeAddOp3(v, 90, iIdxCur, k, iRowidReg+j);
      }
      sqlite3VdbeAddOp4Int(v, 28, iCur, addrCont,
                           iRowidReg, pPk->nKeyCol); ;
    }
# 139169 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pLevel->iLeftJoin==0 && (pWInfo->wctrlFlags & 0x0020)==0 ){
      whereIndexExprTrans(pIdx, iCur, iIdxCur, pWInfo);
    }





    if( pIdx->pPartIdxWhere ){
      whereApplyPartialIndexConstraints(pIdx->pPartIdxWhere, iCur, pWC);
    }


    if( pLoop->wsFlags & 0x00001000 ){
      pLevel->op = 170;
    }else if( bRev ){
      pLevel->op = 4;
    }else{
      pLevel->op = 5;
    }
    pLevel->p1 = iIdxCur;
    pLevel->p3 = (pLoop->wsFlags&0x00010000)!=0 ? 1:0;
    if( (pLoop->wsFlags & 0x0000000f)==0 ){
      pLevel->p5 = 1;
    }else{
      ((void)0);
    }
    if( omitTable ) pIdx = 0;
  }else


  if( pLoop->wsFlags & 0x00002000 ){
# 139244 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    WhereClause *pOrWc;
    SrcList *pOrTab;
    Index *pCov = 0;
    int iCovCur = pParse->nTab++;

    int regReturn = ++pParse->nMem;
    int regRowset = 0;
    int regRowid = 0;
    int iLoopBody = sqlite3VdbeMakeLabel(pParse);
    int iRetInit;
    int untestedTerms = 0;
    int ii;
    u16 wctrlFlags;
    Expr *pAndExpr = 0;
    Table *pTab = pTabItem->pTab;

    pTerm = pLoop->aLTerm[0];
    ((void)0);
    ((void)0);
    ((void)0);
    pOrWc = &pTerm->u.pOrInfo->wc;
    pLevel->op = 66;
    pLevel->p1 = regReturn;





    if( pWInfo->nLevel>1 ){
      int nNotReady;
      struct SrcList_item *origSrc;
      nNotReady = pWInfo->nLevel - iLevel - 1;
      pOrTab = sqlite3DbMallocRaw(db,sizeof(*pOrTab)+ nNotReady*sizeof(pOrTab->a[0]))
                                                                            ;
      if( pOrTab==0 ) return notReady;
      pOrTab->nAlloc = (u8)(nNotReady + 1);
      pOrTab->nSrc = pOrTab->nAlloc;
      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));
      origSrc = pWInfo->pTabList->a;
      for(k=1; k<=nNotReady; k++){
        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));
      }
    }else{
      pOrTab = pWInfo->pTabList;
    }
# 139302 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( (pWInfo->wctrlFlags & 0x0010)==0 ){
      if( (((pTab)->tabFlags & 0x0020)==0) ){
        regRowset = ++pParse->nMem;
        sqlite3VdbeAddOp2(v, 73, 0, regRowset);
      }else{
        Index *pPk = sqlite3PrimaryKeyIndex(pTab);
        regRowset = pParse->nTab++;
        sqlite3VdbeAddOp2(v, 112, regRowset, pPk->nKeyCol);
        sqlite3VdbeSetP4KeyInfo(pParse, pPk);
      }
      regRowid = ++pParse->nMem;
    }
    iRetInit = sqlite3VdbeAddOp2(v, 70, 0, regReturn);
# 139330 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pWC->nTerm>1 ){
      int iTerm;
      for(iTerm=0; iTerm<pWC->nTerm; iTerm++){
        Expr *pExpr = pWC->a[iTerm].pExpr;
        if( &pWC->a[iTerm] == pTerm ) continue;
        ;
        ;
        if( (pWC->a[iTerm].wtFlags & (0x02|0x04))!=0 ) continue;
        if( (pWC->a[iTerm].eOperator & 0x1fff)==0 ) continue;
        ;
        pExpr = sqlite3ExprDup(db, pExpr, 0);
        pAndExpr = sqlite3ExprAnd(pParse, pAndExpr, pExpr);
      }
      if( pAndExpr ){





        pAndExpr = sqlite3PExpr(pParse, 44|0x10000, 0, pAndExpr);
      }
    }





    wctrlFlags = 0x0020 | (pWInfo->wctrlFlags & 0x0400);
    sqlite3VdbeExplain (pParse, 1, "MULTI-INDEX OR");
    for(ii=0; ii<pOrWc->nTerm; ii++){
      WhereTerm *pOrTerm = &pOrWc->a[ii];
      if( pOrTerm->leftCursor==iCur || (pOrTerm->eOperator & 0x0400)!=0 ){
        WhereInfo *pSubWInfo;
        Expr *pOrExpr = pOrTerm->pExpr;
        int jmp1 = 0;
        ((void)0)

         ;
        if( pAndExpr ){
          pAndExpr->pLeft = pOrExpr;
          pOrExpr = pAndExpr;
        }

        sqlite3VdbeExplain (pParse, 1, "INDEX %d", ii+1);
        ;
        pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrExpr, 0, 0,
                                      wctrlFlags, iCovCur);
        ((void)0);
        if( pSubWInfo ){
          WhereLoop *pSubLoop;
          int addrExplain = sqlite3WhereExplainOneScan(
              pParse, pOrTab, &pSubWInfo->a[0], 0
          );
          ((void)addrExplain);






          if( (pWInfo->wctrlFlags & 0x0010)==0 ){
            int iSet = ((ii==pOrWc->nTerm-1)?-1:ii);
            if( (((pTab)->tabFlags & 0x0020)==0) ){
              sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, -1, regRowid);
              jmp1 = sqlite3VdbeAddOp4Int(v, 42, regRowset, 0,
                                          regRowid, iSet);
              ;
            }else{
              Index *pPk = sqlite3PrimaryKeyIndex(pTab);
              int nPk = pPk->nKeyCol;
              int iPk;
              int r;


              r = sqlite3GetTempRange(pParse, nPk);
              for(iPk=0; iPk<nPk; iPk++){
                int iCol = pPk->aiColumn[iPk];
                sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, r+iPk);
              }
# 139421 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
              if( iSet ){
                jmp1 = sqlite3VdbeAddOp4Int(v, 29, regRowset, 0, r, nPk);
                ;
              }
              if( iSet>=0 ){
                sqlite3VdbeAddOp3(v, 92, r, nPk, regRowid);
                sqlite3VdbeAddOp4Int(v, 132, regRowset, regRowid,
                                     r, nPk);
                if( iSet ) sqlite3VdbeChangeP5(v, 0x10);
              }


              sqlite3ReleaseTempRange(pParse, r, nPk);
            }
          }


          sqlite3VdbeAddOp2(v, 12, regReturn, iLoopBody);



          if( jmp1 ) sqlite3VdbeJumpHere(v, jmp1);






          if( pSubWInfo->untestedTerms ) untestedTerms = 1;
# 139463 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          pSubLoop = pSubWInfo->a[0].pWLoop;
          ((void)0);
          if( (pSubLoop->wsFlags & 0x00000200)!=0
           && (ii==0 || pSubLoop->u.btree.pIndex==pCov)
           && ((((pTab)->tabFlags & 0x0020)==0) || !((pSubLoop->u.btree.pIndex)->idxType==2))
          ){
            ((void)0);
            pCov = pSubLoop->u.btree.pIndex;
          }else{
            pCov = 0;
          }


          sqlite3WhereEnd(pSubWInfo);
          sqlite3VdbeExplainPop(pParse);
        }
      }
    }
    sqlite3VdbeExplainPop(pParse);
    pLevel->u.pCovidx = pCov;
    if( pCov ) pLevel->iIdxCur = iCovCur;
    if( pAndExpr ){
      pAndExpr->pLeft = 0;
      sqlite3ExprDelete(db, pAndExpr);
    }
    sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeGoto(v, pLevel->addrBrk);
    sqlite3VdbeResolveLabel(v, iLoopBody);

    if( pWInfo->nLevel>1 ){ sqlite3DbFree(db,pOrTab); }
    if( !untestedTerms ) disableTerm(pLevel, pTerm);
  }else


  {



    static const u8 aStep[] = { 5, 4 };
    static const u8 aStart[] = { 36, 32 };
    ((void)0);
    if( pTabItem->fg.isRecursive ){


      pLevel->op = 170;
    }else{
      ;
      pLevel->op = aStep[bRev];
      pLevel->p1 = iCur;
      pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrHalt);
      ;
      ;
      pLevel->p5 = 1;
    }
  }
# 139537 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  iLoop = (pIdx ? 1 : 2);
  do{
    int iNext = 0;
    for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
      Expr *pE;
      int skipLikeAddr = 0;
      ;
      ;
      if( pTerm->wtFlags & (0x02|0x04) ) continue;
      if( (pTerm->prereqAll & pLevel->notReady)!=0 ){
       
                                                             ;
        pWInfo->untestedTerms = 1;
        continue;
      }
      pE = pTerm->pExpr;
      ((void)0);
      if( (pTabItem->fg.jointype&0x0008) && !(((pE)->flags&(0x000001))!=0) ){
        continue;
      }

      if( iLoop==1 && !sqlite3ExprCoveredByIndex(pE, pLevel->iTabCur, pIdx) ){
        iNext = 2;
        continue;
      }
      if( iLoop<3 && (pTerm->wtFlags & 0x1000) ){
        if( iNext==0 ) iNext = 3;
        continue;
      }

      if( (pTerm->wtFlags & 0x200)!=0 ){
# 139576 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        u32 x = pLevel->iLikeRepCntr;
        if( x>0 ){
          skipLikeAddr = sqlite3VdbeAddOp1(v, (x&1)?20:18,(int)(x>>1));
          ;
          ;
        }

      }






      sqlite3ExprIfFalse(pParse, pE, addrCont, 0x10);
      if( skipLikeAddr ) sqlite3VdbeJumpHere(v, skipLikeAddr);
      pTerm->wtFlags |= 0x04;
    }
    iLoop = iNext;
  }while( iLoop>0 );
# 139605 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){
    Expr *pE, sEAlt;
    WhereTerm *pAlt;
    if( pTerm->wtFlags & (0x02|0x04) ) continue;
    if( (pTerm->eOperator & (0x0002|0x0080))==0 ) continue;
    if( (pTerm->eOperator & 0x0800)==0 ) continue;
    if( pTerm->leftCursor!=iCur ) continue;
    if( pLevel->iLeftJoin ) continue;
    pE = pTerm->pExpr;
    ((void)0);
    ((void)0);
    pAlt = sqlite3WhereFindTerm(pWC, iCur, pTerm->u.leftColumn, notReady,
                    0x0002|0x0001|0x0080, 0);
    if( pAlt==0 ) continue;
    if( pAlt->wtFlags & (0x04) ) continue;
    if( (pAlt->eOperator & 0x0001)
     && (pAlt->pExpr->flags & 0x000800)
     && (pAlt->pExpr->x.pSelect->pEList->nExpr>1)
    ){
      continue;
    }
    ;
    ;
    ;
    ;
    sEAlt = *pAlt->pExpr;
    sEAlt.pLeft = pE->pLeft;
    sqlite3ExprIfFalse(pParse, &sEAlt, addrCont, 0x10);
  }




  if( pLevel->iLeftJoin ){
    pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);
    sqlite3VdbeAddOp2(v, 70, 1, pLevel->iLeftJoin);
    ;
    for(pTerm=pWC->a, j=0; j<pWC->nTerm; j++, pTerm++){
      ;
      ;
      if( pTerm->wtFlags & (0x02|0x04) ) continue;
      if( (pTerm->prereqAll & pLevel->notReady)!=0 ){
        ((void)0);
        continue;
      }
      ((void)0);
      sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, 0x10);
      pTerm->wtFlags |= 0x04;
    }
  }

  return pLevel->notReady;
}
# 139683 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void exprAnalyze(SrcList*, WhereClause*, int);




static void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){
  sqlite3WhereClauseClear(&p->wc);
  sqlite3DbFree(db, p);
}




static void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){
  sqlite3WhereClauseClear(&p->wc);
  sqlite3DbFree(db, p);
}
# 139720 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereClauseInsert(WhereClause *pWC, Expr *p, u16 wtFlags){
  WhereTerm *pTerm;
  int idx;
  ;
  if( pWC->nTerm>=pWC->nSlot ){
    WhereTerm *pOld = pWC->a;
    sqlite3 *db = pWC->pWInfo->pParse->db;
    pWC->a = sqlite3DbMallocRawNN(db, sizeof(pWC->a[0])*pWC->nSlot*2 );
    if( pWC->a==0 ){
      if( wtFlags & 0x01 ){
        sqlite3ExprDelete(db, p);
      }
      pWC->a = pOld;
      return 0;
    }
    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);
    if( pOld!=pWC->aStatic ){
      sqlite3DbFree(db, pOld);
    }
    pWC->nSlot = sqlite3DbMallocSize(db, pWC->a)/sizeof(pWC->a[0]);
  }
  pTerm = &pWC->a[idx = pWC->nTerm++];
  if( p && (((p)->flags&(0x040000))!=0) ){
    pTerm->truthProb = sqlite3LogEst(p->iTable) - 270;
  }else{
    pTerm->truthProb = 1;
  }
  pTerm->pExpr = sqlite3ExprSkipCollateAndLikely(p);
  pTerm->wtFlags = wtFlags;
  pTerm->pWC = pWC;
  pTerm->iParent = -1;
  memset(&pTerm->eOperator, 0,
         sizeof(WhereTerm) - __builtin_offsetof(WhereTerm,eOperator));
  return idx;
}






static int allowedOp(int op){
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  return op==49 || (op>=53 && op<=57) || op==50 || op==45;
}
# 139786 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static u16 exprCommute(Parse *pParse, Expr *pExpr){
  u16 expRight = (pExpr->pRight->flags & 0x000100);
  u16 expLeft = (pExpr->pLeft->flags & 0x000100);
  u16 wtFlags = 0;
  ((void)0);
  if( expRight==expLeft ){

    if( expRight ){


      pExpr->pRight->flags &= ~0x000100;
      wtFlags |= 0x2000;
    }else if( sqlite3ExprCollSeq(pParse, pExpr->pLeft)!=0 ){



      pExpr->pLeft->flags |= 0x000100;
      wtFlags |= 0x2000;
    }
  }
  {Expr* t=pExpr->pRight; pExpr->pRight=pExpr->pLeft; pExpr->pLeft=t;};
  if( pExpr->op>=54 ){
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    pExpr->op = ((pExpr->op-54)^2)+54;
  }
  return wtFlags;
}




static u16 operatorMask(int op){
  u16 c;
  ((void)0);
  if( op==49 ){
    c = 0x0001;
  }else if( op==50 ){
    c = 0x0100;
  }else if( op==45 ){
    c = 0x0080;
  }else{
    ((void)0);
    c = (u16)(0x0002<<(op-53));
  }
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  return c;
}
# 139859 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isLikeOrGlob(
  Parse *pParse,
  Expr *pExpr,
  Expr **ppPrefix,
  int *pisComplete,
  int *pnoCase
){
  const u8 *z = 0;
  Expr *pRight, *pLeft;
  ExprList *pList;
  u8 c;
  int cnt;
  u8 wc[4];
  sqlite3 *db = pParse->db;
  sqlite3_value *pVal = 0;
  int op;
  int rc;

  if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, (char*)wc) ){
    return 0;
  }



  pList = pExpr->x.pList;
  pLeft = pList->a[1].pExpr;

  pRight = sqlite3ExprSkipCollate(pList->a[0].pExpr);
  op = pRight->op;
  if( op==151 && (db->flags & 0x00800000)==0 ){
    Vdbe *pReprepare = pParse->pReprepare;
    int iCol = pRight->iColumn;
    pVal = sqlite3VdbeGetBoundValue(pReprepare, iCol, 0x41);
    if( pVal && sqlite3_value_type(pVal)==3 ){
      z = sqlite3_value_text(pVal);
    }
    sqlite3VdbeSetVarmask(pParse->pVdbe, iCol);
    ((void)0);
  }else if( op==113 ){
    z = (u8*)pRight->u.zToken;
  }
  if( z ){


    cnt = 0;
    while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){
      cnt++;
      if( c==wc[3] && z[cnt]!=0 ) cnt++;
    }
# 139917 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( cnt!=0 && 255!=(u8)z[cnt-1] && (cnt>1 || z[0]!=wc[3]) ){
      Expr *pPrefix;


      *pisComplete = c==wc[0] && z[cnt+1]==0;


      pPrefix = sqlite3Expr(db, 113, (char*)z);
      if( pPrefix ){
        int iFrom, iTo;
        char *zNew = pPrefix->u.zToken;
        zNew[cnt] = 0;
        for(iFrom=iTo=0; iFrom<cnt; iFrom++){
          if( zNew[iFrom]==wc[3] ) iFrom++;
          zNew[iTo++] = zNew[iFrom];
        }
        zNew[iTo] = 0;
        ((void)0);
# 139949 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        if( pLeft->op!=162
         || sqlite3ExprAffinity(pLeft)!=0x42
         || ((pLeft->y.pTab)->nModuleArg)
        ){
          int isNum;
          double rDummy;
          isNum = sqlite3AtoF(zNew, &rDummy, iTo, 1);
          if( isNum<=0 ){
            if( iTo==1 && zNew[0]=='-' ){
              isNum = +1;
            }else{
              zNew[iTo-1]++;
              isNum = sqlite3AtoF(zNew, &rDummy, iTo, 1);
              zNew[iTo-1]--;
            }
          }
          if( isNum>0 ){
            sqlite3ExprDelete(db, pPrefix);
            sqlite3ValueFree(pVal);
            return 0;
          }
        }
      }
      *ppPrefix = pPrefix;



      if( op==151 ){
        Vdbe *v = pParse->pVdbe;
        sqlite3VdbeSetVarmask(v, pRight->iColumn);
        if( *pisComplete && pRight->u.zToken[1] ){






          int r1 = sqlite3GetTempReg(pParse);
          sqlite3ExprCodeTarget(pParse, pRight, r1);
          sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0);
          sqlite3ReleaseTempReg(pParse, r1);
        }
      }
    }else{
      z = 0;
    }
  }

  rc = (z!=0);
  sqlite3ValueFree(pVal);
  return rc;
}
# 140031 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isAuxiliaryVtabOperator(
  sqlite3 *db,
  Expr *pExpr,
  unsigned char *peOp2,
  Expr **ppLeft,
  Expr **ppRight
){
  if( pExpr->op==167 ){
    static const struct Op2 {
      const char *zOp;
      unsigned char eOp2;
    } aOp[] = {
      { "match", 64 },
      { "glob", 66 },
      { "like", 65 },
      { "regexp", 67 }
    };
    ExprList *pList;
    Expr *pCol;
    int i;

    pList = pExpr->x.pList;
    if( pList==0 || pList->nExpr!=2 ){
      return 0;
    }
# 140064 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pCol = pList->a[1].pExpr;
    if( pCol->op==162 && ((pCol->y.pTab)->nModuleArg) ){
      for(i=0; i<((int)(sizeof(aOp)/sizeof(aOp[0]))); i++){
        if( sqlite3StrICmp(pExpr->u.zToken, aOp[i].zOp)==0 ){
          *peOp2 = aOp[i].eOp2;
          *ppRight = pList->a[0].pExpr;
          *ppLeft = pCol;
          return 1;
        }
      }
    }
# 140086 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pCol = pList->a[0].pExpr;
    if( pCol->op==162 && ((pCol->y.pTab)->nModuleArg) ){
      sqlite3_vtab *pVtab;
      sqlite3_module *pMod;
      void (*xNotUsed)(sqlite3_context*,int,sqlite3_value**);
      void *pNotUsed;
      pVtab = sqlite3GetVTable(db, pCol->y.pTab)->pVtab;
      ((void)0);
      ((void)0);
      pMod = (sqlite3_module *)pVtab->pModule;
      if( pMod->xFindFunction!=0 ){
        i = pMod->xFindFunction(pVtab,2, pExpr->u.zToken, &xNotUsed, &pNotUsed);
        if( i>=150 ){
          *peOp2 = i;
          *ppRight = pList->a[1].pExpr;
          *ppLeft = pCol;
          return 1;
        }
      }
    }
  }else if( pExpr->op==52 || pExpr->op==166 || pExpr->op==51 ){
    int res = 0;
    Expr *pLeft = pExpr->pLeft;
    Expr *pRight = pExpr->pRight;
    if( pLeft->op==162 && ((pLeft->y.pTab)->nModuleArg) ){
      res++;
    }
    if( pRight && pRight->op==162 && ((pRight->y.pTab)->nModuleArg) ){
      res++;
      {Expr* t=pLeft; pLeft=pRight; pRight=t;};
    }
    *ppLeft = pLeft;
    *ppRight = pRight;
    if( pExpr->op==52 ) *peOp2 = 68;
    if( pExpr->op==166 ) *peOp2 = 69;
    if( pExpr->op==51 ) *peOp2 = 70;
    return res;
  }
  return 0;
}






static void transferJoinMarkings(Expr *pDerived, Expr *pBase){
  if( pDerived ){
    pDerived->flags |= pBase->flags & 0x000001;
    pDerived->iRightJoinTable = pBase->iRightJoinTable;
  }
}




static void markTermAsChild(WhereClause *pWC, int iChild, int iParent){
  pWC->a[iChild].iParent = iParent;
  pWC->a[iChild].truthProb = pWC->a[iParent].truthProb;
  pWC->a[iParent].nChild++;
}






static WhereTerm *whereNthSubterm(WhereTerm *pTerm, int N){
  if( pTerm->eOperator!=0x0400 ){
    return N==0 ? pTerm : 0;
  }
  if( N<pTerm->u.pAndInfo->wc.nTerm ){
    return &pTerm->u.pAndInfo->wc.a[N];
  }
  return 0;
}
# 140183 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void whereCombineDisjuncts(
  SrcList *pSrc,
  WhereClause *pWC,
  WhereTerm *pOne,
  WhereTerm *pTwo
){
  u16 eOp = pOne->eOperator | pTwo->eOperator;
  sqlite3 *db;
  Expr *pNew;
  int op;
  int idxNew;

  if( (pOne->eOperator & (0x0002|(0x0002<<(56 -53))|(0x0002<<(55 -53))|(0x0002<<(54 -53))|(0x0002<<(57 -53))))==0 ) return;
  if( (pTwo->eOperator & (0x0002|(0x0002<<(56 -53))|(0x0002<<(55 -53))|(0x0002<<(54 -53))|(0x0002<<(57 -53))))==0 ) return;
  if( (eOp & (0x0002|(0x0002<<(56 -53))|(0x0002<<(55 -53))))!=eOp
   && (eOp & (0x0002|(0x0002<<(54 -53))|(0x0002<<(57 -53))))!=eOp ) return;
  ((void)0);
  ((void)0);
  if( sqlite3ExprCompare(0,pOne->pExpr->pLeft, pTwo->pExpr->pLeft, -1) ) return;
  if( sqlite3ExprCompare(0,pOne->pExpr->pRight, pTwo->pExpr->pRight,-1) )return;

  if( (eOp & (eOp-1))!=0 ){
    if( eOp & ((0x0002<<(56 -53))|(0x0002<<(55 -53))) ){
      eOp = (0x0002<<(55 -53));
    }else{
      ((void)0);
      eOp = (0x0002<<(57 -53));
    }
  }
  db = pWC->pWInfo->pParse->db;
  pNew = sqlite3ExprDup(db, pOne->pExpr, 0);
  if( pNew==0 ) return;
  for(op=53; eOp!=(0x0002<<(op-53)); op++){ ((void)0); }
  pNew->op = op;
  idxNew = whereClauseInsert(pWC, pNew, 0x02|0x01);
  exprAnalyze(pSrc, pWC, idxNew);
}
# 140309 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void exprAnalyzeOrTerm(
  SrcList *pSrc,
  WhereClause *pWC,
  int idxTerm
){
  WhereInfo *pWInfo = pWC->pWInfo;
  Parse *pParse = pWInfo->pParse;
  sqlite3 *db = pParse->db;
  WhereTerm *pTerm = &pWC->a[idxTerm];
  Expr *pExpr = pTerm->pExpr;
  int i;
  WhereClause *pOrWc;
  WhereTerm *pOrTerm;
  WhereOrInfo *pOrInfo;
  Bitmask chngToIN;
  Bitmask indexable;






  ((void)0);
  ((void)0);
  pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));
  if( pOrInfo==0 ) return;
  pTerm->wtFlags |= 0x10;
  pOrWc = &pOrInfo->wc;
  memset(pOrWc->aStatic, 0, sizeof(pOrWc->aStatic));
  sqlite3WhereClauseInit(pOrWc, pWInfo);
  sqlite3WhereSplit(pOrWc, pExpr, 43);
  sqlite3WhereExprAnalyze(pSrc, pOrWc);
  if( db->mallocFailed ) return;
  ((void)0);




  indexable = ~(Bitmask)0;
  chngToIN = ~(Bitmask)0;
  for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){
    if( (pOrTerm->eOperator & 0x01ff)==0 ){
      WhereAndInfo *pAndInfo;
      ((void)0);
      chngToIN = 0;
      pAndInfo = sqlite3DbMallocRawNN(db, sizeof(*pAndInfo));
      if( pAndInfo ){
        WhereClause *pAndWC;
        WhereTerm *pAndTerm;
        int j;
        Bitmask b = 0;
        pOrTerm->u.pAndInfo = pAndInfo;
        pOrTerm->wtFlags |= 0x20;
        pOrTerm->eOperator = 0x0400;
        pAndWC = &pAndInfo->wc;
        memset(pAndWC->aStatic, 0, sizeof(pAndWC->aStatic));
        sqlite3WhereClauseInit(pAndWC, pWC->pWInfo);
        sqlite3WhereSplit(pAndWC, pOrTerm->pExpr, 44);
        sqlite3WhereExprAnalyze(pSrc, pAndWC);
        pAndWC->pOuter = pWC;
        if( !db->mallocFailed ){
          for(j=0, pAndTerm=pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++){
            ((void)0);
            if( allowedOp(pAndTerm->pExpr->op)
             || pAndTerm->eOperator==0x0040
            ){
              b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pAndTerm->leftCursor);
            }
          }
        }
        indexable &= b;
      }
    }else if( pOrTerm->wtFlags & 0x08 ){


    }else{
      Bitmask b;
      b = sqlite3WhereGetMask(&pWInfo->sMaskSet, pOrTerm->leftCursor);
      if( pOrTerm->wtFlags & 0x02 ){
        WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];
        b |= sqlite3WhereGetMask(&pWInfo->sMaskSet, pOther->leftCursor);
      }
      indexable &= b;
      if( (pOrTerm->eOperator & 0x0002)==0 ){
        chngToIN = 0;
      }else{
        chngToIN &= b;
      }
    }
  }





  pOrInfo->indexable = indexable;
  if( indexable ){
    pTerm->eOperator = 0x0200;
    pWC->hasOr = 1;
  }else{
    pTerm->eOperator = 0x0200;
  }



  if( indexable && pOrWc->nTerm==2 ){
    int iOne = 0;
    WhereTerm *pOne;
    while( (pOne = whereNthSubterm(&pOrWc->a[0],iOne++))!=0 ){
      int iTwo = 0;
      WhereTerm *pTwo;
      while( (pTwo = whereNthSubterm(&pOrWc->a[1],iTwo++))!=0 ){
        whereCombineDisjuncts(pSrc, pWC, pOne, pTwo);
      }
    }
  }
# 140447 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( chngToIN ){
    int okToChngToIN = 0;
    int iColumn = -1;
    int iCursor = -1;
    int j = 0;







    for(j=0; j<2 && !okToChngToIN; j++){
      Expr *pLeft = 0;
      pOrTerm = pOrWc->a;
      for(i=pOrWc->nTerm-1; i>=0; i--, pOrTerm++){
        ((void)0);
        pOrTerm->wtFlags &= ~0x40;
        if( pOrTerm->leftCursor==iCursor ){


          ((void)0);
          continue;
        }
        if( (chngToIN & sqlite3WhereGetMask(&pWInfo->sMaskSet,
                                            pOrTerm->leftCursor))==0 ){




          ;
          ;
          ((void)0);
          continue;
        }
        iColumn = pOrTerm->u.leftColumn;
        iCursor = pOrTerm->leftCursor;
        pLeft = pOrTerm->pExpr->pLeft;
        break;
      }
      if( i<0 ){


        ((void)0);
        ((void)0);
        ((void)0);
        break;
      }
      ;



      okToChngToIN = 1;
      for(; i>=0 && okToChngToIN; i--, pOrTerm++){
        ((void)0);
        if( pOrTerm->leftCursor!=iCursor ){
          pOrTerm->wtFlags &= ~0x40;
        }else if( pOrTerm->u.leftColumn!=iColumn || (iColumn==(-2)
               && sqlite3ExprCompare(pParse, pOrTerm->pExpr->pLeft, pLeft, -1)
        )){
          okToChngToIN = 0;
        }else{
          int affLeft, affRight;




          affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);
          affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);
          if( affRight!=0 && affRight!=affLeft ){
            okToChngToIN = 0;
          }else{
            pOrTerm->wtFlags |= 0x40;
          }
        }
      }
    }





    if( okToChngToIN ){
      Expr *pDup;
      ExprList *pList = 0;
      Expr *pLeft = 0;
      Expr *pNew;

      for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){
        if( (pOrTerm->wtFlags & 0x40)==0 ) continue;
        ((void)0);
        ((void)0);
        ((void)0);
        pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);
        pList = sqlite3ExprListAppend(pWInfo->pParse, pList, pDup);
        pLeft = pOrTerm->pExpr->pLeft;
      }
      ((void)0);
      pDup = sqlite3ExprDup(db, pLeft, 0);
      pNew = sqlite3PExpr(pParse, 49, pDup, 0);
      if( pNew ){
        int idxNew;
        transferJoinMarkings(pNew, pExpr);
        ((void)0);
        pNew->x.pList = pList;
        idxNew = whereClauseInsert(pWC, pNew, 0x02|0x01);
        ;
        exprAnalyze(pSrc, pWC, idxNew);

        markTermAsChild(pWC, idxNew, idxTerm);
      }else{
        sqlite3ExprListDelete(db, pList);
      }
    }
  }
}
# 140580 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int termIsEquivalence(Parse *pParse, Expr *pExpr){
  char aff1, aff2;
  CollSeq *pColl;
  if( !(((pParse->db)->dbOptFlags&(0x0080))==0) ) return 0;
  if( pExpr->op!=53 && pExpr->op!=45 ) return 0;
  if( (((pExpr)->flags&(0x000001))!=0) ) return 0;
  aff1 = sqlite3ExprAffinity(pExpr->pLeft);
  aff2 = sqlite3ExprAffinity(pExpr->pRight);
  if( aff1!=aff2
   && (!((aff1)>=0x43) || !((aff2)>=0x43))
  ){
    return 0;
  }
  pColl = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft, pExpr->pRight);
  if( sqlite3IsBinary(pColl) ) return 1;
  return sqlite3ExprCollSeqMatch(pParse, pExpr->pLeft, pExpr->pRight);
}






static Bitmask exprSelectUsage(WhereMaskSet *pMaskSet, Select *pS){
  Bitmask mask = 0;
  while( pS ){
    SrcList *pSrc = pS->pSrc;
    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pEList);
    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pGroupBy);
    mask |= sqlite3WhereExprListUsage(pMaskSet, pS->pOrderBy);
    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pWhere);
    mask |= sqlite3WhereExprUsage(pMaskSet, pS->pHaving);
    if( (pSrc!=0) ){
      int i;
      for(i=0; i<pSrc->nSrc; i++){
        mask |= exprSelectUsage(pMaskSet, pSrc->a[i].pSelect);
        mask |= sqlite3WhereExprUsage(pMaskSet, pSrc->a[i].pOn);
        if( pSrc->a[i].fg.isTabFunc ){
          mask |= sqlite3WhereExprListUsage(pMaskSet, pSrc->a[i].u1.pFuncArg);
        }
      }
    }
    pS = pS->pPrior;
  }
  return mask;
}
# 140640 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static __attribute__((noinline)) int exprMightBeIndexed2(
  SrcList *pFrom,
  Bitmask mPrereq,
  int *aiCurCol,
  Expr *pExpr
){
  Index *pIdx;
  int i;
  int iCur;
  for(i=0; mPrereq>1; i++, mPrereq>>=1){}
  iCur = pFrom->a[i].iCursor;
  for(pIdx=pFrom->a[i].pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    if( pIdx->aColExpr==0 ) continue;
    for(i=0; i<pIdx->nKeyCol; i++){
      if( pIdx->aiColumn[i]!=(-2) ) continue;
      if( sqlite3ExprCompareSkip(pExpr, pIdx->aColExpr->a[i].pExpr, iCur)==0 ){
        aiCurCol[0] = iCur;
        aiCurCol[1] = (-2);
        return 1;
      }
    }
  }
  return 0;
}
static int exprMightBeIndexed(
  SrcList *pFrom,
  Bitmask mPrereq,
  int *aiCurCol,
  Expr *pExpr,
  int op
){



  ((void)0);
  ((void)0);
  ((void)0);
  if( pExpr->op==172 && (op>=54 && (op<=57)) ){
    pExpr = pExpr->x.pList->a[0].pExpr;
  }

  if( pExpr->op==162 ){
    aiCurCol[0] = pExpr->iTable;
    aiCurCol[1] = pExpr->iColumn;
    return 1;
  }
  if( mPrereq==0 ) return 0;
  if( (mPrereq&(mPrereq-1))!=0 ) return 0;
  return exprMightBeIndexed2(pFrom,mPrereq,aiCurCol,pExpr);
}
# 140709 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void exprAnalyze(
  SrcList *pSrc,
  WhereClause *pWC,
  int idxTerm
){
  WhereInfo *pWInfo = pWC->pWInfo;
  WhereTerm *pTerm;
  WhereMaskSet *pMaskSet;
  Expr *pExpr;
  Bitmask prereqLeft;
  Bitmask prereqAll;
  Bitmask extraRight = 0;
  Expr *pStr1 = 0;
  int isComplete = 0;
  int noCase = 0;
  int op;
  Parse *pParse = pWInfo->pParse;
  sqlite3 *db = pParse->db;
  unsigned char eOp2 = 0;
  int nLeft;

  if( db->mallocFailed ){
    return;
  }
  pTerm = &pWC->a[idxTerm];
  pMaskSet = &pWInfo->sMaskSet;
  pExpr = pTerm->pExpr;
  ((void)0);
  prereqLeft = sqlite3WhereExprUsage(pMaskSet, pExpr->pLeft);
  op = pExpr->op;
  if( op==49 ){
    ((void)0);
    if( sqlite3ExprCheckIN(pParse, pExpr) ) return;
    if( (((pExpr)->flags&(0x000800))!=0) ){
      pTerm->prereqRight = exprSelectUsage(pMaskSet, pExpr->x.pSelect);
    }else{
      pTerm->prereqRight = sqlite3WhereExprListUsage(pMaskSet, pExpr->x.pList);
    }
  }else if( op==50 ){
    pTerm->prereqRight = 0;
  }else{
    pTerm->prereqRight = sqlite3WhereExprUsage(pMaskSet, pExpr->pRight);
  }
  pMaskSet->bVarSelect = 0;
  prereqAll = sqlite3WhereExprUsageNN(pMaskSet, pExpr);
  if( pMaskSet->bVarSelect ) pTerm->wtFlags |= 0x1000;
  if( (((pExpr)->flags&(0x000001))!=0) ){
    Bitmask x = sqlite3WhereGetMask(pMaskSet, pExpr->iRightJoinTable);
    prereqAll |= x;
    extraRight = x-1;

    if( (prereqAll>>1)>=x ){
      sqlite3ErrorMsg(pParse, "ON clause references tables to its right");
      return;
    }
  }
  pTerm->prereqAll = prereqAll;
  pTerm->leftCursor = -1;
  pTerm->iParent = -1;
  pTerm->eOperator = 0;
  if( allowedOp(op) ){
    int aiCurCol[2];
    Expr *pLeft = sqlite3ExprSkipCollate(pExpr->pLeft);
    Expr *pRight = sqlite3ExprSkipCollate(pExpr->pRight);
    u16 opMask = (pTerm->prereqRight & prereqLeft)==0 ? 0x1fff : 0x0800;

    if( pTerm->iField>0 ){
      ((void)0);
      ((void)0);
      pLeft = pLeft->x.pList->a[pTerm->iField-1].pExpr;
    }

    if( exprMightBeIndexed(pSrc, prereqLeft, aiCurCol, pLeft, op) ){
      pTerm->leftCursor = aiCurCol[0];
      pTerm->u.leftColumn = aiCurCol[1];
      pTerm->eOperator = operatorMask(op) & opMask;
    }
    if( op==45 ) pTerm->wtFlags |= 0x800;
    if( pRight
     && exprMightBeIndexed(pSrc, pTerm->prereqRight, aiCurCol, pRight, op)
    ){
      WhereTerm *pNew;
      Expr *pDup;
      u16 eExtraOp = 0;
      ((void)0);
      if( pTerm->leftCursor>=0 ){
        int idxNew;
        pDup = sqlite3ExprDup(db, pExpr, 0);
        if( db->mallocFailed ){
          sqlite3ExprDelete(db, pDup);
          return;
        }
        idxNew = whereClauseInsert(pWC, pDup, 0x02|0x01);
        if( idxNew==0 ) return;
        pNew = &pWC->a[idxNew];
        markTermAsChild(pWC, idxNew, idxTerm);
        if( op==45 ) pNew->wtFlags |= 0x800;
        pTerm = &pWC->a[idxTerm];
        pTerm->wtFlags |= 0x08;

        if( termIsEquivalence(pParse, pDup) ){
          pTerm->eOperator |= 0x0800;
          eExtraOp = 0x0800;
        }
      }else{
        pDup = pExpr;
        pNew = pTerm;
      }
      pNew->wtFlags |= exprCommute(pParse, pDup);
      pNew->leftCursor = aiCurCol[0];
      pNew->u.leftColumn = aiCurCol[1];
      ;
      pNew->prereqRight = prereqLeft | extraRight;
      pNew->prereqAll = prereqAll;
      pNew->eOperator = (operatorMask(pDup->op) + eExtraOp) & opMask;
    }
  }
# 140843 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  else if( pExpr->op==48 && pWC->op==44 ){
    ExprList *pList = pExpr->x.pList;
    int i;
    static const u8 ops[] = {57, 55};
    ((void)0);
    ((void)0);
    for(i=0; i<2; i++){
      Expr *pNewExpr;
      int idxNew;
      pNewExpr = sqlite3PExpr(pParse, ops[i],
                             sqlite3ExprDup(db, pExpr->pLeft, 0),
                             sqlite3ExprDup(db, pList->a[i].pExpr, 0));
      transferJoinMarkings(pNewExpr, pExpr);
      idxNew = whereClauseInsert(pWC, pNewExpr, 0x02|0x01);
      ;
      exprAnalyze(pSrc, pWC, idxNew);
      pTerm = &pWC->a[idxTerm];
      markTermAsChild(pWC, idxNew, idxTerm);
    }
  }






  else if( pExpr->op==43 ){
    ((void)0);
    exprAnalyzeOrTerm(pSrc, pWC, idxTerm);
    pTerm = &pWC->a[idxTerm];
  }
# 140890 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pWC->op==44
   && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)
  ){
    Expr *pLeft;
    Expr *pStr2;
    Expr *pNewExpr1;
    Expr *pNewExpr2;
    int idxNew1;
    int idxNew2;
    const char *zCollSeqName;
    const u16 wtFlags = 0x100 | 0x02 | 0x01;

    pLeft = pExpr->x.pList->a[1].pExpr;
    pStr2 = sqlite3ExprDup(db, pStr1, 0);





    if( noCase && !pParse->db->mallocFailed ){
      int i;
      char c;
      pTerm->wtFlags |= 0x400;
      for(i=0; (c = pStr1->u.zToken[i])!=0; i++){
        pStr1->u.zToken[i] = ((c)&~(sqlite3CtypeMap[(unsigned char)(c)]&0x20));
        pStr2->u.zToken[i] = (sqlite3UpperToLower[(unsigned char)(c)]);
      }
    }

    if( !db->mallocFailed ){
      u8 c, *pC;
      pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];
      c = *pC;
      if( noCase ){






        if( c=='A'-1 ) isComplete = 0;
        c = sqlite3UpperToLower[c];
      }
      *pC = c + 1;
    }
    zCollSeqName = noCase ? "NOCASE" : sqlite3StrBINARY;
    pNewExpr1 = sqlite3ExprDup(db, pLeft, 0);
    pNewExpr1 = sqlite3PExpr(pParse, 57,
           sqlite3ExprAddCollateString(pParse,pNewExpr1,zCollSeqName),
           pStr1);
    transferJoinMarkings(pNewExpr1, pExpr);
    idxNew1 = whereClauseInsert(pWC, pNewExpr1, wtFlags);
    ;
    exprAnalyze(pSrc, pWC, idxNew1);
    pNewExpr2 = sqlite3ExprDup(db, pLeft, 0);
    pNewExpr2 = sqlite3PExpr(pParse, 56,
           sqlite3ExprAddCollateString(pParse,pNewExpr2,zCollSeqName),
           pStr2);
    transferJoinMarkings(pNewExpr2, pExpr);
    idxNew2 = whereClauseInsert(pWC, pNewExpr2, wtFlags);
    ;
    exprAnalyze(pSrc, pWC, idxNew2);
    pTerm = &pWC->a[idxTerm];
    if( isComplete ){
      markTermAsChild(pWC, idxNew1, idxTerm);
      markTermAsChild(pWC, idxNew2, idxTerm);
    }
  }
# 140970 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pWC->op==44 ){
    Expr *pRight = 0, *pLeft = 0;
    int res = isAuxiliaryVtabOperator(db, pExpr, &eOp2, &pLeft, &pRight);
    while( res-- > 0 ){
      int idxNew;
      WhereTerm *pNewTerm;
      Bitmask prereqColumn, prereqExpr;

      prereqExpr = sqlite3WhereExprUsage(pMaskSet, pRight);
      prereqColumn = sqlite3WhereExprUsage(pMaskSet, pLeft);
      if( (prereqExpr & prereqColumn)==0 ){
        Expr *pNewExpr;
        pNewExpr = sqlite3PExpr(pParse, 46,
            0, sqlite3ExprDup(db, pRight, 0));
        if( (((pExpr)->flags&(0x000001))!=0) && pNewExpr ){
          (pNewExpr)->flags|=(0x000001);
        }
        idxNew = whereClauseInsert(pWC, pNewExpr, 0x02|0x01);
        ;
        pNewTerm = &pWC->a[idxNew];
        pNewTerm->prereqRight = prereqExpr;
        pNewTerm->leftCursor = pLeft->iTable;
        pNewTerm->u.leftColumn = pLeft->iColumn;
        pNewTerm->eOperator = 0x0040;
        pNewTerm->eMatchOp = eOp2;
        markTermAsChild(pWC, idxNew, idxTerm);
        pTerm = &pWC->a[idxTerm];
        pTerm->wtFlags |= 0x08;
        pNewTerm->prereqAll = pTerm->prereqAll;
      }
      {Expr* t=pLeft; pLeft=pRight; pRight=t;};
    }
  }
# 141012 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pWC->op==44
  && (pExpr->op==53 || pExpr->op==45)
  && (nLeft = sqlite3ExprVectorSize(pExpr->pLeft))>1
  && sqlite3ExprVectorSize(pExpr->pRight)==nLeft
  && ( (pExpr->pLeft->flags & 0x000800)==0
    || (pExpr->pRight->flags & 0x000800)==0)
  ){
    int i;
    for(i=0; i<nLeft; i++){
      int idxNew;
      Expr *pNew;
      Expr *pLeft = sqlite3ExprForVectorField(pParse, pExpr->pLeft, i);
      Expr *pRight = sqlite3ExprForVectorField(pParse, pExpr->pRight, i);

      pNew = sqlite3PExpr(pParse, pExpr->op, pLeft, pRight);
      transferJoinMarkings(pNew, pExpr);
      idxNew = whereClauseInsert(pWC, pNew, 0x01);
      exprAnalyze(pSrc, pWC, idxNew);
    }
    pTerm = &pWC->a[idxTerm];
    pTerm->wtFlags |= 0x04|0x02;
    pTerm->eOperator = 0;
  }
# 141044 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pWC->op==44 && pExpr->op==49 && pTerm->iField==0
   && pExpr->pLeft->op==172
   && pExpr->x.pSelect->pPrior==0
  ){
    int i;
    for(i=0; i<sqlite3ExprVectorSize(pExpr->pLeft); i++){
      int idxNew;
      idxNew = whereClauseInsert(pWC, pExpr, 0x02);
      pWC->a[idxNew].iField = i+1;
      exprAnalyze(pSrc, pWC, idxNew);
      markTermAsChild(pWC, idxNew, idxTerm);
    }
  }
# 141100 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ;
  pTerm = &pWC->a[idxTerm];
  pTerm->prereqRight |= extraRight;
}
# 141127 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WhereSplit(WhereClause *pWC, Expr *pExpr, u8 op){
  Expr *pE2 = sqlite3ExprSkipCollateAndLikely(pExpr);
  pWC->op = op;
  if( pE2==0 ) return;
  if( pE2->op!=op ){
    whereClauseInsert(pWC, pExpr, 0);
  }else{
    sqlite3WhereSplit(pWC, pE2->pLeft, op);
    sqlite3WhereSplit(pWC, pE2->pRight, op);
  }
}




static void sqlite3WhereClauseInit(
  WhereClause *pWC,
  WhereInfo *pWInfo
){
  pWC->pWInfo = pWInfo;
  pWC->hasOr = 0;
  pWC->pOuter = 0;
  pWC->nTerm = 0;
  pWC->nSlot = ((int)(sizeof(pWC->aStatic)/sizeof(pWC->aStatic[0])));
  pWC->a = pWC->aStatic;
}






static void sqlite3WhereClauseClear(WhereClause *pWC){
  int i;
  WhereTerm *a;
  sqlite3 *db = pWC->pWInfo->pParse->db;
  for(i=pWC->nTerm-1, a=pWC->a; i>=0; i--, a++){
    if( a->wtFlags & 0x01 ){
      sqlite3ExprDelete(db, a->pExpr);
    }
    if( a->wtFlags & 0x10 ){
      whereOrInfoDelete(db, a->u.pOrInfo);
    }else if( a->wtFlags & 0x20 ){
      whereAndInfoDelete(db, a->u.pAndInfo);
    }
  }
  if( pWC->a!=pWC->aStatic ){
    sqlite3DbFree(db, pWC->a);
  }
}







static Bitmask sqlite3WhereExprUsageNN(WhereMaskSet *pMaskSet, Expr *p){
  Bitmask mask;
  if( p->op==162 && !(((p)->flags&(0x000008))!=0) ){
    return sqlite3WhereGetMask(pMaskSet, p->iTable);
  }else if( (((p)->flags&(0x004000|0x800000))!=0) ){
    ((void)0);
    return 0;
  }
  mask = (p->op==174) ? sqlite3WhereGetMask(pMaskSet, p->iTable) : 0;
  if( p->pLeft ) mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pLeft);
  if( p->pRight ){
    mask |= sqlite3WhereExprUsageNN(pMaskSet, p->pRight);
    ((void)0);
  }else if( (((p)->flags&(0x000800))!=0) ){
    if( (((p)->flags&(0x000020))!=0) ) pMaskSet->bVarSelect = 1;
    mask |= exprSelectUsage(pMaskSet, p->x.pSelect);
  }else if( p->x.pList ){
    mask |= sqlite3WhereExprListUsage(pMaskSet, p->x.pList);
  }

  if( p->op==167 && p->y.pWin ){
    mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pPartition);
    mask |= sqlite3WhereExprListUsage(pMaskSet, p->y.pWin->pOrderBy);
  }

  return mask;
}
static Bitmask sqlite3WhereExprUsage(WhereMaskSet *pMaskSet, Expr *p){
  return p ? sqlite3WhereExprUsageNN(pMaskSet,p) : 0;
}
static Bitmask sqlite3WhereExprListUsage(WhereMaskSet *pMaskSet, ExprList *pList){
  int i;
  Bitmask mask = 0;
  if( pList ){
    for(i=0; i<pList->nExpr; i++){
      mask |= sqlite3WhereExprUsage(pMaskSet, pList->a[i].pExpr);
    }
  }
  return mask;
}
# 141234 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WhereExprAnalyze(
  SrcList *pTabList,
  WhereClause *pWC
){
  int i;
  for(i=pWC->nTerm-1; i>=0; i--){
    exprAnalyze(pTabList, pWC, i);
  }
}
# 141251 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WhereTabFuncArgs(
  Parse *pParse,
  struct SrcList_item *pItem,
  WhereClause *pWC
){
  Table *pTab;
  int j, k;
  ExprList *pArgs;
  Expr *pColRef;
  Expr *pTerm;
  if( pItem->fg.isTabFunc==0 ) return;
  pTab = pItem->pTab;
  ((void)0);
  pArgs = pItem->u1.pFuncArg;
  if( pArgs==0 ) return;
  for(j=k=0; j<pArgs->nExpr; j++){
    Expr *pRhs;
    while( k<pTab->nCol && (pTab->aCol[k].colFlags & 0x0002)==0 ){k++;}
    if( k>=pTab->nCol ){
      sqlite3ErrorMsg(pParse, "too many arguments on %s() - max %d",
                      pTab->zName, j);
      return;
    }
    pColRef = sqlite3ExprAlloc(pParse->db, 162, 0, 0);
    if( pColRef==0 ) return;
    pColRef->iTable = pItem->iCursor;
    pColRef->iColumn = k++;
    pColRef->y.pTab = pTab;
    pRhs = sqlite3PExpr(pParse, 169,
        sqlite3ExprDup(pParse->db, pArgs->a[j].pExpr, 0), 0);
    pTerm = sqlite3PExpr(pParse, 53, pColRef, pRhs);
    whereClauseInsert(pWC, pTerm, 0x01);
  }
}
# 141318 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
typedef struct HiddenIndexInfo HiddenIndexInfo;
struct HiddenIndexInfo {
  WhereClause *pWC;
  Parse *pParse;
};


static int whereLoopResize(sqlite3*, WhereLoop*, int);
# 141336 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static LogEst sqlite3WhereOutputRowCount(WhereInfo *pWInfo){
  return pWInfo->nRowOut;
}





static int sqlite3WhereIsDistinct(WhereInfo *pWInfo){
  return pWInfo->eDistinct;
}





static int sqlite3WhereIsOrdered(WhereInfo *pWInfo){
  return pWInfo->nOBSat;
}
# 141379 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WhereOrderByLimitOptLabel(WhereInfo *pWInfo){
  WhereLevel *pInner;
  if( !pWInfo->bOrderedInnerLoop ){


    return pWInfo->iContinue;
  }
  pInner = &pWInfo->a[pWInfo->nLevel-1];
  ((void)0);
  return pInner->addrNxt;
}





static int sqlite3WhereContinueLabel(WhereInfo *pWInfo){
  ((void)0);
  return pWInfo->iContinue;
}





static int sqlite3WhereBreakLabel(WhereInfo *pWInfo){
  return pWInfo->iBreak;
}
# 141425 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WhereOkOnePass(WhereInfo *pWInfo, int *aiCur){
  memcpy(aiCur, pWInfo->aiCurOnePass, sizeof(int)*2);







  return pWInfo->eOnePass;
}




static void whereOrMove(WhereOrSet *pDest, WhereOrSet *pSrc){
  pDest->n = pSrc->n;
  memcpy(pDest->a, pSrc->a, pDest->n*sizeof(pDest->a[0]));
}
# 141452 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereOrInsert(
  WhereOrSet *pSet,
  Bitmask prereq,
  LogEst rRun,
  LogEst nOut
){
  u16 i;
  WhereOrCost *p;
  for(i=pSet->n, p=pSet->a; i>0; i--, p++){
    if( rRun<=p->rRun && (prereq & p->prereq)==prereq ){
      goto whereOrInsert_done;
    }
    if( p->rRun<=rRun && (p->prereq & prereq)==p->prereq ){
      return 0;
    }
  }
  if( pSet->n<3 ){
    p = &pSet->a[pSet->n++];
    p->nOut = nOut;
  }else{
    p = pSet->a;
    for(i=1; i<pSet->n; i++){
      if( p->rRun>pSet->a[i].rRun ) p = pSet->a + i;
    }
    if( p->rRun<=rRun ) return 0;
  }
whereOrInsert_done:
  p->prereq = prereq;
  p->rRun = rRun;
  if( p->nOut>nOut ) p->nOut = nOut;
  return 1;
}





static Bitmask sqlite3WhereGetMask(WhereMaskSet *pMaskSet, int iCursor){
  int i;
  ((void)0);
  for(i=0; i<pMaskSet->n; i++){
    if( pMaskSet->ix[i]==iCursor ){
      return (((Bitmask)1)<<(i));
    }
  }
  return 0;
}
# 141508 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void createMask(WhereMaskSet *pMaskSet, int iCursor){
  ((void)0);
  pMaskSet->ix[pMaskSet->n++] = iCursor;
}






static WhereTerm *whereScanNext(WhereScan *pScan){
  int iCur;
  i16 iColumn;
  Expr *pX;
  WhereClause *pWC;
  WhereTerm *pTerm;
  int k = pScan->k;

  ((void)0);
  pWC = pScan->pWC;
  while(1){
    iColumn = pScan->aiColumn[pScan->iEquiv-1];
    iCur = pScan->aiCur[pScan->iEquiv-1];
    ((void)0);
    do{
      for(pTerm=pWC->a+k; k<pWC->nTerm; k++, pTerm++){
        if( pTerm->leftCursor==iCur
         && pTerm->u.leftColumn==iColumn
         && (iColumn!=(-2)
             || sqlite3ExprCompareSkip(pTerm->pExpr->pLeft,
                                       pScan->pIdxExpr,iCur)==0)
         && (pScan->iEquiv<=1 || !(((pTerm->pExpr)->flags&(0x000001))!=0))
        ){
          if( (pTerm->eOperator & 0x0800)!=0
           && pScan->nEquiv<((int)(sizeof(pScan->aiCur)/sizeof(pScan->aiCur[0])))
           && (pX = sqlite3ExprSkipCollateAndLikely(pTerm->pExpr->pRight))->op
               ==162
          ){
            int j;
            for(j=0; j<pScan->nEquiv; j++){
              if( pScan->aiCur[j]==pX->iTable
               && pScan->aiColumn[j]==pX->iColumn ){
                  break;
              }
            }
            if( j==pScan->nEquiv ){
              pScan->aiCur[j] = pX->iTable;
              pScan->aiColumn[j] = pX->iColumn;
              pScan->nEquiv++;
            }
          }
          if( (pTerm->eOperator & pScan->opMask)!=0 ){

            if( pScan->zCollName && (pTerm->eOperator & 0x0100)==0 ){
              CollSeq *pColl;
              Parse *pParse = pWC->pWInfo->pParse;
              pX = pTerm->pExpr;
              if( !sqlite3IndexAffinityOk(pX, pScan->idxaff) ){
                continue;
              }
              ((void)0);
              pColl = sqlite3BinaryCompareCollSeq(pParse,
                                                  pX->pLeft, pX->pRight);
              if( pColl==0 ) pColl = pParse->db->pDfltColl;
              if( sqlite3StrICmp(pColl->zName, pScan->zCollName) ){
                continue;
              }
            }
            if( (pTerm->eOperator & (0x0002|0x0080))!=0
             && (pX = pTerm->pExpr->pRight)->op==162
             && pX->iTable==pScan->aiCur[0]
             && pX->iColumn==pScan->aiColumn[0]
            ){
              ;
              continue;
            }
            pScan->pWC = pWC;
            pScan->k = k+1;
            return pTerm;
          }
        }
      }
      pWC = pWC->pOuter;
      k = 0;
    }while( pWC!=0 );
    if( pScan->iEquiv>=pScan->nEquiv ) break;
    pWC = pScan->pOrigWC;
    k = 0;
    pScan->iEquiv++;
  }
  return 0;
}







static __attribute__((noinline)) WhereTerm *whereScanInitIndexExpr(WhereScan *pScan){
  pScan->idxaff = sqlite3ExprAffinity(pScan->pIdxExpr);
  return whereScanNext(pScan);
}
# 141631 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static WhereTerm *whereScanInit(
  WhereScan *pScan,
  WhereClause *pWC,
  int iCur,
  int iColumn,
  u32 opMask,
  Index *pIdx
){
  pScan->pOrigWC = pWC;
  pScan->pWC = pWC;
  pScan->pIdxExpr = 0;
  pScan->idxaff = 0;
  pScan->zCollName = 0;
  pScan->opMask = opMask;
  pScan->k = 0;
  pScan->aiCur[0] = iCur;
  pScan->nEquiv = 1;
  pScan->iEquiv = 1;
  if( pIdx ){
    int j = iColumn;
    iColumn = pIdx->aiColumn[j];
    if( iColumn==(-2) ){
      pScan->pIdxExpr = pIdx->aColExpr->a[j].pExpr;
      pScan->zCollName = pIdx->azColl[j];
      pScan->aiColumn[0] = (-2);
      return whereScanInitIndexExpr(pScan);
    }else if( iColumn==pIdx->pTable->iPKey ){
      iColumn = (-1);
    }else if( iColumn>=0 ){
      pScan->idxaff = pIdx->pTable->aCol[iColumn].affinity;
      pScan->zCollName = pIdx->azColl[j];
    }
  }else if( iColumn==(-2) ){
    return 0;
  }
  pScan->aiColumn[0] = iColumn;
  return whereScanNext(pScan);
}
# 141695 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static WhereTerm *sqlite3WhereFindTerm(
  WhereClause *pWC,
  int iCur,
  int iColumn,
  Bitmask notReady,
  u32 op,
  Index *pIdx
){
  WhereTerm *pResult = 0;
  WhereTerm *p;
  WhereScan scan;

  p = whereScanInit(&scan, pWC, iCur, iColumn, op, pIdx);
  op &= 0x0002|0x0080;
  while( p ){
    if( (p->prereqRight & notReady)==0 ){
      if( p->prereqRight==0 && (p->eOperator&op)!=0 ){
        ;
        return p;
      }
      if( pResult==0 ) pResult = p;
    }
    p = whereScanNext(&scan);
  }
  return pResult;
}
# 141729 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int findIndexCol(
  Parse *pParse,
  ExprList *pList,
  int iBase,
  Index *pIdx,
  int iCol
){
  int i;
  const char *zColl = pIdx->azColl[iCol];

  for(i=0; i<pList->nExpr; i++){
    Expr *p = sqlite3ExprSkipCollateAndLikely(pList->a[i].pExpr);
    if( p->op==162
     && p->iColumn==pIdx->aiColumn[iCol]
     && p->iTable==iBase
    ){
      CollSeq *pColl = sqlite3ExprNNCollSeq(pParse, pList->a[i].pExpr);
      if( 0==sqlite3StrICmp(pColl->zName, zColl) ){
        return i;
      }
    }
  }

  return -1;
}




static int indexColumnNotNull(Index *pIdx, int iCol){
  int j;
  ((void)0);
  ((void)0);
  j = pIdx->aiColumn[iCol];
  if( j>=0 ){
    return pIdx->pTable->aCol[j].notNull;
  }else if( j==(-1) ){
    return 1;
  }else{
    ((void)0);
    return 0;

  }
}
# 141781 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int isDistinctRedundant(
  Parse *pParse,
  SrcList *pTabList,
  WhereClause *pWC,
  ExprList *pDistinct
){
  Table *pTab;
  Index *pIdx;
  int i;
  int iBase;




  if( pTabList->nSrc!=1 ) return 0;
  iBase = pTabList->a[0].iCursor;
  pTab = pTabList->a[0].pTab;





  for(i=0; i<pDistinct->nExpr; i++){
    Expr *p = sqlite3ExprSkipCollateAndLikely(pDistinct->a[i].pExpr);
    if( p->op==162 && p->iTable==iBase && p->iColumn<0 ) return 1;
  }
# 141821 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
    if( !((pIdx)->onError!=0) ) continue;
    for(i=0; i<pIdx->nKeyCol; i++){
      if( 0==sqlite3WhereFindTerm(pWC, iBase, i, ~(Bitmask)0, 0x0002, pIdx) ){
        if( findIndexCol(pParse, pDistinct, iBase, pIdx, i)<0 ) break;
        if( indexColumnNotNull(pIdx, i)==0 ) break;
      }
    }
    if( i==pIdx->nKeyCol ){

      return 1;
    }
  }

  return 0;
}





static LogEst estLog(LogEst N){
  return N<=10 ? 0 : sqlite3LogEst(N) - 33;
}
# 141858 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void translateColumnToCopy(
  Parse *pParse,
  int iStart,
  int iTabCur,
  int iRegister,
  int iAutoidxCur
){
  Vdbe *v = pParse->pVdbe;
  VdbeOp *pOp = sqlite3VdbeGetOp(v, iStart);
  int iEnd = sqlite3VdbeCurrentAddr(v);
  if( pParse->db->mallocFailed ) return;
  for(; iStart<iEnd; iStart++, pOp++){
    if( pOp->p1!=iTabCur ) continue;
    if( pOp->opcode==90 ){
      pOp->opcode = 78;
      pOp->p1 = pOp->p2 + iRegister;
      pOp->p2 = pOp->p3;
      pOp->p3 = 0;
    }else if( pOp->opcode==128 ){
      if( iAutoidxCur ){
        pOp->opcode = 120;
        pOp->p1 = iAutoidxCur;
      }else{
        pOp->opcode = 73;
        pOp->p1 = 0;
        pOp->p3 = 0;
      }
    }
  }
}
# 141930 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define TRACE_IDX_INPUTS(A) 
#define TRACE_IDX_OUTPUTS(A) 
# 141940 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int termCanDriveIndex(
  WhereTerm *pTerm,
  struct SrcList_item *pSrc,
  Bitmask notReady
){
  char aff;
  if( pTerm->leftCursor!=pSrc->iCursor ) return 0;
  if( (pTerm->eOperator & (0x0002|0x0080))==0 ) return 0;
  if( (pSrc->fg.jointype & 0x0008)
   && !(((pTerm->pExpr)->flags&(0x000001))!=0)
   && (pTerm->eOperator & 0x0080)
  ){



    return 0;
  }
  if( (pTerm->prereqRight & notReady)!=0 ) return 0;
  if( pTerm->u.leftColumn<0 ) return 0;
  aff = pSrc->pTab->aCol[pTerm->u.leftColumn].affinity;
  if( !sqlite3IndexAffinityOk(pTerm->pExpr, aff) ) return 0;
  ;
  return 1;
}
# 141973 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void constructAutomaticIndex(
  Parse *pParse,
  WhereClause *pWC,
  struct SrcList_item *pSrc,
  Bitmask notReady,
  WhereLevel *pLevel
){
  int nKeyCol;
  WhereTerm *pTerm;
  WhereTerm *pWCEnd;
  Index *pIdx;
  Vdbe *v;
  int addrInit;
  Table *pTable;
  int addrTop;
  int regRecord;
  int n;
  int i;
  int mxBitCol;
  CollSeq *pColl;
  WhereLoop *pLoop;
  char *zNotUsed;
  Bitmask idxCols;
  Bitmask extraCols;
  u8 sentWarning = 0;
  Expr *pPartial = 0;
  int iContinue = 0;
  struct SrcList_item *pTabItem;
  int addrCounter = 0;
  int regBase;



  v = pParse->pVdbe;
  ((void)0);
  addrInit = sqlite3VdbeAddOp0(v, 17); ;



  nKeyCol = 0;
  pTable = pSrc->pTab;
  pWCEnd = &pWC->a[pWC->nTerm];
  pLoop = pLevel->pWLoop;
  idxCols = 0;
  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    Expr *pExpr = pTerm->pExpr;
    ((void)0)

                              ;
    if( pLoop->prereq==0
     && (pTerm->wtFlags & 0x02)==0
     && !(((pExpr)->flags&(0x000001))!=0)
     && sqlite3ExprIsTableConstant(pExpr, pSrc->iCursor) ){
      pPartial = sqlite3ExprAnd(pParse, pPartial,
                                sqlite3ExprDup(pParse->db, pExpr, 0));
    }
    if( termCanDriveIndex(pTerm, pSrc, notReady) ){
      int iCol = pTerm->u.leftColumn;
      Bitmask cMask = iCol>=((int)(sizeof(Bitmask)*8)) ? (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) : (((Bitmask)1)<<(iCol));
      ;
      ;
      if( !sentWarning ){
        sqlite3_log((28 | (1<<8)),
            "automatic index on %s(%s)", pTable->zName,
            pTable->aCol[iCol].zName);
        sentWarning = 1;
      }
      if( (idxCols & cMask)==0 ){
        if( whereLoopResize(pParse->db, pLoop, nKeyCol+1) ){
          goto end_auto_index_create;
        }
        pLoop->aLTerm[nKeyCol++] = pTerm;
        idxCols |= cMask;
      }
    }
  }
  ((void)0);
  pLoop->u.btree.nEq = pLoop->nLTerm = nKeyCol;
  pLoop->wsFlags = 0x00000001 | 0x00000040 | 0x00000200
                     | 0x00004000;
# 142062 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  extraCols = pSrc->colUsed & (~idxCols | (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)));
  mxBitCol = ((((int)(sizeof(Bitmask)*8))-1)<(pTable->nCol)?(((int)(sizeof(Bitmask)*8))-1):(pTable->nCol));
  ;
  ;
  for(i=0; i<mxBitCol; i++){
    if( extraCols & (((Bitmask)1)<<(i)) ) nKeyCol++;
  }
  if( pSrc->colUsed & (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) ){
    nKeyCol += pTable->nCol - ((int)(sizeof(Bitmask)*8)) + 1;
  }


  pIdx = sqlite3AllocateIndexObject(pParse->db, nKeyCol+1, 0, &zNotUsed);
  if( pIdx==0 ) goto end_auto_index_create;
  pLoop->u.btree.pIndex = pIdx;
  pIdx->zName = "auto-index";
  pIdx->pTable = pTable;
  n = 0;
  idxCols = 0;
  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){
    if( termCanDriveIndex(pTerm, pSrc, notReady) ){
      int iCol = pTerm->u.leftColumn;
      Bitmask cMask = iCol>=((int)(sizeof(Bitmask)*8)) ? (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) : (((Bitmask)1)<<(iCol));
      ;
      ;
      if( (idxCols & cMask)==0 ){
        Expr *pX = pTerm->pExpr;
        idxCols |= cMask;
        pIdx->aiColumn[n] = pTerm->u.leftColumn;
        pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);
        pIdx->azColl[n] = pColl ? pColl->zName : sqlite3StrBINARY;
        n++;
      }
    }
  }
  ((void)0);



  for(i=0; i<mxBitCol; i++){
    if( extraCols & (((Bitmask)1)<<(i)) ){
      pIdx->aiColumn[n] = i;
      pIdx->azColl[n] = sqlite3StrBINARY;
      n++;
    }
  }
  if( pSrc->colUsed & (((Bitmask)1)<<(((int)(sizeof(Bitmask)*8))-1)) ){
    for(i=((int)(sizeof(Bitmask)*8))-1; i<pTable->nCol; i++){
      pIdx->aiColumn[n] = i;
      pIdx->azColl[n] = sqlite3StrBINARY;
      n++;
    }
  }
  ((void)0);
  pIdx->aiColumn[n] = (-1);
  pIdx->azColl[n] = sqlite3StrBINARY;


  ((void)0);
  pLevel->iIdxCur = pParse->nTab++;
  sqlite3VdbeAddOp2(v, 111, pLevel->iIdxCur, nKeyCol+1);
  sqlite3VdbeSetP4KeyInfo(pParse, pIdx);
  ;


  pTabItem = &pWC->pWInfo->pTabList->a[pLevel->iFrom];
  if( pTabItem->fg.viaCoroutine ){
    int regYield = pTabItem->regReturn;
    addrCounter = sqlite3VdbeAddOp2(v, 70, 0, 0);
    sqlite3VdbeAddOp3(v, 13, regYield, 0, pTabItem->addrFillSub);
    addrTop = sqlite3VdbeAddOp1(v, 14, regYield);
    ;
    ;
  }else{
    addrTop = sqlite3VdbeAddOp1(v, 36, pLevel->iTabCur); ;
  }
  if( pPartial ){
    iContinue = sqlite3VdbeMakeLabel(pParse);
    sqlite3ExprIfFalse(pParse, pPartial, iContinue, 0x10);
    pLoop->wsFlags |= 0x00020000;
  }
  regRecord = sqlite3GetTempReg(pParse);
  regBase = sqlite3GenerateIndexKey(
      pParse, pIdx, pLevel->iTabCur, regRecord, 0, 0, 0, 0
  );
  sqlite3VdbeAddOp2(v, 132, pLevel->iIdxCur, regRecord);
  sqlite3VdbeChangeP5(v, 0x10);
  if( pPartial ) sqlite3VdbeResolveLabel(v, iContinue);
  if( pTabItem->fg.viaCoroutine ){
    sqlite3VdbeChangeP2(v, addrCounter, regBase+n);
    ;
    ((void)0);
    translateColumnToCopy(pParse, addrTop, pLevel->iTabCur,
                          pTabItem->regResult, pLevel->iIdxCur);
    sqlite3VdbeGoto(v, addrTop);
    pTabItem->fg.viaCoroutine = 0;
  }else{
    sqlite3VdbeAddOp2(v, 5, pLevel->iTabCur, addrTop+1); ;
  }
  sqlite3VdbeChangeP5(v, 3);
  sqlite3VdbeJumpHere(v, addrTop);
  sqlite3ReleaseTempReg(pParse, regRecord);


  sqlite3VdbeJumpHere(v, addrInit);

end_auto_index_create:
  sqlite3ExprDelete(pParse->db, pPartial);
}
# 142179 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static sqlite3_index_info *allocateIndexInfo(
  Parse *pParse,
  WhereClause *pWC,
  Bitmask mUnusable,
  struct SrcList_item *pSrc,
  ExprList *pOrderBy,
  u16 *pmNoOmit
){
  int i, j;
  int nTerm;
  struct sqlite3_index_constraint *pIdxCons;
  struct sqlite3_index_orderby *pIdxOrderBy;
  struct sqlite3_index_constraint_usage *pUsage;
  struct HiddenIndexInfo *pHidden;
  WhereTerm *pTerm;
  int nOrderBy;
  sqlite3_index_info *pIdxInfo;
  u16 mNoOmit = 0;



  for(i=nTerm=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    if( pTerm->leftCursor != pSrc->iCursor ) continue;
    if( pTerm->prereqRight & mUnusable ) continue;
    ((void)0);
    ;
    ;
    ;
    ;
    if( (pTerm->eOperator & ~(0x0800))==0 ) continue;
    if( pTerm->wtFlags & 0x00 ) continue;
    ((void)0);
    nTerm++;
  }





  nOrderBy = 0;
  if( pOrderBy ){
    int n = pOrderBy->nExpr;
    for(i=0; i<n; i++){
      Expr *pExpr = pOrderBy->a[i].pExpr;
      if( pExpr->op!=162 || pExpr->iTable!=pSrc->iCursor ) break;
      if( pOrderBy->a[i].sortFlags & 0x02 ) break;
    }
    if( i==n){
      nOrderBy = n;
    }
  }



  pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo)
                           + (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm
                           + sizeof(*pIdxOrderBy)*nOrderBy + sizeof(*pHidden) );
  if( pIdxInfo==0 ){
    sqlite3ErrorMsg(pParse, "out of memory");
    return 0;
  }






  pHidden = (struct HiddenIndexInfo*)&pIdxInfo[1];
  pIdxCons = (struct sqlite3_index_constraint*)&pHidden[1];
  pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm];
  pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy];
  *(int*)&pIdxInfo->nConstraint = nTerm;
  *(int*)&pIdxInfo->nOrderBy = nOrderBy;
  *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint = pIdxCons;
  *(struct sqlite3_index_orderby**)&pIdxInfo->aOrderBy = pIdxOrderBy;
  *(struct sqlite3_index_constraint_usage**)&pIdxInfo->aConstraintUsage =
                                                                   pUsage;

  pHidden->pWC = pWC;
  pHidden->pParse = pParse;
  for(i=j=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    u16 op;
    if( pTerm->leftCursor != pSrc->iCursor ) continue;
    if( pTerm->prereqRight & mUnusable ) continue;
    ((void)0);
    ;
    ;
    ;
    ;
    if( (pTerm->eOperator & ~(0x0800))==0 ) continue;
    if( pTerm->wtFlags & 0x00 ) continue;
    if( (pSrc->fg.jointype & 0x0008)!=0
     && !(((pTerm->pExpr)->flags&(0x000001))!=0)
     && (pTerm->eOperator & (0x0080|0x0100))
    ){






      ;
      ;
      continue;
    }
    ((void)0);
    pIdxCons[j].iColumn = pTerm->u.leftColumn;
    pIdxCons[j].iTermOffset = i;
    op = pTerm->eOperator & 0x1fff;
    if( op==0x0001 ) op = 0x0002;
    if( op==0x0040 ){
      pIdxCons[j].op = pTerm->eMatchOp;
    }else if( op & (0x0100|0x0080) ){
      if( op==0x0100 ){
        pIdxCons[j].op = 71;
      }else{
        pIdxCons[j].op = 72;
      }
    }else{
      pIdxCons[j].op = (u8)op;



      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);
      ((void)0);

      if( op & ((0x0002<<(56 -53))|(0x0002<<(55 -53))|(0x0002<<(54 -53))|(0x0002<<(57 -53)))
       && sqlite3ExprIsVector(pTerm->pExpr->pRight)
      ){
        if( i<16 ) mNoOmit |= (1 << i);
        if( op==(0x0002<<(56 -53)) ) pIdxCons[j].op = (0x0002<<(55 -53));
        if( op==(0x0002<<(54 -53)) ) pIdxCons[j].op = (0x0002<<(57 -53));
      }
    }

    j++;
  }
  for(i=0; i<nOrderBy; i++){
    Expr *pExpr = pOrderBy->a[i].pExpr;
    pIdxOrderBy[i].iColumn = pExpr->iColumn;
    pIdxOrderBy[i].desc = pOrderBy->a[i].sortFlags & 0x01;
  }

  *pmNoOmit = mNoOmit;
  return pIdxInfo;
}
# 142346 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){
  sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;
  int rc;

  ;
  rc = pVtab->pModule->xBestIndex(pVtab, p);
  ;

  if( rc!=0 && rc!=19 ){
    if( rc==7 ){
      sqlite3OomFault(pParse->db);
    }else if( !pVtab->zErrMsg ){
      sqlite3ErrorMsg(pParse, "%s", sqlite3ErrStr(rc));
    }else{
      sqlite3ErrorMsg(pParse, "%s", pVtab->zErrMsg);
    }
  }
  sqlite3_free(pVtab->zErrMsg);
  pVtab->zErrMsg = 0;
  return rc;
}
# 142575 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static LogEst whereRangeAdjust(WhereTerm *pTerm, LogEst nNew){
  LogEst nRet = nNew;
  if( pTerm ){
    if( pTerm->truthProb<=0 ){
      nRet += pTerm->truthProb;
    }else if( (pTerm->wtFlags & 0x00)==0 ){
      nRet -= 20; ((void)0);
    }
  }
  return nRet;
}
# 142751 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereRangeScanEst(
  Parse *pParse,
  WhereLoopBuilder *pBuilder,
  WhereTerm *pLower,
  WhereTerm *pUpper,
  WhereLoop *pLoop
){
  int rc = 0;
  int nOut = pLoop->nOut;
  LogEst nNew;
# 142883 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  (void)(pParse);
  (void)(pBuilder);
  ((void)0);

  ((void)0);
  nNew = whereRangeAdjust(pLower, nOut);
  nNew = whereRangeAdjust(pUpper, nNew);







  if( pLower && pLower->truthProb>0 && pUpper && pUpper->truthProb>0 ){
    nNew -= 20;
  }

  nOut -= (pLower!=0) + (pUpper!=0);
  if( nNew<10 ) nNew = 10;
  if( nNew<nOut ) nOut = nNew;






  pLoop->nOut = (LogEst)nOut;
  return rc;
}
# 143134 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void whereLoopInit(WhereLoop *p){
  p->aLTerm = p->aLTermSpace;
  p->nLTerm = 0;
  p->nLSlot = ((int)(sizeof(p->aLTermSpace)/sizeof(p->aLTermSpace[0])));
  p->wsFlags = 0;
}




static void whereLoopClearUnion(sqlite3 *db, WhereLoop *p){
  if( p->wsFlags & (0x00000400|0x00004000) ){
    if( (p->wsFlags & 0x00000400)!=0 && p->u.vtab.needFree ){
      sqlite3_free(p->u.vtab.idxStr);
      p->u.vtab.needFree = 0;
      p->u.vtab.idxStr = 0;
    }else if( (p->wsFlags & 0x00004000)!=0 && p->u.btree.pIndex!=0 ){
      sqlite3DbFree(db, p->u.btree.pIndex->zColAff);
      sqlite3DbFreeNN(db, p->u.btree.pIndex);
      p->u.btree.pIndex = 0;
    }
  }
}




static void whereLoopClear(sqlite3 *db, WhereLoop *p){
  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);
  whereLoopClearUnion(db, p);
  whereLoopInit(p);
}




static int whereLoopResize(sqlite3 *db, WhereLoop *p, int n){
  WhereTerm **paNew;
  if( p->nLSlot>=n ) return 0;
  n = (n+7)&~7;
  paNew = sqlite3DbMallocRawNN(db, sizeof(p->aLTerm[0])*n);
  if( paNew==0 ) return 7;
  memcpy(paNew, p->aLTerm, sizeof(p->aLTerm[0])*p->nLSlot);
  if( p->aLTerm!=p->aLTermSpace ) sqlite3DbFreeNN(db, p->aLTerm);
  p->aLTerm = paNew;
  p->nLSlot = n;
  return 0;
}




static int whereLoopXfer(sqlite3 *db, WhereLoop *pTo, WhereLoop *pFrom){
  whereLoopClearUnion(db, pTo);
  if( whereLoopResize(db, pTo, pFrom->nLTerm) ){
    memset(&pTo->u, 0, sizeof(pTo->u));
    return 7;
  }
  memcpy(pTo, pFrom, __builtin_offsetof(WhereLoop,nLSlot));
  memcpy(pTo->aLTerm, pFrom->aLTerm, pTo->nLTerm*sizeof(pTo->aLTerm[0]));
  if( pFrom->wsFlags & 0x00000400 ){
    pFrom->u.vtab.needFree = 0;
  }else if( (pFrom->wsFlags & 0x00004000)!=0 ){
    pFrom->u.btree.pIndex = 0;
  }
  return 0;
}




static void whereLoopDelete(sqlite3 *db, WhereLoop *p){
  whereLoopClear(db, p);
  sqlite3DbFreeNN(db, p);
}




static void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){
  int i;
  ((void)0);
  for(i=0; i<pWInfo->nLevel; i++){
    WhereLevel *pLevel = &pWInfo->a[i];
    if( pLevel->pWLoop && (pLevel->pWLoop->wsFlags & 0x00000800) ){
      sqlite3DbFree(db, pLevel->u.in.aInLoop);
    }
  }
  sqlite3WhereClauseClear(&pWInfo->sWC);
  while( pWInfo->pLoops ){
    WhereLoop *p = pWInfo->pLoops;
    pWInfo->pLoops = p->pNextLoop;
    whereLoopDelete(db, p);
  }
  sqlite3DbFreeNN(db, pWInfo);
}
# 143249 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereLoopCheaperProperSubset(
  const WhereLoop *pX,
  const WhereLoop *pY
){
  int i, j;
  if( pX->nLTerm-pX->nSkip >= pY->nLTerm-pY->nSkip ){
    return 0;
  }
  if( pY->nSkip > pX->nSkip ) return 0;
  if( pX->rRun >= pY->rRun ){
    if( pX->rRun > pY->rRun ) return 0;
    if( pX->nOut > pY->nOut ) return 0;
  }
  for(i=pX->nLTerm-1; i>=0; i--){
    if( pX->aLTerm[i]==0 ) continue;
    for(j=pY->nLTerm-1; j>=0; j--){
      if( pY->aLTerm[j]==pX->aLTerm[i] ) break;
    }
    if( j<0 ) return 0;
  }
  if( (pX->wsFlags&0x00000040)!=0
   && (pY->wsFlags&0x00000040)==0 ){
    return 0;
  }
  return 1;
}
# 143290 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void whereLoopAdjustCost(const WhereLoop *p, WhereLoop *pTemplate){
  if( (pTemplate->wsFlags & 0x00000200)==0 ) return;
  for(; p; p=p->pNextLoop){
    if( p->iTab!=pTemplate->iTab ) continue;
    if( (p->wsFlags & 0x00000200)==0 ) continue;
    if( whereLoopCheaperProperSubset(p, pTemplate) ){


     
                                                                             ;
      pTemplate->rRun = p->rRun;
      pTemplate->nOut = p->nOut - 1;
    }else if( whereLoopCheaperProperSubset(pTemplate, p) ){


     
                                                                             ;
      pTemplate->rRun = p->rRun;
      pTemplate->nOut = p->nOut + 1;
    }
  }
}
# 143327 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static WhereLoop **whereLoopFindLesser(
  WhereLoop **ppPrev,
  const WhereLoop *pTemplate
){
  WhereLoop *p;
  for(p=(*ppPrev); p; ppPrev=&p->pNextLoop, p=*ppPrev){
    if( p->iTab!=pTemplate->iTab || p->iSortIdx!=pTemplate->iSortIdx ){



      continue;
    }



    ((void)0)
                                                  ;




    ((void)0);




    if( (p->wsFlags & 0x00004000)!=0
     && (pTemplate->nSkip)==0
     && (pTemplate->wsFlags & 0x00000200)!=0
     && (pTemplate->wsFlags & 0x00000001)!=0
     && (p->prereq & pTemplate->prereq)==pTemplate->prereq
    ){
      break;
    }






    if( (p->prereq & pTemplate->prereq)==p->prereq
     && p->rSetup<=pTemplate->rSetup
     && p->rRun<=pTemplate->rRun
     && p->nOut<=pTemplate->nOut
    ){
      return 0;
    }






    if( (p->prereq & pTemplate->prereq)==pTemplate->prereq
     && p->rRun>=pTemplate->rRun
     && p->nOut>=pTemplate->nOut
    ){
      ((void)0);
      break;
    }
  }
  return ppPrev;
}
# 143415 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereLoopInsert(WhereLoopBuilder *pBuilder, WhereLoop *pTemplate){
  WhereLoop **ppPrev, *p;
  WhereInfo *pWInfo = pBuilder->pWInfo;
  sqlite3 *db = pWInfo->pParse->db;
  int rc;


  if( pBuilder->iPlanLimit==0 ){
    ;
    if( pBuilder->pOrSet ) pBuilder->pOrSet->n = 0;
    return 101;
  }
  pBuilder->iPlanLimit--;




  if( pBuilder->pOrSet!=0 ){
    if( pTemplate->nLTerm ){




      whereOrInsert(pBuilder->pOrSet, pTemplate->prereq, pTemplate->rRun,
                                    pTemplate->nOut);






    }
    return 0;
  }



  whereLoopAdjustCost(pWInfo->pLoops, pTemplate);
  ppPrev = whereLoopFindLesser(&pWInfo->pLoops, pTemplate);

  if( ppPrev==0 ){
# 143464 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    return 0;
  }else{
    p = *ppPrev;
  }
# 143485 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( p==0 ){

    *ppPrev = p = sqlite3DbMallocRawNN(db, sizeof(WhereLoop));
    if( p==0 ) return 7;
    whereLoopInit(p);
    p->pNextLoop = 0;
  }else{



    WhereLoop **ppTail = &p->pNextLoop;
    WhereLoop *pToDel;
    while( *ppTail ){
      ppTail = whereLoopFindLesser(ppTail, pTemplate);
      if( ppTail==0 ) break;
      pToDel = *ppTail;
      if( pToDel==0 ) break;
      *ppTail = pToDel->pNextLoop;






      whereLoopDelete(db, pToDel);
    }
  }
  rc = whereLoopXfer(db, p, pTemplate);
  if( (p->wsFlags & 0x00000400)==0 ){
    Index *pIndex = p->u.btree.pIndex;
    if( pIndex && pIndex->idxType==3 ){
      p->u.btree.pIndex = 0;
    }
  }
  return rc;
}
# 143551 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void whereLoopOutputAdjust(
  WhereClause *pWC,
  WhereLoop *pLoop,
  LogEst nRow
){
  WhereTerm *pTerm, *pX;
  Bitmask notAllowed = ~(pLoop->prereq|pLoop->maskSelf);
  int i, j;
  LogEst iReduce = 0;

  ((void)0);
  for(i=pWC->nTerm, pTerm=pWC->a; i>0; i--, pTerm++){
    ((void)0);
    if( (pTerm->wtFlags & 0x02)!=0 ) break;
    if( (pTerm->prereqAll & pLoop->maskSelf)==0 ) continue;
    if( (pTerm->prereqAll & notAllowed)!=0 ) continue;
    for(j=pLoop->nLTerm-1; j>=0; j--){
      pX = pLoop->aLTerm[j];
      if( pX==0 ) continue;
      if( pX==pTerm ) break;
      if( pX->iParent>=0 && (&pWC->a[pX->iParent])==pTerm ) break;
    }
    if( j<0 ){
      if( pTerm->truthProb<=0 ){


        pLoop->nOut += pTerm->truthProb;
      }else{


        pLoop->nOut--;
        if( pTerm->eOperator&(0x0002|0x0080) ){
          Expr *pRight = pTerm->pExpr->pRight;
          int k = 0;
          ;
          if( sqlite3ExprIsInteger(pRight, &k) && k>=(-1) && k<=1 ){
            k = 10;
          }else{
            k = 20;
          }
          if( iReduce<k ) iReduce = k;
        }
      }
    }
  }
  if( pLoop->nOut > nRow-iReduce ) pLoop->nOut = nRow - iReduce;
}
# 143616 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereRangeVectorLen(
  Parse *pParse,
  int iCur,
  Index *pIdx,
  int nEq,
  WhereTerm *pTerm
){
  int nCmp = sqlite3ExprVectorSize(pTerm->pExpr->pLeft);
  int i;

  nCmp = ((nCmp)<((pIdx->nColumn - nEq))?(nCmp):((pIdx->nColumn - nEq)));
  for(i=1; i<nCmp; i++){


    char aff;
    char idxaff = 0;
    CollSeq *pColl;
    Expr *pLhs = pTerm->pExpr->pLeft->x.pList->a[i].pExpr;
    Expr *pRhs = pTerm->pExpr->pRight;
    if( pRhs->flags & 0x000800 ){
      pRhs = pRhs->x.pSelect->pEList->a[i].pExpr;
    }else{
      pRhs = pRhs->x.pList->a[i].pExpr;
    }





    if( pLhs->op!=162
     || pLhs->iTable!=iCur
     || pLhs->iColumn!=pIdx->aiColumn[i+nEq]
     || pIdx->aSortOrder[i+nEq]!=pIdx->aSortOrder[nEq]
    ){
      break;
    }

    ;
    aff = sqlite3CompareAffinity(pRhs, sqlite3ExprAffinity(pLhs));
    idxaff = sqlite3TableColumnAffinity(pIdx->pTable, pLhs->iColumn);
    if( aff!=idxaff ) break;

    pColl = sqlite3BinaryCompareCollSeq(pParse, pLhs, pRhs);
    if( pColl==0 ) break;
    if( sqlite3StrICmp(pColl->zName, pIdx->azColl[i+nEq]) ) break;
  }
  return i;
}
# 143672 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define ApplyCostMultiplier(C,T) 
# 143687 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereLoopAddBtreeIndex(
  WhereLoopBuilder *pBuilder,
  struct SrcList_item *pSrc,
  Index *pProbe,
  LogEst nInMul
){
  WhereInfo *pWInfo = pBuilder->pWInfo;
  Parse *pParse = pWInfo->pParse;
  sqlite3 *db = pParse->db;
  WhereLoop *pNew;
  WhereTerm *pTerm;
  int opMask;
  WhereScan scan;
  Bitmask saved_prereq;
  u16 saved_nLTerm;
  u16 saved_nEq;
  u16 saved_nBtm;
  u16 saved_nTop;
  u16 saved_nSkip;
  u32 saved_wsFlags;
  LogEst saved_nOut;
  int rc = 0;
  LogEst rSize;
  LogEst rLogSize;
  WhereTerm *pTop = 0, *pBtm = 0;

  pNew = pBuilder->pNew;
  if( db->mallocFailed ) return 7;
 
                                                                             ;

  ((void)0);
  ((void)0);
  if( pNew->wsFlags & 0x00000020 ){
    opMask = (0x0002<<(56 -53))|(0x0002<<(55 -53));
  }else{
    ((void)0);
    opMask = 0x0002|0x0001|(0x0002<<(54 -53))|(0x0002<<(57 -53))|(0x0002<<(56 -53))|(0x0002<<(55 -53))|0x0100|0x0080;
  }
  if( pProbe->bUnordered ) opMask &= ~((0x0002<<(54 -53))|(0x0002<<(57 -53))|(0x0002<<(56 -53))|(0x0002<<(55 -53)));

  ((void)0);

  saved_nEq = pNew->u.btree.nEq;
  saved_nBtm = pNew->u.btree.nBtm;
  saved_nTop = pNew->u.btree.nTop;
  saved_nSkip = pNew->nSkip;
  saved_nLTerm = pNew->nLTerm;
  saved_wsFlags = pNew->wsFlags;
  saved_prereq = pNew->prereq;
  saved_nOut = pNew->nOut;
  pTerm = whereScanInit(&scan, pBuilder->pWC, pSrc->iCursor, saved_nEq,
                        opMask, pProbe);
  pNew->rSetup = 0;
  rSize = pProbe->aiRowLogEst[0];
  rLogSize = estLog(rSize);
  for(; rc==0 && pTerm!=0; pTerm = whereScanNext(&scan)){
    u16 eOp = pTerm->eOperator;
    LogEst rCostIdx;
    LogEst nOutUnadjusted;
    int nIn = 0;



    if( (eOp==0x0100 || (pTerm->wtFlags&0x00)!=0)
     && indexColumnNotNull(pProbe, saved_nEq)
    ){
      continue;
    }
    if( pTerm->prereqRight & pNew->maskSelf ) continue;



    if( pTerm->wtFlags & 0x100 && pTerm->eOperator==(0x0002<<(56 -53)) ) continue;




    if( (pSrc->fg.jointype & 0x0008)!=0
     && !(((pTerm->pExpr)->flags&(0x000001))!=0)
    ){
      continue;
    }

    if( ((pProbe)->onError!=0) && saved_nEq==pProbe->nKeyCol-1 ){
      pBuilder->bldFlags |= 0x0002;
    }else{
      pBuilder->bldFlags |= 0x0001;
    }
    pNew->wsFlags = saved_wsFlags;
    pNew->u.btree.nEq = saved_nEq;
    pNew->u.btree.nBtm = saved_nBtm;
    pNew->u.btree.nTop = saved_nTop;
    pNew->nLTerm = saved_nLTerm;
    if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break;
    pNew->aLTerm[pNew->nLTerm++] = pTerm;
    pNew->prereq = (saved_prereq | pTerm->prereqRight) & ~pNew->maskSelf;

    ((void)0)



     ;

    if( eOp & 0x0001 ){
      Expr *pExpr = pTerm->pExpr;
      if( (((pExpr)->flags&(0x000800))!=0) ){

        int i;
        nIn = 46; ((void)0);






        for(i=0; i<pNew->nLTerm-1; i++){
          if( pNew->aLTerm[i] && pNew->aLTerm[i]->pExpr==pExpr ) nIn = 0;
        }
      }else if( (pExpr->x.pList && pExpr->x.pList->nExpr) ){

        nIn = sqlite3LogEst(pExpr->x.pList->nExpr);
      }
      if( pProbe->hasStat1 ){
        LogEst M, logK, safetyMargin;
# 143831 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        M = pProbe->aiRowLogEst[saved_nEq];
        logK = estLog(nIn);
        safetyMargin = 10;
        if( M + logK + safetyMargin < nIn + rLogSize ){
         

                                                                ;
          continue;
        }else{
         

                                                                ;
        }
      }
      pNew->wsFlags |= 0x00000004;
    }else if( eOp & (0x0002|0x0080) ){
      int iCol = pProbe->aiColumn[saved_nEq];
      pNew->wsFlags |= 0x00000001;
      ((void)0);
      if( iCol==(-1)
       || (iCol>=0 && nInMul==0 && saved_nEq==pProbe->nKeyCol-1)
      ){
        if( iCol==(-1) || pProbe->uniqNotNull
         || (pProbe->nKeyCol==1 && pProbe->onError && eOp==0x0002)
        ){
          pNew->wsFlags |= 0x00001000;
        }else{
          pNew->wsFlags |= 0x00010000;
        }
      }
    }else if( eOp & 0x0100 ){
      pNew->wsFlags |= 0x00000008;
    }else if( eOp & ((0x0002<<(54 -53))|(0x0002<<(57 -53))) ){
      ;
      ;
      pNew->wsFlags |= 0x00000002|0x00000020;
      pNew->u.btree.nBtm = whereRangeVectorLen(
          pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm
      );
      pBtm = pTerm;
      pTop = 0;
      if( pTerm->wtFlags & 0x100 ){


        pTop = &pTerm[1];
        ((void)0);
        ((void)0);
        ((void)0);
        if( whereLoopResize(db, pNew, pNew->nLTerm+1) ) break;
        pNew->aLTerm[pNew->nLTerm++] = pTop;
        pNew->wsFlags |= 0x00000010;
        pNew->u.btree.nTop = 1;
      }
    }else{
      ((void)0);
      ;
      ;
      pNew->wsFlags |= 0x00000002|0x00000010;
      pNew->u.btree.nTop = whereRangeVectorLen(
          pParse, pSrc->iCursor, pProbe, saved_nEq, pTerm
      );
      pTop = pTerm;
      pBtm = (pNew->wsFlags & 0x00000020)!=0 ?
                     pNew->aLTerm[pNew->nLTerm-2] : 0;
    }






    ((void)0);
    if( pNew->wsFlags & 0x00000002 ){


      whereRangeScanEst(pParse, pBuilder, pBtm, pTop, pNew);
    }else{
      int nEq = ++pNew->u.btree.nEq;
      ((void)0);

      ((void)0);
      if( pTerm->truthProb<=0 && pProbe->aiColumn[saved_nEq]>=0 ){
        ((void)0);
        ;
        pNew->nOut += pTerm->truthProb;
        pNew->nOut -= nIn;
      }else{
# 143945 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        {
          pNew->nOut += (pProbe->aiRowLogEst[nEq] - pProbe->aiRowLogEst[nEq-1]);
          if( eOp & 0x0100 ){



            pNew->nOut += 10;
          }
        }
      }
    }





    ((void)0);
    rCostIdx = pNew->nOut + 1 + (15*pProbe->szIdxRow)/pSrc->pTab->szTabRow;
    pNew->rRun = sqlite3LogEstAdd(rLogSize, rCostIdx);
    if( (pNew->wsFlags & (0x00000040|0x00000100))==0 ){
      pNew->rRun = sqlite3LogEstAdd(pNew->rRun, pNew->nOut + 16);
    }
    ;

    nOutUnadjusted = pNew->nOut;
    pNew->rRun += nInMul + nIn;
    pNew->nOut += nInMul + nIn;
    whereLoopOutputAdjust(pBuilder->pWC, pNew, rSize);
    rc = whereLoopInsert(pBuilder, pNew);

    if( pNew->wsFlags & 0x00000002 ){
      pNew->nOut = saved_nOut;
    }else{
      pNew->nOut = nOutUnadjusted;
    }

    if( (pNew->wsFlags & 0x00000010)==0
     && pNew->u.btree.nEq<pProbe->nColumn
    ){
      whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nInMul+nIn);
    }
    pNew->nOut = saved_nOut;



  }
  pNew->prereq = saved_prereq;
  pNew->u.btree.nEq = saved_nEq;
  pNew->u.btree.nBtm = saved_nBtm;
  pNew->u.btree.nTop = saved_nTop;
  pNew->nSkip = saved_nSkip;
  pNew->wsFlags = saved_wsFlags;
  pNew->nOut = saved_nOut;
  pNew->nLTerm = saved_nLTerm;
# 144010 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( saved_nEq==saved_nSkip
   && saved_nEq+1<pProbe->nKeyCol
   && pProbe->noSkipScan==0
   && (((db)->dbOptFlags&(0x4000))==0)
   && pProbe->aiRowLogEst[saved_nEq+1]>=42
   && (rc = whereLoopResize(db, pNew, pNew->nLTerm+1))==0
  ){
    LogEst nIter;
    pNew->u.btree.nEq++;
    pNew->nSkip++;
    pNew->aLTerm[pNew->nLTerm++] = 0;
    pNew->wsFlags |= 0x00008000;
    nIter = pProbe->aiRowLogEst[saved_nEq] - pProbe->aiRowLogEst[saved_nEq+1];
    pNew->nOut -= nIter;


    nIter += 5;
    whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, nIter + nInMul);
    pNew->nOut = saved_nOut;
    pNew->u.btree.nEq = saved_nEq;
    pNew->nSkip = saved_nSkip;
    pNew->wsFlags = saved_wsFlags;
  }

 
                                                                           ;
  return rc;
}
# 144048 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int indexMightHelpWithOrderBy(
  WhereLoopBuilder *pBuilder,
  Index *pIndex,
  int iCursor
){
  ExprList *pOB;
  ExprList *aColExpr;
  int ii, jj;

  if( pIndex->bUnordered ) return 0;
  if( (pOB = pBuilder->pWInfo->pOrderBy)==0 ) return 0;
  for(ii=0; ii<pOB->nExpr; ii++){
    Expr *pExpr = sqlite3ExprSkipCollateAndLikely(pOB->a[ii].pExpr);
    if( pExpr->op==162 && pExpr->iTable==iCursor ){
      if( pExpr->iColumn<0 ) return 1;
      for(jj=0; jj<pIndex->nKeyCol; jj++){
        if( pExpr->iColumn==pIndex->aiColumn[jj] ) return 1;
      }
    }else if( (aColExpr = pIndex->aColExpr)!=0 ){
      for(jj=0; jj<pIndex->nKeyCol; jj++){
        if( pIndex->aiColumn[jj]!=(-2) ) continue;
        if( sqlite3ExprCompareSkip(pExpr,aColExpr->a[jj].pExpr,iCursor)==0 ){
          return 1;
        }
      }
    }
  }
  return 0;
}




static int whereUsablePartialIndex(int iTab, WhereClause *pWC, Expr *pWhere){
  int i;
  WhereTerm *pTerm;
  Parse *pParse = pWC->pWInfo->pParse;
  while( pWhere->op==44 ){
    if( !whereUsablePartialIndex(iTab,pWC,pWhere->pLeft) ) return 0;
    pWhere = pWhere->pRight;
  }
  if( pParse->db->flags & 0x00800000 ) pParse = 0;
  for(i=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){
    Expr *pExpr;
    if( pTerm->wtFlags & 0x2000 ) continue;
    pExpr = pTerm->pExpr;
    if( (!(((pExpr)->flags&(0x000001))!=0) || pExpr->iRightJoinTable==iTab)
     && sqlite3ExprImpliesExpr(pParse, pExpr, pWhere, iTab)
    ){
      return 1;
    }
  }
  return 0;
}
# 144139 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereLoopAddBtree(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq
){
  WhereInfo *pWInfo;
  Index *pProbe;
  Index sPk;
  LogEst aiRowEstPk[2];
  i16 aiColumnPk = -1;
  SrcList *pTabList;
  struct SrcList_item *pSrc;
  WhereLoop *pNew;
  int rc = 0;
  int iSortIdx = 1;
  int b;
  LogEst rSize;
  LogEst rLogSize;
  WhereClause *pWC;
  Table *pTab;

  pNew = pBuilder->pNew;
  pWInfo = pBuilder->pWInfo;
  pTabList = pWInfo->pTabList;
  pSrc = pTabList->a + pNew->iTab;
  pTab = pSrc->pTab;
  pWC = pBuilder->pWC;
  ((void)0);

  if( pSrc->pIBIndex ){

    pProbe = pSrc->pIBIndex;
  }else if( !(((pTab)->tabFlags & 0x0020)==0) ){
    pProbe = pTab->pIndex;
  }else{




    Index *pFirst;
    memset(&sPk, 0, sizeof(Index));
    sPk.nKeyCol = 1;
    sPk.nColumn = 1;
    sPk.aiColumn = &aiColumnPk;
    sPk.aiRowLogEst = aiRowEstPk;
    sPk.onError = 5;
    sPk.pTable = pTab;
    sPk.szIdxRow = pTab->szTabRow;
    sPk.idxType = 3;
    aiRowEstPk[0] = pTab->nRowLogEst;
    aiRowEstPk[1] = 0;
    pFirst = pSrc->pTab->pIndex;
    if( pSrc->fg.notIndexed==0 ){


      sPk.pNext = pFirst;
    }
    pProbe = &sPk;
  }
  rSize = pTab->nRowLogEst;
  rLogSize = estLog(rSize);



  if( !pBuilder->pOrSet
   && (pWInfo->wctrlFlags & 0x0020)==0
   && (pWInfo->pParse->db->flags & 0x00008000)!=0
   && pSrc->pIBIndex==0
   && !pSrc->fg.notIndexed
   && (((pTab)->tabFlags & 0x0020)==0)
   && !pSrc->fg.isCorrelated
   && !pSrc->fg.isRecursive
  ){

    WhereTerm *pTerm;
    WhereTerm *pWCEnd = pWC->a + pWC->nTerm;
    for(pTerm=pWC->a; rc==0 && pTerm<pWCEnd; pTerm++){
      if( pTerm->prereqRight & pNew->maskSelf ) continue;
      if( termCanDriveIndex(pTerm, pSrc, 0) ){
        pNew->u.btree.nEq = 1;
        pNew->nSkip = 0;
        pNew->u.btree.pIndex = 0;
        pNew->nLTerm = 1;
        pNew->aLTerm[0] = pTerm;
# 144230 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        pNew->rSetup = rLogSize + rSize;
        if( pTab->pSelect==0 && (pTab->tabFlags & 0x0002)==0 ){
          pNew->rSetup += 28;
        }else{
          pNew->rSetup -= 10;
        }
        ;
        if( pNew->rSetup<0 ) pNew->rSetup = 0;




        pNew->nOut = 43; ((void)0);
        pNew->rRun = sqlite3LogEstAdd(rLogSize,pNew->nOut);
        pNew->wsFlags = 0x00004000;
        pNew->prereq = mPrereq | pTerm->prereqRight;
        rc = whereLoopInsert(pBuilder, pNew);
      }
    }
  }




  for(; rc==0 && pProbe;
      pProbe=(pSrc->pIBIndex ? 0 : pProbe->pNext), iSortIdx++
  ){
    if( pProbe->pPartIdxWhere!=0
     && !whereUsablePartialIndex(pSrc->iCursor, pWC, pProbe->pPartIdxWhere) ){
      ;
      continue;
    }
    if( pProbe->bNoQuery ) continue;
    rSize = pProbe->aiRowLogEst[0];
    pNew->u.btree.nEq = 0;
    pNew->u.btree.nBtm = 0;
    pNew->u.btree.nTop = 0;
    pNew->nSkip = 0;
    pNew->nLTerm = 0;
    pNew->iSortIdx = 0;
    pNew->rSetup = 0;
    pNew->prereq = mPrereq;
    pNew->nOut = rSize;
    pNew->u.btree.pIndex = pProbe;
    b = indexMightHelpWithOrderBy(pBuilder, pProbe, pSrc->iCursor);

    ((void)0);
    if( pProbe->idxType==3 ){

      pNew->wsFlags = 0x00000100;


      pNew->iSortIdx = b ? iSortIdx : 0;

      pNew->rRun = rSize + 16;
      ;
      whereLoopOutputAdjust(pWC, pNew, rSize);
      rc = whereLoopInsert(pBuilder, pNew);
      pNew->nOut = rSize;
      if( rc ) break;
    }else{
      Bitmask m;
      if( pProbe->isCovering ){
        pNew->wsFlags = 0x00000040 | 0x00000200;
        m = 0;
      }else{
        m = pSrc->colUsed & pProbe->colNotIdxed;
        pNew->wsFlags = (m==0) ? (0x00000040|0x00000200) : 0x00000200;
      }


      if( b
       || !(((pTab)->tabFlags & 0x0020)==0)
       || pProbe->pPartIdxWhere!=0
       || ( m==0
         && pProbe->bUnordered==0
         && (pProbe->szIdxRow<pTab->szTabRow)
         && (pWInfo->wctrlFlags & 0x0004)==0
         && sqlite3Config.bUseCis
         && (((pWInfo->pParse->db)->dbOptFlags&(0x0020))==0)
          )
      ){
        pNew->iSortIdx = b ? iSortIdx : 0;




        pNew->rRun = rSize + 1 + (15*pProbe->szIdxRow)/pTab->szTabRow;
        if( m!=0 ){





          LogEst nLookup = rSize + 16;
          int ii;
          int iCur = pSrc->iCursor;
          WhereClause *pWC2 = &pWInfo->sWC;
          for(ii=0; ii<pWC2->nTerm; ii++){
            WhereTerm *pTerm = &pWC2->a[ii];
            if( !sqlite3ExprCoveredByIndex(pTerm->pExpr, iCur, pProbe) ){
              break;
            }


            if( pTerm->truthProb<=0 ){
              nLookup += pTerm->truthProb;
            }else{
              nLookup--;
              if( pTerm->eOperator & (0x0002|0x0080) ) nLookup -= 19;
            }
          }

          pNew->rRun = sqlite3LogEstAdd(pNew->rRun, nLookup);
        }
        ;
        whereLoopOutputAdjust(pWC, pNew, rSize);
        rc = whereLoopInsert(pBuilder, pNew);
        pNew->nOut = rSize;
        if( rc ) break;
      }
    }

    pBuilder->bldFlags = 0;
    rc = whereLoopAddBtreeIndex(pBuilder, pSrc, pProbe, 0);
    if( pBuilder->bldFlags==0x0001 ){




      pTab->tabFlags |= 0x0100;
    }





  }
  return rc;
}
# 144393 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereLoopAddVirtualOne(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq,
  Bitmask mUsable,
  u16 mExclude,
  sqlite3_index_info *pIdxInfo,
  u16 mNoOmit,
  int *pbIn
){
  WhereClause *pWC = pBuilder->pWC;
  struct sqlite3_index_constraint *pIdxCons;
  struct sqlite3_index_constraint_usage *pUsage = pIdxInfo->aConstraintUsage;
  int i;
  int mxTerm;
  int rc = 0;
  WhereLoop *pNew = pBuilder->pNew;
  Parse *pParse = pBuilder->pWInfo->pParse;
  struct SrcList_item *pSrc = &pBuilder->pWInfo->pTabList->a[pNew->iTab];
  int nConstraint = pIdxInfo->nConstraint;

  ((void)0);
  *pbIn = 0;
  pNew->prereq = mPrereq;



  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
  for(i=0; i<nConstraint; i++, pIdxCons++){
    WhereTerm *pTerm = &pWC->a[pIdxCons->iTermOffset];
    pIdxCons->usable = 0;
    if( (pTerm->prereqRight & mUsable)==pTerm->prereqRight
     && (pTerm->eOperator & mExclude)==0
    ){
      pIdxCons->usable = 1;
    }
  }


  memset(pUsage, 0, sizeof(pUsage[0])*nConstraint);
  ((void)0);
  pIdxInfo->idxStr = 0;
  pIdxInfo->idxNum = 0;
  pIdxInfo->orderByConsumed = 0;
  pIdxInfo->estimatedCost = (1e99) / (double)2;
  pIdxInfo->estimatedRows = 25;
  pIdxInfo->idxFlags = 0;
  pIdxInfo->colUsed = (sqlite3_int64)pSrc->colUsed;


  rc = vtabBestIndex(pParse, pSrc->pTab, pIdxInfo);
  if( rc ){
    if( rc==19 ){




      ;
      return 0;
    }
    return rc;
  }

  mxTerm = -1;
  ((void)0);
  for(i=0; i<nConstraint; i++) pNew->aLTerm[i] = 0;
  pNew->u.vtab.omitMask = 0;
  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;
  for(i=0; i<nConstraint; i++, pIdxCons++){
    int iTerm;
    if( (iTerm = pUsage[i].argvIndex - 1)>=0 ){
      WhereTerm *pTerm;
      int j = pIdxCons->iTermOffset;
      if( iTerm>=nConstraint
       || j<0
       || j>=pWC->nTerm
       || pNew->aLTerm[iTerm]!=0
       || pIdxCons->usable==0
      ){
        sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pTab->zName);
        ;
        return 1;
      }
      ;
      ;
      ;
      pTerm = &pWC->a[j];
      pNew->prereq |= pTerm->prereqRight;
      ((void)0);
      pNew->aLTerm[iTerm] = pTerm;
      if( iTerm>mxTerm ) mxTerm = iTerm;
      ;
      ;
      if( iTerm<16 && pUsage[i].omit ) pNew->u.vtab.omitMask |= 1<<iTerm;
      if( (pTerm->eOperator & 0x0001)!=0 ){





        pIdxInfo->orderByConsumed = 0;
        pIdxInfo->idxFlags &= ~1;
        *pbIn = 1; ((void)0);
      }
    }
  }
  pNew->u.vtab.omitMask &= ~mNoOmit;

  pNew->nLTerm = mxTerm+1;
  for(i=0; i<=mxTerm; i++){
    if( pNew->aLTerm[i]==0 ){


      sqlite3ErrorMsg(pParse,"%s.xBestIndex malfunction",pSrc->pTab->zName);
      ;
      return 1;
    }
  }
  ((void)0);
  pNew->u.vtab.idxNum = pIdxInfo->idxNum;
  pNew->u.vtab.needFree = pIdxInfo->needToFreeIdxStr;
  pIdxInfo->needToFreeIdxStr = 0;
  pNew->u.vtab.idxStr = pIdxInfo->idxStr;
  pNew->u.vtab.isOrdered = (i8)(pIdxInfo->orderByConsumed ?
      pIdxInfo->nOrderBy : 0);
  pNew->rSetup = 0;
  pNew->rRun = sqlite3LogEstFromDouble(pIdxInfo->estimatedCost);
  pNew->nOut = sqlite3LogEst(pIdxInfo->estimatedRows);



  if( pIdxInfo->idxFlags & 1 ){
    pNew->wsFlags |= 0x00001000;
  }else{
    pNew->wsFlags &= ~0x00001000;
  }
  rc = whereLoopInsert(pBuilder, pNew);
  if( pNew->u.vtab.needFree ){
    sqlite3_free(pNew->u.vtab.idxStr);
    pNew->u.vtab.needFree = 0;
  }
 

                                                                 ;

  return rc;
}
# 144547 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_vtab_collation(sqlite3_index_info *pIdxInfo, int iCons){
  HiddenIndexInfo *pHidden = (HiddenIndexInfo*)&pIdxInfo[1];
  const char *zRet = 0;
  if( iCons>=0 && iCons<pIdxInfo->nConstraint ){
    CollSeq *pC = 0;
    int iTerm = pIdxInfo->aConstraint[iCons].iTermOffset;
    Expr *pX = pHidden->pWC->a[iTerm].pExpr;
    if( pX->pLeft ){
      pC = sqlite3BinaryCompareCollSeq(pHidden->pParse, pX->pLeft, pX->pRight);
    }
    zRet = (pC ? pC->zName : sqlite3StrBINARY);
  }
  return zRet;
}
# 144587 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereLoopAddVirtual(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq,
  Bitmask mUnusable
){
  int rc = 0;
  WhereInfo *pWInfo;
  Parse *pParse;
  WhereClause *pWC;
  struct SrcList_item *pSrc;
  sqlite3_index_info *p;
  int nConstraint;
  int bIn;
  WhereLoop *pNew;
  Bitmask mBest;
  u16 mNoOmit;

  ((void)0);
  pWInfo = pBuilder->pWInfo;
  pParse = pWInfo->pParse;
  pWC = pBuilder->pWC;
  pNew = pBuilder->pNew;
  pSrc = &pWInfo->pTabList->a[pNew->iTab];
  ((void)0);
  p = allocateIndexInfo(pParse, pWC, mUnusable, pSrc, pBuilder->pOrderBy,
      &mNoOmit);
  if( p==0 ) return 7;
  pNew->rSetup = 0;
  pNew->wsFlags = 0x00000400;
  pNew->nLTerm = 0;
  pNew->u.vtab.needFree = 0;
  nConstraint = p->nConstraint;
  if( whereLoopResize(pParse->db, pNew, nConstraint) ){
    sqlite3DbFree(pParse->db, p);
    return 7;
  }


  ;
  ;
  rc = whereLoopAddVirtualOne(pBuilder, mPrereq, ((Bitmask)-1), 0, p, mNoOmit, &bIn);






  if( rc==0 && ((mBest = (pNew->prereq & ~mPrereq))!=0 || bIn) ){
    int seenZero = 0;
    int seenZeroNoIN = 0;
    Bitmask mPrev = 0;
    Bitmask mBestNoIn = 0;



    if( bIn ){
      ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, ((Bitmask)-1), 0x0001, p, mNoOmit, &bIn);
      ((void)0);
      mBestNoIn = pNew->prereq & ~mPrereq;
      if( mBestNoIn==0 ){
        seenZero = 1;
        seenZeroNoIN = 1;
      }
    }



    while( rc==0 ){
      int i;
      Bitmask mNext = ((Bitmask)-1);
      ((void)0);
      for(i=0; i<nConstraint; i++){
        Bitmask mThis = (
            pWC->a[p->aConstraint[i].iTermOffset].prereqRight & ~mPrereq
        );
        if( mThis>mPrev && mThis<mNext ) mNext = mThis;
      }
      mPrev = mNext;
      if( mNext==((Bitmask)-1) ) break;
      if( mNext==mBest || mNext==mBestNoIn ) continue;
     
                                                                     ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, mNext|mPrereq, 0, p, mNoOmit, &bIn);
      if( pNew->prereq==mPrereq ){
        seenZero = 1;
        if( bIn==0 ) seenZeroNoIN = 1;
      }
    }




    if( rc==0 && seenZero==0 ){
      ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, mPrereq, 0, p, mNoOmit, &bIn);
      if( bIn==0 ) seenZeroNoIN = 1;
    }




    if( rc==0 && seenZeroNoIN==0 ){
      ;
      rc = whereLoopAddVirtualOne(
          pBuilder, mPrereq, mPrereq, 0x0001, p, mNoOmit, &bIn);
    }
  }

  if( p->needToFreeIdxStr ) sqlite3_free(p->idxStr);
  sqlite3DbFreeNN(pParse->db, p);
  ;
  return rc;
}






static int whereLoopAddOr(
  WhereLoopBuilder *pBuilder,
  Bitmask mPrereq,
  Bitmask mUnusable
){
  WhereInfo *pWInfo = pBuilder->pWInfo;
  WhereClause *pWC;
  WhereLoop *pNew;
  WhereTerm *pTerm, *pWCEnd;
  int rc = 0;
  int iCur;
  WhereClause tempWC;
  WhereLoopBuilder sSubBuild;
  WhereOrSet sSum, sCur;
  struct SrcList_item *pItem;

  pWC = pBuilder->pWC;
  pWCEnd = pWC->a + pWC->nTerm;
  pNew = pBuilder->pNew;
  memset(&sSum, 0, sizeof(sSum));
  pItem = pWInfo->pTabList->a + pNew->iTab;
  iCur = pItem->iCursor;

  for(pTerm=pWC->a; pTerm<pWCEnd && rc==0; pTerm++){
    if( (pTerm->eOperator & 0x0200)!=0
     && (pTerm->u.pOrInfo->indexable & pNew->maskSelf)!=0
    ){
      WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;
      WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];
      WhereTerm *pOrTerm;
      int once = 1;
      int i, j;

      sSubBuild = *pBuilder;
      sSubBuild.pOrderBy = 0;
      sSubBuild.pOrSet = &sCur;

      ;
      for(pOrTerm=pOrWC->a; pOrTerm<pOrWCEnd; pOrTerm++){
        if( (pOrTerm->eOperator & 0x0400)!=0 ){
          sSubBuild.pWC = &pOrTerm->u.pAndInfo->wc;
        }else if( pOrTerm->leftCursor==iCur ){
          tempWC.pWInfo = pWC->pWInfo;
          tempWC.pOuter = pWC;
          tempWC.op = 44;
          tempWC.nTerm = 1;
          tempWC.a = pOrTerm;
          sSubBuild.pWC = &tempWC;
        }else{
          continue;
        }
        sCur.n = 0;
# 144770 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        if( ((pItem->pTab)->nModuleArg) ){
          rc = whereLoopAddVirtual(&sSubBuild, mPrereq, mUnusable);
        }else

        {
          rc = whereLoopAddBtree(&sSubBuild, mPrereq);
        }
        if( rc==0 ){
          rc = whereLoopAddOr(&sSubBuild, mPrereq, mUnusable);
        }
        ((void)0);
        if( sCur.n==0 ){
          sSum.n = 0;
          break;
        }else if( once ){
          whereOrMove(&sSum, &sCur);
          once = 0;
        }else{
          WhereOrSet sPrev;
          whereOrMove(&sPrev, &sSum);
          sSum.n = 0;
          for(i=0; i<sPrev.n; i++){
            for(j=0; j<sCur.n; j++){
              whereOrInsert(&sSum, sPrev.a[i].prereq | sCur.a[j].prereq,
                            sqlite3LogEstAdd(sPrev.a[i].rRun, sCur.a[j].rRun),
                            sqlite3LogEstAdd(sPrev.a[i].nOut, sCur.a[j].nOut));
            }
          }
        }
      }
      pNew->nLTerm = 1;
      pNew->aLTerm[0] = pTerm;
      pNew->wsFlags = 0x00002000;
      pNew->rSetup = 0;
      pNew->iSortIdx = 0;
      memset(&pNew->u, 0, sizeof(pNew->u));
      for(i=0; rc==0 && i<sSum.n; i++){
# 144819 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        pNew->rRun = sSum.a[i].rRun + 1;
        pNew->nOut = sSum.a[i].nOut;
        pNew->prereq = sSum.a[i].prereq;
        rc = whereLoopInsert(pBuilder, pNew);
      }
      ;
    }
  }
  return rc;
}




static int whereLoopAddAll(WhereLoopBuilder *pBuilder){
  WhereInfo *pWInfo = pBuilder->pWInfo;
  Bitmask mPrereq = 0;
  Bitmask mPrior = 0;
  int iTab;
  SrcList *pTabList = pWInfo->pTabList;
  struct SrcList_item *pItem;
  struct SrcList_item *pEnd = &pTabList->a[pWInfo->nLevel];
  sqlite3 *db = pWInfo->pParse->db;
  int rc = 0;
  WhereLoop *pNew;
  u8 priorJointype = 0;


  pNew = pBuilder->pNew;
  whereLoopInit(pNew);
  pBuilder->iPlanLimit = 20000;
  for(iTab=0, pItem=pTabList->a; pItem<pEnd; iTab++, pItem++){
    Bitmask mUnusable = 0;
    pNew->iTab = iTab;
    pBuilder->iPlanLimit += 1000;
    pNew->maskSelf = sqlite3WhereGetMask(&pWInfo->sMaskSet, pItem->iCursor);
    if( ((pItem->fg.jointype|priorJointype) & (0x0008|0x0002))!=0 ){


      mPrereq = mPrior;
    }
    priorJointype = pItem->fg.jointype;

    if( ((pItem->pTab)->nModuleArg) ){
      struct SrcList_item *p;
      for(p=&pItem[1]; p<pEnd; p++){
        if( mUnusable || (p->fg.jointype & (0x0008|0x0002)) ){
          mUnusable |= sqlite3WhereGetMask(&pWInfo->sMaskSet, p->iCursor);
        }
      }
      rc = whereLoopAddVirtual(pBuilder, mPrereq, mUnusable);
    }else

    {
      rc = whereLoopAddBtree(pBuilder, mPrereq);
    }
    if( rc==0 && pBuilder->pWC->hasOr ){
      rc = whereLoopAddOr(pBuilder, mPrereq, mUnusable);
    }
    mPrior |= pNew->maskSelf;
    if( rc || db->mallocFailed ){
      if( rc==101 ){

        sqlite3_log(28, "abbreviated query algorithm search");
        rc = 0;
      }else{
        break;
      }
    }
  }

  whereLoopClear(db, pNew);
  return rc;
}
# 144911 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static i8 wherePathSatisfiesOrderBy(
  WhereInfo *pWInfo,
  ExprList *pOrderBy,
  WherePath *pPath,
  u16 wctrlFlags,
  u16 nLoop,
  WhereLoop *pLast,
  Bitmask *pRevMask
){
  u8 revSet;
  u8 rev;
  u8 revIdx;
  u8 isOrderDistinct;
  u8 distinctColumns;
  u8 isMatch;
  u16 eqOpMask;
  u16 nKeyCol;
  u16 nColumn;
  u16 nOrderBy;
  int iLoop;
  int i, j;
  int iCur;
  int iColumn;
  WhereLoop *pLoop = 0;
  WhereTerm *pTerm;
  Expr *pOBExpr;
  CollSeq *pColl;
  Index *pIndex;
  sqlite3 *db = pWInfo->pParse->db;
  Bitmask obSat = 0;
  Bitmask obDone;
  Bitmask orderDistinctMask;
  Bitmask ready;
# 144967 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( nLoop && (((db)->dbOptFlags&(0x0040))!=0) ) return 0;

  nOrderBy = pOrderBy->nExpr;
  ;
  if( nOrderBy>((int)(sizeof(Bitmask)*8))-1 ) return 0;
  isOrderDistinct = 1;
  obDone = (((Bitmask)1)<<(nOrderBy))-1;
  orderDistinctMask = 0;
  ready = 0;
  eqOpMask = 0x0002 | 0x0080 | 0x0100;
  if( wctrlFlags & 0x0800 ) eqOpMask |= 0x0001;
  for(iLoop=0; isOrderDistinct && obSat<obDone && iLoop<=nLoop; iLoop++){
    if( iLoop>0 ) ready |= pLoop->maskSelf;
    if( iLoop<nLoop ){
      pLoop = pPath->aLoop[iLoop];
      if( wctrlFlags & 0x0800 ) continue;
    }else{
      pLoop = pLast;
    }
    if( pLoop->wsFlags & 0x00000400 ){
      if( pLoop->u.vtab.isOrdered ) obSat = obDone;
      break;
    }else if( wctrlFlags & 0x0080 ){
      pLoop->u.btree.nDistinctCol = 0;
    }
    iCur = pWInfo->pTabList->a[pLoop->iTab].iCursor;






    for(i=0; i<nOrderBy; i++){
      if( (((Bitmask)1)<<(i)) & obSat ) continue;
      pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
      if( pOBExpr->op!=162 ) continue;
      if( pOBExpr->iTable!=iCur ) continue;
      pTerm = sqlite3WhereFindTerm(&pWInfo->sWC, iCur, pOBExpr->iColumn,
                       ~ready, eqOpMask, 0);
      if( pTerm==0 ) continue;
      if( pTerm->eOperator==0x0001 ){



        ((void)0);
        for(j=0; j<pLoop->nLTerm && pTerm!=pLoop->aLTerm[j]; j++){}
        if( j>=pLoop->nLTerm ) continue;
      }
      if( (pTerm->eOperator&(0x0002|0x0080))!=0 && pOBExpr->iColumn>=0 ){
        if( sqlite3ExprCollSeqMatch(pWInfo->pParse,
                  pOrderBy->a[i].pExpr, pTerm->pExpr)==0 ){
          continue;
        }
        ;
      }
      obSat |= (((Bitmask)1)<<(i));
    }

    if( (pLoop->wsFlags & 0x00001000)==0 ){
      if( pLoop->wsFlags & 0x00000100 ){
        pIndex = 0;
        nKeyCol = 0;
        nColumn = 1;
      }else if( (pIndex = pLoop->u.btree.pIndex)==0 || pIndex->bUnordered ){
        return 0;
      }else{
        nKeyCol = pIndex->nKeyCol;
        nColumn = pIndex->nColumn;
        ((void)0);
        ((void)0)
                                                       ;
        isOrderDistinct = ((pIndex)->onError!=0)
                          && (pLoop->wsFlags & 0x00008000)==0;
      }




      rev = revSet = 0;
      distinctColumns = 0;
      for(j=0; j<nColumn; j++){
        u8 bOnce = 1;

        ((void)0)

         ;
        if( j<pLoop->u.btree.nEq && j>=pLoop->nSkip ){
          u16 eOp = pLoop->aLTerm[j]->eOperator;
# 145069 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          if( (eOp & eqOpMask)!=0 ){
            if( eOp & (0x0100|0x0080) ){
              ;
              ;
              ;
              isOrderDistinct = 0;
            }
            continue;
          }else if( (eOp & 0x0001) ){




            Expr *pX = pLoop->aLTerm[j]->pExpr;
            for(i=j+1; i<pLoop->u.btree.nEq; i++){
              if( pLoop->aLTerm[i]->pExpr==pX ){
                ((void)0);
                bOnce = 0;
                break;
              }
            }
          }
        }




        if( pIndex ){
          iColumn = pIndex->aiColumn[j];
          revIdx = pIndex->aSortOrder[j] & 0x01;
          if( iColumn==pIndex->pTable->iPKey ) iColumn = (-1);
        }else{
          iColumn = (-1);
          revIdx = 0;
        }




        if( isOrderDistinct
         && iColumn>=0
         && j>=pLoop->u.btree.nEq
         && pIndex->pTable->aCol[iColumn].notNull==0
        ){
          isOrderDistinct = 0;
        }




        isMatch = 0;
        for(i=0; bOnce && i<nOrderBy; i++){
          if( (((Bitmask)1)<<(i)) & obSat ) continue;
          pOBExpr = sqlite3ExprSkipCollateAndLikely(pOrderBy->a[i].pExpr);
          ;
          ;
          if( (wctrlFlags & (0x0040|0x0080))==0 ) bOnce = 0;
          if( iColumn>=(-1) ){
            if( pOBExpr->op!=162 ) continue;
            if( pOBExpr->iTable!=iCur ) continue;
            if( pOBExpr->iColumn!=iColumn ) continue;
          }else{
            Expr *pIdxExpr = pIndex->aColExpr->a[j].pExpr;
            if( sqlite3ExprCompareSkip(pOBExpr, pIdxExpr, iCur) ){
              continue;
            }
          }
          if( iColumn!=(-1) ){
            pColl = sqlite3ExprNNCollSeq(pWInfo->pParse, pOrderBy->a[i].pExpr);
            if( sqlite3StrICmp(pColl->zName, pIndex->azColl[j])!=0 ) continue;
          }
          if( wctrlFlags & 0x0080 ){
            pLoop->u.btree.nDistinctCol = j+1;
          }
          isMatch = 1;
          break;
        }
        if( isMatch && (wctrlFlags & 0x0040)==0 ){


          if( revSet ){
            if( (rev ^ revIdx)!=(pOrderBy->a[i].sortFlags&0x01) ){
              isMatch = 0;
            }
          }else{
            rev = revIdx ^ (pOrderBy->a[i].sortFlags & 0x01);
            if( rev ) *pRevMask |= (((Bitmask)1)<<(iLoop));
            revSet = 1;
          }
        }
        if( isMatch && (pOrderBy->a[i].sortFlags & 0x02) ){
          if( j==pLoop->u.btree.nEq ){
            pLoop->wsFlags |= 0x00080000;
          }else{
            isMatch = 0;
          }
        }
        if( isMatch ){
          if( iColumn==(-1) ){
            ;
            distinctColumns = 1;
          }
          obSat |= (((Bitmask)1)<<(i));
        }else{

          if( j==0 || j<nKeyCol ){
            ;
            isOrderDistinct = 0;
          }
          break;
        }
      }
      if( distinctColumns ){
        ;
        isOrderDistinct = 1;
      }
    }


    if( isOrderDistinct ){
      orderDistinctMask |= pLoop->maskSelf;
      for(i=0; i<nOrderBy; i++){
        Expr *p;
        Bitmask mTerm;
        if( (((Bitmask)1)<<(i)) & obSat ) continue;
        p = pOrderBy->a[i].pExpr;
        mTerm = sqlite3WhereExprUsage(&pWInfo->sMaskSet,p);
        if( mTerm==0 && !sqlite3ExprIsConstant(p) ) continue;
        if( (mTerm&~orderDistinctMask)==0 ){
          obSat |= (((Bitmask)1)<<(i));
        }
      }
    }
  }
  if( obSat==obDone ) return (i8)nOrderBy;
  if( !isOrderDistinct ){
    for(i=nOrderBy-1; i>0; i--){
      Bitmask m = (((Bitmask)1)<<(i)) - 1;
      if( (obSat&m)==m ) return i;
    }
    return 0;
  }
  return -1;
}
# 145238 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WhereIsSorted(WhereInfo *pWInfo){
  ((void)0);
  ((void)0);
  return pWInfo->sorted;
}
# 145261 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static LogEst whereSortingCost(
  WhereInfo *pWInfo,
  LogEst nRow,
  int nOrderBy,
  int nSorted
){
# 145280 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  LogEst rScale, rSortCost;
  ((void)0);
  rScale = sqlite3LogEst((nOrderBy-nSorted)*100/nOrderBy) - 66;
  rSortCost = nRow + rScale + 16;



  if( (pWInfo->wctrlFlags & 0x4000)!=0 && pWInfo->iLimit<nRow ){
    nRow = pWInfo->iLimit;
  }
  rSortCost += estLog(nRow);
  return rSortCost;
}
# 145306 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int wherePathSolver(WhereInfo *pWInfo, LogEst nRowEst){
  int mxChoice;
  int nLoop;
  Parse *pParse;
  sqlite3 *db;
  int iLoop;
  int ii, jj;
  int mxI = 0;
  int nOrderBy;
  LogEst mxCost = 0;
  LogEst mxUnsorted = 0;
  int nTo, nFrom;
  WherePath *aFrom;
  WherePath *aTo;
  WherePath *pFrom;
  WherePath *pTo;
  WhereLoop *pWLoop;
  WhereLoop **pX;
  LogEst *aSortCost = 0;
  char *pSpace;
  int nSpace;

  pParse = pWInfo->pParse;
  db = pParse->db;
  nLoop = pWInfo->nLevel;



  mxChoice = (nLoop<=1) ? 1 : (nLoop==2 ? 5 : 10);
  ((void)0);
  ;






  if( pWInfo->pOrderBy==0 || nRowEst==0 ){
    nOrderBy = 0;
  }else{
    nOrderBy = pWInfo->pOrderBy->nExpr;
  }


  nSpace = (sizeof(WherePath)+sizeof(WhereLoop*)*nLoop)*mxChoice*2;
  nSpace += sizeof(LogEst) * nOrderBy;
  pSpace = sqlite3DbMallocRawNN(db, nSpace);
  if( pSpace==0 ) return 7;
  aTo = (WherePath*)pSpace;
  aFrom = aTo+mxChoice;
  memset(aFrom, 0, sizeof(aFrom[0]));
  pX = (WhereLoop**)(aFrom+mxChoice);
  for(ii=mxChoice*2, pFrom=aTo; ii>0; ii--, pFrom++, pX += nLoop){
    pFrom->aLoop = pX;
  }
  if( nOrderBy ){






    aSortCost = (LogEst*)pX;
    memset(aSortCost, 0, sizeof(LogEst) * nOrderBy);
  }
  ((void)0);
  ((void)0);






  aFrom[0].nRow = ((pParse->nQueryLoop)<(48)?(pParse->nQueryLoop):(48)); ((void)0);
  nFrom = 1;
  ((void)0);
  if( nOrderBy ){






    aFrom[0].isOrdered = nLoop>0 ? -1 : nOrderBy;
  }




  for(iLoop=0; iLoop<nLoop; iLoop++){
    nTo = 0;
    for(ii=0, pFrom=aFrom; ii<nFrom; ii++, pFrom++){
      for(pWLoop=pWInfo->pLoops; pWLoop; pWLoop=pWLoop->pNextLoop){
        LogEst nOut;
        LogEst rCost;
        LogEst rUnsorted;
        i8 isOrdered = pFrom->isOrdered;
        Bitmask maskNew;
        Bitmask revMask = 0;

        if( (pWLoop->prereq & ~pFrom->maskLoop)!=0 ) continue;
        if( (pWLoop->maskSelf & pFrom->maskLoop)!=0 ) continue;
        if( (pWLoop->wsFlags & 0x00004000)!=0 && pFrom->nRow<3 ){




          ((void)0);
          continue;
        }



        rUnsorted = sqlite3LogEstAdd(pWLoop->rSetup,pWLoop->rRun + pFrom->nRow);
        rUnsorted = sqlite3LogEstAdd(rUnsorted, pFrom->rUnsorted);
        nOut = pFrom->nRow + pWLoop->nOut;
        maskNew = pFrom->maskLoop | pWLoop->maskSelf;
        if( isOrdered<0 ){
          isOrdered = wherePathSatisfiesOrderBy(pWInfo,
                       pWInfo->pOrderBy, pFrom, pWInfo->wctrlFlags,
                       iLoop, pWLoop, &revMask);
        }else{
          revMask = pFrom->revLoop;
        }
        if( isOrdered>=0 && isOrdered<nOrderBy ){
          if( aSortCost[isOrdered]==0 ){
            aSortCost[isOrdered] = whereSortingCost(
                pWInfo, nRowEst, nOrderBy, isOrdered
            );
          }




          rCost = sqlite3LogEstAdd(rUnsorted, aSortCost[isOrdered]) + 5;

         


                                 ;
        }else{
          rCost = rUnsorted;
          rUnsorted -= 2;
        }
# 145462 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        for(jj=0, pTo=aTo; jj<nTo; jj++, pTo++){
          if( pTo->maskLoop==maskNew
           && ((pTo->isOrdered^isOrdered)&0x80)==0
          ){
            ;
            break;
          }
        }
        if( jj>=nTo ){

          if( nTo>=mxChoice
           && (rCost>mxCost || (rCost==mxCost && rUnsorted>=mxUnsorted))
          ){
# 145485 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
            continue;
          }


          if( nTo<mxChoice ){

            jj = nTo++;
          }else{

            jj = mxI;
          }
          pTo = &aTo[jj];







        }else{
# 145513 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
          if( pTo->rCost<rCost
           || (pTo->rCost==rCost
               && (pTo->nRow<nOut
                   || (pTo->nRow==nOut && pTo->rUnsorted<=rUnsorted)
                  )
              )
          ){
# 145532 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
            ;
            continue;
          }
          ;
# 145549 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        }

        pTo->maskLoop = pFrom->maskLoop | pWLoop->maskSelf;
        pTo->revLoop = revMask;
        pTo->nRow = nOut;
        pTo->rCost = rCost;
        pTo->rUnsorted = rUnsorted;
        pTo->isOrdered = isOrdered;
        memcpy(pTo->aLoop, pFrom->aLoop, sizeof(WhereLoop*)*iLoop);
        pTo->aLoop[iLoop] = pWLoop;
        if( nTo>=mxChoice ){
          mxI = 0;
          mxCost = aTo[0].rCost;
          mxUnsorted = aTo[0].nRow;
          for(jj=1, pTo=&aTo[1]; jj<mxChoice; jj++, pTo++){
            if( pTo->rCost>mxCost
             || (pTo->rCost==mxCost && pTo->rUnsorted>mxUnsorted)
            ){
              mxCost = pTo->rCost;
              mxUnsorted = pTo->rUnsorted;
              mxI = jj;
            }
          }
        }
      }
    }
# 145593 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    pFrom = aTo;
    aTo = aFrom;
    aFrom = pFrom;
    nFrom = nTo;
  }

  if( nFrom==0 ){
    sqlite3ErrorMsg(pParse, "no query solution");
    sqlite3DbFreeNN(db, pSpace);
    return 1;
  }


  pFrom = aFrom;
  for(ii=1; ii<nFrom; ii++){
    if( pFrom->rCost>aFrom[ii].rCost ) pFrom = &aFrom[ii];
  }
  ((void)0);

  for(iLoop=0; iLoop<nLoop; iLoop++){
    WhereLevel *pLevel = pWInfo->a + iLoop;
    pLevel->pWLoop = pWLoop = pFrom->aLoop[iLoop];
    pLevel->iFrom = pWLoop->iTab;
    pLevel->iTabCur = pWInfo->pTabList->a[pLevel->iFrom].iCursor;
  }
  if( (pWInfo->wctrlFlags & 0x0100)!=0
   && (pWInfo->wctrlFlags & 0x0080)==0
   && pWInfo->eDistinct==0
   && nRowEst
  ){
    Bitmask notUsed;
    int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pResultSet, pFrom,
                 0x0080, nLoop-1, pFrom->aLoop[nLoop-1], &notUsed);
    if( rc==pWInfo->pResultSet->nExpr ){
      pWInfo->eDistinct = 2;
    }
  }
  pWInfo->bOrderedInnerLoop = 0;
  if( pWInfo->pOrderBy ){
    if( pWInfo->wctrlFlags & 0x0080 ){
      if( pFrom->isOrdered==pWInfo->pOrderBy->nExpr ){
        pWInfo->eDistinct = 2;
      }
    }else{
      pWInfo->nOBSat = pFrom->isOrdered;
      pWInfo->revMask = pFrom->revLoop;
      if( pWInfo->nOBSat<=0 ){
        pWInfo->nOBSat = 0;
        if( nLoop>0 ){
          u32 wsFlags = pFrom->aLoop[nLoop-1]->wsFlags;
          if( (wsFlags & 0x00001000)==0
           && (wsFlags&(0x00000100|0x00000004))!=(0x00000100|0x00000004)
          ){
            Bitmask m = 0;
            int rc = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy, pFrom,
                      0x0800, nLoop-1, pFrom->aLoop[nLoop-1], &m);
            ;
            ;
            if( rc==pWInfo->pOrderBy->nExpr ){
              pWInfo->bOrderedInnerLoop = 1;
              pWInfo->revMask = m;
            }
          }
        }
      }
    }
    if( (pWInfo->wctrlFlags & 0x0200)
        && pWInfo->nOBSat==pWInfo->pOrderBy->nExpr && nLoop>0
    ){
      Bitmask revMask = 0;
      int nOrder = wherePathSatisfiesOrderBy(pWInfo, pWInfo->pOrderBy,
          pFrom, 0, nLoop-1, pFrom->aLoop[nLoop-1], &revMask
      );
      ((void)0);
      if( nOrder==pWInfo->pOrderBy->nExpr ){
        pWInfo->sorted = 1;
        pWInfo->revMask = revMask;
      }
    }
  }


  pWInfo->nRowOut = pFrom->nRow;


  sqlite3DbFreeNN(db, pSpace);
  return 0;
}
# 145693 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int whereShortCut(WhereLoopBuilder *pBuilder){
  WhereInfo *pWInfo;
  struct SrcList_item *pItem;
  WhereClause *pWC;
  WhereTerm *pTerm;
  WhereLoop *pLoop;
  int iCur;
  int j;
  Table *pTab;
  Index *pIdx;

  pWInfo = pBuilder->pWInfo;
  if( pWInfo->wctrlFlags & 0x0020 ) return 0;
  ((void)0);
  pItem = pWInfo->pTabList->a;
  pTab = pItem->pTab;
  if( ((pTab)->nModuleArg) ) return 0;
  if( pItem->fg.isIndexedBy ) return 0;
  iCur = pItem->iCursor;
  pWC = &pWInfo->sWC;
  pLoop = pBuilder->pNew;
  pLoop->wsFlags = 0;
  pLoop->nSkip = 0;
  pTerm = sqlite3WhereFindTerm(pWC, iCur, -1, 0, 0x0002|0x0080, 0);
  if( pTerm ){
    ;
    pLoop->wsFlags = 0x00000001|0x00000100|0x00001000;
    pLoop->aLTerm[0] = pTerm;
    pLoop->nLTerm = 1;
    pLoop->u.btree.nEq = 1;

    pLoop->rRun = 33;
  }else{
    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){
      int opMask;
      ((void)0);
      if( !((pIdx)->onError!=0)
       || pIdx->pPartIdxWhere!=0
       || pIdx->nKeyCol>((int)(sizeof(pLoop->aLTermSpace)/sizeof(pLoop->aLTermSpace[0])))
      ) continue;
      opMask = pIdx->uniqNotNull ? (0x0002|0x0080) : 0x0002;
      for(j=0; j<pIdx->nKeyCol; j++){
        pTerm = sqlite3WhereFindTerm(pWC, iCur, j, 0, opMask, pIdx);
        if( pTerm==0 ) break;
        ;
        pLoop->aLTerm[j] = pTerm;
      }
      if( j!=pIdx->nKeyCol ) continue;
      pLoop->wsFlags = 0x00000001|0x00001000|0x00000200;
      if( pIdx->isCovering || (pItem->colUsed & pIdx->colNotIdxed)==0 ){
        pLoop->wsFlags |= 0x00000040;
      }
      pLoop->nLTerm = j;
      pLoop->u.btree.nEq = j;
      pLoop->u.btree.pIndex = pIdx;

      pLoop->rRun = 39;
      break;
    }
  }
  if( pLoop->wsFlags ){
    pLoop->nOut = (LogEst)1;
    pWInfo->a[0].pWLoop = pLoop;
    ((void)0);
    pLoop->maskSelf = 1;
    pWInfo->a[0].iTabCur = iCur;
    pWInfo->nRowOut = 1;
    if( pWInfo->pOrderBy ) pWInfo->nOBSat = pWInfo->pOrderBy->nExpr;
    if( pWInfo->wctrlFlags & 0x0100 ){
      pWInfo->eDistinct = 1;
    }



    return 1;
  }
  return 0;
}




static int exprNodeIsDeterministic(Walker *pWalker, Expr *pExpr){
  if( pExpr->op==167 && (((pExpr)->flags&(0x080000))!=0)==0 ){
    pWalker->eCode = 0;
    return 2;
  }
  return 0;
}






static int exprIsDeterministic(Expr *p){
  Walker w;
  memset(&w, 0, sizeof(w));
  w.eCode = 1;
  w.xExprCallback = exprNodeIsDeterministic;
  w.xSelectCallback = sqlite3SelectWalkFail;
  sqlite3WalkExpr(&w, p);
  return w.eCode;
}
# 145886 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static WhereInfo *sqlite3WhereBegin(
  Parse *pParse,
  SrcList *pTabList,
  Expr *pWhere,
  ExprList *pOrderBy,
  ExprList *pResultSet,
  u16 wctrlFlags,
  int iAuxArg

){
  int nByteWInfo;
  int nTabList;
  WhereInfo *pWInfo;
  Vdbe *v = pParse->pVdbe;
  Bitmask notReady;
  WhereLoopBuilder sWLB;
  WhereMaskSet *pMaskSet;
  WhereLevel *pLevel;
  WhereLoop *pLoop;
  int ii;
  sqlite3 *db;
  int rc;
  u8 bFordelete = 0;

  ((void)0)


    ;


  ((void)0)
                                                  ;


  db = pParse->db;
  memset(&sWLB, 0, sizeof(sWLB));


  ;
  if( pOrderBy && pOrderBy->nExpr>=((int)(sizeof(Bitmask)*8)) ) pOrderBy = 0;
  sWLB.pOrderBy = pOrderBy;



  if( (((db)->dbOptFlags&(0x0010))!=0) ){
    wctrlFlags &= ~0x0100;
  }




  ;
  if( pTabList->nSrc>((int)(sizeof(Bitmask)*8)) ){
    sqlite3ErrorMsg(pParse, "at most %d tables in a join", ((int)(sizeof(Bitmask)*8)));
    return 0;
  }






  nTabList = (wctrlFlags & 0x0020) ? 1 : pTabList->nSrc;
# 145957 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  nByteWInfo = (((sizeof(WhereInfo)+(nTabList-1)*sizeof(WhereLevel))+7)&~7);
  pWInfo = sqlite3DbMallocRawNN(db, nByteWInfo + sizeof(WhereLoop));
  if( db->mallocFailed ){
    sqlite3DbFree(db, pWInfo);
    pWInfo = 0;
    goto whereBeginError;
  }
  pWInfo->pParse = pParse;
  pWInfo->pTabList = pTabList;
  pWInfo->pOrderBy = pOrderBy;
  pWInfo->pWhere = pWhere;
  pWInfo->pResultSet = pResultSet;
  pWInfo->aiCurOnePass[0] = pWInfo->aiCurOnePass[1] = -1;
  pWInfo->nLevel = nTabList;
  pWInfo->iBreak = pWInfo->iContinue = sqlite3VdbeMakeLabel(pParse);
  pWInfo->wctrlFlags = wctrlFlags;
  pWInfo->iLimit = iAuxArg;
  pWInfo->savedNQueryLoop = pParse->nQueryLoop;
  memset(&pWInfo->nOBSat, 0,
         __builtin_offsetof(WhereInfo,sWC) - __builtin_offsetof(WhereInfo,nOBSat));
  memset(&pWInfo->a[0], 0, sizeof(WhereLoop)+nTabList*sizeof(WhereLevel));
  ((void)0);
  pMaskSet = &pWInfo->sMaskSet;
  sWLB.pWInfo = pWInfo;
  sWLB.pWC = &pWInfo->sWC;
  sWLB.pNew = (WhereLoop*)(((char*)pWInfo)+nByteWInfo);
  ((void)0);
  whereLoopInit(sWLB.pNew);







  (pMaskSet)->n=0;
  sqlite3WhereClauseInit(&pWInfo->sWC, pWInfo);
  sqlite3WhereSplit(&pWInfo->sWC, pWhere, 44);



  if( nTabList==0 ){
    if( pOrderBy ) pWInfo->nOBSat = pOrderBy->nExpr;
    if( wctrlFlags & 0x0100 ){
      pWInfo->eDistinct = 1;
    }
    sqlite3VdbeExplain (pParse, 0, "SCAN CONSTANT ROW");
  }else{
# 146019 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    ii = 0;
    do{
      createMask(pMaskSet, pTabList->a[ii].iCursor);
      sqlite3WhereTabFuncArgs(pParse, &pTabList->a[ii], &pWInfo->sWC);
    }while( (++ii)<pTabList->nSrc );
# 146034 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }


  sqlite3WhereExprAnalyze(pTabList, &pWInfo->sWC);
  if( db->mallocFailed ) goto whereBeginError;
# 146051 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  for(ii=0; ii<sWLB.pWC->nTerm; ii++){
    WhereTerm *pT = &sWLB.pWC->a[ii];
    if( pT->wtFlags & 0x02 ) continue;
    if( pT->prereqAll==0 && (nTabList==0 || exprIsDeterministic(pT->pExpr)) ){
      sqlite3ExprIfFalse(pParse, pT->pExpr, pWInfo->iBreak, 0x10);
      pT->wtFlags |= 0x04;
    }
  }

  if( wctrlFlags & 0x0100 ){
    if( isDistinctRedundant(pParse, pTabList, &pWInfo->sWC, pResultSet) ){

      pWInfo->eDistinct = 1;
    }else if( pOrderBy==0 ){

      pWInfo->wctrlFlags |= 0x0080;
      pWInfo->pOrderBy = pResultSet;
    }
  }
# 146095 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( nTabList!=1 || whereShortCut(&sWLB)==0 ){
    rc = whereLoopAddAll(&sWLB);
    if( rc ) goto whereBeginError;
# 146112 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    wherePathSolver(pWInfo, 0);
    if( db->mallocFailed ) goto whereBeginError;
    if( pWInfo->pOrderBy ){
       wherePathSolver(pWInfo, pWInfo->nRowOut+1);
       if( db->mallocFailed ) goto whereBeginError;
    }
  }
  if( pWInfo->pOrderBy==0 && (db->flags & 0x00001000)!=0 ){
     pWInfo->revMask = ((Bitmask)-1);
  }
  if( pParse->nErr || (db->mallocFailed) ){
    goto whereBeginError;
  }
# 146181 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  notReady = ~(Bitmask)0;
  if( pWInfo->nLevel>=2
   && pResultSet!=0
   && (((db)->dbOptFlags&(0x0100))==0)
  ){
    int i;
    Bitmask tabUsed = sqlite3WhereExprListUsage(pMaskSet, pResultSet);
    if( sWLB.pOrderBy ){
      tabUsed |= sqlite3WhereExprListUsage(pMaskSet, sWLB.pOrderBy);
    }
    for(i=pWInfo->nLevel-1; i>=1; i--){
      WhereTerm *pTerm, *pEnd;
      struct SrcList_item *pItem;
      pLoop = pWInfo->a[i].pWLoop;
      pItem = &pWInfo->pTabList->a[pLoop->iTab];
      if( (pItem->fg.jointype & 0x0008)==0 ) continue;
      if( (wctrlFlags & 0x0100)==0
       && (pLoop->wsFlags & 0x00001000)==0
      ){
        continue;
      }
      if( (tabUsed & pLoop->maskSelf)!=0 ) continue;
      pEnd = sWLB.pWC->a + sWLB.pWC->nTerm;
      for(pTerm=sWLB.pWC->a; pTerm<pEnd; pTerm++){
        if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){
          if( !(((pTerm->pExpr)->flags&(0x000001))!=0)
           || pTerm->pExpr->iRightJoinTable!=pItem->iCursor
          ){
            break;
          }
        }
      }
      if( pTerm<pEnd ) continue;
      ;
      notReady &= ~pLoop->maskSelf;
      for(pTerm=sWLB.pWC->a; pTerm<pEnd; pTerm++){
        if( (pTerm->prereqAll & pLoop->maskSelf)!=0 ){
          pTerm->wtFlags |= 0x04;
        }
      }
      if( i!=pWInfo->nLevel-1 ){
        int nByte = (pWInfo->nLevel-1-i) * sizeof(WhereLevel);
        memmove(&pWInfo->a[i], &pWInfo->a[i+1], nByte);
      }
      pWInfo->nLevel--;
      nTabList--;
    }
  }
  ;
  pWInfo->pParse->nQueryLoop += pWInfo->nRowOut;
# 146251 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  if( (wctrlFlags & 0x0004)!=0 ){
    int wsFlags = pWInfo->a[0].pWLoop->wsFlags;
    int bOnerow = (wsFlags & 0x00001000)!=0;
    ((void)0);
    if( bOnerow || (
        0!=(wctrlFlags & 0x0008)
     && !((pTabList->a[0].pTab)->nModuleArg)
     && (0==(wsFlags & 0x00002000) || (wctrlFlags & 0x0010))
    )){
      pWInfo->eOnePass = bOnerow ? 1 : 2;
      if( (((pTabList->a[0].pTab)->tabFlags & 0x0020)==0) && (wsFlags & 0x00000040) ){
        if( wctrlFlags & 0x0008 ){
          bFordelete = 0x08;
        }
        pWInfo->a[0].pWLoop->wsFlags = (wsFlags & ~0x00000040);
      }
    }
  }




  for(ii=0, pLevel=pWInfo->a; ii<nTabList; ii++, pLevel++){
    Table *pTab;
    int iDb;
    struct SrcList_item *pTabItem;

    pTabItem = &pTabList->a[pLevel->iFrom];
    pTab = pTabItem->pTab;
    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);
    pLoop = pLevel->pWLoop;
    if( (pTab->tabFlags & 0x0002)!=0 || pTab->pSelect ){

    }else

    if( (pLoop->wsFlags & 0x00000400)!=0 ){
      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);
      int iCur = pTabItem->iCursor;
      sqlite3VdbeAddOp4(v, 163, iCur, 0, 0, pVTab, (-12));
    }else if( ((pTab)->nModuleArg) ){

    }else

    if( (pLoop->wsFlags & 0x00000040)==0
         && (wctrlFlags & 0x0020)==0 ){
      int op = 97;
      if( pWInfo->eOnePass!=0 ){
        op = 98;
        pWInfo->aiCurOnePass[0] = pTabItem->iCursor;
      };
      sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);
      ((void)0);
      ;
      ;
      if( pWInfo->eOnePass==0 && pTab->nCol<((int)(sizeof(Bitmask)*8)) && (((pTab)->tabFlags & 0x0020)==0) ){
        Bitmask b = pTabItem->colUsed;
        int n = 0;
        for(; b; b=b>>1, n++){}
        sqlite3VdbeChangeP4(v, -1, ((void*)(long int)(n)), (-3));
        ((void)0);
      }





      {
        sqlite3VdbeChangeP5(v, bFordelete);
      }




    }else{
      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);
    }
    if( pLoop->wsFlags & 0x00000200 ){
      Index *pIx = pLoop->u.btree.pIndex;
      int iIndexCur;
      int op = 97;

      ((void)0);
      if( !(((pTab)->tabFlags & 0x0020)==0) && ((pIx)->idxType==2)
       && (wctrlFlags & 0x0020)!=0
      ){


        iIndexCur = pLevel->iTabCur;
        op = 0;
      }else if( pWInfo->eOnePass!=0 ){
        Index *pJ = pTabItem->pTab->pIndex;
        iIndexCur = iAuxArg;
        ((void)0);
        while( (pJ) && pJ!=pIx ){
          iIndexCur++;
          pJ = pJ->pNext;
        }
        op = 98;
        pWInfo->aiCurOnePass[1] = iIndexCur;
      }else if( iAuxArg && (wctrlFlags & 0x0020)!=0 ){
        iIndexCur = iAuxArg;
        op = 96;
      }else{
        iIndexCur = pParse->nTab++;
      }
      pLevel->iIdxCur = iIndexCur;
      ((void)0);
      ((void)0);
      if( op ){
        sqlite3VdbeAddOp3(v, op, iIndexCur, pIx->tnum, iDb);
        sqlite3VdbeSetP4KeyInfo(pParse, pIx);
        if( (pLoop->wsFlags & 0x0000000f)!=0
         && (pLoop->wsFlags & (0x00000002|0x00008000))==0
         && (pLoop->wsFlags & 0x00080000)==0
         && (pWInfo->wctrlFlags&0x0001)==0
         && pWInfo->eDistinct!=2
        ){
          sqlite3VdbeChangeP5(v, 0x02);
        }
        ;
# 146387 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      }
    }
    if( iDb>=0 ) sqlite3CodeVerifySchema(pParse, iDb);
  }
  pWInfo->iTop = sqlite3VdbeCurrentAddr(v);
  if( db->mallocFailed ) goto whereBeginError;





  for(ii=0; ii<nTabList; ii++){
    int addrExplain;
    int wsFlags;
    pLevel = &pWInfo->a[ii];
    wsFlags = pLevel->pWLoop->wsFlags;

    if( (pLevel->pWLoop->wsFlags & 0x00004000)!=0 ){
      constructAutomaticIndex(pParse, &pWInfo->sWC,
                &pTabList->a[pLevel->iFrom], notReady, pLevel);
      if( db->mallocFailed ) goto whereBeginError;
    }

    addrExplain = sqlite3WhereExplainOneScan(
        pParse, pTabList, pLevel, wctrlFlags
    );
    pLevel->addrBody = sqlite3VdbeCurrentAddr(v);
    notReady = sqlite3WhereCodeOneLoopStart(pParse,v,pWInfo,ii,pLevel,notReady);
    pWInfo->iContinue = pLevel->addrCont;
    if( (wsFlags&0x00002000)==0 && (wctrlFlags&0x0020)==0 ){
      ((void)addrExplain);
    }
  }


  ;
  return pWInfo;


whereBeginError:
  if( pWInfo ){
    pParse->nQueryLoop = pWInfo->savedNQueryLoop;
    whereInfoFree(db, pWInfo);
  }
  return 0;
}
# 146441 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define OpcodeRewriteTrace(D,K,P) 
# 146458 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WhereEnd(WhereInfo *pWInfo){
  Parse *pParse = pWInfo->pParse;
  Vdbe *v = pParse->pVdbe;
  int i;
  WhereLevel *pLevel;
  WhereLoop *pLoop;
  SrcList *pTabList = pWInfo->pTabList;
  sqlite3 *db = pParse->db;



  ;
  for(i=pWInfo->nLevel-1; i>=0; i--){
    int addr;
    pLevel = &pWInfo->a[i];
    pLoop = pLevel->pWLoop;
    if( pLevel->op!=170 ){

      int addrSeek = 0;
      Index *pIdx;
      int n;
      if( pWInfo->eDistinct==2
       && i==pWInfo->nLevel-1
       && (pLoop->wsFlags & 0x00000200)!=0
       && (pIdx = pLoop->u.btree.pIndex)->hasStat1
       && (n = pLoop->u.btree.nDistinctCol)>0
       && pIdx->aiRowLogEst[n]>=36
      ){
        int r1 = pParse->nMem+1;
        int j, op;
        for(j=0; j<n; j++){
          sqlite3VdbeAddOp3(v, 90, pLevel->iIdxCur, j, r1+j);
        }
        pParse->nMem += n+1;
        op = pLevel->op==4 ? 22 : 25;
        addrSeek = sqlite3VdbeAddOp4Int(v, op, pLevel->iIdxCur, 0, r1, n);
        ;
        ;
        sqlite3VdbeAddOp2(v, 11, 1, pLevel->p2);
      }


      sqlite3VdbeResolveLabel(v, pLevel->addrCont);
      sqlite3VdbeAddOp3(v, pLevel->op, pLevel->p1, pLevel->p2, pLevel->p3);
      sqlite3VdbeChangeP5(v, pLevel->p5);
      ;
      ;
      ;
      ;
      if( pLevel->regBignull ){
        sqlite3VdbeResolveLabel(v, pLevel->addrBignull);
        sqlite3VdbeAddOp2(v, 49, pLevel->regBignull, pLevel->p2-1);
        ;
      }

      if( addrSeek ) sqlite3VdbeJumpHere(v, addrSeek);

    }else{
      sqlite3VdbeResolveLabel(v, pLevel->addrCont);
    }
    if( pLoop->wsFlags & 0x00000800 && pLevel->u.in.nIn>0 ){
      struct InLoop *pIn;
      int j;
      sqlite3VdbeResolveLabel(v, pLevel->addrNxt);
      for(j=pLevel->u.in.nIn, pIn=&pLevel->u.in.aInLoop[j-1]; j>0; j--, pIn--){
        sqlite3VdbeJumpHere(v, pIn->addrInTop+1);
        if( pIn->eEndLoopOp!=170 ){
          if( pIn->nPrefix ){
            ((void)0);
            sqlite3VdbeAddOp4Int(v, 26, pLevel->iIdxCur,
                              sqlite3VdbeCurrentAddr(v)+2,
                              pIn->iBase, pIn->nPrefix);
            ;
          }
          sqlite3VdbeAddOp2(v, pIn->eEndLoopOp, pIn->iCur, pIn->addrInTop);
          ;
          ;
          ;
        }
        sqlite3VdbeJumpHere(v, pIn->addrInTop-1);
      }
    }
    sqlite3VdbeResolveLabel(v, pLevel->addrBrk);
    if( pLevel->addrSkip ){
      sqlite3VdbeGoto(v, pLevel->addrSkip);
      ;
      sqlite3VdbeJumpHere(v, pLevel->addrSkip);
      sqlite3VdbeJumpHere(v, pLevel->addrSkip-2);
    }

    if( pLevel->addrLikeRep ){
      sqlite3VdbeAddOp2(v, 49, (int)(pLevel->iLikeRepCntr>>1),
                        pLevel->addrLikeRep);
      ;
    }

    if( pLevel->iLeftJoin ){
      int ws = pLoop->wsFlags;
      addr = sqlite3VdbeAddOp1(v, 47, pLevel->iLeftJoin); ;
      ((void)0);
      if( (ws & 0x00000040)==0 ){
        ((void)0);
        sqlite3VdbeAddOp1(v, 129, pLevel->iTabCur);
      }
      if( (ws & 0x00000200)
       || ((ws & 0x00002000) && pLevel->u.pCovidx)
      ){
        sqlite3VdbeAddOp1(v, 129, pLevel->iIdxCur);
      }
      if( pLevel->op==66 ){
        sqlite3VdbeAddOp2(v, 12, pLevel->p1, pLevel->addrFirst);
      }else{
        sqlite3VdbeGoto(v, pLevel->addrFirst);
      }
      sqlite3VdbeJumpHere(v, addr);
    }
   
                                                                     ;
  }




  sqlite3VdbeResolveLabel(v, pWInfo->iBreak);

  ((void)0);
  for(i=0, pLevel=pWInfo->a; i<pWInfo->nLevel; i++, pLevel++){
    int k, last;
    VdbeOp *pOp;
    Index *pIdx = 0;
    struct SrcList_item *pTabItem = &pTabList->a[pLevel->iFrom];
    Table *pTab = pTabItem->pTab;
    ((void)0);
    pLoop = pLevel->pWLoop;





    if( pTabItem->fg.viaCoroutine ){
      ;
      translateColumnToCopy(pParse, pLevel->addrBody, pLevel->iTabCur,
                            pTabItem->regResult, 0);
      continue;
    }
# 146638 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( pLoop->wsFlags & (0x00000200|0x00000040) ){
      pIdx = pLoop->u.btree.pIndex;
    }else if( pLoop->wsFlags & 0x00002000 ){
      pIdx = pLevel->u.pCovidx;
    }
    if( pIdx
     && (pWInfo->eOnePass==0 || !(((pIdx->pTable)->tabFlags & 0x0020)==0))
     && !db->mallocFailed
    ){
      last = sqlite3VdbeCurrentAddr(v);
      k = pLevel->addrBody;





      pOp = sqlite3VdbeGetOp(v, k);
      for(; k<last; k++, pOp++){
        if( pOp->p1!=pLevel->iTabCur ) continue;
        if( pOp->opcode==90



        ){
          int x = pOp->p2;
          ((void)0);
          if( !(((pTab)->tabFlags & 0x0020)==0) ){
            Index *pPk = sqlite3PrimaryKeyIndex(pTab);
            x = pPk->aiColumn[x];
            ((void)0);
          }
          x = sqlite3ColumnOfIndex(pIdx, x);
          if( x>=0 ){
            pOp->p2 = x;
            pOp->p1 = pLevel->iIdxCur;
            ;
          }
          ((void)0)
                                   ;
        }else if( pOp->opcode==128 ){
          pOp->p1 = pLevel->iIdxCur;
          pOp->opcode = 135;
          ;
        }else if( pOp->opcode==21 ){
          pOp->p1 = pLevel->iIdxCur;
          ;
        }
      }



    }
  }



  pParse->nQueryLoop = pWInfo->savedNQueryLoop;
  whereInfoFree(db, pWInfo);
  return;
}
# 146847 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void row_numberStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) (*p)++;
  (void)(nArg);
  (void)(apArg);
}
static void row_numberValueFunc(sqlite3_context *pCtx){
  i64 *p = (i64*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  sqlite3_result_int64(pCtx, (p ? *p : 0));
}





struct CallCount {
  i64 nValue;
  i64 nStep;
  i64 nTotal;
};







static void dense_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ) p->nStep = 1;
  (void)(nArg);
  (void)(apArg);
}
static void dense_rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    if( p->nStep ){
      p->nValue++;
      p->nStep = 0;
    }
    sqlite3_result_int64(pCtx, p->nValue);
  }
}






struct NthValueCtx {
  i64 nStep;
  sqlite3_value *pValue;
};
static void nth_valueStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    i64 iVal;
    switch( sqlite3_value_numeric_type(apArg[1]) ){
      case 1:
        iVal = sqlite3_value_int64(apArg[1]);
        break;
      case 2: {
        double fVal = sqlite3_value_double(apArg[1]);
        if( ((i64)fVal)!=fVal ) goto error_out;
        iVal = (i64)fVal;
        break;
      }
      default:
        goto error_out;
    }
    if( iVal<=0 ) goto error_out;

    p->nStep++;
    if( iVal==p->nStep ){
      p->pValue = sqlite3_value_dup(apArg[0]);
      if( !p->pValue ){
        sqlite3_result_error_nomem(pCtx);
      }
    }
  }
  (void)(nArg);
  (void)(apArg);
  return;

 error_out:
  sqlite3_result_error(
      pCtx, "second argument to nth_value must be a positive integer", -1
  );
}
static void nth_valueFinalizeFunc(sqlite3_context *pCtx){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, 0);
  if( p && p->pValue ){
    sqlite3_result_value(pCtx, p->pValue);
    sqlite3_value_free(p->pValue);
    p->pValue = 0;
  }
}
#define nth_valueInvFunc noopStepFunc
#define nth_valueValueFunc noopValueFunc

static void first_valueStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->pValue==0 ){
    p->pValue = sqlite3_value_dup(apArg[0]);
    if( !p->pValue ){
      sqlite3_result_error_nomem(pCtx);
    }
  }
  (void)(nArg);
  (void)(apArg);
}
static void first_valueFinalizeFunc(sqlite3_context *pCtx){
  struct NthValueCtx *p;
  p = (struct NthValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->pValue ){
    sqlite3_result_value(pCtx, p->pValue);
    sqlite3_value_free(p->pValue);
    p->pValue = 0;
  }
}
#define first_valueInvFunc noopStepFunc
#define first_valueValueFunc noopValueFunc







static void rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nStep++;
    if( p->nValue==0 ){
      p->nValue = p->nStep;
    }
  }
  (void)(nArg);
  (void)(apArg);
}
static void rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    sqlite3_result_int64(pCtx, p->nValue);
    p->nValue = 0;
  }
}







static void percent_rankStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void)0);
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nTotal++;
  }
}
static void percent_rankInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void)0);
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->nStep++;
}
static void percent_rankValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nValue = p->nStep;
    if( p->nTotal>1 ){
      double r = (double)p->nValue / (double)(p->nTotal-1);
      sqlite3_result_double(pCtx, r);
    }else{
      sqlite3_result_double(pCtx, 0.0);
    }
  }
}
#define percent_rankFinalizeFunc percent_rankValueFunc







static void cume_distStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void)0);
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    p->nTotal++;
  }
}
static void cume_distInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct CallCount *p;
  (void)(nArg); ((void)0);
  (void)(apArg);
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->nStep++;
}
static void cume_distValueFunc(sqlite3_context *pCtx){
  struct CallCount *p;
  p = (struct CallCount*)sqlite3_aggregate_context(pCtx, 0);
  if( p ){
    double r = (double)(p->nStep) / (double)(p->nTotal);
    sqlite3_result_double(pCtx, r);
  }
}
#define cume_distFinalizeFunc cume_distValueFunc




struct NtileCtx {
  i64 nTotal;
  i64 nParam;
  i64 iRow;
};







static void ntileStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NtileCtx *p;
  ((void)0); (void)(nArg);
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    if( p->nTotal==0 ){
      p->nParam = sqlite3_value_int64(apArg[0]);
      if( p->nParam<=0 ){
        sqlite3_result_error(
            pCtx, "argument of ntile must be a positive integer", -1
        );
      }
    }
    p->nTotal++;
  }
}
static void ntileInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct NtileCtx *p;
  ((void)0); (void)(nArg);
  (void)(apArg);
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  p->iRow++;
}
static void ntileValueFunc(sqlite3_context *pCtx){
  struct NtileCtx *p;
  p = (struct NtileCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->nParam>0 ){
    int nSize = (p->nTotal / p->nParam);
    if( nSize==0 ){
      sqlite3_result_int64(pCtx, p->iRow+1);
    }else{
      i64 nLarge = p->nTotal - p->nParam*nSize;
      i64 iSmall = nLarge*(nSize+1);
      i64 iRow = p->iRow;

      ((void)0);

      if( iRow<iSmall ){
        sqlite3_result_int64(pCtx, 1 + iRow/(nSize+1));
      }else{
        sqlite3_result_int64(pCtx, 1 + nLarge + (iRow-iSmall)/nSize);
      }
    }
  }
}
#define ntileFinalizeFunc ntileValueFunc




struct LastValueCtx {
  sqlite3_value *pVal;
  int nVal;
};




static void last_valueStepFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct LastValueCtx *p;
  (void)(nArg);
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p ){
    sqlite3_value_free(p->pVal);
    p->pVal = sqlite3_value_dup(apArg[0]);
    if( p->pVal==0 ){
      sqlite3_result_error_nomem(pCtx);
    }else{
      p->nVal++;
    }
  }
}
static void last_valueInvFunc(
  sqlite3_context *pCtx,
  int nArg,
  sqlite3_value **apArg
){
  struct LastValueCtx *p;
  (void)(nArg);
  (void)(apArg);
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( (p) ){
    p->nVal--;
    if( p->nVal==0 ){
      sqlite3_value_free(p->pVal);
      p->pVal = 0;
    }
  }
}
static void last_valueValueFunc(sqlite3_context *pCtx){
  struct LastValueCtx *p;
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, 0);
  if( p && p->pVal ){
    sqlite3_result_value(pCtx, p->pVal);
  }
}
static void last_valueFinalizeFunc(sqlite3_context *pCtx){
  struct LastValueCtx *p;
  p = (struct LastValueCtx*)sqlite3_aggregate_context(pCtx, sizeof(*p));
  if( p && p->pVal ){
    sqlite3_result_value(pCtx, p->pVal);
    sqlite3_value_free(p->pVal);
    p->pVal = 0;
  }
}
# 147248 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char row_numberName[] = "row_number";
static const char dense_rankName[] = "dense_rank";
static const char rankName[] = "rank";
static const char percent_rankName[] = "percent_rank";
static const char cume_distName[] = "cume_dist";
static const char ntileName[] = "ntile";
static const char last_valueName[] = "last_value";
static const char nth_valueName[] = "nth_value";
static const char first_valueName[] = "first_value";
static const char leadName[] = "lead";
static const char lagName[] = "lag";
# 147269 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void noopStepFunc(
  sqlite3_context *p,
  int n,
  sqlite3_value **a
){
  (void)(p);
  (void)(n);
  (void)(a);
  ((void)0);
}
static void noopValueFunc(sqlite3_context *p){ (void)(p); }



#define WINDOWFUNCALL(name,nArg,extra) { nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0, name ## StepFunc, name ## FinalizeFunc, name ## ValueFunc, name ## InvFunc, name ## Name, {0} }







#define WINDOWFUNCNOOP(name,nArg,extra) { nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, name ## Name, {0} }
# 147300 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define WINDOWFUNCX(name,nArg,extra) { nArg, (SQLITE_UTF8|SQLITE_FUNC_WINDOW|extra), 0, 0, name ## StepFunc, name ## ValueFunc, name ## ValueFunc, noopStepFunc, name ## Name, {0} }
# 147310 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WindowFunctions(void){
  static FuncDef aWindowFuncs[] = {
    { 0, (1|0x00010000|0), 0, 0, row_numberStepFunc, row_numberValueFunc, row_numberValueFunc, noopStepFunc, row_numberName, {0} },
    { 0, (1|0x00010000|0), 0, 0, dense_rankStepFunc, dense_rankValueFunc, dense_rankValueFunc, noopStepFunc, dense_rankName, {0} },
    { 0, (1|0x00010000|0), 0, 0, rankStepFunc, rankValueFunc, rankValueFunc, noopStepFunc, rankName, {0} },
    { 0, (1|0x00010000|0), 0, 0, percent_rankStepFunc, percent_rankValueFunc, percent_rankValueFunc, percent_rankInvFunc, percent_rankName, {0} },
    { 0, (1|0x00010000|0), 0, 0, cume_distStepFunc, cume_distValueFunc, cume_distValueFunc, cume_distInvFunc, cume_distName, {0} },
    { 1, (1|0x00010000|0), 0, 0, ntileStepFunc, ntileValueFunc, ntileValueFunc, ntileInvFunc, ntileName, {0} },
    { 1, (1|0x00010000|0), 0, 0, last_valueStepFunc, last_valueFinalizeFunc, last_valueValueFunc, last_valueInvFunc, last_valueName, {0} },
    { 2, (1|0x00010000|0), 0, 0, nth_valueStepFunc, nth_valueFinalizeFunc, noopValueFunc, noopStepFunc, nth_valueName, {0} },
    { 1, (1|0x00010000|0), 0, 0, first_valueStepFunc, first_valueFinalizeFunc, noopValueFunc, noopStepFunc, first_valueName, {0} },
    { 1, (1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, leadName, {0} },
    { 2, (1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, leadName, {0} },
    { 3, (1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, leadName, {0} },
    { 1, (1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, lagName, {0} },
    { 2, (1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, lagName, {0} },
    { 3, (1|0x00010000|0), 0, 0, noopStepFunc, noopValueFunc, noopValueFunc, noopStepFunc, lagName, {0} },
  };
  sqlite3InsertBuiltinFuncs(aWindowFuncs, ((int)(sizeof(aWindowFuncs)/sizeof(aWindowFuncs[0]))));
}

static Window *windowFind(Parse *pParse, Window *pList, const char *zName){
  Window *p;
  for(p=pList; p; p=p->pNextWin){
    if( sqlite3StrICmp(p->zName, zName)==0 ) break;
  }
  if( p==0 ){
    sqlite3ErrorMsg(pParse, "no such window: %s", zName);
  }
  return p;
}
# 147359 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WindowUpdate(
  Parse *pParse,
  Window *pList,
  Window *pWin,
  FuncDef *pFunc
){
  if( pWin->zName && pWin->eFrmType==0 ){
    Window *p = windowFind(pParse, pList, pWin->zName);
    if( p==0 ) return;
    pWin->pPartition = sqlite3ExprListDup(pParse->db, p->pPartition, 0);
    pWin->pOrderBy = sqlite3ExprListDup(pParse->db, p->pOrderBy, 0);
    pWin->pStart = sqlite3ExprDup(pParse->db, p->pStart, 0);
    pWin->pEnd = sqlite3ExprDup(pParse->db, p->pEnd, 0);
    pWin->eStart = p->eStart;
    pWin->eEnd = p->eEnd;
    pWin->eFrmType = p->eFrmType;
    pWin->eExclude = p->eExclude;
  }else{
    sqlite3WindowChain(pParse, pWin, pList);
  }
  if( (pWin->eFrmType==89)
   && (pWin->pStart || pWin->pEnd)
   && (pWin->pOrderBy==0 || pWin->pOrderBy->nExpr!=1)
  ){
    sqlite3ErrorMsg(pParse,
      "RANGE with offset PRECEDING/FOLLOWING requires one ORDER BY expression"
    );
  }else
  if( pFunc->funcFlags & 0x00010000 ){
    sqlite3 *db = pParse->db;
    if( pWin->pFilter ){
      sqlite3ErrorMsg(pParse,
          "FILTER clause may only be used with aggregate window functions"
      );
    }else{
      struct WindowUpdate {
        const char *zFunc;
        int eFrmType;
        int eStart;
        int eEnd;
      } aUp[] = {
        { row_numberName, 76, 90, 85 },
        { dense_rankName, 89, 90, 85 },
        { rankName, 89, 90, 85 },
        { percent_rankName, 92, 85, 90 },
        { cume_distName, 92, 86, 90 },
        { ntileName, 76, 85, 90 },
        { leadName, 76, 90, 90 },
        { lagName, 76, 90, 85 },
      };
      int i;
      for(i=0; i<((int)(sizeof(aUp)/sizeof(aUp[0]))); i++){
        if( pFunc->zName==aUp[i].zFunc ){
          sqlite3ExprDelete(db, pWin->pStart);
          sqlite3ExprDelete(db, pWin->pEnd);
          pWin->pEnd = pWin->pStart = 0;
          pWin->eFrmType = aUp[i].eFrmType;
          pWin->eStart = aUp[i].eStart;
          pWin->eEnd = aUp[i].eEnd;
          pWin->eExclude = 0;
          if( pWin->eStart==86 ){
            pWin->pStart = sqlite3Expr(db, 150, "1");
          }
          break;
        }
      }
    }
  }
  pWin->pFunc = pFunc;
}





typedef struct WindowRewrite WindowRewrite;
struct WindowRewrite {
  Window *pWin;
  SrcList *pSrc;
  ExprList *pSub;
  Table *pTab;
  Select *pSubSelect;
};






static int selectWindowRewriteExprCb(Walker *pWalker, Expr *pExpr){
  struct WindowRewrite *p = pWalker->u.pRewrite;
  Parse *pParse = pWalker->pParse;
  ((void)0);
  ((void)0);






  if( p->pSubSelect ){
    if( pExpr->op!=162 ){
      return 0;
    }else{
      int nSrc = p->pSrc->nSrc;
      int i;
      for(i=0; i<nSrc; i++){
        if( pExpr->iTable==p->pSrc->a[i].iCursor ) break;
      }
      if( i==nSrc ) return 0;
    }
  }

  switch( pExpr->op ){

    case 167:
      if( !(((pExpr)->flags&(0x1000000))!=0) ){
        break;
      }else{
        Window *pWin;
        for(pWin=p->pWin; pWin; pWin=pWin->pNextWin){
          if( pExpr->y.pWin==pWin ){
            ((void)0);
            return 1;
          }
        }
      }


    case 163:
    case 162: {
      Expr *pDup = sqlite3ExprDup(pParse->db, pExpr, 0);
      p->pSub = sqlite3ExprListAppend(pParse, p->pSub, pDup);
      if( p->pSub ){
        ((void)0);
        (pExpr)->flags|=(0x8000000);
        sqlite3ExprDelete(pParse->db, pExpr);
        (pExpr)->flags&=~(0x8000000);
        memset(pExpr, 0, sizeof(Expr));

        pExpr->op = 162;
        pExpr->iColumn = p->pSub->nExpr-1;
        pExpr->iTable = p->pWin->iEphCsr;
        pExpr->y.pTab = p->pTab;
      }

      break;
    }

    default:
      break;
  }

  return 0;
}
static int selectWindowRewriteSelectCb(Walker *pWalker, Select *pSelect){
  struct WindowRewrite *p = pWalker->u.pRewrite;
  Select *pSave = p->pSubSelect;
  if( pSave==pSelect ){
    return 0;
  }else{
    p->pSubSelect = pSelect;
    sqlite3WalkSelect(pWalker, pSelect);
    p->pSubSelect = pSave;
  }
  return 1;
}
# 147541 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void selectWindowRewriteEList(
  Parse *pParse,
  Window *pWin,
  SrcList *pSrc,
  ExprList *pEList,
  Table *pTab,
  ExprList **ppSub
){
  Walker sWalker;
  WindowRewrite sRewrite;

  ((void)0);
  memset(&sWalker, 0, sizeof(Walker));
  memset(&sRewrite, 0, sizeof(WindowRewrite));

  sRewrite.pSub = *ppSub;
  sRewrite.pWin = pWin;
  sRewrite.pSrc = pSrc;
  sRewrite.pTab = pTab;

  sWalker.pParse = pParse;
  sWalker.xExprCallback = selectWindowRewriteExprCb;
  sWalker.xSelectCallback = selectWindowRewriteSelectCb;
  sWalker.u.pRewrite = &sRewrite;

  (void)sqlite3WalkExprList(&sWalker, pEList);

  *ppSub = sRewrite.pSub;
}





static ExprList *exprListAppendList(
  Parse *pParse,
  ExprList *pList,
  ExprList *pAppend,
  int bIntToNull
){
  if( pAppend ){
    int i;
    int nInit = pList ? pList->nExpr : 0;
    for(i=0; i<pAppend->nExpr; i++){
      Expr *pDup = sqlite3ExprDup(pParse->db, pAppend->a[i].pExpr, 0);
      if( bIntToNull && pDup && pDup->op==150 ){
        pDup->op = 117;
        pDup->flags &= ~(0x000400|0x10000000|0x20000000);
      }
      pList = sqlite3ExprListAppend(pParse, pList, pDup);
      if( pList ) pList->a[nInit+i].sortFlags = pAppend->a[i].sortFlags;
    }
  }
  return pList;
}
# 147604 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WindowRewrite(Parse *pParse, Select *p){
  int rc = 0;
  if( p->pWin && p->pPrior==0 ){
    Vdbe *v = sqlite3GetVdbe(pParse);
    sqlite3 *db = pParse->db;
    Select *pSub = 0;
    SrcList *pSrc = p->pSrc;
    Expr *pWhere = p->pWhere;
    ExprList *pGroupBy = p->pGroupBy;
    Expr *pHaving = p->pHaving;
    ExprList *pSort = 0;

    ExprList *pSublist = 0;
    Window *pMWin = p->pWin;
    Window *pWin;
    Table *pTab;

    pTab = sqlite3DbMallocZero(db, sizeof(Table));
    if( pTab==0 ){
      return 7;
    }

    p->pSrc = 0;
    p->pWhere = 0;
    p->pGroupBy = 0;
    p->pHaving = 0;
    p->selFlags &= ~0x00008;




    pSort = sqlite3ExprListDup(db, pMWin->pPartition, 0);
    pSort = exprListAppendList(pParse, pSort, pMWin->pOrderBy, 1);
    if( pSort && p->pOrderBy && p->pOrderBy->nExpr<=pSort->nExpr ){
      int nSave = pSort->nExpr;
      pSort->nExpr = p->pOrderBy->nExpr;
      if( sqlite3ExprListCompare(pSort, p->pOrderBy, -1)==0 ){
        sqlite3ExprListDelete(db, p->pOrderBy);
        p->pOrderBy = 0;
      }
      pSort->nExpr = nSave;
    }




    pMWin->iEphCsr = pParse->nTab++;
    pParse->nTab += 3;

    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pEList, pTab, &pSublist);
    selectWindowRewriteEList(pParse, pMWin, pSrc, p->pOrderBy, pTab, &pSublist);
    pMWin->nBufferCol = (pSublist ? pSublist->nExpr : 0);




    pSublist = exprListAppendList(pParse, pSublist, pMWin->pPartition, 0);
    pSublist = exprListAppendList(pParse, pSublist, pMWin->pOrderBy, 0);





    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
      ExprList *pArgs = pWin->pOwner->x.pList;
      if( pWin->pFunc->funcFlags & 0x00100000 ){
        selectWindowRewriteEList(pParse, pMWin, pSrc, pArgs, pTab, &pSublist);
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pWin->bExprArgs = 1;
      }else{
        pWin->iArgCol = (pSublist ? pSublist->nExpr : 0);
        pSublist = exprListAppendList(pParse, pSublist, pArgs, 0);
      }
      if( pWin->pFilter ){
        Expr *pFilter = sqlite3ExprDup(db, pWin->pFilter, 0);
        pSublist = sqlite3ExprListAppend(pParse, pSublist, pFilter);
      }
      pWin->regAccum = ++pParse->nMem;
      pWin->regResult = ++pParse->nMem;
      sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
    }







    if( pSublist==0 ){
      pSublist = sqlite3ExprListAppend(pParse, 0,
        sqlite3Expr(db, 150, "0")
      );
    }

    pSub = sqlite3SelectNew(
        pParse, pSublist, pSrc, pWhere, pGroupBy, pHaving, pSort, 0, 0
    );
    p->pSrc = sqlite3SrcListAppend(pParse, 0, 0, 0);
    if( p->pSrc ){
      Table *pTab2;
      p->pSrc->a[0].pSelect = pSub;
      sqlite3SrcListAssignCursors(pParse, p->pSrc);
      pSub->selFlags |= 0x00040;
      pTab2 = sqlite3ResultSetOfSelect(pParse, pSub, 0x40);
      if( pTab2==0 ){
        rc = 7;
      }else{
        memcpy(pTab, pTab2, sizeof(Table));
        pTab->tabFlags |= 0x0002;
        p->pSrc->a[0].pTab = pTab;
        pTab = pTab2;
      }
      sqlite3VdbeAddOp2(v, 112, pMWin->iEphCsr, pSublist->nExpr);
      sqlite3VdbeAddOp2(v, 109, pMWin->iEphCsr+1, pMWin->iEphCsr);
      sqlite3VdbeAddOp2(v, 109, pMWin->iEphCsr+2, pMWin->iEphCsr);
      sqlite3VdbeAddOp2(v, 109, pMWin->iEphCsr+3, pMWin->iEphCsr);
    }else{
      sqlite3SelectDelete(db, pSub);
    }
    if( db->mallocFailed ) rc = 7;
    sqlite3DbFree(db, pTab);
  }

  return rc;
}





static void sqlite3WindowUnlinkFromSelect(Window *p){
  if( p->ppThis ){
    *p->ppThis = p->pNextWin;
    if( p->pNextWin ) p->pNextWin->ppThis = p->ppThis;
    p->ppThis = 0;
  }
}




static void sqlite3WindowDelete(sqlite3 *db, Window *p){
  if( p ){
    sqlite3WindowUnlinkFromSelect(p);
    sqlite3ExprDelete(db, p->pFilter);
    sqlite3ExprListDelete(db, p->pPartition);
    sqlite3ExprListDelete(db, p->pOrderBy);
    sqlite3ExprDelete(db, p->pEnd);
    sqlite3ExprDelete(db, p->pStart);
    sqlite3DbFree(db, p->zName);
    sqlite3DbFree(db, p->zBase);
    sqlite3DbFree(db, p);
  }
}




static void sqlite3WindowListDelete(sqlite3 *db, Window *p){
  while( p ){
    Window *pNext = p->pNextWin;
    sqlite3WindowDelete(db, p);
    p = pNext;
  }
}
# 147777 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static Expr *sqlite3WindowOffsetExpr(Parse *pParse, Expr *pExpr){
  if( 0==sqlite3ExprIsConstant(pExpr) ){
    if( (pParse->eParseMode>=2) ) sqlite3RenameExprUnmap(pParse, pExpr);
    sqlite3ExprDelete(pParse->db, pExpr);
    pExpr = sqlite3ExprAlloc(pParse->db, 117, 0, 0);
  }
  return pExpr;
}




static Window *sqlite3WindowAlloc(
  Parse *pParse,
  int eType,
  int eStart,
  Expr *pStart,
  int eEnd,
  Expr *pEnd,
  u8 eExclude
){
  Window *pWin = 0;
  int bImplicitFrame = 0;


  ((void)0);
  ((void)0)
                                                            ;
  ((void)0)
                                                        ;
  ((void)0);
  ((void)0);

  if( eType==0 ){
    bImplicitFrame = 1;
    eType = 89;
  }
# 147829 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( (eStart==85 && eEnd==88)
   || (eStart==86 && (eEnd==88 || eEnd==85))
  ){
    sqlite3ErrorMsg(pParse, "unsupported frame specification");
    goto windowAllocErr;
  }

  pWin = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  if( pWin==0 ) goto windowAllocErr;
  pWin->eFrmType = eType;
  pWin->eStart = eStart;
  pWin->eEnd = eEnd;
  if( eExclude==0 && (((pParse->db)->dbOptFlags&(0x0002))!=0) ){
    eExclude = 66;
  }
  pWin->eExclude = eExclude;
  pWin->bImplicitFrame = bImplicitFrame;
  pWin->pEnd = sqlite3WindowOffsetExpr(pParse, pEnd);
  pWin->pStart = sqlite3WindowOffsetExpr(pParse, pStart);
  return pWin;

windowAllocErr:
  sqlite3ExprDelete(pParse->db, pEnd);
  sqlite3ExprDelete(pParse->db, pStart);
  return 0;
}






static Window *sqlite3WindowAssemble(
  Parse *pParse,
  Window *pWin,
  ExprList *pPartition,
  ExprList *pOrderBy,
  Token *pBase
){
  if( pWin ){
    pWin->pPartition = pPartition;
    pWin->pOrderBy = pOrderBy;
    if( pBase ){
      pWin->zBase = sqlite3DbStrNDup(pParse->db, pBase->z, pBase->n);
    }
  }else{
    sqlite3ExprListDelete(pParse->db, pPartition);
    sqlite3ExprListDelete(pParse->db, pOrderBy);
  }
  return pWin;
}
# 147888 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WindowChain(Parse *pParse, Window *pWin, Window *pList){
  if( pWin->zBase ){
    sqlite3 *db = pParse->db;
    Window *pExist = windowFind(pParse, pList, pWin->zBase);
    if( pExist ){
      const char *zErr = 0;

      if( pWin->pPartition ){
        zErr = "PARTITION clause";
      }else if( pExist->pOrderBy && pWin->pOrderBy ){
        zErr = "ORDER BY clause";
      }else if( pExist->bImplicitFrame==0 ){
        zErr = "frame specification";
      }
      if( zErr ){
        sqlite3ErrorMsg(pParse,
            "cannot override %s of window: %s", zErr, pWin->zBase
        );
      }else{
        pWin->pPartition = sqlite3ExprListDup(db, pExist->pPartition, 0);
        if( pExist->pOrderBy ){
          ((void)0);
          pWin->pOrderBy = sqlite3ExprListDup(db, pExist->pOrderBy, 0);
        }
        sqlite3DbFree(db, pWin->zBase);
        pWin->zBase = 0;
      }
    }
  }
}




static void sqlite3WindowAttach(Parse *pParse, Expr *p, Window *pWin){
  if( p ){
    ((void)0);
    ((void)0);
    p->y.pWin = pWin;
    (p)->flags|=(0x1000000);
    pWin->pOwner = p;
    if( (p->flags & 0x000002) && pWin->eFrmType!=161 ){
      sqlite3ErrorMsg(pParse,
          "DISTINCT is not supported for window functions"
      );
    }
  }else{
    sqlite3WindowDelete(pParse->db, pWin);
  }
}







static void sqlite3WindowLink(Select *pSel, Window *pWin){
  if( 0==pSel->pWin
   || 0==sqlite3WindowCompare(0, pSel->pWin, pWin, 0)
  ){
    pWin->pNextWin = pSel->pWin;
    if( pSel->pWin ){
      pSel->pWin->ppThis = &pWin->pNextWin;
    }
    pSel->pWin = pWin;
    pWin->ppThis = &pSel->pWin;
  }
}





static int sqlite3WindowCompare(Parse *pParse, Window *p1, Window *p2, int bFilter){
  if( p1->eFrmType!=p2->eFrmType ) return 1;
  if( p1->eStart!=p2->eStart ) return 1;
  if( p1->eEnd!=p2->eEnd ) return 1;
  if( p1->eExclude!=p2->eExclude ) return 1;
  if( sqlite3ExprCompare(pParse, p1->pStart, p2->pStart, -1) ) return 1;
  if( sqlite3ExprCompare(pParse, p1->pEnd, p2->pEnd, -1) ) return 1;
  if( sqlite3ExprListCompare(p1->pPartition, p2->pPartition, -1) ) return 1;
  if( sqlite3ExprListCompare(p1->pOrderBy, p2->pOrderBy, -1) ) return 1;
  if( bFilter ){
    if( sqlite3ExprCompare(pParse, p1->pFilter, p2->pFilter, -1) ) return 1;
  }
  return 0;
}







static void sqlite3WindowCodeInit(Parse *pParse, Window *pMWin){
  Window *pWin;
  Vdbe *v = sqlite3GetVdbe(pParse);



  if( pMWin->pPartition ){
    int nExpr = pMWin->pPartition->nExpr;
    pMWin->regPart = pParse->nMem+1;
    pParse->nMem += nExpr;
    sqlite3VdbeAddOp3(v, 73, 0, pMWin->regPart, pMWin->regPart+nExpr-1);
  }

  pMWin->regOne = ++pParse->nMem;
  sqlite3VdbeAddOp2(v, 70, 1, pMWin->regOne);

  if( pMWin->eExclude ){
    pMWin->regStartRowid = ++pParse->nMem;
    pMWin->regEndRowid = ++pParse->nMem;
    pMWin->csrApp = pParse->nTab++;
    sqlite3VdbeAddOp2(v, 70, 1, pMWin->regStartRowid);
    sqlite3VdbeAddOp2(v, 70, 0, pMWin->regEndRowid);
    sqlite3VdbeAddOp2(v, 109, pMWin->csrApp, pMWin->iEphCsr);
    return;
  }

  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *p = pWin->pFunc;
    if( (p->funcFlags & 0x1000) && pWin->eStart!=90 ){







      ExprList *pList = pWin->pOwner->x.pList;
      KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pList, 0, 0);
      pWin->csrApp = pParse->nTab++;
      pWin->regApp = pParse->nMem+1;
      pParse->nMem += 3;
      if( pKeyInfo && pWin->pFunc->zName[1]=='i' ){
        ((void)0);
        pKeyInfo->aSortFlags[0] = 0x01;
      }
      sqlite3VdbeAddOp2(v, 112, pWin->csrApp, 2);
      sqlite3VdbeAppendP4(v, pKeyInfo, (-9));
      sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp+1);
    }
    else if( p->zName==nth_valueName || p->zName==first_valueName ){


      pWin->regApp = pParse->nMem+1;
      pWin->csrApp = pParse->nTab++;
      pParse->nMem += 2;
      sqlite3VdbeAddOp2(v, 109, pWin->csrApp, pMWin->iEphCsr);
    }
    else if( p->zName==leadName || p->zName==lagName ){
      pWin->csrApp = pParse->nTab++;
      sqlite3VdbeAddOp2(v, 109, pWin->csrApp, pMWin->iEphCsr);
    }
  }
}

#define WINDOW_STARTING_INT 0
#define WINDOW_ENDING_INT 1
#define WINDOW_NTH_VALUE_INT 2
#define WINDOW_STARTING_NUM 3
#define WINDOW_ENDING_NUM 4
# 148060 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void windowCheckValue(Parse *pParse, int reg, int eCond){
  static const char *azErr[] = {
    "frame starting offset must be a non-negative integer",
    "frame ending offset must be a non-negative integer",
    "second argument to nth_value must be a positive integer",
    "frame starting offset must be a non-negative number",
    "frame ending offset must be a non-negative number",
  };
  static int aOp[] = { 57, 57, 54, 57, 57 };
  Vdbe *v = sqlite3GetVdbe(pParse);
  int regZero = sqlite3GetTempReg(pParse);
  ((void)0);
  sqlite3VdbeAddOp2(v, 70, 0, regZero);
  if( eCond>=3 ){
    int regString = sqlite3GetTempReg(pParse);
    sqlite3VdbeAddOp4(v, 113, 0, regString, 0, "", (-1));
    sqlite3VdbeAddOp3(v, 57, regString, sqlite3VdbeCurrentAddr(v)+2, reg);
    sqlite3VdbeChangeP5(v, 0x43|0x10);
    ;
    ((void)0);
    ;
    ;
  }else{
    sqlite3VdbeAddOp2(v, 15, reg, sqlite3VdbeCurrentAddr(v)+2);
    ;
    ((void)0);
    ;
    ;
    ;
  }
  sqlite3VdbeAddOp3(v, aOp[eCond], regZero, sqlite3VdbeCurrentAddr(v)+2, reg);
  ;
  ;
  ;
  ;
  ;
  sqlite3MayAbort(pParse);
  sqlite3VdbeAddOp2(v, 69, 1, 2);
  sqlite3VdbeAppendP4(v, (void*)azErr[eCond], (-1));
  sqlite3ReleaseTempReg(pParse, regZero);
}





static int windowArgCount(Window *pWin){
  ExprList *pList = pWin->pOwner->x.pList;
  return (pList ? pList->nExpr : 0);
}

typedef struct WindowCodeArg WindowCodeArg;
typedef struct WindowCsrAndReg WindowCsrAndReg;




struct WindowCsrAndReg {
  int csr;
  int reg;
};
# 148177 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct WindowCodeArg {
  Parse *pParse;
  Window *pMWin;
  Vdbe *pVdbe;
  int addrGosub;
  int regGosub;
  int regArg;
  int eDelete;

  WindowCsrAndReg start;
  WindowCsrAndReg current;
  WindowCsrAndReg end;
};





static void windowReadPeerValues(
  WindowCodeArg *p,
  int csr,
  int reg
){
  Window *pMWin = p->pMWin;
  ExprList *pOrderBy = pMWin->pOrderBy;
  if( pOrderBy ){
    Vdbe *v = sqlite3GetVdbe(p->pParse);
    ExprList *pPart = pMWin->pPartition;
    int iColOff = pMWin->nBufferCol + (pPart ? pPart->nExpr : 0);
    int i;
    for(i=0; i<pOrderBy->nExpr; i++){
      sqlite3VdbeAddOp3(v, 90, csr, iColOff+i, reg+i);
    }
  }
}
# 148232 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void windowAggStep(
  WindowCodeArg *p,
  Window *pMWin,
  int csr,
  int bInverse,
  int reg
){
  Parse *pParse = p->pParse;
  Vdbe *v = sqlite3GetVdbe(pParse);
  Window *pWin;
  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *pFunc = pWin->pFunc;
    int regArg;
    int nArg = pWin->bExprArgs ? 0 : windowArgCount(pWin);
    int i;

    ((void)0);



    ((void)0);

    for(i=0; i<nArg; i++){
      if( i!=1 || pFunc->zName!=nth_valueName ){
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol+i, reg+i);
      }else{
        sqlite3VdbeAddOp3(v, 90, pMWin->iEphCsr, pWin->iArgCol+i, reg+i);
      }
    }
    regArg = reg;

    if( pMWin->regStartRowid==0
     && (pFunc->funcFlags & 0x1000)
     && (pWin->eStart!=90)
    ){
      int addrIsNull = sqlite3VdbeAddOp1(v, 50, regArg);
      ;
      if( bInverse==0 ){
        sqlite3VdbeAddOp2(v, 83, pWin->regApp+1, 1);
        sqlite3VdbeAddOp2(v, 79, regArg, pWin->regApp);
        sqlite3VdbeAddOp3(v, 92, pWin->regApp, 2, pWin->regApp+2);
        sqlite3VdbeAddOp2(v, 132, pWin->csrApp, pWin->regApp+2);
      }else{
        sqlite3VdbeAddOp4Int(v, 24, pWin->csrApp, 0, regArg, 1);
        ;
        sqlite3VdbeAddOp1(v, 123, pWin->csrApp);
        sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
      }
      sqlite3VdbeJumpHere(v, addrIsNull);
    }else if( pWin->regApp ){
      ((void)0)

       ;
      ((void)0);
      sqlite3VdbeAddOp2(v, 83, pWin->regApp+1-bInverse, 1);
    }else if( pFunc->xSFunc!=noopStepFunc ){
      int addrIf = 0;
      if( pWin->pFilter ){
        int regTmp;
        ((void)0);
        ((void)0);
        regTmp = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol+nArg,regTmp);
        addrIf = sqlite3VdbeAddOp3(v, 20, regTmp, 0, 1);
        ;
        sqlite3ReleaseTempReg(pParse, regTmp);
      }

      if( pWin->bExprArgs ){
        int iStart = sqlite3VdbeCurrentAddr(v);
        VdbeOp *pOp, *pEnd;

        nArg = pWin->pOwner->x.pList->nExpr;
        regArg = sqlite3GetTempRange(pParse, nArg);
        sqlite3ExprCodeExprList(pParse, pWin->pOwner->x.pList, regArg, 0, 0);

        pEnd = sqlite3VdbeGetOp(v, -1);
        for(pOp=sqlite3VdbeGetOp(v, iStart); pOp<=pEnd; pOp++){
          if( pOp->opcode==90 && pOp->p1==pWin->iEphCsr ){
            pOp->p1 = csr;
          }
        }
      }
      if( pFunc->funcFlags & 0x0020 ){
        CollSeq *pColl;
        ((void)0);
        pColl = sqlite3ExprNNCollSeq(pParse, pWin->pOwner->x.pList->a[0].pExpr);
        sqlite3VdbeAddOp4(v, 82, 0,0,0, (const char*)pColl, (-2));
      }
      sqlite3VdbeAddOp3(v, bInverse? 153 : 154,
                        bInverse, regArg, pWin->regAccum);
      sqlite3VdbeAppendP4(v, pFunc, (-8));
      sqlite3VdbeChangeP5(v, (u8)nArg);
      if( pWin->bExprArgs ){
        sqlite3ReleaseTempRange(pParse, regArg, nArg);
      }
      if( addrIf ) sqlite3VdbeJumpHere(v, addrIf);
    }
  }
}




#define WINDOW_RETURN_ROW 1
#define WINDOW_AGGINVERSE 2
#define WINDOW_AGGSTEP 3







static void windowAggFinal(WindowCodeArg *p, int bFin){
  Parse *pParse = p->pParse;
  Window *pMWin = p->pMWin;
  Vdbe *v = sqlite3GetVdbe(pParse);
  Window *pWin;

  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    if( pMWin->regStartRowid==0
     && (pWin->pFunc->funcFlags & 0x1000)
     && (pWin->eStart!=90)
    ){
      sqlite3VdbeAddOp2(v, 73, 0, pWin->regResult);
      sqlite3VdbeAddOp1(v, 32, pWin->csrApp);
      ;
      sqlite3VdbeAddOp3(v, 90, pWin->csrApp, 0, pWin->regResult);
      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);
    }else if( pWin->regApp ){
      ((void)0);
    }else{
      int nArg = windowArgCount(pWin);
      if( bFin ){
        sqlite3VdbeAddOp2(v, 157, pWin->regAccum, nArg);
        sqlite3VdbeAppendP4(v, pWin->pFunc, (-8));
        sqlite3VdbeAddOp2(v, 78, pWin->regAccum, pWin->regResult);
        sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
      }else{
        sqlite3VdbeAddOp3(v, 156,pWin->regAccum,nArg,pWin->regResult);
        sqlite3VdbeAppendP4(v, pWin->pFunc, (-8));
      }
    }
  }
}







static void windowFullScan(WindowCodeArg *p){
  Window *pWin;
  Parse *pParse = p->pParse;
  Window *pMWin = p->pMWin;
  Vdbe *v = p->pVdbe;

  int regCRowid = 0;
  int regCPeer = 0;
  int regRowid = 0;
  int regPeer = 0;

  int nPeer;
  int lblNext;
  int lblBrk;
  int addrNext;
  int csr;

  ;

  ((void)0);
  csr = pMWin->csrApp;
  nPeer = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);

  lblNext = sqlite3VdbeMakeLabel(pParse);
  lblBrk = sqlite3VdbeMakeLabel(pParse);

  regCRowid = sqlite3GetTempReg(pParse);
  regRowid = sqlite3GetTempReg(pParse);
  if( nPeer ){
    regCPeer = sqlite3GetTempRange(pParse, nPeer);
    regPeer = sqlite3GetTempRange(pParse, nPeer);
  }

  sqlite3VdbeAddOp2(v, 128, pMWin->iEphCsr, regCRowid);
  windowReadPeerValues(p, pMWin->iEphCsr, regCPeer);

  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
  }

  sqlite3VdbeAddOp3(v, 24, csr, lblBrk, pMWin->regStartRowid);
  ;
  addrNext = sqlite3VdbeCurrentAddr(v);
  sqlite3VdbeAddOp2(v, 128, csr, regRowid);
  sqlite3VdbeAddOp3(v, 54, pMWin->regEndRowid, lblBrk, regRowid);
  ;

  if( pMWin->eExclude==85 ){
    sqlite3VdbeAddOp3(v, 53, regCRowid, lblNext, regRowid);
    ;
  }else if( pMWin->eExclude!=66 ){
    int addr;
    int addrEq = 0;
    KeyInfo *pKeyInfo = 0;

    if( pMWin->pOrderBy ){
      pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pMWin->pOrderBy, 0, 0);
    }
    if( pMWin->eExclude==94 ){
      addrEq = sqlite3VdbeAddOp3(v, 53, regCRowid, 0, regRowid);
      ;
    }
    if( pKeyInfo ){
      windowReadPeerValues(p, csr, regPeer);
      sqlite3VdbeAddOp3(v, 87, regPeer, regCPeer, nPeer);
      sqlite3VdbeAppendP4(v, (void*)pKeyInfo, (-9));
      addr = sqlite3VdbeCurrentAddr(v)+1;
      sqlite3VdbeAddOp3(v, 16, addr, lblNext, addr);
      ;
    }else{
      sqlite3VdbeAddOp2(v, 11, 0, lblNext);
    }
    if( addrEq ) sqlite3VdbeJumpHere(v, addrEq);
  }

  windowAggStep(p, pMWin, csr, 0, p->regArg);

  sqlite3VdbeResolveLabel(v, lblNext);
  sqlite3VdbeAddOp2(v, 5, csr, addrNext);
  ;
  sqlite3VdbeJumpHere(v, addrNext-1);
  sqlite3VdbeJumpHere(v, addrNext+1);
  sqlite3ReleaseTempReg(pParse, regRowid);
  sqlite3ReleaseTempReg(pParse, regCRowid);
  if( nPeer ){
    sqlite3ReleaseTempRange(pParse, regPeer, nPeer);
    sqlite3ReleaseTempRange(pParse, regCPeer, nPeer);
  }

  windowAggFinal(p, 1);
  ;
}
# 148491 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void windowReturnOneRow(WindowCodeArg *p){
  Window *pMWin = p->pMWin;
  Vdbe *v = p->pVdbe;

  if( pMWin->regStartRowid ){
    windowFullScan(p);
  }else{
    Parse *pParse = p->pParse;
    Window *pWin;

    for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
      FuncDef *pFunc = pWin->pFunc;
      if( pFunc->zName==nth_valueName
       || pFunc->zName==first_valueName
      ){
        int csr = pWin->csrApp;
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int tmpReg = sqlite3GetTempReg(pParse);
        sqlite3VdbeAddOp2(v, 73, 0, pWin->regResult);

        if( pFunc->zName==nth_valueName ){
          sqlite3VdbeAddOp3(v, 90,pMWin->iEphCsr,pWin->iArgCol+1,tmpReg);
          windowCheckValue(pParse, tmpReg, 2);
        }else{
          sqlite3VdbeAddOp2(v, 70, 1, tmpReg);
        }
        sqlite3VdbeAddOp3(v, 103, tmpReg, pWin->regApp, tmpReg);
        sqlite3VdbeAddOp3(v, 54, pWin->regApp+1, lbl, tmpReg);
        ;
        sqlite3VdbeAddOp3(v, 30, csr, 0, tmpReg);
        ;
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol, pWin->regResult);
        sqlite3VdbeResolveLabel(v, lbl);
        sqlite3ReleaseTempReg(pParse, tmpReg);
      }
      else if( pFunc->zName==leadName || pFunc->zName==lagName ){
        int nArg = pWin->pOwner->x.pList->nExpr;
        int csr = pWin->csrApp;
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int tmpReg = sqlite3GetTempReg(pParse);
        int iEph = pMWin->iEphCsr;

        if( nArg<3 ){
          sqlite3VdbeAddOp2(v, 73, 0, pWin->regResult);
        }else{
          sqlite3VdbeAddOp3(v, 90, iEph,pWin->iArgCol+2,pWin->regResult);
        }
        sqlite3VdbeAddOp2(v, 128, iEph, tmpReg);
        if( nArg<2 ){
          int val = (pFunc->zName==leadName ? 1 : -1);
          sqlite3VdbeAddOp2(v, 83, tmpReg, val);
        }else{
          int op = (pFunc->zName==leadName ? 103 : 104);
          int tmpReg2 = sqlite3GetTempReg(pParse);
          sqlite3VdbeAddOp3(v, 90, iEph, pWin->iArgCol+1, tmpReg2);
          sqlite3VdbeAddOp3(v, op, tmpReg2, tmpReg, tmpReg);
          sqlite3ReleaseTempReg(pParse, tmpReg2);
        }

        sqlite3VdbeAddOp3(v, 30, csr, lbl, tmpReg);
        ;
        sqlite3VdbeAddOp3(v, 90, csr, pWin->iArgCol, pWin->regResult);
        sqlite3VdbeResolveLabel(v, lbl);
        sqlite3ReleaseTempReg(pParse, tmpReg);
      }
    }
  }
  sqlite3VdbeAddOp2(v, 12, p->regGosub, p->addrGosub);
}







static int windowInitAccum(Parse *pParse, Window *pMWin){
  Vdbe *v = sqlite3GetVdbe(pParse);
  int regArg;
  int nArg = 0;
  Window *pWin;
  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *pFunc = pWin->pFunc;
    sqlite3VdbeAddOp2(v, 73, 0, pWin->regAccum);
    nArg = ((nArg)>(windowArgCount(pWin))?(nArg):(windowArgCount(pWin)));
    if( pMWin->regStartRowid==0 ){
      if( pFunc->zName==nth_valueName || pFunc->zName==first_valueName ){
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp);
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp+1);
      }

      if( (pFunc->funcFlags & 0x1000) && pWin->csrApp ){
        ((void)0);
        sqlite3VdbeAddOp1(v, 138, pWin->csrApp);
        sqlite3VdbeAddOp2(v, 70, 0, pWin->regApp+1);
      }
    }
  }
  regArg = pParse->nMem+1;
  pParse->nMem += nArg;
  return regArg;
}





static int windowCacheFrame(Window *pMWin){
  Window *pWin;
  if( pMWin->regStartRowid ) return 1;
  for(pWin=pMWin; pWin; pWin=pWin->pNextWin){
    FuncDef *pFunc = pWin->pFunc;
    if( (pFunc->zName==nth_valueName)
     || (pFunc->zName==first_valueName)
     || (pFunc->zName==leadName)
     || (pFunc->zName==lagName)
    ){
      return 1;
    }
  }
  return 0;
}
# 148624 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void windowIfNewPeer(
  Parse *pParse,
  ExprList *pOrderBy,
  int regNew,
  int regOld,
  int addr
){
  Vdbe *v = sqlite3GetVdbe(pParse);
  if( pOrderBy ){
    int nVal = pOrderBy->nExpr;
    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pOrderBy, 0, 0);
    sqlite3VdbeAddOp3(v, 87, regOld, regNew, nVal);
    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, (-9));
    sqlite3VdbeAddOp3(v, 16,
      sqlite3VdbeCurrentAddr(v)+1, addr, sqlite3VdbeCurrentAddr(v)+1
    );
    ;
    sqlite3VdbeAddOp3(v, 78, regNew, regOld, nVal-1);
  }else{
    sqlite3VdbeAddOp2(v, 11, 0, addr);
  }
}
# 148670 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void windowCodeRangeTest(
  WindowCodeArg *p,
  int op,
  int csr1,
  int regVal,
  int csr2,
  int lbl
){
  Parse *pParse = p->pParse;
  Vdbe *v = sqlite3GetVdbe(pParse);
  ExprList *pOrderBy = p->pMWin->pOrderBy;
  int reg1 = sqlite3GetTempReg(pParse);
  int reg2 = sqlite3GetTempReg(pParse);
  int regString = ++pParse->nMem;
  int arith = 103;
  int addrGe;

  ((void)0);
  ((void)0);
  if( pOrderBy->a[0].sortFlags & 0x01 ){
    switch( op ){
      case 57: op = 55; break;
      case 54: op = 56; break;
      default: ((void)0); op = 57; break;
    }
    arith = 104;
  }


  windowReadPeerValues(p, csr1, reg1);
  windowReadPeerValues(p, csr2, reg2);

 


    ;
# 148720 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3VdbeAddOp4(v, 113, 0, regString, 0, "", (-1));
  addrGe = sqlite3VdbeAddOp3(v, 57, regString, 0, reg1);
  ;
  sqlite3VdbeAddOp3(v, arith, regVal, reg1, reg1);
  sqlite3VdbeJumpHere(v, addrGe);
# 148745 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pOrderBy->a[0].sortFlags & 0x02 ){

    int addr = sqlite3VdbeAddOp1(v, 51, reg1); ;
    switch( op ){
      case 57:
        sqlite3VdbeAddOp2(v, 11, 0, lbl);
        break;
      case 54:
        sqlite3VdbeAddOp2(v, 51, reg2, lbl);
        ;
        break;
      case 55:
        sqlite3VdbeAddOp2(v, 50, reg2, lbl);
        ;
        break;
      default: ((void)0); break;
    }
    sqlite3VdbeAddOp2(v, 11, 0, sqlite3VdbeCurrentAddr(v)+3);


    sqlite3VdbeJumpHere(v, addr);
    sqlite3VdbeAddOp2(v, 50, reg2, lbl); ;
    if( op==54 || op==57 ){
      sqlite3VdbeChangeP2(v, -1, sqlite3VdbeCurrentAddr(v)+1);
    }
  }




  sqlite3VdbeAddOp3(v, op, reg2, lbl, reg1); ;
  sqlite3VdbeChangeP5(v, 0x80);

  ((void)0);
  ; ;
  ; ;
  ; ;
  ; ;
  sqlite3ReleaseTempReg(pParse, reg1);
  sqlite3ReleaseTempReg(pParse, reg2);

  ;
}







static int windowCodeOp(
 WindowCodeArg *p,
 int op,
 int regCountdown,
 int jumpOnEof
){
  int csr, reg;
  Parse *pParse = p->pParse;
  Window *pMWin = p->pMWin;
  int ret = 0;
  Vdbe *v = p->pVdbe;
  int addrContinue = 0;
  int bPeer = (pMWin->eFrmType!=76);

  int lblDone = sqlite3VdbeMakeLabel(pParse);
  int addrNextRange = 0;



  if( op==2 && pMWin->eStart==90 ){
    ((void)0);
    return 0;
  }

  if( regCountdown>0 ){
    if( pMWin->eFrmType==89 ){
      addrNextRange = sqlite3VdbeCurrentAddr(v);
      ((void)0);
      if( op==2 ){
        if( pMWin->eStart==86 ){
          windowCodeRangeTest(
              p, 55, p->current.csr, regCountdown, p->start.csr, lblDone
          );
        }else{
          windowCodeRangeTest(
              p, 57, p->start.csr, regCountdown, p->current.csr, lblDone
          );
        }
      }else{
        windowCodeRangeTest(
            p, 54, p->end.csr, regCountdown, p->current.csr, lblDone
        );
      }
    }else{
      sqlite3VdbeAddOp3(v, 47, regCountdown, lblDone, 1);
      ;
    }
  }

  if( op==1 && pMWin->regStartRowid==0 ){
    windowAggFinal(p, 0);
  }
  addrContinue = sqlite3VdbeCurrentAddr(v);





  if( pMWin->eStart==pMWin->eEnd && regCountdown
   && pMWin->eFrmType==89 && op==2
  ){
    int regRowid1 = sqlite3GetTempReg(pParse);
    int regRowid2 = sqlite3GetTempReg(pParse);
    sqlite3VdbeAddOp2(v, 128, p->start.csr, regRowid1);
    sqlite3VdbeAddOp2(v, 128, p->end.csr, regRowid2);
    sqlite3VdbeAddOp3(v, 57, regRowid2, lblDone, regRowid1);
    ;
    sqlite3ReleaseTempReg(pParse, regRowid1);
    sqlite3ReleaseTempReg(pParse, regRowid2);
    ((void)0);
  }

  switch( op ){
    case 1:
      csr = p->current.csr;
      reg = p->current.reg;
      windowReturnOneRow(p);
      break;

    case 2:
      csr = p->start.csr;
      reg = p->start.reg;
      if( pMWin->regStartRowid ){
        ((void)0);
        sqlite3VdbeAddOp2(v, 83, pMWin->regStartRowid, 1);
      }else{
        windowAggStep(p, pMWin, csr, 1, p->regArg);
      }
      break;

    default:
      ((void)0);
      csr = p->end.csr;
      reg = p->end.reg;
      if( pMWin->regStartRowid ){
        ((void)0);
        sqlite3VdbeAddOp2(v, 83, pMWin->regEndRowid, 1);
      }else{
        windowAggStep(p, pMWin, csr, 0, p->regArg);
      }
      break;
  }

  if( op==p->eDelete ){
    sqlite3VdbeAddOp1(v, 123, csr);
    sqlite3VdbeChangeP5(v, 0x02);
  }

  if( jumpOnEof ){
    sqlite3VdbeAddOp2(v, 5, csr, sqlite3VdbeCurrentAddr(v)+2);
    ;
    ret = sqlite3VdbeAddOp0(v, 11);
  }else{
    sqlite3VdbeAddOp2(v, 5, csr, sqlite3VdbeCurrentAddr(v)+1+bPeer);
    ;
    if( bPeer ){
      sqlite3VdbeAddOp2(v, 11, 0, lblDone);
    }
  }

  if( bPeer ){
    int nReg = (pMWin->pOrderBy ? pMWin->pOrderBy->nExpr : 0);
    int regTmp = (nReg ? sqlite3GetTempRange(pParse, nReg) : 0);
    windowReadPeerValues(p, csr, regTmp);
    windowIfNewPeer(pParse, pMWin->pOrderBy, regTmp, reg, addrContinue);
    sqlite3ReleaseTempRange(pParse, regTmp, nReg);
  }

  if( addrNextRange ){
    sqlite3VdbeAddOp2(v, 11, 0, addrNextRange);
  }
  sqlite3VdbeResolveLabel(v, lblDone);
  return ret;
}







static Window *sqlite3WindowDup(sqlite3 *db, Expr *pOwner, Window *p){
  Window *pNew = 0;
  if( (p) ){
    pNew = sqlite3DbMallocZero(db, sizeof(Window));
    if( pNew ){
      pNew->zName = sqlite3DbStrDup(db, p->zName);
      pNew->zBase = sqlite3DbStrDup(db, p->zBase);
      pNew->pFilter = sqlite3ExprDup(db, p->pFilter, 0);
      pNew->pFunc = p->pFunc;
      pNew->pPartition = sqlite3ExprListDup(db, p->pPartition, 0);
      pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, 0);
      pNew->eFrmType = p->eFrmType;
      pNew->eEnd = p->eEnd;
      pNew->eStart = p->eStart;
      pNew->eExclude = p->eExclude;
      pNew->regResult = p->regResult;
      pNew->pStart = sqlite3ExprDup(db, p->pStart, 0);
      pNew->pEnd = sqlite3ExprDup(db, p->pEnd, 0);
      pNew->pOwner = pOwner;
      pNew->bImplicitFrame = p->bImplicitFrame;
    }
  }
  return pNew;
}





static Window *sqlite3WindowListDup(sqlite3 *db, Window *p){
  Window *pWin;
  Window *pRet = 0;
  Window **pp = &pRet;

  for(pWin=p; pWin; pWin=pWin->pNextWin){
    *pp = sqlite3WindowDup(db, 0, pWin);
    if( *pp==0 ) break;
    pp = &((*pp)->pNextWin);
  }

  return pRet;
}
# 148987 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int windowExprGtZero(Parse *pParse, Expr *pExpr){
  int ret = 0;
  sqlite3 *db = pParse->db;
  sqlite3_value *pVal = 0;
  sqlite3ValueFromExpr(db, pExpr, db->enc, 0x43, &pVal);
  if( pVal && sqlite3_value_int(pVal)>0 ){
    ret = 1;
  }
  sqlite3ValueFree(pVal);
  return ret;
}
# 149334 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3WindowCodeStep(
  Parse *pParse,
  Select *p,
  WhereInfo *pWInfo,
  int regGosub,
  int addrGosub
){
  Window *pMWin = p->pWin;
  ExprList *pOrderBy = pMWin->pOrderBy;
  Vdbe *v = sqlite3GetVdbe(pParse);
  int csrWrite;
  int csrInput = p->pSrc->a[0].iCursor;
  int nInput = p->pSrc->a[0].pTab->nCol;
  int iInput;
  int addrNe;
  int addrGosubFlush = 0;
  int addrInteger = 0;
  int addrEmpty;
  int regNew;
  int regRecord;
  int regRowid;
  int regNewPeer = 0;
  int regPeer = 0;
  int regFlushPart = 0;
  WindowCodeArg s;
  int lblWhereEnd;
  int regStart = 0;
  int regEnd = 0;

  ((void)0)

   ;
  ((void)0)

   ;
  ((void)0)


   ;

  lblWhereEnd = sqlite3VdbeMakeLabel(pParse);


  memset(&s, 0, sizeof(WindowCodeArg));
  s.pParse = pParse;
  s.pMWin = pMWin;
  s.pVdbe = v;
  s.regGosub = regGosub;
  s.addrGosub = addrGosub;
  s.current.csr = pMWin->iEphCsr;
  csrWrite = s.current.csr+1;
  s.start.csr = s.current.csr+2;
  s.end.csr = s.current.csr+3;







  switch( pMWin->eStart ){
    case 86:
      if( pMWin->eFrmType!=89
       && windowExprGtZero(pParse, pMWin->pStart)
      ){
        s.eDelete = 1;
      }
      break;
    case 90:
      if( windowCacheFrame(pMWin)==0 ){
        if( pMWin->eEnd==88 ){
          if( pMWin->eFrmType!=89
           && windowExprGtZero(pParse, pMWin->pEnd)
          ){
            s.eDelete = 3;
          }
        }else{
          s.eDelete = 1;
        }
      }
      break;
    default:
      s.eDelete = 2;
      break;
  }




  regNew = pParse->nMem+1;
  pParse->nMem += nInput;
  regRecord = ++pParse->nMem;
  regRowid = ++pParse->nMem;




  if( pMWin->eStart==88 || pMWin->eStart==86 ){
    regStart = ++pParse->nMem;
  }
  if( pMWin->eEnd==88 || pMWin->eEnd==86 ){
    regEnd = ++pParse->nMem;
  }




  if( pMWin->eFrmType!=76 ){
    int nPeer = (pOrderBy ? pOrderBy->nExpr : 0);
    regNewPeer = regNew + pMWin->nBufferCol;
    if( pMWin->pPartition ) regNewPeer += pMWin->pPartition->nExpr;
    regPeer = pParse->nMem+1; pParse->nMem += nPeer;
    s.start.reg = pParse->nMem+1; pParse->nMem += nPeer;
    s.current.reg = pParse->nMem+1; pParse->nMem += nPeer;
    s.end.reg = pParse->nMem+1; pParse->nMem += nPeer;
  }




  for(iInput=0; iInput<nInput; iInput++){
    sqlite3VdbeAddOp3(v, 90, csrInput, iInput, regNew+iInput);
  }
  sqlite3VdbeAddOp3(v, 92, regNew, nInput, regRecord);






  if( pMWin->pPartition ){
    int addr;
    ExprList *pPart = pMWin->pPartition;
    int nPart = pPart->nExpr;
    int regNewPart = regNew + pMWin->nBufferCol;
    KeyInfo *pKeyInfo = sqlite3KeyInfoFromExprList(pParse, pPart, 0, 0);

    regFlushPart = ++pParse->nMem;
    addr = sqlite3VdbeAddOp3(v, 87, regNewPart, pMWin->regPart, nPart);
    sqlite3VdbeAppendP4(v, (void*)pKeyInfo, (-9));
    sqlite3VdbeAddOp3(v, 16, addr+2, addr+4, addr+2);
    ;
    addrGosubFlush = sqlite3VdbeAddOp1(v, 12, regFlushPart);
    ;
    sqlite3VdbeAddOp3(v, 78, regNewPart, pMWin->regPart, nPart-1);
  }


  sqlite3VdbeAddOp2(v, 121, csrWrite, regRowid);
  sqlite3VdbeAddOp3(v, 122, csrWrite, regRecord, regRowid);
  addrNe = sqlite3VdbeAddOp3(v, 52, pMWin->regOne, 0, regRowid);
  ;


  s.regArg = windowInitAccum(pParse, pMWin);

  if( regStart ){
    sqlite3ExprCode(pParse, pMWin->pStart, regStart);
    windowCheckValue(pParse, regStart, 0 + (pMWin->eFrmType==89?3:0));
  }
  if( regEnd ){
    sqlite3ExprCode(pParse, pMWin->pEnd, regEnd);
    windowCheckValue(pParse, regEnd, 1 + (pMWin->eFrmType==89?3:0));
  }

  if( pMWin->eFrmType!=89 && pMWin->eStart==pMWin->eEnd && regStart ){
    int op = ((pMWin->eStart==86) ? 57 : 55);
    int addrGe = sqlite3VdbeAddOp3(v, op, regStart, 0, regEnd);
    ;
    ;
    windowAggFinal(&s, 0);
    sqlite3VdbeAddOp2(v, 36, s.current.csr, 1);
    ;
    windowReturnOneRow(&s);
    sqlite3VdbeAddOp1(v, 138, s.current.csr);
    sqlite3VdbeAddOp2(v, 11, 0, lblWhereEnd);
    sqlite3VdbeJumpHere(v, addrGe);
  }
  if( pMWin->eStart==86 && pMWin->eFrmType!=89 && regEnd ){
    ((void)0);
    sqlite3VdbeAddOp3(v, 104, regStart, regEnd, regStart);
  }

  if( pMWin->eStart!=90 ){
    sqlite3VdbeAddOp2(v, 36, s.start.csr, 1);
    ;
  }
  sqlite3VdbeAddOp2(v, 36, s.current.csr, 1);
  ;
  sqlite3VdbeAddOp2(v, 36, s.end.csr, 1);
  ;
  if( regPeer && pOrderBy ){
    sqlite3VdbeAddOp3(v, 78, regNewPeer, regPeer, pOrderBy->nExpr-1);
    sqlite3VdbeAddOp3(v, 78, regPeer, s.start.reg, pOrderBy->nExpr-1);
    sqlite3VdbeAddOp3(v, 78, regPeer, s.current.reg, pOrderBy->nExpr-1);
    sqlite3VdbeAddOp3(v, 78, regPeer, s.end.reg, pOrderBy->nExpr-1);
  }

  sqlite3VdbeAddOp2(v, 11, 0, lblWhereEnd);

  sqlite3VdbeJumpHere(v, addrNe);


  if( regPeer ){
    windowIfNewPeer(pParse, pOrderBy, regNewPeer, regPeer, lblWhereEnd);
  }
  if( pMWin->eStart==86 ){
    windowCodeOp(&s, 3, 0, 0);
    if( pMWin->eEnd!=90 ){
      if( pMWin->eFrmType==89 ){
        int lbl = sqlite3VdbeMakeLabel(pParse);
        int addrNext = sqlite3VdbeCurrentAddr(v);
        windowCodeRangeTest(&s, 57, s.current.csr, regEnd, s.end.csr, lbl);
        windowCodeOp(&s, 2, regStart, 0);
        windowCodeOp(&s, 1, 0, 0);
        sqlite3VdbeAddOp2(v, 11, 0, addrNext);
        sqlite3VdbeResolveLabel(v, lbl);
      }else{
        windowCodeOp(&s, 1, regEnd, 0);
        windowCodeOp(&s, 2, regStart, 0);
      }
    }
  }else
  if( pMWin->eEnd==88 ){
    int bRPS = (pMWin->eStart==88 && pMWin->eFrmType==89);
    windowCodeOp(&s, 3, regEnd, 0);
    if( bRPS ) windowCodeOp(&s, 2, regStart, 0);
    windowCodeOp(&s, 1, 0, 0);
    if( !bRPS ) windowCodeOp(&s, 2, regStart, 0);
  }else{
    int addr = 0;
    windowCodeOp(&s, 3, 0, 0);
    if( pMWin->eEnd!=90 ){
      if( pMWin->eFrmType==89 ){
        int lbl = 0;
        addr = sqlite3VdbeCurrentAddr(v);
        if( regEnd ){
          lbl = sqlite3VdbeMakeLabel(pParse);
          windowCodeRangeTest(&s, 57, s.current.csr, regEnd, s.end.csr, lbl);
        }
        windowCodeOp(&s, 1, 0, 0);
        windowCodeOp(&s, 2, regStart, 0);
        if( regEnd ){
          sqlite3VdbeAddOp2(v, 11, 0, addr);
          sqlite3VdbeResolveLabel(v, lbl);
        }
      }else{
        if( regEnd ){
          addr = sqlite3VdbeAddOp3(v, 47, regEnd, 0, 1);
          ;
        }
        windowCodeOp(&s, 1, 0, 0);
        windowCodeOp(&s, 2, regStart, 0);
        if( regEnd ) sqlite3VdbeJumpHere(v, addr);
      }
    }
  }


  sqlite3VdbeResolveLabel(v, lblWhereEnd);
  sqlite3WhereEnd(pWInfo);


  if( pMWin->pPartition ){
    addrInteger = sqlite3VdbeAddOp2(v, 70, 0, regFlushPart);
    sqlite3VdbeJumpHere(v, addrGosubFlush);
  }

  addrEmpty = sqlite3VdbeAddOp1(v, 36, csrWrite);
  ;
  if( pMWin->eEnd==88 ){
    int bRPS = (pMWin->eStart==88 && pMWin->eFrmType==89);
    windowCodeOp(&s, 3, regEnd, 0);
    if( bRPS ) windowCodeOp(&s, 2, regStart, 0);
    windowCodeOp(&s, 1, 0, 0);
  }else if( pMWin->eStart==86 ){
    int addrStart;
    int addrBreak1;
    int addrBreak2;
    int addrBreak3;
    windowCodeOp(&s, 3, 0, 0);
    if( pMWin->eFrmType==89 ){
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak2 = windowCodeOp(&s, 2, regStart, 1);
      addrBreak1 = windowCodeOp(&s, 1, 0, 1);
    }else
    if( pMWin->eEnd==90 ){
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(&s, 1, regStart, 1);
      addrBreak2 = windowCodeOp(&s, 2, 0, 1);
    }else{
      ((void)0);
      addrStart = sqlite3VdbeCurrentAddr(v);
      addrBreak1 = windowCodeOp(&s, 1, regEnd, 1);
      addrBreak2 = windowCodeOp(&s, 2, regStart, 1);
    }
    sqlite3VdbeAddOp2(v, 11, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak2);
    addrStart = sqlite3VdbeCurrentAddr(v);
    addrBreak3 = windowCodeOp(&s, 1, 0, 1);
    sqlite3VdbeAddOp2(v, 11, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak1);
    sqlite3VdbeJumpHere(v, addrBreak3);
  }else{
    int addrBreak;
    int addrStart;
    windowCodeOp(&s, 3, 0, 0);
    addrStart = sqlite3VdbeCurrentAddr(v);
    addrBreak = windowCodeOp(&s, 1, 0, 1);
    windowCodeOp(&s, 2, regStart, 0);
    sqlite3VdbeAddOp2(v, 11, 0, addrStart);
    sqlite3VdbeJumpHere(v, addrBreak);
  }
  sqlite3VdbeJumpHere(v, addrEmpty);

  sqlite3VdbeAddOp1(v, 138, s.current.csr);
  if( pMWin->pPartition ){
    if( pMWin->regStartRowid ){
      sqlite3VdbeAddOp2(v, 70, 1, pMWin->regStartRowid);
      sqlite3VdbeAddOp2(v, 70, 0, pMWin->regEndRowid);
    }
    sqlite3VdbeChangeP1(v, addrInteger, sqlite3VdbeCurrentAddr(v));
    sqlite3VdbeAddOp1(v, 66, regFlushPart);
  }
}
# 149698 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define YYNOERRORRECOVERY 1




#define yytestcase(X) testcase(X)





#define YYPARSEFREENEVERNULL 1
# 149721 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define sqlite3Parser_ENGINEALWAYSONSTACK 1






#define YYMALLOCARGTYPE u64
# 149739 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct TrigEvent { int a; IdList * b; };

struct FrameBound { int eType; Expr *pExpr; };





static void disableLookaside(Parse *pParse){
  pParse->disableLookaside++;
  pParse->db->lookaside.bDisable++;
}







  static void parserDoubleLinkSelect(Parse *pParse, Select *p){
    ((void)0);
    if( p->pPrior ){
      Select *pNext = 0, *pLoop;
      int mxSelect, cnt = 0;
      for(pLoop=p; pLoop; pNext=pLoop, pLoop=pLoop->pPrior, cnt++){
        pLoop->pNext = pNext;
        pLoop->selFlags |= 0x00100;
      }
      if( (p->selFlags & 0x00400)==0 &&
        (mxSelect = pParse->db->aLimit[4])>0 &&
        cnt>mxSelect
      ){
        sqlite3ErrorMsg(pParse, "too many terms in compound SELECT");
      }
    }
  }






  static Expr *tokenExpr(Parse *pParse, int op, Token t){
    Expr *p = sqlite3DbMallocRawNN(pParse->db, sizeof(Expr)+t.n+1);
    if( p ){

      p->op = (u8)op;
      p->affExpr = 0;
      p->flags = 0x800000;
      p->iAgg = -1;
      p->pLeft = p->pRight = 0;
      p->x.pList = 0;
      p->pAggInfo = 0;
      p->y.pTab = 0;
      p->op2 = 0;
      p->iTable = 0;
      p->iColumn = 0;
      p->u.zToken = (char*)&p[1];
      memcpy(p->u.zToken, t.z, t.n);
      p->u.zToken[t.n] = 0;
      if( (sqlite3CtypeMap[(unsigned char)(p->u.zToken[0])]&0x80) ){
        sqlite3DequoteExpr(p);
      }

      p->nHeight = 1;

      if( (pParse->eParseMode>=2) ){
        return (Expr*)sqlite3RenameTokenMap(pParse, (void*)p, &t);
      }
    }
    return p;
  }




  static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op){
    sqlite3 *db = pParse->db;
    if( pA && pY && pY->op==117 && !(pParse->eParseMode>=2) ){
      pA->op = (u8)op;
      sqlite3ExprDelete(db, pA->pRight);
      pA->pRight = 0;
    }
  }






  static ExprList *parserAddExprIdListTerm(
    Parse *pParse,
    ExprList *pPrior,
    Token *pIdToken,
    int hasCollate,
    int sortOrder
  ){
    ExprList *p = sqlite3ExprListAppend(pParse, pPrior, 0);
    if( (hasCollate || sortOrder!=-1)
        && pParse->db->init.busy==0
    ){
      sqlite3ErrorMsg(pParse, "syntax error after column name \"%.*s\"",
                         pIdToken->n, pIdToken->z);
    }
    sqlite3ExprListSetName(pParse, p, pIdToken, 1);
    return p;
  }
# 149909 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define INTERFACE 1


#define YYCODETYPE unsigned short int
#define YYNOCODE 307
#define YYACTIONTYPE unsigned short int
#define YYWILDCARD 98
#define sqlite3ParserTOKENTYPE Token
typedef union {
  int yyinit;
  Token yy0;
  const char* yy8;
  Select* yy25;
  int yy32;
  Expr* yy46;
  struct FrameBound yy57;
  u8 yy118;
  ExprList* yy138;
  Upsert* yy288;
  With* yy297;
  IdList* yy406;
  Window* yy455;
  struct {int value; int mask;} yy495;
  TriggerStep* yy527;
  struct TrigEvent yy572;
  SrcList* yy609;
} YYMINORTYPE;

#define YYSTACKDEPTH 100

#define sqlite3ParserARG_SDECL 
#define sqlite3ParserARG_PDECL 
#define sqlite3ParserARG_PARAM 
#define sqlite3ParserARG_FETCH 
#define sqlite3ParserARG_STORE 
#define sqlite3ParserCTX_SDECL Parse *pParse;
#define sqlite3ParserCTX_PDECL ,Parse *pParse
#define sqlite3ParserCTX_PARAM ,pParse
#define sqlite3ParserCTX_FETCH Parse *pParse=yypParser->pParse;
#define sqlite3ParserCTX_STORE yypParser->pParse=pParse;
#define YYFALLBACK 1
#define YYNSTATE 543
#define YYNRULE 381
#define YYNTOKEN 179
#define YY_MAX_SHIFT 542
#define YY_MIN_SHIFTREDUCE 790
#define YY_MAX_SHIFTREDUCE 1170
#define YY_ERROR_ACTION 1171
#define YY_ACCEPT_ACTION 1172
#define YY_NO_ACTION 1173
#define YY_MIN_REDUCE 1174
#define YY_MAX_REDUCE 1554

#define YY_NLOOKAHEAD ((int)(sizeof(yy_lookahead)/sizeof(yy_lookahead[0])))
# 150027 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define YY_ACTTAB_COUNT (1913)
static const unsigned short int yy_action[] = {
               537, 339, 537, 1241, 1220, 537, 12, 537, 112, 109,
               209, 537, 1241, 537, 1205, 462, 112, 109, 209, 386,
               338, 462, 42, 42, 42, 42, 445, 42, 42, 70,
                70, 922, 1208, 70, 70, 70, 70, 1443, 403, 923,
               531, 531, 531, 119, 120, 110, 1148, 1148, 991, 994,
               984, 984, 117, 117, 118, 118, 118, 118, 425, 386,
              1498, 542, 2, 1176, 1442, 519, 141, 1518, 289, 519,
               134, 519, 95, 259, 495, 1215, 189, 1254, 518, 494,
               484, 437, 296, 119, 120, 110, 1148, 1148, 991, 994,
               984, 984, 117, 117, 118, 118, 118, 118, 270, 116,
               116, 116, 116, 115, 115, 114, 114, 114, 113, 418,
               264, 264, 264, 264, 423, 1479, 352, 1481, 123, 351,
              1479, 508, 1094, 534, 1034, 534, 1099, 386, 1099, 239,
               206, 112, 109, 209, 96, 1094, 376, 219, 1094, 116,
               116, 116, 116, 115, 115, 114, 114, 114, 113, 418,
               480, 119, 120, 110, 1148, 1148, 991, 994, 984, 984,
               117, 117, 118, 118, 118, 118, 353, 422, 1407, 264,
               264, 114, 114, 114, 113, 418, 883, 121, 416, 416,
               416, 882, 534, 116, 116, 116, 116, 115, 115, 114,
               114, 114, 113, 418, 212, 415, 414, 386, 443, 383,
               382, 118, 118, 118, 118, 111, 177, 116, 116, 116,
               116, 115, 115, 114, 114, 114, 113, 418, 112, 109,
               209, 119, 120, 110, 1148, 1148, 991, 994, 984, 984,
               117, 117, 118, 118, 118, 118, 386, 438, 312, 1163,
              1155, 80, 1155, 1127, 514, 79, 116, 116, 116, 116,
               115, 115, 114, 114, 114, 113, 418, 514, 428, 418,
               119, 120, 110, 1148, 1148, 991, 994, 984, 984, 117,
               117, 118, 118, 118, 118, 428, 427, 116, 116, 116,
               116, 115, 115, 114, 114, 114, 113, 418, 115, 115,
               114, 114, 114, 113, 418, 1127, 1127, 1128, 1129, 1094,
               258, 258, 192, 386, 408, 371, 1168, 326, 118, 118,
               118, 118, 1094, 534, 374, 1094, 116, 116, 116, 116,
               115, 115, 114, 114, 114, 113, 418, 119, 120, 110,
              1148, 1148, 991, 994, 984, 984, 117, 117, 118, 118,
               118, 118, 386, 354, 445, 428, 829, 238, 1127, 1128,
              1129, 515, 1466, 116, 116, 116, 116, 115, 115, 114,
               114, 114, 113, 418, 1127, 1467, 119, 120, 110, 1148,
              1148, 991, 994, 984, 984, 117, 117, 118, 118, 118,
               118, 1169, 82, 116, 116, 116, 116, 115, 115, 114,
               114, 114, 113, 418, 405, 112, 109, 209, 161, 445,
               250, 267, 336, 478, 331, 477, 236, 951, 1127, 386,
               888, 1521, 329, 822, 852, 162, 274, 1127, 1128, 1129,
               338, 169, 116, 116, 116, 116, 115, 115, 114, 114,
               114, 113, 418, 119, 120, 110, 1148, 1148, 991, 994,
               984, 984, 117, 117, 118, 118, 118, 118, 386, 438,
               312, 1502, 1112, 1176, 161, 288, 528, 311, 289, 883,
               134, 1127, 1128, 1129, 882, 537, 143, 1254, 288, 528,
               297, 275, 119, 120, 110, 1148, 1148, 991, 994, 984,
               984, 117, 117, 118, 118, 118, 118, 70, 70, 116,
               116, 116, 116, 115, 115, 114, 114, 114, 113, 418,
               264, 264, 12, 264, 264, 395, 1127, 483, 1473, 1094,
               204, 482, 6, 534, 1258, 386, 534, 1474, 825, 972,
               504, 6, 1094, 500, 95, 1094, 534, 219, 116, 116,
               116, 116, 115, 115, 114, 114, 114, 113, 418, 119,
               120, 110, 1148, 1148, 991, 994, 984, 984, 117, 117,
               118, 118, 118, 118, 386, 1339, 971, 422, 956, 1127,
              1128, 1129, 231, 512, 1473, 475, 472, 471, 6, 113,
               418, 825, 962, 298, 503, 470, 961, 452, 119, 120,
               110, 1148, 1148, 991, 994, 984, 984, 117, 117, 118,
               118, 118, 118, 395, 537, 116, 116, 116, 116, 115,
               115, 114, 114, 114, 113, 418, 202, 961, 961, 963,
               231, 971, 1127, 475, 472, 471, 13, 13, 951, 1127,
               834, 386, 1207, 470, 399, 183, 447, 962, 462, 162,
               397, 961, 1246, 1246, 116, 116, 116, 116, 115, 115,
               114, 114, 114, 113, 418, 119, 120, 110, 1148, 1148,
               991, 994, 984, 984, 117, 117, 118, 118, 118, 118,
               386, 271, 961, 961, 963, 1127, 1128, 1129, 311, 433,
               299, 1406, 1127, 1128, 1129, 178, 1471, 138, 162, 32,
                 6, 1127, 288, 528, 119, 120, 110, 1148, 1148, 991,
               994, 984, 984, 117, 117, 118, 118, 118, 118, 909,
               390, 116, 116, 116, 116, 115, 115, 114, 114, 114,
               113, 418, 1127, 429, 817, 537, 1127, 265, 265, 981,
               981, 992, 995, 324, 1055, 93, 520, 5, 338, 537,
               534, 288, 528, 1522, 1127, 1128, 1129, 70, 70, 1056,
               116, 116, 116, 116, 115, 115, 114, 114, 114, 113,
               418, 70, 70, 1495, 1057, 537, 98, 1244, 1244, 264,
               264, 908, 371, 1076, 1127, 1127, 1128, 1129, 817, 1127,
              1128, 1129, 534, 519, 140, 863, 386, 13, 13, 456,
               192, 193, 521, 453, 319, 864, 322, 284, 365, 430,
               985, 402, 379, 1077, 1548, 101, 386, 1548, 3, 395,
               119, 120, 110, 1148, 1148, 991, 994, 984, 984, 117,
               117, 118, 118, 118, 118, 386, 451, 1127, 1128, 1129,
               119, 120, 110, 1148, 1148, 991, 994, 984, 984, 117,
               117, 118, 118, 118, 118, 1127, 1354, 1412, 1169, 119,
               108, 110, 1148, 1148, 991, 994, 984, 984, 117, 117,
               118, 118, 118, 118, 1412, 1414, 116, 116, 116, 116,
               115, 115, 114, 114, 114, 113, 418, 272, 535, 1075,
               877, 877, 337, 1492, 309, 462, 116, 116, 116, 116,
               115, 115, 114, 114, 114, 113, 418, 537, 1127, 1128,
              1129, 537, 360, 537, 356, 116, 116, 116, 116, 115,
               115, 114, 114, 114, 113, 418, 386, 264, 264, 13,
                13, 273, 1127, 13, 13, 13, 13, 304, 1253, 386,
               534, 1077, 1549, 404, 1412, 1549, 496, 277, 451, 186,
              1252, 120, 110, 1148, 1148, 991, 994, 984, 984, 117,
               117, 118, 118, 118, 118, 110, 1148, 1148, 991, 994,
               984, 984, 117, 117, 118, 118, 118, 118, 105, 529,
               537, 4, 1339, 264, 264, 1127, 1128, 1129, 1039, 1039,
               459, 795, 796, 797, 536, 532, 534, 242, 301, 807,
               303, 462, 69, 69, 451, 1353, 116, 116, 116, 116,
               115, 115, 114, 114, 114, 113, 418, 1075, 419, 116,
               116, 116, 116, 115, 115, 114, 114, 114, 113, 418,
               526, 537, 1146, 192, 350, 105, 529, 537, 4, 497,
               162, 337, 1492, 310, 1249, 385, 1550, 372, 9, 462,
               242, 400, 532, 13, 13, 499, 971, 843, 436, 70,
                70, 359, 103, 103, 8, 339, 278, 187, 278, 104,
              1127, 419, 539, 538, 1339, 419, 961, 302, 1339, 1172,
                 1, 1, 542, 2, 1176, 1146, 1146, 526, 476, 289,
                30, 134, 317, 288, 528, 285, 844, 1014, 1254, 276,
              1472, 506, 410, 1194, 6, 207, 505, 961, 961, 963,
               964, 27, 449, 971, 415, 414, 234, 233, 232, 103,
               103, 31, 1152, 1127, 1128, 1129, 104, 1154, 419, 539,
               538, 264, 264, 961, 1399, 1153, 264, 264, 1470, 1146,
               537, 216, 6, 401, 534, 1197, 392, 458, 406, 534,
               537, 485, 358, 537, 261, 537, 1339, 907, 219, 1155,
               467, 1155, 50, 50, 961, 961, 963, 964, 27, 1497,
              1116, 421, 70, 70, 268, 70, 70, 13, 13, 369,
               369, 368, 253, 366, 264, 264, 804, 235, 422, 105,
               529, 516, 4, 287, 487, 510, 493, 534, 486, 213,
              1055, 294, 490, 384, 1127, 450, 532, 338, 413, 293,
               522, 417, 335, 1036, 509, 1056, 107, 1036, 16, 16,
              1469, 1094, 334, 1105, 6, 411, 1145, 264, 264, 419,
              1057, 102, 511, 100, 1094, 264, 264, 1094, 922, 215,
               534, 526, 907, 264, 264, 208, 923, 154, 534, 457,
               156, 525, 391, 142, 218, 506, 534, 1127, 1128, 1129,
               507, 139, 1131, 38, 214, 530, 392, 971, 329, 1454,
               907, 1105, 537, 103, 103, 105, 529, 537, 4, 537,
               104, 424, 419, 539, 538, 537, 502, 961, 517, 537,
              1072, 537, 532, 373, 54, 54, 288, 528, 387, 55,
                55, 15, 15, 288, 528, 17, 136, 44, 44, 1451,
               537, 56, 56, 57, 57, 419, 1131, 291, 961, 961,
               963, 964, 27, 393, 163, 537, 426, 526, 263, 206,
               208, 517, 58, 58, 235, 440, 842, 841, 197, 105,
               529, 506, 4, 1033, 439, 1033, 505, 59, 59, 308,
               849, 850, 95, 971, 537, 907, 532, 948, 832, 103,
               103, 105, 529, 537, 4, 1021, 104, 537, 419, 539,
               538, 1116, 421, 961, 537, 268, 60, 60, 532, 419,
               369, 369, 368, 253, 366, 61, 61, 804, 965, 45,
                45, 526, 537, 1032, 1277, 1032, 46, 46, 537, 391,
               213, 419, 294, 266, 961, 961, 963, 964, 27, 292,
               293, 295, 832, 526, 48, 48, 1290, 971, 1289, 1021,
                49, 49, 432, 103, 103, 887, 953, 537, 1457, 241,
               104, 305, 419, 539, 538, 925, 926, 961, 444, 971,
               215, 241, 965, 1224, 537, 103, 103, 1431, 154, 62,
                62, 156, 104, 1430, 419, 539, 538, 97, 529, 961,
                 4, 537, 454, 537, 314, 214, 63, 63, 961, 961,
               963, 964, 27, 537, 532, 446, 1286, 318, 241, 537,
               321, 323, 325, 64, 64, 14, 14, 1237, 537, 1223,
               961, 961, 963, 964, 27, 65, 65, 419, 537, 387,
               537, 125, 125, 537, 288, 528, 537, 1486, 537, 526,
                66, 66, 313, 524, 537, 95, 468, 1221, 1511, 237,
                51, 51, 67, 67, 330, 68, 68, 426, 52, 52,
               149, 149, 1222, 340, 341, 971, 150, 150, 1298, 463,
               327, 103, 103, 95, 537, 1338, 1273, 537, 104, 537,
               419, 539, 538, 1284, 537, 961, 268, 283, 523, 1344,
              1204, 369, 369, 368, 253, 366, 75, 75, 804, 53,
                53, 71, 71, 537, 1196, 537, 126, 126, 537, 1017,
               537, 213, 237, 294, 537, 1185, 961, 961, 963, 964,
                27, 293, 537, 1184, 537, 72, 72, 127, 127, 1186,
               128, 128, 124, 124, 1505, 537, 148, 148, 537, 256,
               195, 537, 1270, 537, 147, 147, 132, 132, 537, 11,
               537, 215, 537, 199, 343, 345, 347, 131, 131, 154,
               129, 129, 156, 130, 130, 74, 74, 537, 370, 1323,
                76, 76, 73, 73, 43, 43, 214, 431, 211, 1331,
               300, 916, 880, 815, 241, 107, 137, 307, 881, 47,
                47, 107, 473, 378, 203, 448, 333, 1403, 1220, 1402,
               349, 190, 527, 191, 363, 198, 1508, 1163, 245, 165,
               387, 1450, 1448, 1160, 78, 288, 528, 1408, 81, 394,
                82, 442, 175, 159, 167, 93, 1328, 35, 1320, 434,
               170, 171, 172, 173, 435, 466, 221, 375, 426, 377,
              1334, 179, 455, 441, 1397, 225, 87, 36, 461, 1419,
               316, 257, 227, 184, 320, 464, 228, 479, 1187, 229,
               380, 1240, 1239, 407, 1238, 1212, 834, 332, 1231, 381,
               409, 1211, 204, 1210, 1491, 498, 1520, 1281, 92, 281,
              1230, 489, 282, 492, 342, 243, 1282, 344, 244, 1280,
               346, 412, 1279, 1477, 348, 122, 1476, 517, 10, 357,
               286, 1305, 1304, 99, 1383, 94, 501, 251, 1193, 34,
              1263, 355, 540, 194, 1262, 361, 362, 1122, 252, 254,
               255, 388, 541, 1182, 1177, 151, 1435, 389, 1436, 1434,
              1433, 791, 152, 135, 279, 200, 201, 420, 196, 77,
               153, 290, 269, 210, 1031, 133, 1029, 945, 166, 155,
               217, 168, 866, 306, 220, 1045, 174, 949, 157, 396,
                83, 398, 176, 84, 85, 164, 86, 158, 1048, 222,
               223, 1044, 144, 18, 224, 315, 1037, 180, 241, 460,
              1157, 226, 181, 37, 806, 465, 334, 230, 328, 469,
               182, 88, 474, 19, 20, 160, 89, 280, 145, 90,
               481, 845, 1110, 146, 997, 205, 1080, 39, 91, 40,
               488, 1081, 915, 491, 260, 262, 185, 910, 240, 107,
              1100, 1096, 1098, 1104, 21, 1084, 33, 513, 247, 22,
                23, 24, 1103, 25, 188, 95, 1012, 998, 996, 26,
              1000, 1054, 7, 1053, 1001, 246, 28, 41, 533, 966,
               816, 106, 29, 367, 248, 249, 1513, 1512, 364, 1117,
              1173, 1173, 876,
};
static const unsigned short int yy_lookahead[] = {
               187, 187, 187, 216, 217, 187, 206, 187, 264, 265,
               266, 187, 225, 187, 209, 187, 264, 265, 266, 19,
               187, 187, 209, 210, 209, 210, 187, 209, 210, 209,
               210, 31, 209, 209, 210, 209, 210, 285, 224, 39,
               203, 204, 205, 43, 44, 45, 46, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 230, 19,
               181, 182, 183, 184, 230, 245, 233, 208, 189, 245,
               191, 245, 26, 206, 254, 216, 276, 198, 254, 198,
               254, 281, 187, 43, 44, 45, 46, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 259, 99,
               100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
               231, 232, 231, 232, 286, 302, 303, 302, 22, 304,
               302, 303, 76, 244, 11, 244, 86, 19, 88, 248,
               249, 264, 265, 266, 26, 89, 198, 258, 92, 99,
               100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
               105, 43, 44, 45, 46, 47, 48, 49, 50, 51,
                52, 53, 54, 55, 56, 57, 212, 288, 273, 231,
               232, 105, 106, 107, 108, 109, 131, 69, 203, 204,
               205, 136, 244, 99, 100, 101, 102, 103, 104, 105,
               106, 107, 108, 109, 15, 103, 104, 19, 260, 103,
               104, 54, 55, 56, 57, 58, 22, 99, 100, 101,
               102, 103, 104, 105, 106, 107, 108, 109, 264, 265,
               266, 43, 44, 45, 46, 47, 48, 49, 50, 51,
                52, 53, 54, 55, 56, 57, 19, 124, 125, 60,
               148, 24, 150, 59, 187, 67, 99, 100, 101, 102,
               103, 104, 105, 106, 107, 108, 109, 187, 187, 109,
                43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 204, 205, 99, 100, 101,
               102, 103, 104, 105, 106, 107, 108, 109, 103, 104,
               105, 106, 107, 108, 109, 59, 112, 113, 114, 76,
               231, 232, 187, 19, 19, 22, 23, 23, 54, 55,
                56, 57, 89, 244, 199, 92, 99, 100, 101, 102,
               103, 104, 105, 106, 107, 108, 109, 43, 44, 45,
                46, 47, 48, 49, 50, 51, 52, 53, 54, 55,
                56, 57, 19, 212, 187, 274, 23, 26, 112, 113,
               114, 294, 295, 99, 100, 101, 102, 103, 104, 105,
               106, 107, 108, 109, 59, 295, 43, 44, 45, 46,
                47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                57, 98, 146, 99, 100, 101, 102, 103, 104, 105,
               106, 107, 108, 109, 109, 264, 265, 266, 187, 187,
               115, 116, 117, 118, 119, 120, 121, 73, 59, 19,
               105, 23, 127, 23, 26, 81, 259, 112, 113, 114,
               187, 72, 99, 100, 101, 102, 103, 104, 105, 106,
               107, 108, 109, 43, 44, 45, 46, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 19, 124,
               125, 182, 23, 184, 187, 134, 135, 123, 189, 131,
               191, 112, 113, 114, 136, 187, 233, 198, 134, 135,
               198, 259, 43, 44, 45, 46, 47, 48, 49, 50,
                51, 52, 53, 54, 55, 56, 57, 209, 210, 99,
               100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
               231, 232, 206, 231, 232, 187, 59, 296, 297, 76,
               160, 161, 301, 244, 232, 19, 244, 297, 59, 23,
                87, 301, 89, 245, 26, 92, 244, 258, 99, 100,
               101, 102, 103, 104, 105, 106, 107, 108, 109, 43,
                44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
                54, 55, 56, 57, 19, 187, 97, 288, 23, 112,
               113, 114, 115, 296, 297, 118, 119, 120, 301, 108,
               109, 112, 113, 255, 141, 128, 117, 281, 43, 44,
                45, 46, 47, 48, 49, 50, 51, 52, 53, 54,
                55, 56, 57, 187, 187, 99, 100, 101, 102, 103,
               104, 105, 106, 107, 108, 109, 26, 148, 149, 150,
               115, 97, 59, 118, 119, 120, 209, 210, 73, 59,
               122, 19, 209, 128, 256, 72, 187, 113, 187, 81,
               223, 117, 227, 228, 99, 100, 101, 102, 103, 104,
               105, 106, 107, 108, 109, 43, 44, 45, 46, 47,
                48, 49, 50, 51, 52, 53, 54, 55, 56, 57,
                19, 255, 148, 149, 150, 112, 113, 114, 123, 124,
               125, 230, 112, 113, 114, 22, 297, 22, 81, 22,
               301, 59, 134, 135, 43, 44, 45, 46, 47, 48,
                49, 50, 51, 52, 53, 54, 55, 56, 57, 139,
               192, 99, 100, 101, 102, 103, 104, 105, 106, 107,
               108, 109, 59, 116, 59, 187, 59, 231, 232, 46,
                47, 48, 49, 16, 12, 145, 198, 22, 187, 187,
               244, 134, 135, 222, 112, 113, 114, 209, 210, 27,
                99, 100, 101, 102, 103, 104, 105, 106, 107, 108,
               109, 209, 210, 187, 42, 187, 154, 227, 228, 231,
               232, 139, 22, 23, 59, 112, 113, 114, 113, 112,
               113, 114, 244, 245, 233, 63, 19, 209, 210, 271,
               187, 24, 254, 275, 77, 73, 79, 245, 195, 260,
               117, 223, 199, 22, 23, 154, 19, 26, 22, 187,
                43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 19, 187, 112, 113, 114,
                43, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 59, 263, 187, 98, 43,
                44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
                54, 55, 56, 57, 204, 205, 99, 100, 101, 102,
               103, 104, 105, 106, 107, 108, 109, 255, 130, 98,
               132, 133, 299, 300, 198, 187, 99, 100, 101, 102,
               103, 104, 105, 106, 107, 108, 109, 187, 112, 113,
               114, 187, 241, 187, 243, 99, 100, 101, 102, 103,
               104, 105, 106, 107, 108, 109, 19, 231, 232, 209,
               210, 282, 59, 209, 210, 209, 210, 16, 230, 19,
               244, 22, 23, 223, 274, 26, 19, 223, 187, 223,
               198, 44, 45, 46, 47, 48, 49, 50, 51, 52,
                53, 54, 55, 56, 57, 45, 46, 47, 48, 49,
                50, 51, 52, 53, 54, 55, 56, 57, 19, 20,
               187, 22, 187, 231, 232, 112, 113, 114, 123, 124,
               125, 7, 8, 9, 187, 36, 244, 24, 77, 21,
                79, 187, 209, 210, 187, 263, 99, 100, 101, 102,
               103, 104, 105, 106, 107, 108, 109, 98, 59, 99,
               100, 101, 102, 103, 104, 105, 106, 107, 108, 109,
                71, 187, 59, 187, 187, 19, 20, 187, 22, 112,
                81, 299, 300, 282, 230, 199, 291, 292, 22, 187,
                24, 256, 36, 209, 210, 187, 97, 35, 80, 209,
               210, 268, 103, 104, 48, 187, 220, 223, 222, 110,
                59, 112, 113, 114, 187, 59, 117, 156, 187, 179,
               180, 181, 182, 183, 184, 59, 113, 71, 66, 189,
                22, 191, 230, 134, 135, 245, 74, 119, 198, 282,
               297, 85, 224, 198, 301, 187, 90, 148, 149, 150,
               151, 152, 19, 97, 103, 104, 123, 124, 125, 103,
               104, 53, 111, 112, 113, 114, 110, 116, 112, 113,
               114, 231, 232, 117, 156, 124, 231, 232, 297, 113,
               187, 24, 301, 256, 244, 201, 202, 256, 126, 244,
               187, 198, 187, 187, 23, 187, 187, 26, 258, 148,
                19, 150, 209, 210, 148, 149, 150, 151, 152, 0,
                 1, 2, 209, 210, 5, 209, 210, 209, 210, 10,
                11, 12, 13, 14, 231, 232, 17, 46, 288, 19,
                20, 223, 22, 236, 198, 66, 187, 244, 245, 30,
                12, 32, 198, 246, 59, 112, 36, 187, 245, 40,
               198, 245, 117, 29, 85, 27, 26, 33, 209, 210,
               297, 76, 127, 94, 301, 256, 26, 231, 232, 59,
                42, 153, 87, 155, 89, 231, 232, 92, 31, 70,
               244, 71, 26, 231, 232, 114, 39, 78, 244, 65,
                81, 63, 111, 233, 137, 85, 244, 112, 113, 114,
                90, 22, 59, 24, 95, 201, 202, 97, 127, 187,
               139, 142, 187, 103, 104, 19, 20, 187, 22, 187,
               110, 187, 112, 113, 114, 187, 141, 117, 141, 187,
                23, 187, 36, 26, 209, 210, 134, 135, 129, 209,
               210, 209, 210, 134, 135, 22, 159, 209, 210, 187,
               187, 209, 210, 209, 210, 59, 113, 187, 148, 149,
               150, 151, 152, 289, 290, 187, 157, 71, 248, 249,
               114, 141, 209, 210, 46, 125, 116, 117, 138, 19,
                20, 85, 22, 148, 61, 150, 90, 209, 210, 23,
                 7, 8, 26, 97, 187, 139, 36, 147, 59, 103,
               104, 19, 20, 187, 22, 59, 110, 187, 112, 113,
               114, 1, 2, 117, 187, 5, 209, 210, 36, 59,
                10, 11, 12, 13, 14, 209, 210, 17, 59, 209,
               210, 71, 187, 148, 250, 150, 209, 210, 187, 111,
                30, 59, 32, 22, 148, 149, 150, 151, 152, 187,
                40, 187, 113, 71, 209, 210, 187, 97, 187, 113,
               209, 210, 187, 103, 104, 105, 23, 187, 187, 26,
               110, 187, 112, 113, 114, 83, 84, 117, 23, 97,
                70, 26, 113, 218, 187, 103, 104, 187, 78, 209,
               210, 81, 110, 187, 112, 113, 114, 19, 20, 117,
                22, 187, 187, 187, 187, 95, 209, 210, 148, 149,
               150, 151, 152, 187, 36, 23, 187, 187, 26, 187,
               187, 187, 187, 209, 210, 209, 210, 187, 187, 218,
               148, 149, 150, 151, 152, 209, 210, 59, 187, 129,
               187, 209, 210, 187, 134, 135, 187, 306, 187, 71,
               209, 210, 23, 228, 187, 26, 23, 187, 137, 26,
               209, 210, 209, 210, 187, 209, 210, 157, 209, 210,
               209, 210, 218, 187, 187, 97, 209, 210, 187, 278,
                23, 103, 104, 26, 187, 187, 187, 187, 110, 187,
               112, 113, 114, 187, 187, 117, 5, 247, 187, 187,
               187, 10, 11, 12, 13, 14, 209, 210, 17, 209,
               210, 209, 210, 187, 187, 187, 209, 210, 187, 23,
               187, 30, 26, 32, 187, 187, 148, 149, 150, 151,
               152, 40, 187, 187, 187, 209, 210, 209, 210, 187,
               209, 210, 209, 210, 187, 187, 209, 210, 187, 277,
               234, 187, 247, 187, 209, 210, 209, 210, 187, 235,
               187, 70, 187, 207, 247, 247, 247, 209, 210, 78,
               209, 210, 81, 209, 210, 209, 210, 187, 185, 238,
               209, 210, 209, 210, 209, 210, 95, 251, 287, 238,
               251, 23, 23, 23, 26, 26, 26, 283, 23, 209,
               210, 26, 213, 238, 221, 283, 212, 212, 217, 212,
               251, 241, 270, 241, 237, 235, 190, 60, 137, 287,
               129, 194, 194, 38, 284, 134, 135, 273, 284, 194,
               146, 111, 22, 43, 226, 145, 262, 261, 238, 18,
               229, 229, 229, 229, 194, 18, 193, 238, 157, 262,
               226, 226, 194, 238, 238, 193, 153, 261, 62, 280,
               279, 194, 193, 22, 194, 214, 193, 111, 194, 193,
               214, 211, 211, 64, 211, 211, 122, 211, 219, 214,
               109, 213, 160, 211, 300, 140, 211, 253, 111, 272,
               219, 214, 272, 214, 252, 194, 253, 252, 91, 253,
               252, 82, 253, 305, 252, 144, 305, 141, 22, 194,
               269, 257, 257, 153, 267, 143, 142, 25, 197, 26,
               242, 241, 196, 240, 242, 239, 238, 13, 188, 188,
                 6, 293, 186, 186, 186, 200, 206, 293, 206, 206,
               206, 4, 200, 215, 215, 207, 207, 3, 22, 206,
               200, 158, 96, 15, 23, 16, 23, 135, 146, 126,
                24, 138, 20, 16, 140, 1, 138, 147, 126, 61,
                53, 37, 146, 53, 53, 290, 53, 126, 112, 34,
               137, 1, 5, 22, 111, 156, 68, 68, 26, 41,
                75, 137, 111, 24, 20, 19, 127, 121, 23, 67,
                22, 22, 67, 22, 22, 37, 22, 67, 23, 145,
                22, 28, 23, 23, 23, 137, 23, 22, 26, 22,
                24, 23, 112, 24, 23, 23, 22, 139, 34, 26,
                75, 88, 86, 75, 34, 23, 22, 24, 22, 34,
                34, 34, 93, 34, 26, 26, 23, 23, 23, 34,
                23, 23, 44, 23, 11, 26, 22, 22, 26, 23,
                23, 22, 22, 15, 137, 137, 137, 137, 23, 1,
               307, 307, 131, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307, 307, 307, 307, 307, 307, 307, 307, 307,
               307, 307,
};
#define YY_SHIFT_COUNT (542)
#define YY_SHIFT_MIN (0)
#define YY_SHIFT_MAX (1908)
static const unsigned short int yy_shift_ofst[] = {
              1350, 1149, 1531, 939, 939, 548, 996, 1150, 1236, 1322,
              1322, 1322, 334, 0, 0, 178, 777, 1322, 1322, 1322,
              1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
               991, 991, 1125, 1125, 447, 597, 548, 548, 548, 548,
               548, 548, 40, 108, 217, 284, 323, 390, 429, 496,
               535, 602, 641, 757, 777, 777, 777, 777, 777, 777,
               777, 777, 777, 777, 777, 777, 777, 777, 777, 777,
               777, 777, 796, 777, 887, 900, 900, 1300, 1322, 1322,
              1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
              1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
              1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
              1418, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322, 1322,
              1322, 1322, 1322, 1322, 147, 254, 254, 254, 254, 254,
                84, 185, 66, 853, 958, 1121, 853, 92, 92, 853,
               321, 321, 321, 321, 325, 350, 350, 461, 150, 1913,
              1913, 285, 285, 285, 236, 184, 349, 184, 184, 712,
               712, 433, 553, 771, 899, 853, 853, 853, 853, 853,
               853, 853, 853, 853, 853, 853, 853, 853, 853, 853,
               853, 853, 853, 853, 853, 853, 46, 46, 853, 113,
               223, 223, 1183, 1183, 1127, 1142, 1913, 1913, 1913, 459,
               514, 514, 653, 495, 657, 305, 705, 560, 622, 776,
               853, 853, 853, 853, 853, 853, 853, 853, 853, 545,
               853, 853, 853, 853, 853, 853, 853, 853, 853, 853,
               853, 853, 1002, 1002, 1002, 853, 853, 853, 853, 1111,
               853, 853, 853, 1006, 1109, 853, 853, 1168, 853, 853,
               853, 853, 853, 853, 853, 853, 845, 1164, 738, 953,
               953, 953, 953, 1196, 738, 738, 45, 96, 964, 179,
               580, 907, 907, 1073, 580, 580, 1073, 498, 388, 1268,
              1187, 1187, 1187, 907, 1170, 1170, 1058, 1180, 328, 1219,
              1597, 1521, 1521, 1625, 1625, 1521, 1524, 1560, 1650, 1630,
              1530, 1661, 1661, 1661, 1661, 1521, 1667, 1530, 1530, 1560,
              1650, 1630, 1630, 1530, 1521, 1667, 1543, 1636, 1521, 1667,
              1681, 1521, 1667, 1521, 1667, 1681, 1596, 1596, 1596, 1649,
              1681, 1596, 1594, 1596, 1649, 1596, 1596, 1562, 1681, 1611,
              1611, 1681, 1585, 1617, 1585, 1617, 1585, 1617, 1585, 1617,
              1521, 1647, 1647, 1659, 1659, 1601, 1606, 1726, 1521, 1600,
              1601, 1612, 1614, 1530, 1732, 1733, 1754, 1754, 1764, 1764,
              1764, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913, 1913,
              1913, 1913, 1913, 1913, 1913, 1913, 673, 901, 283, 740,
               707, 973, 655, 1247, 1048, 1097, 1190, 1306, 1263, 1383,
              1395, 1432, 1469, 1473, 1497, 1279, 1200, 1323, 1075, 1286,
              1536, 1608, 1332, 1609, 1175, 1225, 1610, 1615, 1309, 1361,
              1777, 1784, 1766, 1633, 1778, 1696, 1779, 1771, 1773, 1662,
              1652, 1673, 1776, 1663, 1782, 1664, 1787, 1804, 1668, 1660,
              1682, 1748, 1774, 1666, 1757, 1760, 1761, 1763, 1691, 1706,
              1785, 1683, 1820, 1817, 1801, 1713, 1669, 1758, 1802, 1759,
              1755, 1788, 1694, 1721, 1809, 1814, 1816, 1709, 1716, 1818,
              1772, 1819, 1821, 1815, 1822, 1775, 1823, 1824, 1780, 1808,
              1825, 1704, 1828, 1829, 1830, 1831, 1832, 1833, 1835, 1836,
              1838, 1837, 1839, 1718, 1841, 1842, 1750, 1834, 1844, 1728,
              1843, 1840, 1845, 1846, 1847, 1783, 1795, 1786, 1848, 1798,
              1789, 1849, 1852, 1854, 1853, 1858, 1859, 1855, 1863, 1843,
              1864, 1865, 1867, 1868, 1869, 1870, 1856, 1883, 1874, 1875,
              1876, 1877, 1879, 1880, 1872, 1781, 1767, 1768, 1769, 1770,
              1885, 1888, 1908,
};
#define YY_REDUCE_COUNT (385)
#define YY_REDUCE_MIN (-256)
#define YY_REDUCE_MAX (1590)
static const short yy_reduce_ofst[] = {
               880, -121, 269, 528, 933, -119, -187, -185, -182, -180,
              -176, -174, -62, -46, 131, -248, -133, 407, 568, 700,
               704, 278, 706, 824, 542, 830, 948, 773, 943, 946,
                71, 650, 211, 267, 826, 272, 676, 732, 885, 976,
               984, 992, -256, -256, -256, -256, -256, -256, -256, -256,
              -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
              -256, -256, -256, -256, -256, -256, -256, -256, -256, -256,
              -256, -256, -256, -256, -256, -256, -256, 989, 1065, 1070,
              1072, 1078, 1082, 1084, 1103, 1118, 1147, 1156, 1160, 1167,
              1185, 1191, 1220, 1237, 1254, 1256, 1266, 1272, 1281, 1291,
              1293, 1296, 1299, 1301, 1307, 1337, 1340, 1342, 1347, 1366,
              1368, 1371, 1373, 1377, 1385, 1387, 1398, 1401, 1404, 1406,
              1411, 1413, 1415, 1430, -256, -256, -256, -256, -256, -256,
              -256, -256, -256, -172, 508, -213, 57, -163, -25, 593,
                69, 486, 69, 486, -200, 573, 722, -256, -256, -256,
              -256, -141, -141, -141, -105, -161, -167, 157, 212, 405,
               530, 220, 233, 735, 735, 115, 318, 406, 612, 541,
              -166, 441, 688, 794, 629, 368, 741, 775, 867, 797,
               871, 842, -186, 1000, 858, 949, 379, 783, 70, 296,
               821, 903, 924, 1044, 651, 282, 1014, 1060, 937, -195,
              -177, 413, 439, 511, 566, 787, 827, 848, 898, 945,
              1062, 1074, 1102, 1110, 1202, 1204, 1209, 1211, 1215, 529,
              1221, 1224, 1240, 1246, 1255, 1257, 1269, 1270, 1273, 1274,
              1275, 1280, 1205, 1251, 1294, 1310, 1317, 1326, 1327, 1124,
              1331, 1338, 1339, 1290, 1181, 1346, 1351, 1265, 1352, 787,
              1353, 1367, 1378, 1386, 1392, 1397, 1241, 1312, 1356, 1345,
              1357, 1358, 1359, 1124, 1356, 1356, 1364, 1396, 1433, 1341,
              1381, 1376, 1379, 1354, 1391, 1405, 1362, 1429, 1423, 1431,
              1434, 1435, 1437, 1399, 1410, 1412, 1382, 1417, 1420, 1466,
              1372, 1467, 1468, 1380, 1384, 1475, 1394, 1414, 1416, 1448,
              1440, 1451, 1452, 1453, 1454, 1490, 1493, 1449, 1455, 1427,
              1436, 1464, 1465, 1456, 1498, 1502, 1419, 1421, 1507, 1509,
              1491, 1510, 1513, 1514, 1516, 1496, 1500, 1501, 1503, 1499,
              1505, 1504, 1508, 1506, 1511, 1512, 1515, 1424, 1517, 1457,
              1460, 1519, 1474, 1482, 1483, 1485, 1486, 1488, 1489, 1492,
              1541, 1438, 1441, 1494, 1495, 1518, 1520, 1487, 1555, 1481,
              1522, 1523, 1526, 1528, 1561, 1566, 1580, 1581, 1586, 1587,
              1588, 1478, 1484, 1525, 1575, 1570, 1572, 1573, 1574, 1582,
              1568, 1569, 1578, 1579, 1583, 1590,
};
static const unsigned short int yy_default[] = {
              1554, 1554, 1554, 1392, 1171, 1278, 1171, 1171, 1171, 1392,
              1392, 1392, 1171, 1308, 1308, 1445, 1202, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1391, 1171, 1171,
              1171, 1171, 1475, 1475, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1317, 1171, 1171, 1171, 1171, 1171, 1393,
              1394, 1171, 1171, 1171, 1444, 1446, 1409, 1327, 1326, 1325,
              1324, 1427, 1295, 1322, 1315, 1319, 1387, 1388, 1386, 1390,
              1394, 1393, 1171, 1318, 1358, 1372, 1357, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1366, 1371, 1377, 1370, 1367, 1360,
              1359, 1361, 1362, 1171, 1192, 1242, 1171, 1171, 1171, 1171,
              1463, 1462, 1171, 1171, 1202, 1352, 1351, 1363, 1364, 1374,
              1373, 1452, 1510, 1509, 1410, 1171, 1171, 1171, 1171, 1171,
              1171, 1475, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1475, 1475, 1171, 1202,
              1475, 1475, 1198, 1198, 1302, 1171, 1458, 1278, 1269, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1449, 1447, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1274, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1504, 1171, 1422, 1256, 1274,
              1274, 1274, 1274, 1276, 1257, 1255, 1268, 1203, 1178, 1546,
              1321, 1297, 1297, 1543, 1321, 1321, 1543, 1217, 1524, 1214,
              1308, 1308, 1308, 1297, 1302, 1302, 1389, 1275, 1268, 1171,
              1546, 1283, 1283, 1545, 1545, 1283, 1410, 1330, 1336, 1245,
              1321, 1251, 1251, 1251, 1251, 1283, 1189, 1321, 1321, 1330,
              1336, 1245, 1245, 1321, 1283, 1189, 1426, 1540, 1283, 1189,
              1400, 1283, 1189, 1283, 1189, 1400, 1243, 1243, 1243, 1232,
              1400, 1243, 1217, 1243, 1232, 1243, 1243, 1493, 1400, 1404,
              1404, 1400, 1301, 1296, 1301, 1296, 1301, 1296, 1301, 1296,
              1283, 1485, 1485, 1311, 1311, 1316, 1302, 1395, 1283, 1171,
              1316, 1314, 1312, 1321, 1195, 1235, 1507, 1507, 1503, 1503,
              1503, 1551, 1551, 1458, 1519, 1202, 1202, 1202, 1202, 1519,
              1219, 1219, 1203, 1203, 1202, 1519, 1171, 1171, 1171, 1171,
              1171, 1171, 1514, 1171, 1411, 1287, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1341,
              1171, 1174, 1455, 1171, 1171, 1453, 1171, 1171, 1171, 1171,
              1171, 1171, 1288, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1542, 1171, 1171, 1171, 1171, 1171, 1171, 1425, 1424,
              1171, 1171, 1285, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1313, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1171, 1490, 1303, 1171, 1171, 1533,
              1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171, 1171,
              1171, 1171, 1171, 1171, 1528, 1259, 1343, 1171, 1342, 1346,
              1171, 1183, 1171,
};
# 150612 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const unsigned short int yyFallback[] = {
    0,
    0,
   59,
   59,
   59,
   59,
    0,
   59,
   59,
   59,
    0,
   59,
   59,
   59,
   59,
    0,
    0,
    0,
   59,
    0,
    0,
   59,
    0,
    0,
    0,
   59,
    0,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
    0,
    0,
    0,
   59,
   59,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
   59,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
};
# 150811 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
struct yyStackEntry {
  unsigned short int stateno;
  unsigned short int major;

  YYMINORTYPE minor;

};
typedef struct yyStackEntry yyStackEntry;



struct yyParser {
  yyStackEntry *yytos;






 
  Parse *pParse;





  yyStackEntry yystack[100];
  yyStackEntry *yystackEnd;

};
typedef struct yyParser yyParser;
# 151622 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3ParserInit(void *yypRawParser ,Parse *pParse){
  yyParser *yypParser = (yyParser*)yypRawParser;
  yypParser->pParse=pParse;
# 151640 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  yypParser->yytos = yypParser->yystack;
  yypParser->yystack[0].stateno = 0;
  yypParser->yystack[0].major = 0;

  yypParser->yystackEnd = &yypParser->yystack[100 -1];

}
# 151680 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void yy_destructor(
  yyParser *yypParser,
  unsigned short int yymajor,
  YYMINORTYPE *yypminor
){
 
  Parse *pParse=yypParser->pParse;
  switch( yymajor ){
# 151699 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 198:
    case 231:
    case 232:
    case 244:
{
sqlite3SelectDelete(pParse->db, (yypminor->yy25));
}
      break;
    case 209:
    case 210:
    case 238:
    case 240:
    case 252:
    case 268:
    case 270:
    case 273:
    case 280:
    case 285:
    case 299:
{
sqlite3ExprDelete(pParse->db, (yypminor->yy46));
}
      break;
    case 214:
    case 223:
    case 224:
    case 236:
    case 239:
    case 241:
    case 245:
    case 246:
    case 254:
    case 259:
    case 267:
    case 269:
    case 298:
{
sqlite3ExprListDelete(pParse->db, (yypminor->yy138));
}
      break;
    case 230:
    case 237:
    case 248:
    case 249:
    case 255:
{
sqlite3SrcListDelete(pParse->db, (yypminor->yy609));
}
      break;
    case 233:
{
sqlite3WithDelete(pParse->db, (yypminor->yy297));
}
      break;
    case 243:
    case 294:
{
sqlite3WindowListDelete(pParse->db, (yypminor->yy455));
}
      break;
    case 253:
    case 256:
    case 261:
{
sqlite3IdListDelete(pParse->db, (yypminor->yy406));
}
      break;
    case 263:
    case 295:
    case 296:
    case 297:
    case 300:
{
sqlite3WindowDelete(pParse->db, (yypminor->yy455));
}
      break;
    case 276:
    case 281:
{
sqlite3DeleteTriggerStep(pParse->db, (yypminor->yy527));
}
      break;
    case 278:
{
sqlite3IdListDelete(pParse->db, (yypminor->yy572).b);
}
      break;
    case 302:
    case 303:
    case 304:
{
sqlite3ExprDelete(pParse->db, (yypminor->yy57).pExpr);
}
      break;

    default: break;
  }
}







static void yy_pop_parser_stack(yyParser *pParser){
  yyStackEntry *yytos;
  ((void)0);
  ((void)0);
  yytos = pParser->yytos--;







  yy_destructor(pParser, yytos->major, &yytos->minor);
}




static void sqlite3ParserFinalize(void *p){
  yyParser *pParser = (yyParser*)p;
  while( pParser->yytos>pParser->yystack ) yy_pop_parser_stack(pParser);



}
# 151902 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static unsigned short int yy_find_shift_action(
  unsigned short int iLookAhead,
  unsigned short int stateno
){
  int i;

  if( stateno>542 ) return stateno;
  ((void)0);



  do{
    i = yy_shift_ofst[stateno];
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    ((void)0);
    i += iLookAhead;
    ((void)0);
    if( yy_lookahead[i]!=iLookAhead ){

      unsigned short int iFallback;
      ((void)0);
      iFallback = yyFallback[iLookAhead];
      if( iFallback!=0 ){






        ((void)0);
        iLookAhead = iFallback;
        continue;
      }


      {
        int j = i - iLookAhead + 98;
        ((void)0);
        if( yy_lookahead[j]==98 && iLookAhead>0 ){







          return yy_action[j];
        }
      }

      return yy_default[stateno];
    }else{
      ((void)0);
      return yy_action[i];
    }
  }while(1);
}





static unsigned short int yy_find_reduce_action(
  unsigned short int stateno,
  unsigned short int iLookAhead
){
  int i;





  ((void)0);

  i = yy_reduce_ofst[stateno];
  ((void)0);
  i += iLookAhead;





  ((void)0);
  ((void)0);

  return yy_action[i];
}




static void yyStackOverflow(yyParser *yypParser){
  
   Parse *pParse=yypParser->pParse;





   while( yypParser->yytos>yypParser->yystack ) yy_pop_parser_stack(yypParser);




  sqlite3ErrorMsg(pParse, "parser stack overflow");

  
   yypParser->pParse=pParse;
}
# 152033 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define yyTraceShift(X,Y,Z) 





static void yy_shift(
  yyParser *yypParser,
  unsigned short int yyNewState,
  unsigned short int yyMajor,
  Token yyMinor
){
  yyStackEntry *yytos;
  yypParser->yytos++;







  if( yypParser->yytos>yypParser->yystackEnd ){
    yypParser->yytos--;
    yyStackOverflow(yypParser);
    return;
  }
# 152068 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( yyNewState > 542 ){
    yyNewState += 1174 - 790;
  }
  yytos = yypParser->yytos;
  yytos->stateno = yyNewState;
  yytos->major = yyMajor;
  yytos->minor.yy0 = yyMinor;
  ;
}



static const unsigned short int yyRuleInfoLhs[] = {
   183,
   183,
   182,
   184,
   185,
   185,
   185,
   185,
   184,
   184,
   184,
   184,
   184,
   189,
   191,
   193,
   193,
   192,
   192,
   190,
   190,
   197,
   197,
   199,
   201,
   201,
   201,
   202,
   206,
   207,
   208,
   208,
   208,
   208,
   208,
   208,
   208,
   208,
   208,
   208,
   208,
   208,
   208,
   213,
   213,
   215,
   215,
   217,
   217,
   217,
   217,
   218,
   218,
   218,
   218,
   218,
   216,
   216,
   219,
   219,
   219,
   196,
   221,
   222,
   222,
   222,
   222,
   222,
   225,
   211,
   211,
   226,
   226,
   227,
   227,
   184,
   229,
   229,
   184,
   184,
   184,
   198,
   198,
   198,
   231,
   234,
   234,
   234,
   232,
   232,
   244,
   244,
   235,
   235,
   235,
   246,
   236,
   236,
   236,
   247,
   247,
   237,
   237,
   249,
   249,
   248,
   248,
   248,
   248,
   194,
   194,
   230,
   230,
   255,
   255,
   255,
   255,
   250,
   250,
   250,
   250,
   252,
   252,
   251,
   251,
   251,
   253,
   253,
   241,
   241,
   223,
   223,
   212,
   212,
   212,
   257,
   257,
   257,
   239,
   239,
   240,
   240,
   242,
   242,
   242,
   242,
   184,
   238,
   238,
   184,
   259,
   259,
   259,
   259,
   184,
   184,
   262,
   262,
   262,
   262,
   260,
   260,
   261,
   261,
   256,
   256,
   210,
   210,
   210,
   210,
   210,
   209,
   209,
   209,
   210,
   210,
   210,
   210,
   210,
   210,
   210,
   209,
   210,
   210,
   210,
   210,
   210,
   210,
   210,
   210,
   210,
   264,
   210,
   210,
   210,
   210,
   210,
   210,
   210,
   210,
   210,
   265,
   265,
   210,
   266,
   266,
   210,
   210,
   210,
   210,
   210,
   210,
   269,
   269,
   270,
   270,
   268,
   268,
   254,
   245,
   245,
   267,
   267,
   184,
   271,
   271,
   214,
   214,
   224,
   224,
   272,
   272,
   184,
   184,
   184,
   273,
   273,
   184,
   184,
   184,
   184,
   184,
   204,
   205,
   184,
   275,
   277,
   277,
   277,
   278,
   278,
   278,
   280,
   280,
   276,
   276,
   282,
   283,
   283,
   281,
   281,
   281,
   281,
   210,
   210,
   228,
   228,
   228,
   184,
   184,
   184,
   285,
   285,
   184,
   184,
   184,
   184,
   184,
   184,
   286,
   184,
   184,
   184,
   288,
   290,
   291,
   291,
   292,
   258,
   258,
   233,
   233,
   294,
   294,
   295,
   296,
   296,
   296,
   296,
   296,
   296,
   297,
   297,
   297,
   301,
   303,
   303,
   304,
   304,
   302,
   302,
   305,
   305,
   306,
   306,
   306,
   243,
   263,
   263,
   263,
   300,
   300,
   299,
   179,
   180,
   180,
   181,
   181,
   181,
   186,
   186,
   186,
   188,
   188,
   184,
   195,
   195,
   187,
   187,
   187,
   201,
   202,
   203,
   203,
   200,
   200,
   208,
   196,
   220,
   220,
   221,
   225,
   227,
   231,
   232,
   246,
   247,
   210,
   264,
   254,
   274,
   274,
   274,
   274,
   274,
   204,
   279,
   279,
   282,
   283,
   284,
   284,
   287,
   287,
   289,
   289,
   290,
   293,
   293,
   293,
   258,
};



static const signed char yyRuleInfoNRhs[] = {
   -1,
   -3,
   -1,
   -3,
    0,
   -1,
   -1,
   -1,
   -2,
   -2,
   -2,
   -3,
   -5,
   -6,
   -1,
    0,
   -3,
   -1,
    0,
   -5,
   -2,
    0,
   -2,
   -2,
    0,
   -4,
   -6,
   -2,
    0,
    0,
   -2,
   -3,
   -4,
   -4,
   -4,
   -3,
   -3,
   -5,
   -2,
   -4,
   -4,
   -1,
   -2,
    0,
   -1,
    0,
   -2,
   -2,
   -3,
   -3,
   -3,
   -2,
   -2,
   -1,
   -1,
   -2,
   -3,
   -2,
    0,
   -2,
   -2,
    0,
   -1,
   -2,
   -7,
   -5,
   -5,
  -10,
    0,
    0,
   -3,
    0,
   -2,
   -1,
   -1,
   -4,
   -2,
    0,
   -9,
   -4,
   -1,
   -3,
   -4,
   -1,
   -3,
   -1,
   -2,
   -1,
   -9,
  -10,
   -4,
   -5,
   -1,
   -1,
    0,
    0,
   -5,
   -3,
   -5,
   -2,
    0,
    0,
   -2,
   -2,
    0,
   -7,
   -9,
   -7,
   -7,
    0,
   -2,
   -1,
   -3,
   -1,
   -3,
   -5,
   -3,
   -1,
   -2,
   -3,
   -4,
   -2,
    0,
    0,
   -3,
   -2,
   -4,
    0,
    0,
   -3,
   -5,
   -3,
   -1,
   -1,
    0,
   -2,
   -2,
    0,
    0,
   -3,
    0,
   -2,
    0,
   -2,
   -4,
   -4,
   -6,
    0,
   -2,
   -8,
   -5,
   -7,
   -3,
   -5,
   -7,
   -7,
    0,
  -11,
   -8,
   -4,
   -2,
   -1,
    0,
   -3,
   -3,
   -1,
   -3,
   -1,
   -1,
   -3,
   -5,
   -1,
   -1,
   -1,
   -1,
   -3,
   -6,
   -5,
   -4,
   -6,
   -5,
   -1,
   -5,
   -3,
   -3,
   -3,
   -3,
   -3,
   -3,
   -3,
   -3,
   -2,
   -3,
   -5,
   -2,
   -3,
   -3,
   -4,
   -2,
   -2,
   -2,
   -1,
   -2,
   -5,
   -1,
   -2,
   -5,
   -3,
   -5,
   -5,
   -4,
   -5,
   -5,
   -4,
   -2,
    0,
   -1,
    0,
    0,
   -3,
   -1,
    0,
   -3,
  -12,
   -1,
    0,
    0,
   -3,
   -5,
   -3,
    0,
   -2,
   -4,
   -2,
   -3,
   -2,
    0,
   -3,
   -5,
   -6,
   -5,
   -6,
   -2,
   -2,
   -5,
  -11,
   -1,
   -2,
    0,
   -1,
   -1,
   -3,
    0,
   -2,
   -3,
   -2,
   -3,
   -3,
   -2,
   -8,
   -8,
   -6,
   -3,
   -4,
   -6,
   -1,
   -1,
   -1,
   -4,
   -6,
   -3,
    0,
   -2,
   -1,
   -3,
   -1,
   -3,
   -6,
   -7,
   -1,
   -8,
   -1,
   -4,
   -8,
    0,
   -1,
   -3,
   -1,
   -2,
   -3,
   -6,
   -8,
   -1,
   -3,
   -5,
   -5,
   -6,
   -4,
   -5,
   -1,
   -2,
    0,
   -3,
   -6,
   -1,
   -1,
   -2,
   -1,
   -2,
   -2,
   -2,
    0,
   -2,
   -2,
   -2,
   -1,
   -2,
   -2,
   -1,
   -1,
   -4,
   -2,
   -5,
   -1,
   -2,
   -1,
   -1,
   -2,
   -2,
    0,
   -1,
   -2,
   -1,
    0,
   -2,
   -4,
   -2,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -2,
    0,
   -2,
   -2,
   -3,
   -1,
    0,
   -1,
   -1,
   -1,
   -1,
   -2,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
   -1,
    0,
   -3,
   -1,
    0,
   -1,
    0,
    0,
   -1,
   -1,
   -3,
   -2,
    0,
   -4,
   -2,
    0,
};

static void yy_accept(yyParser*);
# 152862 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static unsigned short int yy_reduce(
  yyParser *yypParser,
  unsigned int yyruleno,
  int yyLookahead,
  Token yyLookaheadToken
  ,Parse *pParse
){
  int yygoto;
  unsigned short int yyact;
  yyStackEntry *yymsp;
  int yysize;
 
  (void)yyLookahead;
  (void)yyLookaheadToken;
  yymsp = yypParser->yytos;
# 152894 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( yyRuleInfoNRhs[yyruleno]==0 ){







    if( yypParser->yytos>=yypParser->yystackEnd ){
      yyStackOverflow(yypParser);



      return 0;
    }
# 152921 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  }

  switch( yyruleno ){
# 152933 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
        YYMINORTYPE yylhsminor;
      case 0:
{ pParse->explain = 1; }
        break;
      case 1:
{ pParse->explain = 2; }
        break;
      case 2:
{ sqlite3FinishCoding(pParse); }
        break;
      case 3:
{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy32);}
        break;
      case 4:
{yymsp[1].minor.yy32 = 7;}
        break;
      case 5:
      case 6: ;
      case 7: ;
      case 304: ;
{yymsp[0].minor.yy32 = yymsp[0].major; }
        break;
      case 8:
      case 9: ;
{sqlite3EndTransaction(pParse,yymsp[-1].major);}
        break;
      case 10:
{
  sqlite3Savepoint(pParse, 0, &yymsp[0].minor.yy0);
}
        break;
      case 11:
{
  sqlite3Savepoint(pParse, 1, &yymsp[0].minor.yy0);
}
        break;
      case 12:
{
  sqlite3Savepoint(pParse, 2, &yymsp[0].minor.yy0);
}
        break;
      case 13:
{
   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy32,0,0,yymsp[-2].minor.yy32);
}
        break;
      case 14:
{disableLookaside(pParse);}
        break;
      case 15:
      case 18: ;
      case 21: ;
      case 43: ;
      case 58: ;
      case 68: ;
      case 77: ;
      case 94: ;
      case 230: ;
{yymsp[1].minor.yy32 = 0;}
        break;
      case 16:
{yymsp[-2].minor.yy32 = 1;}
        break;
      case 17:
      case 44: ;
{yymsp[0].minor.yy32 = 1;}
        break;
      case 19:
{
  sqlite3EndTable(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,yymsp[0].minor.yy32,0);
}
        break;
      case 20:
{
  sqlite3EndTable(pParse,0,0,0,yymsp[0].minor.yy25);
  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy25);
}
        break;
      case 22:
{
  if( yymsp[0].minor.yy0.n==5 && sqlite3_strnicmp(yymsp[0].minor.yy0.z,"rowid",5)==0 ){
    yymsp[-1].minor.yy32 = 0x0020 | 0x0040;
  }else{
    yymsp[-1].minor.yy32 = 0;
    sqlite3ErrorMsg(pParse, "unknown table option: %.*s", yymsp[0].minor.yy0.n, yymsp[0].minor.yy0.z);
  }
}
        break;
      case 23:
{sqlite3AddColumn(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);}
        break;
      case 24:
      case 61: ;
      case 100: ;
{yymsp[1].minor.yy0.n = 0; yymsp[1].minor.yy0.z = 0;}
        break;
      case 25:
{
  yymsp[-3].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);
}
        break;
      case 26:
{
  yymsp[-5].minor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);
}
        break;
      case 27:
{yymsp[-1].minor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}
        break;
      case 28:
{
  ((void)0);
  yymsp[1].minor.yy8 = yyLookaheadToken.z;
}
        break;
      case 29:
{
  ((void)0);
  yymsp[1].minor.yy0 = yyLookaheadToken;
}
        break;
      case 30:
      case 63: ;
{pParse->constraintName = yymsp[0].minor.yy0;}
        break;
      case 31:
{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy46,yymsp[-1].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}
        break;
      case 32:
{sqlite3AddDefaultValue(pParse,yymsp[-1].minor.yy46,yymsp[-2].minor.yy0.z+1,yymsp[0].minor.yy0.z);}
        break;
      case 33:
{sqlite3AddDefaultValue(pParse,yymsp[0].minor.yy46,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);}
        break;
      case 34:
{
  Expr *p = sqlite3PExpr(pParse, 168, yymsp[0].minor.yy46, 0);
  sqlite3AddDefaultValue(pParse,p,yymsp[-2].minor.yy0.z,&yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n]);
}
        break;
      case 35:
{
  Expr *p = tokenExpr(pParse, 113, yymsp[0].minor.yy0);
  if( p ){
    sqlite3ExprIdToTrueFalse(p);
    ;
  }
    sqlite3AddDefaultValue(pParse,p,yymsp[0].minor.yy0.z,yymsp[0].minor.yy0.z+yymsp[0].minor.yy0.n);
}
        break;
      case 36:
{sqlite3AddNotNull(pParse, yymsp[0].minor.yy32);}
        break;
      case 37:
{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy32,yymsp[0].minor.yy32,yymsp[-2].minor.yy32);}
        break;
      case 38:
{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy32,0,0,0,0,
                                   1);}
        break;
      case 39:
{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy46);}
        break;
      case 40:
{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy138,yymsp[0].minor.yy32);}
        break;
      case 41:
{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy32);}
        break;
      case 42:
{sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}
        break;
      case 45:
{ yymsp[1].minor.yy32 = 0*0x0101; }
        break;
      case 46:
{ yymsp[-1].minor.yy32 = (yymsp[-1].minor.yy32 & ~yymsp[0].minor.yy495.mask) | yymsp[0].minor.yy495.value; }
        break;
      case 47:
{ yymsp[-1].minor.yy495.value = 0; yymsp[-1].minor.yy495.mask = 0x000000; }
        break;
      case 48:
{ yymsp[-2].minor.yy495.value = 0; yymsp[-2].minor.yy495.mask = 0x000000; }
        break;
      case 49:
{ yymsp[-2].minor.yy495.value = yymsp[0].minor.yy32; yymsp[-2].minor.yy495.mask = 0x0000ff; }
        break;
      case 50:
{ yymsp[-2].minor.yy495.value = yymsp[0].minor.yy32<<8; yymsp[-2].minor.yy495.mask = 0x00ff00; }
        break;
      case 51:
{ yymsp[-1].minor.yy32 = 8; }
        break;
      case 52:
{ yymsp[-1].minor.yy32 = 9; }
        break;
      case 53:
{ yymsp[0].minor.yy32 = 10; }
        break;
      case 54:
{ yymsp[0].minor.yy32 = 7; }
        break;
      case 55:
{ yymsp[-1].minor.yy32 = 0; }
        break;
      case 56:
{yymsp[-2].minor.yy32 = 0;}
        break;
      case 57:
      case 72: ;
      case 160: ;
{yymsp[-1].minor.yy32 = yymsp[0].minor.yy32;}
        break;
      case 59:
      case 76: ;
      case 202: ;
      case 205: ;
      case 231: ;
{yymsp[-1].minor.yy32 = 1;}
        break;
      case 60:
{yymsp[-1].minor.yy32 = 0;}
        break;
      case 62:
{pParse->constraintName.n = 0;}
        break;
      case 64:
{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy138,yymsp[0].minor.yy32,yymsp[-2].minor.yy32,0);}
        break;
      case 65:
{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy138,yymsp[0].minor.yy32,0,0,0,0,
                                       1);}
        break;
      case 66:
{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy46);}
        break;
      case 67:
{
    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy138, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy138, yymsp[-1].minor.yy32);
    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy32);
}
        break;
      case 69:
      case 71: ;
{yymsp[1].minor.yy32 = 11;}
        break;
      case 70:
{yymsp[-2].minor.yy32 = yymsp[0].minor.yy32;}
        break;
      case 73:
{yymsp[0].minor.yy32 = 4;}
        break;
      case 74:
      case 161: ;
{yymsp[0].minor.yy32 = 5;}
        break;
      case 75:
{
  sqlite3DropTable(pParse, yymsp[0].minor.yy609, 0, yymsp[-1].minor.yy32);
}
        break;
      case 78:
{
  sqlite3CreateView(pParse, &yymsp[-8].minor.yy0, &yymsp[-4].minor.yy0, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy138, yymsp[0].minor.yy25, yymsp[-7].minor.yy32, yymsp[-5].minor.yy32);
}
        break;
      case 79:
{
  sqlite3DropTable(pParse, yymsp[0].minor.yy609, 1, yymsp[-1].minor.yy32);
}
        break;
      case 80:
{
  SelectDest dest = {9, 0, 0, 0, 0, 0};
  sqlite3Select(pParse, yymsp[0].minor.yy25, &dest);
  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy25);
}
        break;
      case 81:
{
  Select *p = yymsp[0].minor.yy25;
  if( p ){
    p->pWith = yymsp[-1].minor.yy297;
    parserDoubleLinkSelect(pParse, p);
  }else{
    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy297);
  }
  yymsp[-2].minor.yy25 = p;
}
        break;
      case 82:
{
  Select *p = yymsp[0].minor.yy25;
  if( p ){
    p->pWith = yymsp[-1].minor.yy297;
    parserDoubleLinkSelect(pParse, p);
  }else{
    sqlite3WithDelete(pParse->db, yymsp[-1].minor.yy297);
  }
  yymsp[-3].minor.yy25 = p;
}
        break;
      case 83:
{
  Select *p = yymsp[0].minor.yy25;
  if( p ){
    parserDoubleLinkSelect(pParse, p);
  }
  yymsp[0].minor.yy25 = p;
}
        break;
      case 84:
{
  Select *pRhs = yymsp[0].minor.yy25;
  Select *pLhs = yymsp[-2].minor.yy25;
  if( pRhs && pRhs->pPrior ){
    SrcList *pFrom;
    Token x;
    x.n = 0;
    parserDoubleLinkSelect(pParse, pRhs);
    pFrom = sqlite3SrcListAppendFromTerm(pParse,0,0,0,&x,pRhs,0,0);
    pRhs = sqlite3SelectNew(pParse,0,pFrom,0,0,0,0,0,0);
  }
  if( pRhs ){
    pRhs->op = (u8)yymsp[-1].minor.yy32;
    pRhs->pPrior = pLhs;
    if( (pLhs) ) pLhs->selFlags &= ~0x00400;
    pRhs->selFlags &= ~0x00400;
    if( yymsp[-1].minor.yy32!=131 ) pParse->hasCompound = 1;
  }else{
    sqlite3SelectDelete(pParse->db, pLhs);
  }
  yymsp[-2].minor.yy25 = pRhs;
}
        break;
      case 85:
      case 87: ;
{yymsp[0].minor.yy32 = yymsp[0].major; }
        break;
      case 86:
{yymsp[-1].minor.yy32 = 131;}
        break;
      case 88:
{
  yymsp[-8].minor.yy25 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy138,yymsp[-5].minor.yy609,yymsp[-4].minor.yy46,yymsp[-3].minor.yy138,yymsp[-2].minor.yy46,yymsp[-1].minor.yy138,yymsp[-7].minor.yy32,yymsp[0].minor.yy46);
}
        break;
      case 89:
{
  yymsp[-9].minor.yy25 = sqlite3SelectNew(pParse,yymsp[-7].minor.yy138,yymsp[-6].minor.yy609,yymsp[-5].minor.yy46,yymsp[-4].minor.yy138,yymsp[-3].minor.yy46,yymsp[-1].minor.yy138,yymsp[-8].minor.yy32,yymsp[0].minor.yy46);
  if( yymsp[-9].minor.yy25 ){
    yymsp[-9].minor.yy25->pWinDefn = yymsp[-2].minor.yy455;
  }else{
    sqlite3WindowListDelete(pParse->db, yymsp[-2].minor.yy455);
  }
}
        break;
      case 90:
{
  yymsp[-3].minor.yy25 = sqlite3SelectNew(pParse,yymsp[-1].minor.yy138,0,0,0,0,0,0x00200,0);
}
        break;
      case 91:
{
  Select *pRight, *pLeft = yymsp[-4].minor.yy25;
  pRight = sqlite3SelectNew(pParse,yymsp[-1].minor.yy138,0,0,0,0,0,0x00200|0x00400,0);
  if( (pLeft) ) pLeft->selFlags &= ~0x00400;
  if( pRight ){
    pRight->op = 131;
    pRight->pPrior = pLeft;
    yymsp[-4].minor.yy25 = pRight;
  }else{
    yymsp[-4].minor.yy25 = pLeft;
  }
}
        break;
      case 92:
{yymsp[0].minor.yy32 = 0x00001;}
        break;
      case 93:
{yymsp[0].minor.yy32 = 0x00002;}
        break;
      case 95:
      case 128: ;
      case 138: ;
      case 218: ;
      case 221: ;
      case 226: ;
{yymsp[1].minor.yy138 = 0;}
        break;
      case 96:
{
   yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy138, yymsp[-2].minor.yy46);
   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy138, &yymsp[0].minor.yy0, 1);
   sqlite3ExprListSetSpan(pParse,yymsp[-4].minor.yy138,yymsp[-3].minor.yy8,yymsp[-1].minor.yy8);
}
        break;
      case 97:
{
  Expr *p = sqlite3Expr(pParse->db, 175, 0);
  yymsp[-2].minor.yy138 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy138, p);
}
        break;
      case 98:
{
  Expr *pRight = sqlite3PExpr(pParse, 175, 0, 0);
  Expr *pLeft = sqlite3ExprAlloc(pParse->db, 59, &yymsp[-2].minor.yy0, 1);
  Expr *pDot = sqlite3PExpr(pParse, 137, pLeft, pRight);
  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138, pDot);
}
        break;
      case 99:
      case 110: ;
      case 242: ;
      case 243: ;
{yymsp[-1].minor.yy0 = yymsp[0].minor.yy0;}
        break;
      case 101:
{yymsp[1].minor.yy609 = sqlite3DbMallocZero(pParse->db, sizeof(*yymsp[1].minor.yy609));}
        break;
      case 102:
{
  yymsp[-1].minor.yy609 = yymsp[0].minor.yy609;
  sqlite3SrcListShiftJoinType(yymsp[-1].minor.yy609);
}
        break;
      case 103:
{
   if( (yymsp[-1].minor.yy609 && yymsp[-1].minor.yy609->nSrc>0) ) yymsp[-1].minor.yy609->a[yymsp[-1].minor.yy609->nSrc-1].fg.jointype = (u8)yymsp[0].minor.yy32;
}
        break;
      case 104:
{yymsp[1].minor.yy609 = 0;}
        break;
      case 105:
{
  yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
  sqlite3SrcListIndexedBy(pParse, yymsp[-6].minor.yy609, &yymsp[-2].minor.yy0);
}
        break;
      case 106:
{
  yymsp[-8].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-8].minor.yy609,&yymsp[-7].minor.yy0,&yymsp[-6].minor.yy0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
  sqlite3SrcListFuncArgs(pParse, yymsp[-8].minor.yy609, yymsp[-4].minor.yy138);
}
        break;
      case 107:
{
    yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy25,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
  }
        break;
      case 108:
{
    if( yymsp[-6].minor.yy609==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy46==0 && yymsp[0].minor.yy406==0 ){
      yymsp[-6].minor.yy609 = yymsp[-4].minor.yy609;
    }else if( yymsp[-4].minor.yy609->nSrc==1 ){
      yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,0,0,&yymsp[-2].minor.yy0,0,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
      if( yymsp[-6].minor.yy609 ){
        struct SrcList_item *pNew = &yymsp[-6].minor.yy609->a[yymsp[-6].minor.yy609->nSrc-1];
        struct SrcList_item *pOld = yymsp[-4].minor.yy609->a;
        pNew->zName = pOld->zName;
        pNew->zDatabase = pOld->zDatabase;
        pNew->pSelect = pOld->pSelect;
        if( pOld->fg.isTabFunc ){
          pNew->u1.pFuncArg = pOld->u1.pFuncArg;
          pOld->u1.pFuncArg = 0;
          pOld->fg.isTabFunc = 0;
          pNew->fg.isTabFunc = 1;
        }
        pOld->zName = pOld->zDatabase = 0;
        pOld->pSelect = 0;
      }
      sqlite3SrcListDelete(pParse->db, yymsp[-4].minor.yy609);
    }else{
      Select *pSubquery;
      sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy609);
      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy609,0,0,0,0,0x00800,0);
      yymsp[-6].minor.yy609 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy609,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy46,yymsp[0].minor.yy406);
    }
  }
        break;
      case 109:
      case 123: ;
{yymsp[1].minor.yy0.z=0; yymsp[1].minor.yy0.n=0;}
        break;
      case 111:
{
  yylhsminor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0);
  if( (pParse->eParseMode>=2) && yylhsminor.yy609 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy609->a[0].zName, &yymsp[0].minor.yy0);
}
  yymsp[0].minor.yy609 = yylhsminor.yy609;
        break;
      case 112:
{
  yylhsminor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);
  if( (pParse->eParseMode>=2) && yylhsminor.yy609 ) sqlite3RenameTokenMap(pParse, yylhsminor.yy609->a[0].zName, &yymsp[0].minor.yy0);
}
  yymsp[-2].minor.yy609 = yylhsminor.yy609;
        break;
      case 113:
{yymsp[0].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[0].minor.yy0,0); }
        break;
      case 114:
{yymsp[-2].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0); }
        break;
      case 115:
{
   yymsp[-4].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,&yymsp[-2].minor.yy0);
   if( yymsp[-4].minor.yy609 ) yymsp[-4].minor.yy609->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
}
        break;
      case 116:
{
   yymsp[-2].minor.yy609 = sqlite3SrcListAppend(pParse,0,&yymsp[-2].minor.yy0,0);
   if( yymsp[-2].minor.yy609 ) yymsp[-2].minor.yy609->a[0].zAlias = sqlite3NameFromToken(pParse->db, &yymsp[0].minor.yy0);
}
        break;
      case 117:
{ yymsp[0].minor.yy32 = 0x0001; }
        break;
      case 118:
{yymsp[-1].minor.yy32 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0); }
        break;
      case 119:
{yymsp[-2].minor.yy32 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); }
        break;
      case 120:
{yymsp[-3].minor.yy32 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0); }
        break;
      case 121:
      case 141: ;
      case 148: ;
      case 214: ;
      case 235: ;
{yymsp[-1].minor.yy46 = yymsp[0].minor.yy46;}
        break;
      case 122:
      case 140: ;
      case 142: ;
      case 147: ;
      case 215: ;
      case 217: ;
      case 236: ;
{yymsp[1].minor.yy46 = 0;}
        break;
      case 124:
{yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;}
        break;
      case 125:
{yymsp[-1].minor.yy0.z=0; yymsp[-1].minor.yy0.n=1;}
        break;
      case 126:
{yymsp[-3].minor.yy406 = yymsp[-1].minor.yy406;}
        break;
      case 127:
      case 162: ;
{yymsp[1].minor.yy406 = 0;}
        break;
      case 129:
      case 139: ;
{yymsp[-2].minor.yy138 = yymsp[0].minor.yy138;}
        break;
      case 130:
{
  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138,yymsp[-2].minor.yy46);
  sqlite3ExprListSetSortOrder(yymsp[-4].minor.yy138,yymsp[-1].minor.yy32,yymsp[0].minor.yy32);
}
        break;
      case 131:
{
  yymsp[-2].minor.yy138 = sqlite3ExprListAppend(pParse,0,yymsp[-2].minor.yy46);
  sqlite3ExprListSetSortOrder(yymsp[-2].minor.yy138,yymsp[-1].minor.yy32,yymsp[0].minor.yy32);
}
        break;
      case 132:
{yymsp[0].minor.yy32 = 0;}
        break;
      case 133:
{yymsp[0].minor.yy32 = 1;}
        break;
      case 134:
      case 137: ;
{yymsp[1].minor.yy32 = -1;}
        break;
      case 135:
{yymsp[-1].minor.yy32 = 0;}
        break;
      case 136:
{yymsp[-1].minor.yy32 = 1;}
        break;
      case 143:
{yymsp[-1].minor.yy46 = sqlite3PExpr(pParse,144,yymsp[0].minor.yy46,0);}
        break;
      case 144:
{yymsp[-3].minor.yy46 = sqlite3PExpr(pParse,144,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);}
        break;
      case 145:
{yymsp[-3].minor.yy46 = sqlite3PExpr(pParse,144,yymsp[0].minor.yy46,yymsp[-2].minor.yy46);}
        break;
      case 146:
{
  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy609, &yymsp[-1].minor.yy0);
  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy609,yymsp[0].minor.yy46,0,0);
}
        break;
      case 149:
{
  sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy609, &yymsp[-3].minor.yy0);
  sqlite3ExprListCheckLength(pParse,yymsp[-1].minor.yy138,"set list");
  sqlite3Update(pParse,yymsp[-4].minor.yy609,yymsp[-1].minor.yy138,yymsp[0].minor.yy46,yymsp[-5].minor.yy32,0,0,0);
}
        break;
      case 150:
{
  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy138, yymsp[0].minor.yy46);
  sqlite3ExprListSetName(pParse, yymsp[-4].minor.yy138, &yymsp[-2].minor.yy0, 1);
}
        break;
      case 151:
{
  yymsp[-6].minor.yy138 = sqlite3ExprListAppendVector(pParse, yymsp[-6].minor.yy138, yymsp[-3].minor.yy406, yymsp[0].minor.yy46);
}
        break;
      case 152:
{
  yylhsminor.yy138 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy46);
  sqlite3ExprListSetName(pParse, yylhsminor.yy138, &yymsp[-2].minor.yy0, 1);
}
  yymsp[-2].minor.yy138 = yylhsminor.yy138;
        break;
      case 153:
{
  yymsp[-4].minor.yy138 = sqlite3ExprListAppendVector(pParse, 0, yymsp[-3].minor.yy406, yymsp[0].minor.yy46);
}
        break;
      case 154:
{
  sqlite3Insert(pParse, yymsp[-3].minor.yy609, yymsp[-1].minor.yy25, yymsp[-2].minor.yy406, yymsp[-5].minor.yy32, yymsp[0].minor.yy288);
}
        break;
      case 155:
{
  sqlite3Insert(pParse, yymsp[-3].minor.yy609, 0, yymsp[-2].minor.yy406, yymsp[-5].minor.yy32, 0);
}
        break;
      case 156:
{ yymsp[1].minor.yy288 = 0; }
        break;
      case 157:
{ yymsp[-10].minor.yy288 = sqlite3UpsertNew(pParse->db,yymsp[-7].minor.yy138,yymsp[-5].minor.yy46,yymsp[-1].minor.yy138,yymsp[0].minor.yy46);}
        break;
      case 158:
{ yymsp[-7].minor.yy288 = sqlite3UpsertNew(pParse->db,yymsp[-4].minor.yy138,yymsp[-2].minor.yy46,0,0); }
        break;
      case 159:
{ yymsp[-3].minor.yy288 = sqlite3UpsertNew(pParse->db,0,0,0,0); }
        break;
      case 163:
{yymsp[-2].minor.yy406 = yymsp[-1].minor.yy406;}
        break;
      case 164:
{yymsp[-2].minor.yy406 = sqlite3IdListAppend(pParse,yymsp[-2].minor.yy406,&yymsp[0].minor.yy0);}
        break;
      case 165:
{yymsp[0].minor.yy406 = sqlite3IdListAppend(pParse,0,&yymsp[0].minor.yy0); }
        break;
      case 166:
{yymsp[-2].minor.yy46 = yymsp[-1].minor.yy46;}
        break;
      case 167:
      case 168: ;
{yymsp[0].minor.yy46=tokenExpr(pParse,59,yymsp[0].minor.yy0); }
        break;
      case 169:
{
  Expr *temp1 = sqlite3ExprAlloc(pParse->db, 59, &yymsp[-2].minor.yy0, 1);
  Expr *temp2 = sqlite3ExprAlloc(pParse->db, 59, &yymsp[0].minor.yy0, 1);
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameTokenMap(pParse, (void*)temp2, &yymsp[0].minor.yy0);
    sqlite3RenameTokenMap(pParse, (void*)temp1, &yymsp[-2].minor.yy0);
  }
  yylhsminor.yy46 = sqlite3PExpr(pParse, 137, temp1, temp2);
}
  yymsp[-2].minor.yy46 = yylhsminor.yy46;
        break;
      case 170:
{
  Expr *temp1 = sqlite3ExprAlloc(pParse->db, 59, &yymsp[-4].minor.yy0, 1);
  Expr *temp2 = sqlite3ExprAlloc(pParse->db, 59, &yymsp[-2].minor.yy0, 1);
  Expr *temp3 = sqlite3ExprAlloc(pParse->db, 59, &yymsp[0].minor.yy0, 1);
  Expr *temp4 = sqlite3PExpr(pParse, 137, temp2, temp3);
  if( (pParse->eParseMode>=2) ){
    sqlite3RenameTokenMap(pParse, (void*)temp3, &yymsp[0].minor.yy0);
    sqlite3RenameTokenMap(pParse, (void*)temp2, &yymsp[-2].minor.yy0);
  }
  yylhsminor.yy46 = sqlite3PExpr(pParse, 137, temp1, temp4);
}
  yymsp[-4].minor.yy46 = yylhsminor.yy46;
        break;
      case 171:
      case 172: ;
{yymsp[0].minor.yy46=tokenExpr(pParse,yymsp[0].major,yymsp[0].minor.yy0); }
        break;
      case 173:
{
  yylhsminor.yy46 = sqlite3ExprAlloc(pParse->db, 150, &yymsp[0].minor.yy0, 1);
}
  yymsp[0].minor.yy46 = yylhsminor.yy46;
        break;
      case 174:
{
  if( !(yymsp[0].minor.yy0.z[0]=='#' && (sqlite3CtypeMap[(unsigned char)(yymsp[0].minor.yy0.z[1])]&0x04)) ){
    u32 n = yymsp[0].minor.yy0.n;
    yymsp[0].minor.yy46 = tokenExpr(pParse, 151, yymsp[0].minor.yy0);
    sqlite3ExprAssignVarNumber(pParse, yymsp[0].minor.yy46, n);
  }else{



    Token t = yymsp[0].minor.yy0;
    ((void)0);
    if( pParse->nested==0 ){
      sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &t);
      yymsp[0].minor.yy46 = 0;
    }else{
      yymsp[0].minor.yy46 = sqlite3PExpr(pParse, 171, 0, 0);
      if( yymsp[0].minor.yy46 ) sqlite3GetInt32(&t.z[1], &yymsp[0].minor.yy46->iTable);
    }
  }
}
        break;
      case 175:
{
  yymsp[-2].minor.yy46 = sqlite3ExprAddCollateToken(pParse, yymsp[-2].minor.yy46, &yymsp[0].minor.yy0, 1);
}
        break;
      case 176:
{
  yymsp[-5].minor.yy46 = sqlite3ExprAlloc(pParse->db, 36, &yymsp[-1].minor.yy0, 1);
  sqlite3ExprAttachSubtrees(pParse->db, yymsp[-5].minor.yy46, yymsp[-3].minor.yy46, 0);
}
        break;
      case 177:
{
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy138, &yymsp[-4].minor.yy0, yymsp[-2].minor.yy32);
}
  yymsp[-4].minor.yy46 = yylhsminor.yy46;
        break;
      case 178:
{
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0, 0);
}
  yymsp[-3].minor.yy46 = yylhsminor.yy46;
        break;
      case 179:
{
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, yymsp[-2].minor.yy138, &yymsp[-5].minor.yy0, yymsp[-3].minor.yy32);
  sqlite3WindowAttach(pParse, yylhsminor.yy46, yymsp[0].minor.yy455);
}
  yymsp[-5].minor.yy46 = yylhsminor.yy46;
        break;
      case 180:
{
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, 0, &yymsp[-4].minor.yy0, 0);
  sqlite3WindowAttach(pParse, yylhsminor.yy46, yymsp[0].minor.yy455);
}
  yymsp[-4].minor.yy46 = yylhsminor.yy46;
        break;
      case 181:
{
  yylhsminor.yy46 = sqlite3ExprFunction(pParse, 0, &yymsp[0].minor.yy0, 0);
}
  yymsp[0].minor.yy46 = yylhsminor.yy46;
        break;
      case 182:
{
  ExprList *pList = sqlite3ExprListAppend(pParse, yymsp[-3].minor.yy138, yymsp[-1].minor.yy46);
  yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 172, 0, 0);
  if( yymsp[-4].minor.yy46 ){
    yymsp[-4].minor.yy46->x.pList = pList;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
}
        break;
      case 183:
{yymsp[-2].minor.yy46=sqlite3ExprAnd(pParse,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);}
        break;
      case 184:
      case 185: ;
      case 186: ;
      case 187: ;
      case 188: ;
      case 189: ;
      case 190: ;
{yymsp[-2].minor.yy46=sqlite3PExpr(pParse,yymsp[-1].major,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);}
        break;
      case 191:
{yymsp[-1].minor.yy0=yymsp[0].minor.yy0; yymsp[-1].minor.yy0.n|=0x80000000; }
        break;
      case 192:
{
  ExprList *pList;
  int bNot = yymsp[-1].minor.yy0.n & 0x80000000;
  yymsp[-1].minor.yy0.n &= 0x7fffffff;
  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy46);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy46);
  yymsp[-2].minor.yy46 = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy0, 0);
  if( bNot ) yymsp[-2].minor.yy46 = sqlite3PExpr(pParse, 19, yymsp[-2].minor.yy46, 0);
  if( yymsp[-2].minor.yy46 ) yymsp[-2].minor.yy46->flags |= 0x000080;
}
        break;
      case 193:
{
  ExprList *pList;
  int bNot = yymsp[-3].minor.yy0.n & 0x80000000;
  yymsp[-3].minor.yy0.n &= 0x7fffffff;
  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy46);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy46);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy46);
  yymsp[-4].minor.yy46 = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy0, 0);
  if( bNot ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy46, 0);
  if( yymsp[-4].minor.yy46 ) yymsp[-4].minor.yy46->flags |= 0x000080;
}
        break;
      case 194:
{yymsp[-1].minor.yy46 = sqlite3PExpr(pParse,yymsp[0].major,yymsp[-1].minor.yy46,0);}
        break;
      case 195:
{yymsp[-2].minor.yy46 = sqlite3PExpr(pParse,51,yymsp[-2].minor.yy46,0);}
        break;
      case 196:
{
  yymsp[-2].minor.yy46 = sqlite3PExpr(pParse,45,yymsp[-2].minor.yy46,yymsp[0].minor.yy46);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy46, yymsp[-2].minor.yy46, 50);
}
        break;
      case 197:
{
  yymsp[-3].minor.yy46 = sqlite3PExpr(pParse,166,yymsp[-3].minor.yy46,yymsp[0].minor.yy46);
  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy46, yymsp[-3].minor.yy46, 51);
}
        break;
      case 198:
      case 199: ;
{yymsp[-1].minor.yy46 = sqlite3PExpr(pParse, yymsp[-1].major, yymsp[0].minor.yy46, 0); }
        break;
      case 200:
{
  yymsp[-1].minor.yy46 = sqlite3PExpr(pParse, yymsp[-1].major==103 ? 169 : 168, yymsp[0].minor.yy46, 0);

}
        break;
      case 201:
      case 204: ;
{yymsp[0].minor.yy32 = 0;}
        break;
      case 203:
{
  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy46);
  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy46);
  yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 48, yymsp[-4].minor.yy46, 0);
  if( yymsp[-4].minor.yy46 ){
    yymsp[-4].minor.yy46->x.pList = pList;
  }else{
    sqlite3ExprListDelete(pParse->db, pList);
  }
  if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy46, 0);
}
        break;
      case 206:
{
    if( yymsp[-1].minor.yy138==0 ){
# 153814 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      sqlite3ExprUnmapAndDelete(pParse, yymsp[-4].minor.yy46);
      yymsp[-4].minor.yy46 = sqlite3Expr(pParse->db, 150, yymsp[-3].minor.yy32 ? "1" : "0");
    }else{
      yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy46, 0);
      if( yymsp[-4].minor.yy46 ){
        yymsp[-4].minor.yy46->x.pList = yymsp[-1].minor.yy138;
        sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy46);
      }else{
        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy138);
      }
      if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy46, 0);
    }
  }
        break;
      case 207:
{
    yymsp[-2].minor.yy46 = sqlite3PExpr(pParse, 134, 0, 0);
    sqlite3PExprAddSelect(pParse, yymsp[-2].minor.yy46, yymsp[-1].minor.yy25);
  }
        break;
      case 208:
{
    yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy46, 0);
    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy46, yymsp[-1].minor.yy25);
    if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy46, 0);
  }
        break;
      case 209:
{
    SrcList *pSrc = sqlite3SrcListAppend(pParse, 0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0);
    Select *pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0);
    if( yymsp[0].minor.yy138 ) sqlite3SrcListFuncArgs(pParse, pSelect ? pSrc : 0, yymsp[0].minor.yy138);
    yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 49, yymsp[-4].minor.yy46, 0);
    sqlite3PExprAddSelect(pParse, yymsp[-4].minor.yy46, pSelect);
    if( yymsp[-3].minor.yy32 ) yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 19, yymsp[-4].minor.yy46, 0);
  }
        break;
      case 210:
{
    Expr *p;
    p = yymsp[-3].minor.yy46 = sqlite3PExpr(pParse, 20, 0, 0);
    sqlite3PExprAddSelect(pParse, p, yymsp[-1].minor.yy25);
  }
        break;
      case 211:
{
  yymsp[-4].minor.yy46 = sqlite3PExpr(pParse, 152, yymsp[-3].minor.yy46, 0);
  if( yymsp[-4].minor.yy46 ){
    yymsp[-4].minor.yy46->x.pList = yymsp[-1].minor.yy46 ? sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy138,yymsp[-1].minor.yy46) : yymsp[-2].minor.yy138;
    sqlite3ExprSetHeightAndFlags(pParse, yymsp[-4].minor.yy46);
  }else{
    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy138);
    sqlite3ExprDelete(pParse->db, yymsp[-1].minor.yy46);
  }
}
        break;
      case 212:
{
  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138, yymsp[-2].minor.yy46);
  yymsp[-4].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy138, yymsp[0].minor.yy46);
}
        break;
      case 213:
{
  yymsp[-3].minor.yy138 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy46);
  yymsp[-3].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy138, yymsp[0].minor.yy46);
}
        break;
      case 216:
{yymsp[0].minor.yy46 = yymsp[0].minor.yy46; }
        break;
      case 219:
{yymsp[-2].minor.yy138 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy138,yymsp[0].minor.yy46);}
        break;
      case 220:
{yymsp[0].minor.yy138 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy46); }
        break;
      case 222:
      case 227: ;
{yymsp[-2].minor.yy138 = yymsp[-1].minor.yy138;}
        break;
      case 223:
{
  sqlite3CreateIndex(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0,
                     sqlite3SrcListAppend(pParse,0,&yymsp[-4].minor.yy0,0), yymsp[-2].minor.yy138, yymsp[-10].minor.yy32,
                      &yymsp[-11].minor.yy0, yymsp[0].minor.yy46, 0, yymsp[-8].minor.yy32, 0);
  if( (pParse->eParseMode>=2) && pParse->pNewIndex ){
    sqlite3RenameTokenMap(pParse, pParse->pNewIndex->zName, &yymsp[-4].minor.yy0);
  }
}
        break;
      case 224:
      case 266: ;
{yymsp[0].minor.yy32 = 2;}
        break;
      case 225:
{yymsp[1].minor.yy32 = 0;}
        break;
      case 228:
{
  yymsp[-4].minor.yy138 = parserAddExprIdListTerm(pParse, yymsp[-4].minor.yy138, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy32, yymsp[0].minor.yy32);
}
        break;
      case 229:
{
  yymsp[-2].minor.yy138 = parserAddExprIdListTerm(pParse, 0, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy32, yymsp[0].minor.yy32);
}
        break;
      case 232:
{sqlite3DropIndex(pParse, yymsp[0].minor.yy609, yymsp[-1].minor.yy32);}
        break;
      case 233:
{sqlite3Vacuum(pParse,0,yymsp[0].minor.yy46);}
        break;
      case 234:
{sqlite3Vacuum(pParse,&yymsp[-1].minor.yy0,yymsp[0].minor.yy46);}
        break;
      case 237:
{sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}
        break;
      case 238:
{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}
        break;
      case 239:
{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}
        break;
      case 240:
{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}
        break;
      case 241:
{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}
        break;
      case 244:
{
  Token all;
  all.z = yymsp[-3].minor.yy0.z;
  all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;
  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy527, &all);
}
        break;
      case 245:
{
  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy32, yymsp[-4].minor.yy572.a, yymsp[-4].minor.yy572.b, yymsp[-2].minor.yy609, yymsp[0].minor.yy46, yymsp[-10].minor.yy32, yymsp[-8].minor.yy32);
  yymsp[-10].minor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0);
}
        break;
      case 246:
{ yymsp[0].minor.yy32 = yymsp[0].major; }
        break;
      case 247:
{ yymsp[-1].minor.yy32 = 65;}
        break;
      case 248:
{ yymsp[1].minor.yy32 = 33; }
        break;
      case 249:
      case 250: ;
{yymsp[0].minor.yy572.a = yymsp[0].major; yymsp[0].minor.yy572.b = 0;}
        break;
      case 251:
{yymsp[-2].minor.yy572.a = 125; yymsp[-2].minor.yy572.b = yymsp[0].minor.yy406;}
        break;
      case 252:
      case 271: ;
{ yymsp[1].minor.yy46 = 0; }
        break;
      case 253:
      case 272: ;
{ yymsp[-1].minor.yy46 = yymsp[0].minor.yy46; }
        break;
      case 254:
{
  ((void)0);
  yymsp[-2].minor.yy527->pLast->pNext = yymsp[-1].minor.yy527;
  yymsp[-2].minor.yy527->pLast = yymsp[-1].minor.yy527;
}
        break;
      case 255:
{
  ((void)0);
  yymsp[-1].minor.yy527->pLast = yymsp[-1].minor.yy527;
}
        break;
      case 256:
{
  yymsp[-2].minor.yy0 = yymsp[0].minor.yy0;
  sqlite3ErrorMsg(pParse,
        "qualified table names are not allowed on INSERT, UPDATE, and DELETE "
        "statements within triggers");
}
        break;
      case 257:
{
  sqlite3ErrorMsg(pParse,
        "the INDEXED BY clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}
        break;
      case 258:
{
  sqlite3ErrorMsg(pParse,
        "the NOT INDEXED clause is not allowed on UPDATE or DELETE statements "
        "within triggers");
}
        break;
      case 259:
{yylhsminor.yy527 = sqlite3TriggerUpdateStep(pParse, &yymsp[-5].minor.yy0, yymsp[-2].minor.yy138, yymsp[-1].minor.yy46, yymsp[-6].minor.yy32, yymsp[-7].minor.yy0.z, yymsp[0].minor.yy8);}
  yymsp[-7].minor.yy527 = yylhsminor.yy527;
        break;
      case 260:
{
   yylhsminor.yy527 = sqlite3TriggerInsertStep(pParse,&yymsp[-4].minor.yy0,yymsp[-3].minor.yy406,yymsp[-2].minor.yy25,yymsp[-6].minor.yy32,yymsp[-1].minor.yy288,yymsp[-7].minor.yy8,yymsp[0].minor.yy8);
}
  yymsp[-7].minor.yy527 = yylhsminor.yy527;
        break;
      case 261:
{yylhsminor.yy527 = sqlite3TriggerDeleteStep(pParse, &yymsp[-3].minor.yy0, yymsp[-1].minor.yy46, yymsp[-5].minor.yy0.z, yymsp[0].minor.yy8);}
  yymsp[-5].minor.yy527 = yylhsminor.yy527;
        break;
      case 262:
{yylhsminor.yy527 = sqlite3TriggerSelectStep(pParse->db, yymsp[-1].minor.yy25, yymsp[-2].minor.yy8, yymsp[0].minor.yy8); }
  yymsp[-2].minor.yy527 = yylhsminor.yy527;
        break;
      case 263:
{
  yymsp[-3].minor.yy46 = sqlite3PExpr(pParse, 71, 0, 0);
  if( yymsp[-3].minor.yy46 ){
    yymsp[-3].minor.yy46->affExpr = 4;
  }
}
        break;
      case 264:
{
  yymsp[-5].minor.yy46 = sqlite3ExprAlloc(pParse->db, 71, &yymsp[-1].minor.yy0, 1);
  if( yymsp[-5].minor.yy46 ) {
    yymsp[-5].minor.yy46->affExpr = (char)yymsp[-3].minor.yy32;
  }
}
        break;
      case 265:
{yymsp[0].minor.yy32 = 1;}
        break;
      case 267:
{yymsp[0].minor.yy32 = 3;}
        break;
      case 268:
{
  sqlite3DropTrigger(pParse,yymsp[0].minor.yy609,yymsp[-1].minor.yy32);
}
        break;
      case 269:
{
  sqlite3Attach(pParse, yymsp[-3].minor.yy46, yymsp[-1].minor.yy46, yymsp[0].minor.yy46);
}
        break;
      case 270:
{
  sqlite3Detach(pParse, yymsp[0].minor.yy46);
}
        break;
      case 273:
{sqlite3Reindex(pParse, 0, 0);}
        break;
      case 274:
{sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
        break;
      case 275:
{sqlite3Analyze(pParse, 0, 0);}
        break;
      case 276:
{sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}
        break;
      case 277:
{
  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy609,&yymsp[0].minor.yy0);
}
        break;
      case 278:
{
  yymsp[-1].minor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-1].minor.yy0.z) + pParse->sLastToken.n;
  sqlite3AlterFinishAddColumn(pParse, &yymsp[-1].minor.yy0);
}
        break;
      case 279:
{
  disableLookaside(pParse);
  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy609);
}
        break;
      case 280:
{
  sqlite3AlterRenameColumn(pParse, yymsp[-5].minor.yy609, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);
}
        break;
      case 281:
{sqlite3VtabFinishParse(pParse,0);}
        break;
      case 282:
{sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}
        break;
      case 283:
{
    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0, yymsp[-4].minor.yy32);
}
        break;
      case 284:
{sqlite3VtabArgInit(pParse);}
        break;
      case 285:
      case 286: ;
      case 287: ;
{sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}
        break;
      case 288:
      case 289: ;
{ sqlite3WithPush(pParse, yymsp[0].minor.yy297, 1); }
        break;
      case 290:
{
  yymsp[-5].minor.yy297 = sqlite3WithAdd(pParse, 0, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy138, yymsp[-1].minor.yy25);
}
        break;
      case 291:
{
  yymsp[-7].minor.yy297 = sqlite3WithAdd(pParse, yymsp[-7].minor.yy297, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy138, yymsp[-1].minor.yy25);
}
        break;
      case 292:
{ yylhsminor.yy455 = yymsp[0].minor.yy455; }
  yymsp[0].minor.yy455 = yylhsminor.yy455;
        break;
      case 293:
{
  ((void)0);
  sqlite3WindowChain(pParse, yymsp[0].minor.yy455, yymsp[-2].minor.yy455);
  yymsp[0].minor.yy455->pNextWin = yymsp[-2].minor.yy455;
  yylhsminor.yy455 = yymsp[0].minor.yy455;
}
  yymsp[-2].minor.yy455 = yylhsminor.yy455;
        break;
      case 294:
{
  if( (yymsp[-1].minor.yy455) ){
    yymsp[-1].minor.yy455->zName = sqlite3DbStrNDup(pParse->db, yymsp[-4].minor.yy0.z, yymsp[-4].minor.yy0.n);
  }
  yylhsminor.yy455 = yymsp[-1].minor.yy455;
}
  yymsp[-4].minor.yy455 = yylhsminor.yy455;
        break;
      case 295:
{
  yymsp[-4].minor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, yymsp[-2].minor.yy138, yymsp[-1].minor.yy138, 0);
}
        break;
      case 296:
{
  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, yymsp[-2].minor.yy138, yymsp[-1].minor.yy138, &yymsp[-5].minor.yy0);
}
  yymsp[-5].minor.yy455 = yylhsminor.yy455;
        break;
      case 297:
{
  yymsp[-3].minor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, 0, yymsp[-1].minor.yy138, 0);
}
        break;
      case 298:
{
  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, 0, yymsp[-1].minor.yy138, &yymsp[-4].minor.yy0);
}
  yymsp[-4].minor.yy455 = yylhsminor.yy455;
        break;
      case 299:
      case 318: ;
{
  yylhsminor.yy455 = yymsp[0].minor.yy455;
}
  yymsp[0].minor.yy455 = yylhsminor.yy455;
        break;
      case 300:
{
  yylhsminor.yy455 = sqlite3WindowAssemble(pParse, yymsp[0].minor.yy455, 0, 0, &yymsp[-1].minor.yy0);
}
  yymsp[-1].minor.yy455 = yylhsminor.yy455;
        break;
      case 301:
{
  yymsp[1].minor.yy455 = sqlite3WindowAlloc(pParse, 0, 90, 0, 85, 0, 0);
}
        break;
      case 302:
{
  yylhsminor.yy455 = sqlite3WindowAlloc(pParse, yymsp[-2].minor.yy32, yymsp[-1].minor.yy57.eType, yymsp[-1].minor.yy57.pExpr, 85, 0, yymsp[0].minor.yy118);
}
  yymsp[-2].minor.yy455 = yylhsminor.yy455;
        break;
      case 303:
{
  yylhsminor.yy455 = sqlite3WindowAlloc(pParse, yymsp[-5].minor.yy32, yymsp[-3].minor.yy57.eType, yymsp[-3].minor.yy57.pExpr, yymsp[-1].minor.yy57.eType, yymsp[-1].minor.yy57.pExpr, yymsp[0].minor.yy118);
}
  yymsp[-5].minor.yy455 = yylhsminor.yy455;
        break;
      case 305:
      case 307: ;
{yylhsminor.yy57 = yymsp[0].minor.yy57;}
  yymsp[0].minor.yy57 = yylhsminor.yy57;
        break;
      case 306:
      case 308: ;
      case 310: ;
{yylhsminor.yy57.eType = yymsp[-1].major; yylhsminor.yy57.pExpr = 0;}
  yymsp[-1].minor.yy57 = yylhsminor.yy57;
        break;
      case 309:
{yylhsminor.yy57.eType = yymsp[0].major; yylhsminor.yy57.pExpr = yymsp[-1].minor.yy46;}
  yymsp[-1].minor.yy57 = yylhsminor.yy57;
        break;
      case 311:
{yymsp[1].minor.yy118 = 0;}
        break;
      case 312:
{yymsp[-1].minor.yy118 = yymsp[0].minor.yy118;}
        break;
      case 313:
      case 314: ;
{yymsp[-1].minor.yy118 = yymsp[-1].major; }
        break;
      case 315:
{yymsp[0].minor.yy118 = yymsp[0].major; }
        break;
      case 316:
{ yymsp[-1].minor.yy455 = yymsp[0].minor.yy455; }
        break;
      case 317:
{
  yymsp[0].minor.yy455->pFilter = yymsp[-1].minor.yy46;
  yylhsminor.yy455 = yymsp[0].minor.yy455;
}
  yymsp[-1].minor.yy455 = yylhsminor.yy455;
        break;
      case 319:
{
  yylhsminor.yy455 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  if( yylhsminor.yy455 ){
    yylhsminor.yy455->eFrmType = 161;
    yylhsminor.yy455->pFilter = yymsp[0].minor.yy46;
  }else{
    sqlite3ExprDelete(pParse->db, yymsp[0].minor.yy46);
  }
}
  yymsp[0].minor.yy455 = yylhsminor.yy455;
        break;
      case 320:
{
  yymsp[-3].minor.yy455 = yymsp[-1].minor.yy455;
  ((void)0);
}
        break;
      case 321:
{
  yymsp[-1].minor.yy455 = (Window*)sqlite3DbMallocZero(pParse->db, sizeof(Window));
  if( yymsp[-1].minor.yy455 ){
    yymsp[-1].minor.yy455->zName = sqlite3DbStrNDup(pParse->db, yymsp[0].minor.yy0.z, yymsp[0].minor.yy0.n);
  }
}
        break;
      case 322:
{ yymsp[-4].minor.yy46 = yymsp[-1].minor.yy46; }
        break;
      default:
                                    ;
                                           ;
                                                   ((void)0);
                                ;
                                     ;
                                        ;
                                ;
                                            ;
                                               ;
                                              ;
                                    ;
                                                         ;
                                                                      ;
                                                     ;
                                    ;
                                ;
                                 ;
                                         ;
                                         ;
                                                      ((void)0);
                                                       ((void)0);
                                              ;
                               ;
                                        ;
                                                  ;
                                                         ;
                                                     ((void)0);
                                 ;
                                                                          ((void)0);
                                                            ((void)0);
                                                             ((void)0);
                                       ;
                                            ;
                                   ;
                                                ((void)0);
                                           ;
                                         ;
                                                     ((void)0);
                                               ((void)0);
                               ;
                                   ;
                                    ;
                                             ;
                                     ;
                                                  ;
                              ;
                              ;
                                               ;
                                      ;
                                   ;
                                            ;
                                          ;
                                                            ;
                                                   ;
                              ;
                                                    ;
                                          ;
                           ;
        break;

  };
  ((void)0);
  yygoto = yyRuleInfoLhs[yyruleno];
  yysize = yyRuleInfoNRhs[yyruleno];
  yyact = yy_find_reduce_action(yymsp[yysize].stateno,(unsigned short int)yygoto);



  ((void)0);


  ((void)0);

  yymsp += yysize+1;
  yypParser->yytos = yymsp;
  yymsp->stateno = (unsigned short int)yyact;
  yymsp->major = (unsigned short int)yygoto;
  ;
  return yyact;
}
# 154391 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void yy_syntax_error(
  yyParser *yypParser,
  int yymajor,
  Token yyminor
){
 
  Parse *pParse=yypParser->pParse;
#define TOKEN yyminor


  (void)(yymajor);
  if( yyminor.z[0] ){
    sqlite3ErrorMsg(pParse, "near \"%T\": syntax error", &yyminor);
  }else{
    sqlite3ErrorMsg(pParse, "incomplete input");
  }

 
  yypParser->pParse=pParse;
}




static void yy_accept(
  yyParser *yypParser
){
 
  Parse *pParse=yypParser->pParse;
# 154428 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);




 
  yypParser->pParse=pParse;
}
# 154456 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3Parser(
  void *yyp,
  int yymajor,
  Token yyminor
 
){
  YYMINORTYPE yyminorunion;
  unsigned short int yyact;






  yyParser *yypParser = (yyParser*)yyp;
  Parse *pParse=yypParser->pParse;
 

  ((void)0);




  yyact = yypParser->yytos->stateno;
# 154492 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  do{
    ((void)0);
    yyact = yy_find_shift_action((unsigned short int)yymajor,yyact);
    if( yyact >= 1174 ){
      yyact = yy_reduce(yypParser,yyact-1174,yymajor,
                        yyminor ,pParse);
    }else if( yyact <= 1170 ){
      yy_shift(yypParser,yyact,(unsigned short int)yymajor,yyminor);



      break;
    }else if( yyact==1172 ){
      yypParser->yytos--;
      yy_accept(yypParser);
      return;
    }else{
      ((void)0);
      yyminorunion.yy0 = yyminor;
# 154583 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      yy_syntax_error(yypParser,yymajor, yyminor);
      yy_destructor(yypParser,(unsigned short int)yymajor,&yyminorunion);
      break;
# 154609 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    }
  }while( yypParser->yytos>yypParser->yystack );
# 154623 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return;
}





static int sqlite3ParserFallback(int iToken){

  ((void)0);
  return yyFallback[iToken];



  return 0;
}
# 154670 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define CC_X 0
#define CC_KYWD 1
#define CC_ID 2
#define CC_DIGIT 3
#define CC_DOLLAR 4
#define CC_VARALPHA 5
#define CC_VARNUM 6
#define CC_SPACE 7
#define CC_QUOTE 8
#define CC_QUOTE2 9
#define CC_PIPE 10
#define CC_MINUS 11
#define CC_LT 12
#define CC_GT 13
#define CC_EQ 14
#define CC_BANG 15
#define CC_SLASH 16
#define CC_LP 17
#define CC_RP 18
#define CC_SEMI 19
#define CC_PLUS 20
#define CC_STAR 21
#define CC_PERCENT 22
#define CC_COMMA 23
#define CC_AND 24
#define CC_TILDA 25
#define CC_DOT 26
#define CC_ILLEGAL 27
#define CC_NUL 28

static const unsigned char aiClass[] = {


           28, 27, 27, 27, 27, 27, 27, 27, 27, 7, 7, 27, 7, 7, 27, 27,
           27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
            7, 15, 8, 5, 4, 22, 24, 8, 17, 18, 21, 20, 23, 11, 26, 16,
            3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 5, 19, 12, 14, 13, 6,
            5, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 9, 27, 27, 27, 1,
            8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
            1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 27, 10, 27, 25, 27,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
            2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2
# 154739 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
};
# 154751 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define charMap(X) sqlite3UpperToLower[(unsigned char)X]
# 154815 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char zKWText[637] = {
  'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',
  'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',
  'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',
  'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',
  'E','R','R','A','B','L','E','L','S','E','X','C','L','U','D','E','L','E',
  'T','E','M','P','O','R','A','R','Y','I','S','N','U','L','L','S','A','V',
  'E','P','O','I','N','T','E','R','S','E','C','T','I','E','S','N','O','T',
  'N','U','L','L','I','K','E','X','C','E','P','T','R','A','N','S','A','C',
  'T','I','O','N','A','T','U','R','A','L','T','E','R','A','I','S','E','X',
  'C','L','U','S','I','V','E','X','I','S','T','S','C','O','N','S','T','R',
  'A','I','N','T','O','F','F','S','E','T','R','I','G','G','E','R','E','F',
  'E','R','E','N','C','E','S','U','N','I','Q','U','E','R','Y','W','I','T',
  'H','O','U','T','E','R','E','L','E','A','S','E','A','T','T','A','C','H',
  'A','V','I','N','G','L','O','B','E','G','I','N','N','E','R','A','N','G',
  'E','B','E','T','W','E','E','N','O','T','H','I','N','G','R','O','U','P',
  'S','C','A','S','C','A','D','E','T','A','C','H','C','A','S','E','C','O',
  'L','L','A','T','E','C','R','E','A','T','E','C','U','R','R','E','N','T',
  '_','D','A','T','E','I','M','M','E','D','I','A','T','E','J','O','I','N',
  'S','E','R','T','M','A','T','C','H','P','L','A','N','A','L','Y','Z','E',
  'P','R','A','G','M','A','B','O','R','T','U','P','D','A','T','E','V','A',
  'L','U','E','S','V','I','R','T','U','A','L','A','S','T','W','H','E','N',
  'W','H','E','R','E','C','U','R','S','I','V','E','A','F','T','E','R','E',
  'N','A','M','E','A','N','D','E','F','A','U','L','T','A','U','T','O','I',
  'N','C','R','E','M','E','N','T','C','A','S','T','C','O','L','U','M','N',
  'C','O','M','M','I','T','C','O','N','F','L','I','C','T','C','R','O','S',
  'S','C','U','R','R','E','N','T','_','T','I','M','E','S','T','A','M','P',
  'A','R','T','I','T','I','O','N','D','E','F','E','R','R','E','D','I','S',
  'T','I','N','C','T','D','R','O','P','R','E','C','E','D','I','N','G','F',
  'A','I','L','I','M','I','T','F','I','L','T','E','R','E','P','L','A','C',
  'E','F','I','R','S','T','F','O','L','L','O','W','I','N','G','F','R','O',
  'M','F','U','L','L','I','F','O','R','D','E','R','E','S','T','R','I','C',
  'T','O','T','H','E','R','S','O','V','E','R','I','G','H','T','R','O','L',
  'L','B','A','C','K','R','O','W','S','U','N','B','O','U','N','D','E','D',
  'U','N','I','O','N','U','S','I','N','G','V','A','C','U','U','M','V','I',
  'E','W','I','N','D','O','W','B','Y','I','N','I','T','I','A','L','L','Y',
  'P','R','I','M','A','R','Y',
};

static const unsigned char aKWHash[127] = {
    82, 113, 130, 80, 110, 29, 0, 0, 89, 0, 83, 70, 0,
    53, 35, 84, 15, 0, 129, 92, 64, 124, 131, 19, 0, 0,
   136, 0, 134, 126, 0, 22, 100, 0, 9, 0, 0, 121, 78,
     0, 76, 6, 0, 58, 97, 143, 0, 132, 108, 0, 0, 48,
     0, 111, 24, 0, 17, 0, 137, 63, 23, 26, 5, 65, 138,
   103, 120, 0, 142, 114, 69, 141, 66, 118, 72, 0, 98, 0,
   107, 41, 0, 106, 0, 0, 0, 102, 99, 104, 109, 123, 14,
    50, 122, 0, 87, 0, 139, 119, 140, 68, 127, 135, 86, 81,
    37, 91, 117, 0, 0, 101, 51, 128, 125, 0, 133, 0, 0,
    44, 0, 93, 67, 39, 0, 20, 45, 115, 88,
};



static const unsigned char aKWNext[143] = {
     0, 0, 0, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0,
     0, 2, 0, 0, 0, 0, 0, 0, 13, 0, 0, 0, 0,
     0, 0, 0, 21, 0, 0, 0, 0, 12, 0, 0, 0, 0,
     0, 0, 0, 7, 0, 36, 0, 0, 28, 0, 0, 0, 31,
     0, 0, 0, 40, 0, 0, 0, 0, 0, 60, 0, 54, 0,
     0, 38, 47, 0, 0, 0, 3, 0, 0, 74, 1, 73, 0,
     0, 0, 52, 0, 0, 0, 0, 0, 0, 57, 59, 56, 30,
     0, 0, 0, 46, 0, 16, 49, 10, 0, 0, 0, 0, 0,
     0, 0, 11, 79, 95, 0, 0, 8, 0, 112, 0, 105, 0,
    43, 62, 0, 77, 0, 116, 0, 61, 0, 0, 94, 42, 55,
     0, 75, 34, 90, 32, 33, 27, 25, 18, 96, 0, 71, 85,
};

static const unsigned char aKWLen[143] = {
     7, 7, 5, 4, 6, 4, 5, 3, 6, 7, 3, 6, 6,
     7, 7, 3, 8, 2, 6, 5, 4, 4, 3, 10, 4, 7,
     6, 9, 4, 2, 6, 5, 9, 9, 4, 7, 3, 2, 4,
     4, 6, 11, 6, 2, 7, 5, 5, 9, 6, 10, 4, 6,
     2, 3, 7, 10, 6, 5, 7, 4, 5, 7, 6, 6, 4,
     5, 5, 5, 7, 7, 6, 5, 7, 3, 6, 4, 7, 6,
    12, 9, 4, 6, 5, 4, 7, 6, 5, 6, 6, 7, 4,
     4, 5, 9, 5, 6, 3, 7, 13, 2, 2, 4, 6, 6,
     8, 5, 17, 12, 7, 9, 8, 8, 2, 4, 9, 4, 5,
     6, 7, 5, 9, 4, 4, 2, 5, 8, 6, 4, 5, 8,
     4, 3, 9, 5, 5, 6, 4, 6, 2, 2, 9, 3, 7,
};


static const unsigned short int aKWOffset[143] = {
     0, 2, 2, 8, 9, 14, 16, 20, 23, 25, 25, 29, 33,
    36, 41, 46, 48, 53, 54, 59, 62, 65, 67, 69, 78, 81,
    86, 90, 90, 94, 99, 101, 105, 111, 119, 123, 123, 123, 126,
   129, 132, 137, 142, 146, 147, 152, 156, 160, 168, 174, 181, 184,
   184, 187, 189, 195, 205, 208, 213, 213, 217, 221, 228, 233, 238,
   241, 244, 248, 253, 259, 265, 265, 271, 272, 276, 282, 286, 293,
   299, 311, 320, 322, 328, 333, 335, 342, 347, 352, 358, 364, 370,
   374, 378, 381, 390, 394, 400, 402, 409, 411, 413, 422, 426, 432,
   438, 446, 451, 451, 451, 467, 476, 483, 484, 491, 494, 503, 506,
   511, 516, 523, 528, 537, 541, 545, 547, 551, 559, 565, 568, 573,
   581, 581, 585, 594, 599, 604, 610, 613, 616, 619, 621, 626, 630,
};

static const unsigned char aKWCode[143] = {
  95, 112, 156, 39, 58,
  41, 120, 67, 33, 128,
  62, 63, 47, 2, 65,
  158, 38, 24, 134, 16,
  114, 154, 11, 127, 155,
  91, 124, 21, 21, 43,
  50, 82, 13, 133, 94,
  51, 19, 66, 117, 47,
  132, 6,28, 111, 114,
  157, 71, 9, 20, 115,
  146, 69, 68, 126, 77,
  121, 119, 3, 25, 81,
  114, 14, 32, 143, 47,
  5, 114, 89, 48, 147,
  92, 142, 35, 31, 40,
  152, 109, 17, 97, 8,
  139, 123, 46, 4, 30,
  70, 27, 125, 135, 80,
  84, 153, 145, 72, 29,
  96, 44, 116, 122, 15,
  49, 36, 60, 10, 37,
  114, 97, 97, 85, 87,
  7, 136, 45, 129, 88,
  42, 144, 161, 73, 83,
  86, 138, 114, 18, 141,
  74, 93, 160, 114, 12,
  76, 75, 90, 130, 140,
  78, 79, 159, 61, 34,
  64, 131, 118,
};



static int keywordCode(const char *z, int n, int *pType){
  int i, j;
  const char *zKW;
  if( n>=2 ){
    i = ((sqlite3UpperToLower[(unsigned char)z[0]]*4) ^ (sqlite3UpperToLower[(unsigned char)z[n-1]]*3) ^ n) % 127;
    for(i=((int)aKWHash[i])-1; i>=0; i=((int)aKWNext[i])-1){
      if( aKWLen[i]!=n ) continue;
      j = 0;
      zKW = &zKWText[aKWOffset[i]];

      while( j<n && (z[j]&~0x20)==zKW[j] ){ j++; }




      if( j<n ) continue;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      ;
      *pType = aKWCode[i];
      break;
    }
  }
  return n;
}
static int sqlite3KeywordCode(const unsigned char *z, int n){
  int id = 59;
  keywordCode((char*)z, n, &id);
  return id;
}
#define SQLITE_N_KEYWORD 143
 int sqlite3_keyword_name(int i,const char **pzName,int *pnName){
  if( i<0 || i>=143 ) return 1;
  *pzName = zKWText + aKWOffset[i];
  *pnName = aKWLen[i];
  return 0;
}
 int sqlite3_keyword_count(void){ return 143; }
 int sqlite3_keyword_check(const char *zName, int nName){
  return 59!=sqlite3KeywordCode((const u8*)zName, nName);
}
# 155149 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define IdChar(C) ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)
# 155171 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3IsIdChar(u8 c){ return ((sqlite3CtypeMap[(unsigned char)c]&0x46)!=0); }






static int getToken(const unsigned char **pz){
  const unsigned char *z = *pz;
  int t;
  do {
    z += sqlite3GetToken(z, &t);
  }while( t==177 );
  if( t==59
   || t==113
   || t==114
   || t==159
   || t==160
   || sqlite3ParserFallback(t)==59
  ){
    t = 59;
  }
  *pz = z;
  return t;
}
# 155227 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int analyzeWindowKeyword(const unsigned char *z){
  int t;
  t = getToken(&z);
  if( t!=59 ) return 59;
  t = getToken(&z);
  if( t!=24 ) return 59;
  return 159;
}
static int analyzeOverKeyword(const unsigned char *z, int lastToken){
  if( lastToken==23 ){
    int t = getToken(&z);
    if( t==22 || t==59 ) return 160;
  }
  return 59;
}
static int analyzeFilterKeyword(const unsigned char *z, int lastToken){
  if( lastToken==23 && getToken(&z)==22 ){
    return 161;
  }
  return 59;
}






static int sqlite3GetToken(const unsigned char *z, int *tokenType){
  int i, c;
  switch( aiClass[*z] ){


    case 7: {
      ;
      ;
      ;
      ;
      ;
      for(i=1; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x01); i++){}
      *tokenType = 177;
      return i;
    }
    case 11: {
      if( z[1]=='-' ){
        for(i=2; (c=z[i])!=0 && c!='\n'; i++){}
        *tokenType = 177;
        return i;
      }
      *tokenType = 104;
      return 1;
    }
    case 17: {
      *tokenType = 22;
      return 1;
    }
    case 18: {
      *tokenType = 23;
      return 1;
    }
    case 19: {
      *tokenType = 1;
      return 1;
    }
    case 20: {
      *tokenType = 103;
      return 1;
    }
    case 21: {
      *tokenType = 105;
      return 1;
    }
    case 16: {
      if( z[1]!='*' || z[2]==0 ){
        *tokenType = 106;
        return 1;
      }
      for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}
      if( c ) i++;
      *tokenType = 177;
      return i;
    }
    case 22: {
      *tokenType = 107;
      return 1;
    }
    case 14: {
      *tokenType = 53;
      return 1 + (z[1]=='=');
    }
    case 12: {
      if( (c=z[1])=='=' ){
        *tokenType = 55;
        return 2;
      }else if( c=='>' ){
        *tokenType = 52;
        return 2;
      }else if( c=='<' ){
        *tokenType = 101;
        return 2;
      }else{
        *tokenType = 56;
        return 1;
      }
    }
    case 13: {
      if( (c=z[1])=='=' ){
        *tokenType = 57;
        return 2;
      }else if( c=='>' ){
        *tokenType = 102;
        return 2;
      }else{
        *tokenType = 54;
        return 1;
      }
    }
    case 15: {
      if( z[1]!='=' ){
        *tokenType = 178;
        return 1;
      }else{
        *tokenType = 52;
        return 2;
      }
    }
    case 10: {
      if( z[1]!='|' ){
        *tokenType = 100;
        return 1;
      }else{
        *tokenType = 108;
        return 2;
      }
    }
    case 23: {
      *tokenType = 26;
      return 1;
    }
    case 24: {
      *tokenType = 99;
      return 1;
    }
    case 25: {
      *tokenType = 110;
      return 1;
    }
    case 8: {
      int delim = z[0];
      ;
      ;
      ;
      for(i=1; (c=z[i])!=0; i++){
        if( c==delim ){
          if( z[i+1]==delim ){
            i++;
          }else{
            break;
          }
        }
      }
      if( c=='\'' ){
        *tokenType = 113;
        return i+1;
      }else if( c!=0 ){
        *tokenType = 59;
        return i+1;
      }else{
        *tokenType = 178;
        return i;
      }
    }
    case 26: {

      if( !(sqlite3CtypeMap[(unsigned char)(z[1])]&0x04) )

      {
        *tokenType = 137;
        return 1;
      }


    }
    case 3: {
      ; ; ;
      ; ; ;
      ; ; ;
      ;
      *tokenType = 150;

      if( z[0]=='0' && (z[1]=='x' || z[1]=='X') && (sqlite3CtypeMap[(unsigned char)(z[2])]&0x08) ){
        for(i=3; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x08); i++){}
        return i;
      }

      for(i=0; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04); i++){}

      if( z[i]=='.' ){
        i++;
        while( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04) ){ i++; }
        *tokenType = 148;
      }
      if( (z[i]=='e' || z[i]=='E') &&
           ( (sqlite3CtypeMap[(unsigned char)(z[i+1])]&0x04)
            || ((z[i+1]=='+' || z[i+1]=='-') && (sqlite3CtypeMap[(unsigned char)(z[i+2])]&0x04))
           )
      ){
        i += 2;
        while( (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04) ){ i++; }
        *tokenType = 148;
      }

      while( ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0) ){
        *tokenType = 178;
        i++;
      }
      return i;
    }
    case 9: {
      for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){}
      *tokenType = c==']' ? 59 : 178;
      return i;
    }
    case 6: {
      *tokenType = 151;
      for(i=1; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x04); i++){}
      return i;
    }
    case 4:
    case 5: {
      int n = 0;
      ; ;
      ; ;
      *tokenType = 151;
      for(i=1; (c=z[i])!=0; i++){
        if( ((sqlite3CtypeMap[(unsigned char)c]&0x46)!=0) ){
          n++;

        }else if( c=='(' && n>0 ){
          do{
            i++;
          }while( (c=z[i])!=0 && !(sqlite3CtypeMap[(unsigned char)(c)]&0x01) && c!=')' );
          if( c==')' ){
            i++;
          }else{
            *tokenType = 178;
          }
          break;
        }else if( c==':' && z[i+1]==':' ){
          i++;

        }else{
          break;
        }
      }
      if( n==0 ) *tokenType = 178;
      return i;
    }
    case 1: {
      for(i=1; aiClass[z[i]]<=1; i++){}
      if( ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0) ){



        i++;
        break;
      }
      *tokenType = 59;
      return keywordCode((char*)z, i, tokenType);
    }
    case 0: {

      ; ;
      if( z[1]=='\'' ){
        *tokenType = 149;
        for(i=2; (sqlite3CtypeMap[(unsigned char)(z[i])]&0x08); i++){}
        if( z[i]!='\'' || i%2 ){
          *tokenType = 178;
          while( z[i] && z[i]!='\'' ){ i++; }
        }
        if( z[i] ) i++;
        return i;
      }



    }
    case 2: {
      i = 1;
      break;
    }
    case 28: {
      *tokenType = 178;
      return 0;
    }
    default: {
      *tokenType = 178;
      return 1;
    }
  }
  while( ((sqlite3CtypeMap[(unsigned char)z[i]]&0x46)!=0) ){ i++; }
  *tokenType = 59;
  return i;
}
# 155538 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){
  int nErr = 0;
  void *pEngine;
  int n = 0;
  int tokenType;
  int lastTokenParsed = -1;
  sqlite3 *db = pParse->db;
  int mxSqlLen;

  yyParser sEngine;

  ;

  ((void)0);
  mxSqlLen = db->aLimit[1];
  if( db->nVdbeActive==0 ){
    db->u1.isInterrupted = 0;
  }
  pParse->rc = 0;
  pParse->zTail = zSql;
  ((void)0);
# 155568 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  pEngine = &sEngine;
  sqlite3ParserInit(pEngine, pParse);







  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  pParse->pParentParse = db->pParse;
  db->pParse = pParse;
  while( 1 ){
    n = sqlite3GetToken((u8*)zSql, &tokenType);
    mxSqlLen -= n;
    if( mxSqlLen<0 ){
      pParse->rc = 18;
      break;
    }

    if( tokenType>=159 ){
      ((void)0)

       ;




      if( db->u1.isInterrupted ){
        pParse->rc = 9;
        break;
      }
      if( tokenType==177 ){
        zSql += n;
        continue;
      }
      if( zSql[0]==0 ){


        if( lastTokenParsed==1 ){
          tokenType = 0;
        }else if( lastTokenParsed==0 ){
          break;
        }else{
          tokenType = 1;
        }
        n = 0;

      }else if( tokenType==159 ){
        ((void)0);
        tokenType = analyzeWindowKeyword((const u8*)&zSql[6]);
      }else if( tokenType==160 ){
        ((void)0);
        tokenType = analyzeOverKeyword((const u8*)&zSql[4], lastTokenParsed);
      }else if( tokenType==161 ){
        ((void)0);
        tokenType = analyzeFilterKeyword((const u8*)&zSql[6], lastTokenParsed);

      }else{
        sqlite3ErrorMsg(pParse, "unrecognized token: \"%.*s\"", n, zSql);
        break;
      }
    }
    pParse->sLastToken.z = zSql;
    pParse->sLastToken.n = n;
    sqlite3Parser(pEngine, tokenType, pParse->sLastToken);
    lastTokenParsed = tokenType;
    zSql += n;
    ((void)0);
    if( pParse->rc!=0 ) break;
  }
  ((void)0);
# 155651 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3ParserFinalize(pEngine);



  if( db->mallocFailed ){
    pParse->rc = 7;
  }
  if( pParse->rc!=0 && pParse->rc!=101 && pParse->zErrMsg==0 ){
    pParse->zErrMsg = sqlite3MPrintf(db, "%s", sqlite3ErrStr(pParse->rc));
  }
  ((void)0);
  if( pParse->zErrMsg ){
    *pzErrMsg = pParse->zErrMsg;
    sqlite3_log(pParse->rc, "%s in \"%s\"",
                *pzErrMsg, pParse->zTail);
    pParse->zErrMsg = 0;
    nErr++;
  }
  pParse->zTail = zSql;
  if( pParse->pVdbe && pParse->nErr>0 && pParse->nested==0 ){
    sqlite3VdbeDelete(pParse->pVdbe);
    pParse->pVdbe = 0;
  }

  if( pParse->nested==0 ){
    sqlite3DbFree(db, pParse->aTableLock);
    pParse->aTableLock = 0;
    pParse->nTableLock = 0;
  }


  sqlite3_free(pParse->apVtabLock);


  if( !(pParse->eParseMode!=0) ){




    sqlite3DeleteTable(db, pParse->pNewTable);
  }
  if( !(pParse->eParseMode>=2) ){
    sqlite3DeleteTrigger(db, pParse->pNewTrigger);
  }

  if( pParse->pWithToFree ) sqlite3WithDelete(db, pParse->pWithToFree);
  sqlite3DbFree(db, pParse->pVList);
  while( pParse->pAinc ){
    AutoincInfo *p = pParse->pAinc;
    pParse->pAinc = p->pNext;
    sqlite3DbFreeNN(db, p);
  }
  while( pParse->pZombieTab ){
    Table *p = pParse->pZombieTab;
    pParse->pZombieTab = p->pNextZombie;
    sqlite3DeleteTable(db, p);
  }
  db->pParse = pParse->pParentParse;
  pParse->pParentParse = 0;
  ((void)0);
  return nErr;
}
# 155890 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define tkSEMI 0
#define tkWS 1
#define tkOTHER 2

#define tkEXPLAIN 3
#define tkCREATE 4
#define tkTEMP 5
#define tkTRIGGER 6
#define tkEND 7
# 155954 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_complete(const char *zSql){
  u8 state = 0;
  u8 token;





  static const u8 trans[8][8] = {


                      { 1, 0, 2, 3, 4, 2, 2, 2, },
                      { 1, 1, 2, 3, 4, 2, 2, 2, },
                      { 1, 2, 2, 2, 2, 2, 2, 2, },
                      { 1, 3, 3, 2, 4, 2, 2, 2, },
                      { 1, 4, 2, 2, 2, 4, 5, 2, },
                      { 6, 5, 5, 5, 5, 5, 5, 5, },
                      { 6, 6, 5, 5, 5, 5, 5, 7, },
                      { 1, 7, 5, 5, 5, 5, 5, 5, },
  };
# 155994 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  while( *zSql ){
    switch( *zSql ){
      case ';': {
        token = 0;
        break;
      }
      case ' ':
      case '\r':
      case '\t':
      case '\n':
      case '\f': {
        token = 1;
        break;
      }
      case '/': {
        if( zSql[1]!='*' ){
          token = 2;
          break;
        }
        zSql += 2;
        while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; }
        if( zSql[0]==0 ) return 0;
        zSql++;
        token = 1;
        break;
      }
      case '-': {
        if( zSql[1]!='-' ){
          token = 2;
          break;
        }
        while( *zSql && *zSql!='\n' ){ zSql++; }
        if( *zSql==0 ) return state==1;
        token = 1;
        break;
      }
      case '[': {
        zSql++;
        while( *zSql && *zSql!=']' ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = 2;
        break;
      }
      case '`':
      case '"':
      case '\'': {
        int c = *zSql;
        zSql++;
        while( *zSql && *zSql!=c ){ zSql++; }
        if( *zSql==0 ) return 0;
        token = 2;
        break;
      }
      default: {



        if( ((sqlite3CtypeMap[(unsigned char)(u8)*zSql]&0x46)!=0) ){

          int nId;
          for(nId=1; ((sqlite3CtypeMap[(unsigned char)zSql[nId]]&0x46)!=0); nId++){}



          switch( *zSql ){
            case 'c': case 'C': {
              if( nId==6 && sqlite3_strnicmp(zSql, "create", 6)==0 ){
                token = 4;
              }else{
                token = 2;
              }
              break;
            }
            case 't': case 'T': {
              if( nId==7 && sqlite3_strnicmp(zSql, "trigger", 7)==0 ){
                token = 6;
              }else if( nId==4 && sqlite3_strnicmp(zSql, "temp", 4)==0 ){
                token = 5;
              }else if( nId==9 && sqlite3_strnicmp(zSql, "temporary", 9)==0 ){
                token = 5;
              }else{
                token = 2;
              }
              break;
            }
            case 'e': case 'E': {
              if( nId==3 && sqlite3_strnicmp(zSql, "end", 3)==0 ){
                token = 7;
              }else

              if( nId==7 && sqlite3_strnicmp(zSql, "explain", 7)==0 ){
                token = 3;
              }else

              {
                token = 2;
              }
              break;
            }
            default: {
              token = 2;
              break;
            }
          }

          zSql += nId-1;
        }else{

          token = 2;
        }
        break;
      }
    }
    state = trans[state][token];
    zSql++;
  }
  return state==1;
}







 int sqlite3_complete16(const void *zSql){
  sqlite3_value *pVal;
  char const *zSql8;
  int rc;


  rc = sqlite3_initialize();
  if( rc ) return rc;

  pVal = sqlite3ValueNew(0);
  sqlite3ValueSetStr(pVal, -1, zSql, 2, ((sqlite3_destructor_type)0));
  zSql8 = sqlite3ValueText(pVal, 1);
  if( zSql8 ){
    rc = sqlite3_complete(zSql8);
  }else{
    rc = 7;
  }
  sqlite3ValueFree(pVal);
  return rc & 0xff;
}
# 156286 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_libversion(void){ return sqlite3_version; }
# 156299 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_libversion_number(void){ return 3030001; }





 int sqlite3_threadsafe(void){ return 1; }
# 156336 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_temp_directory = 0;
# 156345 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 char *sqlite3_data_directory = 0;
# 156378 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_initialize(void){
  sqlite3_mutex *pMaster;
  int rc;
# 156395 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);






  if( sqlite3Config.isInit ) return 0;
# 156412 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  rc = sqlite3MutexInit();
  if( rc ) return rc;







  pMaster = sqlite3MutexAlloc(2);
  sqlite3_mutex_enter(pMaster);
  sqlite3Config.isMutexInit = 1;
  if( !sqlite3Config.isMallocInit ){
    rc = sqlite3MallocInit();
  }
  if( rc==0 ){
    sqlite3Config.isMallocInit = 1;
    if( !sqlite3Config.pInitMutex ){
      sqlite3Config.pInitMutex =
           sqlite3MutexAlloc(1);
      if( sqlite3Config.bCoreMutex && !sqlite3Config.pInitMutex ){
        rc = 7;
      }
    }
  }
  if( rc==0 ){
    sqlite3Config.nRefInitMutex++;
  }
  sqlite3_mutex_leave(pMaster);




  if( rc!=0 ){
    return rc;
  }
# 156462 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_mutex_enter(sqlite3Config.pInitMutex);
  if( sqlite3Config.isInit==0 && sqlite3Config.inProgress==0 ){
    sqlite3Config.inProgress = 1;






    memset(&sqlite3BuiltinFunctions, 0, sizeof(sqlite3BuiltinFunctions));
    sqlite3RegisterBuiltinFunctions();
    if( sqlite3Config.isPCacheInit==0 ){
      rc = sqlite3PcacheInitialize();
    }
    if( rc==0 ){
      sqlite3Config.isPCacheInit = 1;
      rc = sqlite3OsInit();
    }





    if( rc==0 ){
      sqlite3PCacheBufferSetup( sqlite3Config.pPage,
          sqlite3Config.szPage, sqlite3Config.nPage);
      sqlite3Config.isInit = 1;



    }
    sqlite3Config.inProgress = 0;
  }
  sqlite3_mutex_leave(sqlite3Config.pInitMutex);




  sqlite3_mutex_enter(pMaster);
  sqlite3Config.nRefInitMutex--;
  if( sqlite3Config.nRefInitMutex<=0 ){
    ((void)0);
    sqlite3_mutex_free(sqlite3Config.pInitMutex);
    sqlite3Config.pInitMutex = 0;
  }
  sqlite3_mutex_leave(pMaster);
# 156538 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  return rc;
}
# 156549 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_shutdown(void){







  if( sqlite3Config.isInit ){




    sqlite3_os_end();
    sqlite3_reset_auto_extension();
    sqlite3Config.isInit = 0;
  }
  if( sqlite3Config.isPCacheInit ){
    sqlite3PcacheShutdown();
    sqlite3Config.isPCacheInit = 0;
  }
  if( sqlite3Config.isMallocInit ){
    sqlite3MallocEnd();
    sqlite3Config.isMallocInit = 0;
# 156582 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    sqlite3_data_directory = 0;
    sqlite3_temp_directory = 0;

  }
  if( sqlite3Config.isMutexInit ){
    sqlite3MutexEnd();
    sqlite3Config.isMutexInit = 0;
  }

  return 0;
}
# 156603 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_config(int op, ...){
  va_list ap;
  int rc = 0;



  if( sqlite3Config.isInit ) return sqlite3MisuseError(156609);

  ( ap = (va_list)( &(op) ) + ( (sizeof(op) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  switch( op ){





    case 1: {


      sqlite3Config.bCoreMutex = 0;
      sqlite3Config.bFullMutex = 0;
      break;
    }


    case 2: {


      sqlite3Config.bCoreMutex = 1;
      sqlite3Config.bFullMutex = 0;
      break;
    }


    case 3: {


      sqlite3Config.bCoreMutex = 1;
      sqlite3Config.bFullMutex = 1;
      break;
    }


    case 10: {

      sqlite3Config.mutex = *( *(sqlite3_mutex_methods* *)((ap += ( (sizeof(sqlite3_mutex_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_mutex_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }


    case 11: {

      *( *(sqlite3_mutex_methods* *)((ap += ( (sizeof(sqlite3_mutex_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_mutex_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ) = sqlite3Config.mutex;
      break;
    }


    case 4: {





      sqlite3Config.m = *( *(sqlite3_mem_methods* *)((ap += ( (sizeof(sqlite3_mem_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_mem_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
    case 5: {




      if( sqlite3Config.m.xMalloc==0 ) sqlite3MemSetDefault();
      *( *(sqlite3_mem_methods* *)((ap += ( (sizeof(sqlite3_mem_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_mem_methods*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ) = sqlite3Config.m;
      break;
    }
    case 9: {



      sqlite3Config.bMemstat = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
    case 27: {
      sqlite3Config.bSmallMalloc = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
    case 7: {




      sqlite3Config.pPage = ( *(void* *)((ap += ( (sizeof(void*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(void*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3Config.szPage = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3Config.nPage = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
    case 24: {




      *( *(int* *)((ap += ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ) =
          sqlite3HeaderSizeBtree() +
          sqlite3HeaderSizePcache() +
          sqlite3HeaderSizePcache1();
      break;
    }

    case 14: {

      break;
    }
    case 15: {

      rc = 1;
      break;
    }

    case 18: {




      sqlite3Config.pcache2 = *( *(sqlite3_pcache_methods2* *)((ap += ( (sizeof(sqlite3_pcache_methods2*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_pcache_methods2*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
    case 19: {




      if( sqlite3Config.pcache2.xInit==0 ){
        sqlite3PCacheSetDefault();
      }
      *( *(sqlite3_pcache_methods2* *)((ap += ( (sizeof(sqlite3_pcache_methods2*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_pcache_methods2*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ) = sqlite3Config.pcache2;
      break;
    }
# 156785 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 13: {
      sqlite3Config.szLookaside = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3Config.nLookaside = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }





    case 16: {




      typedef void(*LOGFUNC_t)(void*,int,const char*);
      sqlite3Config.xLog = ( *(LOGFUNC_t *)((ap += ( (sizeof(LOGFUNC_t) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(LOGFUNC_t) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3Config.pLogArg = ( *(void* *)((ap += ( (sizeof(void*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(void*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }






    case 17: {




      sqlite3Config.bOpenUri = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }

    case 20: {




      sqlite3Config.bUseCis = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
# 156838 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 22: {




      sqlite3_int64 szMmap = ( *(sqlite3_int64 *)((ap += ( (sizeof(sqlite3_int64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_int64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3_int64 mxMmap = ( *(sqlite3_int64 *)((ap += ( (sizeof(sqlite3_int64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_int64) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
# 156853 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      if( mxMmap<0 || mxMmap>0x7fff0000 ){
        mxMmap = 0x7fff0000;
      }
      if( szMmap<0 ) szMmap = 0;
      if( szMmap>mxMmap) szMmap = mxMmap;
      sqlite3Config.mxMmap = mxMmap;
      sqlite3Config.szMmap = szMmap;
      break;
    }
# 156873 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 25: {
      sqlite3Config.szPma = ( *(unsigned int *)((ap += ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }

    case 26: {
      sqlite3Config.nStmtSpill = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
# 156901 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    default: {
      rc = 1;
      break;
    }
  }
  ( ap = (va_list)0 );
  return rc;
}
# 156921 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){

  void *pStart;

  if( sqlite3LookasideUsed(db,0)>0 ){
    return 5;
  }




  if( db->lookaside.bMalloced ){
    sqlite3_free(db->lookaside.pStart);
  }



  sz = ((sz)&~7);
  if( sz<=(int)sizeof(LookasideSlot*) ) sz = 0;
  if( cnt<0 ) cnt = 0;
  if( sz==0 || cnt==0 ){
    sz = 0;
    pStart = 0;
  }else if( pBuf==0 ){
    sqlite3BeginBenignMalloc();
    pStart = sqlite3Malloc( sz*(sqlite3_int64)cnt );
    sqlite3EndBenignMalloc();
    if( pStart ) cnt = sqlite3MallocSize(pStart)/sz;
  }else{
    pStart = pBuf;
  }
  db->lookaside.pStart = pStart;
  db->lookaside.pInit = 0;
  db->lookaside.pFree = 0;
  db->lookaside.sz = (u16)sz;
  if( pStart ){
    int i;
    LookasideSlot *p;
    ((void)0);
    db->lookaside.nSlot = cnt;
    p = (LookasideSlot*)pStart;
    for(i=cnt-1; i>=0; i--){
      p->pNext = db->lookaside.pInit;
      db->lookaside.pInit = p;
      p = (LookasideSlot*)&((u8*)p)[sz];
    }
    db->lookaside.pEnd = p;
    db->lookaside.bDisable = 0;
    db->lookaside.bMalloced = pBuf==0 ?1:0;
  }else{
    db->lookaside.pStart = db;
    db->lookaside.pEnd = db;
    db->lookaside.bDisable = 1;
    db->lookaside.bMalloced = 0;
    db->lookaside.nSlot = 0;
  }

  return 0;
}




 sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){






  return db->mutex;
}





 int sqlite3_db_release_memory(sqlite3 *db){
  int i;




  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  for(i=0; i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( pBt ){
      Pager *pPager = sqlite3BtreePager(pBt);
      sqlite3PagerShrink(pPager);
    }
  }
  sqlite3BtreeLeaveAll(db);
  sqlite3_mutex_leave(db->mutex);
  return 0;
}





 int sqlite3_db_cacheflush(sqlite3 *db){
  int i;
  int rc = 0;
  int bSeenBusy = 0;




  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  for(i=0; rc==0 && i<db->nDb; i++){
    Btree *pBt = db->aDb[i].pBt;
    if( pBt && sqlite3BtreeIsInTrans(pBt) ){
      Pager *pPager = sqlite3BtreePager(pBt);
      rc = sqlite3PagerFlush(pPager);
      if( rc==5 ){
        bSeenBusy = 1;
        rc = 0;
      }
    }
  }
  sqlite3BtreeLeaveAll(db);
  sqlite3_mutex_leave(db->mutex);
  return ((rc==0 && bSeenBusy) ? 5 : rc);
}




 int sqlite3_db_config(sqlite3 *db, int op, ...){
  va_list ap;
  int rc;
  ( ap = (va_list)( &(op) ) + ( (sizeof(op) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  switch( op ){
    case 1000: {


      db->aDb[0].zDbSName = ( *(char* *)((ap += ( (sizeof(char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      rc = 0;
      break;
    }
    case 1001: {
      void *pBuf = ( *(void* *)((ap += ( (sizeof(void*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(void*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      int sz = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      int cnt = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      rc = setupLookaside(db, pBuf, sz, cnt);
      break;
    }
    default: {
      static const struct {
        int op;
        u32 mask;
      } aFlagOp[] = {
        { 1002, 0x00004000 },
        { 1003, 0x00040000 },
        { 1015, 0x80000000 },
        { 1004, 0x00400000 },
        { 1005, 0x00010000 },
        { 1006, 0x00000800 },
        { 1007, 0x00800000 },
        { 1008, 0x01000000 },
        { 1009, 0x02000000 },
        { 1010, 0x10000000 },
        { 1011, 0x00000001|
                                                 0x08000000 },
        { 1012, 0x04000000 },
        { 1014, 0x20000000 },
        { 1013, 0x40000000 },
      };
      unsigned int i;
      rc = 1;
      for(i=0; i<((int)(sizeof(aFlagOp)/sizeof(aFlagOp[0]))); i++){
        if( aFlagOp[i].op==op ){
          int onoff = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
          int *pRes = ( *(int* *)((ap += ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
          u64 oldFlags = db->flags;
          if( onoff>0 ){
            db->flags |= aFlagOp[i].mask;
          }else if( onoff==0 ){
            db->flags &= ~(u64)aFlagOp[i].mask;
          }
          if( oldFlags!=db->flags ){
            sqlite3ExpirePreparedStatements(db, 0);
          }
          if( pRes ){
            *pRes = (db->flags & aFlagOp[i].mask)!=0;
          }
          rc = 0;
          break;
        }
      }
      break;
    }
  }
  ( ap = (va_list)0 );
  return rc;
}





static int binCollFunc(
  void *NotUsed,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int rc, n;
  (void)(NotUsed);
  n = nKey1<nKey2 ? nKey1 : nKey2;



  ((void)0);
  rc = memcmp(pKey1, pKey2, n);
  if( rc==0 ){
    rc = nKey1 - nKey2;
  }
  return rc;
}





static int rtrimCollFunc(
  void *pUser,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  const u8 *pK1 = (const u8*)pKey1;
  const u8 *pK2 = (const u8*)pKey2;
  while( nKey1 && pK1[nKey1-1]==' ' ) nKey1--;
  while( nKey2 && pK2[nKey2-1]==' ' ) nKey2--;
  return binCollFunc(pUser, nKey1, pKey1, nKey2, pKey2);
}




static int sqlite3IsBinary(const CollSeq *p){
  ((void)0);
  return p==0 || p->xCmp==binCollFunc;
}
# 157176 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int nocaseCollatingFunc(
  void *NotUsed,
  int nKey1, const void *pKey1,
  int nKey2, const void *pKey2
){
  int r = sqlite3_strnicmp(
      (const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);
  (void)(NotUsed);
  if( 0==r ){
    r = nKey1-nKey2;
  }
  return r;
}




 sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){






  return db->lastRowid;
}




 void sqlite3_set_last_insert_rowid(sqlite3 *db, sqlite3_int64 iRowid){






  sqlite3_mutex_enter(db->mutex);
  db->lastRowid = iRowid;
  sqlite3_mutex_leave(db->mutex);
}




 int sqlite3_changes(sqlite3 *db){






  return db->nChange;
}




 int sqlite3_total_changes(sqlite3 *db){






  return db->nTotalChange;
}






static void sqlite3CloseSavepoints(sqlite3 *db){
  while( db->pSavepoint ){
    Savepoint *pTmp = db->pSavepoint;
    db->pSavepoint = pTmp->pNext;
    sqlite3DbFree(db, pTmp);
  }
  db->nSavepoint = 0;
  db->nStatement = 0;
  db->isTransactionSavepoint = 0;
}







static void functionDestroy(sqlite3 *db, FuncDef *p){
  FuncDestructor *pDestructor = p->u.pDestructor;
  if( pDestructor ){
    pDestructor->nRef--;
    if( pDestructor->nRef==0 ){
      pDestructor->xDestroy(pDestructor->pUserData);
      sqlite3DbFree(db, pDestructor);
    }
  }
}





static void disconnectAllVtab(sqlite3 *db){

  int i;
  HashElem *p;
  sqlite3BtreeEnterAll(db);
  for(i=0; i<db->nDb; i++){
    Schema *pSchema = db->aDb[i].pSchema;
    if( pSchema ){
      for(p=((&pSchema->tblHash)->first); p; p=((p)->next)){
        Table *pTab = (Table *)((p)->data);
        if( ((pTab)->nModuleArg) ) sqlite3VtabDisconnect(db, pTab);
      }
    }
  }
  for(p=((&db->aModule)->first); p; p=((p)->next)){
    Module *pMod = (Module *)((p)->data);
    if( pMod->pEpoTab ){
      sqlite3VtabDisconnect(db, pMod->pEpoTab);
    }
  }
  sqlite3VtabUnlockList(db);
  sqlite3BtreeLeaveAll(db);



}





static int connectionIsBusy(sqlite3 *db){
  int j;
  ((void)0);
  if( db->pVdbe ) return 1;
  for(j=0; j<db->nDb; j++){
    Btree *pBt = db->aDb[j].pBt;
    if( pBt && sqlite3BtreeIsInBackup(pBt) ) return 1;
  }
  return 0;
}




static int sqlite3Close(sqlite3 *db, int forceZombie){
  if( !db ){


    return 0;
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(157333);
  }
  sqlite3_mutex_enter(db->mutex);
  if( db->mTrace & 0x08 ){
    db->xTrace(0x08, db->pTraceArg, db, 0);
  }


  disconnectAllVtab(db);
# 157350 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3VtabRollback(db);




  if( !forceZombie && connectionIsBusy(db) ){
    sqlite3ErrorWithMsg(db, 5, "unable to close due to unfinalized "
       "statements or unfinished backups");
    sqlite3_mutex_leave(db->mutex);
    return 5;
  }
# 157371 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  db->magic = 0x64cffc7f;
  sqlite3LeaveMutexAndCloseZombie(db);
  return 0;
}
# 157385 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_close(sqlite3 *db){ return sqlite3Close(db,0); }
 int sqlite3_close_v2(sqlite3 *db){ return sqlite3Close(db,1); }
# 157397 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3LeaveMutexAndCloseZombie(sqlite3 *db){
  HashElem *i;
  int j;





  if( db->magic!=0x64cffc7f || connectionIsBusy(db) ){
    sqlite3_mutex_leave(db->mutex);
    return;
  }
# 157420 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3RollbackAll(db, 0);


  sqlite3CloseSavepoints(db);


  for(j=0; j<db->nDb; j++){
    struct Db *pDb = &db->aDb[j];
    if( pDb->pBt ){
      sqlite3BtreeClose(pDb->pBt);
      pDb->pBt = 0;
      if( j!=1 ){
        pDb->pSchema = 0;
      }
    }
  }

  if( db->aDb[1].pSchema ){
    sqlite3SchemaClear(db->aDb[1].pSchema);
  }
  sqlite3VtabUnlockList(db);


  sqlite3CollapseDatabaseArray(db);
  ((void)0);
  ((void)0);




  ;

  for(i=((&db->aFunc)->first); i; i=((i)->next)){
    FuncDef *pNext, *p;
    p = ((i)->data);
    do{
      functionDestroy(db, p);
      pNext = p->pNext;
      sqlite3DbFree(db, p);
      p = pNext;
    }while( p );
  }
  sqlite3HashClear(&db->aFunc);
  for(i=((&db->aCollSeq)->first); i; i=((i)->next)){
    CollSeq *pColl = (CollSeq *)((i)->data);

    for(j=0; j<3; j++){
      if( pColl[j].xDel ){
        pColl[j].xDel(pColl[j].pUser);
      }
    }
    sqlite3DbFree(db, pColl);
  }
  sqlite3HashClear(&db->aCollSeq);

  for(i=((&db->aModule)->first); i; i=((i)->next)){
    Module *pMod = (Module *)((i)->data);
    sqlite3VtabEponymousTableClear(db, pMod);
    sqlite3VtabModuleUnref(db, pMod);
  }
  sqlite3HashClear(&db->aModule);


  sqlite3Error(db, 0);
  sqlite3ValueFree(db->pErr);
  sqlite3CloseExtensions(db);





  db->magic = 0xb5357930;







  sqlite3DbFree(db, db->aDb[1].pSchema);
  sqlite3_mutex_leave(db->mutex);
  db->magic = 0x9f3c2d33;
  sqlite3_mutex_free(db->mutex);
  ((void)0);
  if( db->lookaside.bMalloced ){
    sqlite3_free(db->lookaside.pStart);
  }
  sqlite3_free(db);
}
# 157517 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3RollbackAll(sqlite3 *db, int tripCode){
  int i;
  int inTrans = 0;
  int schemaChange;
  ((void)0);
  sqlite3BeginBenignMalloc();







  sqlite3BtreeEnterAll(db);
  schemaChange = (db->mDbFlags & 0x0001)!=0 && db->init.busy==0;

  for(i=0; i<db->nDb; i++){
    Btree *p = db->aDb[i].pBt;
    if( p ){
      if( sqlite3BtreeIsInTrans(p) ){
        inTrans = 1;
      }
      sqlite3BtreeRollback(p, tripCode, !schemaChange);
    }
  }
  sqlite3VtabRollback(db);
  sqlite3EndBenignMalloc();

  if( schemaChange ){
    sqlite3ExpirePreparedStatements(db, 0);
    sqlite3ResetAllSchemasOfConnection(db);
  }
  sqlite3BtreeLeaveAll(db);


  db->nDeferredCons = 0;
  db->nDeferredImmCons = 0;
  db->flags &= ~(u64)0x00080000;


  if( db->xRollbackCallback && (inTrans || !db->autoCommit) ){
    db->xRollbackCallback(db->pRollbackArg);
  }
}
# 157677 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static const char *sqlite3ErrStr(int rc){
  static const char* const aMsg[] = {
                             "not an error",
                             "SQL logic error",
                             0,
                             "access permission denied",
                             "query aborted",
                             "database is locked",
                             "database table is locked",
                             "out of memory",
                             "attempt to write a readonly database",
                             "interrupted",
                             "disk I/O error",
                             "database disk image is malformed",
                             "unknown operation",
                             "database or disk is full",
                             "unable to open database file",
                             "locking protocol",
                             0,
                             "database schema has changed",
                             "string or blob too big",
                             "constraint failed",
                             "datatype mismatch",
                             "bad parameter or other API misuse",



                             0,

                             "authorization denied",
                             0,
                             "column index out of range",
                             "file is not a database",
                             "notification message",
                             "warning message",
  };
  const char *zErr = "unknown error";
  switch( rc ){
    case (4 | (2<<8)): {
      zErr = "abort due to ROLLBACK";
      break;
    }
    case 100: {
      zErr = "another row available";
      break;
    }
    case 101: {
      zErr = "no more rows available";
      break;
    }
    default: {
      rc &= 0xff;
      if( (rc>=0) && rc<((int)(sizeof(aMsg)/sizeof(aMsg[0]))) && aMsg[rc]!=0 ){
        zErr = aMsg[rc];
      }
      break;
    }
  }
  return zErr;
}
# 157747 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqliteDefaultBusyCallback(
  void *ptr,
  int count,
  sqlite3_file *pFile
){
# 157794 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3 *db = (sqlite3 *)ptr;
  int tmout = ((sqlite3 *)ptr)->busyTimeout;
  (void)(pFile);
  if( (count+1)*1000 > tmout ){
    return 0;
  }
  sqlite3OsSleep(db->pVfs, 1000000);
  return 1;

}
# 157814 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3InvokeBusyHandler(BusyHandler *p, sqlite3_file *pFile){
  int rc;
  if( p->xBusyHandler==0 || p->nBusy<0 ) return 0;
  if( p->bExtraFileArg ){


    int (*xTra)(void*,int,sqlite3_file*);
    xTra = (int(*)(void*,int,sqlite3_file*))p->xBusyHandler;
    rc = xTra(p->pBusyArg, p->nBusy, pFile);
  }else{

    rc = p->xBusyHandler(p->pBusyArg, p->nBusy);
  }
  if( rc==0 ){
    p->nBusy = -1;
  }else{
    p->nBusy++;
  }
  return rc;
}





 int sqlite3_busy_handler(
  sqlite3 *db,
  int (*xBusy)(void*,int),
  void *pArg
){



  sqlite3_mutex_enter(db->mutex);
  db->busyHandler.xBusyHandler = xBusy;
  db->busyHandler.pBusyArg = pArg;
  db->busyHandler.nBusy = 0;
  db->busyHandler.bExtraFileArg = 0;
  db->busyTimeout = 0;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}







 void sqlite3_progress_handler(
  sqlite3 *db,
  int nOps,
  int (*xProgress)(void*),
  void *pArg
){






  sqlite3_mutex_enter(db->mutex);
  if( nOps>0 ){
    db->xProgress = xProgress;
    db->nProgressOps = (unsigned)nOps;
    db->pProgressArg = pArg;
  }else{
    db->xProgress = 0;
    db->nProgressOps = 0;
    db->pProgressArg = 0;
  }
  sqlite3_mutex_leave(db->mutex);
}







 int sqlite3_busy_timeout(sqlite3 *db, int ms){



  if( ms>0 ){
    sqlite3_busy_handler(db, (int(*)(void*,int))sqliteDefaultBusyCallback,
                             (void*)db);
    db->busyTimeout = ms;
    db->busyHandler.bExtraFileArg = 1;
  }else{
    sqlite3_busy_handler(db, 0, 0);
  }
  return 0;
}




 void sqlite3_interrupt(sqlite3 *db){






  db->u1.isInterrupted = 1;
}
# 157929 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3CreateFunc(
  sqlite3 *db,
  const char *zFunctionName,
  int nArg,
  int enc,
  void *pUserData,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value **),
  FuncDestructor *pDestructor
){
  FuncDef *p;
  int nName;
  int extraFlags;

  ((void)0);
  ((void)0);
  if( zFunctionName==0
   || (xSFunc!=0 && xFinal!=0)
   || ((xFinal==0)!=(xStep==0))
   || ((xValue==0)!=(xInverse==0))
   || (nArg<-1 || nArg>127)
   || (255<(nName = sqlite3Strlen30( zFunctionName)))
  ){
    return sqlite3MisuseError(157955);
  }

  ((void)0);
  ((void)0);
  extraFlags = enc & (0x000000800|0x000080000|0x000100000);
  enc &= (0x0003|5);
# 157971 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( enc==4 ){
    enc = 2;
  }else if( enc==5 ){
    int rc;
    rc = sqlite3CreateFunc(db, zFunctionName, nArg, 1|extraFlags,
         pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);
    if( rc==0 ){
      rc = sqlite3CreateFunc(db, zFunctionName, nArg, 2|extraFlags,
          pUserData, xSFunc, xStep, xFinal, xValue, xInverse, pDestructor);
    }
    if( rc!=0 ){
      return rc;
    }
    enc = 3;
  }
# 157995 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 0);
  if( p && (p->funcFlags & 0x0003)==(u32)enc && p->nArg==nArg ){
    if( db->nVdbeActive ){
      sqlite3ErrorWithMsg(db, 5,
        "unable to delete/modify user-function due to active statements");
      ((void)0);
      return 5;
    }else{
      sqlite3ExpirePreparedStatements(db, 0);
    }
  }

  p = sqlite3FindFunction(db, zFunctionName, nArg, (u8)enc, 1);
  ((void)0);
  if( !p ){
    return 7;
  }



  functionDestroy(db, p);

  if( pDestructor ){
    pDestructor->nRef++;
  }
  p->u.pDestructor = pDestructor;
  p->funcFlags = (p->funcFlags & 0x0003) | extraFlags;
  ;
  ;
  p->xSFunc = xSFunc ? xSFunc : xStep;
  p->xFinalize = xFinal;
  p->xValue = xValue;
  p->xInverse = xInverse;
  p->pUserData = pUserData;
  p->nArg = (u16)nArg;
  return 0;
}
# 158040 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int createFunctionApi(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value**),
  void(*xDestroy)(void*)
){
  int rc = 1;
  FuncDestructor *pArg = 0;






  sqlite3_mutex_enter(db->mutex);
  if( xDestroy ){
    pArg = (FuncDestructor *)sqlite3Malloc(sizeof(FuncDestructor));
    if( !pArg ){
      sqlite3OomFault(db);
      xDestroy(p);
      goto out;
    }
    pArg->nRef = 0;
    pArg->xDestroy = xDestroy;
    pArg->pUserData = p;
  }
  rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p,
      xSFunc, xStep, xFinal, xValue, xInverse, pArg
  );
  if( pArg && pArg->nRef==0 ){
    ((void)0);
    xDestroy(p);
    sqlite3_free(pArg);
  }

 out:
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




 int sqlite3_create_function(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*)
){
  return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,
                                    xFinal, 0, 0, 0);
}
 int sqlite3_create_function_v2(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value **),
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xDestroy)(void *)
){
  return createFunctionApi(db, zFunc, nArg, enc, p, xSFunc, xStep,
                                    xFinal, 0, 0, xDestroy);
}
 int sqlite3_create_window_function(
  sqlite3 *db,
  const char *zFunc,
  int nArg,
  int enc,
  void *p,
  void (*xStep)(sqlite3_context*,int,sqlite3_value **),
  void (*xFinal)(sqlite3_context*),
  void (*xValue)(sqlite3_context*),
  void (*xInverse)(sqlite3_context*,int,sqlite3_value **),
  void (*xDestroy)(void *)
){
  return createFunctionApi(db, zFunc, nArg, enc, p, 0, xStep,
                                    xFinal, xValue, xInverse, xDestroy);
}


 int sqlite3_create_function16(
  sqlite3 *db,
  const void *zFunctionName,
  int nArg,
  int eTextRep,
  void *p,
  void (*xSFunc)(sqlite3_context*,int,sqlite3_value**),
  void (*xStep)(sqlite3_context*,int,sqlite3_value**),
  void (*xFinal)(sqlite3_context*)
){
  int rc;
  char *zFunc8;




  sqlite3_mutex_enter(db->mutex);
  ((void)0);
  zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, 2);
  rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xSFunc,xStep,xFinal,0,0,0);
  sqlite3DbFree(db, zFunc8);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}
# 158171 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static void sqlite3InvalidFunction(
  sqlite3_context *context,
  int NotUsed,
  sqlite3_value **NotUsed2
){
  const char *zName = (const char*)sqlite3_user_data(context);
  char *zErr;
  (void)(NotUsed),(void)(NotUsed2);
  zErr = sqlite3_mprintf(
      "unable to use function %s in the requested context", zName);
  sqlite3_result_error(context, zErr, -1);
  sqlite3_free(zErr);
}
# 158197 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_overload_function(
  sqlite3 *db,
  const char *zName,
  int nArg
){
  int rc;
  char *zCopy;






  sqlite3_mutex_enter(db->mutex);
  rc = sqlite3FindFunction(db, zName, nArg, 1, 0)!=0;
  sqlite3_mutex_leave(db->mutex);
  if( rc ) return 0;
  zCopy = sqlite3_mprintf(zName);
  if( zCopy==0 ) return 7;
  return sqlite3_create_function_v2(db, zName, nArg, 1,
                           zCopy, sqlite3InvalidFunction, 0, 0, sqlite3_free);
}
# 158230 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_trace(sqlite3 *db, void(*xTrace)(void*,const char*), void *pArg){
  void *pOld;







  sqlite3_mutex_enter(db->mutex);
  pOld = db->pTraceArg;
  db->mTrace = xTrace ? 0x40 : 0;
  db->xTrace = (int(*)(u32,void*,void*,void*))xTrace;
  db->pTraceArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pOld;
}




 int sqlite3_trace_v2(
  sqlite3 *db,
  unsigned mTrace,
  int(*xTrace)(unsigned,void*,void*,void*),
  void *pArg
){





  sqlite3_mutex_enter(db->mutex);
  if( mTrace==0 ) xTrace = 0;
  if( xTrace==0 ) mTrace = 0;
  db->mTrace = mTrace;
  db->xTrace = xTrace;
  db->pTraceArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}
# 158281 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_profile(
  sqlite3 *db,
  void (*xProfile)(void*,const char*,sqlite_uint64),
  void *pArg
){
  void *pOld;







  sqlite3_mutex_enter(db->mutex);
  pOld = db->pProfileArg;
  db->xProfile = xProfile;
  db->pProfileArg = pArg;
  db->mTrace &= 0x0f;
  if( db->xProfile ) db->mTrace |= 0x80;
  sqlite3_mutex_leave(db->mutex);
  return pOld;
}
# 158311 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void *sqlite3_commit_hook(
  sqlite3 *db,
  int (*xCallback)(void*),
  void *pArg
){
  void *pOld;







  sqlite3_mutex_enter(db->mutex);
  pOld = db->pCommitArg;
  db->xCommitCallback = xCallback;
  db->pCommitArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pOld;
}





 void *sqlite3_update_hook(
  sqlite3 *db,
  void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),
  void *pArg
){
  void *pRet;







  sqlite3_mutex_enter(db->mutex);
  pRet = db->pUpdateArg;
  db->xUpdateCallback = xCallback;
  db->pUpdateArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pRet;
}





 void *sqlite3_rollback_hook(
  sqlite3 *db,
  void (*xCallback)(void*),
  void *pArg
){
  void *pRet;







  sqlite3_mutex_enter(db->mutex);
  pRet = db->pRollbackArg;
  db->xRollbackCallback = xCallback;
  db->pRollbackArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pRet;
}
# 158410 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3WalDefaultHook(
  void *pClientData,
  sqlite3 *db,
  const char *zDb,
  int nFrame
){
  if( nFrame>=((int)(long int)(pClientData)) ){
    sqlite3BeginBenignMalloc();
    sqlite3_wal_checkpoint(db, zDb);
    sqlite3EndBenignMalloc();
  }
  return 0;
}
# 158436 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){







  if( nFrame>0 ){
    sqlite3_wal_hook(db, sqlite3WalDefaultHook, ((void*)(long int)(nFrame)));
  }else{
    sqlite3_wal_hook(db, 0, 0);
  }

  return 0;
}





 void *sqlite3_wal_hook(
  sqlite3 *db,
  int(*xCallback)(void *, sqlite3*, const char*, int),
  void *pArg
){

  void *pRet;






  sqlite3_mutex_enter(db->mutex);
  pRet = db->pWalArg;
  db->xWalCallback = xCallback;
  db->pWalArg = pArg;
  sqlite3_mutex_leave(db->mutex);
  return pRet;



}




 int sqlite3_wal_checkpoint_v2(
  sqlite3 *db,
  const char *zDb,
  int eMode,
  int *pnLog,
  int *pnCkpt
){



  int rc;
  int iDb = 10;






  if( pnLog ) *pnLog = -1;
  if( pnCkpt ) *pnCkpt = -1;

  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  if( eMode<0 || eMode>3 ){


    return 21;
  }

  sqlite3_mutex_enter(db->mutex);
  if( zDb && zDb[0] ){
    iDb = sqlite3FindDbName(db, zDb);
  }
  if( iDb<0 ){
    rc = 1;
    sqlite3ErrorWithMsg(db, 1, "unknown database: %s", zDb);
  }else{
    db->busyHandler.nBusy = 0;
    rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);
    sqlite3Error(db, rc);
  }
  rc = sqlite3ApiExit(db, rc);



  if( db->nVdbeActive==0 ){
    db->u1.isInterrupted = 0;
  }

  sqlite3_mutex_leave(db->mutex);
  return rc;

}







 int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){


  return sqlite3_wal_checkpoint_v2(db,zDb,0,0,0);
}
# 158573 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt){
  int rc = 0;
  int i;
  int bBusy = 0;

  ((void)0);
  ((void)0);
  ((void)0);

  for(i=0; i<db->nDb && rc==0; i++){
    if( i==iDb || iDb==10 ){
      rc = sqlite3BtreeCheckpoint(db->aDb[i].pBt, eMode, pnLog, pnCkpt);
      pnLog = 0;
      pnCkpt = 0;
      if( rc==5 ){
        bBusy = 1;
        rc = 0;
      }
    }
  }

  return (rc==0 && bBusy) ? 5 : rc;
}
# 158617 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3TempInMemory(const sqlite3 *db){

  return ( db->temp_store==2 );
# 158632 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
}





 const char *sqlite3_errmsg(sqlite3 *db){
  const char *z;
  if( !db ){
    return sqlite3ErrStr(7);
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3ErrStr(sqlite3MisuseError(158644));
  }
  sqlite3_mutex_enter(db->mutex);
  if( db->mallocFailed ){
    z = sqlite3ErrStr(7);
  }else{
    ;
    z = db->errCode ? (char*)sqlite3_value_text(db->pErr) : 0;
    ((void)0);
    if( z==0 ){
      z = sqlite3ErrStr(db->errCode);
    }
  }
  sqlite3_mutex_leave(db->mutex);
  return z;
}






 const void *sqlite3_errmsg16(sqlite3 *db){
  static const u16 outOfMem[] = {
    'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0
  };
  static const u16 misuse[] = {
    'b', 'a', 'd', ' ', 'p', 'a', 'r', 'a', 'm', 'e', 't', 'e', 'r', ' ',
    'o', 'r', ' ', 'o', 't', 'h', 'e', 'r', ' ', 'A', 'P', 'I', ' ',
    'm', 'i', 's', 'u', 's', 'e', 0
  };

  const void *z;
  if( !db ){
    return (void *)outOfMem;
  }
  if( !sqlite3SafetyCheckSickOrOk(db) ){
    return (void *)misuse;
  }
  sqlite3_mutex_enter(db->mutex);
  if( db->mallocFailed ){
    z = (void *)outOfMem;
  }else{
    z = sqlite3_value_text16(db->pErr);
    if( z==0 ){
      sqlite3ErrorWithMsg(db, db->errCode, sqlite3ErrStr(db->errCode));
      z = sqlite3_value_text16(db->pErr);
    }





    sqlite3OomClear(db);
  }
  sqlite3_mutex_leave(db->mutex);
  return z;
}






 int sqlite3_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(158710);
  }
  if( !db || db->mallocFailed ){
    return 7;
  }
  return db->errCode & db->errMask;
}
 int sqlite3_extended_errcode(sqlite3 *db){
  if( db && !sqlite3SafetyCheckSickOrOk(db) ){
    return sqlite3MisuseError(158719);
  }
  if( !db || db->mallocFailed ){
    return 7;
  }
  return db->errCode;
}
 int sqlite3_system_errno(sqlite3 *db){
  return db ? db->iSysErrno : 0;
}






 const char *sqlite3_errstr(int rc){
  return sqlite3ErrStr(rc);
}





static int createCollation(
  sqlite3* db,
  const char *zName,
  u8 enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDel)(void*)
){
  CollSeq *pColl;
  int enc2;

  ((void)0);





  enc2 = enc;
  ;
  ;
  if( enc2==4 || enc2==8 ){
    enc2 = 2;
  }
  if( enc2<1 || enc2>3 ){
    return sqlite3MisuseError(158767);
  }





  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 0);
  if( pColl && pColl->xCmp ){
    if( db->nVdbeActive ){
      sqlite3ErrorWithMsg(db, 5,
        "unable to delete/modify collation sequence due to active statements");
      return 5;
    }
    sqlite3ExpirePreparedStatements(db, 0);







    if( (pColl->enc & ~8)==enc2 ){
      CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName);
      int j;
      for(j=0; j<3; j++){
        CollSeq *p = &aColl[j];
        if( p->enc==pColl->enc ){
          if( p->xDel ){
            p->xDel(p->pUser);
          }
          p->xCmp = 0;
        }
      }
    }
  }

  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 1);
  if( pColl==0 ) return 7;
  pColl->xCmp = xCompare;
  pColl->pUser = pCtx;
  pColl->xDel = xDel;
  pColl->enc = (u8)(enc2 | (enc & 8));
  sqlite3Error(db, 0);
  return 0;
}







static const int aHardLimit[] = {
  1000000000,
  1000000000,
  2000,
  1000,
  500,
  250000000,
  127,
  10,
  50000,
  999,
  1000,
  8,
};
# 158883 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){
  int oldLimit;
# 158898 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0)
                                                                               ;
  ((void)0);
  ((void)0);
  ((void)0);
  ((void)0);


  if( limitId<0 || limitId>=(11 +1) ){
    return -1;
  }
  oldLimit = db->aLimit[limitId];
  if( newLimit>=0 ){
    if( newLimit>aHardLimit[limitId] ){
      newLimit = aHardLimit[limitId];
    }
    db->aLimit[limitId] = newLimit;
  }
  return oldLimit;
}
# 158951 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ParseUri(
  const char *zDefaultVfs,
  const char *zUri,
  unsigned int *pFlags,
  sqlite3_vfs **ppVfs,
  char **pzFile,
  char **pzErrMsg
){
  int rc = 0;
  unsigned int flags = *pFlags;
  const char *zVfs = zDefaultVfs;
  char *zFile;
  char c;
  int nUri = sqlite3Strlen30(zUri);

  ((void)0);

  if( ((flags & 0x00000040)
            || sqlite3Config.bOpenUri)
   && nUri>=5 && memcmp(zUri, "file:", 5)==0
  ){
    char *zOpt;
    int eState;
    int iIn;
    int iOut = 0;
    u64 nByte = nUri+2;



    flags |= 0x00000040;

    for(iIn=0; iIn<nUri; iIn++) nByte += (zUri[iIn]=='&');
    zFile = sqlite3_malloc64(nByte);
    if( !zFile ) return 7;

    iIn = 5;
# 159001 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    if( zUri[5]=='/' && zUri[6]=='/' ){
      iIn = 7;
      while( zUri[iIn] && zUri[iIn]!='/' ) iIn++;
      if( iIn!=7 && (iIn!=16 || memcmp("localhost", &zUri[7], 9)) ){
        *pzErrMsg = sqlite3_mprintf("invalid uri authority: %.*s",
            iIn-7, &zUri[7]);
        rc = 1;
        goto parse_uri_out;
      }
    }
# 159023 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    eState = 0;
    while( (c = zUri[iIn])!=0 && c!='#' ){
      iIn++;
      if( c=='%'
       && (sqlite3CtypeMap[(unsigned char)(zUri[iIn])]&0x08)
       && (sqlite3CtypeMap[(unsigned char)(zUri[iIn+1])]&0x08)
      ){
        int octet = (sqlite3HexToInt(zUri[iIn++]) << 4);
        octet += sqlite3HexToInt(zUri[iIn++]);

        ((void)0);
        if( octet==0 ){





          while( (c = zUri[iIn])!=0 && c!='#'
              && (eState!=0 || c!='?')
              && (eState!=1 || (c!='=' && c!='&'))
              && (eState!=2 || c!='&')
          ){
            iIn++;
          }
          continue;






        }
        c = octet;
      }else if( eState==1 && (c=='&' || c=='=') ){
        if( zFile[iOut-1]==0 ){

          while( zUri[iIn] && zUri[iIn]!='#' && zUri[iIn-1]!='&' ) iIn++;
          continue;
        }
        if( c=='&' ){
          zFile[iOut++] = '\0';
        }else{
          eState = 2;
        }
        c = 0;
      }else if( (eState==0 && c=='?') || (eState==2 && c=='&') ){
        c = 0;
        eState = 1;
      }
      zFile[iOut++] = c;
    }
    if( eState==1 ) zFile[iOut++] = '\0';
    zFile[iOut++] = '\0';
    zFile[iOut++] = '\0';





    zOpt = &zFile[sqlite3Strlen30(zFile)+1];
    while( zOpt[0] ){
      int nOpt = sqlite3Strlen30(zOpt);
      char *zVal = &zOpt[nOpt+1];
      int nVal = sqlite3Strlen30(zVal);

      if( nOpt==3 && memcmp("vfs", zOpt, 3)==0 ){
        zVfs = zVal;
      }else{
        struct OpenMode {
          const char *z;
          int mode;
        } *aMode = 0;
        char *zModeType = 0;
        int mask = 0;
        int limit = 0;

        if( nOpt==5 && memcmp("cache", zOpt, 5)==0 ){
          static struct OpenMode aCacheMode[] = {
            { "shared", 0x00020000 },
            { "private", 0x00040000 },
            { 0, 0 }
          };

          mask = 0x00020000|0x00040000;
          aMode = aCacheMode;
          limit = mask;
          zModeType = "cache";
        }
        if( nOpt==4 && memcmp("mode", zOpt, 4)==0 ){
          static struct OpenMode aOpenMode[] = {
            { "ro", 0x00000001 },
            { "rw", 0x00000002 },
            { "rwc", 0x00000002 | 0x00000004 },
            { "memory", 0x00000080 },
            { 0, 0 }
          };

          mask = 0x00000001 | 0x00000002
                   | 0x00000004 | 0x00000080;
          aMode = aOpenMode;
          limit = mask & flags;
          zModeType = "access";
        }

        if( aMode ){
          int i;
          int mode = 0;
          for(i=0; aMode[i].z; i++){
            const char *z = aMode[i].z;
            if( nVal==sqlite3Strlen30(z) && 0==memcmp(zVal, z, nVal) ){
              mode = aMode[i].mode;
              break;
            }
          }
          if( mode==0 ){
            *pzErrMsg = sqlite3_mprintf("no such %s mode: %s", zModeType, zVal);
            rc = 1;
            goto parse_uri_out;
          }
          if( (mode & ~0x00000080)>limit ){
            *pzErrMsg = sqlite3_mprintf("%s mode not allowed: %s",
                                        zModeType, zVal);
            rc = 3;
            goto parse_uri_out;
          }
          flags = (flags & ~mask) | mode;
        }
      }

      zOpt = &zVal[nVal+1];
    }

  }else{
    zFile = sqlite3_malloc64(nUri+2);
    if( !zFile ) return 7;
    if( nUri ){
      memcpy(zFile, zUri, nUri);
    }
    zFile[nUri] = '\0';
    zFile[nUri+1] = '\0';
    flags &= ~0x00000040;
  }

  *ppVfs = sqlite3_vfs_find(zVfs);
  if( *ppVfs==0 ){
    *pzErrMsg = sqlite3_mprintf("no such vfs: %s", zVfs);
    rc = 1;
  }
 parse_uri_out:
  if( rc!=0 ){
    sqlite3_free(zFile);
    zFile = 0;
  }
  *pFlags = flags;
  *pzFile = zFile;
  return rc;
}
# 159221 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int openDatabase(
  const char *zFilename,
  sqlite3 **ppDb,
  unsigned int flags,
  const char *zVfs
){
  sqlite3 *db;
  int rc;
  int isThreadsafe;
  char *zOpen = 0;
  char *zErrMsg = 0;




  *ppDb = 0;

  rc = sqlite3_initialize();
  if( rc ) return rc;


  if( sqlite3Config.bCoreMutex==0 ){
    isThreadsafe = 0;
  }else if( flags & 0x00008000 ){
    isThreadsafe = 0;
  }else if( flags & 0x00010000 ){
    isThreadsafe = 1;
  }else{
    isThreadsafe = sqlite3Config.bFullMutex;
  }

  if( flags & 0x00040000 ){
    flags &= ~0x00020000;
  }else if( sqlite3Config.sharedCacheEnabled ){
    flags |= 0x00020000;
  }
# 159267 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  flags &= ~( 0x00000008 |
               0x00000010 |
               0x00000100 |
               0x00000200 |
               0x00000400 |
               0x00000800 |
               0x00001000 |
               0x00002000 |
               0x00004000 |
               0x00008000 |
               0x00010000 |
               0x00080000
             );


  db = sqlite3MallocZero( sizeof(sqlite3) );
  if( db==0 ) goto opendb_out;
  if( isThreadsafe



  ){
    db->mutex = sqlite3MutexAlloc(1);
    if( db->mutex==0 ){
      sqlite3_free(db);
      db = 0;
      goto opendb_out;
    }
    if( isThreadsafe==0 ){
      ;
    }
  }
  sqlite3_mutex_enter(db->mutex);
  db->errMask = 0xff;
  db->nDb = 2;
  db->magic = 0xf03b7906;
  db->aDb = db->aDbStatic;
  db->lookaside.bDisable = 1;

  ((void)0);
  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));
  db->aLimit[11] = 0;
  db->autoCommit = 1;
  db->nextAutovac = -1;
  db->szMmap = sqlite3Config.szMmap;
  db->nextPagesize = 0;
  db->nMaxSorterMmap = 0x7FFFFFFF;
  db->flags |= 0x00000040
                 | 0x00040000
                 | 0x80000000
                 | 0x00000020
# 159335 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define SQLITE_DQS 3


                 | 0x40000000


                 | 0x20000000



                 | 0x00008000
# 159377 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
      ;
  sqlite3HashInit(&db->aCollSeq);

  sqlite3HashInit(&db->aModule);
# 159390 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  createCollation(db, sqlite3StrBINARY, 1, 0, binCollFunc, 0);
  createCollation(db, sqlite3StrBINARY, 3, 0, binCollFunc, 0);
  createCollation(db, sqlite3StrBINARY, 2, 0, binCollFunc, 0);
  createCollation(db, "NOCASE", 1, 0, nocaseCollatingFunc, 0);
  createCollation(db, "RTRIM", 1, 0, rtrimCollFunc, 0);
  if( db->mallocFailed ){
    goto opendb_out;
  }



  db->pDfltColl = sqlite3FindCollSeq(db, 1, sqlite3StrBINARY, 0);
  ((void)0);
# 159416 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  db->openFlags = flags;
  ((void)0);
  ((void)0);
  ((void)0);
  ;
  ;
  ;
  if( ((1<<(flags&7)) & 0x46)==0 ){
    rc = sqlite3MisuseError(159424);
  }else{
    rc = sqlite3ParseUri(zVfs, zFilename, &flags, &db->pVfs, &zOpen, &zErrMsg);
  }
  if( rc!=0 ){
    if( rc==7 ) sqlite3OomFault(db);
    sqlite3ErrorWithMsg(db, rc, zErrMsg ? "%s" : 0, zErrMsg);
    sqlite3_free(zErrMsg);
    goto opendb_out;
  }


  rc = sqlite3BtreeOpen(db->pVfs, zOpen, db, &db->aDb[0].pBt, 0,
                        flags | 0x00000100);
  if( rc!=0 ){
    if( rc==(10 | (12<<8)) ){
      rc = 7;
    }
    sqlite3Error(db, rc);
    goto opendb_out;
  }
  sqlite3BtreeEnter(db->aDb[0].pBt);
  db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);
  if( !db->mallocFailed ) ((db)->enc) = ((db)->aDb[0].pSchema->enc);
  sqlite3BtreeLeave(db->aDb[0].pBt);
  db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);




  db->aDb[0].zDbSName = "main";
  db->aDb[0].safety_level = 2 +1;
  db->aDb[1].zDbSName = "temp";
  db->aDb[1].safety_level = 0x01;

  db->magic = 0xa029a697;
  if( db->mallocFailed ){
    goto opendb_out;
  }





  sqlite3Error(db, 0);
  sqlite3RegisterPerConnectionBuiltinFunctions(db);
  rc = sqlite3_errcode(db);
# 159484 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rc==0 ){
    sqlite3AutoLoadExtensions(db);
    rc = sqlite3_errcode(db);
    if( rc!=0 ){
      goto opendb_out;
    }
  }
# 159558 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( rc ) sqlite3Error(db, rc);


  setupLookaside(db, 0, sqlite3Config.szLookaside,
                        sqlite3Config.nLookaside);

  sqlite3_wal_autocheckpoint(db, 1000);

opendb_out:
  if( db ){
    ((void)0)
                                                 ;
    sqlite3_mutex_leave(db->mutex);
  }
  rc = sqlite3_errcode(db);
  ((void)0);
  if( rc==7 ){
    sqlite3_close(db);
    db = 0;
  }else if( rc!=0 ){
    db->magic = 0x4b771290;
  }
  *ppDb = db;
# 159591 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_free(zOpen);
  return rc & 0xff;
}





 int sqlite3_open(
  const char *zFilename,
  sqlite3 **ppDb
){
  return openDatabase(zFilename, ppDb,
                      0x00000002 | 0x00000004, 0);
}
 int sqlite3_open_v2(
  const char *filename,
  sqlite3 **ppDb,
  int flags,
  const char *zVfs
){
  return openDatabase(filename, ppDb, (unsigned int)flags, zVfs);
}





 int sqlite3_open16(
  const void *zFilename,
  sqlite3 **ppDb
){
  char const *zFilename8;
  sqlite3_value *pVal;
  int rc;




  *ppDb = 0;

  rc = sqlite3_initialize();
  if( rc ) return rc;

  if( zFilename==0 ) zFilename = "\000\000";
  pVal = sqlite3ValueNew(0);
  sqlite3ValueSetStr(pVal, -1, zFilename, 2, ((sqlite3_destructor_type)0));
  zFilename8 = sqlite3ValueText(pVal, 1);
  if( zFilename8 ){
    rc = openDatabase(zFilename8, ppDb,
                      0x00000002 | 0x00000004, 0);
    ((void)0);
    if( rc==0 && !(((*ppDb)->aDb[0].pSchema->schemaFlags&(0x0001))==(0x0001)) ){
      ((*ppDb)->aDb[0].pSchema->enc) = ((*ppDb)->enc) = 2;
    }
  }else{
    rc = 7;
  }
  sqlite3ValueFree(pVal);

  return rc & 0xff;
}





 int sqlite3_create_collation(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
){
  return sqlite3_create_collation_v2(db, zName, enc, pCtx, xCompare, 0);
}




 int sqlite3_create_collation_v2(
  sqlite3* db,
  const char *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*),
  void(*xDel)(void*)
){
  int rc;




  sqlite3_mutex_enter(db->mutex);
  ((void)0);
  rc = createCollation(db, zName, (u8)enc, pCtx, xCompare, xDel);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}





 int sqlite3_create_collation16(
  sqlite3* db,
  const void *zName,
  int enc,
  void* pCtx,
  int(*xCompare)(void*,int,const void*,int,const void*)
){
  int rc = 0;
  char *zName8;




  sqlite3_mutex_enter(db->mutex);
  ((void)0);
  zName8 = sqlite3Utf16to8(db, zName, -1, 2);
  if( zName8 ){
    rc = createCollation(db, zName8, (u8)enc, pCtx, xCompare, 0);
    sqlite3DbFree(db, zName8);
  }
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}






 int sqlite3_collation_needed(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)
){



  sqlite3_mutex_enter(db->mutex);
  db->xCollNeeded = xCollNeeded;
  db->xCollNeeded16 = 0;
  db->pCollNeededArg = pCollNeededArg;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}






 int sqlite3_collation_needed16(
  sqlite3 *db,
  void *pCollNeededArg,
  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)
){



  sqlite3_mutex_enter(db->mutex);
  db->xCollNeeded = 0;
  db->xCollNeeded16 = xCollNeeded16;
  db->pCollNeededArg = pCollNeededArg;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}







 int sqlite3_global_recover(void){
  return 0;
}
# 159780 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_get_autocommit(sqlite3 *db){






  return db->autoCommit;
}
# 159801 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
static int sqlite3ReportError(int iErr, int lineno, const char *zType){
  sqlite3_log(iErr, "%s at line %d of [%.10s]",
              zType, lineno, 20+sqlite3_sourceid());
  return iErr;
}
static int sqlite3CorruptError(int lineno){
  ;
  return sqlite3ReportError(11, lineno, "database corruption");
}
static int sqlite3MisuseError(int lineno){
  ;
  return sqlite3ReportError(21, lineno, "misuse");
}
static int sqlite3CantopenError(int lineno){
  ;
  return sqlite3ReportError(14, lineno, "cannot open file");
}
# 159843 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 void sqlite3_thread_cleanup(void){
}






 int sqlite3_table_column_metadata(
  sqlite3 *db,
  const char *zDbName,
  const char *zTableName,
  const char *zColumnName,
  char const **pzDataType,
  char const **pzCollSeq,
  int *pNotNull,
  int *pPrimaryKey,
  int *pAutoinc
){
  int rc;
  char *zErrMsg = 0;
  Table *pTab = 0;
  Column *pCol = 0;
  int iCol = 0;
  char const *zDataType = 0;
  char const *zCollSeq = 0;
  int notnull = 0;
  int primarykey = 0;
  int autoinc = 0;
# 159881 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  sqlite3_mutex_enter(db->mutex);
  sqlite3BtreeEnterAll(db);
  rc = sqlite3Init(db, &zErrMsg);
  if( 0!=rc ){
    goto error_out;
  }


  pTab = sqlite3FindTable(db, zTableName, zDbName);
  if( !pTab || pTab->pSelect ){
    pTab = 0;
    goto error_out;
  }


  if( zColumnName==0 ){

  }else{
    for(iCol=0; iCol<pTab->nCol; iCol++){
      pCol = &pTab->aCol[iCol];
      if( 0==sqlite3StrICmp(pCol->zName, zColumnName) ){
        break;
      }
    }
    if( iCol==pTab->nCol ){
      if( (((pTab)->tabFlags & 0x0020)==0) && sqlite3IsRowid(zColumnName) ){
        iCol = pTab->iPKey;
        pCol = iCol>=0 ? &pTab->aCol[iCol] : 0;
      }else{
        pTab = 0;
        goto error_out;
      }
    }
  }
# 159926 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  if( pCol ){
    zDataType = sqlite3ColumnType(pCol,0);
    zCollSeq = pCol->zColl;
    notnull = pCol->notNull!=0;
    primarykey = (pCol->colFlags & 0x0001)!=0;
    autoinc = pTab->iPKey==iCol && (pTab->tabFlags & 0x0008)!=0;
  }else{
    zDataType = "INTEGER";
    primarykey = 1;
  }
  if( !zCollSeq ){
    zCollSeq = sqlite3StrBINARY;
  }

error_out:
  sqlite3BtreeLeaveAll(db);





  if( pzDataType ) *pzDataType = zDataType;
  if( pzCollSeq ) *pzCollSeq = zCollSeq;
  if( pNotNull ) *pNotNull = notnull;
  if( pPrimaryKey ) *pPrimaryKey = primarykey;
  if( pAutoinc ) *pAutoinc = autoinc;

  if( 0==rc && !pTab ){
    sqlite3DbFree(db, zErrMsg);
    zErrMsg = sqlite3MPrintf(db, "no such table column: %s.%s", zTableName,
        zColumnName);
    rc = 1;
  }
  sqlite3ErrorWithMsg(db, rc, (zErrMsg?"%s":0), zErrMsg);
  sqlite3DbFree(db, zErrMsg);
  rc = sqlite3ApiExit(db, rc);
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




 int sqlite3_sleep(int ms){
  sqlite3_vfs *pVfs;
  int rc;
  pVfs = sqlite3_vfs_find(0);
  if( pVfs==0 ) return 0;




  rc = (sqlite3OsSleep(pVfs, 1000*ms)/1000);
  return rc;
}




 int sqlite3_extended_result_codes(sqlite3 *db, int onoff){



  sqlite3_mutex_enter(db->mutex);
  db->errMask = onoff ? 0xffffffff : 0xff;
  sqlite3_mutex_leave(db->mutex);
  return 0;
}




 int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){
  int rc = 1;
  Btree *pBtree;




  sqlite3_mutex_enter(db->mutex);
  pBtree = sqlite3DbNameToBtree(db, zDbName);
  if( pBtree ){
    Pager *pPager;
    sqlite3_file *fd;
    sqlite3BtreeEnter(pBtree);
    pPager = sqlite3BtreePager(pBtree);
    ((void)0);
    fd = sqlite3PagerFile(pPager);
    ((void)0);
    if( op==7 ){
      *(sqlite3_file**)pArg = fd;
      rc = 0;
    }else if( op==27 ){
      *(sqlite3_vfs**)pArg = sqlite3PagerVfs(pPager);
      rc = 0;
    }else if( op==28 ){
      *(sqlite3_file**)pArg = sqlite3PagerJrnlFile(pPager);
      rc = 0;
    }else if( op==35 ){
      *(unsigned int*)pArg = sqlite3PagerDataVersion(pPager);
      rc = 0;
    }else{
      rc = sqlite3OsFileControl(fd, op, pArg);
    }
    sqlite3BtreeLeave(pBtree);
  }
  sqlite3_mutex_leave(db->mutex);
  return rc;
}




 int sqlite3_test_control(int op, ...){
  int rc = 0;



  va_list ap;
  ( ap = (va_list)( &(op) ) + ( (sizeof(op) + sizeof(int) - 1) & ~(sizeof(int) - 1) ) );
  switch( op ){




    case 5: {
      sqlite3PrngSaveState();
      break;
    }






    case 6: {
      sqlite3PrngRestoreState();
      break;
    }
# 160086 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 28: {
      int x = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      int y;
      sqlite3 *db = ( *(sqlite3* *)((ap += ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      ((void)0);
      if( db && (y = db->aDb[0].pSchema->schema_cookie)!=0 ){ x = y; }
      sqlite3Config.iPrngSeed = x;
      sqlite3_randomness(0,0);
      break;
    }
# 160105 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 8: {
      int sz = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      int *aProg = ( *(int* *)((ap += ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      rc = sqlite3BitvecBuiltinTest(sz, aProg);
      break;
    }
# 160123 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 9: {




      typedef int(*TESTCALLBACKFUNC_t)(int);
      sqlite3Config.xTestCallback = ( *(TESTCALLBACKFUNC_t *)((ap += ( (sizeof(TESTCALLBACKFUNC_t) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(TESTCALLBACKFUNC_t) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      rc = sqlite3FaultSim(0);
      break;
    }







    case 10: {
      typedef void (*void_function)(void);
      void_function xBenignBegin;
      void_function xBenignEnd;
      xBenignBegin = ( *(void_function *)((ap += ( (sizeof(void_function) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(void_function) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      xBenignEnd = ( *(void_function *)((ap += ( (sizeof(void_function) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(void_function) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);
      break;
    }
# 160162 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 11: {
      rc = sqlite3PendingByte;

      {
        unsigned int newVal = ( *(unsigned int *)((ap += ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(unsigned int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
        if( newVal ) sqlite3PendingByte = newVal;
      }

      break;
    }
# 160184 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 12: {
      volatile int x = 0;
      ((void)0);
      rc = x;
      break;
    }
# 160219 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 13: {
      int x = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      rc = x ? (x) : 0;
      break;
    }
# 160236 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 22: {
      rc = 1234*100 + 1*10 + 0;
      break;
    }






    case 14: {
      sqlite3 *db = ( *(sqlite3* *)((ap += ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      int x = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3_mutex_enter(db->mutex);
      sqlite3BtreeSetPageSize(db->aDb[0].pBt, 0, x, 0);
      sqlite3_mutex_leave(db->mutex);
      break;
    }
# 160264 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 15: {
      sqlite3 *db = ( *(sqlite3* *)((ap += ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      db->dbOptFlags = (u16)(( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ) & 0xffff);
      break;
    }






    case 18: {
      sqlite3Config.bLocaltimeFault = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
# 160287 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 17: {
      sqlite3Config.bInternalFunctions = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }
# 160300 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 20: {
      sqlite3Config.neverCorrupt = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }







    case 29: {
      sqlite3Config.bExtraSchemaChecks = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }






    case 19: {
      sqlite3Config.iOnceResetThreshold = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }






    case 21: {






      break;
    }


    case 24: {
      sqlite3 *db = ( *(sqlite3* *)((ap += ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      db->nMaxSorterMmap = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      break;
    }






    case 23: {
      if( sqlite3Config.isInit==0 ) rc = 1;
      break;
    }
# 160374 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 25: {
      sqlite3 *db = ( *(sqlite3* *)((ap += ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3_mutex_enter(db->mutex);
      db->init.iDb = sqlite3FindDbName(db, ( *(const char* *)((ap += ( (sizeof(const char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(const char*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) ));
      db->init.busy = db->init.imposterTable = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      db->init.newTnum = ( *(int *)((ap += ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(int) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      if( db->init.busy==0 && db->init.newTnum>0 ){
        sqlite3ResetAllSchemasOfConnection(db);
      }
      sqlite3_mutex_leave(db->mutex);
      break;
    }
# 160413 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
    case 27: {
      sqlite3_context *pCtx = ( *(sqlite3_context* *)((ap += ( (sizeof(sqlite3_context*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) - ( (sizeof(sqlite3_context*) + sizeof(int) - 1) & ~(sizeof(int) - 1) )) );
      sqlite3ResultIntReal(pCtx);
      break;
    }
  }
  ( ap = (va_list)0 );

  return rc;
}
# 160435 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_uri_parameter(const char *zFilename, const char *zParam){
  if( zFilename==0 || zParam==0 ) return 0;
  zFilename += sqlite3Strlen30(zFilename) + 1;
  while( zFilename[0] ){
    int x = strcmp(zFilename, zParam);
    zFilename += sqlite3Strlen30(zFilename) + 1;
    if( x==0 ) return zFilename;
    zFilename += sqlite3Strlen30(zFilename) + 1;
  }
  return 0;
}




 int sqlite3_uri_boolean(const char *zFilename, const char *zParam, int bDflt){
  const char *z = sqlite3_uri_parameter(zFilename, zParam);
  bDflt = bDflt!=0;
  return z ? sqlite3GetBoolean(z, bDflt) : bDflt;
}




 sqlite3_int64 sqlite3_uri_int64(
  const char *zFilename,
  const char *zParam,
  sqlite3_int64 bDflt
){
  const char *z = sqlite3_uri_parameter(zFilename, zParam);
  sqlite3_int64 v;
  if( z && sqlite3DecOrHexToI64(z, &v)==0 ){
    bDflt = v;
  }
  return bDflt;
}




static Btree *sqlite3DbNameToBtree(sqlite3 *db, const char *zDbName){
  int iDb = zDbName ? sqlite3FindDbName(db, zDbName) : 0;
  return iDb<0 ? 0 : db->aDb[iDb].pBt;
}





 const char *sqlite3_db_filename(sqlite3 *db, const char *zDbName){
  Btree *pBt;






  pBt = sqlite3DbNameToBtree(db, zDbName);
  return pBt ? sqlite3BtreeGetFilename(pBt) : 0;
}





 int sqlite3_db_readonly(sqlite3 *db, const char *zDbName){
  Btree *pBt;






  pBt = sqlite3DbNameToBtree(db, zDbName);
  return pBt ? sqlite3BtreeIsReadonly(pBt) : -1;
}
# 160653 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 int sqlite3_compileoption_used(const char *zOptName){
  int i, n;
  int nOpt;
  const char **azCompileOpt;
# 160665 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
  azCompileOpt = sqlite3CompileOptions(&nOpt);

  if( sqlite3_strnicmp(zOptName, "SQLITE_", 7)==0 ) zOptName += 7;
  n = sqlite3Strlen30(zOptName);



  for(i=0; i<nOpt; i++){
    if( sqlite3_strnicmp(zOptName, azCompileOpt[i], n)==0
     && sqlite3IsIdChar((unsigned char)azCompileOpt[i][n])==0
    ){
      return 1;
    }
  }
  return 0;
}





 const char *sqlite3_compileoption_get(int N){
  int nOpt;
  const char **azCompileOpt;
  azCompileOpt = sqlite3CompileOptions(&nOpt);
  if( N>=0 && N<nOpt ){
    return azCompileOpt[N];
  }
  return 0;
}
# 161340 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
#define _FTSINT_H 
# 225061 "/Users/tamofplease/Workspace/research/docker-exp/workspace/mimikatz/modules/sqlite3.c"
 const char *sqlite3_sourceid(void){ return "2019-10-10 20:19:45 18db032d058f1436ce3dea84081f4ee5a0f2259ad97301d43c426bc7f3df1b0b"; }
