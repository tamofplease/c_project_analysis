# 0 "project/radare2/libr/util/regex/engine.c"
# 0 "<built-in>"
#define __STDC__ 1
# 0 "<built-in>"
#define __STDC_VERSION__ 201710L
# 0 "<built-in>"
#define __STDC_UTF_16__ 1
# 0 "<built-in>"
#define __STDC_UTF_32__ 1
# 0 "<built-in>"
#define __STDC_HOSTED__ 1
# 0 "<built-in>"
#define __GNUC__ 11
# 0 "<built-in>"
#define __GNUC_MINOR__ 2
# 0 "<built-in>"
#define __GNUC_PATCHLEVEL__ 0
# 0 "<built-in>"
#define __VERSION__ "11.2.0"
# 0 "<built-in>"
#define __ATOMIC_RELAXED 0
# 0 "<built-in>"
#define __ATOMIC_SEQ_CST 5
# 0 "<built-in>"
#define __ATOMIC_ACQUIRE 2
# 0 "<built-in>"
#define __ATOMIC_RELEASE 3
# 0 "<built-in>"
#define __ATOMIC_ACQ_REL 4
# 0 "<built-in>"
#define __ATOMIC_CONSUME 1
# 0 "<built-in>"
#define __pic__ 2
# 0 "<built-in>"
#define __PIC__ 2
# 0 "<built-in>"
#define __FINITE_MATH_ONLY__ 0
# 0 "<built-in>"
#define _LP64 1
# 0 "<built-in>"
#define __LP64__ 1
# 0 "<built-in>"
#define __SIZEOF_INT__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_SHORT__ 2
# 0 "<built-in>"
#define __SIZEOF_FLOAT__ 4
# 0 "<built-in>"
#define __SIZEOF_DOUBLE__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_DOUBLE__ 16
# 0 "<built-in>"
#define __SIZEOF_SIZE_T__ 8
# 0 "<built-in>"
#define __CHAR_BIT__ 8
# 0 "<built-in>"
#define __BIGGEST_ALIGNMENT__ 16
# 0 "<built-in>"
#define __ORDER_LITTLE_ENDIAN__ 1234
# 0 "<built-in>"
#define __ORDER_BIG_ENDIAN__ 4321
# 0 "<built-in>"
#define __ORDER_PDP_ENDIAN__ 3412
# 0 "<built-in>"
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __SIZEOF_POINTER__ 8
# 0 "<built-in>"
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
# 0 "<built-in>"
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
# 0 "<built-in>"
#define __SIZE_TYPE__ long unsigned int
# 0 "<built-in>"
#define __PTRDIFF_TYPE__ long int
# 0 "<built-in>"
#define __WCHAR_TYPE__ int
# 0 "<built-in>"
#define __WINT_TYPE__ int
# 0 "<built-in>"
#define __INTMAX_TYPE__ long int
# 0 "<built-in>"
#define __UINTMAX_TYPE__ long unsigned int
# 0 "<built-in>"
#define __CHAR16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __CHAR32_TYPE__ unsigned int
# 0 "<built-in>"
#define __SIG_ATOMIC_TYPE__ int
# 0 "<built-in>"
#define __INT8_TYPE__ signed char
# 0 "<built-in>"
#define __INT16_TYPE__ short int
# 0 "<built-in>"
#define __INT32_TYPE__ int
# 0 "<built-in>"
#define __INT64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_LEAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_LEAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_LEAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_LEAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_LEAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_LEAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_LEAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_LEAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_FAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_FAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_FAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_FAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_FAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_FAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INTPTR_TYPE__ long int
# 0 "<built-in>"
#define __UINTPTR_TYPE__ long unsigned int
# 0 "<built-in>"
#define __GXX_ABI_VERSION 1016
# 0 "<built-in>"
#define __SCHAR_MAX__ 0x7f
# 0 "<built-in>"
#define __SHRT_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __LONG_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __WCHAR_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
# 0 "<built-in>"
#define __WINT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WINT_MIN__ (-__WINT_MAX__ - 1)
# 0 "<built-in>"
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __SIZE_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __SCHAR_WIDTH__ 8
# 0 "<built-in>"
#define __SHRT_WIDTH__ 16
# 0 "<built-in>"
#define __INT_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_WIDTH__ 64
# 0 "<built-in>"
#define __LONG_LONG_WIDTH__ 64
# 0 "<built-in>"
#define __WCHAR_WIDTH__ 32
# 0 "<built-in>"
#define __WINT_WIDTH__ 32
# 0 "<built-in>"
#define __PTRDIFF_WIDTH__ 64
# 0 "<built-in>"
#define __SIZE_WIDTH__ 64
# 0 "<built-in>"
#define __INTMAX_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTMAX_C(c) c ## L
# 0 "<built-in>"
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __UINTMAX_C(c) c ## UL
# 0 "<built-in>"
#define __INTMAX_WIDTH__ 64
# 0 "<built-in>"
#define __SIG_ATOMIC_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
# 0 "<built-in>"
#define __SIG_ATOMIC_WIDTH__ 32
# 0 "<built-in>"
#define __INT8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __UINT8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INT_LEAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT8_C(c) c
# 0 "<built-in>"
#define __INT_LEAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_LEAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT16_C(c) c
# 0 "<built-in>"
#define __INT_LEAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_LEAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT32_C(c) c
# 0 "<built-in>"
#define __INT_LEAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT64_C(c) c ## LL
# 0 "<built-in>"
#define __INT_LEAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_LEAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT8_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT16_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT32_C(c) c ## U
# 0 "<built-in>"
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINT64_C(c) c ## ULL
# 0 "<built-in>"
#define __INT_FAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT_FAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_FAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_FAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_FAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT_FAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_FAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT_FAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT_FAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INTPTR_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTPTR_WIDTH__ 64
# 0 "<built-in>"
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __GCC_IEC_559 2
# 0 "<built-in>"
#define __GCC_IEC_559_COMPLEX 2
# 0 "<built-in>"
#define __FLT_EVAL_METHOD__ 0
# 0 "<built-in>"
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
# 0 "<built-in>"
#define __DEC_EVAL_METHOD__ 2
# 0 "<built-in>"
#define __FLT_RADIX__ 2
# 0 "<built-in>"
#define __FLT_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT_DIG__ 6
# 0 "<built-in>"
#define __FLT_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
# 0 "<built-in>"
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
# 0 "<built-in>"
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
# 0 "<built-in>"
#define __FLT_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __DBL_MANT_DIG__ 53
# 0 "<built-in>"
#define __DBL_DIG__ 15
# 0 "<built-in>"
#define __DBL_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __DBL_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __DBL_MAX_EXP__ 1024
# 0 "<built-in>"
#define __DBL_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __DBL_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_NORM_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
# 0 "<built-in>"
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
# 0 "<built-in>"
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
# 0 "<built-in>"
#define __DBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __DBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __DBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __DBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __LDBL_MANT_DIG__ 64
# 0 "<built-in>"
#define __LDBL_DIG__ 18
# 0 "<built-in>"
#define __LDBL_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __LDBL_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __LDBL_MAX_EXP__ 16384
# 0 "<built-in>"
#define __LDBL_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
# 0 "<built-in>"
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
# 0 "<built-in>"
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
# 0 "<built-in>"
#define __LDBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __LDBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __LDBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __LDBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT32_DIG__ 6
# 0 "<built-in>"
#define __FLT32_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT32_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT32_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT32_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT32_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
# 0 "<built-in>"
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
# 0 "<built-in>"
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
# 0 "<built-in>"
#define __FLT32_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT64_DIG__ 15
# 0 "<built-in>"
#define __FLT64_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT64_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT64_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT64_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT64_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
# 0 "<built-in>"
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
# 0 "<built-in>"
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
# 0 "<built-in>"
#define __FLT64_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT128_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT128_DIG__ 33
# 0 "<built-in>"
#define __FLT128_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT128_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT128_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT128_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT128_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
# 0 "<built-in>"
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
# 0 "<built-in>"
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
# 0 "<built-in>"
#define __FLT128_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT128_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT128_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT128_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32X_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT32X_DIG__ 15
# 0 "<built-in>"
#define __FLT32X_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT32X_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT32X_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT32X_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT32X_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
# 0 "<built-in>"
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
# 0 "<built-in>"
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
# 0 "<built-in>"
#define __FLT32X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64X_MANT_DIG__ 64
# 0 "<built-in>"
#define __FLT64X_DIG__ 18
# 0 "<built-in>"
#define __FLT64X_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT64X_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT64X_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT64X_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT64X_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
# 0 "<built-in>"
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
# 0 "<built-in>"
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
# 0 "<built-in>"
#define __FLT64X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __REGISTER_PREFIX__ 
# 0 "<built-in>"
#define __USER_LABEL_PREFIX__ _
# 0 "<built-in>"
#define __GNUC_STDC_INLINE__ 1
# 0 "<built-in>"
#define __NO_INLINE__ 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
# 0 "<built-in>"
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_INT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
# 0 "<built-in>"
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
# 0 "<built-in>"
#define __HAVE_SPECULATION_SAFE_VALUE 1
# 0 "<built-in>"
#define __PRAGMA_REDEFINE_EXTNAME 1
# 0 "<built-in>"
#define __SIZEOF_INT128__ 16
# 0 "<built-in>"
#define __SIZEOF_WCHAR_T__ 4
# 0 "<built-in>"
#define __SIZEOF_WINT_T__ 4
# 0 "<built-in>"
#define __SIZEOF_PTRDIFF_T__ 8
# 0 "<built-in>"
#define __amd64 1
# 0 "<built-in>"
#define __amd64__ 1
# 0 "<built-in>"
#define __x86_64 1
# 0 "<built-in>"
#define __x86_64__ 1
# 0 "<built-in>"
#define __SIZEOF_FLOAT80__ 16
# 0 "<built-in>"
#define __SIZEOF_FLOAT128__ 16
# 0 "<built-in>"
#define __ATOMIC_HLE_ACQUIRE 65536
# 0 "<built-in>"
#define __ATOMIC_HLE_RELEASE 131072
# 0 "<built-in>"
#define __GCC_ASM_FLAG_OUTPUTS__ 1
# 0 "<built-in>"
#define __k8 1
# 0 "<built-in>"
#define __k8__ 1
# 0 "<built-in>"
#define __tune_core2__ 1
# 0 "<built-in>"
#define __code_model_small__ 1
# 0 "<built-in>"
#define __MMX__ 1
# 0 "<built-in>"
#define __SSE__ 1
# 0 "<built-in>"
#define __SSE2__ 1
# 0 "<built-in>"
#define __SSE3__ 1
# 0 "<built-in>"
#define __FXSR__ 1
# 0 "<built-in>"
#define __SSE_MATH__ 1
# 0 "<built-in>"
#define __SSE2_MATH__ 1
# 0 "<built-in>"
#define __MMX_WITH_SSE__ 1
# 0 "<built-in>"
#define __SEG_FS 1
# 0 "<built-in>"
#define __SEG_GS 1
# 0 "<built-in>"
#define __LITTLE_ENDIAN__ 1
# 0 "<built-in>"
#define __MACH__ 1
# 0 "<built-in>"
#define __APPLE__ 1
# 0 "<built-in>"
#define __APPLE_CC__ 1
# 0 "<built-in>"
#define __CONSTANT_CFSTRINGS__ 1
# 0 "<built-in>"
#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 110500
# 0 "<built-in>"
#define __strong 
# 0 "<built-in>"
#define __weak 
# 0 "<command-line>"
#define __DYNAMIC__ 1
# 1 "project/radare2/libr/util/regex/engine.c"
# 71 "project/radare2/libr/util/regex/engine.c"
struct match {
 struct re_guts *g;
 int eflags;
 RRegexMatch *pmatch;
 char *offp;
 char *beginp;
 char *endp;
 char *coldp;
 char **lastpos;
 STATEVARS;
 states st;
 states fresh;
 states tmp;
 states empty;
};

static int matcher(struct re_guts *, char *, size_t, RRegexMatch[], int);
static char *dissect(struct match *, char *, char *, sopno, sopno);
static char *backref(struct match *, char *, char *, sopno, sopno, sopno, int);
static char *fast(struct match *, char *, char *, sopno, sopno);
static char *slow(struct match *, char *, char *, sopno, sopno);
static states step(struct re_guts *, sopno, sopno, states, int, states);
#define MAX_RECURSION 100
#define BOL (OUT+1)
#define EOL (BOL+1)
#define BOLEOL (BOL+2)
#define NOTHING (BOL+3)
#define BOW (BOL+4)
#define EOW (BOL+5)
#define CODEMAX (BOL+5)
#define NONCHAR(c) ((c) > CHAR_MAX)
#define NNONCHAR (CODEMAX-CHAR_MAX)


#define SP(t,s,c) 
#define AT(t,p1,p2,s1,s2) 




static int matcher(struct re_guts *g, char *string, size_t nmatch, RRegexMatch pmatch[], int eflags) {
 char *endp;
 int i;
 struct match mv;
 struct match *m = &mv;
 char *dp;
 const sopno gf = g->firststate + 1;
 const sopno gl = g->laststate;
 char *start;
 char *stop;


 if (g->cflags & R_REGEX_NOSUB) {
  nmatch = 0;
 }
 if (eflags & R_REGEX_STARTEND && pmatch) {
  start = string + pmatch[0].rm_so;
  stop = string + pmatch[0].rm_eo;
 } else {
  start = string;
  stop = start + strlen (start);
 }
 if (start > stop) {
  return R_REGEX_INVARG;
 }


 if (g->must != NULL) {
  for (dp = start; dp < stop; dp++) {
   if (*dp == g->must[0] && stop - dp >= g->mlen && !memcmp (dp, g->must, (size_t)g->mlen)) {
    break;
   }
  }
  if (dp == stop) {
   return R_REGEX_NOMATCH;
  }
 }


 m->g = g;
 m->eflags = eflags;
 m->pmatch = NULL;
 m->lastpos = NULL;
 m->offp = string;
 m->beginp = start;
 m->endp = stop;

 if (m->g->nstates * 4 < m->g->nstates) {
  return R_REGEX_NOMATCH;
 }
 STATESETUP (m, 4);
 SETUP (m->st);
 SETUP (m->fresh);
 SETUP (m->tmp);
 SETUP (m->empty);
 CLEAR (m->empty);


 for (;;) {
  endp = fast (m, start, stop, gf, gl);
  if (!endp) {
   free (m->pmatch);
   free (m->lastpos);
   STATETEARDOWN (m);
   return R_REGEX_NOMATCH;
  }
  if (nmatch == 0 && !g->backrefs) {
   break;
  }

  if (!m->coldp) {
   break;
  }
  for (;;) {
   endp = slow (m, m->coldp, stop, gf, gl);
   if (endp || m->coldp > m->endp) {
    break;
   }
   m->coldp++;
  }
  if (nmatch == 1 && !g->backrefs)
   break;


  if (!m->pmatch) {
   if ((m->g->nsub + 1) * sizeof (RRegexMatch) < m->g->nsub) {
    return R_REGEX_ESPACE;
   }
   m->pmatch = (RRegexMatch *)malloc ((m->g->nsub + 1) *
       sizeof (RRegexMatch));
  }
  if (!m->pmatch) {
   STATETEARDOWN (m);
   return R_REGEX_ESPACE;
  }
  for (i = 1; i <= m->g->nsub; i++) {
   m->pmatch[i].rm_so = m->pmatch[i].rm_eo = -1;
  }
  if (!g->backrefs && !(m->eflags&R_REGEX_BACKR)) {
   dp = dissect (m, m->coldp, endp, gf, gl);
  } else {
   if (g->nplus > 0 && !m->lastpos) {
    if ((g->nplus + 1) * sizeof (char *) < g->nplus) {
     free (m->pmatch);
     STATETEARDOWN (m);
     return R_REGEX_ESPACE;
    }
    m->lastpos = (char **)malloc ((g->nplus+1) *
       sizeof(char *));
   }
   if (g->nplus > 0 && !m->lastpos) {
    free (m->pmatch);
    STATETEARDOWN (m);
    return R_REGEX_ESPACE;
   }
   dp = backref (m, m->coldp, endp, gf, gl, (sopno)0, 0);
  }
  if (dp) {
   break;
  }

  if (!g->backrefs) {
   break;
  }
  if (g->nplus || !m->lastpos) {
   break;
  }
  for (;;) {
   if (dp != NULL || endp <= m->coldp) {
    break;
   }
   endp = slow (m, m->coldp, endp - 1, gf, gl);
   if (!endp) {
    break;
   }


   for (i = 1; i <= m->g->nsub; i++) {
    if (m->pmatch[i].rm_so != -1) {
     break;
    }
    if (m->pmatch[i].rm_eo != -1) {
     break;
    }
   }

   dp = backref (m, m->coldp, endp, gf, gl, (sopno)0, 0);
  }
  if (dp != NULL || dp != endp) {
   break;
  }


  if (m->coldp == stop) {
   break;
  }
  start = m->coldp + 1;
 }


 if (pmatch) {
  if (nmatch > 0) {
   pmatch[0].rm_so = m->coldp - m->offp;
   pmatch[0].rm_eo = endp - m->offp;
  }
  if (nmatch > 1) {
   if (m->pmatch) {
    for (i = 1; i < nmatch; i++) {
     if (i <= m->g->nsub) {
      pmatch[i] = m->pmatch[i];
     } else {
      pmatch[i].rm_so = -1;
      pmatch[i].rm_eo = -1;
     }
    }
   }
  }
 }

 free ((char *)m->pmatch);
 free ((char *)m->lastpos);
 STATETEARDOWN (m);
 return 0;
}




static char *
dissect(struct match *m, char *start, char *stop, sopno startst, sopno stopst)
{
 int i;
 sopno ss;
 sopno es;
 char *sp;
 char *stp;
 char *rest;
 char *tail;
 sopno ssub;
 sopno esub;
 char *ssp;
 char *sep;
 char *oldssp;
 char *dp;

 ;
 sp = start;
 for (ss = startst; ss < stopst; ss = es) {

  es = ss;
  switch (OP (m->g->strip[es])) {
  case OPLUS_:
  case OQUEST_:
   es += OPND (m->g->strip[es]);
   break;
  case OCH_:
   while (OP (m->g->strip[es]) != O_CH)
    es += OPND (m->g->strip[es]);
   break;
  }
  es++;


  switch (OP (m->g->strip[ss])) {
  case OEND:
   break;
  case OCHAR:
   sp++;
   break;
  case OBOL:
  case OEOL:
  case OBOW:
  case OEOW:
   break;
  case OANY:
  case OANYOF:
   sp++;
   break;
  case OBACK_:
  case O_BACK:
   break;

  case OQUEST_:
   stp = stop;
   for (;;) {

    rest = slow(m, sp, stp, ss, es);
    if (rest) {

     tail = slow(m, rest, stop, es, stopst);
     if (tail == stop)
      break;

     stp = rest - 1;
    }
   }
   ssub = ss + 1;
   esub = es - 1;

   if (slow(m, sp, rest, ssub, esub) != NULL) {
    dp = dissect(m, sp, rest, ssub, esub);
    if (dp != rest) return NULL;
   } else if (sp != rest) return NULL;
   sp = rest;
   break;
  case OPLUS_:
   stp = stop;
   for (;;) {

    rest = slow(m, sp, stp, ss, es);
    if (rest != NULL) {

     tail = slow(m, rest, stop, es, stopst);
     if (tail == stop)
      break;

     stp = rest - 1;
    }
   }
   ssub = ss + 1;
   esub = es - 1;
   ssp = sp;
   oldssp = ssp;
   for (;;) {
    sep = slow(m, ssp, rest, ssub, esub);
    if (!sep || sep == ssp)
     break;
    oldssp = ssp;
    ssp = sep;
   }
   if (!sep) {

    sep = ssp;
    ssp = oldssp;
   }
   if (sep == rest) {
    if (slow(m, ssp, sep, ssub, esub) == rest) {
     dp = dissect(m, ssp, sep, ssub, esub);
     if (dp == sep) {
      sp = rest;
     }
    }
   }
   break;
  case OCH_:
   stp = stop;
   for (;;) {

    rest = slow(m, sp, stp, ss, es);
    if (rest) {

     tail = slow(m, rest, stop, es, stopst);
     if (tail == stop)
      break;

     stp = rest - 1;
    }
   }
   ssub = ss + 1;
   esub = ss + OPND (m->g->strip[ss]) - 1;
   if (OP (m->g->strip[esub]) != OOR1) {
    break;
   }
   for (;;) {
    if (slow (m, sp, rest, ssub, esub) == rest)
     break;

    if (OP (m->g->strip[esub]) == OOR1) {
     esub++;
     if (OP (m->g->strip[esub]) == OOR2) {
      ssub = esub + 1;
      esub += OPND (m->g->strip[esub]);
      if (OP (m->g->strip[esub]) == OOR2) {
       esub--;
      } else {
       if (OP (m->g->strip[esub]) != O_CH) {
        break;
       }
      }
     }
    }
   }
   dp = dissect(m, sp, rest, ssub, esub);
   if (dp == rest) {
    sp = rest;
   }
   break;
  case O_PLUS:
  case O_QUEST:
  case OOR1:
  case OOR2:
  case O_CH:
   break;
  case OLPAREN:
   i = OPND (m->g->strip[ss]);
   if (i > 0 && i <= m->g->nsub) {
    m->pmatch[i].rm_so = sp - m->offp;
   }
   break;
  case ORPAREN:
   i = OPND (m->g->strip[ss]);
   if (i > 0 && i <= m->g->nsub) {
    m->pmatch[i].rm_eo = sp - m->offp;
   }
   break;
  default:
   break;
  }
 }

 return (sp == stop)? sp: NULL;
}




static char *
backref(struct match *m, char *start, char *stop, sopno startst, sopno stopst,
    sopno lev, int rec)
{
 int i;
 sopno ss;
 char *sp;
 sopno ssub;
 sopno esub;
 char *ssp;
 char *dp;
 size_t len;
 int hard;
 sop s;
 ut64 offsave;
 cset *cs;

 ;
 sp = start;


 hard = 0;
 for (ss = startst; !hard && ss < stopst; ss++)
  switch (OP (s = m->g->strip[ss])) {
  case OCHAR:
   if (sp == stop || *sp++ != (char)OPND (s))
    return NULL;
   break;
  case OANY:
   if (sp == stop)
    return NULL;
   sp++;
   break;
  case OANYOF:
   cs = &m->g->sets[OPND (s)];
   if (sp == stop || !CHIN (cs, *sp++))
    return NULL;
   break;
  case OBOL:
   if ( (sp == m->beginp && !(m->eflags&R_REGEX_NOTBOL)) ||
     (sp < m->endp && *(sp-1) == '\n' &&
      (m->g->cflags&R_REGEX_NEWLINE)) )
    { }
   else
    return NULL;
   break;
  case OEOL:
   if ( (sp == m->endp && !(m->eflags&R_REGEX_NOTEOL)) ||
     (sp < m->endp && *sp == '\n' &&
      (m->g->cflags&R_REGEX_NEWLINE)) )
    { }
   else
    return NULL;
   break;
  case OBOW:
   if (( (sp == m->beginp && !(m->eflags&R_REGEX_NOTBOL)) ||
     (sp < m->endp && *(sp-1) == '\n' &&
      (m->g->cflags&R_REGEX_NEWLINE)) ||
     (sp > m->beginp && !ISWORD ((unsigned char)*(sp-1))) ) &&
     (sp < m->endp && ISWORD ((unsigned char)*sp)) )
    { }
   else
    return NULL;
   break;
  case OEOW:
   if (( (sp == m->endp && !(m->eflags&R_REGEX_NOTEOL)) ||
     (sp < m->endp && *sp == '\n' &&
      (m->g->cflags&R_REGEX_NEWLINE)) ||
     (sp < m->endp && !ISWORD ((unsigned char)*sp)) ) &&
     (sp > m->beginp && ISWORD ((unsigned char)*(sp-1))) )
    { }
   else
    return NULL;
   break;
  case O_QUEST:
   break;
  case OOR1:
   ss++;
   s = m->g->strip[ss];
   do {
    if (OP (s) == OOR2) {
     ss += OPND (s);
    }
   } while (OP (s = m->g->strip[ss]) != O_CH);

   break;
  default:
   hard = 1;
   break;
  }
 if (!hard) {
  return (sp == stop)? sp: NULL;
 }
 ss--;


 ;
 s = m->g->strip[ss];
 switch (OP (s)) {
 case OBACK_:
  i = OPND (s);
  if (i > 0 && i <= m->g->nsub) {
   if (m->pmatch[i].rm_eo == -1) {
    return NULL;
   }
  }
  if (m->pmatch[i].rm_so != -1) {
   len = m->pmatch[i].rm_eo - m->pmatch[i].rm_so;
   if (len == 0 && rec++ > 100)
    return NULL;
   if (stop - m->beginp >= len) {
    if (sp > stop - len) {
     return NULL;
    }
   }
   ssp = m->offp + m->pmatch[i].rm_so;
   if (memcmp (sp, ssp, len) != 0)
    return NULL;
   while (m->g->strip[ss] != SOP (O_BACK, i))
    ss++;
   return backref (m, sp+len, stop, ss + 1, stopst, lev, rec);
  }
  break;
 case OQUEST_:
  dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
  if (dp) {
   return dp;
  }
  return backref (m, sp, stop, ss + OPND (s) + 1, stopst, lev, rec);
 case OPLUS_:
  if (m->lastpos && (lev + 1 <= m->g->nplus)) {
   m->lastpos[lev+1] = sp;
   return backref(m, sp, stop, ss+1, stopst, lev+1, rec);
  }
  break;
 case O_PLUS:
  if (sp == m->lastpos[lev])
   return backref(m, sp, stop, ss+1, stopst, lev-1, rec);

  m->lastpos[lev] = sp;
  dp = backref(m, sp, stop, ss-OPND (s)+1, stopst, lev, rec);
  return dp? dp: backref(m, sp, stop, ss+1, stopst, lev-1, rec);
 case OCH_:
  ssub = ss + 1;
  esub = ss + OPND (s) - 1;
  if (OP (m->g->strip[esub]) != OOR1) {
   break;
  }
  for (;;) {
   dp = backref(m, sp, stop, ssub, esub, lev, rec);
   if (dp != NULL)
    return dp;

   if (OP (m->g->strip[esub]) == O_CH)
    return NULL;
   esub++;
   if (OP (m->g->strip[esub]) != OOR2) {
    break;
   }
   ssub = esub + 1;
   esub += OPND (m->g->strip[esub]);
   if (OP (m->g->strip[esub]) == OOR2)
    esub--;
   else
    if (OP (m->g->strip[esub]) != O_CH) {
     break;
    }
  }
  break;
 case OLPAREN:
  i = OPND (s);
  if (i > 0 && i <= m->g->nsub) {
   offsave = m->pmatch[i].rm_so;
   m->pmatch[i].rm_so = sp - m->offp;
   dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
   if (dp != NULL)
    return(dp);
   m->pmatch[i].rm_so = offsave;
   return(NULL);
  }
  break;
 case ORPAREN:
  i = OPND (s);
  if (i > 0 && i <= m->g->nsub) {
   offsave = m->pmatch[i].rm_eo;
   m->pmatch[i].rm_eo = sp - m->offp;
   dp = backref(m, sp, stop, ss+1, stopst, lev, rec);
   if (dp) {
    return dp;
   }
   m->pmatch[i].rm_eo = offsave;
   return NULL;
  }
  break;
 default:
  break;
 }


 return NULL;
}




static char *
fast(struct match *m, char *start, char *stop, sopno startst, sopno stopst)
{
 states st = m->st;
 states fresh = m->fresh;
 states tmp = m->tmp;
 char *p = start;
 int c = (start == m->beginp) ? OUT : *(start-1);
 int lastc;
 int flagch;
 int i;
 char *coldp;

 CLEAR (st);
 SET1 (st, startst);
 st = step (m->g, startst, stopst, st, ((OUT+1)+3), st);
 ASSIGN (fresh, st);
 ;
 coldp = NULL;
 for (;;) {

  lastc = c;
  c = (p == m->endp) ? OUT : *p;
  if (st==fresh)
   coldp = p;


  flagch = '\0';
  i = 0;
  if ( (lastc == '\n' && m->g->cflags&R_REGEX_NEWLINE) ||
    (lastc == OUT && !(m->eflags&R_REGEX_NOTBOL)) ) {
   flagch = (OUT+1);
   i = m->g->nbol;
  }
  if ( (c == '\n' && m->g->cflags&R_REGEX_NEWLINE) ||
    (c == OUT && !(m->eflags&R_REGEX_NOTEOL)) ) {
   flagch = (flagch == (OUT+1)) ? ((OUT+1)+2) : ((OUT+1)+1);
   i += m->g->neol;
  }
  if (i != 0) {
   for (; i > 0; i--) {
    st = step (m->g, startst, stopst, st, flagch, st);
   }
   ;
  }


  if ( (flagch == (OUT+1) || (lastc != OUT && !ISWORD (lastc))) &&
     (c != OUT && ISWORD(c)) ) {
   flagch = ((OUT+1)+4);
  }
  if ( (lastc != OUT && ISWORD (lastc)) &&
    (flagch == ((OUT+1)+1) || (c != OUT && !ISWORD (c))) ) {
   flagch = ((OUT+1)+5);
  }
  if (flagch == ((OUT+1)+4) || flagch == ((OUT+1)+5)) {
   st = step (m->g, startst, stopst, st, flagch, st);
   ;
  }


  if (ISSET (st, stopst) || p == stop) {
   break;
  }


  ASSIGN (tmp, st);
  ASSIGN (st, fresh);
  if (c == OUT) {
   break;
  }
  st = step (m->g, startst, stopst, tmp, c, st);
  ;
  if (!EQ (step (m->g, startst, stopst, st, ((OUT+1)+3), st), st)) {
   break;
  }
  p++;
 }

 if (coldp) {
  m->coldp = coldp;
  if (ISSET (st, stopst))
   return p + 1;
 }
 return NULL;
}




static char *
slow(struct match *m, char *start, char *stop, sopno startst, sopno stopst)
{
 states st = m->st;
 states empty = m->empty;
 states tmp = m->tmp;
 char *p = start;
 int c = (start == m->beginp) ? OUT : *(start-1);
 int lastc;
 int flagch;
 int i;
 char *matchp;

 ;
 CLEAR (st);
 SET1 (st, startst);
 ;
 st = step (m->g, startst, stopst, st, ((OUT+1)+3), st);
 matchp = NULL;
 for (;;) {

  lastc = c;
  c = (p == m->endp) ? OUT : *p;


  flagch = '\0';
  i = 0;
  if ( (lastc == '\n' && m->g->cflags&R_REGEX_NEWLINE) ||
    (lastc == OUT && !(m->eflags&R_REGEX_NOTBOL)) ) {
   flagch = (OUT+1);
   i = m->g->nbol;
  }
  if ( (c == '\n' && m->g->cflags&R_REGEX_NEWLINE) ||
    (c == OUT && !(m->eflags&R_REGEX_NOTEOL)) ) {
   flagch = (flagch == (OUT+1)) ? ((OUT+1)+2) : ((OUT+1)+1);
   i += m->g->neol;
  }
  if (i != 0) {
   for (; i > 0; i--) {
    st = step (m->g, startst, stopst, st, flagch, st);
   }
   ;
  }


  if ( (flagch == (OUT+1) || (lastc != OUT && !ISWORD (lastc))) &&
     (c != OUT && ISWORD (c)) ) {
   flagch = ((OUT+1)+4);
  }
  if ( (lastc != OUT && ISWORD (lastc)) &&
    (flagch == ((OUT+1)+1) || (c != OUT && !ISWORD (c))) ) {
   flagch = ((OUT+1)+5);
  }
  if (flagch == ((OUT+1)+4) || flagch == ((OUT+1)+5)) {
   st = step (m->g, startst, stopst, st, flagch, st);
   ;
  }


  if (ISSET (st, stopst)) {
   matchp = p;
  }
  if (EQ (st, empty) || p == stop) {
   break;
  }


  ASSIGN (tmp, st);
  ASSIGN (st, empty);
  if (c == OUT) {
   break;
  }
  st = step (m->g, startst, stopst, tmp, c, st);
  ;
  if (!EQ (step (m->g, startst, stopst, st, ((OUT+1)+3), st), st)) {
   break;
  }
  p++;
 }

 return matchp;
}





static states
step(struct re_guts *g,
    sopno start,
    sopno stop,
    states bef,
    int ch,
    states aft)
{
 cset *cs;
 sop s;
 sopno pc;
 onestate here;
 sopno look;
 int i;

 for (pc = start, INIT (here, pc); pc != stop; pc++, INC (here)) {
  s = g->strip[pc];
  switch (OP (s)) {
  case OEND:
   break;
  case OCHAR:

   if (!((ch) > CHAR_MAX) || ch != (char)OPND (s)) {
    if (ch == (char)OPND (s)) {
     FWD (aft, bef, 1);
    }
   }
   break;
  case OBOL:
   if (ch == (OUT+1) || ch == ((OUT+1)+2)) {
    FWD (aft, bef, 1);
   }
   break;
  case OEOL:
   if (ch == ((OUT+1)+1) || ch == ((OUT+1)+2)) {
    FWD (aft, bef, 1);
   }
   break;
  case OBOW:
   if (ch == ((OUT+1)+4)) {
    FWD (aft, bef, 1);
   }
   break;
  case OEOW:
   if (ch == ((OUT+1)+5)) {
    FWD (aft, bef, 1);
   }
   break;
  case OANY:
   if (!((ch) > CHAR_MAX)) {
    FWD (aft, bef, 1);
   }
   break;
  case OANYOF:
   cs = &g->sets[OPND (s)];
   if (!((ch) > CHAR_MAX) && CHIN (cs, ch))
    FWD (aft, bef, 1);
   break;
  case OBACK_:
  case O_BACK:
   FWD (aft, aft, 1);
   break;
  case OPLUS_:
   FWD (aft, aft, 1);
   break;
  case O_PLUS:
   FWD (aft, aft, 1);
   i = ISSETBACK (aft, OPND (s));
   BACK (aft, aft, OPND (s));
   if (!i && ISSETBACK (aft, OPND (s))) {

    pc -= OPND (s) + 1;
    INIT (here, pc);
   }
   break;
  case OQUEST_:
   FWD (aft, aft, 1);
   FWD (aft, aft, OPND (s));
   break;
  case O_QUEST:
   FWD (aft, aft, 1);
   break;
  case OLPAREN:
  case ORPAREN:
   FWD (aft, aft, 1);
   break;
  case OCH_:
   FWD (aft, aft, 1);
   if ((OP (g->strip[pc + OPND (s)]) != OOR2)) {
    break;
   }
   FWD (aft, aft, OPND (s));
   break;
  case OOR1:
   if (ISSTATEIN (aft, here)) {
    for (look = 1;
      OP (s = g->strip[pc+look]) != O_CH;
      look += OPND (s)) {
       if (OP (s) != OOR2) {
        break;
       }
      }
    FWD (aft, aft, look);
   }
   break;
  case OOR2:
   FWD (aft, aft, 1);
   if (OP (g->strip[pc+OPND (s)]) != O_CH) {
    if (OP (g->strip[pc+OPND (s)]) == OOR2) {
     FWD (aft, aft, OPND (s));
    }
   }
   break;
  case O_CH:
   FWD (aft, aft, 1);
   break;
  default:
   eprintf ("ops in regex.c\n");
   break;
  }
 }

 return aft;
}

#undef matcher
#undef fast
#undef slow
#undef dissect
#undef backref
#undef step
#undef print
#undef at
#undef match
#undef nope
