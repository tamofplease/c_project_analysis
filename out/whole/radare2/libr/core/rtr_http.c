# 0 "project/radare2/libr/core/rtr_http.c"
# 0 "<built-in>"
#define __STDC__ 1
# 0 "<built-in>"
#define __STDC_VERSION__ 201710L
# 0 "<built-in>"
#define __STDC_UTF_16__ 1
# 0 "<built-in>"
#define __STDC_UTF_32__ 1
# 0 "<built-in>"
#define __STDC_HOSTED__ 1
# 0 "<built-in>"
#define __GNUC__ 11
# 0 "<built-in>"
#define __GNUC_MINOR__ 2
# 0 "<built-in>"
#define __GNUC_PATCHLEVEL__ 0
# 0 "<built-in>"
#define __VERSION__ "11.2.0"
# 0 "<built-in>"
#define __ATOMIC_RELAXED 0
# 0 "<built-in>"
#define __ATOMIC_SEQ_CST 5
# 0 "<built-in>"
#define __ATOMIC_ACQUIRE 2
# 0 "<built-in>"
#define __ATOMIC_RELEASE 3
# 0 "<built-in>"
#define __ATOMIC_ACQ_REL 4
# 0 "<built-in>"
#define __ATOMIC_CONSUME 1
# 0 "<built-in>"
#define __pic__ 2
# 0 "<built-in>"
#define __PIC__ 2
# 0 "<built-in>"
#define __FINITE_MATH_ONLY__ 0
# 0 "<built-in>"
#define _LP64 1
# 0 "<built-in>"
#define __LP64__ 1
# 0 "<built-in>"
#define __SIZEOF_INT__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_SHORT__ 2
# 0 "<built-in>"
#define __SIZEOF_FLOAT__ 4
# 0 "<built-in>"
#define __SIZEOF_DOUBLE__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_DOUBLE__ 16
# 0 "<built-in>"
#define __SIZEOF_SIZE_T__ 8
# 0 "<built-in>"
#define __CHAR_BIT__ 8
# 0 "<built-in>"
#define __BIGGEST_ALIGNMENT__ 16
# 0 "<built-in>"
#define __ORDER_LITTLE_ENDIAN__ 1234
# 0 "<built-in>"
#define __ORDER_BIG_ENDIAN__ 4321
# 0 "<built-in>"
#define __ORDER_PDP_ENDIAN__ 3412
# 0 "<built-in>"
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __SIZEOF_POINTER__ 8
# 0 "<built-in>"
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
# 0 "<built-in>"
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
# 0 "<built-in>"
#define __SIZE_TYPE__ long unsigned int
# 0 "<built-in>"
#define __PTRDIFF_TYPE__ long int
# 0 "<built-in>"
#define __WCHAR_TYPE__ int
# 0 "<built-in>"
#define __WINT_TYPE__ int
# 0 "<built-in>"
#define __INTMAX_TYPE__ long int
# 0 "<built-in>"
#define __UINTMAX_TYPE__ long unsigned int
# 0 "<built-in>"
#define __CHAR16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __CHAR32_TYPE__ unsigned int
# 0 "<built-in>"
#define __SIG_ATOMIC_TYPE__ int
# 0 "<built-in>"
#define __INT8_TYPE__ signed char
# 0 "<built-in>"
#define __INT16_TYPE__ short int
# 0 "<built-in>"
#define __INT32_TYPE__ int
# 0 "<built-in>"
#define __INT64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_LEAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_LEAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_LEAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_LEAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_LEAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_LEAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_LEAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_LEAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_FAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_FAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_FAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_FAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_FAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_FAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INTPTR_TYPE__ long int
# 0 "<built-in>"
#define __UINTPTR_TYPE__ long unsigned int
# 0 "<built-in>"
#define __GXX_ABI_VERSION 1016
# 0 "<built-in>"
#define __SCHAR_MAX__ 0x7f
# 0 "<built-in>"
#define __SHRT_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __LONG_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __WCHAR_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
# 0 "<built-in>"
#define __WINT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WINT_MIN__ (-__WINT_MAX__ - 1)
# 0 "<built-in>"
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __SIZE_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __SCHAR_WIDTH__ 8
# 0 "<built-in>"
#define __SHRT_WIDTH__ 16
# 0 "<built-in>"
#define __INT_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_WIDTH__ 64
# 0 "<built-in>"
#define __LONG_LONG_WIDTH__ 64
# 0 "<built-in>"
#define __WCHAR_WIDTH__ 32
# 0 "<built-in>"
#define __WINT_WIDTH__ 32
# 0 "<built-in>"
#define __PTRDIFF_WIDTH__ 64
# 0 "<built-in>"
#define __SIZE_WIDTH__ 64
# 0 "<built-in>"
#define __INTMAX_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTMAX_C(c) c ## L
# 0 "<built-in>"
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __UINTMAX_C(c) c ## UL
# 0 "<built-in>"
#define __INTMAX_WIDTH__ 64
# 0 "<built-in>"
#define __SIG_ATOMIC_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
# 0 "<built-in>"
#define __SIG_ATOMIC_WIDTH__ 32
# 0 "<built-in>"
#define __INT8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __UINT8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INT_LEAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT8_C(c) c
# 0 "<built-in>"
#define __INT_LEAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_LEAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT16_C(c) c
# 0 "<built-in>"
#define __INT_LEAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_LEAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT32_C(c) c
# 0 "<built-in>"
#define __INT_LEAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT64_C(c) c ## LL
# 0 "<built-in>"
#define __INT_LEAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_LEAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT8_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT16_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT32_C(c) c ## U
# 0 "<built-in>"
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINT64_C(c) c ## ULL
# 0 "<built-in>"
#define __INT_FAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT_FAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_FAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_FAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_FAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT_FAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_FAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT_FAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT_FAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INTPTR_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTPTR_WIDTH__ 64
# 0 "<built-in>"
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __GCC_IEC_559 2
# 0 "<built-in>"
#define __GCC_IEC_559_COMPLEX 2
# 0 "<built-in>"
#define __FLT_EVAL_METHOD__ 0
# 0 "<built-in>"
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
# 0 "<built-in>"
#define __DEC_EVAL_METHOD__ 2
# 0 "<built-in>"
#define __FLT_RADIX__ 2
# 0 "<built-in>"
#define __FLT_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT_DIG__ 6
# 0 "<built-in>"
#define __FLT_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
# 0 "<built-in>"
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
# 0 "<built-in>"
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
# 0 "<built-in>"
#define __FLT_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __DBL_MANT_DIG__ 53
# 0 "<built-in>"
#define __DBL_DIG__ 15
# 0 "<built-in>"
#define __DBL_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __DBL_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __DBL_MAX_EXP__ 1024
# 0 "<built-in>"
#define __DBL_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __DBL_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_NORM_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
# 0 "<built-in>"
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
# 0 "<built-in>"
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
# 0 "<built-in>"
#define __DBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __DBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __DBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __DBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __LDBL_MANT_DIG__ 64
# 0 "<built-in>"
#define __LDBL_DIG__ 18
# 0 "<built-in>"
#define __LDBL_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __LDBL_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __LDBL_MAX_EXP__ 16384
# 0 "<built-in>"
#define __LDBL_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
# 0 "<built-in>"
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
# 0 "<built-in>"
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
# 0 "<built-in>"
#define __LDBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __LDBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __LDBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __LDBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT32_DIG__ 6
# 0 "<built-in>"
#define __FLT32_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT32_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT32_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT32_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT32_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
# 0 "<built-in>"
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
# 0 "<built-in>"
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
# 0 "<built-in>"
#define __FLT32_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT64_DIG__ 15
# 0 "<built-in>"
#define __FLT64_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT64_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT64_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT64_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT64_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
# 0 "<built-in>"
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
# 0 "<built-in>"
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
# 0 "<built-in>"
#define __FLT64_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT128_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT128_DIG__ 33
# 0 "<built-in>"
#define __FLT128_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT128_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT128_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT128_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT128_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
# 0 "<built-in>"
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
# 0 "<built-in>"
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
# 0 "<built-in>"
#define __FLT128_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT128_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT128_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT128_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32X_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT32X_DIG__ 15
# 0 "<built-in>"
#define __FLT32X_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT32X_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT32X_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT32X_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT32X_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
# 0 "<built-in>"
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
# 0 "<built-in>"
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
# 0 "<built-in>"
#define __FLT32X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64X_MANT_DIG__ 64
# 0 "<built-in>"
#define __FLT64X_DIG__ 18
# 0 "<built-in>"
#define __FLT64X_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT64X_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT64X_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT64X_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT64X_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
# 0 "<built-in>"
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
# 0 "<built-in>"
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
# 0 "<built-in>"
#define __FLT64X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __REGISTER_PREFIX__ 
# 0 "<built-in>"
#define __USER_LABEL_PREFIX__ _
# 0 "<built-in>"
#define __GNUC_STDC_INLINE__ 1
# 0 "<built-in>"
#define __NO_INLINE__ 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
# 0 "<built-in>"
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_INT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
# 0 "<built-in>"
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
# 0 "<built-in>"
#define __HAVE_SPECULATION_SAFE_VALUE 1
# 0 "<built-in>"
#define __PRAGMA_REDEFINE_EXTNAME 1
# 0 "<built-in>"
#define __SIZEOF_INT128__ 16
# 0 "<built-in>"
#define __SIZEOF_WCHAR_T__ 4
# 0 "<built-in>"
#define __SIZEOF_WINT_T__ 4
# 0 "<built-in>"
#define __SIZEOF_PTRDIFF_T__ 8
# 0 "<built-in>"
#define __amd64 1
# 0 "<built-in>"
#define __amd64__ 1
# 0 "<built-in>"
#define __x86_64 1
# 0 "<built-in>"
#define __x86_64__ 1
# 0 "<built-in>"
#define __SIZEOF_FLOAT80__ 16
# 0 "<built-in>"
#define __SIZEOF_FLOAT128__ 16
# 0 "<built-in>"
#define __ATOMIC_HLE_ACQUIRE 65536
# 0 "<built-in>"
#define __ATOMIC_HLE_RELEASE 131072
# 0 "<built-in>"
#define __GCC_ASM_FLAG_OUTPUTS__ 1
# 0 "<built-in>"
#define __k8 1
# 0 "<built-in>"
#define __k8__ 1
# 0 "<built-in>"
#define __tune_core2__ 1
# 0 "<built-in>"
#define __code_model_small__ 1
# 0 "<built-in>"
#define __MMX__ 1
# 0 "<built-in>"
#define __SSE__ 1
# 0 "<built-in>"
#define __SSE2__ 1
# 0 "<built-in>"
#define __SSE3__ 1
# 0 "<built-in>"
#define __FXSR__ 1
# 0 "<built-in>"
#define __SSE_MATH__ 1
# 0 "<built-in>"
#define __SSE2_MATH__ 1
# 0 "<built-in>"
#define __MMX_WITH_SSE__ 1
# 0 "<built-in>"
#define __SEG_FS 1
# 0 "<built-in>"
#define __SEG_GS 1
# 0 "<built-in>"
#define __LITTLE_ENDIAN__ 1
# 0 "<built-in>"
#define __MACH__ 1
# 0 "<built-in>"
#define __APPLE__ 1
# 0 "<built-in>"
#define __APPLE_CC__ 1
# 0 "<built-in>"
#define __CONSTANT_CFSTRINGS__ 1
# 0 "<built-in>"
#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 110500
# 0 "<built-in>"
#define __strong 
# 0 "<built-in>"
#define __weak 
# 0 "<command-line>"
#define __DYNAMIC__ 1
# 1 "project/radare2/libr/core/rtr_http.c"



static int r_core_rtr_http_run(RCore *core, int launch, int browse, const char *path) {
 RConfig *newcfg = NULL, *origcfg = NULL;
 char headers[128] = R_EMPTY;
 RSocketHTTPRequest *rs;
 char buf[32];
 int ret = 0;
 RSocket *s;
 RSocketHTTPOptions so;
 char *dir;
 int iport;
 const char *host = r_config_get (core->config, "http.bind");
 const char *index = r_config_get (core->config, "http.index");
 const char *root = r_config_get (core->config, "http.root");
 const char *homeroot = r_config_get (core->config, "http.homeroot");
 const char *port = r_config_get (core->config, "http.port");
 const char *allow = r_config_get (core->config, "http.allow");
 const char *basepath = r_config_get (core->config, "http.basepath");
 const char *httpui = r_config_get (core->config, "http.ui");
 const char *httpauthfile = r_config_get (core->config, "http.authfile");
 char *pfile = NULL;

 if (!r_file_is_directory (root)) {
  if (!r_file_is_directory (homeroot)) {
   eprintf ("Cannot find http.root or http.homeroot\n");
  }
 }
 if (!path) {
  return false;
 }
 char *arg = strchr (path, ' ');
 if (arg) {
  path = arg + 1;
 }
 if (path && atoi (path)) {
  port = path;
  r_config_set (core->config, "http.port", port);
  path = NULL;
 } else {
  if (core->io->desc && (!path || !*path)) {
   path = httpui;
  }
 }

 if (!strcmp (port, "0")) {
  r_num_irand ();
  iport = 1024 + r_num_rand (45256);
  snprintf (buf, sizeof (buf), "%d", iport);
  port = buf;
 }
 s = r_socket_new (false);
 {
  if (host && *host) {
   if (!strcmp (host, "::1")) {
    s->local = true;
   } else if (!strcmp (host, "localhost")) {
    s->local = true;
   } else if (!strcmp (host, "127.0.0.1")) {
    s->local = true;
   } else if (!strcmp (host, "local")) {
    s->local = true;
    r_config_set (core->config, "http.bind", "localhost");
   } else if (R_STR_ISEMPTY (host) || !strcmp (host, "public")) {

    host = "127.0.0.1";
    r_config_set (core->config, "http.bind", "0.0.0.0");
    s->local = false;
   } else {
    s->local = true;
   }
  } else {
   s->local = true;
  }
  memset (&so, 0, sizeof (so));
 }
 if (!r_socket_listen (s, port, NULL)) {
  r_socket_free (s);
  eprintf ("Cannot listen on http.port\n");
  return 1;
 }

 if (browse == 'H') {
  const char *browser = r_config_get (core->config, "http.browser");
  r_sys_cmdf ("%s http://%s:%d/%s &",
   browser, host, atoi (port), r_str_get (path));
 }

 so.httpauth = r_config_get_i (core->config, "http.auth");

 if (so.httpauth) {
  if (!httpauthfile) {
   r_socket_free (s);
   eprintf ("No user list set for HTTP Authentication\n");
   return 1;
  }

  pfile = r_file_slurp (httpauthfile, NULL);

  if (pfile) {
   so.authtokens = r_str_split_list (pfile, "\n", 0);
  } else {
   r_socket_free (s);
   eprintf ("Empty list of HTTP users\n");
   return 1;
  }

  so.timeout = r_config_get_i (core->config, "http.timeout");
  so.accept_timeout = 1;
 }

 origcfg = core->config;
 newcfg = r_config_clone (core->config);
 core->config = newcfg;

 r_config_set (core->config, "asm.cmt.right", "false");




 r_config_set_i (core->config, "scr.color", COLOR_MODE_DISABLED);
 r_config_set (core->config, "asm.bytes", "false");
 r_config_set (core->config, "scr.interactive", "false");
 bool restoreSandbox = false;
 if (r_config_get_i (core->config, "http.sandbox")) {

  r_config_set (core->config, "cfg.sandbox", "true");
  restoreSandbox = true;
 }
 eprintf ("Starting http server...\n");
 eprintf ("open http://%s:%d/\n", host, atoi (port));
 eprintf ("r2 -C http://%s:%d/cmd/\n", host, atoi (port));
 core->http_up = true;

 ut64 newoff, origoff = core->offset;
 int newblksz, origblksz = core->blocksize;
 ut8 *newblk, *origblk = core->block;

 newblk = malloc (core->blocksize);
 if (!newblk) {
  r_socket_free (s);
  r_list_free (so.authtokens);
  free (pfile);
  return 1;
 }
 memcpy (newblk, core->block, core->blocksize);

 core->block = newblk;

 r_cons_break_push ((RConsBreak)r_core_rtr_http_stop, core);
 while (!r_cons_is_breaked ()) {

  core->config = origcfg;
  r_config_set (origcfg, "scr.html", r_config_get (origcfg, "scr.html"));
  r_config_set_i (origcfg, "scr.color", r_config_get_i (origcfg, "scr.color"));
  r_config_set (origcfg, "scr.interactive", r_config_get (origcfg, "scr.interactive"));
  core->http_up = 0;

  newoff = core->offset;
  newblk = core->block;
  newblksz = core->blocksize;

  core->offset = origoff;
  core->block = origblk;
  core->blocksize = origblksz;




  activateDieTime (core);

  void *bed = r_cons_sleep_begin ();
  rs = r_socket_http_accept (s, &so);
  r_cons_sleep_end (bed);

  if (*basepath && strcmp (basepath, "/")) {
   if (R_STR_ISEMPTY (rs->path) || !strcmp (rs->path, "/")) {
    char *res = r_str_newf ("Location: %s/\n%s", basepath, headers);
    r_socket_http_response (rs, 302, NULL, 0, res);
    r_socket_http_close (rs);
    continue;
   }
   if (r_str_startswith (rs->path, basepath)) {
    char *p = strdup (rs->path + strlen (basepath));
    free (rs->path);
    rs->path = p;
   }
  }

  origoff = core->offset;
  origblk = core->block;
  origblksz = core->blocksize;
  core->offset = newoff;
  core->block = newblk;
  core->blocksize = newblksz;


  core->http_up = 1;
  core->config = newcfg;
  r_config_set (newcfg, "scr.html", r_config_get (newcfg, "scr.html"));
  r_config_set_i (newcfg, "scr.color", r_config_get_i (newcfg, "scr.color"));
  r_config_set (newcfg, "scr.interactive", r_config_get (newcfg, "scr.interactive"));

  if (!rs) {
   bed = r_cons_sleep_begin ();
   r_sys_usleep (100);
   r_cons_sleep_end (bed);
   continue;
  }
  if (allow && *allow) {
   bool accepted = false;
   const char *allows_host;
   char *p, *peer = r_socket_to_string (rs->s);
   char *allows = strdup (allow);

   int i, count = r_str_split (allows, ',');
   p = strchr (peer, ':');
   if (p) {
    *p = 0;
   }
   for (i = 0; i < count; i++) {
    allows_host = r_str_word_get0 (allows, i);

    if (!strcmp (allows_host, peer)) {
     accepted = true;
     break;
    }
   }
   free (peer);
   free (allows);
   if (!accepted) {
    r_socket_http_close (rs);
    continue;
   }
  }
  if (!rs->method || !rs->path) {
   http_logf (core, "Invalid http headers received from client\n");
   r_socket_http_close (rs);
   continue;
  }
  dir = NULL;

  if (!rs->auth) {
   r_socket_http_response (rs, 401, "", 0, NULL);
  }

  if (r_config_get_i (core->config, "http.verbose")) {
   char *peer = r_socket_to_string (rs->s);
   http_logf (core, "[HTTP] %s %s\n", peer, rs->path);
   free (peer);
  }
  if (r_config_get_i (core->config, "http.dirlist")) {
   if (r_file_is_directory (rs->path)) {
    dir = strdup (rs->path);
   }
  }
  if (r_config_get_i (core->config, "http.cors")) {
   strcpy (headers, "Access-Control-Allow-Origin: *\n"
    "Access-Control-Allow-Headers: Origin, "
    "X-Requested-With, Content-Type, Accept\n");
  }
  if (!strcmp (rs->method, "OPTIONS")) {
   r_socket_http_response (rs, 200, "", 0, headers);
  } else if (!strcmp (rs->method, "GET")) {
   if (!strncmp (rs->path, "/up/", 4)) {
    if (r_config_get_i (core->config, "http.upget")) {
     const char *uproot = r_config_get (core->config, "http.uproot");
     if (!rs->path[3] || (rs->path[3]=='/' && !rs->path[4])) {
      char *ptr = rtr_dir_files (uproot);
      r_socket_http_response (rs, 200, ptr, 0, headers);
      free (ptr);
     } else {
      char *path = r_file_root (uproot, rs->path + 4);
      if (r_file_exists (path)) {
       size_t sz = 0;
       char *f = r_file_slurp (path, &sz);
       if (f) {
        r_socket_http_response (rs, 200, f, (int)sz, headers);
        free (f);
       } else {
        r_socket_http_response (rs, 403, "Permission denied", 0, headers);
        http_logf (core, "http: Cannot open '%s'\n", path);
       }
      } else {
       if (dir) {
        char *resp = rtr_dir_files (dir);
        r_socket_http_response (rs, 404, resp, 0, headers);
        free (resp);
       } else {
        http_logf (core, "File '%s' not found\n", path);
        r_socket_http_response (rs, 404, "File not found\n", 0, headers);
       }
      }
      free (path);
     }
    } else {
     r_socket_http_response (rs, 403, "", 0, NULL);
    }
   } else if (!strncmp (rs->path, "/cmd/", 5)) {
    const bool colon = r_config_get_i (core->config, "http.colon");
    if (colon && rs->path[5] != ':') {
     r_socket_http_response (rs, 403, "Permission denied", 0, headers);
    } else {
     char *cmd = rs->path + 5;
     const char *httpcmd = r_config_get (core->config, "http.uri");
     const char *httpref = r_config_get (core->config, "http.referer");
     const bool httpref_enabled = (httpref && *httpref);
     char *refstr = NULL;
     if (httpref_enabled) {
      if (strstr (httpref, "http")) {
       refstr = strdup (httpref);
      } else {
       refstr = r_str_newf ("http://localhost:%d/", atoi (port));
      }
     }

     while (*cmd == '/') {
      cmd++;
     }
     if (httpref_enabled && (!rs->referer || (refstr && !strstr (rs->referer, refstr)))) {
      r_socket_http_response (rs, 503, "", 0, headers);
     } else {
      if (httpcmd && *httpcmd) {
       int len;
       char *res, *bar = r_str_newf ("%s/%s", httpcmd, cmd);
       bed = r_cons_sleep_begin ();
       res = r_socket_http_get (bar, NULL, &len);
       r_cons_sleep_end (bed);
       if (res) {
        res[len] = 0;
        r_cons_println (res);
       }
       free (bar);
      } else {
       char *out, *cmd = rs->path + 5;
       r_str_uri_decode (cmd);
       r_config_set (core->config, "scr.interactive", "false");

       if (!r_sandbox_enable (0) &&
         (!strcmp (cmd, "=h*") ||
          !strcmp (cmd, "=h--"))) {
        out = NULL;
       } else if (*cmd == ':') {

        r_core_cmd0 (core, cmd + 1);
        out = NULL;
       } else {
        RConsContext *ctx = r_cons_context ();
        ctx->noflush = false;
        out = r_core_cmd_str_pipe (core, cmd);
       }

       if (out) {
        char *res = r_str_uri_encode (out);
        char *newheaders = r_str_newf (
          "Content-Type: text/plain\n%s", headers);
        r_socket_http_response (rs, 200, out, 0, newheaders);
        free (out);
        free (newheaders);
        free (res);
       } else {
        r_socket_http_response (rs, 200, "", 0, headers);
       }

       if (!r_sandbox_enable (0)) {
        if (!strcmp (cmd, "=h*")) {

         r_socket_http_close (rs);
         free (dir);
         free (refstr);
         ret = -2;
         goto the_end;
        } else if (!strcmp (cmd, "=h--")) {
         r_socket_http_close (rs);
         free (dir);
         free (refstr);
         ret = 0;
         goto the_end;
        }
       }
      }
     }
     free (refstr);
    }
   } else {
    const char *root = r_config_get (core->config, "http.root");
    const char *homeroot = r_config_get (core->config, "http.homeroot");
    char *path = NULL;
    if (!strcmp (rs->path, "/")) {
     free (rs->path);
     if (*index == '/') {
      rs->path = strdup (index);
      path = strdup (index);
     } else {
      rs->path = r_str_newf ("/%s", index);
      path = r_file_root (root, rs->path);
     }
    } else if (homeroot && *homeroot) {
     char *homepath = r_file_abspath (homeroot);
     path = r_file_root (homepath, rs->path);
     free (homepath);
     if (!r_file_exists (path) && !r_file_is_directory (path)) {
      free (path);
      path = r_file_root (root, rs->path);
     }
    } else {
     if (*index == '/') {
      path = strdup (index);
     } else {
     }
    }

    if (rs->path [strlen (rs->path) - 1] == '/') {
     path = (*index == '/')? strdup (index): r_str_append (path, index);
    } else {

     if (r_file_is_directory (path)) {
      char *res = r_str_newf ("Location: %s/\n%s", rs->path, headers);
      r_socket_http_response (rs, 302, NULL, 0, res);
      r_socket_http_close (rs);
      free (path);
      free (res);
      R_FREE (dir);
      continue;
     }
    }
    if (r_file_exists (path)) {
     size_t sz = 0;
     char *f = r_file_slurp (path, &sz);
     if (f) {
      const char *ct = NULL;
      if (strstr (path, ".js")) {
       ct = "Content-Type: application/javascript\n";
      }
      if (strstr (path, ".css")) {
       ct = "Content-Type: text/css\n";
      }
      if (strstr (path, ".html")) {
       ct = "Content-Type: text/html\n";
      }
      char *hdr = r_str_newf ("%s%s", ct, headers);
      r_socket_http_response (rs, 200, f, (int)sz, hdr);
      free (hdr);
      free (f);
     } else {
      r_socket_http_response (rs, 403, "Permission denied", 0, headers);
      http_logf (core, "http: Cannot open '%s'\n", path);
     }
    } else {
     if (dir) {
      char *resp = rtr_dir_files (dir);
      http_logf (core, "Dirlisting %s\n", dir);
      r_socket_http_response (rs, 404, resp, 0, headers);
      free (resp);
     } else {
      http_logf (core, "File '%s' not found\n", path);
      r_socket_http_response (rs, 404, "File not found\n", 0, headers);
     }
    }
    free (path);
   }
  } else if (!strcmp (rs->method, "POST")) {
   ut8 *ret;
   int retlen;
   char buf[128];
   if (r_config_get_i (core->config, "http.upload")) {
    ret = r_socket_http_handle_upload (rs->data, rs->data_length, &retlen);
    if (ret) {
     ut64 size = r_config_get_i (core->config, "http.maxsize");
     if (size && retlen > size) {
      r_socket_http_response (rs, 403, "403 File too big\n", 0, headers);
     } else {
      char *filename = r_file_root (
       r_config_get (core->config, "http.uproot"),
       rs->path + 4);
      http_logf (core, "UPLOADED '%s'\n", filename);
      r_file_dump (filename, ret, retlen, 0);
      free (filename);
      snprintf (buf, sizeof (buf),
       "<html><body><h2>uploaded %d byte(s). Thanks</h2>\n", retlen);
       r_socket_http_response (rs, 200, buf, 0, headers);
     }
     free (ret);
    }
   } else {
    r_socket_http_response (rs, 403, "403 Forbidden\n", 0, headers);
   }
  } else {
   r_socket_http_response (rs, 404, "Invalid protocol", 0, headers);
  }
  r_socket_http_close (rs);
  free (dir);
 }
the_end:
 {
  int timeout = r_config_get_i (core->config, "http.timeout");
  const char *host = r_config_get (core->config, "http.bind");
  const char *port = r_config_get (core->config, "http.port");
  const char *cors = r_config_get (core->config, "http.cors");
  const char *allow = r_config_get (core->config, "http.allow");
  const char *httpui = r_config_get (core->config, "http.ui");
  core->config = origcfg;
  r_config_set_i (core->config, "http.timeout", timeout);
  r_config_set (core->config, "http.bind", host);
  r_config_set (core->config, "http.port", port);
  r_config_set (core->config, "http.cors", cors);
  r_config_set (core->config, "http.allow", allow);
  r_config_set (core->config, "http.ui", httpui);
 }
 r_cons_break_pop ();
 core->http_up = false;
 free (pfile);
 r_socket_free (s);
 r_config_free (newcfg);
 if (restoreSandbox) {
  r_sandbox_disable (true);
 }

 r_config_set (origcfg, "scr.html", r_config_get (origcfg, "scr.html"));
 r_config_set_i (origcfg, "scr.color", r_config_get_i (origcfg, "scr.color"));
 r_config_set (origcfg, "scr.interactive", r_config_get (origcfg, "scr.interactive"));
 return ret;
}
# 549 "project/radare2/libr/core/rtr_http.c"
R_API int r_core_rtr_http(RCore *core, int launch, int browse, const char *path) {
 int ret;
 if (r_sandbox_enable (0)) {
  eprintf ("sandbox: connect disabled\n");
  return 1;
 }
 if (launch == '-') {
  if (httpthread) {
   eprintf ("Press ^C to stop the webserver\n");
   r_th_kill_free (httpthread);
   httpthread = NULL;
  } else {
   eprintf ("No webserver running\n");
  }
  return 0;
 }
 if (core->http_up) {
  eprintf ("http server is already running\n");
  return 1;
 }
 if (launch == '&') {
  while (*path == '&') {
   path++;
  }
  return r_core_cmdf (core, "& =h%s", path);
 }
# 599 "project/radare2/libr/core/rtr_http.c"
 do {
  ret = r_core_rtr_http_run (core, launch, browse, path);
 } while (ret == -2);
 return ret;
}
