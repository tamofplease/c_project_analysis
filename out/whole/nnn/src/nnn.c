# 0 "project/nnn/src/nnn.c"
# 0 "<built-in>"
#define __STDC__ 1
# 0 "<built-in>"
#define __STDC_VERSION__ 201710L
# 0 "<built-in>"
#define __STDC_UTF_16__ 1
# 0 "<built-in>"
#define __STDC_UTF_32__ 1
# 0 "<built-in>"
#define __STDC_HOSTED__ 1
# 0 "<built-in>"
#define __GNUC__ 11
# 0 "<built-in>"
#define __GNUC_MINOR__ 2
# 0 "<built-in>"
#define __GNUC_PATCHLEVEL__ 0
# 0 "<built-in>"
#define __VERSION__ "11.2.0"
# 0 "<built-in>"
#define __ATOMIC_RELAXED 0
# 0 "<built-in>"
#define __ATOMIC_SEQ_CST 5
# 0 "<built-in>"
#define __ATOMIC_ACQUIRE 2
# 0 "<built-in>"
#define __ATOMIC_RELEASE 3
# 0 "<built-in>"
#define __ATOMIC_ACQ_REL 4
# 0 "<built-in>"
#define __ATOMIC_CONSUME 1
# 0 "<built-in>"
#define __pic__ 2
# 0 "<built-in>"
#define __PIC__ 2
# 0 "<built-in>"
#define __FINITE_MATH_ONLY__ 0
# 0 "<built-in>"
#define _LP64 1
# 0 "<built-in>"
#define __LP64__ 1
# 0 "<built-in>"
#define __SIZEOF_INT__ 4
# 0 "<built-in>"
#define __SIZEOF_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_LONG__ 8
# 0 "<built-in>"
#define __SIZEOF_SHORT__ 2
# 0 "<built-in>"
#define __SIZEOF_FLOAT__ 4
# 0 "<built-in>"
#define __SIZEOF_DOUBLE__ 8
# 0 "<built-in>"
#define __SIZEOF_LONG_DOUBLE__ 16
# 0 "<built-in>"
#define __SIZEOF_SIZE_T__ 8
# 0 "<built-in>"
#define __CHAR_BIT__ 8
# 0 "<built-in>"
#define __BIGGEST_ALIGNMENT__ 16
# 0 "<built-in>"
#define __ORDER_LITTLE_ENDIAN__ 1234
# 0 "<built-in>"
#define __ORDER_BIG_ENDIAN__ 4321
# 0 "<built-in>"
#define __ORDER_PDP_ENDIAN__ 3412
# 0 "<built-in>"
#define __BYTE_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __FLOAT_WORD_ORDER__ __ORDER_LITTLE_ENDIAN__
# 0 "<built-in>"
#define __SIZEOF_POINTER__ 8
# 0 "<built-in>"
#define __GNUC_EXECUTION_CHARSET_NAME "UTF-8"
# 0 "<built-in>"
#define __GNUC_WIDE_EXECUTION_CHARSET_NAME "UTF-32LE"
# 0 "<built-in>"
#define __SIZE_TYPE__ long unsigned int
# 0 "<built-in>"
#define __PTRDIFF_TYPE__ long int
# 0 "<built-in>"
#define __WCHAR_TYPE__ int
# 0 "<built-in>"
#define __WINT_TYPE__ int
# 0 "<built-in>"
#define __INTMAX_TYPE__ long int
# 0 "<built-in>"
#define __UINTMAX_TYPE__ long unsigned int
# 0 "<built-in>"
#define __CHAR16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __CHAR32_TYPE__ unsigned int
# 0 "<built-in>"
#define __SIG_ATOMIC_TYPE__ int
# 0 "<built-in>"
#define __INT8_TYPE__ signed char
# 0 "<built-in>"
#define __INT16_TYPE__ short int
# 0 "<built-in>"
#define __INT32_TYPE__ int
# 0 "<built-in>"
#define __INT64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_LEAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_LEAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_LEAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_LEAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_LEAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_LEAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_LEAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_LEAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INT_FAST8_TYPE__ signed char
# 0 "<built-in>"
#define __INT_FAST16_TYPE__ short int
# 0 "<built-in>"
#define __INT_FAST32_TYPE__ int
# 0 "<built-in>"
#define __INT_FAST64_TYPE__ long long int
# 0 "<built-in>"
#define __UINT_FAST8_TYPE__ unsigned char
# 0 "<built-in>"
#define __UINT_FAST16_TYPE__ short unsigned int
# 0 "<built-in>"
#define __UINT_FAST32_TYPE__ unsigned int
# 0 "<built-in>"
#define __UINT_FAST64_TYPE__ long long unsigned int
# 0 "<built-in>"
#define __INTPTR_TYPE__ long int
# 0 "<built-in>"
#define __UINTPTR_TYPE__ long unsigned int
# 0 "<built-in>"
#define __GXX_ABI_VERSION 1016
# 0 "<built-in>"
#define __SCHAR_MAX__ 0x7f
# 0 "<built-in>"
#define __SHRT_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __LONG_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __LONG_LONG_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __WCHAR_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WCHAR_MIN__ (-__WCHAR_MAX__ - 1)
# 0 "<built-in>"
#define __WINT_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __WINT_MIN__ (-__WINT_MAX__ - 1)
# 0 "<built-in>"
#define __PTRDIFF_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __SIZE_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __SCHAR_WIDTH__ 8
# 0 "<built-in>"
#define __SHRT_WIDTH__ 16
# 0 "<built-in>"
#define __INT_WIDTH__ 32
# 0 "<built-in>"
#define __LONG_WIDTH__ 64
# 0 "<built-in>"
#define __LONG_LONG_WIDTH__ 64
# 0 "<built-in>"
#define __WCHAR_WIDTH__ 32
# 0 "<built-in>"
#define __WINT_WIDTH__ 32
# 0 "<built-in>"
#define __PTRDIFF_WIDTH__ 64
# 0 "<built-in>"
#define __SIZE_WIDTH__ 64
# 0 "<built-in>"
#define __INTMAX_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTMAX_C(c) c ## L
# 0 "<built-in>"
#define __UINTMAX_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __UINTMAX_C(c) c ## UL
# 0 "<built-in>"
#define __INTMAX_WIDTH__ 64
# 0 "<built-in>"
#define __SIG_ATOMIC_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __SIG_ATOMIC_MIN__ (-__SIG_ATOMIC_MAX__ - 1)
# 0 "<built-in>"
#define __SIG_ATOMIC_WIDTH__ 32
# 0 "<built-in>"
#define __INT8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __UINT8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INT_LEAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT8_C(c) c
# 0 "<built-in>"
#define __INT_LEAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_LEAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT16_C(c) c
# 0 "<built-in>"
#define __INT_LEAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_LEAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT32_C(c) c
# 0 "<built-in>"
#define __INT_LEAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_LEAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT64_C(c) c ## LL
# 0 "<built-in>"
#define __INT_LEAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_LEAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT8_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT16_C(c) c
# 0 "<built-in>"
#define __UINT_LEAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT32_C(c) c ## U
# 0 "<built-in>"
#define __UINT_LEAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __UINT64_C(c) c ## ULL
# 0 "<built-in>"
#define __INT_FAST8_MAX__ 0x7f
# 0 "<built-in>"
#define __INT_FAST8_WIDTH__ 8
# 0 "<built-in>"
#define __INT_FAST16_MAX__ 0x7fff
# 0 "<built-in>"
#define __INT_FAST16_WIDTH__ 16
# 0 "<built-in>"
#define __INT_FAST32_MAX__ 0x7fffffff
# 0 "<built-in>"
#define __INT_FAST32_WIDTH__ 32
# 0 "<built-in>"
#define __INT_FAST64_MAX__ 0x7fffffffffffffffLL
# 0 "<built-in>"
#define __INT_FAST64_WIDTH__ 64
# 0 "<built-in>"
#define __UINT_FAST8_MAX__ 0xff
# 0 "<built-in>"
#define __UINT_FAST16_MAX__ 0xffff
# 0 "<built-in>"
#define __UINT_FAST32_MAX__ 0xffffffffU
# 0 "<built-in>"
#define __UINT_FAST64_MAX__ 0xffffffffffffffffULL
# 0 "<built-in>"
#define __INTPTR_MAX__ 0x7fffffffffffffffL
# 0 "<built-in>"
#define __INTPTR_WIDTH__ 64
# 0 "<built-in>"
#define __UINTPTR_MAX__ 0xffffffffffffffffUL
# 0 "<built-in>"
#define __GCC_IEC_559 2
# 0 "<built-in>"
#define __GCC_IEC_559_COMPLEX 2
# 0 "<built-in>"
#define __FLT_EVAL_METHOD__ 0
# 0 "<built-in>"
#define __FLT_EVAL_METHOD_TS_18661_3__ 0
# 0 "<built-in>"
#define __DEC_EVAL_METHOD__ 2
# 0 "<built-in>"
#define __FLT_RADIX__ 2
# 0 "<built-in>"
#define __FLT_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT_DIG__ 6
# 0 "<built-in>"
#define __FLT_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_NORM_MAX__ 3.40282346638528859811704183484516925e+38F
# 0 "<built-in>"
#define __FLT_MIN__ 1.17549435082228750796873653722224568e-38F
# 0 "<built-in>"
#define __FLT_EPSILON__ 1.19209289550781250000000000000000000e-7F
# 0 "<built-in>"
#define __FLT_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F
# 0 "<built-in>"
#define __FLT_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __DBL_MANT_DIG__ 53
# 0 "<built-in>"
#define __DBL_DIG__ 15
# 0 "<built-in>"
#define __DBL_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __DBL_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __DBL_MAX_EXP__ 1024
# 0 "<built-in>"
#define __DBL_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __DBL_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __DBL_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_NORM_MAX__ ((double)1.79769313486231570814527423731704357e+308L)
# 0 "<built-in>"
#define __DBL_MIN__ ((double)2.22507385850720138309023271733240406e-308L)
# 0 "<built-in>"
#define __DBL_EPSILON__ ((double)2.22044604925031308084726333618164062e-16L)
# 0 "<built-in>"
#define __DBL_DENORM_MIN__ ((double)4.94065645841246544176568792868221372e-324L)
# 0 "<built-in>"
#define __DBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __DBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __DBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __DBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __LDBL_MANT_DIG__ 64
# 0 "<built-in>"
#define __LDBL_DIG__ 18
# 0 "<built-in>"
#define __LDBL_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __LDBL_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __LDBL_MAX_EXP__ 16384
# 0 "<built-in>"
#define __LDBL_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __LDBL_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_NORM_MAX__ 1.18973149535723176502126385303097021e+4932L
# 0 "<built-in>"
#define __LDBL_MIN__ 3.36210314311209350626267781732175260e-4932L
# 0 "<built-in>"
#define __LDBL_EPSILON__ 1.08420217248550443400745280086994171e-19L
# 0 "<built-in>"
#define __LDBL_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951L
# 0 "<built-in>"
#define __LDBL_HAS_DENORM__ 1
# 0 "<built-in>"
#define __LDBL_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __LDBL_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __LDBL_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32_MANT_DIG__ 24
# 0 "<built-in>"
#define __FLT32_DIG__ 6
# 0 "<built-in>"
#define __FLT32_MIN_EXP__ (-125)
# 0 "<built-in>"
#define __FLT32_MIN_10_EXP__ (-37)
# 0 "<built-in>"
#define __FLT32_MAX_EXP__ 128
# 0 "<built-in>"
#define __FLT32_MAX_10_EXP__ 38
# 0 "<built-in>"
#define __FLT32_DECIMAL_DIG__ 9
# 0 "<built-in>"
#define __FLT32_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_NORM_MAX__ 3.40282346638528859811704183484516925e+38F32
# 0 "<built-in>"
#define __FLT32_MIN__ 1.17549435082228750796873653722224568e-38F32
# 0 "<built-in>"
#define __FLT32_EPSILON__ 1.19209289550781250000000000000000000e-7F32
# 0 "<built-in>"
#define __FLT32_DENORM_MIN__ 1.40129846432481707092372958328991613e-45F32
# 0 "<built-in>"
#define __FLT32_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT64_DIG__ 15
# 0 "<built-in>"
#define __FLT64_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT64_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT64_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT64_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT64_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT64_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_NORM_MAX__ 1.79769313486231570814527423731704357e+308F64
# 0 "<built-in>"
#define __FLT64_MIN__ 2.22507385850720138309023271733240406e-308F64
# 0 "<built-in>"
#define __FLT64_EPSILON__ 2.22044604925031308084726333618164062e-16F64
# 0 "<built-in>"
#define __FLT64_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F64
# 0 "<built-in>"
#define __FLT64_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT128_MANT_DIG__ 113
# 0 "<built-in>"
#define __FLT128_DIG__ 33
# 0 "<built-in>"
#define __FLT128_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT128_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT128_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT128_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT128_DECIMAL_DIG__ 36
# 0 "<built-in>"
#define __FLT128_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_NORM_MAX__ 1.18973149535723176508575932662800702e+4932F128
# 0 "<built-in>"
#define __FLT128_MIN__ 3.36210314311209350626267781732175260e-4932F128
# 0 "<built-in>"
#define __FLT128_EPSILON__ 1.92592994438723585305597794258492732e-34F128
# 0 "<built-in>"
#define __FLT128_DENORM_MIN__ 6.47517511943802511092443895822764655e-4966F128
# 0 "<built-in>"
#define __FLT128_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT128_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT128_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT128_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT32X_MANT_DIG__ 53
# 0 "<built-in>"
#define __FLT32X_DIG__ 15
# 0 "<built-in>"
#define __FLT32X_MIN_EXP__ (-1021)
# 0 "<built-in>"
#define __FLT32X_MIN_10_EXP__ (-307)
# 0 "<built-in>"
#define __FLT32X_MAX_EXP__ 1024
# 0 "<built-in>"
#define __FLT32X_MAX_10_EXP__ 308
# 0 "<built-in>"
#define __FLT32X_DECIMAL_DIG__ 17
# 0 "<built-in>"
#define __FLT32X_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_NORM_MAX__ 1.79769313486231570814527423731704357e+308F32x
# 0 "<built-in>"
#define __FLT32X_MIN__ 2.22507385850720138309023271733240406e-308F32x
# 0 "<built-in>"
#define __FLT32X_EPSILON__ 2.22044604925031308084726333618164062e-16F32x
# 0 "<built-in>"
#define __FLT32X_DENORM_MIN__ 4.94065645841246544176568792868221372e-324F32x
# 0 "<built-in>"
#define __FLT32X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT32X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT32X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __FLT64X_MANT_DIG__ 64
# 0 "<built-in>"
#define __FLT64X_DIG__ 18
# 0 "<built-in>"
#define __FLT64X_MIN_EXP__ (-16381)
# 0 "<built-in>"
#define __FLT64X_MIN_10_EXP__ (-4931)
# 0 "<built-in>"
#define __FLT64X_MAX_EXP__ 16384
# 0 "<built-in>"
#define __FLT64X_MAX_10_EXP__ 4932
# 0 "<built-in>"
#define __FLT64X_DECIMAL_DIG__ 21
# 0 "<built-in>"
#define __FLT64X_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_NORM_MAX__ 1.18973149535723176502126385303097021e+4932F64x
# 0 "<built-in>"
#define __FLT64X_MIN__ 3.36210314311209350626267781732175260e-4932F64x
# 0 "<built-in>"
#define __FLT64X_EPSILON__ 1.08420217248550443400745280086994171e-19F64x
# 0 "<built-in>"
#define __FLT64X_DENORM_MIN__ 3.64519953188247460252840593361941982e-4951F64x
# 0 "<built-in>"
#define __FLT64X_HAS_DENORM__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_INFINITY__ 1
# 0 "<built-in>"
#define __FLT64X_HAS_QUIET_NAN__ 1
# 0 "<built-in>"
#define __FLT64X_IS_IEC_60559__ 2
# 0 "<built-in>"
#define __REGISTER_PREFIX__ 
# 0 "<built-in>"
#define __USER_LABEL_PREFIX__ _
# 0 "<built-in>"
#define __GNUC_STDC_INLINE__ 1
# 0 "<built-in>"
#define __NO_INLINE__ 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_1 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_2 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 1
# 0 "<built-in>"
#define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 1
# 0 "<built-in>"
#define __GCC_ATOMIC_BOOL_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR16_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_CHAR32_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_WCHAR_T_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_SHORT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_INT_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_LLONG_LOCK_FREE 2
# 0 "<built-in>"
#define __GCC_ATOMIC_TEST_AND_SET_TRUEVAL 1
# 0 "<built-in>"
#define __GCC_ATOMIC_POINTER_LOCK_FREE 2
# 0 "<built-in>"
#define __HAVE_SPECULATION_SAFE_VALUE 1
# 0 "<built-in>"
#define __PRAGMA_REDEFINE_EXTNAME 1
# 0 "<built-in>"
#define __SIZEOF_INT128__ 16
# 0 "<built-in>"
#define __SIZEOF_WCHAR_T__ 4
# 0 "<built-in>"
#define __SIZEOF_WINT_T__ 4
# 0 "<built-in>"
#define __SIZEOF_PTRDIFF_T__ 8
# 0 "<built-in>"
#define __amd64 1
# 0 "<built-in>"
#define __amd64__ 1
# 0 "<built-in>"
#define __x86_64 1
# 0 "<built-in>"
#define __x86_64__ 1
# 0 "<built-in>"
#define __SIZEOF_FLOAT80__ 16
# 0 "<built-in>"
#define __SIZEOF_FLOAT128__ 16
# 0 "<built-in>"
#define __ATOMIC_HLE_ACQUIRE 65536
# 0 "<built-in>"
#define __ATOMIC_HLE_RELEASE 131072
# 0 "<built-in>"
#define __GCC_ASM_FLAG_OUTPUTS__ 1
# 0 "<built-in>"
#define __k8 1
# 0 "<built-in>"
#define __k8__ 1
# 0 "<built-in>"
#define __tune_core2__ 1
# 0 "<built-in>"
#define __code_model_small__ 1
# 0 "<built-in>"
#define __MMX__ 1
# 0 "<built-in>"
#define __SSE__ 1
# 0 "<built-in>"
#define __SSE2__ 1
# 0 "<built-in>"
#define __SSE3__ 1
# 0 "<built-in>"
#define __FXSR__ 1
# 0 "<built-in>"
#define __SSE_MATH__ 1
# 0 "<built-in>"
#define __SSE2_MATH__ 1
# 0 "<built-in>"
#define __MMX_WITH_SSE__ 1
# 0 "<built-in>"
#define __SEG_FS 1
# 0 "<built-in>"
#define __SEG_GS 1
# 0 "<built-in>"
#define __LITTLE_ENDIAN__ 1
# 0 "<built-in>"
#define __MACH__ 1
# 0 "<built-in>"
#define __APPLE__ 1
# 0 "<built-in>"
#define __APPLE_CC__ 1
# 0 "<built-in>"
#define __CONSTANT_CFSTRINGS__ 1
# 0 "<built-in>"
#define __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__ 110500
# 0 "<built-in>"
#define __strong 
# 0 "<built-in>"
#define __weak 
# 0 "<command-line>"
#define __DYNAMIC__ 1
# 1 "project/nnn/src/nnn.c"
# 47 "project/nnn/src/nnn.c"
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 3 4
#define _SYS_RESOURCE_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/appleapiopts.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/appleapiopts.h" 3 4
#define __SYS_APPLEAPIOPTS_H__ 



#define __APPLE_API_STANDARD 



#define __APPLE_API_STABLE 





#define __APPLE_API_EVOLVING 



#define __APPLE_API_UNSTABLE 



#define __APPLE_API_PRIVATE 



#define __APPLE_API_OBSOLETE 
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define _CDEFS_H_ 





#define __BEGIN_DECLS 
#define __END_DECLS 
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __has_feature(x) 0





#define __has_extension(x) 0
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __P(protos) protos
#define __CONCAT(x,y) x ## y
#define __STRING(x) #x

#define __const const
#define __signed signed
#define __volatile volatile
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __dead2 __attribute__((__noreturn__))
#define __pure2 __attribute__((__const__))




#define __unused __attribute__((__unused__))




#define __used __attribute__((__used__))





#define __cold __attribute__((__cold__))
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __exported __attribute__((__visibility__("default")))
#define __exported_push _Pragma("GCC visibility push(default)")
#define __exported_pop _Pragma("GCC visibility pop")
# 196 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __deprecated __attribute__((__deprecated__))



#define __deprecated_msg(_msg) __attribute__((__deprecated__(_msg)))







#define __deprecated_enum_msg(_msg) 


#define __kpi_deprecated(_msg) 







#define __unavailable 


#define __kpi_unavailable 

#define __kpi_deprecated_arm64_macos_unavailable 



#define __dead 
#define __pure 
# 239 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __restrict restrict
# 248 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __nullable 


#define __nonnull 


#define __null_unspecified 


#define _Nullable 


#define _Nonnull 


#define _Null_unspecified 
# 274 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __disable_tail_calls 
# 286 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __not_tail_called 
# 295 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __result_use_check __attribute__((__warn_unused_result__))
# 307 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __swift_unavailable(_msg) 
# 316 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __abortlike __dead2 __cold __not_tail_called
# 341 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __header_inline extern __inline __attribute__((__gnu_inline__))
# 352 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __header_always_inline __header_inline __attribute__ ((__always_inline__))
# 371 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __unreachable_ok_push _Pragma("GCC diagnostic push") _Pragma("GCC diagnostic ignored \"-Wunreachable-code\"")


#define __unreachable_ok_pop _Pragma("GCC diagnostic pop")
# 389 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __printflike(fmtarg,firstvararg) __attribute__((__format__ (__printf__, fmtarg, firstvararg)))

#define __printf0like(fmtarg,firstvararg) __attribute__((__format__ (__printf0__, fmtarg, firstvararg)))

#define __scanflike(fmtarg,firstvararg) __attribute__((__format__ (__scanf__, fmtarg, firstvararg)))


#define __IDSTRING(name,string) static const char name[] __used = string


#define __COPYRIGHT(s) __IDSTRING(copyright,s)



#define __RCSID(s) __IDSTRING(rcsid,s)



#define __SCCSID(s) __IDSTRING(sccsid,s)



#define __PROJECT_VERSION(s) __IDSTRING(project_version,s)




#define __FBSDID(s) 



#define __DECONST(type,var) __CAST_AWAY_QUALIFIER(var, const, type)



#define __DEVOLATILE(type,var) __CAST_AWAY_QUALIFIER(var, volatile, type)



#define __DEQUALIFY(type,var) __CAST_AWAY_QUALIFIER(var, const volatile, type)
# 446 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __alloc_size(...) __attribute__((alloc_size(__VA_ARGS__)))
# 496 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_ONLY_64_BIT_INO_T 0
#define __DARWIN_ONLY_UNIX_CONFORMANCE 1
#define __DARWIN_ONLY_VERS_1050 0
# 528 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_UNIX03 1
# 564 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_64_BIT_INO_T 1
# 575 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_VERS_1050 1




#define __DARWIN_NON_CANCELABLE 0







#define __DARWIN_SUF_UNIX03 
# 597 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_SUF_64_BIT_INO_T "$INODE64"
# 607 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_SUF_1050 "$1050"
# 616 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_SUF_NON_CANCELABLE 
# 626 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_SUF_EXTSN "$DARWIN_EXTSN"




#define __DARWIN_ALIAS(sym) __asm("_" __STRING(sym) __DARWIN_SUF_UNIX03)
#define __DARWIN_ALIAS_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_NON_CANCELABLE __DARWIN_SUF_UNIX03)
#define __DARWIN_ALIAS_I(sym) __asm("_" __STRING(sym) __DARWIN_SUF_64_BIT_INO_T __DARWIN_SUF_UNIX03)
#define __DARWIN_NOCANCEL(sym) __asm("_" __STRING(sym) __DARWIN_SUF_NON_CANCELABLE)
#define __DARWIN_INODE64(sym) __asm("_" __STRING(sym) __DARWIN_SUF_64_BIT_INO_T)

#define __DARWIN_1050(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050)
#define __DARWIN_1050ALIAS(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_UNIX03)
#define __DARWIN_1050ALIAS_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_NON_CANCELABLE __DARWIN_SUF_UNIX03)
#define __DARWIN_1050ALIAS_I(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_64_BIT_INO_T __DARWIN_SUF_UNIX03)
#define __DARWIN_1050INODE64(sym) __asm("_" __STRING(sym) __DARWIN_SUF_1050 __DARWIN_SUF_64_BIT_INO_T)

#define __DARWIN_EXTSN(sym) __asm("_" __STRING(sym) __DARWIN_SUF_EXTSN)
#define __DARWIN_EXTSN_C(sym) __asm("_" __STRING(sym) __DARWIN_SUF_EXTSN __DARWIN_SUF_NON_CANCELABLE)




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_symbol_aliasing.h" 3 4
#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_2_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_3_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_4_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_5_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_5_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_6_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_6_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_7_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_7_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_8_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_9_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_10_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_11_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_12_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_4(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_5(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_6(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_13_7(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_0(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_1(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_2(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_3(x) 





#define __DARWIN_ALIAS_STARTING_IPHONE___IPHONE_14_5(x) 



#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_0(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_3(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_5(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_6(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_7(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_8(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_9(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_10(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_10_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_10_3(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_3(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_11_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_12_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_2(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_13_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_4(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_5(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_14_6(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_15(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_15_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_10_16(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_11_0(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_11_1(x) x





#define __DARWIN_ALIAS_STARTING_MAC___MAC_11_3(x) x
# 650 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 2 3 4




#define __DARWIN_ALIAS_STARTING(_mac,_iphone,x) __DARWIN_ALIAS_STARTING_MAC_ ##_mac(x)
# 715 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_posix_availability.h" 3 4
#define ___POSIX_C_DEPRECATED_STARTING_198808L 





#define ___POSIX_C_DEPRECATED_STARTING_199009L 





#define ___POSIX_C_DEPRECATED_STARTING_199209L 





#define ___POSIX_C_DEPRECATED_STARTING_199309L 





#define ___POSIX_C_DEPRECATED_STARTING_199506L 





#define ___POSIX_C_DEPRECATED_STARTING_200112L 





#define ___POSIX_C_DEPRECATED_STARTING_200809L 
# 716 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 2 3 4

#define __POSIX_C_DEPRECATED(ver) ___POSIX_C_DEPRECATED_STARTING_ ##ver







#define __DARWIN_C_ANSI 010000L
#define __DARWIN_C_FULL 900000L






#define __DARWIN_C_LEVEL __DARWIN_C_FULL







#define __STDC_WANT_LIB_EXT1__ 1
# 752 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __DARWIN_NO_LONG_LONG 0
# 764 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define _DARWIN_FEATURE_64_BIT_INODE 1
# 790 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE 1







#define _DARWIN_FEATURE_UNIX_CONFORMANCE 3
# 809 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __CAST_AWAY_QUALIFIER(variable,qualifier,type) (type) (long)(variable)







#define __XNU_PRIVATE_EXTERN __attribute__((visibility("hidden")))
# 833 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __compiler_barrier() __asm__ __volatile__("" ::: "memory")





#define __enum_open 
#define __enum_closed 





#define __enum_options 
# 866 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
#define __enum_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_open

#define __enum_closed_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_closed

#define __options_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_open __enum_options

#define __options_closed_decl(_name,_type,...) typedef _type _name; enum __VA_ARGS__ __enum_closed __enum_options
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 3 4
#define _SYS__TYPES_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_types.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_types.h" 3 4
#define _BSD_MACHINE__TYPES_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_types.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_types.h" 3 4
#define _BSD_I386__TYPES_H_ 








# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 2 3 4
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 3 4
#define __DARWIN_NULL ((void *)0)


typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
#define _SYS__PTHREAD_TYPES_H_ 





#define __PTHREAD_SIZE__ 8176
#define __PTHREAD_ATTR_SIZE__ 56
#define __PTHREAD_MUTEXATTR_SIZE__ 8
#define __PTHREAD_MUTEX_SIZE__ 56
#define __PTHREAD_CONDATTR_SIZE__ 8
#define __PTHREAD_COND_SIZE__ 40
#define __PTHREAD_ONCE_SIZE__ 8
#define __PTHREAD_RWLOCK_SIZE__ 192
#define __PTHREAD_RWLOCKATTR_SIZE__ 16
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 2 3 4


#define __offsetof(type,field) __builtin_offsetof(type, field)
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 2 3 4


# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdint.h" 1 3 4
# 9 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdint.h" 3 4
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 1 3 4
# 16 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 3 4
#define _STDINT_H_ 


#define __WORDSIZE 64







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int8_t.h" 3 4
#define _INT8_T 
typedef signed char int8_t;
# 28 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int16_t.h" 3 4
#define _INT16_T 
typedef short int16_t;
# 29 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int32_t.h" 3 4
#define _INT32_T 
typedef int int32_t;
# 30 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int64_t.h" 3 4
#define _INT64_T 
typedef long long int64_t;
# 31 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint8_t.h" 3 4
#define _UINT8_T 
typedef unsigned char uint8_t;
# 33 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint16_t.h" 3 4
#define _UINT16_T 
typedef unsigned short uint16_t;
# 34 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint32_t.h" 3 4
#define _UINT32_T 
typedef unsigned int uint32_t;
# 35 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint64_t.h" 3 4
#define _UINT64_T 
typedef unsigned long long uint64_t;
# 36 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
#define _INTPTR_T 
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/types.h" 3 4
#define _BSD_MACHINE_TYPES_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 3 4
#define _MACHTYPES_H_ 
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
#define _U_INT8_T 
typedef unsigned char u_int8_t;
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
#define _U_INT16_T 
typedef unsigned short u_int16_t;
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
#define _U_INT32_T 
typedef unsigned int u_int32_t;
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
#define _U_INT64_T 
typedef unsigned long long u_int64_t;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4


typedef int64_t register_t;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
#define _UINTPTR_T 
typedef unsigned long uintptr_t;
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4



typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;
#define USER_ADDR_NULL ((user_addr_t) 0)
#define CAST_USER_ADDR_T(a_ptr) ((user_addr_t)((uintptr_t)(a_ptr)))





typedef u_int64_t syscall_arg_t;
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/types.h" 2 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 63 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_intmax_t.h" 3 4
#define _INTMAX_T 

typedef long int intmax_t;
# 68 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uintmax_t.h" 3 4
#define _UINTMAX_T 

typedef long unsigned int uintmax_t;
# 69 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4


#define INT8_C(v) (v)
#define INT16_C(v) (v)
#define INT32_C(v) (v)
#define INT64_C(v) (v ## LL)

#define UINT8_C(v) (v)
#define UINT16_C(v) (v)
#define UINT32_C(v) (v ## U)
#define UINT64_C(v) (v ## ULL)


#define INTMAX_C(v) (v ## L)
#define UINTMAX_C(v) (v ## UL)
# 105 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 3 4
#define INT8_MAX 127
#define INT16_MAX 32767
#define INT32_MAX 2147483647
#define INT64_MAX 9223372036854775807LL

#define INT8_MIN -128
#define INT16_MIN -32768






#define INT32_MIN (-INT32_MAX-1)
#define INT64_MIN (-INT64_MAX-1)

#define UINT8_MAX 255
#define UINT16_MAX 65535
#define UINT32_MAX 4294967295U
#define UINT64_MAX 18446744073709551615ULL


#define INT_LEAST8_MIN INT8_MIN
#define INT_LEAST16_MIN INT16_MIN
#define INT_LEAST32_MIN INT32_MIN
#define INT_LEAST64_MIN INT64_MIN

#define INT_LEAST8_MAX INT8_MAX
#define INT_LEAST16_MAX INT16_MAX
#define INT_LEAST32_MAX INT32_MAX
#define INT_LEAST64_MAX INT64_MAX

#define UINT_LEAST8_MAX UINT8_MAX
#define UINT_LEAST16_MAX UINT16_MAX
#define UINT_LEAST32_MAX UINT32_MAX
#define UINT_LEAST64_MAX UINT64_MAX


#define INT_FAST8_MIN INT8_MIN
#define INT_FAST16_MIN INT16_MIN
#define INT_FAST32_MIN INT32_MIN
#define INT_FAST64_MIN INT64_MIN

#define INT_FAST8_MAX INT8_MAX
#define INT_FAST16_MAX INT16_MAX
#define INT_FAST32_MAX INT32_MAX
#define INT_FAST64_MAX INT64_MAX

#define UINT_FAST8_MAX UINT8_MAX
#define UINT_FAST16_MAX UINT16_MAX
#define UINT_FAST32_MAX UINT32_MAX
#define UINT_FAST64_MAX UINT64_MAX




#define INTPTR_MAX 9223372036854775807L



#define INTPTR_MIN (-INTPTR_MAX-1)


#define UINTPTR_MAX 18446744073709551615UL





#define INTMAX_MAX INTMAX_C(9223372036854775807)
#define UINTMAX_MAX UINTMAX_C(18446744073709551615)
#define INTMAX_MIN (-INTMAX_MAX-1)



#define PTRDIFF_MIN INTMAX_MIN
#define PTRDIFF_MAX INTMAX_MAX





#define SIZE_MAX UINTPTR_MAX


#define RSIZE_MAX (SIZE_MAX >> 1)




#define WCHAR_MAX __WCHAR_MAX__
# 209 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 3 4
#define WCHAR_MIN (-WCHAR_MAX-1)



#define WINT_MIN INT32_MIN
#define WINT_MAX INT32_MAX

#define SIG_ATOMIC_MIN INT32_MIN
#define SIG_ATOMIC_MAX INT32_MAX
# 10 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdint.h" 2 3 4



#define _GCC_WRAP_STDINT_H 
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __AVAILABILITY__ 
# 132 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __API_TO_BE_DEPRECATED 100000


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/AvailabilityVersions.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/AvailabilityVersions.h" 3 4
#define __AVAILABILITY_VERSIONS__ 

#define __MAC_10_0 1000
#define __MAC_10_1 1010
#define __MAC_10_2 1020
#define __MAC_10_3 1030
#define __MAC_10_4 1040
#define __MAC_10_5 1050
#define __MAC_10_6 1060
#define __MAC_10_7 1070
#define __MAC_10_8 1080
#define __MAC_10_9 1090
#define __MAC_10_10 101000
#define __MAC_10_10_2 101002
#define __MAC_10_10_3 101003
#define __MAC_10_11 101100
#define __MAC_10_11_2 101102
#define __MAC_10_11_3 101103
#define __MAC_10_11_4 101104
#define __MAC_10_12 101200
#define __MAC_10_12_1 101201
#define __MAC_10_12_2 101202
#define __MAC_10_12_4 101204
#define __MAC_10_13 101300
#define __MAC_10_13_1 101301
#define __MAC_10_13_2 101302
#define __MAC_10_13_4 101304
#define __MAC_10_14 101400
#define __MAC_10_14_1 101401
#define __MAC_10_14_4 101404
#define __MAC_10_14_6 101406
#define __MAC_10_15 101500
#define __MAC_10_15_1 101501
#define __MAC_10_15_4 101504
#define __MAC_10_16 101600
#define __MAC_11_0 110000
#define __MAC_11_1 110100
#define __MAC_11_3 110300


#define __IPHONE_2_0 20000
#define __IPHONE_2_1 20100
#define __IPHONE_2_2 20200
#define __IPHONE_3_0 30000
#define __IPHONE_3_1 30100
#define __IPHONE_3_2 30200
#define __IPHONE_4_0 40000
#define __IPHONE_4_1 40100
#define __IPHONE_4_2 40200
#define __IPHONE_4_3 40300
#define __IPHONE_5_0 50000
#define __IPHONE_5_1 50100
#define __IPHONE_6_0 60000
#define __IPHONE_6_1 60100
#define __IPHONE_7_0 70000
#define __IPHONE_7_1 70100
#define __IPHONE_8_0 80000
#define __IPHONE_8_1 80100
#define __IPHONE_8_2 80200
#define __IPHONE_8_3 80300
#define __IPHONE_8_4 80400
#define __IPHONE_9_0 90000
#define __IPHONE_9_1 90100
#define __IPHONE_9_2 90200
#define __IPHONE_9_3 90300
#define __IPHONE_10_0 100000
#define __IPHONE_10_1 100100
#define __IPHONE_10_2 100200
#define __IPHONE_10_3 100300
#define __IPHONE_11_0 110000
#define __IPHONE_11_1 110100
#define __IPHONE_11_2 110200
#define __IPHONE_11_3 110300
#define __IPHONE_11_4 110400
#define __IPHONE_12_0 120000
#define __IPHONE_12_1 120100
#define __IPHONE_12_2 120200
#define __IPHONE_12_3 120300
#define __IPHONE_12_4 120400
#define __IPHONE_13_0 130000
#define __IPHONE_13_1 130100
#define __IPHONE_13_2 130200
#define __IPHONE_13_3 130300
#define __IPHONE_13_4 130400
#define __IPHONE_13_5 130500
#define __IPHONE_13_6 130600
#define __IPHONE_13_7 130700
#define __IPHONE_14_0 140000
#define __IPHONE_14_1 140100
#define __IPHONE_14_2 140200
#define __IPHONE_14_3 140300
#define __IPHONE_14_5 140500


#define __TVOS_9_0 90000
#define __TVOS_9_1 90100
#define __TVOS_9_2 90200
#define __TVOS_10_0 100000
#define __TVOS_10_0_1 100001
#define __TVOS_10_1 100100
#define __TVOS_10_2 100200
#define __TVOS_11_0 110000
#define __TVOS_11_1 110100
#define __TVOS_11_2 110200
#define __TVOS_11_3 110300
#define __TVOS_11_4 110400
#define __TVOS_12_0 120000
#define __TVOS_12_1 120100
#define __TVOS_12_2 120200
#define __TVOS_12_3 120300
#define __TVOS_12_4 120400
#define __TVOS_13_0 130000
#define __TVOS_13_2 130200
#define __TVOS_13_3 130300
#define __TVOS_13_4 130400
#define __TVOS_14_0 140000
#define __TVOS_14_1 140100
#define __TVOS_14_2 140200
#define __TVOS_14_3 140300
#define __TVOS_14_5 140500

#define __WATCHOS_1_0 10000
#define __WATCHOS_2_0 20000
#define __WATCHOS_2_1 20100
#define __WATCHOS_2_2 20200
#define __WATCHOS_3_0 30000
#define __WATCHOS_3_1 30100
#define __WATCHOS_3_1_1 30101
#define __WATCHOS_3_2 30200
#define __WATCHOS_4_0 40000
#define __WATCHOS_4_1 40100
#define __WATCHOS_4_2 40200
#define __WATCHOS_4_3 40300
#define __WATCHOS_5_0 50000
#define __WATCHOS_5_1 50100
#define __WATCHOS_5_2 50200
#define __WATCHOS_5_3 50300
#define __WATCHOS_6_0 60000
#define __WATCHOS_6_1 60100
#define __WATCHOS_6_2 60200
#define __WATCHOS_7_0 70000
#define __WATCHOS_7_1 70100
#define __WATCHOS_7_2 70200
#define __WATCHOS_7_3 70300
#define __WATCHOS_7_4 70400







#define MAC_OS_X_VERSION_10_0 1000
#define MAC_OS_X_VERSION_10_1 1010
#define MAC_OS_X_VERSION_10_2 1020
#define MAC_OS_X_VERSION_10_3 1030
#define MAC_OS_X_VERSION_10_4 1040
#define MAC_OS_X_VERSION_10_5 1050
#define MAC_OS_X_VERSION_10_6 1060
#define MAC_OS_X_VERSION_10_7 1070
#define MAC_OS_X_VERSION_10_8 1080
#define MAC_OS_X_VERSION_10_9 1090
#define MAC_OS_X_VERSION_10_10 101000
#define MAC_OS_X_VERSION_10_10_2 101002
#define MAC_OS_X_VERSION_10_10_3 101003
#define MAC_OS_X_VERSION_10_11 101100
#define MAC_OS_X_VERSION_10_11_2 101102
#define MAC_OS_X_VERSION_10_11_3 101103
#define MAC_OS_X_VERSION_10_11_4 101104
#define MAC_OS_X_VERSION_10_12 101200
#define MAC_OS_X_VERSION_10_12_1 101201
#define MAC_OS_X_VERSION_10_12_2 101202
#define MAC_OS_X_VERSION_10_12_4 101204
#define MAC_OS_X_VERSION_10_13 101300
#define MAC_OS_X_VERSION_10_13_1 101301
#define MAC_OS_X_VERSION_10_13_2 101302
#define MAC_OS_X_VERSION_10_13_4 101304
#define MAC_OS_X_VERSION_10_14 101400
#define MAC_OS_X_VERSION_10_14_1 101401
#define MAC_OS_X_VERSION_10_14_4 101404
#define MAC_OS_X_VERSION_10_14_6 101406
#define MAC_OS_X_VERSION_10_15 101500
#define MAC_OS_X_VERSION_10_15_1 101501
#define MAC_OS_X_VERSION_10_16 101600
#define MAC_OS_VERSION_11_0 110000



#define __DRIVERKIT_19_0 190000
#define __DRIVERKIT_20_0 200000
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 2 3 4
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 1 3 4
# 40 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 3 4
#define __AVAILABILITY_INTERNAL__ 
# 49 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 3 4
#define __MAC_OS_X_VERSION_MIN_REQUIRED __ENVIRONMENT_MAC_OS_X_VERSION_MIN_REQUIRED__
# 102 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 3 4
#define __MAC_OS_X_VERSION_MAX_ALLOWED __MAC_11_3
# 118 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 3 4
#define __AVAILABILITY_INTERNAL_DEPRECATED __attribute__((deprecated))




#define __AVAILABILITY_INTERNAL_DEPRECATED_MSG(_msg) __attribute__((deprecated))






#define __AVAILABILITY_INTERNAL_UNAVAILABLE __attribute__((unavailable))
#define __AVAILABILITY_INTERNAL_WEAK_IMPORT __attribute__((weak_import))
#define __AVAILABILITY_INTERNAL_REGULAR 
# 157 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 3 4
#define __ENABLE_LEGACY_MAC_AVAILABILITY 1
# 4703 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 3 4
#define __API_AVAILABLE_GET_MACRO(...) 
#define __API_AVAILABLE_BEGIN_GET_MACRO(...) 
#define __API_DEPRECATED_MSG_GET_MACRO(...) 
#define __API_DEPRECATED_REP_GET_MACRO(...) 
#define __API_DEPRECATED_BEGIN_MSG_GET_MACRO(...) 
#define __API_DEPRECATED_BEGIN_REP_GET_MACRO 
#define __API_UNAVAILABLE_GET_MACRO(...) 
#define __API_UNAVAILABLE_BEGIN_GET_MACRO(...) 
# 4745 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 3 4
#define __swift_compiler_version_at_least(...) 1







#define __SPI_AVAILABLE(...) 
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 2 3 4
# 178 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __OSX_AVAILABLE_STARTING(_osx,_ios) 
#define __OSX_AVAILABLE_BUT_DEPRECATED(_osxIntro,_osxDep,_iosIntro,_iosDep) 
#define __OSX_AVAILABLE_BUT_DEPRECATED_MSG(_osxIntro,_osxDep,_iosIntro,_iosDep,_msg) 
# 204 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __OS_AVAILABILITY(_target,_availability) 
#define __OS_AVAILABILITY_MSG(_target,_availability,_msg) 
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __OSX_EXTENSION_UNAVAILABLE(_msg) 
#define __IOS_EXTENSION_UNAVAILABLE(_msg) 






#define __OS_EXTENSION_UNAVAILABLE(_msg) __OSX_EXTENSION_UNAVAILABLE(_msg) __IOS_EXTENSION_UNAVAILABLE(_msg)
# 241 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __OSX_UNAVAILABLE 



#define __OSX_AVAILABLE(_vers) 



#define __OSX_DEPRECATED(_start,_dep,_msg) 
# 264 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __IOS_UNAVAILABLE 



#define __IOS_PROHIBITED 



#define __IOS_AVAILABLE(_vers) 



#define __IOS_DEPRECATED(_start,_dep,_msg) 
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __TVOS_UNAVAILABLE 



#define __TVOS_PROHIBITED 



#define __TVOS_AVAILABLE(_vers) 



#define __TVOS_DEPRECATED(_start,_dep,_msg) 
# 318 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __WATCHOS_UNAVAILABLE 



#define __WATCHOS_PROHIBITED 



#define __WATCHOS_AVAILABLE(_vers) 



#define __WATCHOS_DEPRECATED(_start,_dep,_msg) 
# 343 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __SWIFT_UNAVAILABLE 



#define __SWIFT_UNAVAILABLE_MSG(_msg) 
# 429 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __API_AVAILABLE(...) 
#define __API_AVAILABLE_BEGIN(...) 
#define __API_AVAILABLE_END 
#define __API_DEPRECATED(...) 
#define __API_DEPRECATED_WITH_REPLACEMENT(...) 
#define __API_DEPRECATED_BEGIN(...) 
#define __API_DEPRECATED_END 
#define __API_DEPRECATED_WITH_REPLACEMENT_BEGIN(...) 
#define __API_DEPRECATED_WITH_REPLACEMENT_END 
#define __API_UNAVAILABLE(...) 
#define __API_UNAVAILABLE_BEGIN(...) 
#define __API_UNAVAILABLE_END 
# 475 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
#define __SPI_DEPRECATED(...) 



#define __SPI_DEPRECATED_WITH_REPLACEMENT(...) 
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_timeval.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_timeval.h" 3 4
#define _STRUCT_TIMEVAL struct timeval




struct timeval
{
 __darwin_time_t tv_sec;
 __darwin_suseconds_t tv_usec;
};
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_id_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_id_t.h" 3 4
#define _ID_T 

typedef __darwin_id_t id_t;
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 2 3 4





typedef __uint64_t rlim_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 3 4
#define PRIO_PROCESS 0
#define PRIO_PGRP 1
#define PRIO_USER 2


#define PRIO_DARWIN_THREAD 3
#define PRIO_DARWIN_PROCESS 4





#define PRIO_MIN -20
#define PRIO_MAX 20






#define PRIO_DARWIN_BG 0x1000





#define PRIO_DARWIN_NONUI 0x1001
# 140 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 3 4
#define RUSAGE_SELF 0
#define RUSAGE_CHILDREN -1
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 3 4
struct rusage {
 struct timeval ru_utime;
 struct timeval ru_stime;
# 163 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 3 4
 long ru_maxrss;
#define ru_first ru_ixrss
 long ru_ixrss;
 long ru_idrss;
 long ru_isrss;
 long ru_minflt;
 long ru_majflt;
 long ru_nswap;
 long ru_inblock;
 long ru_oublock;
 long ru_msgsnd;
 long ru_msgrcv;
 long ru_nsignals;
 long ru_nvcsw;
 long ru_nivcsw;
#define ru_last ru_nivcsw

};





#define RUSAGE_INFO_V0 0
#define RUSAGE_INFO_V1 1
#define RUSAGE_INFO_V2 2
#define RUSAGE_INFO_V3 3
#define RUSAGE_INFO_V4 4
#define RUSAGE_INFO_V5 5
#define RUSAGE_INFO_CURRENT RUSAGE_INFO_V5




#define RU_PROC_RUNS_RESLIDE 0x00000001

typedef void *rusage_info_t;

struct rusage_info_v0 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
};

struct rusage_info_v1 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
};

struct rusage_info_v2 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
};

struct rusage_info_v3 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
};

struct rusage_info_v4 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
};

struct rusage_info_v5 {
 uint8_t ri_uuid[16];
 uint64_t ri_user_time;
 uint64_t ri_system_time;
 uint64_t ri_pkg_idle_wkups;
 uint64_t ri_interrupt_wkups;
 uint64_t ri_pageins;
 uint64_t ri_wired_size;
 uint64_t ri_resident_size;
 uint64_t ri_phys_footprint;
 uint64_t ri_proc_start_abstime;
 uint64_t ri_proc_exit_abstime;
 uint64_t ri_child_user_time;
 uint64_t ri_child_system_time;
 uint64_t ri_child_pkg_idle_wkups;
 uint64_t ri_child_interrupt_wkups;
 uint64_t ri_child_pageins;
 uint64_t ri_child_elapsed_abstime;
 uint64_t ri_diskio_bytesread;
 uint64_t ri_diskio_byteswritten;
 uint64_t ri_cpu_time_qos_default;
 uint64_t ri_cpu_time_qos_maintenance;
 uint64_t ri_cpu_time_qos_background;
 uint64_t ri_cpu_time_qos_utility;
 uint64_t ri_cpu_time_qos_legacy;
 uint64_t ri_cpu_time_qos_user_initiated;
 uint64_t ri_cpu_time_qos_user_interactive;
 uint64_t ri_billed_system_time;
 uint64_t ri_serviced_system_time;
 uint64_t ri_logical_writes;
 uint64_t ri_lifetime_max_phys_footprint;
 uint64_t ri_instructions;
 uint64_t ri_cycles;
 uint64_t ri_billed_energy;
 uint64_t ri_serviced_energy;
 uint64_t ri_interval_max_phys_footprint;
 uint64_t ri_runnable_time;
 uint64_t ri_flags;
};

typedef struct rusage_info_v5 rusage_info_current;
# 382 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/resource.h" 3 4
#define RLIM_INFINITY (((__uint64_t)1 << 63) - 1)
#define RLIM_SAVED_MAX RLIM_INFINITY
#define RLIM_SAVED_CUR RLIM_INFINITY





#define RLIMIT_CPU 0
#define RLIMIT_FSIZE 1
#define RLIMIT_DATA 2
#define RLIMIT_STACK 3
#define RLIMIT_CORE 4
#define RLIMIT_AS 5

#define RLIMIT_RSS RLIMIT_AS
#define RLIMIT_MEMLOCK 6
#define RLIMIT_NPROC 7

#define RLIMIT_NOFILE 8

#define RLIM_NLIMITS 9

#define _RLIMIT_POSIX_FLAG 0x1000





struct rlimit {
 rlim_t rlim_cur;
 rlim_t rlim_max;
};







#define RLIMIT_WAKEUPS_MONITOR 0x1
#define RLIMIT_CPU_USAGE_MONITOR 0x2
#define RLIMIT_THREAD_CPULIMITS 0x3
#define RLIMIT_FOOTPRINT_INTERVAL 0x4




#define WAKEMON_ENABLE 0x01
#define WAKEMON_DISABLE 0x02
#define WAKEMON_GET_PARAMS 0x04
#define WAKEMON_SET_DEFAULTS 0x08
#define WAKEMON_MAKE_FATAL 0x10




#define CPUMON_MAKE_FATAL 0x1000




#define FOOTPRINT_INTERVAL_RESET 0x1

struct proc_rlimit_control_wakeupmon {
 uint32_t wm_flags;
 int32_t wm_rate;
};




#define IOPOL_TYPE_DISK 0
#define IOPOL_TYPE_VFS_ATIME_UPDATES 2
#define IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES 3
#define IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME 4
#define IOPOL_TYPE_VFS_TRIGGER_RESOLVE 5
#define IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION 6
#define IOPOL_TYPE_VFS_IGNORE_PERMISSIONS 7
#define IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE 8


#define IOPOL_SCOPE_PROCESS 0
#define IOPOL_SCOPE_THREAD 1
#define IOPOL_SCOPE_DARWIN_BG 2


#define IOPOL_DEFAULT 0
#define IOPOL_IMPORTANT 1
#define IOPOL_PASSIVE 2
#define IOPOL_THROTTLE 3
#define IOPOL_UTILITY 4
#define IOPOL_STANDARD 5


#define IOPOL_APPLICATION IOPOL_STANDARD
#define IOPOL_NORMAL IOPOL_IMPORTANT


#define IOPOL_ATIME_UPDATES_DEFAULT 0
#define IOPOL_ATIME_UPDATES_OFF 1

#define IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT 0
#define IOPOL_MATERIALIZE_DATALESS_FILES_OFF 1
#define IOPOL_MATERIALIZE_DATALESS_FILES_ON 2

#define IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT 0
#define IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME 1

#define IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT 0
#define IOPOL_VFS_TRIGGER_RESOLVE_OFF 1

#define IOPOL_VFS_CONTENT_PROTECTION_DEFAULT 0
#define IOPOL_VFS_CONTENT_PROTECTION_IGNORE 1

#define IOPOL_VFS_IGNORE_PERMISSIONS_OFF 0
#define IOPOL_VFS_IGNORE_PERMISSIONS_ON 1

#define IOPOL_VFS_SKIP_MTIME_UPDATE_OFF 0
#define IOPOL_VFS_SKIP_MTIME_UPDATE_ON 1





int getpriority(int, id_t);

int getiopolicy_np(int, int) ;

int getrlimit(int, struct rlimit *) __asm("_" "getrlimit" );
int getrusage(int, struct rusage *);
int setpriority(int, id_t, int);

int setiopolicy_np(int, int, int) ;

int setrlimit(int, const struct rlimit *) __asm("_" "setrlimit" );

# 48 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
#define _SYS_STAT_H_ 






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_timespec.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_timespec.h" 3 4
#define _STRUCT_TIMESPEC struct timespec



struct timespec
{
 __darwin_time_t tv_sec;
 long tv_nsec;
};
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_blkcnt_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_blkcnt_t.h" 3 4
#define _BLKCNT_T 

typedef __darwin_blkcnt_t blkcnt_t;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_blksize_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_blksize_t.h" 3 4
#define _BLKSIZE_T 

typedef __darwin_blksize_t blksize_t;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_dev_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_dev_t.h" 3 4
#define _DEV_T 

typedef __darwin_dev_t dev_t;
# 88 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ino_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ino_t.h" 3 4
#define _INO_T 

typedef __darwin_ino_t ino_t;
# 89 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ino64_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ino64_t.h" 3 4
#define _INO64_T 

typedef __darwin_ino64_t ino64_t;
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_mode_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_mode_t.h" 3 4
#define _MODE_T 

typedef __darwin_mode_t mode_t;
# 95 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_nlink_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_nlink_t.h" 3 4
#define _NLINK_T 

typedef __uint16_t nlink_t;
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uid_t.h" 3 4
#define _UID_T 

typedef __darwin_uid_t uid_t;
# 97 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_gid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_gid_t.h" 3 4
#define _GID_T 

typedef __darwin_gid_t gid_t;
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_off_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_off_t.h" 3 4
#define _OFF_T 

typedef __darwin_off_t off_t;
# 99 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_time_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_time_t.h" 3 4
#define _TIME_T 

typedef __darwin_time_t time_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
struct ostat {
 __uint16_t st_dev;
 ino_t st_ino;
 mode_t st_mode;
 nlink_t st_nlink;
 __uint16_t st_uid;
 __uint16_t st_gid;
 __uint16_t st_rdev;
 __int32_t st_size;
 struct timespec st_atimespec;
 struct timespec st_mtimespec;
 struct timespec st_ctimespec;
 __int32_t st_blksize;
 __int32_t st_blocks;
 __uint32_t st_flags;
 __uint32_t st_gen;
};

#define __DARWIN_STRUCT_STAT64_TIMES struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec;
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
#define __DARWIN_STRUCT_STAT64 { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; __DARWIN_STRUCT_STAT64_TIMES off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; }
# 182 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
struct stat { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
struct stat64 { dev_t st_dev; mode_t st_mode; nlink_t st_nlink; __darwin_ino64_t st_ino; uid_t st_uid; gid_t st_gid; dev_t st_rdev; struct timespec st_atimespec; struct timespec st_mtimespec; struct timespec st_ctimespec; struct timespec st_birthtimespec; off_t st_size; blkcnt_t st_blocks; blksize_t st_blksize; __uint32_t st_flags; __uint32_t st_gen; __int32_t st_lspare; __int64_t st_qspare[2]; };
# 231 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
#define st_atime st_atimespec.tv_sec
#define st_mtime st_mtimespec.tv_sec
#define st_ctime st_ctimespec.tv_sec
#define st_birthtime st_birthtimespec.tv_sec






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_s_ifmt.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_s_ifmt.h" 3 4
#define S_IFMT 0170000
#define S_IFIFO 0010000
#define S_IFCHR 0020000
#define S_IFDIR 0040000
#define S_IFBLK 0060000
#define S_IFREG 0100000
#define S_IFLNK 0120000
#define S_IFSOCK 0140000

#define S_IFWHT 0160000




#define S_IRWXU 0000700
#define S_IRUSR 0000400
#define S_IWUSR 0000200
#define S_IXUSR 0000100

#define S_IRWXG 0000070
#define S_IRGRP 0000040
#define S_IWGRP 0000020
#define S_IXGRP 0000010

#define S_IRWXO 0000007
#define S_IROTH 0000004
#define S_IWOTH 0000002
#define S_IXOTH 0000001

#define S_ISUID 0004000
#define S_ISGID 0002000
#define S_ISVTX 0001000


#define S_ISTXT S_ISVTX
#define S_IREAD S_IRUSR
#define S_IWRITE S_IWUSR
#define S_IEXEC S_IXUSR
# 242 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4







#define S_ISBLK(m) (((m) & S_IFMT) == S_IFBLK)
#define S_ISCHR(m) (((m) & S_IFMT) == S_IFCHR)
#define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
#define S_ISFIFO(m) (((m) & S_IFMT) == S_IFIFO)
#define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)
#define S_ISSOCK(m) (((m) & S_IFMT) == S_IFSOCK)

#define S_ISWHT(m) (((m) & S_IFMT) == S_IFWHT)
# 275 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
#define S_TYPEISMQ(buf) (0)
#define S_TYPEISSEM(buf) (0)
#define S_TYPEISSHM(buf) (0)
# 293 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
#define S_TYPEISTMO(buf) (0)



#define ACCESSPERMS (S_IRWXU|S_IRWXG|S_IRWXO)

#define ALLPERMS (S_ISUID|S_ISGID|S_ISTXT|S_IRWXU|S_IRWXG|S_IRWXO)

#define DEFFILEMODE (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)

#define S_BLKSIZE 512






#define UF_SETTABLE 0x0000ffff
#define UF_NODUMP 0x00000001
#define UF_IMMUTABLE 0x00000002
#define UF_APPEND 0x00000004
#define UF_OPAQUE 0x00000008





#define UF_COMPRESSED 0x00000020



#define UF_TRACKED 0x00000040

#define UF_DATAVAULT 0x00000080



#define UF_HIDDEN 0x00008000




#define SF_SUPPORTED 0x009f0000
#define SF_SETTABLE 0x3fff0000
#define SF_SYNTHETIC 0xc0000000
#define SF_ARCHIVED 0x00010000
#define SF_IMMUTABLE 0x00020000
#define SF_APPEND 0x00040000
#define SF_RESTRICTED 0x00080000
#define SF_NOUNLINK 0x00100000
# 351 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
#define SF_FIRMLINK 0x00800000







#define SF_DATALESS 0x40000000
# 368 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 3 4
#define EF_MAY_SHARE_BLOCKS 0x00000001
#define EF_NO_XATTRS 0x00000002
#define EF_IS_SYNC_ROOT 0x00000004
#define EF_IS_PURGEABLE 0x00000008
#define EF_IS_SPARSE 0x00000010
#define EF_IS_SYNTHETIC 0x00000020






int chmod(const char *, mode_t) __asm("_" "chmod" );
int fchmod(int, mode_t) __asm("_" "fchmod" );
int fstat(int, struct stat *) __asm("_" "fstat" "$INODE64");
int lstat(const char *, struct stat *) __asm("_" "lstat" "$INODE64");
int mkdir(const char *, mode_t);
int mkfifo(const char *, mode_t);
int stat(const char *, struct stat *) __asm("_" "stat" "$INODE64");
int mknod(const char *, mode_t, dev_t);
mode_t umask(mode_t);


int fchmodat(int, const char *, mode_t, int) ;
int fstatat(int, const char *, struct stat *, int) __asm("_" "fstatat" "$INODE64") ;
int mkdirat(int, const char *, mode_t) ;

#define UTIME_NOW -1
#define UTIME_OMIT -2

int futimens(int __fd, const struct timespec __times[2]) ;
int utimensat(int __fd, const char *__path, const struct timespec __times[2],
    int __flag) ;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_filesec_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_filesec_t.h" 3 4
#define _FILESEC_T 
struct _filesec;
typedef struct _filesec *filesec_t;
# 406 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stat.h" 2 3 4

int chflags(const char *, __uint32_t);
int chmodx_np(const char *, filesec_t);
int fchflags(int, __uint32_t);
int fchmodx_np(int, filesec_t);
int fstatx_np(int, struct stat *, filesec_t) __asm("_" "fstatx_np" "$INODE64");
int lchflags(const char *, __uint32_t) ;
int lchmod(const char *, mode_t) ;
int lstatx_np(const char *, struct stat *, filesec_t) __asm("_" "lstatx_np" "$INODE64");
int mkdirx_np(const char *, filesec_t);
int mkfifox_np(const char *, filesec_t);
int statx_np(const char *, struct stat *, filesec_t) __asm("_" "statx_np" "$INODE64");
int umaskx_np(filesec_t) ;



int fstatx64_np(int, struct stat64 *, filesec_t) ;
int lstatx64_np(const char *, struct stat64 *, filesec_t) ;
int statx64_np(const char *, struct stat64 *, filesec_t) ;
int fstat64(int, struct stat64 *) ;
int lstat64(const char *, struct stat64 *) ;
int stat64(const char *, struct stat64 *) ;




# 49 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/statvfs.h" 1 3 4
# 28 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/statvfs.h" 3 4
#define _SYS_STATVFS_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fsblkcnt_t.h" 3 4
#define _FSBLKCNT_T 

typedef __darwin_fsblkcnt_t fsblkcnt_t;
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/statvfs.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fsfilcnt_t.h" 3 4
#define _FSFILCNT_T 

typedef __darwin_fsfilcnt_t fsfilcnt_t;
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/statvfs.h" 2 3 4


struct statvfs {
 unsigned long f_bsize;
 unsigned long f_frsize;
 fsblkcnt_t f_blocks;
 fsblkcnt_t f_bfree;
 fsblkcnt_t f_bavail;
 fsfilcnt_t f_files;
 fsfilcnt_t f_ffree;
 fsfilcnt_t f_favail;
 unsigned long f_fsid;
 unsigned long f_flag;
 unsigned long f_namemax;
};


#define ST_RDONLY 0x00000001
#define ST_NOSUID 0x00000002


int fstatvfs(int, struct statvfs *);
int statvfs(const char * restrict, struct statvfs * restrict);

# 50 "project/nnn/src/nnn.c" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 3 4
#define _SYS_TYPES_H_ 
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/endian.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/endian.h" 3 4
#define _BSD_MACHINE_ENDIAN_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/endian.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/endian.h" 3 4
#define _I386__ENDIAN_H_ 
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/endian.h" 3 4
#define _QUAD_HIGHWORD 1
#define _QUAD_LOWWORD 0





#define __DARWIN_LITTLE_ENDIAN 1234
#define __DARWIN_BIG_ENDIAN 4321
#define __DARWIN_PDP_ENDIAN 3412

#define __DARWIN_BYTE_ORDER __DARWIN_LITTLE_ENDIAN



#define LITTLE_ENDIAN __DARWIN_LITTLE_ENDIAN
#define BIG_ENDIAN __DARWIN_BIG_ENDIAN
#define PDP_ENDIAN __DARWIN_PDP_ENDIAN

#define BYTE_ORDER __DARWIN_BYTE_ORDER

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_endian.h" 1 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_endian.h" 3 4
#define _SYS__ENDIAN_H_ 
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_endian.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/_OSByteOrder.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
#define _OS__OSBYTEORDER_H 
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
#define __DARWIN_OSSwapConstInt16(x) ((__uint16_t)((((__uint16_t)(x) & 0xff00U) >> 8) | (((__uint16_t)(x) & 0x00ffU) << 8)))



#define __DARWIN_OSSwapConstInt32(x) ((__uint32_t)((((__uint32_t)(x) & 0xff000000U) >> 24) | (((__uint32_t)(x) & 0x00ff0000U) >> 8) | (((__uint32_t)(x) & 0x0000ff00U) << 8) | (((__uint32_t)(x) & 0x000000ffU) << 24)))





#define __DARWIN_OSSwapConstInt64(x) ((__uint64_t)((((__uint64_t)(x) & 0xff00000000000000ULL) >> 56) | (((__uint64_t)(x) & 0x00ff000000000000ULL) >> 40) | (((__uint64_t)(x) & 0x0000ff0000000000ULL) >> 24) | (((__uint64_t)(x) & 0x000000ff00000000ULL) >> 8) | (((__uint64_t)(x) & 0x00000000ff000000ULL) << 8) | (((__uint64_t)(x) & 0x0000000000ff0000ULL) << 24) | (((__uint64_t)(x) & 0x000000000000ff00ULL) << 40) | (((__uint64_t)(x) & 0x00000000000000ffULL) << 56)))
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
#define __DARWIN_OS_INLINE static inline
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/_OSByteOrder.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/i386/_OSByteOrder.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
#define _OS__OSBYTEORDERI386_H 
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint16_t
_OSSwapInt16(
 __uint16_t _data
 )
{
 return (__uint16_t)((_data << 8) | (_data >> 8));
}

static inline
__uint32_t
_OSSwapInt32(
 __uint32_t _data
 )
{



 __asm__ ("bswap   %0" : "+r" (_data));
 return _data;

}
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/i386/_OSByteOrder.h" 3 4
static inline
__uint64_t
_OSSwapInt64(
 __uint64_t _data
 )
{
 __asm__ ("bswap   %0" : "+r" (_data));
 return _data;
}
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libkern/_OSByteOrder.h" 2 3 4







#define __DARWIN_OSSwapInt16(x) ((__uint16_t)(__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt16(x) : _OSSwapInt16(x)))


#define __DARWIN_OSSwapInt32(x) (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt32(x) : _OSSwapInt32(x))


#define __DARWIN_OSSwapInt64(x) (__builtin_constant_p(x) ? __DARWIN_OSSwapConstInt64(x) : _OSSwapInt64(x))
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_endian.h" 2 3 4

#define ntohs(x) __DARWIN_OSSwapInt16(x)
#define htons(x) __DARWIN_OSSwapInt16(x)

#define ntohl(x) __DARWIN_OSSwapInt32(x)
#define htonl(x) __DARWIN_OSSwapInt32(x)



#define ntohll(x) __DARWIN_OSSwapInt64(x)
#define htonll(x) __DARWIN_OSSwapInt64(x)

#define NTOHL(x) (x) = ntohl((__uint32_t)x)
#define NTOHS(x) (x) = ntohs((__uint16_t)x)
#define NTOHLL(x) (x) = ntohll((__uint64_t)x)
#define HTONL(x) (x) = htonl((__uint32_t)x)
#define HTONS(x) (x) = htons((__uint16_t)x)
#define HTONLL(x) (x) = htonll((__uint64_t)x)
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/endian.h" 2 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/endian.h" 2 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_char.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_char.h" 3 4
#define _U_CHAR 
typedef unsigned char u_char;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_short.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_short.h" 3 4
#define _U_SHORT 
typedef unsigned short u_short;
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int.h" 3 4
#define _U_INT 
typedef unsigned int u_int;
# 87 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4

typedef unsigned long u_long;
#define _U_LONG 

typedef unsigned short ushort;
typedef unsigned int uint;


typedef u_int64_t u_quad_t;
typedef int64_t quad_t;
typedef quad_t * qaddr_t;

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_caddr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_caddr_t.h" 3 4
#define _CADDR_T 
typedef char * caddr_t;
# 100 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4

typedef int32_t daddr_t;



typedef u_int32_t fixpt_t;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_in_addr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_in_addr_t.h" 3 4
#define _IN_ADDR_T 

typedef __uint32_t in_addr_t;
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_in_port_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_in_port_t.h" 3 4
#define _IN_PORT_T 

typedef __uint16_t in_port_t;
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_key_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_key_t.h" 3 4
#define _KEY_T 

typedef __int32_t key_t;
# 119 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_pid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_pid_t.h" 3 4
#define _PID_T 

typedef __darwin_pid_t pid_t;
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4


typedef int32_t segsz_t;
typedef int32_t swblk_t;
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 3 4
#define major(x) ((int32_t)(((u_int32_t)(x) >> 24) & 0xff))
#define minor(x) ((int32_t)((x) & 0xffffff))
#define makedev(x,y) ((dev_t)(((x) << 24) | (y)))




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_clock_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_clock_t.h" 3 4
#define _CLOCK_T 

typedef __darwin_clock_t clock_t;
# 166 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_size_t.h" 3 4
#define _SIZE_T 

typedef __darwin_size_t size_t;
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
#define _SSIZE_T 

typedef __darwin_ssize_t ssize_t;
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_useconds_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_useconds_t.h" 3 4
#define _USECONDS_T 

typedef __darwin_useconds_t useconds_t;
# 171 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_suseconds_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_suseconds_t.h" 3 4
#define _SUSECONDS_T 

typedef __darwin_suseconds_t suseconds_t;
# 172 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_rsize_t.h" 3 4
#define _RSIZE_T 

typedef __darwin_size_t rsize_t;
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_errno_t.h" 3 4
#define _ERRNO_T 
typedef int errno_t;
# 176 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_def.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_def.h" 3 4
#define _FD_SET 
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_def.h" 3 4
#define __DARWIN_FD_SETSIZE 1024

#define __DARWIN_NBBY 8
#define __DARWIN_NFDBITS (sizeof(__int32_t) * __DARWIN_NBBY)
#define __DARWIN_howmany(x,y) ((((x) % (y)) == 0) ? ((x) / (y)) : (((x) / (y)) + 1))


typedef struct fd_set {
 __int32_t fds_bits[((((1024) % ((sizeof(__int32_t) * 8))) == 0) ? ((1024) / ((sizeof(__int32_t) * 8))) : (((1024) / ((sizeof(__int32_t) * 8))) + 1))];
} fd_set;

int __darwin_check_fd_set_overflow(int, const void *, int) ;


extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int
__darwin_check_fd_set(int _a, const void *_b)
{




 if ((uintptr_t)&__darwin_check_fd_set_overflow != (uintptr_t) 0) {



  return __darwin_check_fd_set_overflow(_a, _b, 0);

 } else {
  return 1;
 }



}


extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int
__darwin_fd_isset(int _fd, const struct fd_set *_p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  return _p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] & ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8))));
 }

 return 0;
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void
__darwin_fd_set(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] |= ((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) void
__darwin_fd_clr(int _fd, struct fd_set *const _p)
{
 if (__darwin_check_fd_set(_fd, (const void *) _p)) {
  (_p->fds_bits[(unsigned long)_fd / (sizeof(__int32_t) * 8)] &= ~((__int32_t)(((unsigned long)1) << ((unsigned long)_fd % (sizeof(__int32_t) * 8)))));
 }
}


#define __DARWIN_FD_SET(n,p) __darwin_fd_set((n), (p))
#define __DARWIN_FD_CLR(n,p) __darwin_fd_clr((n), (p))
#define __DARWIN_FD_ISSET(n,p) __darwin_fd_isset((n), (p))






#define __DARWIN_FD_ZERO(p) __builtin_bzero(p, sizeof(*(p)))




#define __DARWIN_FD_COPY(f,t) bcopy(f, t, sizeof(*(f)))
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4

#define NBBY __DARWIN_NBBY
#define NFDBITS __DARWIN_NFDBITS
#define howmany(x,y) __DARWIN_howmany(x, y)
typedef __int32_t fd_mask;







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_setsize.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_setsize.h" 3 4
#define FD_SETSIZE __DARWIN_FD_SETSIZE
# 198 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_set.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_set.h" 3 4
#define FD_SET(n,p) __DARWIN_FD_SET(n, p)
# 199 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_clr.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_clr.h" 3 4
#define FD_CLR(n,p) __DARWIN_FD_CLR(n, p)
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_zero.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_zero.h" 3 4
#define FD_ZERO(p) __DARWIN_FD_ZERO(p)
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_isset.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_isset.h" 3 4
#define FD_ISSET(n,p) __DARWIN_FD_ISSET(n, p)
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_copy.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_fd_copy.h" 3 4
#define FD_COPY(f,t) __DARWIN_FD_COPY(f, t)
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 215 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_attr_t.h" 3 4
#define _PTHREAD_ATTR_T 

typedef __darwin_pthread_attr_t pthread_attr_t;
# 216 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_cond_t.h" 3 4
#define _PTHREAD_COND_T 

typedef __darwin_pthread_cond_t pthread_cond_t;
# 217 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_condattr_t.h" 3 4
#define _PTHREAD_CONDATTR_T 

typedef __darwin_pthread_condattr_t pthread_condattr_t;
# 218 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_mutex_t.h" 3 4
#define _PTHREAD_MUTEX_T 

typedef __darwin_pthread_mutex_t pthread_mutex_t;
# 219 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_mutexattr_t.h" 3 4
#define _PTHREAD_MUTEXATTR_T 

typedef __darwin_pthread_mutexattr_t pthread_mutexattr_t;
# 220 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_once_t.h" 3 4
#define _PTHREAD_ONCE_T 

typedef __darwin_pthread_once_t pthread_once_t;
# 221 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_rwlock_t.h" 3 4
#define _PTHREAD_RWLOCK_T 

typedef __darwin_pthread_rwlock_t pthread_rwlock_t;
# 222 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_rwlockattr_t.h" 3 4
#define _PTHREAD_RWLOCKATTR_T 

typedef __darwin_pthread_rwlockattr_t pthread_rwlockattr_t;
# 223 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_t.h" 3 4
#define _PTHREAD_T 

typedef __darwin_pthread_t pthread_t;
# 224 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_key_t.h" 3 4
#define _PTHREAD_KEY_T 

typedef __darwin_pthread_key_t pthread_key_t;
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/types.h" 2 3 4
# 52 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define _SYS_EVENT_H_ 
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define EVFILT_READ (-1)
#define EVFILT_WRITE (-2)
#define EVFILT_AIO (-3)
#define EVFILT_VNODE (-4)
#define EVFILT_PROC (-5)
#define EVFILT_SIGNAL (-6)
#define EVFILT_TIMER (-7)
#define EVFILT_MACHPORT (-8)
#define EVFILT_FS (-9)
#define EVFILT_USER (-10)
#define EVFILT_VM (-12)
#define EVFILT_EXCEPT (-15)

#define EVFILT_SYSCOUNT 17
#define EVFILT_THREADMARKER EVFILT_SYSCOUNT

#pragma pack(4)

struct kevent {
 uintptr_t ident;
 int16_t filter;
 uint16_t flags;
 uint32_t fflags;
 intptr_t data;
 void *udata;
};


#pragma pack()

struct kevent64_s {
 uint64_t ident;
 int16_t filter;
 uint16_t flags;
 uint32_t fflags;
 int64_t data;
 uint64_t udata;
 uint64_t ext[2];
};


#define EV_SET(kevp,a,b,c,d,e,f) do { struct kevent *__kevp__ = (kevp); __kevp__->ident = (a); __kevp__->filter = (b); __kevp__->flags = (c); __kevp__->fflags = (d); __kevp__->data = (e); __kevp__->udata = (f); } while(0)
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define EV_SET64(kevp,a,b,c,d,e,f,g,h) do { struct kevent64_s *__kevp__ = (kevp); __kevp__->ident = (a); __kevp__->filter = (b); __kevp__->flags = (c); __kevp__->fflags = (d); __kevp__->data = (e); __kevp__->udata = (f); __kevp__->ext[0] = (g); __kevp__->ext[1] = (h); } while(0)
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define KEVENT_FLAG_NONE 0x000000
#define KEVENT_FLAG_IMMEDIATE 0x000001
#define KEVENT_FLAG_ERROR_EVENTS 0x000002



#define EV_ADD 0x0001
#define EV_DELETE 0x0002
#define EV_ENABLE 0x0004
#define EV_DISABLE 0x0008


#define EV_ONESHOT 0x0010
#define EV_CLEAR 0x0020
#define EV_RECEIPT 0x0040




#define EV_DISPATCH 0x0080
#define EV_UDATA_SPECIFIC 0x0100

#define EV_DISPATCH2 (EV_DISPATCH | EV_UDATA_SPECIFIC)





#define EV_VANISHED 0x0200


#define EV_SYSFLAGS 0xF000
#define EV_FLAG0 0x1000
#define EV_FLAG1 0x2000


#define EV_EOF 0x8000
#define EV_ERROR 0x4000
# 195 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define EV_POLL EV_FLAG0
#define EV_OOBAND EV_FLAG1
# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define NOTE_TRIGGER 0x01000000
# 214 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define NOTE_FFNOP 0x00000000
#define NOTE_FFAND 0x40000000
#define NOTE_FFOR 0x80000000
#define NOTE_FFCOPY 0xc0000000
#define NOTE_FFCTRLMASK 0xc0000000
#define NOTE_FFLAGSMASK 0x00ffffff
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define NOTE_LOWAT 0x00000001


#define NOTE_OOB 0x00000002




#define NOTE_DELETE 0x00000001
#define NOTE_WRITE 0x00000002
#define NOTE_EXTEND 0x00000004
#define NOTE_ATTRIB 0x00000008
#define NOTE_LINK 0x00000010
#define NOTE_RENAME 0x00000020
#define NOTE_REVOKE 0x00000040
#define NOTE_NONE 0x00000080
#define NOTE_FUNLOCK 0x00000100
# 256 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
enum {
 eNoteReapDeprecated = 0x10000000
};

#define NOTE_EXIT 0x80000000
#define NOTE_FORK 0x40000000
#define NOTE_EXEC 0x20000000
#define NOTE_REAP ((unsigned int)eNoteReapDeprecated )
#define NOTE_SIGNAL 0x08000000
#define NOTE_EXITSTATUS 0x04000000
#define NOTE_EXIT_DETAIL 0x02000000

#define NOTE_PDATAMASK 0x000fffff
#define NOTE_PCTRLMASK (~NOTE_PDATAMASK)




enum {
 eNoteExitReparentedDeprecated = 0x00080000
};
#define NOTE_EXIT_REPARENTED ((unsigned int)eNoteExitReparentedDeprecated)




#define NOTE_EXIT_DETAIL_MASK 0x00070000
#define NOTE_EXIT_DECRYPTFAIL 0x00010000
#define NOTE_EXIT_MEMORY 0x00020000
#define NOTE_EXIT_CSERROR 0x00040000





#define NOTE_VM_PRESSURE 0x80000000
#define NOTE_VM_PRESSURE_TERMINATE 0x40000000
#define NOTE_VM_PRESSURE_SUDDEN_TERMINATE 0x20000000
#define NOTE_VM_ERROR 0x10000000
# 304 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define NOTE_SECONDS 0x00000001
#define NOTE_USECONDS 0x00000002
#define NOTE_NSECONDS 0x00000004
#define NOTE_ABSOLUTE 0x00000008

#define NOTE_LEEWAY 0x00000010
#define NOTE_CRITICAL 0x00000020
#define NOTE_BACKGROUND 0x00000040
#define NOTE_MACH_CONTINUOUS_TIME 0x00000080







#define NOTE_MACHTIME 0x00000100
# 362 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 3 4
#define NOTE_TRACK 0x00000001
#define NOTE_TRACKERR 0x00000002
#define NOTE_CHILD 0x00000004




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 1 3 4
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define _SYS_QUEUE_H_ 


#define __improbable(x) (x)
# 174 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define QMD_TRACE_ELEM(elem) 
#define QMD_TRACE_HEAD(head) 
#define TRACEBUF 
#define TRASHIT(x) 
# 201 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define __MISMATCH_TAGS_PUSH 
#define __MISMATCH_TAGS_POP 
# 229 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define __NULLABILITY_COMPLETENESS_PUSH 
#define __NULLABILITY_COMPLETENESS_POP 





#define SLIST_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *slh_first; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 245 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define SLIST_HEAD_INITIALIZER(head) { NULL }


#define SLIST_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *sle_next; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 260 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define SLIST_EMPTY(head) ((head)->slh_first == NULL)

#define SLIST_FIRST(head) ((head)->slh_first)

#define SLIST_FOREACH(var,head,field) for ((var) = SLIST_FIRST((head)); (var); (var) = SLIST_NEXT((var), field))




#define SLIST_FOREACH_SAFE(var,head,field,tvar) for ((var) = SLIST_FIRST((head)); (var) && ((tvar) = SLIST_NEXT((var), field), 1); (var) = (tvar))




#define SLIST_FOREACH_PREVPTR(var,varp,head,field) for ((varp) = &SLIST_FIRST((head)); ((var) = *(varp)) != NULL; (varp) = &SLIST_NEXT((var), field))




#define SLIST_INIT(head) do { SLIST_FIRST((head)) = NULL; } while (0)



#define SLIST_INSERT_AFTER(slistelm,elm,field) do { SLIST_NEXT((elm), field) = SLIST_NEXT((slistelm), field); SLIST_NEXT((slistelm), field) = (elm); } while (0)




#define SLIST_INSERT_HEAD(head,elm,field) do { SLIST_NEXT((elm), field) = SLIST_FIRST((head)); SLIST_FIRST((head)) = (elm); } while (0)




#define SLIST_NEXT(elm,field) ((elm)->field.sle_next)

#define SLIST_REMOVE(head,elm,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { if (SLIST_FIRST((head)) == (elm)) { SLIST_REMOVE_HEAD((head), field); } else { struct type *curelm = SLIST_FIRST((head)); while (SLIST_NEXT(curelm, field) != (elm)) curelm = SLIST_NEXT(curelm, field); SLIST_REMOVE_AFTER(curelm, field); } TRASHIT((elm)->field.sle_next); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 313 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define SLIST_REMOVE_AFTER(elm,field) do { SLIST_NEXT(elm, field) = SLIST_NEXT(SLIST_NEXT(elm, field), field); } while (0)




#define SLIST_REMOVE_HEAD(head,field) do { SLIST_FIRST((head)) = SLIST_NEXT(SLIST_FIRST((head)), field); } while (0)






#define STAILQ_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *stqh_first; struct type **stqh_last; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 335 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_HEAD_INITIALIZER(head) { NULL, &(head).stqh_first }


#define STAILQ_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *stqe_next; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 350 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_CONCAT(head1,head2) do { if (!STAILQ_EMPTY((head2))) { *(head1)->stqh_last = (head2)->stqh_first; (head1)->stqh_last = (head2)->stqh_last; STAILQ_INIT((head2)); } } while (0)







#define STAILQ_EMPTY(head) ((head)->stqh_first == NULL)

#define STAILQ_FIRST(head) ((head)->stqh_first)

#define STAILQ_FOREACH(var,head,field) for((var) = STAILQ_FIRST((head)); (var); (var) = STAILQ_NEXT((var), field))





#define STAILQ_FOREACH_SAFE(var,head,field,tvar) for ((var) = STAILQ_FIRST((head)); (var) && ((tvar) = STAILQ_NEXT((var), field), 1); (var) = (tvar))




#define STAILQ_INIT(head) do { STAILQ_FIRST((head)) = NULL; (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)




#define STAILQ_INSERT_AFTER(head,tqelm,elm,field) do { if ((STAILQ_NEXT((elm), field) = STAILQ_NEXT((tqelm), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_NEXT((tqelm), field) = (elm); } while (0)





#define STAILQ_INSERT_HEAD(head,elm,field) do { if ((STAILQ_NEXT((elm), field) = STAILQ_FIRST((head))) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); STAILQ_FIRST((head)) = (elm); } while (0)





#define STAILQ_INSERT_TAIL(head,elm,field) do { STAILQ_NEXT((elm), field) = NULL; *(head)->stqh_last = (elm); (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)





#define STAILQ_LAST(head,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (STAILQ_EMPTY((head)) ? NULL : ((struct type *)(void *) ((char *)((head)->stqh_last) - __offsetof(struct type, field))))__NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 406 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_NEXT(elm,field) ((elm)->field.stqe_next)

#define STAILQ_REMOVE(head,elm,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { if (STAILQ_FIRST((head)) == (elm)) { STAILQ_REMOVE_HEAD((head), field); } else { struct type *curelm = STAILQ_FIRST((head)); while (STAILQ_NEXT(curelm, field) != (elm)) curelm = STAILQ_NEXT(curelm, field); STAILQ_REMOVE_AFTER(head, curelm, field); } TRASHIT((elm)->field.stqe_next); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 426 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define STAILQ_REMOVE_HEAD(head,field) do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT(STAILQ_FIRST((head)), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)





#define STAILQ_REMOVE_HEAD_UNTIL(head,elm,field) do { if ((STAILQ_FIRST((head)) = STAILQ_NEXT((elm), field)) == NULL) (head)->stqh_last = &STAILQ_FIRST((head)); } while (0)




#define STAILQ_REMOVE_AFTER(head,elm,field) do { if ((STAILQ_NEXT(elm, field) = STAILQ_NEXT(STAILQ_NEXT(elm, field), field)) == NULL) (head)->stqh_last = &STAILQ_NEXT((elm), field); } while (0)





#define STAILQ_SWAP(head1,head2,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_first = STAILQ_FIRST(head1); struct type **swap_last = (head1)->stqh_last; STAILQ_FIRST(head1) = STAILQ_FIRST(head2); (head1)->stqh_last = (head2)->stqh_last; STAILQ_FIRST(head2) = swap_first; (head2)->stqh_last = swap_last; if (STAILQ_EMPTY(head1)) (head1)->stqh_last = &STAILQ_FIRST(head1); if (STAILQ_EMPTY(head2)) (head2)->stqh_last = &STAILQ_FIRST(head2); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 465 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define LIST_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *lh_first; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 474 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define LIST_HEAD_INITIALIZER(head) { NULL }


#define LIST_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *le_next; struct type **le_prev; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 491 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define LIST_CHECK_HEAD(head,field) 
#define LIST_CHECK_NEXT(elm,field) 
#define LIST_CHECK_PREV(elm,field) 

#define LIST_EMPTY(head) ((head)->lh_first == NULL)

#define LIST_FIRST(head) ((head)->lh_first)

#define LIST_FOREACH(var,head,field) for ((var) = LIST_FIRST((head)); (var); (var) = LIST_NEXT((var), field))




#define LIST_FOREACH_SAFE(var,head,field,tvar) for ((var) = LIST_FIRST((head)); (var) && ((tvar) = LIST_NEXT((var), field), 1); (var) = (tvar))




#define LIST_INIT(head) do { LIST_FIRST((head)) = NULL; } while (0)



#define LIST_INSERT_AFTER(listelm,elm,field) do { LIST_CHECK_NEXT(listelm, field); if ((LIST_NEXT((elm), field) = LIST_NEXT((listelm), field)) != NULL) LIST_NEXT((listelm), field)->field.le_prev = &LIST_NEXT((elm), field); LIST_NEXT((listelm), field) = (elm); (elm)->field.le_prev = &LIST_NEXT((listelm), field); } while (0)
# 522 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define LIST_INSERT_BEFORE(listelm,elm,field) do { LIST_CHECK_PREV(listelm, field); (elm)->field.le_prev = (listelm)->field.le_prev; LIST_NEXT((elm), field) = (listelm); *(listelm)->field.le_prev = (elm); (listelm)->field.le_prev = &LIST_NEXT((elm), field); } while (0)







#define LIST_INSERT_HEAD(head,elm,field) do { LIST_CHECK_HEAD((head), field); if ((LIST_NEXT((elm), field) = LIST_FIRST((head))) != NULL) LIST_FIRST((head))->field.le_prev = &LIST_NEXT((elm), field); LIST_FIRST((head)) = (elm); (elm)->field.le_prev = &LIST_FIRST((head)); } while (0)







#define LIST_NEXT(elm,field) ((elm)->field.le_next)

#define LIST_REMOVE(elm,field) do { LIST_CHECK_NEXT(elm, field); LIST_CHECK_PREV(elm, field); if (LIST_NEXT((elm), field) != NULL) LIST_NEXT((elm), field)->field.le_prev = (elm)->field.le_prev; *(elm)->field.le_prev = LIST_NEXT((elm), field); TRASHIT((elm)->field.le_next); TRASHIT((elm)->field.le_prev); } while (0)
# 551 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define LIST_SWAP(head1,head2,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_tmp = LIST_FIRST((head1)); LIST_FIRST((head1)) = LIST_FIRST((head2)); LIST_FIRST((head2)) = swap_tmp; if ((swap_tmp = LIST_FIRST((head1))) != NULL) swap_tmp->field.le_prev = &LIST_FIRST((head1)); if ((swap_tmp = LIST_FIRST((head2))) != NULL) swap_tmp->field.le_prev = &LIST_FIRST((head2)); } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 569 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *tqh_first; struct type **tqh_last; TRACEBUF } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 580 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_HEAD_INITIALIZER(head) { NULL, &(head).tqh_first }


#define TAILQ_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *tqe_next; struct type **tqe_prev; TRACEBUF } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 597 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_CHECK_HEAD(head,field) 
#define TAILQ_CHECK_NEXT(elm,field) 
#define TAILQ_CHECK_PREV(elm,field) 

#define TAILQ_CONCAT(head1,head2,field) do { if (!TAILQ_EMPTY(head2)) { *(head1)->tqh_last = (head2)->tqh_first; (head2)->tqh_first->field.tqe_prev = (head1)->tqh_last; (head1)->tqh_last = (head2)->tqh_last; TAILQ_INIT((head2)); QMD_TRACE_HEAD(head1); QMD_TRACE_HEAD(head2); } } while (0)
# 612 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_EMPTY(head) ((head)->tqh_first == NULL)

#define TAILQ_FIRST(head) ((head)->tqh_first)

#define TAILQ_FOREACH(var,head,field) for ((var) = TAILQ_FIRST((head)); (var); (var) = TAILQ_NEXT((var), field))




#define TAILQ_FOREACH_SAFE(var,head,field,tvar) for ((var) = TAILQ_FIRST((head)); (var) && ((tvar) = TAILQ_NEXT((var), field), 1); (var) = (tvar))




#define TAILQ_FOREACH_REVERSE(var,head,headname,field) for ((var) = TAILQ_LAST((head), headname); (var); (var) = TAILQ_PREV((var), headname, field))




#define TAILQ_FOREACH_REVERSE_SAFE(var,head,headname,field,tvar) for ((var) = TAILQ_LAST((head), headname); (var) && ((tvar) = TAILQ_PREV((var), headname, field), 1); (var) = (tvar))





#define TAILQ_INIT(head) do { TAILQ_FIRST((head)) = NULL; (head)->tqh_last = &TAILQ_FIRST((head)); QMD_TRACE_HEAD(head); } while (0)






#define TAILQ_INSERT_AFTER(head,listelm,elm,field) do { TAILQ_CHECK_NEXT(listelm, field); if ((TAILQ_NEXT((elm), field) = TAILQ_NEXT((listelm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = &TAILQ_NEXT((elm), field); else { (head)->tqh_last = &TAILQ_NEXT((elm), field); QMD_TRACE_HEAD(head); } TAILQ_NEXT((listelm), field) = (elm); (elm)->field.tqe_prev = &TAILQ_NEXT((listelm), field); QMD_TRACE_ELEM(&(elm)->field); QMD_TRACE_ELEM(&listelm->field); } while (0)
# 659 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_INSERT_BEFORE(listelm,elm,field) do { TAILQ_CHECK_PREV(listelm, field); (elm)->field.tqe_prev = (listelm)->field.tqe_prev; TAILQ_NEXT((elm), field) = (listelm); *(listelm)->field.tqe_prev = (elm); (listelm)->field.tqe_prev = &TAILQ_NEXT((elm), field); QMD_TRACE_ELEM(&(elm)->field); QMD_TRACE_ELEM(&listelm->field); } while (0)
# 669 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_INSERT_HEAD(head,elm,field) do { TAILQ_CHECK_HEAD(head, field); if ((TAILQ_NEXT((elm), field) = TAILQ_FIRST((head))) != NULL) TAILQ_FIRST((head))->field.tqe_prev = &TAILQ_NEXT((elm), field); else (head)->tqh_last = &TAILQ_NEXT((elm), field); TAILQ_FIRST((head)) = (elm); (elm)->field.tqe_prev = &TAILQ_FIRST((head)); QMD_TRACE_HEAD(head); QMD_TRACE_ELEM(&(elm)->field); } while (0)
# 682 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_INSERT_TAIL(head,elm,field) do { TAILQ_NEXT((elm), field) = NULL; (elm)->field.tqe_prev = (head)->tqh_last; *(head)->tqh_last = (elm); (head)->tqh_last = &TAILQ_NEXT((elm), field); QMD_TRACE_HEAD(head); QMD_TRACE_ELEM(&(elm)->field); } while (0)
# 691 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_LAST(head,headname) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (*(((struct headname *)((head)->tqh_last))->tqh_last)) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP






#define TAILQ_NEXT(elm,field) ((elm)->field.tqe_next)

#define TAILQ_PREV(elm,headname,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH (*(((struct headname *)((elm)->field.tqe_prev))->tqh_last)) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP






#define TAILQ_REMOVE(head,elm,field) do { TAILQ_CHECK_NEXT(elm, field); TAILQ_CHECK_PREV(elm, field); if ((TAILQ_NEXT((elm), field)) != NULL) TAILQ_NEXT((elm), field)->field.tqe_prev = (elm)->field.tqe_prev; else { (head)->tqh_last = (elm)->field.tqe_prev; QMD_TRACE_HEAD(head); } *(elm)->field.tqe_prev = TAILQ_NEXT((elm), field); TRASHIT((elm)->field.tqe_next); TRASHIT((elm)->field.tqe_prev); QMD_TRACE_ELEM(&(elm)->field); } while (0)
# 726 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define TAILQ_SWAP(head1,head2,type,field) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH do { struct type *swap_first = (head1)->tqh_first; struct type **swap_last = (head1)->tqh_last; (head1)->tqh_first = (head2)->tqh_first; (head1)->tqh_last = (head2)->tqh_last; (head2)->tqh_first = swap_first; (head2)->tqh_last = swap_last; if ((swap_first = (head1)->tqh_first) != NULL) swap_first->field.tqe_prev = &(head1)->tqh_first; else (head1)->tqh_last = &(head1)->tqh_first; if ((swap_first = (head2)->tqh_first) != NULL) swap_first->field.tqe_prev = &(head2)->tqh_first; else (head2)->tqh_last = &(head2)->tqh_first; } while (0) __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 751 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_HEAD(name,type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct name { struct type *cqh_first; struct type *cqh_last; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 761 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_ENTRY(type) __MISMATCH_TAGS_PUSH __NULLABILITY_COMPLETENESS_PUSH struct { struct type *cqe_next; struct type *cqe_prev; } __NULLABILITY_COMPLETENESS_POP __MISMATCH_TAGS_POP
# 774 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_CHECK_HEAD(head,field) 
#define CIRCLEQ_CHECK_NEXT(head,elm,field) 
#define CIRCLEQ_CHECK_PREV(head,elm,field) 

#define CIRCLEQ_EMPTY(head) ((head)->cqh_first == (void *)(head))

#define CIRCLEQ_FIRST(head) ((head)->cqh_first)

#define CIRCLEQ_FOREACH(var,head,field) for((var) = (head)->cqh_first; (var) != (void *)(head); (var) = (var)->field.cqe_next)




#define CIRCLEQ_INIT(head) do { (head)->cqh_first = (void *)(head); (head)->cqh_last = (void *)(head); } while (0)




#define CIRCLEQ_INSERT_AFTER(head,listelm,elm,field) do { CIRCLEQ_CHECK_NEXT(head, listelm, field); (elm)->field.cqe_next = (listelm)->field.cqe_next; (elm)->field.cqe_prev = (listelm); if ((listelm)->field.cqe_next == (void *)(head)) (head)->cqh_last = (elm); else (listelm)->field.cqe_next->field.cqe_prev = (elm); (listelm)->field.cqe_next = (elm); } while (0)
# 803 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_INSERT_BEFORE(head,listelm,elm,field) do { CIRCLEQ_CHECK_PREV(head, listelm, field); (elm)->field.cqe_next = (listelm); (elm)->field.cqe_prev = (listelm)->field.cqe_prev; if ((listelm)->field.cqe_prev == (void *)(head)) (head)->cqh_first = (elm); else (listelm)->field.cqe_prev->field.cqe_next = (elm); (listelm)->field.cqe_prev = (elm); } while (0)
# 814 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_INSERT_HEAD(head,elm,field) do { CIRCLEQ_CHECK_HEAD(head, field); (elm)->field.cqe_next = (head)->cqh_first; (elm)->field.cqe_prev = (void *)(head); if ((head)->cqh_last == (void *)(head)) (head)->cqh_last = (elm); else (head)->cqh_first->field.cqe_prev = (elm); (head)->cqh_first = (elm); } while (0)
# 825 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_INSERT_TAIL(head,elm,field) do { (elm)->field.cqe_next = (void *)(head); (elm)->field.cqe_prev = (head)->cqh_last; if ((head)->cqh_first == (void *)(head)) (head)->cqh_first = (elm); else (head)->cqh_last->field.cqe_next = (elm); (head)->cqh_last = (elm); } while (0)
# 835 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/queue.h" 3 4
#define CIRCLEQ_LAST(head) ((head)->cqh_last)

#define CIRCLEQ_NEXT(elm,field) ((elm)->field.cqe_next)

#define CIRCLEQ_PREV(elm,field) ((elm)->field.cqe_prev)

#define CIRCLEQ_REMOVE(head,elm,field) do { CIRCLEQ_CHECK_NEXT(head, elm, field); CIRCLEQ_CHECK_PREV(head, elm, field); if ((elm)->field.cqe_next == (void *)(head)) (head)->cqh_last = (elm)->field.cqe_prev; else (elm)->field.cqe_next->field.cqe_prev = (elm)->field.cqe_prev; if ((elm)->field.cqe_prev == (void *)(head)) (head)->cqh_first = (elm)->field.cqe_next; else (elm)->field.cqe_prev->field.cqe_next = (elm)->field.cqe_next; } while (0)
# 370 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/event.h" 2 3 4
struct knote;
 struct klist { struct knote *slh_first; } ;




struct timespec;


int kqueue(void);
int kevent(int kq,
    const struct kevent *changelist, int nchanges,
    struct kevent *eventlist, int nevents,
    const struct timespec *timeout);
int kevent64(int kq,
    const struct kevent64_s *changelist, int nchanges,
    struct kevent64_s *eventlist, int nevents,
    unsigned int flags,
    const struct timespec *timeout);



# 53 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 3 4
#define _SYS_TIME_H_ 
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_timeval64.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_timeval64.h" 3 4
#define _STRUCT_TIMEVAL64 



struct timeval64 {
 __int64_t tv_sec;
 __int64_t tv_usec;
};
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 2 3 4
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 3 4
struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};





#define ITIMER_REAL 0
#define ITIMER_VIRTUAL 1
#define ITIMER_PROF 2
# 120 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 3 4
#define TIMEVAL_TO_TIMESPEC(tv,ts) { (ts)->tv_sec = (tv)->tv_sec; (ts)->tv_nsec = (tv)->tv_usec * 1000; }



#define TIMESPEC_TO_TIMEVAL(tv,ts) { (tv)->tv_sec = (ts)->tv_sec; (tv)->tv_usec = (ts)->tv_nsec / 1000; }




struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
#define DST_NONE 0
#define DST_USA 1
#define DST_AUST 2
#define DST_WET 3
#define DST_MET 4
#define DST_EET 5
#define DST_CAN 6


#define timerclear(tvp) (tvp)->tv_sec = (tvp)->tv_usec = 0
#define timerisset(tvp) ((tvp)->tv_sec || (tvp)->tv_usec)
#define timercmp(tvp,uvp,cmp) (((tvp)->tv_sec == (uvp)->tv_sec) ? ((tvp)->tv_usec cmp (uvp)->tv_usec) : ((tvp)->tv_sec cmp (uvp)->tv_sec))



#define timeradd(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec + (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec + (uvp)->tv_usec; if ((vvp)->tv_usec >= 1000000) { (vvp)->tv_sec++; (vvp)->tv_usec -= 1000000; } } while (0)
# 157 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 3 4
#define timersub(tvp,uvp,vvp) do { (vvp)->tv_sec = (tvp)->tv_sec - (uvp)->tv_sec; (vvp)->tv_usec = (tvp)->tv_usec - (uvp)->tv_usec; if ((vvp)->tv_usec < 0) { (vvp)->tv_sec--; (vvp)->tv_usec += 1000000; } } while (0)
# 167 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 3 4
#define timevalcmp(l,r,cmp) timercmp(l, r, cmp)




struct clockinfo {
 int hz;
 int tick;
 int tickadj;
 int stathz;
 int profhz;
};





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/time.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/time.h" 3 4
#define _TIME_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types.h" 3 4
#define __TYPES_H_ 





#define __strfmonlike(fmtarg,firstvararg) __attribute__((__format__ (__strfmon__, fmtarg, firstvararg)))

#define __strftimelike(fmtarg) __attribute__((__format__ (__strftime__, fmtarg, 0)))






typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;





#define __DARWIN_WCHAR_MAX __WCHAR_MAX__





#define __DARWIN_WCHAR_MIN (-0x7fffffff - 1)



#define __DARWIN_WEOF ((__darwin_wint_t)-1)





#define _FORTIFY_SOURCE 2
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/time.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_null.h" 3 4
#define NULL __DARWIN_NULL
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/time.h" 2 3 4




struct tm {
 int tm_sec;
 int tm_min;
 int tm_hour;
 int tm_mday;
 int tm_mon;
 int tm_year;
 int tm_wday;
 int tm_yday;
 int tm_isdst;
 long tm_gmtoff;
 char *tm_zone;
};


#define CLOCKS_PER_SEC 1000000







extern char *tzname[];


extern int getdate_err;

extern long timezone __asm("_" "timezone" );

extern int daylight;


char *asctime(const struct tm *);
clock_t clock(void) __asm("_" "clock" );
char *ctime(const time_t *);
double difftime(time_t, time_t);
struct tm *getdate(const char *);
struct tm *gmtime(const time_t *);
struct tm *localtime(const time_t *);
time_t mktime(struct tm *) __asm("_" "mktime" );
size_t strftime(char * restrict, size_t, const char * restrict, const struct tm * restrict) __asm("_" "strftime" );
char *strptime(const char * restrict, const char * restrict, struct tm * restrict) __asm("_" "strptime" );
time_t time(time_t *);


void tzset(void);



char *asctime_r(const struct tm * restrict, char * restrict);
char *ctime_r(const time_t *, char *);
struct tm *gmtime_r(const time_t * restrict, struct tm * restrict);
struct tm *localtime_r(const time_t * restrict, struct tm * restrict);


time_t posix2time(time_t);



void tzsetwall(void);
time_t time2posix(time_t);
time_t timelocal(struct tm * const);
time_t timegm(struct tm * const);



int nanosleep(const struct timespec *__rqtp, struct timespec *__rmtp) __asm("_" "nanosleep" );







#define __CLOCK_AVAILABILITY 


typedef enum {
_CLOCK_REALTIME = 0,
#define CLOCK_REALTIME _CLOCK_REALTIME
_CLOCK_MONOTONIC = 6,
#define CLOCK_MONOTONIC _CLOCK_MONOTONIC

_CLOCK_MONOTONIC_RAW = 4,
#define CLOCK_MONOTONIC_RAW _CLOCK_MONOTONIC_RAW
_CLOCK_MONOTONIC_RAW_APPROX = 5,
#define CLOCK_MONOTONIC_RAW_APPROX _CLOCK_MONOTONIC_RAW_APPROX
_CLOCK_UPTIME_RAW = 8,
#define CLOCK_UPTIME_RAW _CLOCK_UPTIME_RAW
_CLOCK_UPTIME_RAW_APPROX = 9,
#define CLOCK_UPTIME_RAW_APPROX _CLOCK_UPTIME_RAW_APPROX

_CLOCK_PROCESS_CPUTIME_ID = 12,
#define CLOCK_PROCESS_CPUTIME_ID _CLOCK_PROCESS_CPUTIME_ID
_CLOCK_THREAD_CPUTIME_ID = 16
#define CLOCK_THREAD_CPUTIME_ID _CLOCK_THREAD_CPUTIME_ID
} clockid_t;


int clock_getres(clockid_t __clock_id, struct timespec *__res);


int clock_gettime(clockid_t __clock_id, struct timespec *__tp);



__uint64_t clock_gettime_nsec_np(clockid_t __clock_id);




int clock_settime(clockid_t __clock_id, const struct timespec *__tp);

#undef __CLOCK_AVAILABILITY







#define TIME_UTC 1

int timespec_get(struct timespec *ts, int base);



# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 2 3 4





int adjtime(const struct timeval *, struct timeval *);
int futimes(int, const struct timeval *);
int lutimes(const char *, const struct timeval *) ;
int settimeofday(const struct timeval *, const struct timezone *);


int getitimer(int, struct itimerval *);
int gettimeofday(struct timeval * restrict, void * restrict);

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_select.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_select.h" 3 4
#define _SYS__SELECT_H_ 





int select(int, fd_set * restrict, fd_set * restrict,
    fd_set * restrict, struct timeval * restrict)





__asm("_" "select" "$1050")




;
# 200 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/time.h" 2 3 4

int setitimer(int, const struct itimerval * restrict,
    struct itimerval * restrict);
int utimes(const char *, const struct timeval *);


# 54 "project/nnn/src/nnn.c" 2
#define BSD_KQUEUE 






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
#define _SYS_WAIT_H_ 
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
typedef enum {
 P_ALL,
 P_PID,
 P_PGID
} idtype_t;
# 109 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 3 4
#define _SYS_SIGNAL_H_ 





#define __DARWIN_NSIG 32


#define NSIG __DARWIN_NSIG


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/signal.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/signal.h" 3 4
#define _BSD_MACHINE_SIGNAL_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/signal.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/signal.h" 3 4
#define _I386_SIGNAL_H_ 1




typedef int sig_atomic_t;
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/signal.h" 2 3 4
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 2 3 4

#define SIGHUP 1
#define SIGINT 2
#define SIGQUIT 3
#define SIGILL 4
#define SIGTRAP 5
#define SIGABRT 6



#define SIGIOT SIGABRT
#define SIGEMT 7

#define SIGFPE 8
#define SIGKILL 9
#define SIGBUS 10
#define SIGSEGV 11
#define SIGSYS 12
#define SIGPIPE 13
#define SIGALRM 14
#define SIGTERM 15
#define SIGURG 16
#define SIGSTOP 17
#define SIGTSTP 18
#define SIGCONT 19
#define SIGCHLD 20
#define SIGTTIN 21
#define SIGTTOU 22

#define SIGIO 23

#define SIGXCPU 24
#define SIGXFSZ 25
#define SIGVTALRM 26
#define SIGPROF 27

#define SIGWINCH 28
#define SIGINFO 29

#define SIGUSR1 30
#define SIGUSR2 31







#define SIG_DFL (void (*)(int))0
#define SIG_IGN (void (*)(int))1
#define SIG_HOLD (void (*)(int))5
#define SIG_ERR ((void (*)(int))-1)
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_mcontext.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_mcontext.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_mcontext.h" 3 4
#define __I386_MCONTEXT_H_ 



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/machine/_structs.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/machine/_structs.h" 3 4
#define _MACH_MACHINE__STRUCTS_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _MACH_I386__STRUCTS_H_ 
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_THREAD_STATE32 struct __darwin_i386_thread_state
struct __darwin_i386_thread_state
{
    unsigned int __eax;
    unsigned int __ebx;
    unsigned int __ecx;
    unsigned int __edx;
    unsigned int __edi;
    unsigned int __esi;
    unsigned int __ebp;
    unsigned int __esp;
    unsigned int __ss;
    unsigned int __eflags;
    unsigned int __eip;
    unsigned int __cs;
    unsigned int __ds;
    unsigned int __es;
    unsigned int __fs;
    unsigned int __gs;
};
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_FP_CONTROL struct __darwin_fp_control
struct __darwin_fp_control
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
      :2,
    __pc :2,

#define FP_PREC_24B 0
#define FP_PREC_53B 2
#define FP_PREC_64B 3

    __rc :2,

#define FP_RND_NEAR 0
#define FP_RND_DOWN 1
#define FP_RND_UP 2
#define FP_CHOP 3

             :1,
      :3;
};
typedef struct __darwin_fp_control __darwin_fp_control_t;
# 149 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_FP_STATUS struct __darwin_fp_status
struct __darwin_fp_status
{
    unsigned short __invalid :1,
        __denorm :1,
    __zdiv :1,
    __ovrfl :1,
    __undfl :1,
    __precis :1,
    __stkflt :1,
    __errsumm :1,
    __c0 :1,
    __c1 :1,
    __c2 :1,
    __tos :3,
    __c3 :1,
    __busy :1;
};
typedef struct __darwin_fp_status __darwin_fp_status_t;
# 193 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_MMST_REG struct __darwin_mmst_reg
struct __darwin_mmst_reg
{
 char __mmst_reg[10];
 char __mmst_rsrv[6];
};
# 212 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_XMM_REG struct __darwin_xmm_reg
struct __darwin_xmm_reg
{
 char __xmm_reg[16];
};
# 228 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_YMM_REG struct __darwin_ymm_reg
struct __darwin_ymm_reg
{
 char __ymm_reg[32];
};
# 244 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_ZMM_REG struct __darwin_zmm_reg
struct __darwin_zmm_reg
{
 char __zmm_reg[64];
};
# 258 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_OPMASK_REG struct __darwin_opmask_reg
struct __darwin_opmask_reg
{
 char __opmask_reg[8];
};
# 276 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define FP_STATE_BYTES 512



#define _STRUCT_X86_FLOAT_STATE32 struct __darwin_i386_float_state
struct __darwin_i386_float_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
};

#define _STRUCT_X86_AVX_STATE32 struct __darwin_i386_avx_state
struct __darwin_i386_avx_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
};

#define _STRUCT_X86_AVX512_STATE32 struct __darwin_i386_avx512_state
struct __darwin_i386_avx512_state
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;
 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;
 __uint16_t __fpu_rsrv2;
 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;
 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 char __fpu_rsrv4[14*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
};
# 574 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_EXCEPTION_STATE32 struct __darwin_i386_exception_state
struct __darwin_i386_exception_state
{
 __uint16_t __trapno;
 __uint16_t __cpu;
 __uint32_t __err;
 __uint32_t __faultvaddr;
};
# 594 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_DEBUG_STATE32 struct __darwin_x86_debug_state32
struct __darwin_x86_debug_state32
{
 unsigned int __dr0;
 unsigned int __dr1;
 unsigned int __dr2;
 unsigned int __dr3;
 unsigned int __dr4;
 unsigned int __dr5;
 unsigned int __dr6;
 unsigned int __dr7;
};

#define _STRUCT_X86_INSTRUCTION_STATE struct __x86_instruction_state
struct __x86_instruction_state
{
        int __insn_stream_valid_bytes;
        int __insn_offset;
 int __out_of_synch;




#define _X86_INSTRUCTION_STATE_MAX_INSN_BYTES (2448 - 64 - 4)
        __uint8_t __insn_bytes[(2448 - 64 - 4)];
#define _X86_INSTRUCTION_STATE_CACHELINE_SIZE 64
 __uint8_t __insn_cacheline[64];
};

#define _STRUCT_LAST_BRANCH_RECORD struct __last_branch_record
struct __last_branch_record
{
 __uint64_t __from_ip;
 __uint64_t __to_ip;
 __uint32_t __mispredict : 1,
   __tsx_abort : 1,
   __in_tsx : 1,
   __cycle_count: 16,
   __reserved : 13;
};

#define _STRUCT_LAST_BRANCH_STATE struct __last_branch_state
struct __last_branch_state
{
        int __lbr_count;
 __uint32_t __lbr_supported_tsx : 1,
     __lbr_supported_cycle_count : 1,
     __reserved : 30;
#define __LASTBRANCH_MAX 32
 struct __last_branch_record __lbrs[32];
};
# 701 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_PAGEIN_STATE struct __x86_pagein_state
struct __x86_pagein_state
{
 int __pagein_error;
};






#define _STRUCT_X86_THREAD_STATE64 struct __darwin_x86_thread_state64
struct __darwin_x86_thread_state64
{
 __uint64_t __rax;
 __uint64_t __rbx;
 __uint64_t __rcx;
 __uint64_t __rdx;
 __uint64_t __rdi;
 __uint64_t __rsi;
 __uint64_t __rbp;
 __uint64_t __rsp;
 __uint64_t __r8;
 __uint64_t __r9;
 __uint64_t __r10;
 __uint64_t __r11;
 __uint64_t __r12;
 __uint64_t __r13;
 __uint64_t __r14;
 __uint64_t __r15;
 __uint64_t __rip;
 __uint64_t __rflags;
 __uint64_t __cs;
 __uint64_t __fs;
 __uint64_t __gs;
};
# 770 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_THREAD_FULL_STATE64 struct __darwin_x86_thread_full_state64
struct __darwin_x86_thread_full_state64
{
 struct __darwin_x86_thread_state64 __ss64;
 __uint64_t __ds;
 __uint64_t __es;
 __uint64_t __ss;
 __uint64_t __gsbase;
};
# 793 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_FLOAT_STATE64 struct __darwin_x86_float_state64
struct __darwin_x86_float_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
};

#define _STRUCT_X86_AVX_STATE64 struct __darwin_x86_avx_state64
struct __darwin_x86_avx_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
};

#define _STRUCT_X86_AVX512_STATE64 struct __darwin_x86_avx512_state64
struct __darwin_x86_avx512_state64
{
 int __fpu_reserved[2];
 struct __darwin_fp_control __fpu_fcw;
 struct __darwin_fp_status __fpu_fsw;
 __uint8_t __fpu_ftw;
 __uint8_t __fpu_rsrv1;
 __uint16_t __fpu_fop;


 __uint32_t __fpu_ip;
 __uint16_t __fpu_cs;

 __uint16_t __fpu_rsrv2;


 __uint32_t __fpu_dp;
 __uint16_t __fpu_ds;

 __uint16_t __fpu_rsrv3;
 __uint32_t __fpu_mxcsr;
 __uint32_t __fpu_mxcsrmask;
 struct __darwin_mmst_reg __fpu_stmm0;
 struct __darwin_mmst_reg __fpu_stmm1;
 struct __darwin_mmst_reg __fpu_stmm2;
 struct __darwin_mmst_reg __fpu_stmm3;
 struct __darwin_mmst_reg __fpu_stmm4;
 struct __darwin_mmst_reg __fpu_stmm5;
 struct __darwin_mmst_reg __fpu_stmm6;
 struct __darwin_mmst_reg __fpu_stmm7;
 struct __darwin_xmm_reg __fpu_xmm0;
 struct __darwin_xmm_reg __fpu_xmm1;
 struct __darwin_xmm_reg __fpu_xmm2;
 struct __darwin_xmm_reg __fpu_xmm3;
 struct __darwin_xmm_reg __fpu_xmm4;
 struct __darwin_xmm_reg __fpu_xmm5;
 struct __darwin_xmm_reg __fpu_xmm6;
 struct __darwin_xmm_reg __fpu_xmm7;
 struct __darwin_xmm_reg __fpu_xmm8;
 struct __darwin_xmm_reg __fpu_xmm9;
 struct __darwin_xmm_reg __fpu_xmm10;
 struct __darwin_xmm_reg __fpu_xmm11;
 struct __darwin_xmm_reg __fpu_xmm12;
 struct __darwin_xmm_reg __fpu_xmm13;
 struct __darwin_xmm_reg __fpu_xmm14;
 struct __darwin_xmm_reg __fpu_xmm15;
 char __fpu_rsrv4[6*16];
 int __fpu_reserved1;
 char __avx_reserved1[64];
 struct __darwin_xmm_reg __fpu_ymmh0;
 struct __darwin_xmm_reg __fpu_ymmh1;
 struct __darwin_xmm_reg __fpu_ymmh2;
 struct __darwin_xmm_reg __fpu_ymmh3;
 struct __darwin_xmm_reg __fpu_ymmh4;
 struct __darwin_xmm_reg __fpu_ymmh5;
 struct __darwin_xmm_reg __fpu_ymmh6;
 struct __darwin_xmm_reg __fpu_ymmh7;
 struct __darwin_xmm_reg __fpu_ymmh8;
 struct __darwin_xmm_reg __fpu_ymmh9;
 struct __darwin_xmm_reg __fpu_ymmh10;
 struct __darwin_xmm_reg __fpu_ymmh11;
 struct __darwin_xmm_reg __fpu_ymmh12;
 struct __darwin_xmm_reg __fpu_ymmh13;
 struct __darwin_xmm_reg __fpu_ymmh14;
 struct __darwin_xmm_reg __fpu_ymmh15;
 struct __darwin_opmask_reg __fpu_k0;
 struct __darwin_opmask_reg __fpu_k1;
 struct __darwin_opmask_reg __fpu_k2;
 struct __darwin_opmask_reg __fpu_k3;
 struct __darwin_opmask_reg __fpu_k4;
 struct __darwin_opmask_reg __fpu_k5;
 struct __darwin_opmask_reg __fpu_k6;
 struct __darwin_opmask_reg __fpu_k7;
 struct __darwin_ymm_reg __fpu_zmmh0;
 struct __darwin_ymm_reg __fpu_zmmh1;
 struct __darwin_ymm_reg __fpu_zmmh2;
 struct __darwin_ymm_reg __fpu_zmmh3;
 struct __darwin_ymm_reg __fpu_zmmh4;
 struct __darwin_ymm_reg __fpu_zmmh5;
 struct __darwin_ymm_reg __fpu_zmmh6;
 struct __darwin_ymm_reg __fpu_zmmh7;
 struct __darwin_ymm_reg __fpu_zmmh8;
 struct __darwin_ymm_reg __fpu_zmmh9;
 struct __darwin_ymm_reg __fpu_zmmh10;
 struct __darwin_ymm_reg __fpu_zmmh11;
 struct __darwin_ymm_reg __fpu_zmmh12;
 struct __darwin_ymm_reg __fpu_zmmh13;
 struct __darwin_ymm_reg __fpu_zmmh14;
 struct __darwin_ymm_reg __fpu_zmmh15;
 struct __darwin_zmm_reg __fpu_zmm16;
 struct __darwin_zmm_reg __fpu_zmm17;
 struct __darwin_zmm_reg __fpu_zmm18;
 struct __darwin_zmm_reg __fpu_zmm19;
 struct __darwin_zmm_reg __fpu_zmm20;
 struct __darwin_zmm_reg __fpu_zmm21;
 struct __darwin_zmm_reg __fpu_zmm22;
 struct __darwin_zmm_reg __fpu_zmm23;
 struct __darwin_zmm_reg __fpu_zmm24;
 struct __darwin_zmm_reg __fpu_zmm25;
 struct __darwin_zmm_reg __fpu_zmm26;
 struct __darwin_zmm_reg __fpu_zmm27;
 struct __darwin_zmm_reg __fpu_zmm28;
 struct __darwin_zmm_reg __fpu_zmm29;
 struct __darwin_zmm_reg __fpu_zmm30;
 struct __darwin_zmm_reg __fpu_zmm31;
};
# 1251 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_EXCEPTION_STATE64 struct __darwin_x86_exception_state64
struct __darwin_x86_exception_state64
{
    __uint16_t __trapno;
    __uint16_t __cpu;
    __uint32_t __err;
    __uint64_t __faultvaddr;
};
# 1271 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_DEBUG_STATE64 struct __darwin_x86_debug_state64
struct __darwin_x86_debug_state64
{
 __uint64_t __dr0;
 __uint64_t __dr1;
 __uint64_t __dr2;
 __uint64_t __dr3;
 __uint64_t __dr4;
 __uint64_t __dr5;
 __uint64_t __dr6;
 __uint64_t __dr7;
};
# 1299 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/i386/_structs.h" 3 4
#define _STRUCT_X86_CPMU_STATE64 struct __darwin_x86_cpmu_state64
struct __darwin_x86_cpmu_state64
{
 __uint64_t __ctrs[16];
};
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/mach/machine/_structs.h" 2 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_mcontext.h" 2 3 4



#define _STRUCT_MCONTEXT32 struct __darwin_mcontext32
struct __darwin_mcontext32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_float_state __fs;
};

#define _STRUCT_MCONTEXT_AVX32 struct __darwin_mcontext_avx32
struct __darwin_mcontext_avx32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx_state __fs;
};


#define _STRUCT_MCONTEXT_AVX512_32 struct __darwin_mcontext_avx512_32
struct __darwin_mcontext_avx512_32
{
 struct __darwin_i386_exception_state __es;
 struct __darwin_i386_thread_state __ss;
 struct __darwin_i386_avx512_state __fs;
};
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_mcontext.h" 3 4
#define _STRUCT_MCONTEXT64 struct __darwin_mcontext64
struct __darwin_mcontext64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};

#define _STRUCT_MCONTEXT64_FULL struct __darwin_mcontext64_full
struct __darwin_mcontext64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_float_state64 __fs;
};

#define _STRUCT_MCONTEXT_AVX64 struct __darwin_mcontext_avx64
struct __darwin_mcontext_avx64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};

#define _STRUCT_MCONTEXT_AVX64_FULL struct __darwin_mcontext_avx64_full
struct __darwin_mcontext_avx64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_avx_state64 __fs;
};


#define _STRUCT_MCONTEXT_AVX512_64 struct __darwin_mcontext_avx512_64
struct __darwin_mcontext_avx512_64
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};

#define _STRUCT_MCONTEXT_AVX512_64_FULL struct __darwin_mcontext_avx512_64_full
struct __darwin_mcontext_avx512_64_full
{
 struct __darwin_x86_exception_state64 __es;
 struct __darwin_x86_thread_full_state64 __ss;
 struct __darwin_x86_avx512_state64 __fs;
};
# 202 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_mcontext.h" 3 4
#define _MCONTEXT_T 

typedef struct __darwin_mcontext64 *mcontext_t;
#define _STRUCT_MCONTEXT _STRUCT_MCONTEXT64
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_mcontext.h" 2 3 4
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_sigaltstack.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_sigaltstack.h" 3 4
#define _STRUCT_SIGALTSTACK struct __darwin_sigaltstack






struct __darwin_sigaltstack
{
 void *ss_sp;
 __darwin_size_t ss_size;
 int ss_flags;
};
typedef struct __darwin_sigaltstack stack_t;
# 151 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ucontext.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ucontext.h" 3 4
#define _STRUCT_UCONTEXT struct __darwin_ucontext





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_mcontext.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ucontext.h" 2 3 4



struct __darwin_ucontext
{
 int uc_onstack;
 __darwin_sigset_t uc_sigmask;
 struct __darwin_sigaltstack uc_stack;
 struct __darwin_ucontext *uc_link;
 __darwin_size_t uc_mcsize;
 struct __darwin_mcontext64 *uc_mcontext;



};


typedef struct __darwin_ucontext ucontext_t;
# 152 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_sigset_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_sigset_t.h" 3 4
#define _SIGSET_T 

typedef __darwin_sigset_t sigset_t;
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 2 3 4



union sigval {

 int sival_int;
 void *sival_ptr;
};

#define SIGEV_NONE 0
#define SIGEV_SIGNAL 1
#define SIGEV_THREAD 3

struct sigevent {
 int sigev_notify;
 int sigev_signo;
 union sigval sigev_value;
 void (*sigev_notify_function)(union sigval);
 pthread_attr_t *sigev_notify_attributes;
};


typedef struct __siginfo {
 int si_signo;
 int si_errno;
 int si_code;
 pid_t si_pid;
 uid_t si_uid;
 int si_status;
 void *si_addr;
 union sigval si_value;
 long si_band;
 unsigned long __pad[7];
} siginfo_t;
# 206 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 3 4
#define ILL_NOOP 0

#define ILL_ILLOPC 1
#define ILL_ILLTRP 2
#define ILL_PRVOPC 3
#define ILL_ILLOPN 4
#define ILL_ILLADR 5
#define ILL_PRVREG 6
#define ILL_COPROC 7
#define ILL_BADSTK 8



#define FPE_NOOP 0

#define FPE_FLTDIV 1
#define FPE_FLTOVF 2
#define FPE_FLTUND 3
#define FPE_FLTRES 4
#define FPE_FLTINV 5
#define FPE_FLTSUB 6
#define FPE_INTDIV 7
#define FPE_INTOVF 8



#define SEGV_NOOP 0

#define SEGV_MAPERR 1
#define SEGV_ACCERR 2



#define BUS_NOOP 0

#define BUS_ADRALN 1
#define BUS_ADRERR 2
#define BUS_OBJERR 3


#define TRAP_BRKPT 1
#define TRAP_TRACE 2



#define CLD_NOOP 0

#define CLD_EXITED 1
#define CLD_KILLED 2
#define CLD_DUMPED 3
#define CLD_TRAPPED 4
#define CLD_STOPPED 5
#define CLD_CONTINUED 6


#define POLL_IN 1
#define POLL_OUT 2
#define POLL_MSG 3
#define POLL_ERR 4
#define POLL_PRI 5
#define POLL_HUP 6


union __sigaction_u {
 void (*__sa_handler)(int);
 void (*__sa_sigaction)(int, struct __siginfo *,
     void *);
};


struct __sigaction {
 union __sigaction_u __sigaction_u;
 void (*sa_tramp)(void *, int, int, siginfo_t *, void *);
 sigset_t sa_mask;
 int sa_flags;
};




struct sigaction {
 union __sigaction_u __sigaction_u;
 sigset_t sa_mask;
 int sa_flags;
};




#define sa_handler __sigaction_u.__sa_handler
#define sa_sigaction __sigaction_u.__sa_sigaction

#define SA_ONSTACK 0x0001
#define SA_RESTART 0x0002
#define SA_RESETHAND 0x0004
#define SA_NOCLDSTOP 0x0008
#define SA_NODEFER 0x0010
#define SA_NOCLDWAIT 0x0020
#define SA_SIGINFO 0x0040

#define SA_USERTRAMP 0x0100

#define SA_64REGSET 0x0200





#define SA_USERSPACE_MASK (SA_ONSTACK | SA_RESTART | SA_RESETHAND | SA_NOCLDSTOP | SA_NODEFER | SA_NOCLDWAIT | SA_SIGINFO)




#define SIG_BLOCK 1
#define SIG_UNBLOCK 2
#define SIG_SETMASK 3


#define SI_USER 0x10001
#define SI_QUEUE 0x10002
#define SI_TIMER 0x10003
#define SI_ASYNCIO 0x10004
#define SI_MESGQ 0x10005


typedef void (*sig_t)(int);






#define SS_ONSTACK 0x0001
#define SS_DISABLE 0x0004
#define MINSIGSTKSZ 32768
#define SIGSTKSZ 131072






struct sigvec {
 void (*sv_handler)(int);
 int sv_mask;
 int sv_flags;
};

#define SV_ONSTACK SA_ONSTACK
#define SV_INTERRUPT SA_RESTART
#define SV_RESETHAND SA_RESETHAND
#define SV_NODEFER SA_NODEFER
#define SV_NOCLDSTOP SA_NOCLDSTOP
#define SV_SIGINFO SA_SIGINFO

#define sv_onstack sv_flags





struct sigstack {
 char *ss_sp;
 int ss_onstack;
};






#define sigmask(m) (1 << ((m)-1))


#define BADSIG SIG_ERR
# 389 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/signal.h" 3 4

    void(*signal(int, void (*)(int)))(int);

# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 2 3 4
# 121 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
#define WNOHANG 0x00000001
#define WUNTRACED 0x00000002
# 131 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
#define _W_INT(w) (*(int *)&(w))
#define WCOREFLAG 0200



#define _WSTATUS(x) (_W_INT(x) & 0177)
#define _WSTOPPED 0177






#define WEXITSTATUS(x) ((_W_INT(x) >> 8) & 0x000000ff)




#define WSTOPSIG(x) (_W_INT(x) >> 8)
#define WIFCONTINUED(x) (_WSTATUS(x) == _WSTOPPED && WSTOPSIG(x) == 0x13)
#define WIFSTOPPED(x) (_WSTATUS(x) == _WSTOPPED && WSTOPSIG(x) != 0x13)
#define WIFEXITED(x) (_WSTATUS(x) == 0)
#define WIFSIGNALED(x) (_WSTATUS(x) != _WSTOPPED && _WSTATUS(x) != 0)
#define WTERMSIG(x) (_WSTATUS(x))

#define WCOREDUMP(x) (_W_INT(x) & WCOREFLAG)

#define W_EXITCODE(ret,sig) ((ret) << 8 | (sig))
#define W_STOPCODE(sig) ((sig) << 8 | _WSTOPPED)
# 168 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
#define WEXITED 0x00000004


#define WSTOPPED 0x00000008

#define WCONTINUED 0x00000010
#define WNOWAIT 0x00000020
# 183 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
#define WAIT_ANY (-1)
#define WAIT_MYPGRP 0
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4
union wait {
 int w_status;



 struct {

  unsigned int w_Termsig:7,
      w_Coredump:1,
      w_Retcode:8,
      w_Filler:16;







 } w_T;





 struct {

  unsigned int w_Stopval:8,
      w_Stopsig:8,
      w_Filler:16;






 } w_S;
};
#define w_termsig w_T.w_Termsig
#define w_coredump w_T.w_Coredump
#define w_retcode w_T.w_Retcode
#define w_stopval w_S.w_Stopval
#define w_stopsig w_S.w_Stopsig
# 247 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/wait.h" 3 4

pid_t wait(int *) __asm("_" "wait" );
pid_t waitpid(pid_t, int *, int) __asm("_" "waitpid" );

int waitid(idtype_t, id_t, siginfo_t *, int) __asm("_" "waitid" );


pid_t wait3(int *, int, struct rusage *);
pid_t wait4(pid_t, int *, int, struct rusage *);


# 62 "project/nnn/src/nnn.c" 2
# 70 "project/nnn/src/nnn.c"
#define _XOPEN_SOURCE_EXTENDED 



#define __USE_XOPEN 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/dirent.h" 1 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/dirent.h" 3 4
#define _DIRENT_H_ 





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/dirent.h" 1 3 4
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/dirent.h" 3 4
#define _SYS_DIRENT_H 







#define __DARWIN_MAXNAMLEN 255

#pragma pack(4)
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/dirent.h" 3 4
#pragma pack()

#define __DARWIN_MAXPATHLEN 1024

#define __DARWIN_STRUCT_DIRENTRY { __uint64_t d_ino; __uint64_t d_seekoff; __uint16_t d_reclen; __uint16_t d_namlen; __uint8_t d_type; char d_name[__DARWIN_MAXPATHLEN]; }
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/dirent.h" 3 4
struct dirent { __uint64_t d_ino; __uint64_t d_seekoff; __uint16_t d_reclen; __uint16_t d_namlen; __uint8_t d_type; char d_name[1024]; };





#define d_fileno d_ino
#define MAXNAMLEN __DARWIN_MAXNAMLEN



#define DT_UNKNOWN 0
#define DT_FIFO 1
#define DT_CHR 2
#define DT_DIR 4
#define DT_BLK 6
#define DT_REG 8
#define DT_LNK 10
#define DT_SOCK 12
#define DT_WHT 14




#define IFTODT(mode) (((mode) & 0170000) >> 12)
#define DTTOIF(dirtype) ((dirtype) << 12)
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/dirent.h" 2 3 4




struct _telldir;


typedef struct {
 int __dd_fd;
 long __dd_loc;
 long __dd_size;
 char *__dd_buf;
 int __dd_len;
 long __dd_seek;
 __attribute__((__unused__)) long __padding;
 int __dd_flags;
 __darwin_pthread_mutex_t __dd_lock;
 struct _telldir *__dd_td;
} DIR;




#define DIRBLKSIZ 1024


#define DTF_HIDEW 0x0001
#define DTF_NODUP 0x0002
#define DTF_REWIND 0x0004
#define __DTF_READALL 0x0008
#define __DTF_SKIPREAD 0x0010
#define __DTF_ATEND 0x0020







int closedir(DIR *) __asm("_" "closedir" );

DIR *opendir(const char *) __asm("_" "opendir" "$INODE64" );

struct dirent *readdir(DIR *) __asm("_" "readdir" "$INODE64");
int readdir_r(DIR *, struct dirent *, struct dirent **) __asm("_" "readdir_r" "$INODE64");

void rewinddir(DIR *) __asm("_" "rewinddir" "$INODE64" );

void seekdir(DIR *, long) __asm("_" "seekdir" "$INODE64" );

long telldir(DIR *) __asm("_" "telldir" "$INODE64" );












DIR *fdopendir(int) __asm("_" "fdopendir" "$INODE64" );

int alphasort(const struct dirent **, const struct dirent **) __asm("_" "alphasort" "$INODE64");
# 146 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/dirent.h" 3 4
int dirfd(DIR *dirp) ;


int scandir(const char *, struct dirent ***,
    int (*)(const struct dirent *), int (*)(const struct dirent **, const struct dirent **)) __asm("_" "scandir" "$INODE64");
# 164 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/dirent.h" 3 4







int getdirentries(int, char *, int, long *)






      __asm("_getdirentries_is_not_available_when_64_bit_inodes_are_in_effect")



;

DIR *__opendir2(const char *, int) __asm("_" "__opendir2" "$INODE64" );


# 77 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/errno.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/errno.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/errno.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/errno.h" 3 4
#define _SYS_ERRNO_H_ 
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/errno.h" 3 4

extern int * __error(void);
#define errno (*__error())






#define EPERM 1
#define ENOENT 2
#define ESRCH 3
#define EINTR 4
#define EIO 5
#define ENXIO 6
#define E2BIG 7
#define ENOEXEC 8
#define EBADF 9
#define ECHILD 10
#define EDEADLK 11

#define ENOMEM 12
#define EACCES 13
#define EFAULT 14

#define ENOTBLK 15

#define EBUSY 16
#define EEXIST 17
#define EXDEV 18
#define ENODEV 19
#define ENOTDIR 20
#define EISDIR 21
#define EINVAL 22
#define ENFILE 23
#define EMFILE 24
#define ENOTTY 25
#define ETXTBSY 26
#define EFBIG 27
#define ENOSPC 28
#define ESPIPE 29
#define EROFS 30
#define EMLINK 31
#define EPIPE 32


#define EDOM 33
#define ERANGE 34


#define EAGAIN 35
#define EWOULDBLOCK EAGAIN
#define EINPROGRESS 36
#define EALREADY 37


#define ENOTSOCK 38
#define EDESTADDRREQ 39
#define EMSGSIZE 40
#define EPROTOTYPE 41
#define ENOPROTOOPT 42
#define EPROTONOSUPPORT 43

#define ESOCKTNOSUPPORT 44

#define ENOTSUP 45
# 158 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/errno.h" 3 4
#define EPFNOSUPPORT 46

#define EAFNOSUPPORT 47
#define EADDRINUSE 48
#define EADDRNOTAVAIL 49


#define ENETDOWN 50
#define ENETUNREACH 51
#define ENETRESET 52
#define ECONNABORTED 53
#define ECONNRESET 54
#define ENOBUFS 55
#define EISCONN 56
#define ENOTCONN 57

#define ESHUTDOWN 58
#define ETOOMANYREFS 59

#define ETIMEDOUT 60
#define ECONNREFUSED 61

#define ELOOP 62
#define ENAMETOOLONG 63



#define EHOSTDOWN 64

#define EHOSTUNREACH 65
#define ENOTEMPTY 66



#define EPROCLIM 67
#define EUSERS 68

#define EDQUOT 69


#define ESTALE 70

#define EREMOTE 71
#define EBADRPC 72
#define ERPCMISMATCH 73
#define EPROGUNAVAIL 74
#define EPROGMISMATCH 75
#define EPROCUNAVAIL 76


#define ENOLCK 77
#define ENOSYS 78


#define EFTYPE 79
#define EAUTH 80
#define ENEEDAUTH 81


#define EPWROFF 82
#define EDEVERR 83


#define EOVERFLOW 84



#define EBADEXEC 85
#define EBADARCH 86
#define ESHLIBVERS 87
#define EBADMACHO 88


#define ECANCELED 89

#define EIDRM 90
#define ENOMSG 91
#define EILSEQ 92

#define ENOATTR 93


#define EBADMSG 94
#define EMULTIHOP 95
#define ENODATA 96
#define ENOLINK 97
#define ENOSR 98
#define ENOSTR 99
#define EPROTO 100
#define ETIME 101



#define EOPNOTSUPP 102


#define ENOPOLICY 103


#define ENOTRECOVERABLE 104
#define EOWNERDEAD 105



#define EQFULL 106
#define ELAST 106
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/errno.h" 2 3 4
# 78 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/fcntl.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/fcntl.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 1 3 4
# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
#define _SYS_FCNTL_H_ 
# 96 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
#define O_RDONLY 0x0000
#define O_WRONLY 0x0001
#define O_RDWR 0x0002
#define O_ACCMODE 0x0003
# 110 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
#define FREAD 0x00000001
#define FWRITE 0x00000002

#define O_NONBLOCK 0x00000004
#define O_APPEND 0x00000008

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_o_sync.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_o_sync.h" 3 4
#define O_SYNC 0x0080
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 2 3 4


#define O_SHLOCK 0x00000010
#define O_EXLOCK 0x00000020
#define O_ASYNC 0x00000040
#define O_FSYNC O_SYNC
#define O_NOFOLLOW 0x00000100

#define O_CREAT 0x00000200
#define O_TRUNC 0x00000400
#define O_EXCL 0x00000800


#define O_EVTONLY 0x00008000



#define O_NOCTTY 0x00020000



#define O_DIRECTORY 0x00100000
#define O_SYMLINK 0x00200000



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_o_dsync.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_o_dsync.h" 3 4
#define O_DSYNC 0x400000
# 144 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 2 3 4



#define O_CLOEXEC 0x01000000




#define O_NOFOLLOW_ANY 0x20000000







#define AT_FDCWD -2




#define AT_EACCESS 0x0010
#define AT_SYMLINK_NOFOLLOW 0x0020
#define AT_SYMLINK_FOLLOW 0x0040
#define AT_REMOVEDIR 0x0080

#define AT_REALDEV 0x0200
#define AT_FDONLY 0x0400





#define O_DP_GETRAWENCRYPTED 0x0001
#define O_DP_GETRAWUNENCRYPTED 0x0002
# 189 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
#define FAPPEND O_APPEND
#define FASYNC O_ASYNC
#define FFSYNC O_FSYNC
#define FFDSYNC O_DSYNC
#define FNONBLOCK O_NONBLOCK
#define FNDELAY O_NONBLOCK
#define O_NDELAY O_NONBLOCK







#define CPF_OVERWRITE 0x0001
#define CPF_IGNORE_MODE 0x0002
#define CPF_MASK (CPF_OVERWRITE|CPF_IGNORE_MODE)







#define F_DUPFD 0
#define F_GETFD 1
#define F_SETFD 2
#define F_GETFL 3
#define F_SETFL 4
#define F_GETOWN 5
#define F_SETOWN 6
#define F_GETLK 7
#define F_SETLK 8
#define F_SETLKW 9

#define F_SETLKWTIMEOUT 10


#define F_FLUSH_DATA 40
#define F_CHKCLEAN 41
#define F_PREALLOCATE 42
#define F_SETSIZE 43
#define F_RDADVISE 44
#define F_RDAHEAD 45



#define F_NOCACHE 48
#define F_LOG2PHYS 49
#define F_GETPATH 50
#define F_FULLFSYNC 51
#define F_PATHPKG_CHECK 52
#define F_FREEZE_FS 53
#define F_THAW_FS 54
#define F_GLOBAL_NOCACHE 55


#define F_ADDSIGS 59


#define F_ADDFILESIGS 61

#define F_NODIRECT 62


#define F_GETPROTECTIONCLASS 63
#define F_SETPROTECTIONCLASS 64

#define F_LOG2PHYS_EXT 65

#define F_GETLKPID 66




#define F_SETBACKINGSTORE 70
#define F_GETPATH_MTMINFO 71

#define F_GETCODEDIR 72

#define F_SETNOSIGPIPE 73
#define F_GETNOSIGPIPE 74

#define F_TRANSCODEKEY 75

#define F_SINGLE_WRITER 76


#define F_GETPROTECTIONLEVEL 77

#define F_FINDSIGS 78


#define F_ADDFILESIGS_FOR_DYLD_SIM 83


#define F_BARRIERFSYNC 85


#define F_ADDFILESIGS_RETURN 97
#define F_CHECK_LV 98

#define F_PUNCHHOLE 99

#define F_TRIM_ACTIVE_FILE 100

#define F_SPECULATIVE_READ 101

#define F_GETPATH_NOFIRMLINK 102

#define F_ADDFILESIGS_INFO 103
#define F_ADDFILESUPPL 104
#define F_GETSIGSINFO 105


#define FCNTL_FS_SPECIFIC_BASE 0x00010000




#define F_DUPFD_CLOEXEC 67



#define FD_CLOEXEC 1


#define F_RDLCK 1
#define F_UNLCK 2
#define F_WRLCK 3






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_seek_set.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_seek_set.h" 3 4
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2




#define SEEK_HOLE 3



#define SEEK_DATA 4
# 326 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 2 3 4
# 336 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
#define F_ALLOCATECONTIG 0x00000002
#define F_ALLOCATEALL 0x00000004



#define F_PEOFPOSMODE 3

#define F_VOLPOSMODE 4






struct flock {
 off_t l_start;
 off_t l_len;
 pid_t l_pid;
 short l_type;
 short l_whence;
};
# 365 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
struct flocktimeout {
 struct flock fl;
 struct timespec timeout;
};
# 378 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
struct radvisory {
 off_t ra_offset;
 int ra_count;
};
# 390 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
#define USER_FSIGNATURES_CDHASH_LEN 20
typedef struct fsignatures {
 off_t fs_file_start;
 void *fs_blob_start;
 size_t fs_blob_size;



 size_t fs_fsignatures_size;
 char fs_cdhash[20];
 int fs_hash_type;
} fsignatures_t;

typedef struct fsupplement {
 off_t fs_file_start;
 off_t fs_blob_start;
 size_t fs_blob_size;
 int fs_orig_fd;
} fsupplement_t;
# 422 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
typedef struct fchecklv {
 off_t lv_file_start;
 size_t lv_error_message_size;
 void *lv_error_message;
} fchecklv_t;






#define GETSIGSINFO_PLATFORM_BINARY 1


typedef struct fgetsigsinfo {
 off_t fg_file_start;
 int fg_info_request;
 int fg_sig_is_platform;
} fgetsigsinfo_t;



#define LOCK_SH 0x01
#define LOCK_EX 0x02
#define LOCK_NB 0x04
#define LOCK_UN 0x08



typedef struct fstore {
 unsigned int fst_flags;
 int fst_posmode;
 off_t fst_offset;
 off_t fst_length;
 off_t fst_bytesalloc;
} fstore_t;


typedef struct fpunchhole {
 unsigned int fp_flags;
 unsigned int reserved;
 off_t fp_offset;
 off_t fp_length;
} fpunchhole_t;


typedef struct ftrimactivefile {
 off_t fta_offset;
 off_t fta_length;
} ftrimactivefile_t;


typedef struct fspecread {
 unsigned int fsr_flags;
 unsigned int reserved;
 off_t fsr_offset;
 off_t fsr_length;
} fspecread_t;



typedef struct fbootstraptransfer {
 off_t fbt_offset;
 size_t fbt_length;
 void *fbt_buffer;
} fbootstraptransfer_t;
# 511 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
#pragma pack(4)

struct log2phys {
 unsigned int l2p_flags;
 off_t l2p_contigbytes;


 off_t l2p_devoffset;


};

#pragma pack()

#define O_POPUP 0x80000000
#define O_ALERT 0x20000000
# 536 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/fcntl.h" 3 4
typedef enum {
 FILESEC_OWNER = 1,
 FILESEC_GROUP = 2,
 FILESEC_UUID = 3,
 FILESEC_MODE = 4,
 FILESEC_ACL = 5,
 FILESEC_GRPUUID = 6,


 FILESEC_ACL_RAW = 100,
 FILESEC_ACL_ALLOCSIZE = 101
} filesec_property_t;


#define FILESEC_GUID FILESEC_UUID



int open(const char *, int, ...) __asm("_" "open" );

int openat(int, const char *, int, ...) __asm("_" "openat" ) ;

int creat(const char *, mode_t) __asm("_" "creat" );
int fcntl(int, int, ...) __asm("_" "fcntl" );


int openx_np(const char *, int, filesec_t);




int open_dprotected_np( const char *, int, int, int, ...);
int flock(int, int);
filesec_t filesec_init(void);
filesec_t filesec_dup(filesec_t);
void filesec_free(filesec_t);
int filesec_get_property(filesec_t, filesec_property_t, void *);
int filesec_query_property(filesec_t, filesec_property_t, int *);
int filesec_set_property(filesec_t, filesec_property_t, const void *);
int filesec_unset_property(filesec_t, filesec_property_t) ;
#define _FILESEC_UNSET_PROPERTY ((void *)0)
#define _FILESEC_REMOVE_ACL ((void *)1)


# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/fcntl.h" 2 3 4
# 79 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/fts.h" 1 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/fts.h" 3 4
#define _FTS_H_ 
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/fts.h" 3 4
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wstrict-prototypes"

typedef struct {
 struct _ftsent *fts_cur;
 struct _ftsent *fts_child;
 struct _ftsent **fts_array;
 dev_t fts_dev;
 char *fts_path;
 int fts_rfd;
 int fts_pathlen;
 int fts_nitems;



     int (*fts_compar)();





#define FTS_COMFOLLOW 0x001
#define FTS_LOGICAL 0x002
#define FTS_NOCHDIR 0x004
#define FTS_NOSTAT 0x008
#define FTS_PHYSICAL 0x010
#define FTS_SEEDOT 0x020
#define FTS_XDEV 0x040
#define FTS_WHITEOUT 0x080
#define FTS_COMFOLLOWDIR 0x400



#define FTS_NOSTAT_TYPE 0x800
#define FTS_OPTIONMASK 0xcff


#define FTS_NAMEONLY 0x100
#define FTS_STOP 0x200



 int fts_options;
} FTS;

typedef struct _ftsent {
 struct _ftsent *fts_cycle;
 struct _ftsent *fts_parent;
 struct _ftsent *fts_link;
 long fts_number;
 void *fts_pointer;
 char *fts_accpath;
 char *fts_path;
 int fts_errno;
 int fts_symfd;
 unsigned short fts_pathlen;
 unsigned short fts_namelen;

 ino_t fts_ino;
 dev_t fts_dev;
 nlink_t fts_nlink;

#define FTS_ROOTPARENTLEVEL -1
#define FTS_ROOTLEVEL 0
#define FTS_MAXLEVEL 0x7fffffff
 short fts_level;

#define FTS_D 1
#define FTS_DC 2
#define FTS_DEFAULT 3
#define FTS_DNR 4
#define FTS_DOT 5
#define FTS_DP 6
#define FTS_ERR 7
#define FTS_F 8
#define FTS_INIT 9
#define FTS_NS 10
#define FTS_NSOK 11
#define FTS_SL 12
#define FTS_SLNONE 13
#define FTS_W 14
 unsigned short fts_info;

#define FTS_DONTCHDIR 0x01
#define FTS_SYMFOLLOW 0x02
#define FTS_ISW 0x04
#define FTS_CHDIRFD 0x08
 unsigned short fts_flags;

#define FTS_AGAIN 1
#define FTS_FOLLOW 2
#define FTS_NOINSTR 3
#define FTS_SKIP 4
 unsigned short fts_instr;

 struct stat *fts_statp;
 char fts_name[1];
} FTSENT;





FTSENT *fts_children(FTS *, int) __asm("_" "fts_children" "$INODE64");
int fts_close(FTS *) __asm("_" "fts_close" "$INODE64");
FTS *fts_open(char * const *, int,
     int (*)(const FTSENT **, const FTSENT **)) __asm("_" "fts_open" "$INODE64");
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/fts.h" 3 4
FTSENT *fts_read(FTS *) __asm("_" "fts_read" "$INODE64");
int fts_set(FTS *, FTSENT *, int) __asm("_" "fts_set" "$INODE64");


#pragma clang diagnostic pop
# 80 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libgen.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libgen.h" 3 4
#define _LIBGEN_H_ 







char *basename(char *);
char *dirname(char *);
# 52 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/libgen.h" 3 4
char *basename_r(const char *, char *)
 
  ;

char *dirname_r(const char *, char *)
 
  ;



# 81 "project/nnn/src/nnn.c" 2
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 1 3 4
# 30 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 3 4
#define _GCC_LIMITS_H_ 



# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/syslimits.h" 1 3 4





#define _GCC_NEXT_LIMITS_H 
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 1 3 4
# 203 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/limits.h" 1 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/limits.h" 3 4
#define _LIMITS_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/limits.h" 1 3 4





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/limits.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/limits.h" 3 4
#define _I386_LIMITS_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_limits.h" 1 3 4
# 23 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_limits.h" 3 4
#define _I386__LIMITS_H_ 

#define __DARWIN_CLK_TCK 100
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/limits.h" 2 3 4

#define CHAR_BIT 8
#define MB_LEN_MAX 6


#define CLK_TCK __DARWIN_CLK_TCK
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/limits.h" 3 4
#define SCHAR_MAX 127
#define SCHAR_MIN (-128)

#define UCHAR_MAX 255
#define CHAR_MAX 127
#define CHAR_MIN (-128)

#define USHRT_MAX 65535
#define SHRT_MAX 32767
#define SHRT_MIN (-32768)

#define UINT_MAX 0xffffffff
#define INT_MAX 2147483647
#define INT_MIN (-2147483647-1)


#define ULONG_MAX 0xffffffffffffffffUL
#define LONG_MAX 0x7fffffffffffffffL
#define LONG_MIN (-0x7fffffffffffffffL-1)






#define ULLONG_MAX 0xffffffffffffffffULL
#define LLONG_MAX 0x7fffffffffffffffLL
#define LLONG_MIN (-0x7fffffffffffffffLL-1)



#define LONG_BIT 64



#define SSIZE_MAX LONG_MAX
#define WORD_BIT 32


#define SIZE_T_MAX ULONG_MAX

#define UQUAD_MAX ULLONG_MAX
#define QUAD_MAX LLONG_MAX
#define QUAD_MIN LLONG_MIN
# 7 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/limits.h" 2 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/limits.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/syslimits.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/syslimits.h" 3 4
#define _SYS_SYSLIMITS_H_ 







#define ARG_MAX (1024 * 1024)
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/syslimits.h" 3 4
#define CHILD_MAX 266
#define GID_MAX 2147483647U

#define LINK_MAX 32767
#define MAX_CANON 1024
#define MAX_INPUT 1024
#define NAME_MAX 255
#define NGROUPS_MAX 16

#define UID_MAX 2147483647U

#define OPEN_MAX 10240


#define PATH_MAX 1024
#define PIPE_BUF 512

#define BC_BASE_MAX 99
#define BC_DIM_MAX 2048
#define BC_SCALE_MAX 99
#define BC_STRING_MAX 1000
#define CHARCLASS_NAME_MAX 14
#define COLL_WEIGHTS_MAX 2
#define EQUIV_CLASS_MAX 2
#define EXPR_NEST_MAX 32
#define LINE_MAX 2048
#define RE_DUP_MAX 255


#define NZERO 20
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/limits.h" 2 3 4


#define _POSIX_ARG_MAX 4096
#define _POSIX_CHILD_MAX 25
#define _POSIX_LINK_MAX 8
#define _POSIX_MAX_CANON 255
#define _POSIX_MAX_INPUT 255
#define _POSIX_NAME_MAX 14
#define _POSIX_NGROUPS_MAX 8
#define _POSIX_OPEN_MAX 20
#define _POSIX_PATH_MAX 256
#define _POSIX_PIPE_BUF 512
#define _POSIX_SSIZE_MAX 32767
#define _POSIX_STREAM_MAX 8
#define _POSIX_TZNAME_MAX 6

#define _POSIX2_BC_BASE_MAX 99
#define _POSIX2_BC_DIM_MAX 2048
#define _POSIX2_BC_SCALE_MAX 99
#define _POSIX2_BC_STRING_MAX 1000
#define _POSIX2_EQUIV_CLASS_MAX 2
#define _POSIX2_EXPR_NEST_MAX 32
#define _POSIX2_LINE_MAX 2048
#define _POSIX2_RE_DUP_MAX 255



#define _POSIX_AIO_LISTIO_MAX 2
#define _POSIX_AIO_MAX 1
#define _POSIX_DELAYTIMER_MAX 32
#define _POSIX_MQ_OPEN_MAX 8
#define _POSIX_MQ_PRIO_MAX 32
#define _POSIX_RTSIG_MAX 8
#define _POSIX_SEM_NSEMS_MAX 256
#define _POSIX_SEM_VALUE_MAX 32767
#define _POSIX_SIGQUEUE_MAX 32
#define _POSIX_TIMER_MAX 32

#define _POSIX_CLOCKRES_MIN 20000000



#define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
#define _POSIX_THREAD_KEYS_MAX 128
#define _POSIX_THREAD_THREADS_MAX 64

#define PTHREAD_DESTRUCTOR_ITERATIONS 4
#define PTHREAD_KEYS_MAX 512



#define PTHREAD_STACK_MIN 8192




#define _POSIX_HOST_NAME_MAX 255
#define _POSIX_LOGIN_NAME_MAX 9
#define _POSIX_SS_REPL_MAX 4
#define _POSIX_SYMLINK_MAX 255
#define _POSIX_SYMLOOP_MAX 8
#define _POSIX_TRACE_EVENT_NAME_MAX 30
#define _POSIX_TRACE_NAME_MAX 8
#define _POSIX_TRACE_SYS_MAX 8
#define _POSIX_TRACE_USER_EVENT_MAX 32
#define _POSIX_TTY_NAME_MAX 9
#define _POSIX2_CHARCLASS_NAME_MAX 14
#define _POSIX2_COLL_WEIGHTS_MAX 2

#define _POSIX_RE_DUP_MAX _POSIX2_RE_DUP_MAX



#define OFF_MIN LLONG_MIN
#define OFF_MAX LLONG_MAX







#define PASS_MAX 128


#define NL_ARGMAX 9
#define NL_LANGMAX 14
#define NL_MSGMAX 32767
#define NL_NMAX 1
#define NL_SETMAX 255
#define NL_TEXTMAX 2048

#define _XOPEN_IOV_MAX 16
#define IOV_MAX 1024
#define _XOPEN_NAME_MAX 255
#define _XOPEN_PATH_MAX 1024
# 204 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 2 3 4
# 8 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/syslimits.h" 2 3 4
#undef _GCC_NEXT_LIMITS_H
# 35 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 2 3 4
# 60 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 3 4
#define _LIMITS_H___ 


#undef CHAR_BIT
#define CHAR_BIT __CHAR_BIT__







#undef SCHAR_MIN
#define SCHAR_MIN (-SCHAR_MAX - 1)
#undef SCHAR_MAX
#define SCHAR_MAX __SCHAR_MAX__


#undef UCHAR_MAX



#define UCHAR_MAX (SCHAR_MAX * 2 + 1)
# 96 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/limits.h" 3 4
#undef CHAR_MIN
#define CHAR_MIN SCHAR_MIN
#undef CHAR_MAX
#define CHAR_MAX SCHAR_MAX



#undef SHRT_MIN
#define SHRT_MIN (-SHRT_MAX - 1)
#undef SHRT_MAX
#define SHRT_MAX __SHRT_MAX__


#undef USHRT_MAX



#define USHRT_MAX (SHRT_MAX * 2 + 1)



#undef INT_MIN
#define INT_MIN (-INT_MAX - 1)
#undef INT_MAX
#define INT_MAX __INT_MAX__


#undef UINT_MAX
#define UINT_MAX (INT_MAX * 2U + 1U)



#undef LONG_MIN
#define LONG_MIN (-LONG_MAX - 1L)
#undef LONG_MAX
#define LONG_MAX __LONG_MAX__


#undef ULONG_MAX
#define ULONG_MAX (LONG_MAX * 2UL + 1UL)



#undef LLONG_MIN
#define LLONG_MIN (-LLONG_MAX - 1LL)
#undef LLONG_MAX
#define LLONG_MAX __LONG_LONG_MAX__


#undef ULLONG_MAX
#define ULLONG_MAX (LLONG_MAX * 2ULL + 1ULL)




#undef LONG_LONG_MIN
#define LONG_LONG_MIN (-LONG_LONG_MAX - 1LL)
#undef LONG_LONG_MAX
#define LONG_LONG_MAX __LONG_LONG_MAX__


#undef ULONG_LONG_MAX
#define ULONG_LONG_MAX (LONG_LONG_MAX * 2ULL + 1ULL)
# 82 "project/nnn/src/nnn.c" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/locale.h" 1 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/locale.h" 3 4
#define _LOCALE_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_locale.h" 1 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_locale.h" 3 4
#define __LOCALE_H_ 




struct lconv {
 char *decimal_point;
 char *thousands_sep;
 char *grouping;
 char *int_curr_symbol;
 char *currency_symbol;
 char *mon_decimal_point;
 char *mon_thousands_sep;
 char *mon_grouping;
 char *positive_sign;
 char *negative_sign;
 char int_frac_digits;
 char frac_digits;
 char p_cs_precedes;
 char p_sep_by_space;
 char n_cs_precedes;
 char n_sep_by_space;
 char p_sign_posn;
 char n_sign_posn;
 char int_p_cs_precedes;
 char int_n_cs_precedes;
 char int_p_sep_by_space;
 char int_n_sep_by_space;
 char int_p_sign_posn;
 char int_n_sign_posn;
};




struct lconv *localeconv(void);

# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/locale.h" 2 3 4

#define LC_ALL 0
#define LC_COLLATE 1
#define LC_CTYPE 2
#define LC_MONETARY 3
#define LC_NUMERIC 4
#define LC_TIME 5
#define LC_MESSAGES 6

#define _LC_LAST 7


char *setlocale(int, const char *);

# 84 "project/nnn/src/nnn.c" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 1 3 4
# 53 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4
#define _PTHREAD_H 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/sched.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/sched.h" 3 4
#define _SCHED_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/pthread_impl.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/pthread_impl.h" 3 4
#define _PTHREAD_IMPL_H_ 
# 41 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/pthread_impl.h" 3 4
#define _PTHREAD_MUTEX_SIG_init 0x32AAABA7

#define _PTHREAD_ERRORCHECK_MUTEX_SIG_init 0x32AAABA1
#define _PTHREAD_RECURSIVE_MUTEX_SIG_init 0x32AAABA2
#define _PTHREAD_FIRSTFIT_MUTEX_SIG_init 0x32AAABA3

#define _PTHREAD_COND_SIG_init 0x3CB0B1BB
#define _PTHREAD_ONCE_SIG_init 0x30B1BCBA
#define _PTHREAD_RWLOCK_SIG_init 0x2DA8B3B4




#define SCHED_OTHER 1
#define SCHED_FIFO 4
#define SCHED_RR 2

#define __SCHED_PARAM_SIZE__ 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/sched.h" 2 3 4






struct sched_param { int sched_priority; char __opaque[4]; };




extern int sched_yield(void);
extern int sched_get_priority_min(int);
extern int sched_get_priority_max(int);

# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 2 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4
#define _PTHREAD_QOS_H 
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/qos.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/qos.h" 3 4
#define _SYS_QOS_H 
# 114 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/qos.h" 3 4
#define __QOS_ENUM(name,type,...) enum { __VA_ARGS__ }; typedef type name ##_t
#define __QOS_CLASS_AVAILABLE(...) 
# 130 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/qos.h" 3 4
enum { QOS_CLASS_USER_INTERACTIVE = 0x21, QOS_CLASS_USER_INITIATED = 0x19, QOS_CLASS_DEFAULT = 0x15, QOS_CLASS_UTILITY = 0x11, QOS_CLASS_BACKGROUND = 0x09, QOS_CLASS_UNSPECIFIED = 0x00, }; typedef unsigned int qos_class_t
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/qos.h" 3 4
 ;

#undef __QOS_ENUM







#define QOS_MIN_RELATIVE_PRIORITY (-15)






# 170 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/qos.h" 3 4

qos_class_t
qos_class_self(void);
# 192 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/qos.h" 3 4

qos_class_t
qos_class_main(void);


# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 2 3 4







# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_attr_set_qos_class_np(pthread_attr_t *__attr,
  qos_class_t __qos_class, int __relative_priority);
# 112 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_attr_get_qos_class_np(pthread_attr_t * restrict __attr,
  qos_class_t * restrict __qos_class,
  int * restrict __relative_priority);
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_set_qos_class_self_np(qos_class_t __qos_class,
  int __relative_priority);
# 184 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_get_qos_class_np(pthread_t __pthread,
  qos_class_t * restrict __qos_class,
  int * restrict __relative_priority);
# 211 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4
typedef struct pthread_override_s* pthread_override_t;
# 263 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4

pthread_override_t
pthread_override_qos_class_start_np(pthread_t __pthread,
  qos_class_t __qos_class, int __relative_priority);
# 291 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread/qos.h" 3 4

int
pthread_override_qos_class_end_np(pthread_override_t __override);


# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_mach_port_t.h" 1 3 4
# 48 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_mach_port_t.h" 3 4
#define _MACH_PORT_T 

typedef __darwin_mach_port_t mach_port_t;
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 2 3 4
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4

# 116 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4
#define pthread_cleanup_push(func,val) { struct __darwin_pthread_handler_rec __handler; pthread_t __self = pthread_self(); __handler.__routine = func; __handler.__arg = val; __handler.__next = __self->__cleanup_stack; __self->__cleanup_stack = &__handler;
# 125 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4
#define pthread_cleanup_pop(execute) __self->__cleanup_stack = __handler.__next; if (execute) (__handler.__routine)(__handler.__arg); }
# 135 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4
#define PTHREAD_CREATE_JOINABLE 1
#define PTHREAD_CREATE_DETACHED 2

#define PTHREAD_INHERIT_SCHED 1
#define PTHREAD_EXPLICIT_SCHED 2

#define PTHREAD_CANCEL_ENABLE 0x01
#define PTHREAD_CANCEL_DISABLE 0x00
#define PTHREAD_CANCEL_DEFERRED 0x02
#define PTHREAD_CANCEL_ASYNCHRONOUS 0x00


#define PTHREAD_CANCELED ((void *) 1)


#define PTHREAD_SCOPE_SYSTEM 1
#define PTHREAD_SCOPE_PROCESS 2

#define PTHREAD_PROCESS_SHARED 1
#define PTHREAD_PROCESS_PRIVATE 2




#define PTHREAD_PRIO_NONE 0
#define PTHREAD_PRIO_INHERIT 1
#define PTHREAD_PRIO_PROTECT 2




#define PTHREAD_MUTEX_NORMAL 0
#define PTHREAD_MUTEX_ERRORCHECK 1
#define PTHREAD_MUTEX_RECURSIVE 2
#define PTHREAD_MUTEX_DEFAULT PTHREAD_MUTEX_NORMAL




#define PTHREAD_MUTEX_POLICY_FAIRSHARE_NP 1
#define PTHREAD_MUTEX_POLICY_FIRSTFIT_NP 3




#define PTHREAD_RWLOCK_INITIALIZER {_PTHREAD_RWLOCK_SIG_init, {0}}




#define PTHREAD_MUTEX_INITIALIZER {_PTHREAD_MUTEX_SIG_init, {0}}




#define PTHREAD_ERRORCHECK_MUTEX_INITIALIZER {_PTHREAD_ERRORCHECK_MUTEX_SIG_init, {0}}
#define PTHREAD_RECURSIVE_MUTEX_INITIALIZER {_PTHREAD_RECURSIVE_MUTEX_SIG_init, {0}}




#define _PTHREAD_SWIFT_IMPORTER_NULLABILITY_COMPAT defined(SWIFT_CLASS_EXTRA) && (!defined(SWIFT_SDK_OVERLAY_PTHREAD_EPOCH) || (SWIFT_SDK_OVERLAY_PTHREAD_EPOCH < 1))
# 207 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4
#define PTHREAD_COND_INITIALIZER {_PTHREAD_COND_SIG_init, {0}}





#define PTHREAD_ONCE_INIT {_PTHREAD_ONCE_SIG_init, {0}}





int pthread_atfork(void (* )(void), void (* )(void),
  void (* )(void));


int pthread_attr_destroy(pthread_attr_t *);


int pthread_attr_getdetachstate(const pthread_attr_t *, int *);


int pthread_attr_getguardsize(const pthread_attr_t * restrict, size_t * restrict);


int pthread_attr_getinheritsched(const pthread_attr_t * restrict, int * restrict);


int pthread_attr_getschedparam(const pthread_attr_t * restrict,
  struct sched_param * restrict);


int pthread_attr_getschedpolicy(const pthread_attr_t * restrict, int * restrict);


int pthread_attr_getscope(const pthread_attr_t * restrict, int * restrict);


int pthread_attr_getstack(const pthread_attr_t * restrict,
  void * * restrict, size_t * restrict);


int pthread_attr_getstackaddr(const pthread_attr_t * restrict,
  void * * restrict);


int pthread_attr_getstacksize(const pthread_attr_t * restrict, size_t * restrict);


int pthread_attr_init(pthread_attr_t *);


int pthread_attr_setdetachstate(pthread_attr_t *, int);


int pthread_attr_setguardsize(pthread_attr_t *, size_t);


int pthread_attr_setinheritsched(pthread_attr_t *, int);


int pthread_attr_setschedparam(pthread_attr_t * restrict,
  const struct sched_param * restrict);


int pthread_attr_setschedpolicy(pthread_attr_t *, int);


int pthread_attr_setscope(pthread_attr_t *, int);


int pthread_attr_setstack(pthread_attr_t *, void *, size_t);


int pthread_attr_setstackaddr(pthread_attr_t *, void *);


int pthread_attr_setstacksize(pthread_attr_t *, size_t);


int pthread_cancel(pthread_t) __asm("_" "pthread_cancel" );


int pthread_cond_broadcast(pthread_cond_t *);


int pthread_cond_destroy(pthread_cond_t *);


int pthread_cond_init(
  pthread_cond_t * restrict,
  const pthread_condattr_t * restrict)
  __asm("_" "pthread_cond_init" );


int pthread_cond_signal(pthread_cond_t *);


int pthread_cond_timedwait(
  pthread_cond_t * restrict, pthread_mutex_t * restrict,
  const struct timespec * restrict)
  __asm("_" "pthread_cond_timedwait" );


int pthread_cond_wait(pthread_cond_t * restrict,
  pthread_mutex_t * restrict) __asm("_" "pthread_cond_wait" );


int pthread_condattr_destroy(pthread_condattr_t *);


int pthread_condattr_init(pthread_condattr_t *);


int pthread_condattr_getpshared(const pthread_condattr_t * restrict,
  int * restrict);


int pthread_condattr_setpshared(pthread_condattr_t *, int);



int pthread_create(pthread_t * restrict,
  const pthread_attr_t * restrict,
  void * (* )(void * ),
  void * restrict);







int pthread_detach(pthread_t);


int pthread_equal(pthread_t , pthread_t );


void pthread_exit(void * ) __attribute__((__noreturn__));


int pthread_getconcurrency(void);


int pthread_getschedparam(pthread_t , int * restrict,
  struct sched_param * restrict);


void* pthread_getspecific(pthread_key_t);


int pthread_join(pthread_t , void * * )
  __asm("_" "pthread_join" );


int pthread_key_create(pthread_key_t *, void (* )(void *));


int pthread_key_delete(pthread_key_t);


int pthread_mutex_destroy(pthread_mutex_t *);


int pthread_mutex_getprioceiling(const pthread_mutex_t * restrict,
  int * restrict);


int pthread_mutex_init(pthread_mutex_t * restrict,
  const pthread_mutexattr_t * restrict);


int pthread_mutex_lock(pthread_mutex_t *);


int pthread_mutex_setprioceiling(pthread_mutex_t * restrict, int,
  int * restrict);


int pthread_mutex_trylock(pthread_mutex_t *);


int pthread_mutex_unlock(pthread_mutex_t *);


int pthread_mutexattr_destroy(pthread_mutexattr_t *) __asm("_" "pthread_mutexattr_destroy" );


int pthread_mutexattr_getprioceiling(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_getprotocol(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_getpshared(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_gettype(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_getpolicy_np(const pthread_mutexattr_t * restrict,
  int * restrict);


int pthread_mutexattr_init(pthread_mutexattr_t *);


int pthread_mutexattr_setprioceiling(pthread_mutexattr_t *, int);


int pthread_mutexattr_setprotocol(pthread_mutexattr_t *, int);


int pthread_mutexattr_setpshared(pthread_mutexattr_t *, int);


int pthread_mutexattr_settype(pthread_mutexattr_t *, int);


int pthread_mutexattr_setpolicy_np(pthread_mutexattr_t *, int);



int pthread_once(pthread_once_t *, void (* )(void));


int pthread_rwlock_destroy(pthread_rwlock_t * ) __asm("_" "pthread_rwlock_destroy" );


int pthread_rwlock_init(pthread_rwlock_t * restrict,
  const pthread_rwlockattr_t * restrict)
  __asm("_" "pthread_rwlock_init" );


int pthread_rwlock_rdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_rdlock" );


int pthread_rwlock_tryrdlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_tryrdlock" );


int pthread_rwlock_trywrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_trywrlock" );


int pthread_rwlock_wrlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_wrlock" );


int pthread_rwlock_unlock(pthread_rwlock_t *) __asm("_" "pthread_rwlock_unlock" );


int pthread_rwlockattr_destroy(pthread_rwlockattr_t *);


int pthread_rwlockattr_getpshared(const pthread_rwlockattr_t * restrict,
  int * restrict);


int pthread_rwlockattr_init(pthread_rwlockattr_t *);


int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *, int);


pthread_t pthread_self(void);


int pthread_setcancelstate(int , int * )
  __asm("_" "pthread_setcancelstate" );


int pthread_setcanceltype(int , int * )
  __asm("_" "pthread_setcanceltype" );


int pthread_setconcurrency(int);


int pthread_setschedparam(pthread_t, int, const struct sched_param *);


int pthread_setspecific(pthread_key_t , const void * );


void pthread_testcancel(void) __asm("_" "pthread_testcancel" );





int pthread_is_threaded_np(void);


int pthread_threadid_np(pthread_t ,__uint64_t* );



int pthread_getname_np(pthread_t,char*,size_t);


int pthread_setname_np(const char*);



int pthread_main_np(void);



mach_port_t pthread_mach_thread_np(pthread_t);


size_t pthread_get_stacksize_np(pthread_t);


void* pthread_get_stackaddr_np(pthread_t);



int pthread_cond_signal_thread_np(pthread_cond_t *, pthread_t );



int pthread_cond_timedwait_relative_np(pthread_cond_t *, pthread_mutex_t *,
  const struct timespec * );




int pthread_create_suspended_np(
  pthread_t * , const pthread_attr_t * ,
  void * (* )(void * ), void * );






int pthread_kill(pthread_t, int);


 pthread_t pthread_from_mach_thread_np(mach_port_t);


int pthread_sigmask(int, const sigset_t * , sigset_t * )
  __asm("_" "pthread_sigmask" );


void pthread_yield_np(void);



void pthread_jit_write_protect_np(int enabled);



int pthread_jit_write_protect_supported_np(void);
# 582 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pthread.h" 3 4

int
pthread_cpu_number_np(size_t *cpu_number_out);



# 86 "project/nnn/src/nnn.c" 2
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 1 3 4
# 11 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
#define FIXINC_WRAP_STDIO_H_STDIO_STDARG_H 1

#define __need___va_list 
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdarg.h" 1 3 4
# 34 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdarg.h" 3 4
#undef __need___va_list




#define __GNUC_VA_LIST 
typedef __builtin_va_list __gnuc_va_list;
# 15 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 2 3 4
# 76 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
#define _STDIO_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_stdio.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_stdio.h" 3 4
#define __STDIO_H_ 
# 75 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_va_list.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_va_list.h" 3 4
#define _VA_LIST_T 

typedef __darwin_va_list va_list;
# 76 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_stdio.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stdio.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/stdio.h" 3 4
#define _SYS_STDIO_H_ 








int renameat(int, const char *, int, const char *) ;



#define RENAME_SECLUDE 0x00000001
#define RENAME_SWAP 0x00000002
#define RENAME_EXCL 0x00000004
int renamex_np(const char *, const char *, unsigned int) ;
int renameatx_np(int, const char *, int, const char *, unsigned int) ;




# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_stdio.h" 2 3 4

typedef __darwin_off_t fpos_t;

#define _FSTDIO 
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_stdio.h" 3 4
struct __sbuf {
 unsigned char *_base;
 int _size;
};


struct __sFILEX;
# 126 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_stdio.h" 3 4
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (* _close)(void *);
 int (* _read) (void *, char *, int);
 fpos_t (* _seek) (void *, fpos_t, int);
 int (* _write)(void *, const char *, int);


 struct __sbuf _ub;
 struct __sFILEX *_extra;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;
# 79 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 2 3 4


extern FILE *__stdinp;
extern FILE *__stdoutp;
extern FILE *__stderrp;


#define __SLBF 0x0001
#define __SNBF 0x0002
#define __SRD 0x0004
#define __SWR 0x0008

#define __SRW 0x0010
#define __SEOF 0x0020
#define __SERR 0x0040
#define __SMBF 0x0080
#define __SAPP 0x0100
#define __SSTR 0x0200
#define __SOPT 0x0400
#define __SNPT 0x0800
#define __SOFF 0x1000
#define __SMOD 0x2000
#define __SALC 0x4000
#define __SIGN 0x8000
# 113 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
#define _IOFBF 0
#define _IOLBF 1
#define _IONBF 2

#define BUFSIZ 1024
#define EOF (-1)


#define FOPEN_MAX 20
#define FILENAME_MAX 1024



#define P_tmpdir "/var/tmp/"

#define L_tmpnam 1024
#define TMP_MAX 308915776
# 141 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
#define stdin __stdinp
#define stdout __stdoutp
#define stderr __stderrp
# 155 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4

void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE * restrict, fpos_t *);
char *fgets(char * restrict, int, FILE *);



FILE *fopen(const char * restrict __filename, const char * restrict __mode) __asm("_" "fopen" );

int fprintf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3)));
int fputc(int, FILE *);
int fputs(const char * restrict, FILE * restrict) __asm("_" "fputs" );
size_t fread(void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream);
FILE *freopen(const char * restrict, const char * restrict,
                 FILE * restrict) __asm("_" "freopen" );
int fscanf(FILE * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));
int fseek(FILE *, long, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
size_t fwrite(const void * restrict __ptr, size_t __size, size_t __nitems, FILE * restrict __stream) __asm("_" "fwrite" );
int getc(FILE *);
int getchar(void);
char *gets(char *);
void perror(const char *) __attribute__((__cold__));
int printf(const char * restrict, ...) __attribute__((__format__ (__printf__, 1, 2)));
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename (const char *__old, const char *__new);
void rewind(FILE *);
int scanf(const char * restrict, ...) __attribute__((__format__ (__scanf__, 1, 2)));
void setbuf(FILE * restrict, char * restrict);
int setvbuf(FILE * restrict, char * restrict, int, size_t);
int sprintf(char * restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) ;
int sscanf(const char * restrict, const char * restrict, ...) __attribute__((__format__ (__scanf__, 2, 3)));
FILE *tmpfile(void);



__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tmpnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE * restrict, const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 2, 0)));
int vprintf(const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 1, 0)));
int vsprintf(char * restrict, const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 2, 0))) ;

# 216 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
#define L_ctermid 1024


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctermid.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctermid.h" 3 4
#define _CTERMID_H_ 





char *ctermid(char *);


# 220 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 2 3 4




FILE *fdopen(int, const char *) __asm("_" "fdopen" );

int fileno(FILE *);

# 237 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
#define __swift_unavailable_on(osx_msg,ios_msg) __swift_unavailable(osx_msg)




int pclose(FILE *) ;



FILE *popen(const char *, const char *) __asm("_" "popen" ) ;




#undef __swift_unavailable_on
# 262 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4

int __srget(FILE *);
int __svfscanf(FILE *, const char *, __gnuc_va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int __swbuf(int, FILE *);






#define __sgetc(p) (--(p)->_r < 0 ? __srget(p) : (int)(*(p)->_p++))

extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int __sputc(int _c, FILE *_p) {
 if (--_p->_w >= 0 || (_p->_w >= _p->_lbfsize && (char)_c != '\n'))
  return (*_p->_p++ = _c);
 else
  return (__swbuf(_c, _p));
}
# 294 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
#define __sfeof(p) (((p)->_flags & __SEOF) != 0)
#define __sferror(p) (((p)->_flags & __SERR) != 0)
#define __sclearerr(p) ((void)((p)->_flags &= ~(__SERR|__SEOF)))
#define __sfileno(p) ((p)->_file)


void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);
int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



int getw(FILE *);
int putw(int, FILE *);




__attribute__((__deprecated__("This function is provided for compatibility reasons only.  Due to security concerns inherent in the design of tempnam(3), it is highly recommended that you use mkstemp(3) instead.")))

char *tempnam(const char *__dir, const char *__prefix) __asm("_" "tempnam" );



#define getc_unlocked(fp) __sgetc(fp)
#define putc_unlocked(x,fp) __sputc(x, fp)


#define getchar_unlocked() getc_unlocked(stdin)
#define putchar_unlocked(x) putc_unlocked(x, stdout)
# 340 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4

int fseeko(FILE * __stream, off_t __offset, int __whence);
off_t ftello(FILE * __stream);





int snprintf(char * restrict __str, size_t __size, const char * restrict __format, ...) __attribute__((__format__ (__printf__, 3, 4)));
int vfscanf(FILE * restrict __stream, const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__scanf__, 2, 0)));
int vscanf(const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__scanf__, 1, 0)));
int vsnprintf(char * restrict __str, size_t __size, const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__printf__, 3, 0)));
int vsscanf(const char * restrict __str, const char * restrict __format, __gnuc_va_list) __attribute__((__format__ (__scanf__, 2, 0)));

# 365 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4

int dprintf(int, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3))) ;
int vdprintf(int, const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 2, 0))) ;
ssize_t getdelim(char ** restrict __linep, size_t * restrict __linecapp, int __delimiter, FILE * restrict __stream) ;
ssize_t getline(char ** restrict __linep, size_t * restrict __linecapp, FILE * restrict __stream) ;
FILE *fmemopen(void * restrict __buf, size_t __size, const char * restrict __mode) ;
FILE *open_memstream(char **__bufp, size_t *__sizep) ;









extern const int sys_nerr;
extern const char *const sys_errlist[];

int asprintf(char ** restrict, const char * restrict, ...) __attribute__((__format__ (__printf__, 2, 3)));
char *ctermid_r(char *);
char *fgetln(FILE *, size_t *);
const char *fmtcheck(const char *, const char *);
int fpurge(FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char ** restrict, const char * restrict, __gnuc_va_list) __attribute__((__format__ (__printf__, 2, 0)));
FILE *zopen(const char *, const char *, int);





FILE *funopen(const void *,
                 int (* )(void *, char *, int),
                 int (* )(void *, const char *, int),
                 fpos_t (* )(void *, fpos_t, int),
                 int (* )(void *));

#define fropen(cookie,fn) funopen(cookie, fn, 0, 0, 0)
#define fwopen(cookie,fn) funopen(cookie, 0, fn, 0, 0)

#define feof_unlocked(p) __sfeof(p)
#define ferror_unlocked(p) __sferror(p)
#define clearerr_unlocked(p) __sclearerr(p)
#define fileno_unlocked(p) __sfileno(p)
# 421 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_stdio.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_stdio.h" 3 4
#define _SECURE__STDIO_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_common.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_common.h" 3 4
#define _SECURE__COMMON_H_ 

#undef _USE_FORTIFY_LEVEL


#define _USE_FORTIFY_LEVEL 2







#define __darwin_obsz0(object) __builtin_object_size (object, 0)
#define __darwin_obsz(object) __builtin_object_size (object, _USE_FORTIFY_LEVEL > 1 ? 1 : 0)
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_stdio.h" 2 3 4
# 42 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_stdio.h" 3 4
extern int __sprintf_chk (char * restrict, int, size_t,
     const char * restrict, ...);

#undef sprintf
#define sprintf(str,...) __builtin___sprintf_chk (str, 0, __darwin_obsz(str), __VA_ARGS__)





extern int __snprintf_chk (char * restrict, size_t, int, size_t,
      const char * restrict, ...);

#undef snprintf
#define snprintf(str,len,...) __builtin___snprintf_chk (str, len, 0, __darwin_obsz(str), __VA_ARGS__)




extern int __vsprintf_chk (char * restrict, int, size_t,
      const char * restrict, va_list);

#undef vsprintf
#define vsprintf(str,format,ap) __builtin___vsprintf_chk (str, 0, __darwin_obsz(str), format, ap)




extern int __vsnprintf_chk (char * restrict, size_t, int, size_t,
       const char * restrict, va_list);

#undef vsnprintf
#define vsnprintf(str,len,format,ap) __builtin___vsnprintf_chk (str, len, 0, __darwin_obsz(str), format, ap)
# 422 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdio.h" 2 3 4
# 87 "project/nnn/src/nnn.c" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/readline/history.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/readline/history.h" 3 4
#define _READLINE_H_ 







typedef int Function(const char *, int);
typedef void VFunction(void);
typedef void VCPFunction(char *);
typedef char *CPFunction(const char *, int);
typedef char **CPPFunction(const char *, int, int);
typedef char *rl_compentry_func_t(const char *, int);
typedef int rl_command_func_t(int, int);


typedef struct {
 int length;
} HISTORY_STATE;

typedef void *histdata_t;

typedef struct _hist_entry {
 const char *line;
 histdata_t data;
} HIST_ENTRY;

typedef struct _keymap_entry {
 char type;
#define ISFUNC 0
#define ISKMAP 1
#define ISMACR 2
 Function *function;
} KEYMAP_ENTRY;

#define KEYMAP_SIZE 256

typedef KEYMAP_ENTRY KEYMAP_ENTRY_ARRAY[256];
typedef KEYMAP_ENTRY *Keymap;

#define control_character_threshold 0x20
#define control_character_bit 0x40


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioctl.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioctl.h" 3 4
#define _SYS_IOCTL_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ttycom.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ttycom.h" 3 4
#define _SYS_TTYCOM_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioccom.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioccom.h" 3 4
#define _SYS_IOCCOM_H_ 
# 74 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioccom.h" 3 4
#define IOCPARM_MASK 0x1fff
#define IOCPARM_LEN(x) (((x) >> 16) & IOCPARM_MASK)
#define IOCBASECMD(x) ((x) & ~(IOCPARM_MASK << 16))
#define IOCGROUP(x) (((x) >> 8) & 0xff)

#define IOCPARM_MAX (IOCPARM_MASK + 1)

#define IOC_VOID (__uint32_t)0x20000000

#define IOC_OUT (__uint32_t)0x40000000

#define IOC_IN (__uint32_t)0x80000000

#define IOC_INOUT (IOC_IN|IOC_OUT)

#define IOC_DIRMASK (__uint32_t)0xe0000000

#define _IOC(inout,group,num,len) (inout | ((len & IOCPARM_MASK) << 16) | ((group) << 8) | (num))

#define _IO(g,n) _IOC(IOC_VOID, (g), (n), 0)
#define _IOR(g,n,t) _IOC(IOC_OUT, (g), (n), sizeof(t))
#define _IOW(g,n,t) _IOC(IOC_IN, (g), (n), sizeof(t))

#define _IOWR(g,n,t) _IOC(IOC_INOUT, (g), (n), sizeof(t))
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ttycom.h" 2 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ttycom.h" 3 4
struct winsize {
 unsigned short ws_row;
 unsigned short ws_col;
 unsigned short ws_xpixel;
 unsigned short ws_ypixel;
};

#define TIOCMODG _IOR('t', 3, int)
#define TIOCMODS _IOW('t', 4, int)
#define TIOCM_LE 0001
#define TIOCM_DTR 0002
#define TIOCM_RTS 0004
#define TIOCM_ST 0010
#define TIOCM_SR 0020
#define TIOCM_CTS 0040
#define TIOCM_CAR 0100
#define TIOCM_CD TIOCM_CAR
#define TIOCM_RNG 0200
#define TIOCM_RI TIOCM_RNG
#define TIOCM_DSR 0400

#define TIOCEXCL _IO('t', 13)
#define TIOCNXCL _IO('t', 14)

#define TIOCFLUSH _IOW('t', 16, int)

#define TIOCGETA _IOR('t', 19, struct termios)
#define TIOCSETA _IOW('t', 20, struct termios)
#define TIOCSETAW _IOW('t', 21, struct termios)
#define TIOCSETAF _IOW('t', 22, struct termios)
#define TIOCGETD _IOR('t', 26, int)
#define TIOCSETD _IOW('t', 27, int)
#define TIOCIXON _IO('t', 129)
#define TIOCIXOFF _IO('t', 128)

#define TIOCSBRK _IO('t', 123)
#define TIOCCBRK _IO('t', 122)
#define TIOCSDTR _IO('t', 121)
#define TIOCCDTR _IO('t', 120)
#define TIOCGPGRP _IOR('t', 119, int)
#define TIOCSPGRP _IOW('t', 118, int)

#define TIOCOUTQ _IOR('t', 115, int)
#define TIOCSTI _IOW('t', 114, char)
#define TIOCNOTTY _IO('t', 113)
#define TIOCPKT _IOW('t', 112, int)
#define TIOCPKT_DATA 0x00
#define TIOCPKT_FLUSHREAD 0x01
#define TIOCPKT_FLUSHWRITE 0x02
#define TIOCPKT_STOP 0x04
#define TIOCPKT_START 0x08
#define TIOCPKT_NOSTOP 0x10
#define TIOCPKT_DOSTOP 0x20
#define TIOCPKT_IOCTL 0x40
#define TIOCSTOP _IO('t', 111)
#define TIOCSTART _IO('t', 110)
#define TIOCMSET _IOW('t', 109, int)
#define TIOCMBIS _IOW('t', 108, int)
#define TIOCMBIC _IOW('t', 107, int)
#define TIOCMGET _IOR('t', 106, int)
#define TIOCREMOTE _IOW('t', 105, int)
#define TIOCGWINSZ _IOR('t', 104, struct winsize)
#define TIOCSWINSZ _IOW('t', 103, struct winsize)
#define TIOCUCNTL _IOW('t', 102, int)
#define TIOCSTAT _IO('t', 101)
#define UIOCCMD(n) _IO('u', n)
#define TIOCSCONS _IO('t', 99)
#define TIOCCONS _IOW('t', 98, int)
#define TIOCSCTTY _IO('t', 97)
#define TIOCEXT _IOW('t', 96, int)
#define TIOCSIG _IO('t', 95)
#define TIOCDRAIN _IO('t', 94)
#define TIOCMSDTRWAIT _IOW('t', 91, int)
#define TIOCMGDTRWAIT _IOR('t', 90, int)
#define TIOCTIMESTAMP _IOR('t', 89, struct timeval)

#define TIOCDCDTIMESTAMP _IOR('t', 88, struct timeval)

#define TIOCSDRAINWAIT _IOW('t', 87, int)
#define TIOCGDRAINWAIT _IOR('t', 86, int)
#define TIOCDSIMICROCODE _IO('t', 85)

#define TIOCPTYGRANT _IO('t', 84)
#define TIOCPTYGNAME _IOC(IOC_OUT, 't', 83, 128)
#define TIOCPTYUNLK _IO('t', 82)

#define TTYDISC 0
#define TABLDISC 3
#define SLIPDISC 4
#define PPPDISC 5
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioctl.h" 2 3 4






struct ttysize {
 unsigned short ts_lines;
 unsigned short ts_cols;
 unsigned short ts_xxx;
 unsigned short ts_yyy;
};
#define TIOCGSIZE TIOCGWINSZ
#define TIOCSSIZE TIOCSWINSZ



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/filio.h" 1 3 4
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/filio.h" 3 4
#define _SYS_FILIO_H_ 




#define FIOCLEX _IO('f', 1)
#define FIONCLEX _IO('f', 2)
#define FIONREAD _IOR('f', 127, int)
#define FIONBIO _IOW('f', 126, int)
#define FIOASYNC _IOW('f', 125, int)
#define FIOSETOWN _IOW('f', 124, int)
#define FIOGETOWN _IOR('f', 123, int)
#define FIODTYPE _IOR('f', 122, int)
# 91 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioctl.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/sockio.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/sockio.h" 3 4
#define _SYS_SOCKIO_H_ 






#define SIOCSHIWAT _IOW('s', 0, int)
#define SIOCGHIWAT _IOR('s', 1, int)
#define SIOCSLOWAT _IOW('s', 2, int)
#define SIOCGLOWAT _IOR('s', 3, int)
#define SIOCATMARK _IOR('s', 7, int)
#define SIOCSPGRP _IOW('s', 8, int)
#define SIOCGPGRP _IOR('s', 9, int)




#define SIOCSIFADDR _IOW('i', 12, struct ifreq)
#define SIOCSIFDSTADDR _IOW('i', 14, struct ifreq)
#define SIOCSIFFLAGS _IOW('i', 16, struct ifreq)
#define SIOCGIFFLAGS _IOWR('i', 17, struct ifreq)
#define SIOCSIFBRDADDR _IOW('i', 19, struct ifreq)
#define SIOCSIFNETMASK _IOW('i', 22, struct ifreq)
#define SIOCGIFMETRIC _IOWR('i', 23, struct ifreq)
#define SIOCSIFMETRIC _IOW('i', 24, struct ifreq)
#define SIOCDIFADDR _IOW('i', 25, struct ifreq)
#define SIOCAIFADDR _IOW('i', 26, struct ifaliasreq)

#define SIOCGIFADDR _IOWR('i', 33, struct ifreq)
#define SIOCGIFDSTADDR _IOWR('i', 34, struct ifreq)
#define SIOCGIFBRDADDR _IOWR('i', 35, struct ifreq)
#define SIOCGIFCONF _IOWR('i', 36, struct ifconf)
#define SIOCGIFNETMASK _IOWR('i', 37, struct ifreq)
#define SIOCAUTOADDR _IOWR('i', 38, struct ifreq)
#define SIOCAUTONETMASK _IOW('i', 39, struct ifreq)
#define SIOCARPIPLL _IOWR('i', 40, struct ifreq)

#define SIOCADDMULTI _IOW('i', 49, struct ifreq)
#define SIOCDELMULTI _IOW('i', 50, struct ifreq)
#define SIOCGIFMTU _IOWR('i', 51, struct ifreq)
#define SIOCSIFMTU _IOW('i', 52, struct ifreq)
#define SIOCGIFPHYS _IOWR('i', 53, struct ifreq)
#define SIOCSIFPHYS _IOW('i', 54, struct ifreq)
#define SIOCSIFMEDIA _IOWR('i', 55, struct ifreq)





#define SIOCGIFMEDIA _IOWR('i', 56, struct ifmediareq)

#define SIOCSIFGENERIC _IOW('i', 57, struct ifreq)
#define SIOCGIFGENERIC _IOWR('i', 58, struct ifreq)
#define SIOCRSLVMULTI _IOWR('i', 59, struct rslvmulti_req)

#define SIOCSIFLLADDR _IOW('i', 60, struct ifreq)
#define SIOCGIFSTATUS _IOWR('i', 61, struct ifstat)
#define SIOCSIFPHYADDR _IOW('i', 62, struct ifaliasreq)
#define SIOCGIFPSRCADDR _IOWR('i', 63, struct ifreq)
#define SIOCGIFPDSTADDR _IOWR('i', 64, struct ifreq)
#define SIOCDIFPHYADDR _IOW('i', 65, struct ifreq)

#define SIOCGIFDEVMTU _IOWR('i', 68, struct ifreq)
#define SIOCSIFALTMTU _IOW('i', 69, struct ifreq)
#define SIOCGIFALTMTU _IOWR('i', 72, struct ifreq)
#define SIOCSIFBOND _IOW('i', 70, struct ifreq)
#define SIOCGIFBOND _IOWR('i', 71, struct ifreq)
# 141 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/sockio.h" 3 4
#define SIOCGIFXMEDIA _IOWR('i', 72, struct ifmediareq)


#define SIOCSIFCAP _IOW('i', 90, struct ifreq)
#define SIOCGIFCAP _IOWR('i', 91, struct ifreq)

#define SIOCIFCREATE _IOWR('i', 120, struct ifreq)
#define SIOCIFDESTROY _IOW('i', 121, struct ifreq)
#define SIOCIFCREATE2 _IOWR('i', 122, struct ifreq)

#define SIOCSDRVSPEC _IOW('i', 123, struct ifdrv)

#define SIOCGDRVSPEC _IOWR('i', 123, struct ifdrv)

#define SIOCSIFVLAN _IOW('i', 126, struct ifreq)
#define SIOCGIFVLAN _IOWR('i', 127, struct ifreq)
#define SIOCSETVLAN SIOCSIFVLAN
#define SIOCGETVLAN SIOCGIFVLAN

#define SIOCIFGCLONERS _IOWR('i', 129, struct if_clonereq)

#define SIOCGIFASYNCMAP _IOWR('i', 124, struct ifreq)
#define SIOCSIFASYNCMAP _IOW('i', 125, struct ifreq)



#define SIOCGIFMAC _IOWR('i', 130, struct ifreq)
#define SIOCSIFMAC _IOW('i', 131, struct ifreq)
#define SIOCSIFKPI _IOW('i', 134, struct ifreq)
#define SIOCGIFKPI _IOWR('i', 135, struct ifreq)

#define SIOCGIFWAKEFLAGS _IOWR('i', 136, struct ifreq)

#define SIOCGIFFUNCTIONALTYPE _IOWR('i', 173, struct ifreq)

#define SIOCSIF6LOWPAN _IOW('i', 196, struct ifreq)
#define SIOCGIF6LOWPAN _IOWR('i', 197, struct ifreq)
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ioctl.h" 2 3 4





int ioctl(int, unsigned long, ...);

# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/readline/history.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ttydefaults.h" 1 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/ttydefaults.h" 3 4
#define _SYS_TTYDEFAULTS_H_ 




#define TTYDEF_IFLAG (BRKINT | ICRNL | IMAXBEL | IXON | IXANY)
#define TTYDEF_OFLAG (OPOST | ONLCR)
#define TTYDEF_LFLAG (ECHO | ICANON | ISIG | IEXTEN | ECHOE|ECHOKE|ECHOCTL)
#define TTYDEF_CFLAG (CREAD | CS8 | HUPCL)
#define TTYDEF_SPEED (B9600)




#define CTRL(x) (x&037)
#define CEOF CTRL('d')
#define CEOL 0xff
#define CERASE 0177
#define CINTR CTRL('c')
#define CSTATUS CTRL('t')
#define CKILL CTRL('u')
#define CMIN 1
#define CQUIT 034
#define CSUSP CTRL('z')
#define CTIME 0
#define CDSUSP CTRL('y')
#define CSTART CTRL('q')
#define CSTOP CTRL('s')
#define CLNEXT CTRL('v')
#define CDISCARD CTRL('o')
#define CWERASE CTRL('w')
#define CREPRINT CTRL('r')
#define CEOT CEOF

#define CBRK CEOL
#define CRPRNT CREPRINT
#define CFLUSH CDISCARD
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/readline/history.h" 2 3 4






#define UNCTRL(c) (((c) - 'a' + 'A')|control_character_bit)


#define RUBOUT 0x7f
#define ABORT_CHAR CTRL('G')
#define RL_READLINE_VERSION 0x0402
#define RL_PROMPT_START_IGNORE '\1'
#define RL_PROMPT_END_IGNORE '\2'





extern const char *rl_library_version;
extern int rl_readline_version;
extern char *rl_readline_name;
extern FILE *rl_instream;
extern FILE *rl_outstream;
extern char *rl_line_buffer;
extern int rl_point, rl_end;
extern int history_base, history_length;
extern int max_input_history;
extern char *rl_basic_word_break_characters;
extern char *rl_completer_word_break_characters;
extern char *rl_completer_quote_characters;
extern Function *rl_completion_entry_function;
extern char *(*rl_completion_word_break_hook)(void);
extern CPPFunction *rl_attempted_completion_function;
extern int rl_attempted_completion_over;
extern int rl_completion_type;
extern int rl_completion_query_items;
extern char *rl_special_prefixes;
extern int rl_completion_append_character;
extern int rl_inhibit_completion;
extern Function *rl_pre_input_hook;
extern Function *rl_startup_hook;
extern char *rl_terminal_name;
extern int rl_already_prompted;
extern char *rl_prompt;



extern KEYMAP_ENTRY_ARRAY emacs_standard_keymap,
   emacs_meta_keymap,
   emacs_ctlx_keymap;
extern int rl_filename_completion_desired;
extern int rl_ignore_completion_duplicates;
extern int (*rl_getc_function)(FILE *);
extern VFunction *rl_redisplay_function;
extern VFunction *rl_completion_display_matches_hook;
extern VFunction *rl_prep_term_function;
extern VFunction *rl_deprep_term_function;
extern int readline_echoing_p;
extern int _rl_print_completions_horizontally;


char *readline(const char *);
int rl_initialize(void);

void using_history(void);
int add_history(const char *);
void clear_history(void);
void stifle_history(int);
int unstifle_history(void);
int history_is_stifled(void);
int where_history(void);
HIST_ENTRY *current_history(void);
HIST_ENTRY *history_get(int);
HIST_ENTRY *remove_history(int);
HIST_ENTRY *replace_history_entry(int, const char *, histdata_t);
int history_total_bytes(void);
int history_set_pos(int);
HIST_ENTRY *previous_history(void);
HIST_ENTRY *next_history(void);
int history_search(const char *, int);
int history_search_prefix(const char *, int);
int history_search_pos(const char *, int, int);
int read_history(const char *);
int write_history(const char *);
int history_truncate_file (const char *, int);
int history_expand(char *, char **);
char **history_tokenize(const char *);
const char *get_history_event(const char *, int *, int);
char *history_arg_extract(int, int, const char *);

char *tilde_expand(char *);
char *filename_completion_function(const char *, int);
char *username_completion_function(const char *, int);
int rl_complete(int, int);
int rl_read_key(void);
char **completion_matches(const char *, CPFunction *);
void rl_display_match_list(char **, int, int);

int rl_insert(int, int);
int rl_insert_text(const char *);
void rl_reset_terminal(const char *);
int rl_bind_key(int, rl_command_func_t *);
int rl_newline(int, int);
void rl_callback_read_char(void);
void rl_callback_handler_install(const char *, VCPFunction *);
void rl_callback_handler_remove(void);
void rl_redisplay(void);
int rl_get_previous_history(int, int);
void rl_prep_terminal(int);
void rl_deprep_terminal(void);
int rl_read_init_file(const char *);
int rl_parse_and_bind(const char *);
int rl_variable_bind(const char *, const char *);
void rl_stuff_char(int);
int rl_add_defun(const char *, Function *, int);
HISTORY_STATE *history_get_history_state(void);
void rl_get_screen_size(int *, int *);
void rl_set_screen_size(int, int);
char *rl_filename_completion_function (const char *, int);
int _rl_abort_internal(void);
int _rl_qsort_string_compare(char **, char **);
char **rl_completion_matches(const char *, rl_compentry_func_t *);
void rl_forced_update_display(void);
int rl_set_prompt(const char *);
int rl_on_new_line(void);




int rl_kill_text(int, int);
Keymap rl_get_keymap(void);
void rl_set_keymap(Keymap);
Keymap rl_make_bare_keymap(void);
int rl_generic_bind(int, const char *, const char *, Keymap);
int rl_bind_key_in_map(int, rl_command_func_t *, Keymap);
void rl_cleanup_after_signal(void);
void rl_free_line_state(void);
# 89 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/readline/readline.h" 1 3 4
# 90 "project/nnn/src/nnn.c" 2




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/regex.h" 1 3 4
# 90 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/regex.h" 3 4
#define _REGEX_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_regex.h" 1 3 4
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_regex.h" 3 4
#define __REGEX_H_ 
# 104 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_regex.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_wchar_t.h" 3 4
#define _WCHAR_T 

typedef __darwin_wchar_t wchar_t;
# 105 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_regex.h" 2 3 4


typedef __darwin_off_t regoff_t;

typedef struct {
 int re_magic;
 size_t re_nsub;
 const char *re_endp;
 struct re_guts *re_g;
} regex_t;

typedef struct {
 regoff_t rm_so;
 regoff_t rm_eo;
} regmatch_t;
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/regex.h" 2 3 4





#define REG_BASIC 0000


#define REG_EXTENDED 0001
#define REG_ICASE 0002
#define REG_NOSUB 0004
#define REG_NEWLINE 0010


#define REG_NOSPEC 0020




#define REG_LITERAL REG_NOSPEC


#define REG_PEND 0040




#define REG_MINIMAL 0100
#define REG_UNGREEDY REG_MINIMAL


#define REG_DUMP 0200




#define REG_ENHANCED 0400






#define REG_ENOSYS (-1)
#define REG_NOMATCH 1
#define REG_BADPAT 2
#define REG_ECOLLATE 3
#define REG_ECTYPE 4
#define REG_EESCAPE 5
#define REG_ESUBREG 6
#define REG_EBRACK 7
#define REG_EPAREN 8
#define REG_EBRACE 9
#define REG_BADBR 10
#define REG_ERANGE 11
#define REG_ESPACE 12
#define REG_BADRPT 13


#define REG_EMPTY 14
#define REG_ASSERT 15
#define REG_INVARG 16
#define REG_ILLSEQ 17

#define REG_ATOI 255
#define REG_ITOA 0400





#define REG_NOTBOL 00001
#define REG_NOTEOL 00002


#define REG_STARTEND 00004
#define REG_TRACE 00400
#define REG_LARGE 01000
#define REG_BACKR 02000




#define REG_BACKTRACKING_MATCHER REG_BACKR




int regcomp(regex_t * restrict, const char * restrict, int) __asm("_" "regcomp" );
size_t regerror(int, const regex_t * restrict, char * restrict, size_t) __attribute__((__cold__));




int regexec(const regex_t * restrict, const char * restrict, size_t,
     regmatch_t __pmatch[ restrict], int);
void regfree(regex_t *);




int regncomp(regex_t * restrict, const char * restrict, size_t, int)
     ;
int regnexec(const regex_t * restrict, const char * restrict, size_t,
     size_t, regmatch_t __pmatch[ restrict], int)
     ;
int regwcomp(regex_t * restrict, const wchar_t * restrict, int)
     ;
int regwexec(const regex_t * restrict, const wchar_t * restrict, size_t,
     regmatch_t __pmatch[ restrict], int)
     ;
int regwncomp(regex_t * restrict, const wchar_t * restrict, size_t, int)
     ;
int regwnexec(const regex_t * restrict, const wchar_t * restrict,
     size_t, size_t, regmatch_t __pmatch[ restrict], int)
     ;



# 95 "project/nnn/src/nnn.c" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/signal.h" 1 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/signal.h" 3 4
#define _USER_SIGNAL_H 
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/signal.h" 3 4
extern const char *const sys_signame[32];
extern const char *const sys_siglist[32];



int raise(int);




void (* bsd_signal(int, void (* )(int)))(int);
int kill(pid_t, int) __asm("_" "kill" );
int killpg(pid_t, int) __asm("_" "killpg" );
int pthread_kill(pthread_t, int);
int pthread_sigmask(int, const sigset_t *, sigset_t *) __asm("_" "pthread_sigmask" );
int sigaction(int, const struct sigaction * restrict,
     struct sigaction * restrict);
int sigaddset(sigset_t *, int);
int sigaltstack(const stack_t * restrict, stack_t * restrict) __asm("_" "sigaltstack" ) ;
int sigdelset(sigset_t *, int);
int sigemptyset(sigset_t *);
int sigfillset(sigset_t *);
int sighold(int);
int sigignore(int);
int siginterrupt(int, int);
int sigismember(const sigset_t *, int);
int sigpause(int) __asm("_" "sigpause" );
int sigpending(sigset_t *);
int sigprocmask(int, const sigset_t * restrict, sigset_t * restrict);
int sigrelse(int);
void (* sigset(int, void (* )(int)))(int);
int sigsuspend(const sigset_t *) __asm("_" "sigsuspend" );
int sigwait(const sigset_t * restrict, int * restrict) __asm("_" "sigwait" );

void psignal(unsigned int, const char *);
int sigblock(int);
int sigsetmask(int);
int sigvec(int, struct sigvec *, struct sigvec *);




extern __inline __attribute__((__gnu_inline__)) __attribute__ ((__always_inline__)) int
__sigbits(int __signo)
{
    return __signo > 32 ? 0 : (1 << (__signo - 1));
}

#define sigaddset(set,signo) (*(set) |= __sigbits(signo), 0)
#define sigdelset(set,signo) (*(set) &= ~__sigbits(signo), 0)
#define sigismember(set,signo) ((*(set) & __sigbits(signo)) != 0)
#define sigemptyset(set) (*(set) = 0, 0)
#define sigfillset(set) (*(set) = ~(sigset_t)0, 0)
# 97 "project/nnn/src/nnn.c" 2
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdarg.h" 1 3 4
# 31 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdarg.h" 3 4
#define _STDARG_H 
#define _ANSI_STDARG_H_ 

#undef __need___va_list
# 47 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdarg.h" 3 4
#define va_start(v,l) __builtin_va_start(v,l)
#define va_end(v) __builtin_va_end(v)
#define va_arg(v,l) __builtin_va_arg(v,l)


#define va_copy(d,s) __builtin_va_copy(d,s)

#define __va_copy(d,s) __builtin_va_copy(d,s)
# 99 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdarg.h" 3 4
typedef __gnuc_va_list va_list;





#define _VA_LIST_ 


#define _VA_LIST 


#define _VA_LIST_DEFINED 


#define _VA_LIST_T_H 


#define __va_list__ 
# 98 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 1 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 3 4
#define _STDLIB_H_ 
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/alloca.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/alloca.h" 3 4
#define _ALLOCA_H_ 






void *alloca(size_t);




#undef alloca
#undef __alloca
#define alloca(size) __alloca(size)
#define __alloca(size) __builtin_alloca(size)
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 2 3 4
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ct_rune_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ct_rune_t.h" 3 4
#define _CT_RUNE_T 

typedef __darwin_ct_rune_t ct_rune_t;
# 78 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_rune_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_rune_t.h" 3 4
#define _RUNE_T 

typedef __darwin_rune_t rune_t;
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 2 3 4

typedef struct {
 int quot;
 int rem;
} div_t;

typedef struct {
 long quot;
 long rem;
} ldiv_t;


typedef struct {
 long long quot;
 long long rem;
} lldiv_t;




#define EXIT_FAILURE 1
#define EXIT_SUCCESS 0

#define RAND_MAX 0x7fffffff
# 118 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 3 4
extern int __mb_cur_max;
#define MB_CUR_MAX __mb_cur_max
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/malloc/_malloc.h" 1 3 4
# 25 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/malloc/_malloc.h" 3 4
#define _MALLOC_UNDERSCORE_MALLOC_H_ 
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/malloc/_malloc.h" 3 4


void *malloc(size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1)));
void *calloc(size_t __count, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(1,2)));
void free(void *);
void *realloc(void *__ptr, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2)));

void *valloc(size_t) __attribute__((alloc_size(1)));




void *aligned_alloc(size_t __alignment, size_t __size) __attribute__((__warn_unused_result__)) __attribute__((alloc_size(2))) ;

int posix_memalign(void **__memptr, size_t __alignment, size_t __size) ;


# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 2 3 4


void abort(void) __attribute__((__cold__)) __attribute__((__noreturn__));
int abs(int) __attribute__((__const__));
int atexit(void (* )(void));
double atof(const char *);
int atoi(const char *);
long atol(const char *);

long long
  atoll(const char *);

void *bsearch(const void *__key, const void *__base, size_t __nel,
     size_t __width, int (* __compar)(const void *, const void *));

div_t div(int, int) __attribute__((__const__));
void exit(int) __attribute__((__noreturn__));

char *getenv(const char *);
long labs(long) __attribute__((__const__));
ldiv_t ldiv(long, long) __attribute__((__const__));

long long
  llabs(long long);
lldiv_t lldiv(long long, long long);


int mblen(const char *__s, size_t __n);
size_t mbstowcs(wchar_t * restrict , const char * restrict, size_t);
int mbtowc(wchar_t * restrict, const char * restrict, size_t);

void qsort(void *__base, size_t __nel, size_t __width,
     int (* __compar)(const void *, const void *));
int rand(void) ;

void srand(unsigned) ;
double strtod(const char *, char **) __asm("_" "strtod" );
float strtof(const char *, char **) __asm("_" "strtof" );
long strtol(const char *__str, char **__endptr, int __base);
long double
  strtold(const char *, char **);

long long
  strtoll(const char *__str, char **__endptr, int __base);

unsigned long
  strtoul(const char *__str, char **__endptr, int __base);

unsigned long long
  strtoull(const char *__str, char **__endptr, int __base);





#define __swift_unavailable_on(osx_msg,ios_msg) __swift_unavailable(osx_msg)





int system(const char *) __asm("_" "system" );

#undef __swift_unavailable_on

size_t wcstombs(char * restrict, const wchar_t * restrict, size_t);
int wctomb(char *, wchar_t);


void _Exit(int) __attribute__((__noreturn__));
long a64l(const char *);
double drand48(void);
char *ecvt(double, int, int *restrict, int *restrict);
double erand48(unsigned short[3]);
char *fcvt(double, int, int *restrict, int *restrict);
char *gcvt(double, int, char *);
int getsubopt(char **, char * const *, char **);
int grantpt(int);

char *initstate(unsigned, char *, size_t);



long jrand48(unsigned short[3]) ;
char *l64a(long);
void lcong48(unsigned short[7]);
long lrand48(void) ;
char *mktemp(char *);
int mkstemp(char *);
long mrand48(void) ;
long nrand48(unsigned short[3]) ;
int posix_openpt(int);
char *ptsname(int);


int ptsname_r(int fildes, char *buffer, size_t buflen) ;


int putenv(char *) __asm("_" "putenv" );
long random(void) ;
int rand_r(unsigned *) ;

char *realpath(const char * restrict, char * restrict) __asm("_" "realpath" "$DARWIN_EXTSN");



unsigned short
 *seed48(unsigned short[3]);
int setenv(const char * __name, const char * __value, int __overwrite) __asm("_" "setenv" );

void setkey(const char *) __asm("_" "setkey" );



char *setstate(const char *);
void srand48(long);

void srandom(unsigned);



int unlockpt(int);

int unsetenv(const char *) __asm("_" "unsetenv" );
# 264 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 3 4
uint32_t arc4random(void);
void arc4random_addrandom(unsigned char * , int )
   
   
   
    ;
void arc4random_buf(void * __buf, size_t __nbytes) ;
void arc4random_stir(void);
uint32_t
  arc4random_uniform(uint32_t __upper_bound) ;







char *cgetcap(char *, const char *, int);
int cgetclose(void);
int cgetent(char **, char **, const char *);
int cgetfirst(char **, char **);
int cgetmatch(const char *, const char *);
int cgetnext(char **, char **);
int cgetnum(char *, const char *, long *);
int cgetset(const char *);
int cgetstr(char *, const char *, char **);
int cgetustr(char *, const char *, char **);

int daemon(int, int) __asm("_" "daemon" "$1050") ;
char *devname(dev_t, mode_t);
char *devname_r(dev_t, mode_t, char *buf, int len);
char *getbsize(int *, long *);
int getloadavg(double [], int);
const char
 *getprogname(void);
void setprogname(const char *);
# 309 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/stdlib.h" 3 4
int heapsort(void *__base, size_t __nel, size_t __width,
     int (* __compar)(const void *, const void *));





int mergesort(void *__base, size_t __nel, size_t __width,
     int (* __compar)(const void *, const void *));





void psort(void *__base, size_t __nel, size_t __width,
     int (* __compar)(const void *, const void *))
     ;





void psort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* __compar)(void *, const void *, const void *))
     ;





void qsort_r(void *__base, size_t __nel, size_t __width, void *,
     int (* __compar)(void *, const void *, const void *));
int radixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
int rpmatch(const char *)
 ;
int sradixsort(const unsigned char **__base, int __nel, const unsigned char *__table,
     unsigned __endbyte);
void sranddev(void);
void srandomdev(void);
void *reallocf(void *__ptr, size_t __size) __attribute__((alloc_size(2)));
long long
 strtonum(const char *__numstr, long long __minval, long long __maxval, const char **__errstrp)
 ;

long long
  strtoq(const char *__str, char **__endptr, int __base);
unsigned long long
  strtouq(const char *__str, char **__endptr, int __base);

extern char *suboptarg;








# 99 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 1 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4
#define _STRING_H_ 
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);

# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

char *strtok_r(char *__str, const char *__sep, char **__lasts);

# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);

# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) ;
char *strndup(const char *__s1, size_t __n) ;
size_t strnlen(const char *__s1, size_t __n) ;
char *strsignal(int __sig);

# 144 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n) ;









void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len) ;
void memset_pattern4(void *__b, const void *__pattern4, size_t __len) ;
void memset_pattern8(void *__b, const void *__pattern8, size_t __len) ;
void memset_pattern16(void *__b, const void *__pattern16, size_t __len) ;

char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);


void swab(const void * restrict, void * restrict, ssize_t);



int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);



int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen);







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 1 3 4
# 59 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 3 4
#define _STRINGS_H_ 










int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);





int ffsl(long) ;
int ffsll(long long) ;
int fls(int) ;
int flsl(long) ;
int flsll(long long) ;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_strings.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_strings.h" 3 4
#define _SECURE__STRINGS_H_ 
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_strings.h" 3 4
#undef bcopy

#define bcopy(src,dest,...) __builtin___memmove_chk (dest, src, __VA_ARGS__, __darwin_obsz0 (dest))




#undef bzero

#define bzero(dest,...) __builtin___memset_chk (dest, 0, __VA_ARGS__, __darwin_obsz0 (dest))
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 2 3 4
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_string.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_string.h" 3 4
#define _SECURE__STRING_H_ 
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_string.h" 3 4
#define __HAS_FIXED_CHK_PROTOTYPES 0
# 60 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_string.h" 3 4
#undef memcpy

#define memcpy(dest,...) __builtin___memcpy_chk (dest, __VA_ARGS__, __darwin_obsz0 (dest))




#undef memmove

#define memmove(dest,...) __builtin___memmove_chk (dest, __VA_ARGS__, __darwin_obsz0 (dest))




#undef memset

#define memset(dest,...) __builtin___memset_chk (dest, __VA_ARGS__, __darwin_obsz0 (dest))




#undef strcpy

#define strcpy(dest,...) __builtin___strcpy_chk (dest, __VA_ARGS__, __darwin_obsz (dest))





#undef stpcpy

#define stpcpy(dest,...) __builtin___stpcpy_chk (dest, __VA_ARGS__, __darwin_obsz (dest))






#undef stpncpy

#define stpncpy(dest,...) __builtin___stpncpy_chk (dest, __VA_ARGS__, __darwin_obsz (dest))
# 125 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_string.h" 3 4
#undef strncpy

#define strncpy(dest,...) __builtin___strncpy_chk (dest, __VA_ARGS__, __darwin_obsz (dest))




#undef strcat

#define strcat(dest,...) __builtin___strcat_chk (dest, __VA_ARGS__, __darwin_obsz (dest))





#undef strncat

#define strncat(dest,...) __builtin___strncat_chk (dest, __VA_ARGS__, __darwin_obsz (dest))




#undef __HAS_FIXED_CHK_PROTOTYPES
# 195 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4
# 100 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 1 3 4
# 101 "project/nnn/src/nnn.c" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 1 3 4
# 69 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4
#define _UNISTD_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/unistd.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/unistd.h" 3 4
#define _SYS_UNISTD_H_ 
# 79 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/unistd.h" 3 4
#define _POSIX_VERSION 200112L
#define _POSIX2_VERSION 200112L



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_posix_vdisable.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_posix_vdisable.h" 3 4
#define _POSIX_VDISABLE ((unsigned char)'\377')
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/unistd.h" 2 3 4

#define _POSIX_THREAD_KEYS_MAX 128


#define F_OK 0
#define X_OK (1<<0)
#define W_OK (1<<1)
#define R_OK (1<<2)







#define _READ_OK (1<<9)
#define _WRITE_OK (1<<10)
#define _EXECUTE_OK (1<<11)
#define _DELETE_OK (1<<12)
#define _APPEND_OK (1<<13)
#define _RMFILE_OK (1<<14)
#define _RATTR_OK (1<<15)
#define _WATTR_OK (1<<16)
#define _REXT_OK (1<<17)
#define _WEXT_OK (1<<18)
#define _RPERM_OK (1<<19)
#define _WPERM_OK (1<<20)
#define _CHOWN_OK (1<<21)

#define _ACCESS_EXTENDED_MASK (_READ_OK | _WRITE_OK | _EXECUTE_OK | _DELETE_OK | _APPEND_OK | _RMFILE_OK | _REXT_OK | _WEXT_OK | _RATTR_OK | _WATTR_OK | _RPERM_OK | _WPERM_OK | _CHOWN_OK)







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_seek_set.h" 1 3 4
# 123 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/unistd.h" 2 3 4



#define L_SET SEEK_SET
#define L_INCR SEEK_CUR
#define L_XTND SEEK_END



struct accessx_descriptor {
 unsigned int ad_name_offset;
 int ad_flags;
 int ad_pad[2];
};
#define ACCESSX_MAX_DESCRIPTORS 100
#define ACCESSX_MAX_TABLESIZE (16 * 1024)



#define _PC_LINK_MAX 1
#define _PC_MAX_CANON 2
#define _PC_MAX_INPUT 3
#define _PC_NAME_MAX 4
#define _PC_PATH_MAX 5
#define _PC_PIPE_BUF 6
#define _PC_CHOWN_RESTRICTED 7
#define _PC_NO_TRUNC 8
#define _PC_VDISABLE 9


#define _PC_NAME_CHARS_MAX 10
#define _PC_CASE_SENSITIVE 11
#define _PC_CASE_PRESERVING 12
#define _PC_EXTENDED_SECURITY_NP 13
#define _PC_AUTH_OPAQUE_NP 14


#define _PC_2_SYMLINKS 15
#define _PC_ALLOC_SIZE_MIN 16
#define _PC_ASYNC_IO 17
#define _PC_FILESIZEBITS 18
#define _PC_PRIO_IO 19
#define _PC_REC_INCR_XFER_SIZE 20
#define _PC_REC_MAX_XFER_SIZE 21
#define _PC_REC_MIN_XFER_SIZE 22
#define _PC_REC_XFER_ALIGN 23
#define _PC_SYMLINK_MAX 24
#define _PC_SYNC_IO 25
#define _PC_XATTR_SIZE_BITS 26
#define _PC_MIN_HOLE_SIZE 27


#define _CS_PATH 1
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/unistd.h" 3 4


int getattrlistbulk(int, void *, void *, size_t, uint64_t) ;
int getattrlistat(int, const char *, void *, void *, size_t, unsigned long) ;
int setattrlistat(int, const char *, void *, void *, size_t, uint32_t) ;


# 205 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/unistd.h" 3 4


int faccessat(int, const char *, int, int) ;
int fchownat(int, const char *, uid_t, gid_t, int) ;
int linkat(int, const char *, int, const char *, int) ;
ssize_t readlinkat(int, const char *, char *, size_t) ;
int symlinkat(const char *, int, const char *) ;
int unlinkat(int, const char *, int) ;


# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 2 3 4
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4
#define STDIN_FILENO 0
#define STDOUT_FILENO 1
#define STDERR_FILENO 2




#define _XOPEN_VERSION 600
#define _XOPEN_XCU_VERSION 4



#define _POSIX_ADVISORY_INFO (-1)
#define _POSIX_ASYNCHRONOUS_IO (-1)
#define _POSIX_BARRIERS (-1)
#define _POSIX_CHOWN_RESTRICTED 200112L
#define _POSIX_CLOCK_SELECTION (-1)
#define _POSIX_CPUTIME (-1)
#define _POSIX_FSYNC 200112L
#define _POSIX_IPV6 200112L
#define _POSIX_JOB_CONTROL 200112L
#define _POSIX_MAPPED_FILES 200112L
#define _POSIX_MEMLOCK (-1)
#define _POSIX_MEMLOCK_RANGE (-1)
#define _POSIX_MEMORY_PROTECTION 200112L
#define _POSIX_MESSAGE_PASSING (-1)
#define _POSIX_MONOTONIC_CLOCK (-1)
#define _POSIX_NO_TRUNC 200112L
#define _POSIX_PRIORITIZED_IO (-1)
#define _POSIX_PRIORITY_SCHEDULING (-1)
#define _POSIX_RAW_SOCKETS (-1)
#define _POSIX_READER_WRITER_LOCKS 200112L
#define _POSIX_REALTIME_SIGNALS (-1)
#define _POSIX_REGEXP 200112L
#define _POSIX_SAVED_IDS 200112L
#define _POSIX_SEMAPHORES (-1)
#define _POSIX_SHARED_MEMORY_OBJECTS (-1)
#define _POSIX_SHELL 200112L
#define _POSIX_SPAWN (-1)
#define _POSIX_SPIN_LOCKS (-1)
#define _POSIX_SPORADIC_SERVER (-1)
#define _POSIX_SYNCHRONIZED_IO (-1)
#define _POSIX_THREAD_ATTR_STACKADDR 200112L
#define _POSIX_THREAD_ATTR_STACKSIZE 200112L
#define _POSIX_THREAD_CPUTIME (-1)
#define _POSIX_THREAD_PRIO_INHERIT (-1)
#define _POSIX_THREAD_PRIO_PROTECT (-1)
#define _POSIX_THREAD_PRIORITY_SCHEDULING (-1)
#define _POSIX_THREAD_PROCESS_SHARED 200112L
#define _POSIX_THREAD_SAFE_FUNCTIONS 200112L
#define _POSIX_THREAD_SPORADIC_SERVER (-1)
#define _POSIX_THREADS 200112L
#define _POSIX_TIMEOUTS (-1)
#define _POSIX_TIMERS (-1)
#define _POSIX_TRACE (-1)
#define _POSIX_TRACE_EVENT_FILTER (-1)
#define _POSIX_TRACE_INHERIT (-1)
#define _POSIX_TRACE_LOG (-1)
#define _POSIX_TYPED_MEMORY_OBJECTS (-1)





#define _POSIX2_C_BIND 200112L
#define _POSIX2_C_DEV 200112L
#define _POSIX2_CHAR_TERM 200112L
#define _POSIX2_FORT_DEV (-1)
#define _POSIX2_FORT_RUN 200112L
#define _POSIX2_LOCALEDEF 200112L
#define _POSIX2_PBS (-1)
#define _POSIX2_PBS_ACCOUNTING (-1)
#define _POSIX2_PBS_CHECKPOINT (-1)
#define _POSIX2_PBS_LOCATE (-1)
#define _POSIX2_PBS_MESSAGE (-1)
#define _POSIX2_PBS_TRACK (-1)
#define _POSIX2_SW_DEV 200112L
#define _POSIX2_UPE 200112L


#define __ILP32_OFF32 (-1)
#define __ILP32_OFFBIG (-1)

#define __LP64_OFF64 (1)
#define __LPBIG_OFFBIG (1)


#define _POSIX_V6_ILP32_OFF32 __ILP32_OFF32
#define _POSIX_V6_ILP32_OFFBIG __ILP32_OFFBIG
#define _POSIX_V6_LP64_OFF64 __LP64_OFF64
#define _POSIX_V6_LPBIG_OFFBIG __LPBIG_OFFBIG



#define _POSIX_V7_ILP32_OFF32 __ILP32_OFF32
#define _POSIX_V7_ILP32_OFFBIG __ILP32_OFFBIG
#define _POSIX_V7_LP64_OFF64 __LP64_OFF64
#define _POSIX_V7_LPBIG_OFFBIG __LPBIG_OFFBIG



#define _V6_ILP32_OFF32 __ILP32_OFF32
#define _V6_ILP32_OFFBIG __ILP32_OFFBIG
#define _V6_LP64_OFF64 __LP64_OFF64
#define _V6_LPBIG_OFFBIG __LPBIG_OFFBIG




#define _XBS5_ILP32_OFF32 __ILP32_OFF32
#define _XBS5_ILP32_OFFBIG __ILP32_OFFBIG
#define _XBS5_LP64_OFF64 __LP64_OFF64
#define _XBS5_LPBIG_OFFBIG __LPBIG_OFFBIG



#define _XOPEN_CRYPT (1)
#define _XOPEN_ENH_I18N (1)
#define _XOPEN_LEGACY (-1)
#define _XOPEN_REALTIME (-1)
#define _XOPEN_REALTIME_THREADS (-1)
#define _XOPEN_SHM (1)
#define _XOPEN_STREAMS (-1)
#define _XOPEN_UNIX (1)



#define _SC_ARG_MAX 1
#define _SC_CHILD_MAX 2
#define _SC_CLK_TCK 3
#define _SC_NGROUPS_MAX 4
#define _SC_OPEN_MAX 5
#define _SC_JOB_CONTROL 6
#define _SC_SAVED_IDS 7
#define _SC_VERSION 8
#define _SC_BC_BASE_MAX 9
#define _SC_BC_DIM_MAX 10
#define _SC_BC_SCALE_MAX 11
#define _SC_BC_STRING_MAX 12
#define _SC_COLL_WEIGHTS_MAX 13
#define _SC_EXPR_NEST_MAX 14
#define _SC_LINE_MAX 15
#define _SC_RE_DUP_MAX 16
#define _SC_2_VERSION 17
#define _SC_2_C_BIND 18
#define _SC_2_C_DEV 19
#define _SC_2_CHAR_TERM 20
#define _SC_2_FORT_DEV 21
#define _SC_2_FORT_RUN 22
#define _SC_2_LOCALEDEF 23
#define _SC_2_SW_DEV 24
#define _SC_2_UPE 25
#define _SC_STREAM_MAX 26
#define _SC_TZNAME_MAX 27


#define _SC_ASYNCHRONOUS_IO 28
#define _SC_PAGESIZE 29
#define _SC_MEMLOCK 30
#define _SC_MEMLOCK_RANGE 31
#define _SC_MEMORY_PROTECTION 32
#define _SC_MESSAGE_PASSING 33
#define _SC_PRIORITIZED_IO 34
#define _SC_PRIORITY_SCHEDULING 35
#define _SC_REALTIME_SIGNALS 36
#define _SC_SEMAPHORES 37
#define _SC_FSYNC 38
#define _SC_SHARED_MEMORY_OBJECTS 39
#define _SC_SYNCHRONIZED_IO 40
#define _SC_TIMERS 41
#define _SC_AIO_LISTIO_MAX 42
#define _SC_AIO_MAX 43
#define _SC_AIO_PRIO_DELTA_MAX 44
#define _SC_DELAYTIMER_MAX 45
#define _SC_MQ_OPEN_MAX 46
#define _SC_MAPPED_FILES 47
#define _SC_RTSIG_MAX 48
#define _SC_SEM_NSEMS_MAX 49
#define _SC_SEM_VALUE_MAX 50
#define _SC_SIGQUEUE_MAX 51
#define _SC_TIMER_MAX 52



#define _SC_NPROCESSORS_CONF 57
#define _SC_NPROCESSORS_ONLN 58



#define _SC_2_PBS 59
#define _SC_2_PBS_ACCOUNTING 60
#define _SC_2_PBS_CHECKPOINT 61
#define _SC_2_PBS_LOCATE 62
#define _SC_2_PBS_MESSAGE 63
#define _SC_2_PBS_TRACK 64
#define _SC_ADVISORY_INFO 65
#define _SC_BARRIERS 66
#define _SC_CLOCK_SELECTION 67
#define _SC_CPUTIME 68
#define _SC_FILE_LOCKING 69
#define _SC_GETGR_R_SIZE_MAX 70
#define _SC_GETPW_R_SIZE_MAX 71
#define _SC_HOST_NAME_MAX 72
#define _SC_LOGIN_NAME_MAX 73
#define _SC_MONOTONIC_CLOCK 74
#define _SC_MQ_PRIO_MAX 75
#define _SC_READER_WRITER_LOCKS 76
#define _SC_REGEXP 77
#define _SC_SHELL 78
#define _SC_SPAWN 79
#define _SC_SPIN_LOCKS 80
#define _SC_SPORADIC_SERVER 81
#define _SC_THREAD_ATTR_STACKADDR 82
#define _SC_THREAD_ATTR_STACKSIZE 83
#define _SC_THREAD_CPUTIME 84
#define _SC_THREAD_DESTRUCTOR_ITERATIONS 85
#define _SC_THREAD_KEYS_MAX 86
#define _SC_THREAD_PRIO_INHERIT 87
#define _SC_THREAD_PRIO_PROTECT 88
#define _SC_THREAD_PRIORITY_SCHEDULING 89
#define _SC_THREAD_PROCESS_SHARED 90
#define _SC_THREAD_SAFE_FUNCTIONS 91
#define _SC_THREAD_SPORADIC_SERVER 92
#define _SC_THREAD_STACK_MIN 93
#define _SC_THREAD_THREADS_MAX 94
#define _SC_TIMEOUTS 95
#define _SC_THREADS 96
#define _SC_TRACE 97
#define _SC_TRACE_EVENT_FILTER 98
#define _SC_TRACE_INHERIT 99
#define _SC_TRACE_LOG 100
#define _SC_TTY_NAME_MAX 101
#define _SC_TYPED_MEMORY_OBJECTS 102
#define _SC_V6_ILP32_OFF32 103
#define _SC_V6_ILP32_OFFBIG 104
#define _SC_V6_LP64_OFF64 105
#define _SC_V6_LPBIG_OFFBIG 106
#define _SC_IPV6 118
#define _SC_RAW_SOCKETS 119
#define _SC_SYMLOOP_MAX 120



#define _SC_ATEXIT_MAX 107
#define _SC_IOV_MAX 56
#define _SC_PAGE_SIZE _SC_PAGESIZE
#define _SC_XOPEN_CRYPT 108
#define _SC_XOPEN_ENH_I18N 109
#define _SC_XOPEN_LEGACY 110
#define _SC_XOPEN_REALTIME 111
#define _SC_XOPEN_REALTIME_THREADS 112
#define _SC_XOPEN_SHM 113
#define _SC_XOPEN_STREAMS 114
#define _SC_XOPEN_UNIX 115
#define _SC_XOPEN_VERSION 116
#define _SC_XOPEN_XCU_VERSION 121




#define _SC_XBS5_ILP32_OFF32 122
#define _SC_XBS5_ILP32_OFFBIG 123
#define _SC_XBS5_LP64_OFF64 124
#define _SC_XBS5_LPBIG_OFFBIG 125



#define _SC_SS_REPL_MAX 126
#define _SC_TRACE_EVENT_NAME_MAX 127
#define _SC_TRACE_NAME_MAX 128
#define _SC_TRACE_SYS_MAX 129
#define _SC_TRACE_USER_EVENT_MAX 130




#define _SC_PASS_MAX 131




#define _SC_PHYS_PAGES 200
# 377 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4
#define _CS_POSIX_V6_ILP32_OFF32_CFLAGS 2
#define _CS_POSIX_V6_ILP32_OFF32_LDFLAGS 3
#define _CS_POSIX_V6_ILP32_OFF32_LIBS 4
#define _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS 5
#define _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS 6
#define _CS_POSIX_V6_ILP32_OFFBIG_LIBS 7
#define _CS_POSIX_V6_LP64_OFF64_CFLAGS 8
#define _CS_POSIX_V6_LP64_OFF64_LDFLAGS 9
#define _CS_POSIX_V6_LP64_OFF64_LIBS 10
#define _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS 11
#define _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS 12
#define _CS_POSIX_V6_LPBIG_OFFBIG_LIBS 13
#define _CS_POSIX_V6_WIDTH_RESTRICTED_ENVS 14




#define _CS_XBS5_ILP32_OFF32_CFLAGS 20
#define _CS_XBS5_ILP32_OFF32_LDFLAGS 21
#define _CS_XBS5_ILP32_OFF32_LIBS 22
#define _CS_XBS5_ILP32_OFF32_LINTFLAGS 23
#define _CS_XBS5_ILP32_OFFBIG_CFLAGS 24
#define _CS_XBS5_ILP32_OFFBIG_LDFLAGS 25
#define _CS_XBS5_ILP32_OFFBIG_LIBS 26
#define _CS_XBS5_ILP32_OFFBIG_LINTFLAGS 27
#define _CS_XBS5_LP64_OFF64_CFLAGS 28
#define _CS_XBS5_LP64_OFF64_LDFLAGS 29
#define _CS_XBS5_LP64_OFF64_LIBS 30
#define _CS_XBS5_LP64_OFF64_LINTFLAGS 31
#define _CS_XBS5_LPBIG_OFFBIG_CFLAGS 32
#define _CS_XBS5_LPBIG_OFFBIG_LDFLAGS 33
#define _CS_XBS5_LPBIG_OFFBIG_LIBS 34
#define _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS 35



#define _CS_DARWIN_USER_DIR 65536
#define _CS_DARWIN_USER_TEMP_DIR 65537
#define _CS_DARWIN_USER_CACHE_DIR 65538
# 429 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4

void _exit(int) __attribute__((__noreturn__));
int access(const char *, int);
unsigned int
  alarm(unsigned int);
int chdir(const char *);
int chown(const char *, uid_t, gid_t);

int close(int) __asm("_" "close" );

int dup(int);
int dup2(int, int);
int execl(const char * __path, const char * __arg0, ...) ;
int execle(const char * __path, const char * __arg0, ...) ;
int execlp(const char * __file, const char * __arg0, ...) ;
int execv(const char * __path, char * const * __argv) ;
int execve(const char * __file, char * const * __argv, char * const * __envp) ;
int execvp(const char * __file, char * const * __argv) ;
pid_t fork(void) ;
long fpathconf(int, int);
char *getcwd(char *, size_t);
gid_t getegid(void);
uid_t geteuid(void);
gid_t getgid(void);



int getgroups(int, gid_t []);

char *getlogin(void);
pid_t getpgrp(void);
pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
int isatty(int);
int link(const char *, const char *);
off_t lseek(int, off_t, int);
long pathconf(const char *, int);

int pause(void) __asm("_" "pause" );

int pipe(int [2]);

ssize_t read(int, void *, size_t) __asm("_" "read" );

int rmdir(const char *);
int setgid(gid_t);
int setpgid(pid_t, pid_t);
pid_t setsid(void);
int setuid(uid_t);

unsigned int
  sleep(unsigned int) __asm("_" "sleep" );

long sysconf(int);
pid_t tcgetpgrp(int);
int tcsetpgrp(int, pid_t);
char *ttyname(int);


int ttyname_r(int, char *, size_t) __asm("_" "ttyname_r" );




int unlink(const char *);

ssize_t write(int __fd, const void * __buf, size_t __nbyte) __asm("_" "write" );

# 506 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4

size_t confstr(int, char *, size_t) __asm("_" "confstr" );

int getopt(int, char * const [], const char *) __asm("_" "getopt" );

extern char *optarg;
extern int optind, opterr, optopt;

# 527 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4
#define F_ULOCK 0
#define F_LOCK 1
#define F_TLOCK 2
#define F_TEST 3







__attribute__((__deprecated__))

void *brk(const void *);
int chroot(const char *) ;


char *crypt(const char *, const char *);

void encrypt(char *, int) __asm("_" "encrypt" );



int fchdir(int);
long gethostid(void);
pid_t getpgid(pid_t);
pid_t getsid(pid_t);



int getdtablesize(void) ;
int getpagesize(void) __attribute__((__const__)) ;
char *getpass(const char *) ;




char *getwd(char *) ;


int lchown(const char *, uid_t, gid_t) __asm("_" "lchown" );

int lockf(int, int, off_t) __asm("_" "lockf" );

int nice(int) __asm("_" "nice" );

ssize_t pread(int __fd, void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pread" );

ssize_t pwrite(int __fd, const void * __buf, size_t __nbyte, off_t __offset) __asm("_" "pwrite" );






__attribute__((__deprecated__))

void *sbrk(int);



pid_t setpgrp(void) __asm("_" "setpgrp" );




int setregid(gid_t, gid_t) __asm("_" "setregid" );

int setreuid(uid_t, uid_t) __asm("_" "setreuid" );

void swab(const void * restrict, void * restrict, ssize_t);
void sync(void);
int truncate(const char *, off_t);
useconds_t ualarm(useconds_t, useconds_t);
int usleep(useconds_t) __asm("_" "usleep" );
pid_t vfork(void) ;


int fsync(int) __asm("_" "fsync" );

int ftruncate(int, off_t);
int getlogin_r(char *, size_t);

# 620 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4

int fchown(int, uid_t, gid_t);
int gethostname(char *, size_t);
ssize_t readlink(const char * restrict, char * restrict, size_t);
int setegid(gid_t);
int seteuid(uid_t);
int symlink(const char *, const char *);








# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/select.h" 1 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/select.h" 3 4
#define _SYS_SELECT_H_ 
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/select.h" 3 4



int pselect(int, fd_set * restrict, fd_set * restrict,
    fd_set * restrict, const struct timespec * restrict,
    const sigset_t * restrict)




__asm("_" "pselect" "$1050")




;





# 636 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 2 3 4



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uuid_t.h" 1 3 4
# 29 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uuid_t.h" 3 4
#define _UUID_T 

typedef __darwin_uuid_t uuid_t;
# 640 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 2 3 4


void _Exit(int) __attribute__((__noreturn__));
int accessx_np(const struct accessx_descriptor *, size_t, int *, uid_t);
int acct(const char *);
int add_profil(char *, size_t, unsigned long, unsigned int) ;
void endusershell(void);
int execvP(const char * __file, const char * __searchpath, char * const * __argv) ;
char *fflagstostr(unsigned long);
int getdomainname(char *, int);
int getgrouplist(const char *, int, int *, int *);




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/gethostuuid.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/gethostuuid.h" 3 4
#define __GETHOSTUUID_H 
# 39 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/gethostuuid.h" 3 4
int gethostuuid(uuid_t, const struct timespec *) ;
# 656 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 2 3 4




mode_t getmode(const void *, mode_t);
int getpeereid(int, uid_t *, gid_t *);
int getsgroups_np(int *, uuid_t);
char *getusershell(void);
int getwgroups_np(int *, uuid_t);
int initgroups(const char *, int);
int issetugid(void);
char *mkdtemp(char *);
int mknod(const char *, mode_t, dev_t);
int mkpath_np(const char *path, mode_t omode) ;
int mkpathat_np(int dfd, const char *path, mode_t omode)
 
  ;
int mkstemp(char *);
int mkstemps(char *, int);
char *mktemp(char *);
int mkostemp(char *path, int oflags)
 
  ;
int mkostemps(char *path, int slen, int oflags)
 
  ;

int mkstemp_dprotected_np(char *path, int dpclass, int dpflags)
 
  ;
char *mkdtempat_np(int dfd, char *path)
 
  ;
int mkstempsat_np(int dfd, char *path, int slen)
 
  ;
int mkostempsat_np(int dfd, char *path, int slen, int oflags)
 
  ;
int nfssvc(int, void *);
int profil(char *, size_t, unsigned long, unsigned int);

__attribute__((__deprecated__("Use of per-thread security contexts is error-prone and discouraged.")))
int pthread_setugid_np(uid_t, gid_t);
int pthread_getugid_np( uid_t *, gid_t *);

int reboot(int);
int revoke(const char *);

__attribute__((__deprecated__)) int rcmd(char **, int, const char *, const char *, const char *, int *);
__attribute__((__deprecated__)) int rcmd_af(char **, int, const char *, const char *, const char *, int *,
  int);
__attribute__((__deprecated__)) int rresvport(int *);
__attribute__((__deprecated__)) int rresvport_af(int *, int);
__attribute__((__deprecated__)) int iruserok(unsigned long, int, const char *, const char *);
__attribute__((__deprecated__)) int iruserok_sa(const void *, int, int, const char *, const char *);
__attribute__((__deprecated__)) int ruserok(const char *, int, const char *, const char *);

int setdomainname(const char *, int);
int setgroups(int, const gid_t *);
void sethostid(long);
int sethostname(const char *, int);

void setkey(const char *) __asm("_" "setkey" );



int setlogin(const char *);
void *setmode(const char *) __asm("_" "setmode" );
int setrgid(gid_t);
int setruid(uid_t);
int setsgroups_np(int, const uuid_t);
void setusershell(void);
int setwgroups_np(int, const uuid_t);
int strtofflags(char **, unsigned long *, unsigned long *);
int swapon(const char *);
int ttyslot(void);
int undelete(const char *);
int unwhiteout(const char *);
void *valloc(size_t);






int syscall(int, ...);

extern char *suboptarg;
int getsubopt(char **, char * const *, char **);



int fgetattrlist(int,void*,void*,size_t,unsigned int) ;
int fsetattrlist(int,void*,void*,size_t,unsigned int) ;
int getattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "getattrlist" );
int setattrlist(const char*,void*,void*,size_t,unsigned int) __asm("_" "setattrlist" );
int exchangedata(const char*,const char*,unsigned int) ;
int getdirentriesattr(int,void*,void*,size_t,unsigned int*,unsigned int*,unsigned int*,unsigned int) ;
# 769 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unistd.h" 3 4
struct fssearchblock;
struct searchstate;

int searchfs(const char *, struct fssearchblock *, unsigned long *, unsigned int, unsigned int, struct searchstate *) ;
int fsctl(const char *,unsigned long,void*,unsigned int);
int ffsctl(int,unsigned long,void*,unsigned int) ;

#define SYNC_VOLUME_FULLSYNC 0x01
#define SYNC_VOLUME_WAIT 0x02

int fsync_volume_np(int, int) ;
int sync_volume_np(const char *, int) ;

extern int optreset;


# 103 "project/nnn/src/nnn.c" 2

#define __USE_XOPEN_EXTENDED 1

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ftw.h" 1 3 4
# 24 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ftw.h" 3 4
#define _FTW_H 







#define FTW_F 0
#define FTW_D 1
#define FTW_DNR 2
#define FTW_DP 3
#define FTW_NS 4
#define FTW_SL 5
#define FTW_SLN 6




#define FTW_PHYS 0x01
#define FTW_MOUNT 0x02
#define FTW_DEPTH 0x04
#define FTW_CHDIR 0x08

struct FTW {
 int base;
 int level;
};


int ftw(const char *, int (*)(const char *, const struct stat *, int), int)
 __asm("_" "ftw" "$INODE64" );
int nftw(const char *, int (*)(const char *, const struct stat *, int,
     struct FTW *), int, int) __asm("_" "nftw" "$INODE64" );

# 107 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 1 3 4
# 68 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 3 4
#define _WCHAR_H_ 







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_mbstate_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_mbstate_t.h" 3 4
#define _MBSTATE_T 

typedef __darwin_mbstate_t mbstate_t;
# 77 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 2 3 4


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 80 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 2 3 4
# 92 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_wctype.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_wctype.h" 3 4
#define __WCTYPE_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/__wctype.h" 1 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/__wctype.h" 3 4
#define ___WCTYPE_H_ 




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_wint_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_wint_t.h" 3 4
#define _WINT_T 

typedef __darwin_wint_t wint_t;
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/__wctype.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_wctype_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_wctype_t.h" 3 4
#define _WCTYPE_T 

typedef __darwin_wctype_t wctype_t;
# 63 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/__wctype.h" 2 3 4


#define WEOF __DARWIN_WEOF



#define __DARWIN_WCTYPE_TOP_inline __header_inline


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ctype.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ctype.h" 3 4
#define _CTYPE_H_ 

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctype.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctype.h" 3 4
#define __CTYPE_H_ 


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/runetype.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/runetype.h" 3 4
#define _RUNETYPE_H_ 
# 49 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/runetype.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_wchar_t.h" 1 3 4
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/runetype.h" 2 3 4




#define _CACHED_RUNES (1 <<8 )
#define _CRMASK (~(_CACHED_RUNES - 1))




typedef struct {
 __darwin_rune_t __min;
 __darwin_rune_t __max;
 __darwin_rune_t __map;
 __uint32_t *__types;
} _RuneEntry;

typedef struct {
 int __nranges;
 _RuneEntry *__ranges;
} _RuneRange;

typedef struct {
 char __name[14];
 __uint32_t __mask;
} _RuneCharClass;

typedef struct {
 char __magic[8];
 char __encoding[32];

 __darwin_rune_t (*__sgetrune)(const char *, __darwin_size_t, char const **);
 int (*__sputrune)(__darwin_rune_t, char *, __darwin_size_t, char **);
 __darwin_rune_t __invalid_rune;

 __uint32_t __runetype[(1 <<8 )];
 __darwin_rune_t __maplower[(1 <<8 )];
 __darwin_rune_t __mapupper[(1 <<8 )];






 _RuneRange __runetype_ext;
 _RuneRange __maplower_ext;
 _RuneRange __mapupper_ext;

 void *__variable;
 int __variable_len;




 int __ncharclasses;
 _RuneCharClass *__charclasses;
} _RuneLocale;

#define _RUNE_MAGIC_A "RuneMagA"


extern _RuneLocale _DefaultRuneLocale;
extern _RuneLocale *_CurrentRuneLocale;

# 71 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctype.h" 2 3 4

#define _CTYPE_A 0x00000100L
#define _CTYPE_C 0x00000200L
#define _CTYPE_D 0x00000400L
#define _CTYPE_G 0x00000800L
#define _CTYPE_L 0x00001000L
#define _CTYPE_P 0x00002000L
#define _CTYPE_S 0x00004000L
#define _CTYPE_U 0x00008000L
#define _CTYPE_X 0x00010000L
#define _CTYPE_B 0x00020000L
#define _CTYPE_R 0x00040000L
#define _CTYPE_I 0x00080000L
#define _CTYPE_T 0x00100000L
#define _CTYPE_Q 0x00200000L
#define _CTYPE_SW0 0x20000000L
#define _CTYPE_SW1 0x40000000L
#define _CTYPE_SW2 0x80000000L
#define _CTYPE_SW3 0xc0000000L
#define _CTYPE_SWM 0xe0000000L
#define _CTYPE_SWS 30
# 117 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctype.h" 3 4
#define __DARWIN_CTYPE_inline __header_inline

#define __DARWIN_CTYPE_TOP_inline __header_inline
# 128 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctype.h" 3 4

unsigned long ___runetype(__darwin_ct_rune_t);
__darwin_ct_rune_t ___tolower(__darwin_ct_rune_t);
__darwin_ct_rune_t ___toupper(__darwin_ct_rune_t);


extern __inline __attribute__((__gnu_inline__)) int
isascii(int _c)
{
 return ((_c & ~0x7F) == 0);
}
# 147 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctype.h" 3 4

int __maskrune(__darwin_ct_rune_t, unsigned long);



extern __inline __attribute__((__gnu_inline__)) int
__istype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (isascii(_c) ? !!(_DefaultRuneLocale.__runetype[_c] & _f)
  : !!__maskrune(_c, _f));

}

extern __inline __attribute__((__gnu_inline__)) __darwin_ct_rune_t
__isctype(__darwin_ct_rune_t _c, unsigned long _f)
{



 return (_c < 0 || _c >= (1 <<8 )) ? 0 :
  !!(_DefaultRuneLocale.__runetype[_c] & _f);

}
# 187 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_ctype.h" 3 4

__darwin_ct_rune_t __toupper(__darwin_ct_rune_t);
__darwin_ct_rune_t __tolower(__darwin_ct_rune_t);



extern __inline __attribute__((__gnu_inline__)) int
__wcwidth(__darwin_ct_rune_t _c)
{
 unsigned int _x;

 if (_c == 0)
  return (0);
 _x = (unsigned int)__maskrune(_c, 0xe0000000L|0x00040000L);
 if ((_x & 0xe0000000L) != 0)
  return ((_x & 0xe0000000L) >> 30);
 return ((_x & 0x00040000L) != 0 ? 1 : -1);
}



#define _tolower(c) __tolower(c)
#define _toupper(c) __toupper(c)

extern __inline __attribute__((__gnu_inline__)) int
isalnum(int _c)
{
 return (__istype(_c, 0x00000100L|0x00000400L));
}

extern __inline __attribute__((__gnu_inline__)) int
isalpha(int _c)
{
 return (__istype(_c, 0x00000100L));
}

extern __inline __attribute__((__gnu_inline__)) int
isblank(int _c)
{
 return (__istype(_c, 0x00020000L));
}

extern __inline __attribute__((__gnu_inline__)) int
iscntrl(int _c)
{
 return (__istype(_c, 0x00000200L));
}


extern __inline __attribute__((__gnu_inline__)) int
isdigit(int _c)
{
 return (__isctype(_c, 0x00000400L));
}

extern __inline __attribute__((__gnu_inline__)) int
isgraph(int _c)
{
 return (__istype(_c, 0x00000800L));
}

extern __inline __attribute__((__gnu_inline__)) int
islower(int _c)
{
 return (__istype(_c, 0x00001000L));
}

extern __inline __attribute__((__gnu_inline__)) int
isprint(int _c)
{
 return (__istype(_c, 0x00040000L));
}

extern __inline __attribute__((__gnu_inline__)) int
ispunct(int _c)
{
 return (__istype(_c, 0x00002000L));
}

extern __inline __attribute__((__gnu_inline__)) int
isspace(int _c)
{
 return (__istype(_c, 0x00004000L));
}

extern __inline __attribute__((__gnu_inline__)) int
isupper(int _c)
{
 return (__istype(_c, 0x00008000L));
}


extern __inline __attribute__((__gnu_inline__)) int
isxdigit(int _c)
{
 return (__isctype(_c, 0x00010000L));
}

extern __inline __attribute__((__gnu_inline__)) int
toascii(int _c)
{
 return (_c & 0x7F);
}

extern __inline __attribute__((__gnu_inline__)) int
tolower(int _c)
{
        return (__tolower(_c));
}

extern __inline __attribute__((__gnu_inline__)) int
toupper(int _c)
{
        return (__toupper(_c));
}


extern __inline __attribute__((__gnu_inline__)) int
digittoint(int _c)
{
 return (__maskrune(_c, 0x0F));
}

extern __inline __attribute__((__gnu_inline__)) int
ishexnumber(int _c)
{
 return (__istype(_c, 0x00010000L));
}

extern __inline __attribute__((__gnu_inline__)) int
isideogram(int _c)
{
 return (__istype(_c, 0x00080000L));
}

extern __inline __attribute__((__gnu_inline__)) int
isnumber(int _c)
{
 return (__istype(_c, 0x00000400L));
}

extern __inline __attribute__((__gnu_inline__)) int
isphonogram(int _c)
{
 return (__istype(_c, 0x00200000L));
}

extern __inline __attribute__((__gnu_inline__)) int
isrune(int _c)
{
 return (__istype(_c, 0xFFFFFFF0L));
}

extern __inline __attribute__((__gnu_inline__)) int
isspecial(int _c)
{
 return (__istype(_c, 0x00100000L));
}
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ctype.h" 2 3 4
# 73 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/__wctype.h" 2 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_wctype.h" 2 3 4







extern __inline __attribute__((__gnu_inline__)) int
iswalnum(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L|0x00000400L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswalpha(wint_t _wc)
{
 return (__istype(_wc, 0x00000100L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswcntrl(wint_t _wc)
{
 return (__istype(_wc, 0x00000200L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswctype(wint_t _wc, wctype_t _charclass)
{
 return (__istype(_wc, _charclass));
}

extern __inline __attribute__((__gnu_inline__)) int
iswdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00000400L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswgraph(wint_t _wc)
{
 return (__istype(_wc, 0x00000800L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswlower(wint_t _wc)
{
 return (__istype(_wc, 0x00001000L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswprint(wint_t _wc)
{
 return (__istype(_wc, 0x00040000L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswpunct(wint_t _wc)
{
 return (__istype(_wc, 0x00002000L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswspace(wint_t _wc)
{
 return (__istype(_wc, 0x00004000L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswupper(wint_t _wc)
{
 return (__istype(_wc, 0x00008000L));
}

extern __inline __attribute__((__gnu_inline__)) int
iswxdigit(wint_t _wc)
{
 return (__isctype(_wc, 0x00010000L));
}

extern __inline __attribute__((__gnu_inline__)) wint_t
towlower(wint_t _wc)
{
        return (__tolower(_wc));
}

extern __inline __attribute__((__gnu_inline__)) wint_t
towupper(wint_t _wc)
{
        return (__toupper(_wc));
}
# 155 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_wctype.h" 3 4

wctype_t
 wctype(const char *);

# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 2 3 4




wint_t btowc(int);
wint_t fgetwc(FILE *);
wchar_t *fgetws(wchar_t * restrict, int, FILE * restrict);
wint_t fputwc(wchar_t, FILE *);
int fputws(const wchar_t * restrict, FILE * restrict);
int fwide(FILE *, int);
int fwprintf(FILE * restrict, const wchar_t * restrict, ...);
int fwscanf(FILE * restrict, const wchar_t * restrict, ...);
wint_t getwc(FILE *);
wint_t getwchar(void);
size_t mbrlen(const char * restrict, size_t, mbstate_t * restrict);
size_t mbrtowc(wchar_t * restrict, const char * restrict, size_t,
     mbstate_t * restrict);
int mbsinit(const mbstate_t *);
size_t mbsrtowcs(wchar_t * restrict, const char ** restrict, size_t,
     mbstate_t * restrict);
wint_t putwc(wchar_t, FILE *);
wint_t putwchar(wchar_t);
int swprintf(wchar_t * restrict, size_t, const wchar_t * restrict, ...);
int swscanf(const wchar_t * restrict, const wchar_t * restrict, ...);
wint_t ungetwc(wint_t, FILE *);
int vfwprintf(FILE * restrict, const wchar_t * restrict,
     __darwin_va_list);
int vswprintf(wchar_t * restrict, size_t, const wchar_t * restrict,
     __darwin_va_list);
int vwprintf(const wchar_t * restrict, __darwin_va_list);
size_t wcrtomb(char * restrict, wchar_t, mbstate_t * restrict);
wchar_t *wcscat(wchar_t * restrict, const wchar_t * restrict);
wchar_t *wcschr(const wchar_t *, wchar_t);
int wcscmp(const wchar_t *, const wchar_t *);
int wcscoll(const wchar_t *, const wchar_t *);
wchar_t *wcscpy(wchar_t * restrict, const wchar_t * restrict);
size_t wcscspn(const wchar_t *, const wchar_t *);
size_t wcsftime(wchar_t * restrict, size_t, const wchar_t * restrict,
     const struct tm * restrict) __asm("_" "wcsftime" );
size_t wcslen(const wchar_t *);
wchar_t *wcsncat(wchar_t * restrict, const wchar_t * restrict, size_t);
int wcsncmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wcsncpy(wchar_t * restrict , const wchar_t * restrict, size_t);
wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
wchar_t *wcsrchr(const wchar_t *, wchar_t);
size_t wcsrtombs(char * restrict, const wchar_t ** restrict, size_t,
     mbstate_t * restrict);
size_t wcsspn(const wchar_t *, const wchar_t *);
wchar_t *wcsstr(const wchar_t * restrict, const wchar_t * restrict);
size_t wcsxfrm(wchar_t * restrict, const wchar_t * restrict, size_t);
int wctob(wint_t);
double wcstod(const wchar_t * restrict, wchar_t ** restrict);
wchar_t *wcstok(wchar_t * restrict, const wchar_t * restrict,
     wchar_t ** restrict);
long wcstol(const wchar_t * restrict, wchar_t ** restrict, int);
unsigned long
  wcstoul(const wchar_t * restrict, wchar_t ** restrict, int);
wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
int wmemcmp(const wchar_t *, const wchar_t *, size_t);
wchar_t *wmemcpy(wchar_t * restrict, const wchar_t * restrict, size_t);
wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
wchar_t *wmemset(wchar_t *, wchar_t, size_t);
int wprintf(const wchar_t * restrict, ...);
int wscanf(const wchar_t * restrict, ...);
int wcswidth(const wchar_t *, size_t);
int wcwidth(wchar_t);

# 169 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 3 4

int vfwscanf(FILE * restrict, const wchar_t * restrict,
     __darwin_va_list);
int vswscanf(const wchar_t * restrict, const wchar_t * restrict,
     __darwin_va_list);
int vwscanf(const wchar_t * restrict, __darwin_va_list);
float wcstof(const wchar_t * restrict, wchar_t ** restrict);
long double
 wcstold(const wchar_t * restrict, wchar_t ** restrict);

long long
 wcstoll(const wchar_t * restrict, wchar_t ** restrict, int);
unsigned long long
 wcstoull(const wchar_t * restrict, wchar_t ** restrict, int);


# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/wchar.h" 3 4

size_t mbsnrtowcs(wchar_t * restrict, const char ** restrict, size_t,
            size_t, mbstate_t * restrict);
wchar_t *wcpcpy(wchar_t * restrict, const wchar_t * restrict) ;
wchar_t *wcpncpy(wchar_t * restrict, const wchar_t * restrict, size_t) ;
wchar_t *wcsdup(const wchar_t *) ;
int wcscasecmp(const wchar_t *, const wchar_t *) ;
int wcsncasecmp(const wchar_t *, const wchar_t *, size_t n) ;
size_t wcsnlen(const wchar_t *, size_t) ;
size_t wcsnrtombs(char * restrict, const wchar_t ** restrict, size_t,
            size_t, mbstate_t * restrict);
FILE *open_wmemstream(wchar_t ** __bufp, size_t * __sizep) ;









wchar_t *fgetwln(FILE * restrict, size_t *) ;
size_t wcslcat(wchar_t *, const wchar_t *, size_t);
size_t wcslcpy(wchar_t *, const wchar_t *, size_t);

# 108 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pwd.h" 1 3 4
# 44 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pwd.h" 3 4
#define _PWD_H_ 







#define _PATH_PWD "/etc"
#define _PATH_PASSWD "/etc/passwd"
#define _PASSWD "passwd"
#define _PATH_MASTERPASSWD "/etc/master.passwd"
#define _PATH_MASTERPASSWD_LOCK "/etc/ptmp"
#define _MASTERPASSWD "master.passwd"

#define _PATH_MP_DB "/etc/pwd.db"
#define _MP_DB "pwd.db"
#define _PATH_SMP_DB "/etc/spwd.db"
#define _SMP_DB "spwd.db"

#define _PATH_PWD_MKDB "/usr/sbin/pwd_mkdb"

#define _PW_KEYBYNAME '1'
#define _PW_KEYBYNUM '2'
#define _PW_KEYBYUID '3'

#define _PASSWORD_EFMT1 '_'

#define _PASSWORD_LEN 128

#define _PASSWORD_NOUID 0x01
#define _PASSWORD_NOGID 0x02
#define _PASSWORD_NOCHG 0x04
#define _PASSWORD_NOEXP 0x08

#define _PASSWORD_WARNDAYS 14
#define _PASSWORD_CHGNOW -1



struct passwd {
 char *pw_name;
 char *pw_passwd;
 uid_t pw_uid;
 gid_t pw_gid;
 __darwin_time_t pw_change;
 char *pw_class;
 char *pw_gecos;
 char *pw_dir;
 char *pw_shell;
 __darwin_time_t pw_expire;
};




struct passwd *getpwuid(uid_t);
struct passwd *getpwnam(const char *);
int getpwuid_r(uid_t, struct passwd *, char *, size_t, struct passwd **);
int getpwnam_r(const char *, struct passwd *, char *, size_t, struct passwd **);
struct passwd *getpwent(void);
void setpwent(void);
void endpwent(void);



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/uuid/uuid.h" 1 3 4
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/uuid/uuid.h" 3 4
#define _UUID_UUID_H 





#define _UUID_STRING_T 
typedef __darwin_uuid_string_t uuid_string_t;


#define UUID_DEFINE(name,u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15) static const uuid_t name __attribute__ ((unused)) = {u0,u1,u2,u3,u4,u5,u6,u7,u8,u9,u10,u11,u12,u13,u14,u15}


static const uuid_t UUID_NULL __attribute__ ((unused)) = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};





void uuid_clear(uuid_t uu);

int uuid_compare(const uuid_t uu1, const uuid_t uu2);

void uuid_copy(uuid_t dst, const uuid_t src);

void uuid_generate(uuid_t out);
void uuid_generate_random(uuid_t out);
void uuid_generate_time(uuid_t out);

void uuid_generate_early_random(uuid_t out);

int uuid_is_null(const uuid_t uu);

int uuid_parse(const uuid_string_t in, uuid_t uu);

void uuid_unparse(const uuid_t uu, uuid_string_t out);
void uuid_unparse_lower(const uuid_t uu, uuid_string_t out);
void uuid_unparse_upper(const uuid_t uu, uuid_string_t out);
# 111 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/pwd.h" 2 3 4

int setpassent(int);
char *user_from_uid(uid_t, int);
struct passwd *getpwuuid(uuid_t);
int getpwuuid_r(uuid_t, struct passwd *, char *, size_t, struct passwd **);

# 109 "project/nnn/src/nnn.c" 2
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/grp.h" 1 3 4
# 43 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/grp.h" 3 4
#define _GRP_H_ 






#define _PATH_GROUP "/etc/group"


struct group {
 char *gr_name;
 char *gr_passwd;
 gid_t gr_gid;
 char **gr_mem;
};





struct group *getgrgid(gid_t);
struct group *getgrnam(const char *);

int getgrgid_r(gid_t, struct group *, char *, size_t, struct group **);
int getgrnam_r(const char *, struct group *, char *, size_t, struct group **);

struct group *getgrent(void);
void setgrent(void);
void endgrent(void);





char *group_from_gid(gid_t, int);
struct group *getgruuid(uuid_t);
int getgruuid_r(uuid_t, struct group *, char *, size_t, struct group **);






void setgrfile(const char *);

int setgroupent(int);

# 110 "project/nnn/src/nnn.c" 2
# 124 "project/nnn/src/nnn.c"
# 1 "project/nnn/src/nnn.h" 1
# 31 "project/nnn/src/nnn.h"
       

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 1 3 4
# 38 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define __NCURSES_H 

#define CURSES 1
#define CURSES_H 1
# 50 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define NCURSES_VERSION_MAJOR 5
#define NCURSES_VERSION_MINOR 7
#define NCURSES_VERSION_PATCH 20081102


#undef NCURSES_VERSION
#define NCURSES_VERSION "5.7"




#define NCURSES_MOUSE_VERSION 1




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ncurses_dll.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ncurses_dll.h" 3 4
#define NCURSES_DLL_H_incl 1





#undef NCURSES_DLL
#define NCURSES_STATIC 
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/ncurses_dll.h" 3 4
#define NCURSES_IMPEXP 


#define NCURSES_API 


#define NCURSES_EXPORT(type) NCURSES_IMPEXP type NCURSES_API


#define NCURSES_EXPORT_VAR(type) NCURSES_IMPEXP type






#define NCURSES_PUBLIC_VAR(name) _nc_ ##name
#define NCURSES_WRAPPED_VAR(type,name) extern type NCURSES_PUBLIC_VAR(name)(void)
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 2 3 4





#define NCURSES_ENABLE_STDBOOL_H 1
# 86 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define NCURSES_ATTR_T int






#undef NCURSES_CONST
#define NCURSES_CONST 

#undef NCURSES_INLINE
#define NCURSES_INLINE inline




#undef NCURSES_COLOR_T
#define NCURSES_COLOR_T short





#define NCURSES_OPAQUE 1





#undef NCURSES_SIZE_T
#define NCURSES_SIZE_T short




#undef NCURSES_TPARM_VARARGS
#define NCURSES_TPARM_VARARGS 1






#undef NCURSES_CH_T
#define NCURSES_CH_T cchar_t





typedef unsigned int chtype;
typedef unsigned long mmask_t;



# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unctrl.h" 1 3 4
# 45 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unctrl.h" 3 4
#define NCURSES_UNCTRL_H_incl 1

#undef NCURSES_VERSION
#define NCURSES_VERSION "5.7"





# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 1 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/unctrl.h" 2 3 4

#undef unctrl
 char * unctrl (chtype);
# 142 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 2 3 4


# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 1 3 4
# 39 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
#define _STDDEF_H 
#define _STDDEF_H_ 

#define _ANSI_STDDEF_H 
# 131 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
#define _PTRDIFF_T 
#define _T_PTRDIFF_ 
#define _T_PTRDIFF 
#define __PTRDIFF_T 
#define _PTRDIFF_T_ 
#define _BSD_PTRDIFF_T_ 
#define ___int_ptrdiff_t_h 
#define _GCC_PTRDIFF_T 
#define _PTRDIFF_T_DECLARED 



typedef long int ptrdiff_t;
# 155 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
#undef __need_ptrdiff_t
# 231 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
#undef __need_size_t
# 340 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
#undef __need_wchar_t
# 390 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
#undef NULL




#define NULL ((void *)0)





#undef __need_NULL




#define offsetof(TYPE,MEMBER) __builtin_offsetof (TYPE, MEMBER)




#define _GCC_MAX_ALIGN_T 



typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
} max_align_t;
# 145 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 2 3 4
# 159 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#undef TRUE
#define TRUE 1

#undef FALSE
#define FALSE 0

typedef unsigned char NCURSES_BOOL;
# 175 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdbool.h" 1 3 4
# 29 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdbool.h" 3 4
#define _STDBOOL_H 



#define bool _Bool




#define true 1
#define false 0
# 50 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdbool.h" 3 4
#define __bool_true_false_are_defined 1
# 176 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 2 3 4

#define NCURSES_BOOL bool
# 190 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define NCURSES_CAST(type,value) (type)(value)






#define WA_ATTRIBUTES A_ATTRIBUTES
#define WA_NORMAL A_NORMAL
#define WA_STANDOUT A_STANDOUT
#define WA_UNDERLINE A_UNDERLINE
#define WA_REVERSE A_REVERSE
#define WA_BLINK A_BLINK
#define WA_DIM A_DIM
#define WA_BOLD A_BOLD
#define WA_ALTCHARSET A_ALTCHARSET
#define WA_INVIS A_INVIS
#define WA_PROTECT A_PROTECT
#define WA_HORIZONTAL A_HORIZONTAL
#define WA_LEFT A_LEFT
#define WA_LOW A_LOW
#define WA_RIGHT A_RIGHT
#define WA_TOP A_TOP
#define WA_VERTICAL A_VERTICAL


#define COLOR_BLACK 0
#define COLOR_RED 1
#define COLOR_GREEN 2
#define COLOR_YELLOW 3
#define COLOR_BLUE 4
#define COLOR_MAGENTA 5
#define COLOR_CYAN 6
#define COLOR_WHITE 7







extern chtype acs_map[];


#define NCURSES_ACS(c) (acs_map[NCURSES_CAST(unsigned char,c)])


#define ACS_ULCORNER NCURSES_ACS('l')
#define ACS_LLCORNER NCURSES_ACS('m')
#define ACS_URCORNER NCURSES_ACS('k')
#define ACS_LRCORNER NCURSES_ACS('j')
#define ACS_LTEE NCURSES_ACS('t')
#define ACS_RTEE NCURSES_ACS('u')
#define ACS_BTEE NCURSES_ACS('v')
#define ACS_TTEE NCURSES_ACS('w')
#define ACS_HLINE NCURSES_ACS('q')
#define ACS_VLINE NCURSES_ACS('x')
#define ACS_PLUS NCURSES_ACS('n')
#define ACS_S1 NCURSES_ACS('o')
#define ACS_S9 NCURSES_ACS('s')
#define ACS_DIAMOND NCURSES_ACS('`')
#define ACS_CKBOARD NCURSES_ACS('a')
#define ACS_DEGREE NCURSES_ACS('f')
#define ACS_PLMINUS NCURSES_ACS('g')
#define ACS_BULLET NCURSES_ACS('~')

#define ACS_LARROW NCURSES_ACS(',')
#define ACS_RARROW NCURSES_ACS('+')
#define ACS_DARROW NCURSES_ACS('.')
#define ACS_UARROW NCURSES_ACS('-')
#define ACS_BOARD NCURSES_ACS('h')
#define ACS_LANTERN NCURSES_ACS('i')
#define ACS_BLOCK NCURSES_ACS('0')





#define ACS_S3 NCURSES_ACS('p')
#define ACS_S7 NCURSES_ACS('r')
#define ACS_LEQUAL NCURSES_ACS('y')
#define ACS_GEQUAL NCURSES_ACS('z')
#define ACS_PI NCURSES_ACS('{')
#define ACS_NEQUAL NCURSES_ACS('|')
#define ACS_STERLING NCURSES_ACS('}')







#define ACS_BSSB ACS_ULCORNER
#define ACS_SSBB ACS_LLCORNER
#define ACS_BBSS ACS_URCORNER
#define ACS_SBBS ACS_LRCORNER
#define ACS_SBSS ACS_RTEE
#define ACS_SSSB ACS_LTEE
#define ACS_SSBS ACS_BTEE
#define ACS_BSSS ACS_TTEE
#define ACS_BSBS ACS_HLINE
#define ACS_SBSB ACS_VLINE
#define ACS_SSSS ACS_PLUS

#undef ERR
#define ERR (-1)

#undef OK
#define OK (0)


#define _SUBWIN 0x01
#define _ENDLINE 0x02
#define _FULLWIN 0x04
#define _SCROLLWIN 0x08
#define _ISPAD 0x10
#define _HASMOVED 0x20
#define _WRAPPED 0x40





#define _NOCHANGE -1





#define _NEWINDEX -1

typedef struct screen SCREEN;
typedef struct _win_st WINDOW;

typedef chtype attr_t;
# 347 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define CCHARW_MAX 5
typedef struct
{
    attr_t attr;
    wchar_t chars[5];





}
cchar_t;
# 493 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define GCC_PRINTFLIKE(fmt,var) 







#define GCC_SCANFLIKE(fmt,var) 




#define GCC_NORETURN 



#define GCC_UNUSED 
# 520 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
extern int addch (const chtype);
extern int addchnstr (const chtype *, int);
extern int addchstr (const chtype *);
extern int addnstr (const char *, int);
extern int addstr (const char *);
extern int attroff (int);
extern int attron (int);
extern int attrset (int);
extern int attr_get (attr_t *, short *, void *);
extern int attr_off (attr_t, void *);
extern int attr_on (attr_t, void *);
extern int attr_set (attr_t, short, void *);
extern int baudrate (void);
extern int beep (void);
extern int bkgd (chtype);
extern void bkgdset (chtype);
extern int border (chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);
extern int box (WINDOW *, chtype, chtype);
extern _Bool can_change_color (void);
extern int cbreak (void);
extern int chgat (int, attr_t, short, const void *);
extern int clear (void);
extern int clearok (WINDOW *,_Bool);
extern int clrtobot (void);
extern int clrtoeol (void);
extern int color_content (short,short*,short*,short*);
extern int color_set (short,void*);
extern int COLOR_PAIR (int);
extern int copywin (const WINDOW*,WINDOW*,int,int,int,int,int,int,int);
extern int curs_set (int);
extern int def_prog_mode (void);
extern int def_shell_mode (void);
extern int delay_output (int);
extern int delch (void);
extern void delscreen (SCREEN *);
extern int delwin (WINDOW *);
extern int deleteln (void);
extern WINDOW * derwin (WINDOW *,int,int,int,int);
extern int doupdate (void);
extern WINDOW * dupwin (WINDOW *);
extern int echo (void);
extern int echochar (const chtype);
extern int erase (void);
extern int endwin (void);
extern char erasechar (void);
extern void filter (void);
extern int flash (void);
extern int flushinp (void);
extern chtype getbkgd (WINDOW *);
extern int getch (void);
extern int getnstr (char *, int);
extern int getstr (char *);
extern WINDOW * getwin (FILE *);
extern int halfdelay (int);
extern _Bool has_colors (void);
extern _Bool has_ic (void);
extern _Bool has_il (void);
extern int hline (chtype, int);
extern void idcok (WINDOW *, _Bool);
extern int idlok (WINDOW *, _Bool);
extern void immedok (WINDOW *, _Bool);
extern chtype inch (void);
extern int inchnstr (chtype *, int);
extern int inchstr (chtype *);
extern WINDOW * initscr (void);
extern int init_color (short,short,short,short);
extern int init_pair (short,short,short);
extern int innstr (char *, int);
extern int insch (chtype);
extern int insdelln (int);
extern int insertln (void);
extern int insnstr (const char *, int);
extern int insstr (const char *);
extern int instr (char *);
extern int intrflush (WINDOW *,_Bool);
extern _Bool isendwin (void);
extern _Bool is_linetouched (WINDOW *,int);
extern _Bool is_wintouched (WINDOW *);
extern char * keyname (int);
extern int keypad (WINDOW *,_Bool);
extern char killchar (void);
extern int leaveok (WINDOW *,_Bool);
extern char * longname (void);
extern int meta (WINDOW *,_Bool);
extern int move (int, int);
extern int mvaddch (int, int, const chtype);
extern int mvaddchnstr (int, int, const chtype *, int);
extern int mvaddchstr (int, int, const chtype *);
extern int mvaddnstr (int, int, const char *, int);
extern int mvaddstr (int, int, const char *);
extern int mvchgat (int, int, int, attr_t, short, const void *);
extern int mvcur (int,int,int,int);
extern int mvdelch (int, int);
extern int mvderwin (WINDOW *, int, int);
extern int mvgetch (int, int);
extern int mvgetnstr (int, int, char *, int);
extern int mvgetstr (int, int, char *);
extern int mvhline (int, int, chtype, int);
extern chtype mvinch (int, int);
extern int mvinchnstr (int, int, chtype *, int);
extern int mvinchstr (int, int, chtype *);
extern int mvinnstr (int, int, char *, int);
extern int mvinsch (int, int, chtype);
extern int mvinsnstr (int, int, const char *, int);
extern int mvinsstr (int, int, const char *);
extern int mvinstr (int, int, char *);
extern int mvprintw (int,int, const char *,...)
  ;
extern int mvscanw (int,int, char *,...)
  ;
extern int mvvline (int, int, chtype, int);
extern int mvwaddch (WINDOW *, int, int, const chtype);
extern int mvwaddchnstr (WINDOW *, int, int, const chtype *, int);
extern int mvwaddchstr (WINDOW *, int, int, const chtype *);
extern int mvwaddnstr (WINDOW *, int, int, const char *, int);
extern int mvwaddstr (WINDOW *, int, int, const char *);
extern int mvwchgat (WINDOW *, int, int, int, attr_t, short, const void *);
extern int mvwdelch (WINDOW *, int, int);
extern int mvwgetch (WINDOW *, int, int);
extern int mvwgetnstr (WINDOW *, int, int, char *, int);
extern int mvwgetstr (WINDOW *, int, int, char *);
extern int mvwhline (WINDOW *, int, int, chtype, int);
extern int mvwin (WINDOW *,int,int);
extern chtype mvwinch (WINDOW *, int, int);
extern int mvwinchnstr (WINDOW *, int, int, chtype *, int);
extern int mvwinchstr (WINDOW *, int, int, chtype *);
extern int mvwinnstr (WINDOW *, int, int, char *, int);
extern int mvwinsch (WINDOW *, int, int, chtype);
extern int mvwinsnstr (WINDOW *, int, int, const char *, int);
extern int mvwinsstr (WINDOW *, int, int, const char *);
extern int mvwinstr (WINDOW *, int, int, char *);
extern int mvwprintw (WINDOW*,int,int, const char *,...)
  ;
extern int mvwscanw (WINDOW *,int,int, char *,...)
  ;
extern int mvwvline (WINDOW *,int, int, chtype, int);
extern int napms (int);
extern WINDOW * newpad (int,int);
extern SCREEN * newterm ( char *,FILE *,FILE *);
extern WINDOW * newwin (int,int,int,int);
extern int nl (void);
extern int nocbreak (void);
extern int nodelay (WINDOW *,_Bool);
extern int noecho (void);
extern int nonl (void);
extern void noqiflush (void);
extern int noraw (void);
extern int notimeout (WINDOW *,_Bool);
extern int overlay (const WINDOW*,WINDOW *);
extern int overwrite (const WINDOW*,WINDOW *);
extern int pair_content (short,short*,short*);
extern int PAIR_NUMBER (int);
extern int pechochar (WINDOW *, const chtype);
extern int pnoutrefresh (WINDOW*,int,int,int,int,int,int);
extern int prefresh (WINDOW *,int,int,int,int,int,int);
extern int printw (const char *,...)
  ;
extern int putwin (WINDOW *, FILE *);
extern void qiflush (void);
extern int raw (void);
extern int redrawwin (WINDOW *);
extern int refresh (void);
extern int resetty (void);
extern int reset_prog_mode (void);
extern int reset_shell_mode (void);
extern int ripoffline (int, int (*)(WINDOW *, int));
extern int savetty (void);
extern int scanw ( char *,...)
  ;
extern int scr_dump (const char *);
extern int scr_init (const char *);
extern int scrl (int);
extern int scroll (WINDOW *);
extern int scrollok (WINDOW *,_Bool);
extern int scr_restore (const char *);
extern int scr_set (const char *);
extern int setscrreg (int,int);
extern SCREEN * set_term (SCREEN *);
extern int slk_attroff (const chtype);
extern int slk_attr_off (const attr_t, void *);
extern int slk_attron (const chtype);
extern int slk_attr_on (attr_t,void*);
extern int slk_attrset (const chtype);
extern attr_t slk_attr (void);
extern int slk_attr_set (const attr_t,short,void*);
extern int slk_clear (void);
extern int slk_color (short);
extern int slk_init (int);
extern char * slk_label (int);
extern int slk_noutrefresh (void);
extern int slk_refresh (void);
extern int slk_restore (void);
extern int slk_set (int,const char *,int);
extern int slk_touch (void);
extern int standout (void);
extern int standend (void);
extern int start_color (void);
extern WINDOW * subpad (WINDOW *, int, int, int, int);
extern WINDOW * subwin (WINDOW *, int, int, int, int);
extern int syncok (WINDOW *, _Bool);
extern chtype termattrs (void);
extern char * termname (void);
extern void timeout (int);
extern int touchline (WINDOW *, int, int);
extern int touchwin (WINDOW *);
extern int typeahead (int);
extern int ungetch (int);
extern int untouchwin (WINDOW *);
extern void use_env (_Bool);
extern int vidattr (chtype);
extern int vidputs (chtype, int (*)(int));
extern int vline (chtype, int);
extern int vwprintw (WINDOW *, const char *,va_list);
extern int vw_printw (WINDOW *, const char *,va_list);
extern int vwscanw (WINDOW *, char *,va_list);
extern int vw_scanw (WINDOW *, char *,va_list);
extern int waddch (WINDOW *, const chtype);
extern int waddchnstr (WINDOW *,const chtype *,int);
extern int waddchstr (WINDOW *,const chtype *);
extern int waddnstr (WINDOW *,const char *,int);
extern int waddstr (WINDOW *,const char *);
extern int wattron (WINDOW *, int);
extern int wattroff (WINDOW *, int);
extern int wattrset (WINDOW *, int);
extern int wattr_get (WINDOW *, attr_t *, short *, void *);
extern int wattr_on (WINDOW *, attr_t, void *);
extern int wattr_off (WINDOW *, attr_t, void *);
extern int wattr_set (WINDOW *, attr_t, short, void *);
extern int wbkgd (WINDOW *, chtype);
extern void wbkgdset (WINDOW *,chtype);
extern int wborder (WINDOW *,chtype,chtype,chtype,chtype,chtype,chtype,chtype,chtype);
extern int wchgat (WINDOW *, int, attr_t, short, const void *);
extern int wclear (WINDOW *);
extern int wclrtobot (WINDOW *);
extern int wclrtoeol (WINDOW *);
extern int wcolor_set (WINDOW*,short,void*);
extern void wcursyncup (WINDOW *);
extern int wdelch (WINDOW *);
extern int wdeleteln (WINDOW *);
extern int wechochar (WINDOW *, const chtype);
extern int werase (WINDOW *);
extern int wgetch (WINDOW *);
extern int wgetnstr (WINDOW *,char *,int);
extern int wgetstr (WINDOW *, char *);
extern int whline (WINDOW *, chtype, int);
extern chtype winch (WINDOW *);
extern int winchnstr (WINDOW *, chtype *, int);
extern int winchstr (WINDOW *, chtype *);
extern int winnstr (WINDOW *, char *, int);
extern int winsch (WINDOW *, chtype);
extern int winsdelln (WINDOW *,int);
extern int winsertln (WINDOW *);
extern int winsnstr (WINDOW *, const char *,int);
extern int winsstr (WINDOW *, const char *);
extern int winstr (WINDOW *, char *);
extern int wmove (WINDOW *,int,int);
extern int wnoutrefresh (WINDOW *);
extern int wprintw (WINDOW *, const char *,...)
  ;
extern int wredrawln (WINDOW *,int,int);
extern int wrefresh (WINDOW *);
extern int wscanw (WINDOW *, char *,...)
  ;
extern int wscrl (WINDOW *,int);
extern int wsetscrreg (WINDOW *,int,int);
extern int wstandout (WINDOW *);
extern int wstandend (WINDOW *);
extern void wsyncdown (WINDOW *);
extern void wsyncup (WINDOW *);
extern void wtimeout (WINDOW *,int);
extern int wtouchln (WINDOW *,int,int,int);
extern int wvline (WINDOW *,chtype,int);




extern int tigetflag ( char *);
extern int tigetnum ( char *);
extern char * tigetstr ( char *);
extern int putp (const char *);


extern char * tparm ( char *, ...);
# 811 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
extern int getattrs (const WINDOW *);
extern int getcurx (const WINDOW *);
extern int getcury (const WINDOW *);
extern int getbegx (const WINDOW *);
extern int getbegy (const WINDOW *);
extern int getmaxx (const WINDOW *);
extern int getmaxy (const WINDOW *);
extern int getparx (const WINDOW *);
extern int getpary (const WINDOW *);
# 832 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#undef NCURSES_EXT_FUNCS
#define NCURSES_EXT_FUNCS 20081102
typedef int (*NCURSES_WINDOW_CB)(WINDOW *, void *);
typedef int (*NCURSES_SCREEN_CB)(SCREEN *, void *);
extern _Bool is_term_resized (int, int);
extern char * keybound (int, int);
extern const char * curses_version (void);
extern int assume_default_colors (int, int);
extern int define_key (const char *, int);
extern int key_defined (const char *);
extern int keyok (int, _Bool);
extern int resize_term (int, int);
extern int resizeterm (int, int);
extern int set_escdelay (int);
extern int set_tabsize (int);
extern int use_default_colors (void);
extern int use_extended_names (_Bool);
extern int use_legacy_coding (int);
extern int use_screen (SCREEN *, NCURSES_SCREEN_CB, void *);
extern int use_window (WINDOW *, NCURSES_WINDOW_CB, void *);
extern int wresize (WINDOW *, int, int);
extern void nofilter(void);





extern WINDOW * wgetparent (const WINDOW *);
extern _Bool is_cleared (const WINDOW *);
extern _Bool is_idcok (const WINDOW *);
extern _Bool is_idlok (const WINDOW *);
extern _Bool is_immedok (const WINDOW *);
extern _Bool is_keypad (const WINDOW *);
extern _Bool is_leaveok (const WINDOW *);
extern _Bool is_nodelay (const WINDOW *);
extern _Bool is_notimeout (const WINDOW *);
extern _Bool is_scrollok (const WINDOW *);
extern _Bool is_syncok (const WINDOW *);
extern int wgetscrreg (const WINDOW *, int *, int *);







#define NCURSES_ATTR_SHIFT 8
#define NCURSES_BITS(mask,shift) ((mask) << ((shift) + NCURSES_ATTR_SHIFT))

#define A_NORMAL (1U - 1U)
#define A_ATTRIBUTES NCURSES_BITS(~(1U - 1U),0)
#define A_CHARTEXT (NCURSES_BITS(1U,0) - 1U)
#define A_COLOR NCURSES_BITS(((1U) << 8) - 1U,0)
#define A_STANDOUT NCURSES_BITS(1U,8)
#define A_UNDERLINE NCURSES_BITS(1U,9)
#define A_REVERSE NCURSES_BITS(1U,10)
#define A_BLINK NCURSES_BITS(1U,11)
#define A_DIM NCURSES_BITS(1U,12)
#define A_BOLD NCURSES_BITS(1U,13)
#define A_ALTCHARSET NCURSES_BITS(1U,14)
#define A_INVIS NCURSES_BITS(1U,15)
#define A_PROTECT NCURSES_BITS(1U,16)
#define A_HORIZONTAL NCURSES_BITS(1U,17)
#define A_LEFT NCURSES_BITS(1U,18)
#define A_LOW NCURSES_BITS(1U,19)
#define A_RIGHT NCURSES_BITS(1U,20)
#define A_TOP NCURSES_BITS(1U,21)
#define A_VERTICAL NCURSES_BITS(1U,22)
# 911 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define getyx(win,y,x) (y = getcury(win), x = getcurx(win))
#define getbegyx(win,y,x) (y = getbegy(win), x = getbegx(win))
#define getmaxyx(win,y,x) (y = getmaxy(win), x = getmaxx(win))
#define getparyx(win,y,x) (y = getpary(win), x = getparx(win))

#define getsyx(y,x) do { if (newscr) { if (is_leaveok(newscr)) (y) = (x) = -1; else getyx(newscr,(y), (x)); } } while(0)







#define setsyx(y,x) do { if (newscr) { if ((y) == -1 && (x) == -1) leaveok(newscr, TRUE); else { leaveok(newscr, FALSE); wmove(newscr, (y), (x)); } } } while(0)
# 940 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define wgetstr(w,s) wgetnstr(w, s, -1)
#define getnstr(s,n) wgetnstr(stdscr, s, n)

#define setterm(term) setupterm(term, 1, (int *)0)

#define fixterm() reset_prog_mode()
#define resetterm() reset_shell_mode()
#define saveterm() def_prog_mode()
#define crmode() cbreak()
#define nocrmode() nocbreak()
#define gettmode() 
# 965 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define wstandout(win) (wattrset(win,A_STANDOUT))
#define wstandend(win) (wattrset(win,A_NORMAL))

#define wattron(win,at) wattr_on(win, NCURSES_CAST(attr_t, at), NULL)
#define wattroff(win,at) wattr_off(win, NCURSES_CAST(attr_t, at), NULL)
# 980 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define scroll(win) wscrl(win,1)

#define touchwin(win) wtouchln((win), 0, getmaxy(win), 1)
#define touchline(win,s,c) wtouchln((win), s, c, 1)
#define untouchwin(win) wtouchln((win), 0, getmaxy(win), 0)

#define box(win,v,h) wborder(win, v, v, h, h, 0, 0, 0, 0)
#define border(ls,rs,ts,bs,tl,tr,bl,br) wborder(stdscr, ls, rs, ts, bs, tl, tr, bl, br)
#define hline(ch,n) whline(stdscr, ch, n)
#define vline(ch,n) wvline(stdscr, ch, n)

#define winstr(w,s) winnstr(w, s, -1)
#define winchstr(w,s) winchnstr(w, s, -1)
#define winsstr(w,s) winsnstr(w, s, -1)





#define waddstr(win,str) waddnstr(win,str,-1)
#define waddchstr(win,str) waddchnstr(win,str,-1)




#define COLOR_PAIR(n) NCURSES_BITS(n, 0)
#define PAIR_NUMBER(a) (NCURSES_CAST(int,(((a) & A_COLOR) >> NCURSES_ATTR_SHIFT)))





#define addch(ch) waddch(stdscr,ch)
#define addchnstr(str,n) waddchnstr(stdscr,str,n)
#define addchstr(str) waddchstr(stdscr,str)
#define addnstr(str,n) waddnstr(stdscr,str,n)
#define addstr(str) waddnstr(stdscr,str,-1)
#define attroff(at) wattroff(stdscr,at)
#define attron(at) wattron(stdscr,at)
#define attrset(at) wattrset(stdscr,at)
#define attr_get(ap,cp,o) wattr_get(stdscr,ap,cp,o)
#define attr_off(a,o) wattr_off(stdscr,a,o)
#define attr_on(a,o) wattr_on(stdscr,a,o)
#define attr_set(a,c,o) wattr_set(stdscr,a,c,o)
#define bkgd(ch) wbkgd(stdscr,ch)
#define bkgdset(ch) wbkgdset(stdscr,ch)
#define chgat(n,a,c,o) wchgat(stdscr,n,a,c,o)
#define clear() wclear(stdscr)
#define clrtobot() wclrtobot(stdscr)
#define clrtoeol() wclrtoeol(stdscr)
#define color_set(c,o) wcolor_set(stdscr,c,o)
#define delch() wdelch(stdscr)
#define deleteln() winsdelln(stdscr,-1)
#define echochar(c) wechochar(stdscr,c)
#define erase() werase(stdscr)
#define getch() wgetch(stdscr)
#define getstr(str) wgetstr(stdscr,str)
#define inch() winch(stdscr)
#define inchnstr(s,n) winchnstr(stdscr,s,n)
#define inchstr(s) winchstr(stdscr,s)
#define innstr(s,n) winnstr(stdscr,s,n)
#define insch(c) winsch(stdscr,c)
#define insdelln(n) winsdelln(stdscr,n)
#define insertln() winsdelln(stdscr,1)
#define insnstr(s,n) winsnstr(stdscr,s,n)
#define insstr(s) winsstr(stdscr,s)
#define instr(s) winstr(stdscr,s)
#define move(y,x) wmove(stdscr,y,x)
#define refresh() wrefresh(stdscr)
#define scrl(n) wscrl(stdscr,n)
#define setscrreg(t,b) wsetscrreg(stdscr,t,b)
#define standend() wstandend(stdscr)
#define standout() wstandout(stdscr)
#define timeout(delay) wtimeout(stdscr,delay)
#define wdeleteln(win) winsdelln(win,-1)
#define winsertln(win) winsdelln(win,1)





#define mvwaddch(win,y,x,ch) (wmove(win,y,x) == ERR ? ERR : waddch(win,ch))
#define mvwaddchnstr(win,y,x,str,n) (wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,n))
#define mvwaddchstr(win,y,x,str) (wmove(win,y,x) == ERR ? ERR : waddchnstr(win,str,-1))
#define mvwaddnstr(win,y,x,str,n) (wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,n))
#define mvwaddstr(win,y,x,str) (wmove(win,y,x) == ERR ? ERR : waddnstr(win,str,-1))
#define mvwdelch(win,y,x) (wmove(win,y,x) == ERR ? ERR : wdelch(win))
#define mvwchgat(win,y,x,n,a,c,o) (wmove(win,y,x) == ERR ? ERR : wchgat(win,n,a,c,o))
#define mvwgetch(win,y,x) (wmove(win,y,x) == ERR ? ERR : wgetch(win))
#define mvwgetnstr(win,y,x,str,n) (wmove(win,y,x) == ERR ? ERR : wgetnstr(win,str,n))
#define mvwgetstr(win,y,x,str) (wmove(win,y,x) == ERR ? ERR : wgetstr(win,str))
#define mvwhline(win,y,x,c,n) (wmove(win,y,x) == ERR ? ERR : whline(win,c,n))
#define mvwinch(win,y,x) (wmove(win,y,x) == ERR ? NCURSES_CAST(chtype, ERR) : winch(win))
#define mvwinchnstr(win,y,x,s,n) (wmove(win,y,x) == ERR ? ERR : winchnstr(win,s,n))
#define mvwinchstr(win,y,x,s) (wmove(win,y,x) == ERR ? ERR : winchstr(win,s))
#define mvwinnstr(win,y,x,s,n) (wmove(win,y,x) == ERR ? ERR : winnstr(win,s,n))
#define mvwinsch(win,y,x,c) (wmove(win,y,x) == ERR ? ERR : winsch(win,c))
#define mvwinsnstr(win,y,x,s,n) (wmove(win,y,x) == ERR ? ERR : winsnstr(win,s,n))
#define mvwinsstr(win,y,x,s) (wmove(win,y,x) == ERR ? ERR : winsstr(win,s))
#define mvwinstr(win,y,x,s) (wmove(win,y,x) == ERR ? ERR : winstr(win,s))
#define mvwvline(win,y,x,c,n) (wmove(win,y,x) == ERR ? ERR : wvline(win,c,n))

#define mvaddch(y,x,ch) mvwaddch(stdscr,y,x,ch)
#define mvaddchnstr(y,x,str,n) mvwaddchnstr(stdscr,y,x,str,n)
#define mvaddchstr(y,x,str) mvwaddchstr(stdscr,y,x,str)
#define mvaddnstr(y,x,str,n) mvwaddnstr(stdscr,y,x,str,n)
#define mvaddstr(y,x,str) mvwaddstr(stdscr,y,x,str)
#define mvchgat(y,x,n,a,c,o) mvwchgat(stdscr,y,x,n,a,c,o)
#define mvdelch(y,x) mvwdelch(stdscr,y,x)
#define mvgetch(y,x) mvwgetch(stdscr,y,x)
#define mvgetnstr(y,x,str,n) mvwgetnstr(stdscr,y,x,str,n)
#define mvgetstr(y,x,str) mvwgetstr(stdscr,y,x,str)
#define mvhline(y,x,c,n) mvwhline(stdscr,y,x,c,n)
#define mvinch(y,x) mvwinch(stdscr,y,x)
#define mvinchnstr(y,x,s,n) mvwinchnstr(stdscr,y,x,s,n)
#define mvinchstr(y,x,s) mvwinchstr(stdscr,y,x,s)
#define mvinnstr(y,x,s,n) mvwinnstr(stdscr,y,x,s,n)
#define mvinsch(y,x,c) mvwinsch(stdscr,y,x,c)
#define mvinsnstr(y,x,s,n) mvwinsnstr(stdscr,y,x,s,n)
#define mvinsstr(y,x,s) mvwinsstr(stdscr,y,x,s)
#define mvinstr(y,x,s) mvwinstr(stdscr,y,x,s)
#define mvvline(y,x,c,n) mvwvline(stdscr,y,x,c,n)
# 1110 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define slk_attr_off(a,v) ((v) ? ERR : slk_attroff(a))
#define slk_attr_on(a,v) ((v) ? ERR : slk_attron(a))
# 1135 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define vw_printw vwprintw
#define vw_scanw vwscanw
# 1202 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
extern WINDOW * curscr;
extern WINDOW * newscr;
extern WINDOW * stdscr;
extern char ttytype[];
extern int COLORS;
extern int COLOR_PAIRS;
extern int COLS;
extern int ESCDELAY;
extern int LINES;
extern int TABSIZE;
# 1227 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define KEY_CODE_YES 0400
#define KEY_MIN 0401
#define KEY_BREAK 0401
#define KEY_SRESET 0530
#define KEY_RESET 0531



#define KEY_DOWN 0402
#define KEY_UP 0403
#define KEY_LEFT 0404
#define KEY_RIGHT 0405
#define KEY_HOME 0406
#define KEY_BACKSPACE 0407
#define KEY_F0 0410
#define KEY_F(n) (KEY_F0+(n))
#define KEY_DL 0510
#define KEY_IL 0511
#define KEY_DC 0512
#define KEY_IC 0513
#define KEY_EIC 0514
#define KEY_CLEAR 0515
#define KEY_EOS 0516
#define KEY_EOL 0517
#define KEY_SF 0520
#define KEY_SR 0521
#define KEY_NPAGE 0522
#define KEY_PPAGE 0523
#define KEY_STAB 0524
#define KEY_CTAB 0525
#define KEY_CATAB 0526
#define KEY_ENTER 0527
#define KEY_PRINT 0532
#define KEY_LL 0533
#define KEY_A1 0534
#define KEY_A3 0535
#define KEY_B2 0536
#define KEY_C1 0537
#define KEY_C3 0540
#define KEY_BTAB 0541
#define KEY_BEG 0542
#define KEY_CANCEL 0543
#define KEY_CLOSE 0544
#define KEY_COMMAND 0545
#define KEY_COPY 0546
#define KEY_CREATE 0547
#define KEY_END 0550
#define KEY_EXIT 0551
#define KEY_FIND 0552
#define KEY_HELP 0553
#define KEY_MARK 0554
#define KEY_MESSAGE 0555
#define KEY_MOVE 0556
#define KEY_NEXT 0557
#define KEY_OPEN 0560
#define KEY_OPTIONS 0561
#define KEY_PREVIOUS 0562
#define KEY_REDO 0563
#define KEY_REFERENCE 0564
#define KEY_REFRESH 0565
#define KEY_REPLACE 0566
#define KEY_RESTART 0567
#define KEY_RESUME 0570
#define KEY_SAVE 0571
#define KEY_SBEG 0572
#define KEY_SCANCEL 0573
#define KEY_SCOMMAND 0574
#define KEY_SCOPY 0575
#define KEY_SCREATE 0576
#define KEY_SDC 0577
#define KEY_SDL 0600
#define KEY_SELECT 0601
#define KEY_SEND 0602
#define KEY_SEOL 0603
#define KEY_SEXIT 0604
#define KEY_SFIND 0605
#define KEY_SHELP 0606
#define KEY_SHOME 0607
#define KEY_SIC 0610
#define KEY_SLEFT 0611
#define KEY_SMESSAGE 0612
#define KEY_SMOVE 0613
#define KEY_SNEXT 0614
#define KEY_SOPTIONS 0615
#define KEY_SPREVIOUS 0616
#define KEY_SPRINT 0617
#define KEY_SREDO 0620
#define KEY_SREPLACE 0621
#define KEY_SRIGHT 0622
#define KEY_SRSUME 0623
#define KEY_SSAVE 0624
#define KEY_SSUSPEND 0625
#define KEY_SUNDO 0626
#define KEY_SUSPEND 0627
#define KEY_UNDO 0630
#define KEY_MOUSE 0631
#define KEY_RESIZE 0632
#define KEY_EVENT 0633

#define KEY_MAX 0777
# 1335 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
extern cchar_t * _nc_wacs;

#define NCURSES_WACS(c) (&_nc_wacs[(unsigned char)c])

#define WACS_BSSB NCURSES_WACS('l')
#define WACS_SSBB NCURSES_WACS('m')
#define WACS_BBSS NCURSES_WACS('k')
#define WACS_SBBS NCURSES_WACS('j')
#define WACS_SBSS NCURSES_WACS('u')
#define WACS_SSSB NCURSES_WACS('t')
#define WACS_SSBS NCURSES_WACS('v')
#define WACS_BSSS NCURSES_WACS('w')
#define WACS_BSBS NCURSES_WACS('q')
#define WACS_SBSB NCURSES_WACS('x')
#define WACS_SSSS NCURSES_WACS('n')

#define WACS_ULCORNER WACS_BSSB
#define WACS_LLCORNER WACS_SSBB
#define WACS_URCORNER WACS_BBSS
#define WACS_LRCORNER WACS_SBBS
#define WACS_RTEE WACS_SBSS
#define WACS_LTEE WACS_SSSB
#define WACS_BTEE WACS_SSBS
#define WACS_TTEE WACS_BSSS
#define WACS_HLINE WACS_BSBS
#define WACS_VLINE WACS_SBSB
#define WACS_PLUS WACS_SSSS

#define WACS_S1 NCURSES_WACS('o')
#define WACS_S9 NCURSES_WACS('s')
#define WACS_DIAMOND NCURSES_WACS('`')
#define WACS_CKBOARD NCURSES_WACS('a')
#define WACS_DEGREE NCURSES_WACS('f')
#define WACS_PLMINUS NCURSES_WACS('g')
#define WACS_BULLET NCURSES_WACS('~')


#define WACS_LARROW NCURSES_WACS(',')
#define WACS_RARROW NCURSES_WACS('+')
#define WACS_DARROW NCURSES_WACS('.')
#define WACS_UARROW NCURSES_WACS('-')
#define WACS_BOARD NCURSES_WACS('h')
#define WACS_LANTERN NCURSES_WACS('i')
#define WACS_BLOCK NCURSES_WACS('0')


#define WACS_S3 NCURSES_WACS('p')
#define WACS_S7 NCURSES_WACS('r')
#define WACS_LEQUAL NCURSES_WACS('y')
#define WACS_GEQUAL NCURSES_WACS('z')
#define WACS_PI NCURSES_WACS('{')
#define WACS_NEQUAL NCURSES_WACS('|')
#define WACS_STERLING NCURSES_WACS('}')
# 1398 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
extern int add_wch (const cchar_t *);
extern int add_wchnstr (const cchar_t *, int);
extern int add_wchstr (const cchar_t *);
extern int addnwstr (const wchar_t *, int);
extern int addwstr (const wchar_t *);
extern int bkgrnd (const cchar_t *);
extern void bkgrndset (const cchar_t *);
extern int border_set (const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*);
extern int box_set (WINDOW *, const cchar_t *, const cchar_t *);
extern int echo_wchar (const cchar_t *);
extern int erasewchar (wchar_t*);
extern int get_wch (wint_t *);
extern int get_wstr (wint_t *);
extern int getbkgrnd (cchar_t *);
extern int getcchar (const cchar_t *, wchar_t*, attr_t*, short*, void*);
extern int getn_wstr (wint_t *, int);
extern int hline_set (const cchar_t *, int);
extern int in_wch (cchar_t *);
extern int in_wchnstr (cchar_t *, int);
extern int in_wchstr (cchar_t *);
extern int innwstr (wchar_t *, int);
extern int ins_nwstr (const wchar_t *, int);
extern int ins_wch (const cchar_t *);
extern int ins_wstr (const wchar_t *);
extern int inwstr (wchar_t *);
extern char* key_name (wchar_t);
extern int killwchar (wchar_t *);
extern int mvadd_wch (int, int, const cchar_t *);
extern int mvadd_wchnstr (int, int, const cchar_t *, int);
extern int mvadd_wchstr (int, int, const cchar_t *);
extern int mvaddnwstr (int, int, const wchar_t *, int);
extern int mvaddwstr (int, int, const wchar_t *);
extern int mvget_wch (int, int, wint_t *);
extern int mvget_wstr (int, int, wint_t *);
extern int mvgetn_wstr (int, int, wint_t *, int);
extern int mvhline_set (int, int, const cchar_t *, int);
extern int mvin_wch (int, int, cchar_t *);
extern int mvin_wchnstr (int, int, cchar_t *, int);
extern int mvin_wchstr (int, int, cchar_t *);
extern int mvinnwstr (int, int, wchar_t *, int);
extern int mvins_nwstr (int, int, const wchar_t *, int);
extern int mvins_wch (int, int, const cchar_t *);
extern int mvins_wstr (int, int, const wchar_t *);
extern int mvinwstr (int, int, wchar_t *);
extern int mvvline_set (int, int, const cchar_t *, int);
extern int mvwadd_wch (WINDOW *, int, int, const cchar_t *);
extern int mvwadd_wchnstr (WINDOW *, int, int, const cchar_t *, int);
extern int mvwadd_wchstr (WINDOW *, int, int, const cchar_t *);
extern int mvwaddnwstr (WINDOW *, int, int, const wchar_t *, int);
extern int mvwaddwstr (WINDOW *, int, int, const wchar_t *);
extern int mvwget_wch (WINDOW *, int, int, wint_t *);
extern int mvwget_wstr (WINDOW *, int, int, wint_t *);
extern int mvwgetn_wstr (WINDOW *, int, int, wint_t *, int);
extern int mvwhline_set (WINDOW *, int, int, const cchar_t *, int);
extern int mvwin_wch (WINDOW *, int, int, cchar_t *);
extern int mvwin_wchnstr (WINDOW *, int,int, cchar_t *,int);
extern int mvwin_wchstr (WINDOW *, int, int, cchar_t *);
extern int mvwinnwstr (WINDOW *, int, int, wchar_t *, int);
extern int mvwins_nwstr (WINDOW *, int,int, const wchar_t *,int);
extern int mvwins_wch (WINDOW *, int, int, const cchar_t *);
extern int mvwins_wstr (WINDOW *, int, int, const wchar_t *);
extern int mvwinwstr (WINDOW *, int, int, wchar_t *);
extern int mvwvline_set (WINDOW *, int,int, const cchar_t *,int);
extern int pecho_wchar (WINDOW *, const cchar_t *);
extern int setcchar (cchar_t *, const wchar_t *, const attr_t, short, const void *);
extern int slk_wset (int, const wchar_t *, int);
extern attr_t term_attrs (void);
extern int unget_wch (const wchar_t);
extern int vid_attr (attr_t, short, void *);
extern int vid_puts (attr_t, short, void *, int (*)(int));
extern int vline_set (const cchar_t *, int);
extern int wadd_wch (WINDOW *,const cchar_t *);
extern int wadd_wchnstr (WINDOW *,const cchar_t *,int);
extern int wadd_wchstr (WINDOW *,const cchar_t *);
extern int waddnwstr (WINDOW *,const wchar_t *,int);
extern int waddwstr (WINDOW *,const wchar_t *);
extern int wbkgrnd (WINDOW *,const cchar_t *);
extern void wbkgrndset (WINDOW *,const cchar_t *);
extern int wborder_set (WINDOW *,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*,const cchar_t*);
extern int wecho_wchar (WINDOW *, const cchar_t *);
extern int wget_wch (WINDOW *, wint_t *);
extern int wget_wstr (WINDOW *, wint_t *);
extern int wgetbkgrnd (WINDOW *, cchar_t *);
extern int wgetn_wstr (WINDOW *,wint_t *, int);
extern int whline_set (WINDOW *, const cchar_t *, int);
extern int win_wch (WINDOW *, cchar_t *);
extern int win_wchnstr (WINDOW *, cchar_t *, int);
extern int win_wchstr (WINDOW *, cchar_t *);
extern int winnwstr (WINDOW *, wchar_t *, int);
extern int wins_nwstr (WINDOW *, const wchar_t *, int);
extern int wins_wch (WINDOW *, const cchar_t *);
extern int wins_wstr (WINDOW *, const wchar_t *);
extern int winwstr (WINDOW *, wchar_t *);
extern wchar_t* wunctrl (cchar_t *);
extern int wvline_set (WINDOW *, const cchar_t *, int);






#define add_wch(c) wadd_wch(stdscr,c)
#define add_wchnstr(str,n) wadd_wchnstr(stdscr,str,n)
#define add_wchstr(str) wadd_wchstr(stdscr,str)
#define addnwstr(wstr,n) waddnwstr(stdscr,wstr,n)
#define addwstr(wstr) waddwstr(stdscr,wstr)
#define bkgrnd(c) wbkgrnd(stdscr,c)
#define bkgrndset(c) wbkgrndset(stdscr,c)
#define border_set(l,r,t,b,tl,tr,bl,br) wborder_set(stdscr,l,r,t,b,tl,tr,bl,br)
#define box_set(w,v,h) wborder_set(w,v,v,h,h,0,0,0,0)
#define echo_wchar(c) wecho_wchar(stdscr,c)
#define get_wch(c) wget_wch(stdscr,c)
#define get_wstr(t) wget_wstr(stdscr,t)
#define getbkgrnd(wch) wgetbkgrnd(stdscr,wch)
#define getn_wstr(t,n) wgetn_wstr(stdscr,t,n)
#define hline_set(c,n) whline_set(stdscr,c,n)
#define in_wch(c) win_wch(stdscr,c)
#define in_wchnstr(c,n) win_wchnstr(stdscr,c,n)
#define in_wchstr(c) win_wchstr(stdscr,c)
#define innwstr(c,n) winnwstr(stdscr,c,n)
#define ins_nwstr(t,n) wins_nwstr(stdscr,t,n)
#define ins_wch(c) wins_wch(stdscr,c)
#define ins_wstr(t) wins_wstr(stdscr,t)
#define inwstr(c) winwstr(stdscr,c)
#define vline_set(c,n) wvline_set(stdscr,c,n)
#define wadd_wchstr(win,str) wadd_wchnstr(win,str,-1)
#define waddwstr(win,wstr) waddnwstr(win,wstr,-1)
#define wget_wstr(w,t) wgetn_wstr(w,t,-1)
#define win_wchstr(w,c) win_wchnstr(w,c,-1)
#define wins_wstr(w,t) wins_nwstr(w,t,-1)





#define mvadd_wch(y,x,c) mvwadd_wch(stdscr,y,x,c)
#define mvadd_wchnstr(y,x,s,n) mvwadd_wchnstr(stdscr,y,x,s,n)
#define mvadd_wchstr(y,x,s) mvwadd_wchstr(stdscr,y,x,s)
#define mvaddnwstr(y,x,wstr,n) mvwaddnwstr(stdscr,y,x,wstr,n)
#define mvaddwstr(y,x,wstr) mvwaddwstr(stdscr,y,x,wstr)
#define mvget_wch(y,x,c) mvwget_wch(stdscr,y,x,c)
#define mvget_wstr(y,x,t) mvwget_wstr(stdscr,y,x,t)
#define mvgetn_wstr(y,x,t,n) mvwgetn_wstr(stdscr,y,x,t,n)
#define mvhline_set(y,x,c,n) mvwhline_set(stdscr,y,x,c,n)
#define mvin_wch(y,x,c) mvwin_wch(stdscr,y,x,c)
#define mvin_wchnstr(y,x,c,n) mvwin_wchnstr(stdscr,y,x,c,n)
#define mvin_wchstr(y,x,c) mvwin_wchstr(stdscr,y,x,c)
#define mvinnwstr(y,x,c,n) mvwinnwstr(stdscr,y,x,c,n)
#define mvins_nwstr(y,x,t,n) mvwins_nwstr(stdscr,y,x,t,n)
#define mvins_wch(y,x,c) mvwins_wch(stdscr,y,x,c)
#define mvins_wstr(y,x,t) mvwins_wstr(stdscr,y,x,t)
#define mvinwstr(y,x,c) mvwinwstr(stdscr,y,x,c)
#define mvvline_set(y,x,c,n) mvwvline_set(stdscr,y,x,c,n)

#define mvwadd_wch(win,y,x,c) (wmove(win,y,x) == ERR ? ERR : wadd_wch(win,c))
#define mvwadd_wchnstr(win,y,x,s,n) (wmove(win,y,x) == ERR ? ERR : wadd_wchnstr(win,s,n))
#define mvwadd_wchstr(win,y,x,s) (wmove(win,y,x) == ERR ? ERR : wadd_wchstr(win,s))
#define mvwaddnwstr(win,y,x,wstr,n) (wmove(win,y,x) == ERR ? ERR : waddnwstr(win,wstr,n))
#define mvwaddwstr(win,y,x,wstr) (wmove(win,y,x) == ERR ? ERR : waddwstr(win,wstr))
#define mvwget_wch(win,y,x,c) (wmove(win,y,x) == ERR ? ERR : wget_wch(win,c))
#define mvwget_wstr(win,y,x,t) (wmove(win,y,x) == ERR ? ERR : wget_wstr(win,t))
#define mvwgetn_wstr(win,y,x,t,n) (wmove(win,y,x) == ERR ? ERR : wgetn_wstr(win,t,n))
#define mvwhline_set(win,y,x,c,n) (wmove(win,y,x) == ERR ? ERR : whline_set(win,c,n))
#define mvwin_wch(win,y,x,c) (wmove(win,y,x) == ERR ? ERR : win_wch(win,c))
#define mvwin_wchnstr(win,y,x,c,n) (wmove(win,y,x) == ERR ? ERR : win_wchnstr(win,c,n))
#define mvwin_wchstr(win,y,x,c) (wmove(win,y,x) == ERR ? ERR : win_wchstr(win,c))
#define mvwinnwstr(win,y,x,c,n) (wmove(win,y,x) == ERR ? ERR : winnwstr(win,c,n))
#define mvwins_nwstr(win,y,x,t,n) (wmove(win,y,x) == ERR ? ERR : wins_nwstr(win,t,n))
#define mvwins_wch(win,y,x,c) (wmove(win,y,x) == ERR ? ERR : wins_wch(win,c))
#define mvwins_wstr(win,y,x,t) (wmove(win,y,x) == ERR ? ERR : wins_wstr(win,t))
#define mvwinwstr(win,y,x,c) (wmove(win,y,x) == ERR ? ERR : winwstr(win,c))
#define mvwvline_set(win,y,x,c,n) (wmove(win,y,x) == ERR ? ERR : wvline_set(win,c,n))
# 1591 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define NCURSES_MOUSE_MASK(b,m) ((m) << (((b) - 1) * 6))


#define NCURSES_BUTTON_RELEASED 001L
#define NCURSES_BUTTON_PRESSED 002L
#define NCURSES_BUTTON_CLICKED 004L
#define NCURSES_DOUBLE_CLICKED 010L
#define NCURSES_TRIPLE_CLICKED 020L
#define NCURSES_RESERVED_EVENT 040L


#define BUTTON1_RELEASED NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_RELEASED)
#define BUTTON1_PRESSED NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_PRESSED)
#define BUTTON1_CLICKED NCURSES_MOUSE_MASK(1, NCURSES_BUTTON_CLICKED)
#define BUTTON1_DOUBLE_CLICKED NCURSES_MOUSE_MASK(1, NCURSES_DOUBLE_CLICKED)
#define BUTTON1_TRIPLE_CLICKED NCURSES_MOUSE_MASK(1, NCURSES_TRIPLE_CLICKED)

#define BUTTON2_RELEASED NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_RELEASED)
#define BUTTON2_PRESSED NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_PRESSED)
#define BUTTON2_CLICKED NCURSES_MOUSE_MASK(2, NCURSES_BUTTON_CLICKED)
#define BUTTON2_DOUBLE_CLICKED NCURSES_MOUSE_MASK(2, NCURSES_DOUBLE_CLICKED)
#define BUTTON2_TRIPLE_CLICKED NCURSES_MOUSE_MASK(2, NCURSES_TRIPLE_CLICKED)

#define BUTTON3_RELEASED NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_RELEASED)
#define BUTTON3_PRESSED NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_PRESSED)
#define BUTTON3_CLICKED NCURSES_MOUSE_MASK(3, NCURSES_BUTTON_CLICKED)
#define BUTTON3_DOUBLE_CLICKED NCURSES_MOUSE_MASK(3, NCURSES_DOUBLE_CLICKED)
#define BUTTON3_TRIPLE_CLICKED NCURSES_MOUSE_MASK(3, NCURSES_TRIPLE_CLICKED)

#define BUTTON4_RELEASED NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_RELEASED)
#define BUTTON4_PRESSED NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_PRESSED)
#define BUTTON4_CLICKED NCURSES_MOUSE_MASK(4, NCURSES_BUTTON_CLICKED)
#define BUTTON4_DOUBLE_CLICKED NCURSES_MOUSE_MASK(4, NCURSES_DOUBLE_CLICKED)
#define BUTTON4_TRIPLE_CLICKED NCURSES_MOUSE_MASK(4, NCURSES_TRIPLE_CLICKED)
# 1645 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define BUTTON1_RESERVED_EVENT NCURSES_MOUSE_MASK(1, NCURSES_RESERVED_EVENT)
#define BUTTON2_RESERVED_EVENT NCURSES_MOUSE_MASK(2, NCURSES_RESERVED_EVENT)
#define BUTTON3_RESERVED_EVENT NCURSES_MOUSE_MASK(3, NCURSES_RESERVED_EVENT)
#define BUTTON4_RESERVED_EVENT NCURSES_MOUSE_MASK(4, NCURSES_RESERVED_EVENT)

#define BUTTON_CTRL NCURSES_MOUSE_MASK(5, 0001L)
#define BUTTON_SHIFT NCURSES_MOUSE_MASK(5, 0002L)
#define BUTTON_ALT NCURSES_MOUSE_MASK(5, 0004L)
#define REPORT_MOUSE_POSITION NCURSES_MOUSE_MASK(5, 0010L)



#define ALL_MOUSE_EVENTS (REPORT_MOUSE_POSITION - 1)


#define BUTTON_RELEASE(e,x) ((e) & NCURSES_MOUSE_MASK(x, 001))
#define BUTTON_PRESS(e,x) ((e) & NCURSES_MOUSE_MASK(x, 002))
#define BUTTON_CLICK(e,x) ((e) & NCURSES_MOUSE_MASK(x, 004))
#define BUTTON_DOUBLE_CLICK(e,x) ((e) & NCURSES_MOUSE_MASK(x, 010))
#define BUTTON_TRIPLE_CLICK(e,x) ((e) & NCURSES_MOUSE_MASK(x, 020))
#define BUTTON_RESERVED_EVENT(e,x) ((e) & NCURSES_MOUSE_MASK(x, 040))

typedef struct
{
    short id;
    int x, y, z;
    mmask_t bstate;
}
MEVENT;

extern int getmouse (MEVENT *);
extern int ungetmouse (MEVENT *);
extern mmask_t mousemask (mmask_t, mmask_t *);
extern _Bool wenclose (const WINDOW *, int, int);
extern int mouseinterval (int);
extern _Bool wmouse_trafo (const WINDOW*, int*, int*, _Bool);
extern _Bool mouse_trafo (int*, int*, _Bool);

#define mouse_trafo(y,x,to_screen) wmouse_trafo(stdscr,y,x,to_screen)



extern int mcprint (char *, int);
extern int has_key (int);
# 1715 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/curses.h" 3 4
#define TRACE_DISABLE 0x0000
#define TRACE_TIMES 0x0001
#define TRACE_TPUTS 0x0002
#define TRACE_UPDATE 0x0004
#define TRACE_MOVE 0x0008
#define TRACE_CHARPUT 0x0010
#define TRACE_ORDINARY 0x001F
#define TRACE_CALLS 0x0020
#define TRACE_VIRTPUT 0x0040
#define TRACE_IEVENT 0x0080
#define TRACE_BITS 0x0100
#define TRACE_ICALLS 0x0200
#define TRACE_CCALLS 0x0400
#define TRACE_DATABASE 0x0800
#define TRACE_ATTRS 0x1000

#define TRACE_SHIFT 13
#define TRACE_MAXIMUM ((1 << TRACE_SHIFT) - 1)
# 34 "project/nnn/src/nnn.h" 2

#define CONTROL(c) ((c) & 0x1f)


#define ESC (27)



#define DEL (127)




# 46 "project/nnn/src/nnn.h"
enum action {
 SEL_BACK = 1,
 SEL_OPEN,
 SEL_NAV_IN,
 SEL_NEXT,
 SEL_PREV,
 SEL_PGDN,
 SEL_PGUP,
 SEL_CTRL_D,
 SEL_CTRL_U,
 SEL_HOME,
 SEL_END,
 SEL_FIRST,
 SEL_CDHOME,
 SEL_CDBEGIN,
 SEL_CDLAST,
 SEL_CDROOT,
 SEL_BMOPEN,
 SEL_REMOTE,
 SEL_CYCLE,
 SEL_CYCLER,
 SEL_CTX1,
 SEL_CTX2,
 SEL_CTX3,
 SEL_CTX4,






 SEL_MARK,
 SEL_BMARK,
 SEL_FLTR,
 SEL_MFLTR,
 SEL_HIDDEN,
 SEL_DETAIL,
 SEL_STATS,
 SEL_CHMODX,
 SEL_ARCHIVE,
 SEL_SORT,
 SEL_REDRAW,
 SEL_SEL,
 SEL_SELMUL,
 SEL_SELALL,
 SEL_SELINV,
 SEL_SELEDIT,
 SEL_CP,
 SEL_MV,
 SEL_CPMVAS,
 SEL_RM,
 SEL_OPENWITH,
 SEL_NEW,
 SEL_RENAME,
 SEL_RENAMEMUL,
 SEL_UMOUNT,
 SEL_HELP,
 SEL_AUTONEXT,
 SEL_EDIT,
 SEL_PLUGIN,
 SEL_SHELL,
 SEL_LAUNCH,
 SEL_PROMPT,
 SEL_LOCK,
 SEL_SESSIONS,
 SEL_EXPORT,
 SEL_TIMETYPE,
 SEL_QUITCTX,
 SEL_QUITCD,
 SEL_QUIT,
 SEL_QUITERR,

 SEL_CLICK,

};


struct key {
 int sym;
 enum action act;
};

static struct key bindings[] = {

 { 
# 130 "project/nnn/src/nnn.h" 3 4
  0404
# 130 "project/nnn/src/nnn.h"
          , SEL_BACK },
 { 'h', SEL_BACK },

 { 
# 133 "project/nnn/src/nnn.h" 3 4
  0527
# 133 "project/nnn/src/nnn.h"
           , SEL_OPEN },
 { '\r', SEL_OPEN },

 { 
# 136 "project/nnn/src/nnn.h" 3 4
  0405
# 136 "project/nnn/src/nnn.h"
           , SEL_NAV_IN },
 { 'l', SEL_NAV_IN },

 { 'j', SEL_NEXT },
 { 
# 140 "project/nnn/src/nnn.h" 3 4
  0402
# 140 "project/nnn/src/nnn.h"
          , SEL_NEXT },

 { 'k', SEL_PREV },
 { 
# 143 "project/nnn/src/nnn.h" 3 4
  0403
# 143 "project/nnn/src/nnn.h"
        , SEL_PREV },

 { 
# 145 "project/nnn/src/nnn.h" 3 4
  0522
# 145 "project/nnn/src/nnn.h"
           , SEL_PGDN },

 { 
# 147 "project/nnn/src/nnn.h" 3 4
  0523
# 147 "project/nnn/src/nnn.h"
           , SEL_PGUP },

 { (('D') & 0x1f), SEL_CTRL_D },

 { (('U') & 0x1f), SEL_CTRL_U },

 { 
# 153 "project/nnn/src/nnn.h" 3 4
  0406
# 153 "project/nnn/src/nnn.h"
          , SEL_HOME },
 { 'g', SEL_HOME },
 { (('A') & 0x1f), SEL_HOME },

 { 
# 157 "project/nnn/src/nnn.h" 3 4
  0550
# 157 "project/nnn/src/nnn.h"
         , SEL_END },
 { 'G', SEL_END },
 { (('E') & 0x1f), SEL_END },

 { '\'', SEL_FIRST },

 { '~', SEL_CDHOME },

 { '@', SEL_CDBEGIN },

 { '-', SEL_CDLAST },

 { '`', SEL_CDROOT },

 { 'b', SEL_BMOPEN },
 { (('_') & 0x1f), SEL_BMOPEN },

 { 'c', SEL_REMOTE },

 { '\t', SEL_CYCLE },

 { 
# 178 "project/nnn/src/nnn.h" 3 4
  0541
# 178 "project/nnn/src/nnn.h"
          , SEL_CYCLER },

 { '1', SEL_CTX1 },
 { '2', SEL_CTX2 },
 { '3', SEL_CTX3 },
 { '4', SEL_CTX4 },







 { ',', SEL_MARK },

 { 'B', SEL_BMARK },

 { '/', SEL_FLTR },

 { (('N') & 0x1f), SEL_MFLTR },

 { '.', SEL_HIDDEN },

 { 'd', SEL_DETAIL },

 { 'f', SEL_STATS },
 { (('F') & 0x1f), SEL_STATS },

 { '*', SEL_CHMODX },

 { 'z', SEL_ARCHIVE },

 { 't', SEL_SORT },
 { (('T') & 0x1f), SEL_SORT },

 { (('L') & 0x1f), SEL_REDRAW },

 { (('J') & 0x1f), SEL_SEL },
 { ' ', SEL_SEL },

 { 'm', SEL_SELMUL },

 { 'a', SEL_SELALL },

 { 'A', SEL_SELINV },

 { 'E', SEL_SELEDIT },

 { 'p', SEL_CP },
 { (('P') & 0x1f), SEL_CP },

 { 'v', SEL_MV },
 { (('V') & 0x1f), SEL_MV },

 { 'w', SEL_CPMVAS },
 { (('W') & 0x1f), SEL_CPMVAS },

 { 'x', SEL_RM },
 { (('X') & 0x1f), SEL_RM },

 { 'o', SEL_OPENWITH },
 { (('O') & 0x1f), SEL_OPENWITH },

 { 'n', SEL_NEW },

 { (('R') & 0x1f), SEL_RENAME },

 { 'r', SEL_RENAMEMUL },

 { 'u', SEL_UMOUNT },

 { '?', SEL_HELP },

 { '+', SEL_AUTONEXT },

 { 'e', SEL_EDIT },

 { ';', SEL_PLUGIN },

 { '!', SEL_SHELL },
 { ((']') & 0x1f), SEL_SHELL },

 { '=', SEL_LAUNCH },

 { ']', SEL_PROMPT },

 { '0', SEL_LOCK },

 { 's', SEL_SESSIONS },

 { '>', SEL_EXPORT },

 { 'T', SEL_TIMETYPE },

 { 'q', SEL_QUITCTX },

 { (('G') & 0x1f), SEL_QUITCD },

 { (('Q') & 0x1f), SEL_QUIT },

 { 'Q', SEL_QUITERR },

 { 
# 280 "project/nnn/src/nnn.h" 3 4
  0631
# 280 "project/nnn/src/nnn.h"
           , SEL_CLICK },

};
# 125 "project/nnn/src/nnn.c" 2
# 1 "project/nnn/src/dbg.h" 1
# 31 "project/nnn/src/dbg.h"
       
# 87 "project/nnn/src/dbg.h"
#define DPRINTF_D(x) 
#define DPRINTF_U(x) 
#define DPRINTF_S(x) 
#define DPRINTF_P(x) 
# 126 "project/nnn/src/nnn.c" 2
# 137 "project/nnn/src/nnn.c"
#define VERSION "4.4"
#define GENERAL_INFO "BSD 2-Clause\nhttps://github.com/jarun/nnn"


#define SESSIONS_VERSION 1
# 160 "project/nnn/src/nnn.c"
#define _ABSSUB(N,M) (((N) <= (M)) ? ((M) - (N)) : ((N) - (M)))
#define ELEMENTS(x) (sizeof(x) / sizeof(*(x)))
#undef MIN
#define MIN(x,y) ((x) < (y) ? (x) : (y))
#undef MAX
#define MAX(x,y) ((x) > (y) ? (x) : (y))
#define ISODD(x) ((x) & 1)
#define ISBLANK(x) ((x) == ' ' || (x) == '\t')
#define TOUPPER(ch) (((ch) >= 'a' && (ch) <= 'z') ? ((ch) - 'a' + 'A') : (ch))
#define TOLOWER(ch) (((ch) >= 'A' && (ch) <= 'Z') ? ((ch) - 'A' + 'a') : (ch))
#define ISUPPER_(ch) ((ch) >= 'A' && (ch) <= 'Z')
#define ISLOWER_(ch) ((ch) >= 'a' && (ch) <= 'z')
#define CMD_LEN_MAX (PATH_MAX + ((NAME_MAX + 1) << 1))
#define ALIGN_UP(x,A) ((((x) + (A) - 1) / (A)) * (A))
#define READLINE_MAX 256
#define FILTER '/'
#define RFILTER '\\'
#define CASE ':'
#define MSGWAIT '$'
#define SELECT ' '
#define PROMPT ">>> "
#define REGEX_MAX 48
#define ENTRY_INCR 64
#define NAMEBUF_INCR 0x800
#define DESCRIPTOR_LEN 32
#define _ALIGNMENT 0x10
#define _ALIGNMENT_MASK 0xF
#define TMP_LEN_MAX 64
#define DOT_FILTER_LEN 7
#define ASCII_MAX 128
#define EXEC_ARGS_MAX 10
#define LIST_FILES_MAX (1 << 16)
#define SCROLLOFF 3
#define COLOR_256 256


#define DBLCLK_INTERVAL_NS (400000000)
#define XDELAY_INTERVAL_MS (350000)


#define CTX_MAX 4






#define SED "gsed"






#define LARGESEL 1000


#define MIN_DISPLAY_COL (CTX_MAX * 2)
#define ARCHIVE_CMD_LEN 16
#define BLK_SHIFT_512 9


#define HASH_BITS (0xFFFFFF)
#define HASH_OCTETS (HASH_BITS >> 6)


#define DIR_OR_DIRLNK 0x01
#define HARD_LINK 0x02
#define SYM_ORPHAN 0x04
#define FILE_MISSING 0x08
#define FILE_SELECTED 0x10
#define FILE_SCANNED 0x20


#define F_NONE 0x00
#define F_MULTI 0x01
#define F_NOWAIT 0x02
#define F_NOTRACE 0x04
#define F_NORMAL 0x08
#define F_CONFIRM 0x10
#define F_CHKRTN 0x20
#define F_NOSTDIN 0x40
#define F_PAGE 0x80
#define F_TTY 0x100
#define F_CLI (F_NORMAL | F_MULTI)
#define F_SILENT (F_CLI | F_NOTRACE)






#define S_N 0x0
#define S_I 0x3
#define S_F 0x6
#define S_Z 0x9


#define VCMP 2
#define VLEN 3


#define FREE 0
#define CAPACITY 1


typedef unsigned int uint_t;
typedef unsigned char uchar_t;
typedef unsigned short ushort_t;
typedef unsigned long long ullong_t;




typedef struct entry {
 char *name;
 time_t sec;
 uint_t nsec;
 mode_t mode;
 off_t size;
 struct {
  ullong_t blocks : 40;
  ullong_t nlen : 16;
  ullong_t flags : 8;
 };

 uid_t uid;
 gid_t gid;

} *pEntry;


typedef struct {
 char *startpos;
 size_t len;
} selmark;


typedef struct {
 int key;
 int off;
} kv;

typedef struct {



 const regex_t *regex;

 const char *str;
} fltrexp_t;





typedef struct {
 uint_t filtermode : 1;
 uint_t timeorder : 1;
 uint_t sizeorder : 1;
 uint_t apparentsz : 1;
 uint_t blkorder : 1;
 uint_t extnorder : 1;
 uint_t showhidden : 1;
 uint_t reserved0 : 1;
 uint_t showdetail : 1;
 uint_t ctxactive : 1;
 uint_t reverse : 1;
 uint_t version : 1;
 uint_t reserved1 : 1;

 uint_t curctx : 3;
 uint_t prefersel : 1;
 uint_t fileinfo : 1;
 uint_t nonavopen : 1;
 uint_t autoselect : 1;
 uint_t reserved2 : 1;
 uint_t useeditor : 1;
 uint_t reserved3 : 3;
 uint_t regex : 1;
 uint_t x11 : 1;
 uint_t timetype : 2;
 uint_t cliopener : 1;
 uint_t waitedit : 1;
 uint_t rollover : 1;
} settings;


typedef struct {
 uint_t autofifo : 1;
 uint_t autonext : 1;
 uint_t dircolor : 1;
 uint_t dirctx : 1;
 uint_t duinit : 1;
 uint_t fifomode : 1;
 uint_t forcequit : 1;
 uint_t initfile : 1;
 uint_t interrupt : 1;
 uint_t move : 1;
 uint_t oldcolor : 1;
 uint_t picked : 1;
 uint_t picker : 1;
 uint_t pluginit : 1;
 uint_t prstssn : 1;
 uint_t rangesel : 1;
 uint_t runctx : 3;
 uint_t runplugin : 1;
 uint_t selmode : 1;
 uint_t stayonsel : 1;
 uint_t trash : 2;
 uint_t uidgid : 1;
 uint_t reserved : 7;
} runstate;


typedef struct {
 char c_path[
# 376 "project/nnn/src/nnn.c" 3 4
            1024
# 376 "project/nnn/src/nnn.c"
                    ];
 char c_last[
# 377 "project/nnn/src/nnn.c" 3 4
            1024
# 377 "project/nnn/src/nnn.c"
                    ];
 char c_name[
# 378 "project/nnn/src/nnn.c" 3 4
            255 
# 378 "project/nnn/src/nnn.c"
                     + 1];
 char c_fltr[48];
 settings c_cfg;
 uint_t color;
} context;


typedef struct {
 size_t ver;
 size_t pathln[4];
 size_t lastln[4];
 size_t nameln[4];
 size_t fltrln[4];
} session_header_t;





static settings cfg = {
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 1,
 0,
 0,
 0,
 0,
 0,
 0,
 0,
 1,
 0,
 0,
 0,
 0,
 0,
 2,
 0,
 0,
 1,
};

static context g_ctx[4] __attribute__ ((aligned));

static int ndents, cur, last, curscroll, last_curscroll, total_dents = 64, scroll_lines = 1;
static int nselected;

static int fifofd = -1;

static uint_t idletimeout, selbufpos, selbuflen;
static ushort_t xlines, xcols;
static ushort_t idle;
static uchar_t maxbm, maxplug, maxorder;
static uchar_t cfgsort[4 + 1];
static char *bmstr;
static char *pluginstr;
static char *orderstr;
static char *opener;
static char *editor;
static char *enveditor;
static char *pager;
static char *shell;
static char *home;
static char *initpath;
static char *cfgpath;
static char *selpath;
static char *listpath;
static char *listroot;
static char *plgpath;
static char *pnamebuf, *pselbuf, *findselpos;
static char *mark;

static char *hostname;


static char *fifopath;

static char *lastcmd;
static ullong_t *ihashbmp;
static struct entry *pdents;
static blkcnt_t dir_blocks;
static kv *bookmark;
static kv *plug;
static kv *order;
static uchar_t tmpfplen, homelen;
static uchar_t blk_shift = 9;

static int middle_click_key;




static regex_t archive_re;



#define NUM_DU_THREADS (4)
#define DU_TEST (((node->fts_info & FTS_F) && (sb->st_nlink <= 1 || test_set_bit((uint_t)sb->st_ino))) || node->fts_info & FTS_DP)


static int threadbmp = -1;
static volatile int active_threads;
static pthread_mutex_t running_mutex = 
# 487 "project/nnn/src/nnn.c" 3 4
                                      {0x32AAABA7, {0}}
# 487 "project/nnn/src/nnn.c"
                                                               ;
static pthread_mutex_t hardlink_mutex = 
# 488 "project/nnn/src/nnn.c" 3 4
                                       {0x32AAABA7, {0}}
# 488 "project/nnn/src/nnn.c"
                                                                ;
static ullong_t *core_files;
static blkcnt_t *core_blocks;
static ullong_t num_files;

typedef struct {
 char path[
# 494 "project/nnn/src/nnn.c" 3 4
          1024
# 494 "project/nnn/src/nnn.c"
                  ];
 int entnum;
 ushort_t core;
 
# 497 "project/nnn/src/nnn.c" 3 4
_Bool 
# 497 "project/nnn/src/nnn.c"
     mntpoint;
} thread_data;

static thread_data *core_data;


static struct sigaction oldsighup;
static struct sigaction oldsigtstp;
static struct sigaction oldsigwinch;


static char g_buf[(
# 508 "project/nnn/src/nnn.c" 3 4
                 1024 
# 508 "project/nnn/src/nnn.c"
                 + ((
# 508 "project/nnn/src/nnn.c" 3 4
                 255 
# 508 "project/nnn/src/nnn.c"
                 + 1) << 1))] __attribute__ ((aligned));


static char g_sel[
# 511 "project/nnn/src/nnn.c" 3 4
                 1024
# 511 "project/nnn/src/nnn.c"
                         ] __attribute__ ((aligned));


static char g_tmpfpath[64] __attribute__ ((aligned));


static char g_pipepath[64] __attribute__ ((aligned));


static runstate g_state;



#define FILE_MIME_OPTS "-bIL"





#define UTIL_OPENER 0
#define UTIL_ATOOL 1
#define UTIL_BSDTAR 2
#define UTIL_UNZIP 3
#define UTIL_TAR 4
#define UTIL_LOCKER 5
#define UTIL_LAUNCH 6
#define UTIL_SH_EXEC 7
#define UTIL_BASH 8
#define UTIL_SSHFS 9
#define UTIL_RCLONE 10
#define UTIL_VI 11
#define UTIL_LESS 12
#define UTIL_SH 13
#define UTIL_FZF 14
#define UTIL_NTFY 15
#define UTIL_CBCP 16
#define UTIL_NMV 17
#define UTIL_TRASH_CLI 18
#define UTIL_GIO_TRASH 19
#define UTIL_RM_RF 20


static char * const utils[] = {

 "/usr/bin/open",







 "atool",
 "bsdtar",
 "unzip",
 "tar",

 "bashlock",







 "launch",
 "sh -c",
 "bash",
 "sshfs",
 "rclone",
 "vi",
 "less",
 "sh",
 "fzf",
 ".ntfy",
 ".cbcp",
 ".nmv",
 "trash-put",
 "gio trash",
 "rm -rf",
};


#define MSG_ZERO 0
#define MSG_0_ENTRIES 1
#define STR_TMPFILE 2
#define MSG_0_SELECTED 3
#define MSG_CANCEL 4
#define MSG_FAILED 5
#define MSG_SSN_NAME 6
#define MSG_CP_MV_AS 7
#define MSG_CUR_SEL_OPTS 8
#define MSG_FORCE_RM 9
#define MSG_LIMIT 10
#define MSG_NEW_OPTS 11
#define MSG_CLI_MODE 12
#define MSG_OVERWRITE 13
#define MSG_SSN_OPTS 14
#define MSG_QUIT_ALL 15
#define MSG_HOSTNAME 16
#define MSG_ARCHIVE_NAME 17
#define MSG_OPEN_WITH 18
#define MSG_NEW_PATH 19
#define MSG_LINK_PREFIX 20
#define MSG_COPY_NAME 21
#define MSG_ENTER 22
#define MSG_SEL_MISSING 23
#define MSG_ACCESS 24
#define MSG_EMPTY_FILE 25
#define MSG_UNSUPPORTED 26
#define MSG_NOT_SET 27
#define MSG_EXISTS 28
#define MSG_FEW_COLUMNS 29
#define MSG_REMOTE_OPTS 30
#define MSG_RCLONE_DELAY 31
#define MSG_APP_NAME 32
#define MSG_ARCHIVE_OPTS 33
#define MSG_KEYS 34
#define MSG_INVALID_REG 35
#define MSG_ORDER 36
#define MSG_LAZY 37
#define MSG_FIRST 38
#define MSG_RM_TMP 39
#define MSG_INVALID_KEY 40
#define MSG_NOCHANGE 41
#define MSG_DIR_CHANGED 42

static const char * const messages[] = {
 "",
 "0 entries",
 "/.nnnXXXXXX",
 "0 selected",
 "cancelled",
 "failed!",
 "session name: ",
 "'c'p / 'm'v as?",
 "'c'urrent / 's'el?",
 "%s %s? [Esc cancels]",
 "limit exceeded",
 "'f'ile / 'd'ir / 's'ym / 'h'ard?",
 "'c'li / 'g'ui?",
 "overwrite?",
 "'s'ave / 'l'oad / 'r'estore?",
 "Quit all contexts?",
 "remote name (- for hovered): ",
 "archive [path/]name: ",
 "open with: ",
 "[path/]name: ",
 "link prefix [@ for none]: ",
 "copy [path/]name: ",
 "\n'Enter' to continue",
 "open failed",
 "dir inaccessible",
 "empty! edit/open with",
 "?",
 "not set",
 "entry exists",
 "too few cols!",
 "'s'shfs / 'r'clone?",
 "refresh if slow",
 "app name: ",
 "'o'pen / e'x'tract / 'l's / 'm'nt?",
 "keys:",
 "invalid regex",
 "'a'u / 'd'u / 'e'xt / 'r'ev / 's'z / 't'm / 'v'er / 'c'lr / '^T'?",
 "unmount failed! try lazy?",
 "first file (\')/char?",
 "remove tmp file?",
 "invalid key",
 "unchanged",
 "dir changed, range sel off",
};


#define NNN_OPTS 0
#define NNN_BMS 1
#define NNN_PLUG 2
#define NNN_OPENER 3
#define NNN_COLORS 4
#define NNN_FCOLORS 5
#define NNNLVL 6
#define NNN_PIPE 7
#define NNN_MCLICK 8
#define NNN_SEL 9
#define NNN_ARCHIVE 10
#define NNN_ORDER 11
#define NNN_HELP 12
#define NNN_TRASH 13

static const char * const env_cfg[] = {
 "NNN_OPTS",
 "NNN_BMS",
 "NNN_PLUG",
 "NNN_OPENER",
 "NNN_COLORS",
 "NNN_FCOLORS",
 "NNNLVL",
 "NNN_PIPE",
 "NNN_MCLICK",
 "NNN_SEL",
 "NNN_ARCHIVE",
 "NNN_ORDER",
 "NNN_HELP",
 "NNN_TRASH",
};


#define ENV_SHELL 0
#define ENV_VISUAL 1
#define ENV_EDITOR 2
#define ENV_PAGER 3
#define ENV_NCUR 4

static const char * const envs[] = {
 "SHELL",
 "VISUAL",
 "EDITOR",
 "PAGER",
 "nnn",
};


#define T_ACCESS 0
#define T_CHANGE 1
#define T_MOD 2





static char cp[] = "cp -iRp";
static char mv[] = "mv -i";



static const char * const archive_cmd[] = {"atool -a", "bsdtar -acvf", "zip -r", "tar -acvf"};


#define TOK_BM 0
#define TOK_SSN 1
#define TOK_MNT 2
#define TOK_PLG 3

static const char * const toks[] = {
 "bookmarks",
 "sessions",
 "mounts",
 "plugins",
};


#define P_CPMVFMT 0
#define P_CPMVRNM 1
#define P_ARCHIVE 2
#define P_REPLACE 3

static const char * const patterns[] = {
 "gsed"" -i 's|^\\(\\(.*/\\)\\(.*\\)$\\)|#\\1\\n\\3|' %s",
 "gsed"" 's|^\\([^#/][^/]\\?.*\\)$|%s/\\1|;s|^#\\(/.*\\)$|\\1|' "
  "%s | tr '\\n' '\\0' | xargs -0 -n2 sh -c '%s \"$0\" \"$@\" < /dev/tty'",
 "\\.(bz|bz2|gz|tar|taz|tbz|tbz2|tgz|z|zip)$",
 "gsed"" -i 's|^%s\\(.*\\)$|%s\\1|' %s",
};


#define C_BLK (CTX_MAX + 1)
#define C_CHR (C_BLK + 1)
#define C_DIR (C_CHR + 1)
#define C_EXE (C_DIR + 1)
#define C_FIL (C_EXE + 1)
#define C_HRD (C_FIL + 1)
#define C_LNK (C_HRD + 1)
#define C_MIS (C_LNK + 1)
#define C_ORP (C_MIS + 1)
#define C_PIP (C_ORP + 1)
#define C_SOC (C_PIP + 1)
#define C_UND (C_SOC + 1)






static char gcolors[] = "c1e2272e006033f7c6d6abc4";
static uint_t fcolors[((((((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1] = {0};
# 806 "project/nnn/src/nnn.c"
#define NUM_EVENT_SLOTS 1
#define NUM_EVENT_FDS 1
static int kq, event_fd = -1;
static struct kevent events_to_monitor[1];
static uint_t KQUEUE_FFLAGS = 
# 810 "project/nnn/src/nnn.c" 3 4
                             0x00000001 
# 810 "project/nnn/src/nnn.c"
                                         | 
# 810 "project/nnn/src/nnn.c" 3 4
                                           0x00000004 
# 810 "project/nnn/src/nnn.c"
                                                       | 
# 810 "project/nnn/src/nnn.c" 3 4
                                                         0x00000010
       
# 811 "project/nnn/src/nnn.c"
      | 
# 811 "project/nnn/src/nnn.c" 3 4
        0x00000020 
# 811 "project/nnn/src/nnn.c"
                    | 
# 811 "project/nnn/src/nnn.c" 3 4
                      0x00000040 
# 811 "project/nnn/src/nnn.c"
                                  | 
# 811 "project/nnn/src/nnn.c" 3 4
                                    0x00000002
# 811 "project/nnn/src/nnn.c"
                                              ;
static struct timespec gtimeout;






#define tolastln() move(xlines - 1, 0)
#define tocursor() move(cur + 2 - curscroll, 0)
#define exitcurses() endwin()
#define printwarn(presel) printwait(strerror(errno), presel)
#define istopdir(path) ((path)[1] == '\0' && (path)[0] == '/')
#define copycurname() xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", NAME_MAX + 1)
#define settimeout() timeout(1000)
#define cleartimeout() timeout(-1)
#define errexit() printerr(__LINE__)
#define setdirwatch() (cfg.filtermode ? (presel = FILTER) : (watch = TRUE))
#define filterset() (g_ctx[cfg.curctx].c_fltr[1])

#define xstrcmp(a,b) (*(a) != *(b) ? -1 : strcmp((a), (b)))

#define xisdigit(c) ((unsigned int) (c) - '0' <= 9)
#define xerror() perror(xitoa(__LINE__))






#define ENTSORT(pdents,ndents,entrycmpfn) qsort((pdents), (ndents), sizeof(*(pdents)), (entrycmpfn))



static void redraw(char *path);
static int spawn(char *file, char *arg1, char *arg2, char *arg3, ushort_t flag);
static void move_cursor(int target, int ignore_scrolloff);
static char *load_input(int fd, const char *path);
static int set_sort_flags(int r);
static void statusbar(char *path);
static 
# 851 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 851 "project/nnn/src/nnn.c"
           get_output(char *file, char *arg1, char *arg2, int fdout, 
# 851 "project/nnn/src/nnn.c" 3 4
                                                                     _Bool 
# 851 "project/nnn/src/nnn.c"
                                                                          multi, 
# 851 "project/nnn/src/nnn.c" 3 4
                                                                                 _Bool 
# 851 "project/nnn/src/nnn.c"
                                                                                      page);

static void notify_fifo(
# 853 "project/nnn/src/nnn.c" 3 4
                       _Bool 
# 853 "project/nnn/src/nnn.c"
                            force);




static void sigint_handler(int sig)
{
 (void) sig;
 g_state.interrupt = 1;
}

static void clean_exit_sighandler(int sig)
{
 (void) sig;
 endwin();

 exit(
# 869 "project/nnn/src/nnn.c" 3 4
     0
# 869 "project/nnn/src/nnn.c"
                 );
}

static char *xitoa(uint_t val)
{
 static char dst[32] = {'\0'};
 static const char digits[201] =
  "0001020304050607080910111213141516171819"
  "2021222324252627282930313233343536373839"
  "4041424344454647484950515253545556575859"
  "6061626364656667686970717273747576777879"
  "8081828384858687888990919293949596979899";
 uint_t next = 30, quo, i;

 while (val >= 100) {
  quo = val / 100;
  i = (val - (quo * 100)) * 2;
  val = quo;
  dst[next] = digits[i + 1];
  dst[--next] = digits[i];
  --next;
 }


 if (val < 10)
  dst[next] = '0' + val;
 else {
  i = val * 2;
  dst[next] = digits[i + 1];
  dst[--next] = digits[i];
 }

 return &dst[next];
}


static uchar_t xchartohex(uchar_t c)
{
 if (((unsigned int) (c) - '0' <= 9))
  return c - '0';

 if (c >= 'a' && c <= 'f')
  return c - 'a' + 10;

 if (c >= 'A' && c <= 'F')
  return c - 'A' + 10;

 return c;
}




static 
# 922 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 922 "project/nnn/src/nnn.c"
           test_set_bit(uint_t nr)
{
 nr &= (0xFFFFFF);

 pthread_mutex_lock(&hardlink_mutex);
 ullong_t *m = ((ullong_t *)ihashbmp) + (nr >> 6);

 if (*m & (1 << (nr & 63))) {
  pthread_mutex_unlock(&hardlink_mutex);
  return 
# 931 "project/nnn/src/nnn.c" 3 4
        0
# 931 "project/nnn/src/nnn.c"
             ;
 }

 *m |= 1 << (nr & 63);
 pthread_mutex_unlock(&hardlink_mutex);

 return 
# 937 "project/nnn/src/nnn.c" 3 4
       1
# 937 "project/nnn/src/nnn.c"
           ;
}
# 960 "project/nnn/src/nnn.c"
static void *xrealloc(void *pcur, size_t len)
{
 void *pmem = realloc(pcur, len);

 if (!pmem)
  free(pcur);

 return pmem;
}






static size_t xstrsncpy(char *restrict dst, const char *restrict src, size_t n)
{
 char *end = memccpy(dst, src, '\0', n);

 if (!end) {
  dst[n - 1] = '\0';
  end = dst + n;
 }

 return end - dst;
}

static inline size_t xstrlen(const char *restrict s)
{

 return strlen(s);



}

static char *xstrdup(const char *restrict s)
{
 size_t len = xstrlen(s) + 1;
 char *ptr = malloc(len);

 if (ptr)
  xstrsncpy(ptr, s, len);
 return ptr;
}

static 
# 1006 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 1006 "project/nnn/src/nnn.c"
           is_suffix(const char *restrict str, const char *restrict suffix)
{
 if (!str || !suffix)
  return 
# 1009 "project/nnn/src/nnn.c" 3 4
        0
# 1009 "project/nnn/src/nnn.c"
             ;

 size_t lenstr = xstrlen(str);
 size_t lensuffix = xstrlen(suffix);

 if (lensuffix > lenstr)
  return 
# 1015 "project/nnn/src/nnn.c" 3 4
        0
# 1015 "project/nnn/src/nnn.c"
             ;

 return ((*(str + (lenstr - lensuffix)) != *(suffix) ? -1 : strcmp((str + (lenstr - lensuffix)), (suffix))) == 0);
}

static inline 
# 1020 "project/nnn/src/nnn.c" 3 4
             _Bool 
# 1020 "project/nnn/src/nnn.c"
                  is_prefix(const char *restrict str, const char *restrict prefix, size_t len)
{
 return !strncmp(str, prefix, len);
}







static void *xmemrchr(uchar_t *restrict s, uchar_t ch, size_t n)
{




 if (!s || !n)
  return 
# 1038 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 1038 "project/nnn/src/nnn.c"
            ;

 uchar_t *ptr = s + n;

 do {
  if (*--ptr == ch)
   return ptr;
 } while (s != ptr);

 return 
# 1047 "project/nnn/src/nnn.c" 3 4
       ((void *)0)
# 1047 "project/nnn/src/nnn.c"
           ;

}


static char *xdirname(char *path)
{
 char *base = xmemrchr((uchar_t *)path, '/', xstrlen(path));

 if (base == path)
  path[1] = '\0';
 else
  *base = '\0';

 return path;
}

static char *xbasename(char *path)
{
 char *base = xmemrchr((uchar_t *)path, '/', xstrlen(path));

 return base ? base + 1 : path;
}

static inline char *xextension(const char *fname, size_t len)
{
 return xmemrchr((uchar_t *)fname, '.', len);
}







static char *getpwname(uid_t uid)
{
 static uint_t uidcache = 
# 1084 "project/nnn/src/nnn.c" 3 4
                         (0x7fffffff * 2U + 1U)
# 1084 "project/nnn/src/nnn.c"
                                 ;
 static char *namecache;

 if (uidcache != uid) {
  struct passwd *pw = getpwuid(uid);

  uidcache = uid;
  namecache = pw ? pw->pw_name : 
# 1091 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 1091 "project/nnn/src/nnn.c"
                                    ;
 }

 return namecache ? namecache : xitoa(uid);
}

static char *getgrname(gid_t gid)
{
 static uint_t gidcache = 
# 1099 "project/nnn/src/nnn.c" 3 4
                         (0x7fffffff * 2U + 1U)
# 1099 "project/nnn/src/nnn.c"
                                 ;
 static char *grpcache;

 if (gidcache != gid) {
  struct group *gr = getgrgid(gid);

  gidcache = gid;
  grpcache = gr ? gr->gr_name : 
# 1106 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 1106 "project/nnn/src/nnn.c"
                                   ;
 }

 return grpcache ? grpcache : xitoa(gid);
}


static inline 
# 1113 "project/nnn/src/nnn.c" 3 4
             _Bool 
# 1113 "project/nnn/src/nnn.c"
                  getutil(char *util)
{
 return spawn("which", util, 
# 1115 "project/nnn/src/nnn.c" 3 4
                            ((void *)0)
# 1115 "project/nnn/src/nnn.c"
                                , 
# 1115 "project/nnn/src/nnn.c" 3 4
                                  ((void *)0)
# 1115 "project/nnn/src/nnn.c"
                                      , 0x08 | 0x04) == 0;
}







static size_t mkpath(const char *dir, const char *name, char *out)
{
 size_t len = 0;

 if (name[0] != '/') {

  if (((dir)[1] == '\0' && (dir)[0] == '/'))
   len = 1;
  else
   len = xstrsncpy(out, dir, 
# 1133 "project/nnn/src/nnn.c" 3 4
                            1024
# 1133 "project/nnn/src/nnn.c"
                                    );

  out[len - 1] = '/';
 }
 return (xstrsncpy(out + len, name, 
# 1137 "project/nnn/src/nnn.c" 3 4
                                   1024 
# 1137 "project/nnn/src/nnn.c"
                                            - len) + len);
}


static char *common_prefix(const char *path, char *prefix)
{
 const char *x = path, *y = prefix;
 char *sep;

 if (!path || !*path || !prefix)
  return 
# 1147 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 1147 "project/nnn/src/nnn.c"
            ;

 if (!*prefix) {
  xstrsncpy(prefix, path, 
# 1150 "project/nnn/src/nnn.c" 3 4
                         1024
# 1150 "project/nnn/src/nnn.c"
                                 );
  return prefix;
 }

 while (*x && *y && (*x == *y))
  ++x, ++y;


 if (!*x && !*y)
  return prefix;


 if (!*x && *y == '/') {
  xstrsncpy(prefix, path, y - path);
  return prefix;
 }


 if (!*y && *x == '/')
  return prefix;


 prefix[y - prefix] = '\0';

 sep = xmemrchr((uchar_t *)prefix, '/', y - prefix);
 if (sep != prefix)
  *sep = '\0';
 else
  prefix[1] = '\0';

 return prefix;
}






static char *abspath(const char *path, const char *cwd, char *buf)
{
 if (!path)
  return 
# 1191 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 1191 "project/nnn/src/nnn.c"
            ;

 if (path[0] == '~')
  cwd = home;
 else if ((path[0] != '/') && !cwd)
  cwd = getcwd(
# 1196 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 1196 "project/nnn/src/nnn.c"
                  , 0);

 size_t dst_size = 0, src_size = xstrlen(path), cwd_size = cwd ? xstrlen(cwd) : 0;
 size_t len = src_size;
 const char *src;
 char *dst;





 char *resolved_path = buf ? buf : malloc(src_size + cwd_size + 2);

 if (!resolved_path)
  return 
# 1210 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 1210 "project/nnn/src/nnn.c"
            ;


 if (path[0] != '/') {
  if (!cwd) {
   if (!buf)
    free(resolved_path);
   return 
# 1217 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 1217 "project/nnn/src/nnn.c"
             ;
  }
  dst_size = xstrsncpy(resolved_path, cwd, cwd_size + 1) - 1;
 } else
  resolved_path[0] = '\0';

 src = path;
 dst = resolved_path + dst_size;
 for (const char *next = 
# 1225 "project/nnn/src/nnn.c" 3 4
                        ((void *)0)
# 1225 "project/nnn/src/nnn.c"
                            ; next != path + src_size;) {
  next = memchr(src, '/', len);
  if (!next)
   next = path + src_size;

  if (next - src == 2 && src[0] == '.' && src[1] == '.') {
   if (dst - resolved_path) {
    dst = xmemrchr((uchar_t *)resolved_path, '/', dst - resolved_path);
    *dst = '\0';
   }
  } else if (next - src == 1 && src[0] == '.') {

  } else if (next - src) {
   *(dst++) = '/';
   xstrsncpy(dst, src, next - src + 1);
   dst += next - src;
  }

  src = next + 1;
  len = src_size - (src - path);
 }

 if (*resolved_path == '\0') {
  resolved_path[0] = '/';
  resolved_path[1] = '\0';
 }

 return resolved_path;
}

static 
# 1255 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 1255 "project/nnn/src/nnn.c"
           set_tilde_in_path(char *path)
{
 if (is_prefix(path, home, homelen)) {
  home[homelen] = path[homelen - 1];
  path[homelen - 1] = '~';
  return 
# 1260 "project/nnn/src/nnn.c" 3 4
        1
# 1260 "project/nnn/src/nnn.c"
            ;
 }

 return 
# 1263 "project/nnn/src/nnn.c" 3 4
       0
# 1263 "project/nnn/src/nnn.c"
            ;
}

static void reset_tilde_in_path(char *path)
{
 path[homelen - 1] = home[homelen];
 home[homelen] = '\0';
}


static void xterm_cfg(char *path)
{
 if (cfg.x11 && !g_state.picker) {

  printf("\033]7;file://%s%s\033\\", hostname, path);


  
# 1280 "project/nnn/src/nnn.c" 3 4
 _Bool 
# 1280 "project/nnn/src/nnn.c"
      r = set_tilde_in_path(path);

  printf("\033]2;%s\007", r ? &path[homelen - 1] : path);
  fflush(
# 1283 "project/nnn/src/nnn.c" 3 4
        __stdoutp
# 1283 "project/nnn/src/nnn.c"
              );

  if (r)
   reset_tilde_in_path(path);
 }
}


static void convert_tilde(const char *path, char *buf)
{
 if (path[0] == '~') {
  ssize_t len = xstrlen(home);
  ssize_t loclen = xstrlen(path);

  xstrsncpy(buf, home, len + 1);
  xstrsncpy(buf + len, path + 1, loclen);
 }
}

static int create_tmp_file(void)
{
 xstrsncpy(g_tmpfpath + tmpfplen - 1, messages[2], 64 - tmpfplen);

 int fd = mkstemp(g_tmpfpath);

 if (fd == -1) {
  ;
 }

 return fd;
}

static void msg(const char *message)
{
 dprintf(
# 1317 "project/nnn/src/nnn.c" 3 4
        2
# 1317 "project/nnn/src/nnn.c"
                     , "%s\n", message);
}


static void handle_key_resize()
{
 endwin();
 
# 1324 "project/nnn/src/nnn.c" 3 4
wrefresh(stdscr)
# 1324 "project/nnn/src/nnn.c"
         ;
}


static void clearoldprompt(void)
{

 
# 1331 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 1331 "project/nnn/src/nnn.c"
xlines - 2
# 1331 "project/nnn/src/nnn.c" 3 4
,
# 1331 "project/nnn/src/nnn.c"
0
# 1331 "project/nnn/src/nnn.c" 3 4
)
# 1331 "project/nnn/src/nnn.c"
                   ;
 
# 1332 "project/nnn/src/nnn.c" 3 4
wclrtoeol(stdscr)
# 1332 "project/nnn/src/nnn.c"
          ;

 
# 1334 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 1334 "project/nnn/src/nnn.c"
xlines - 1
# 1334 "project/nnn/src/nnn.c" 3 4
,
# 1334 "project/nnn/src/nnn.c"
0
# 1334 "project/nnn/src/nnn.c" 3 4
)
# 1334 "project/nnn/src/nnn.c"
          ;
 
# 1335 "project/nnn/src/nnn.c" 3 4
wclrtoeol(stdscr)
# 1335 "project/nnn/src/nnn.c"
          ;
 handle_key_resize();
}



static inline void printmsg_nc(const char *msg)
{
 
# 1343 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 1343 "project/nnn/src/nnn.c"
xlines - 1
# 1343 "project/nnn/src/nnn.c" 3 4
,
# 1343 "project/nnn/src/nnn.c"
0
# 1343 "project/nnn/src/nnn.c" 3 4
)
# 1343 "project/nnn/src/nnn.c"
          ;
 
# 1344 "project/nnn/src/nnn.c" 3 4
waddnstr(stdscr,
# 1344 "project/nnn/src/nnn.c"
msg
# 1344 "project/nnn/src/nnn.c" 3 4
,-1)
# 1344 "project/nnn/src/nnn.c"
           ;
 
# 1345 "project/nnn/src/nnn.c" 3 4
wclrtoeol(stdscr)
# 1345 "project/nnn/src/nnn.c"
          ;
}

static void printmsg(const char *msg)
{
 
# 1350 "project/nnn/src/nnn.c" 3 4
wattr_on(stdscr, (attr_t)(((
# 1350 "project/nnn/src/nnn.c"
cfg.curctx + 1
# 1350 "project/nnn/src/nnn.c" 3 4
) << ((0) + 8))), ((void *)0))
# 1350 "project/nnn/src/nnn.c"
                                  ;
 printmsg_nc(msg);
 
# 1352 "project/nnn/src/nnn.c" 3 4
wattr_off(stdscr, (attr_t)(((
# 1352 "project/nnn/src/nnn.c"
cfg.curctx + 1
# 1352 "project/nnn/src/nnn.c" 3 4
) << ((0) + 8))), ((void *)0))
# 1352 "project/nnn/src/nnn.c"
                                   ;
}

static void printwait(const char *msg, int *presel)
{
 printmsg(msg);
 if (presel) {
  *presel = '$';
  if (ndents)
   xstrsncpy(g_ctx[cfg.curctx].c_name, pdents[cur].name, 
# 1361 "project/nnn/src/nnn.c" 3 4
                                                        255 
# 1361 "project/nnn/src/nnn.c"
                                                                 + 1);
 }
}


static void printerr(int linenum)
{
 endwin();
 perror(xitoa(linenum));
 if (!g_state.picker && selpath)
  unlink(selpath);
 free(pselbuf);
 exit(1);
}

static inline 
# 1376 "project/nnn/src/nnn.c" 3 4
             _Bool 
# 1376 "project/nnn/src/nnn.c"
                  xconfirm(int c)
{
 return (c == 'y' || c == 'Y');
}

static int get_input(const char *prompt)
{
 if (prompt)
  printmsg(prompt);
 
# 1385 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 1385 "project/nnn/src/nnn.c"
-1
# 1385 "project/nnn/src/nnn.c" 3 4
)
# 1385 "project/nnn/src/nnn.c"
              ;

 int r = 
# 1387 "project/nnn/src/nnn.c" 3 4
        wgetch(stdscr)
# 1387 "project/nnn/src/nnn.c"
               ;


 while (r == 
# 1390 "project/nnn/src/nnn.c" 3 4
            0632
# 1390 "project/nnn/src/nnn.c"
                      ) {
  if (prompt) {
   clearoldprompt();
   xlines = LINES;
   printmsg(prompt);
  }

  r = 
# 1397 "project/nnn/src/nnn.c" 3 4
     wgetch(stdscr)
# 1397 "project/nnn/src/nnn.c"
            ;
 }

 
# 1400 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 1400 "project/nnn/src/nnn.c"
1000
# 1400 "project/nnn/src/nnn.c" 3 4
)
# 1400 "project/nnn/src/nnn.c"
            ;
 return r;
}

static 
# 1404 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 1404 "project/nnn/src/nnn.c"
           isselfileempty(void)
{
 struct stat sb;

 return (stat(selpath, &sb) == -1) || (!sb.st_size);
}

static int get_cur_or_sel(void)
{
 
# 1413 "project/nnn/src/nnn.c" 3 4
_Bool 
# 1413 "project/nnn/src/nnn.c"
     sel = (selbufpos || !isselfileempty());


 if (sel && ndents) {



  if (cfg.prefersel && selbufpos)
   return 's';

  int choice = get_input(messages[8]);

  return ((choice == 'c' || choice == 's') ? choice : 0);
 }

 if (sel)
  return 's';

 if (ndents)
  return 'c';

 return 0;
}

static void xdelay(useconds_t delay)
{
 
# 1439 "project/nnn/src/nnn.c" 3 4
wrefresh(stdscr)
# 1439 "project/nnn/src/nnn.c"
         ;
 usleep(delay);
}

static char confirm_force(
# 1443 "project/nnn/src/nnn.c" 3 4
                         _Bool 
# 1443 "project/nnn/src/nnn.c"
                              selection)
{
 char str[64];

 
# 1447 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 1447 "project/nnn/src/nnn.c"
str
# 1447 "project/nnn/src/nnn.c" 3 4
, 
# 1447 "project/nnn/src/nnn.c"
64
# 1447 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 1447 "project/nnn/src/nnn.c"
str
# 1447 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 1447 "project/nnn/src/nnn.c"
messages[9], g_state.trash ? utils[19] + 4 : utils[20], (selection ? "selection" : "hovered")
# 1447 "project/nnn/src/nnn.c" 3 4
)

                                         
# 1449 "project/nnn/src/nnn.c"
                                        ;

 int r = get_input(str);

 if (r == (27))
  return '\0';
 if (r == 'y' || r == 'Y')
  return 'f';
 return (g_state.trash ? '\0' : 'i');
}


static void writesel(const char *buf, const size_t buflen)
{
 if (!selpath)
  return;

 int fd = open(selpath, 
# 1466 "project/nnn/src/nnn.c" 3 4
                       0x00000200 
# 1466 "project/nnn/src/nnn.c"
                               | 
# 1466 "project/nnn/src/nnn.c" 3 4
                                 0x0001 
# 1466 "project/nnn/src/nnn.c"
                                          | 
# 1466 "project/nnn/src/nnn.c" 3 4
                                            0x00000400
# 1466 "project/nnn/src/nnn.c"
                                                   , 0666);

 if (fd != -1) {
  if (write(fd, buf, buflen) != (ssize_t)buflen)
   printwait(strerror(
# 1470 "project/nnn/src/nnn.c" 3 4
  (*__error())
# 1470 "project/nnn/src/nnn.c"
  ), 
# 1470 "project/nnn/src/nnn.c" 3 4
  ((void *)0)
# 1470 "project/nnn/src/nnn.c"
  );
  close(fd);
 } else
  printwait(strerror(
# 1473 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 1473 "project/nnn/src/nnn.c"
 ), 
# 1473 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 1473 "project/nnn/src/nnn.c"
 );
}

static void appendfpath(const char *path, const size_t len)
{
 if ((selbufpos >= selbuflen) || ((len + 3) > (selbuflen - selbufpos))) {
  selbuflen += 
# 1479 "project/nnn/src/nnn.c" 3 4
              1024
# 1479 "project/nnn/src/nnn.c"
                      ;
  pselbuf = xrealloc(pselbuf, selbuflen);
  if (!pselbuf)
   printerr(1482);
 }

 selbufpos += xstrsncpy(pselbuf + selbufpos, path, len);
}

static void selbufrealloc(const size_t alloclen)
{
 if ((selbufpos + alloclen) > selbuflen) {
  selbuflen = ((((selbufpos + alloclen) + (
# 1491 "project/nnn/src/nnn.c" 3 4
             1024
# 1491 "project/nnn/src/nnn.c"
             ) - 1) / (
# 1491 "project/nnn/src/nnn.c" 3 4
             1024
# 1491 "project/nnn/src/nnn.c"
             )) * (
# 1491 "project/nnn/src/nnn.c" 3 4
             1024
# 1491 "project/nnn/src/nnn.c"
             ));
  pselbuf = xrealloc(pselbuf, selbuflen);
  if (!pselbuf)
   printerr(1494);
 }
}


static size_t seltofile(int fd, uint_t *pcount)
{
 uint_t lastpos, count = 0;
 char *pbuf = pselbuf;
 size_t pos = 0;
 ssize_t len, prefixlen = 0, initlen = 0;

 if (pcount)
  *pcount = 0;

 if (!selbufpos)
  return 0;

 lastpos = selbufpos - 1;

 if (listpath) {
  prefixlen = (ssize_t)xstrlen(listroot);
  initlen = (ssize_t)xstrlen(listpath);
 }

 while (pos <= lastpos) {
  ;
  len = (ssize_t)xstrlen(pbuf);

  if (!listpath || !is_prefix(pbuf, listpath, initlen)) {
   if (write(fd, pbuf, len) != len)
    return pos;
  } else {
   if (write(fd, listroot, prefixlen) != prefixlen)
    return pos;
   if (write(fd, pbuf + initlen, len - initlen) != (len - initlen))
    return pos;
  }

  pos += len;
  if (pos <= lastpos) {
   if (write(fd, "\n", 1) != 1)
    return pos;
   pbuf += len + 1;
  }
  ++pos;
  ++count;
 }

 if (pcount)
  *pcount = count;

 return pos;
}


static 
# 1550 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 1550 "project/nnn/src/nnn.c"
           listselfile(void)
{
 if (isselfileempty())
  return 
# 1553 "project/nnn/src/nnn.c" 3 4
        0
# 1553 "project/nnn/src/nnn.c"
             ;

 
# 1555 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 1555 "project/nnn/src/nnn.c"
g_buf
# 1555 "project/nnn/src/nnn.c" 3 4
, 
# 1555 "project/nnn/src/nnn.c"
(
# 1555 "project/nnn/src/nnn.c" 3 4
1024 
# 1555 "project/nnn/src/nnn.c"
+ ((
# 1555 "project/nnn/src/nnn.c" 3 4
255 
# 1555 "project/nnn/src/nnn.c"
+ 1) << 1))
# 1555 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 1555 "project/nnn/src/nnn.c"
g_buf
# 1555 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 1555 "project/nnn/src/nnn.c"
"tr \'\\0\' \'\\n\' < %s", selpath
# 1555 "project/nnn/src/nnn.c" 3 4
)
# 1555 "project/nnn/src/nnn.c"
                                                                ;
 spawn(utils[7], g_buf, 
# 1556 "project/nnn/src/nnn.c" 3 4
                                  ((void *)0)
# 1556 "project/nnn/src/nnn.c"
                                      , 
# 1556 "project/nnn/src/nnn.c" 3 4
                                        ((void *)0)
# 1556 "project/nnn/src/nnn.c"
                                            , (0x08 | 0x01) | 0x10);

 return 
# 1558 "project/nnn/src/nnn.c" 3 4
       1
# 1558 "project/nnn/src/nnn.c"
           ;
}


static void resetselind(void)
{
 for (int r = 0; r < ndents; ++r)
  if (pdents[r].flags & 0x10)
   pdents[r].flags &= ~0x10;
}

static void startselection(void)
{
 if (!g_state.selmode) {
  g_state.selmode = 1;
  nselected = 0;

  if (selbufpos) {
   resetselind();
   writesel(
# 1577 "project/nnn/src/nnn.c" 3 4
           ((void *)0)
# 1577 "project/nnn/src/nnn.c"
               , 0);
   selbufpos = 0;
  }
 }
}

static void clearselection(void)
{
 nselected = 0;
 selbufpos = 0;
 g_state.selmode = 0;
 writesel(
# 1588 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 1588 "project/nnn/src/nnn.c"
             , 0);
}

static char *findinsel(char *startpos, int len)
{
 if (!selbufpos)
  return 
# 1594 "project/nnn/src/nnn.c" 3 4
        0
# 1594 "project/nnn/src/nnn.c"
             ;

 if (!startpos)
  startpos = pselbuf;

 char *found = startpos;
 size_t buflen = selbufpos - (startpos - pselbuf);

 while (1) {

  found = memmem(found, buflen - (found - startpos), g_sel, len);
  if (!found)
   return 
# 1606 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 1606 "project/nnn/src/nnn.c"
             ;
  if (found == startpos || *(found - 1) == '\0')
   return found;
  found += len;
  if (found >= startpos + buflen)
   return 
# 1611 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 1611 "project/nnn/src/nnn.c"
             ;
 }
}

static int markcmp(const void *va, const void *vb)
{
 const selmark *ma = (selmark*)va;
 const selmark *mb = (selmark*)vb;

 return ma->startpos - mb->startpos;
}


static inline void findmarkentry(size_t len, struct entry *dentp)
{
 if (!(dentp->flags & 0x20)) {
  if (findinsel(findselpos, len + xstrsncpy(g_sel + len, dentp->name, dentp->nlen)))
   dentp->flags |= 0x10;
  dentp->flags |= 0x20;
 }
}





static void invertselbuf(const int pathlen)
{
 size_t len, endpos, shrinklen = 0, alloclen = 0;
 char * const pbuf = g_sel + pathlen;
 char *found;
 int i, nmarked = 0, prev = 0;
 struct entry *dentp;
 selmark *marked = malloc(nselected * sizeof(selmark));
 
# 1645 "project/nnn/src/nnn.c" 3 4
_Bool 
# 1645 "project/nnn/src/nnn.c"
     scan = 
# 1645 "project/nnn/src/nnn.c" 3 4
            0
# 1645 "project/nnn/src/nnn.c"
                 ;


 for (i = 0; i < ndents; ++i) {
  dentp = &pdents[i];

  if (dentp->flags & 0x20) {
   if (dentp->flags & 0x10) {
    dentp->flags ^= 0x10;
    scan = 
# 1654 "project/nnn/src/nnn.c" 3 4
          1
# 1654 "project/nnn/src/nnn.c"
              ;
   } else {
    dentp->flags |= 0x10;
    alloclen += pathlen + dentp->nlen;
   }
  } else {
   dentp->flags |= 0x20;
   scan = 
# 1661 "project/nnn/src/nnn.c" 3 4
         1
# 1661 "project/nnn/src/nnn.c"
             ;
  }

  if (scan) {
   len = pathlen + xstrsncpy(pbuf, dentp->name, 
# 1665 "project/nnn/src/nnn.c" 3 4
                                               255
# 1665 "project/nnn/src/nnn.c"
                                                       );
   found = findinsel(findselpos, len);
   if (found) {
    if (findselpos == found)
     findselpos += len;

    if (nmarked && (found
        == (marked[nmarked - 1].startpos + marked[nmarked - 1].len)))
     marked[nmarked - 1].len += len;
    else {
     marked[nmarked].startpos = found;
     marked[nmarked].len = len;
     ++nmarked;
    }

    --nselected;
    shrinklen += len;
   } else {
    dentp->flags |= 0x10;
    alloclen += pathlen + dentp->nlen;
   }
   scan = 
# 1686 "project/nnn/src/nnn.c" 3 4
         0
# 1686 "project/nnn/src/nnn.c"
              ;
  }
 }







 qsort(marked, nmarked, sizeof(selmark), &markcmp);


 for (i = 1; i < nmarked; ++i) {
  if (marked[i].startpos == marked[prev].startpos + marked[prev].len)
   marked[prev].len += marked[i].len;
  else {
   ++prev;
   marked[prev].startpos = marked[i].startpos;
   marked[prev].len = marked[i].len;
  }
 }






 if (nmarked)
  nmarked = prev + 1;


 for (i = 0; i < nmarked; ++i) {
# 1727 "project/nnn/src/nnn.c"
  found = marked[i].startpos;
  endpos = (i + 1 == nmarked ? selbufpos : marked[i + 1].startpos - pselbuf);
  len = marked[i].len;


  
# 1732 "project/nnn/src/nnn.c" 3 4
 __builtin___memmove_chk (
# 1732 "project/nnn/src/nnn.c"
 found
# 1732 "project/nnn/src/nnn.c" 3 4
 , 
# 1732 "project/nnn/src/nnn.c"
 found + len, endpos - (found + len - pselbuf)
# 1732 "project/nnn/src/nnn.c" 3 4
 , __builtin_object_size (
# 1732 "project/nnn/src/nnn.c"
 found
# 1732 "project/nnn/src/nnn.c" 3 4
 , 0))
# 1732 "project/nnn/src/nnn.c"
                                                              ;
 }

 free(marked);


 selbufpos -= shrinklen;

 selbufrealloc(alloclen);


 for (i = 0; i < ndents; ++i) {
  if (pdents[i].flags & 0x10) {
   len = pathlen + xstrsncpy(pbuf, pdents[i].name, 
# 1745 "project/nnn/src/nnn.c" 3 4
                                                  255
# 1745 "project/nnn/src/nnn.c"
                                                          );
   appendfpath(g_sel, len);
   ++nselected;
  }
 }

 nselected ? writesel(pselbuf, selbufpos - 1) : clearselection();
}





static void addtoselbuf(const int pathlen, int startid, int endid)
{
 int i;
 size_t len, alloclen = 0;
 struct entry *dentp;
 char *found;
 char * const pbuf = g_sel + pathlen;


 for (i = startid; i <= endid; ++i) {
  dentp = &pdents[i];

  if (findselpos) {
   len = pathlen + xstrsncpy(pbuf, dentp->name, 
# 1771 "project/nnn/src/nnn.c" 3 4
                                               255
# 1771 "project/nnn/src/nnn.c"
                                                       );
   found = findinsel(findselpos, len);
   if (found) {
    dentp->flags |= (0x20 | 0x10);
    if (found == findselpos) {
     findselpos += len;
     if (findselpos == (pselbuf + selbufpos))
      findselpos = 
# 1778 "project/nnn/src/nnn.c" 3 4
                  ((void *)0)
# 1778 "project/nnn/src/nnn.c"
                      ;
    }
   } else
    alloclen += pathlen + dentp->nlen;
  } else
   alloclen += pathlen + dentp->nlen;
 }

 selbufrealloc(alloclen);

 for (i = startid; i <= endid; ++i) {
  if (!(pdents[i].flags & 0x10)) {
   len = pathlen + xstrsncpy(pbuf, pdents[i].name, 
# 1790 "project/nnn/src/nnn.c" 3 4
                                                  255
# 1790 "project/nnn/src/nnn.c"
                                                          );
   appendfpath(g_sel, len);
   ++nselected;
   pdents[i].flags |= (0x20 | 0x10);
  }
 }

 writesel(pselbuf, selbufpos - 1);
}


static void rmfromselbuf(size_t len)
{
 char *found = findinsel(findselpos, len);
 if (!found)
  return;

 
# 1807 "project/nnn/src/nnn.c" 3 4
__builtin___memmove_chk (
# 1807 "project/nnn/src/nnn.c"
found
# 1807 "project/nnn/src/nnn.c" 3 4
, 
# 1807 "project/nnn/src/nnn.c"
found + len, selbufpos - (found + len - pselbuf)
# 1807 "project/nnn/src/nnn.c" 3 4
, __builtin_object_size (
# 1807 "project/nnn/src/nnn.c"
found
# 1807 "project/nnn/src/nnn.c" 3 4
, 0))
# 1807 "project/nnn/src/nnn.c"
                                                                ;
 selbufpos -= len;

 nselected ? writesel(pselbuf, selbufpos - 1) : clearselection();
}

static int scanselforpath(const char *path, 
# 1813 "project/nnn/src/nnn.c" 3 4
                                           _Bool 
# 1813 "project/nnn/src/nnn.c"
                                                getsize)
{
 if (!path[1]) {
  g_sel[0] = '/';
  findselpos = pselbuf;
  return 1;
 }

 size_t off = xstrsncpy(g_sel, path, 
# 1821 "project/nnn/src/nnn.c" 3 4
                                    1024
# 1821 "project/nnn/src/nnn.c"
                                            );

 g_sel[off - 1] = '/';




 findselpos = findinsel(
# 1828 "project/nnn/src/nnn.c" 3 4
                       ((void *)0)
# 1828 "project/nnn/src/nnn.c"
                           , off);

 if (getsize)
  return off;
 return (findselpos ? off : 0);
}


static void endselection(
# 1836 "project/nnn/src/nnn.c" 3 4
                        _Bool 
# 1836 "project/nnn/src/nnn.c"
                             endselmode)
{
 int fd;
 ssize_t count;
 char buf[sizeof(patterns[3]) + 
# 1840 "project/nnn/src/nnn.c" 3 4
                                       1024 
# 1840 "project/nnn/src/nnn.c"
                                                + (64 << 1)];

 if (endselmode && g_state.selmode)
  g_state.selmode = 0;


 if (!listpath || !selbufpos)
  return;

 fd = create_tmp_file();
 if (fd == -1) {
  ;
  return;
 }

 seltofile(fd, 
# 1855 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 1855 "project/nnn/src/nnn.c"
                  );
 if (close(fd)) {
  ;
  printwait(strerror(
# 1858 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 1858 "project/nnn/src/nnn.c"
 ), 
# 1858 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 1858 "project/nnn/src/nnn.c"
 );
  return;
 }

 
# 1862 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 1862 "project/nnn/src/nnn.c"
buf
# 1862 "project/nnn/src/nnn.c" 3 4
, 
# 1862 "project/nnn/src/nnn.c"
sizeof(buf)
# 1862 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 1862 "project/nnn/src/nnn.c"
buf
# 1862 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 1862 "project/nnn/src/nnn.c"
patterns[3], listpath, listroot, g_tmpfpath
# 1862 "project/nnn/src/nnn.c" 3 4
)
# 1862 "project/nnn/src/nnn.c"
                                                                               ;
 spawn(utils[7], buf, 
# 1863 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 1863 "project/nnn/src/nnn.c"
                                    , 
# 1863 "project/nnn/src/nnn.c" 3 4
                                      ((void *)0)
# 1863 "project/nnn/src/nnn.c"
                                          , (0x08 | 0x01));

 fd = open(g_tmpfpath, 
# 1865 "project/nnn/src/nnn.c" 3 4
                      0x0000
# 1865 "project/nnn/src/nnn.c"
                              );
 if (fd == -1) {
  ;
  printwait(strerror(
# 1868 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 1868 "project/nnn/src/nnn.c"
 ), 
# 1868 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 1868 "project/nnn/src/nnn.c"
 );
  if (unlink(g_tmpfpath)) {
   ;
   printwait(strerror(
# 1871 "project/nnn/src/nnn.c" 3 4
  (*__error())
# 1871 "project/nnn/src/nnn.c"
  ), 
# 1871 "project/nnn/src/nnn.c" 3 4
  ((void *)0)
# 1871 "project/nnn/src/nnn.c"
  );
  }
  return;
 }

 count = read(fd, pselbuf, selbuflen);
 if (count < 0) {
  ;
  printwait(strerror(
# 1879 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 1879 "project/nnn/src/nnn.c"
 ), 
# 1879 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 1879 "project/nnn/src/nnn.c"
 );
  if (close(fd) || unlink(g_tmpfpath)) {
   ;
  }
  return;
 }

 if (close(fd) || unlink(g_tmpfpath)) {
  ;
  printwait(strerror(
# 1888 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 1888 "project/nnn/src/nnn.c"
 ), 
# 1888 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 1888 "project/nnn/src/nnn.c"
 );
  return;
 }

 selbufpos = count;
 pselbuf[--count] = '\0';
 for (--count; count > 0; --count)
  if (pselbuf[count] == '\n' && pselbuf[count+1] == '/')
   pselbuf[count] = '\0';

 writesel(pselbuf, selbufpos - 1);
}


static int editselection(void)
{
 int ret = -1;
 int fd, lines = 0;
 ssize_t count;
 struct stat sb;
 time_t mtime;

 if (!selbufpos)
  return listselfile();

 fd = create_tmp_file();
 if (fd == -1) {
  ;
  return -1;
 }

 seltofile(fd, 
# 1919 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 1919 "project/nnn/src/nnn.c"
                  );
 if (close(fd)) {
  ;
  return -1;
 }


 if (stat(g_tmpfpath, &sb)) {
  ;
  unlink(g_tmpfpath);
  return -1;
 }
 mtime = sb.
# 1931 "project/nnn/src/nnn.c" 3 4
           st_mtimespec.tv_sec
# 1931 "project/nnn/src/nnn.c"
                   ;

 spawn((cfg.waitedit ? enveditor : editor), g_tmpfpath, 
# 1933 "project/nnn/src/nnn.c" 3 4
                                                       ((void *)0)
# 1933 "project/nnn/src/nnn.c"
                                                           , 
# 1933 "project/nnn/src/nnn.c" 3 4
                                                             ((void *)0)
# 1933 "project/nnn/src/nnn.c"
                                                                 , (0x08 | 0x01));

 fd = open(g_tmpfpath, 
# 1935 "project/nnn/src/nnn.c" 3 4
                      0x0000
# 1935 "project/nnn/src/nnn.c"
                              );
 if (fd == -1) {
  ;
  unlink(g_tmpfpath);
  return -1;
 }

 fstat(fd, &sb);

 if (mtime == sb.
# 1944 "project/nnn/src/nnn.c" 3 4
                st_mtimespec.tv_sec
# 1944 "project/nnn/src/nnn.c"
                        ) {
  ;
  unlink(g_tmpfpath);
  return 1;
 }

 if (sb.st_size > selbufpos) {
  ;
  unlink(g_tmpfpath);
  goto emptyedit;
 }

 count = read(fd, pselbuf, selbuflen);
 if (count < 0) {
  ;
  printwait(strerror(
# 1959 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 1959 "project/nnn/src/nnn.c"
 ), 
# 1959 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 1959 "project/nnn/src/nnn.c"
 );
  if (close(fd) || unlink(g_tmpfpath)) {
   ;
   printwait(strerror(
# 1962 "project/nnn/src/nnn.c" 3 4
  (*__error())
# 1962 "project/nnn/src/nnn.c"
  ), 
# 1962 "project/nnn/src/nnn.c" 3 4
  ((void *)0)
# 1962 "project/nnn/src/nnn.c"
  );
  }
  goto emptyedit;
 }

 if (close(fd) || unlink(g_tmpfpath)) {
  ;
  printwait(strerror(
# 1969 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 1969 "project/nnn/src/nnn.c"
 ), 
# 1969 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 1969 "project/nnn/src/nnn.c"
 );
  goto emptyedit;
 }

 if (!count) {
  ret = 1;
  goto emptyedit;
 }

 resetselind();
 selbufpos = count;

 pselbuf[--count] = '\0';
 for (--count; count > 0; --count) {

  if (pselbuf[count] == '\n' && pselbuf[count + 1] == '/') {
   ++lines;
   pselbuf[count] = '\0';
  }
 }


 ++lines;

 if (lines > nselected) {
  ;
  goto emptyedit;
 }

 nselected = lines;
 writesel(pselbuf, selbufpos - 1);

 return 1;

emptyedit:
 resetselind();
 clearselection();
 return ret;
}

static 
# 2009 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2009 "project/nnn/src/nnn.c"
           selsafe(void)
{

 if (!selpath) {
  printmsg(messages[23]);
  return 
# 2014 "project/nnn/src/nnn.c" 3 4
        0
# 2014 "project/nnn/src/nnn.c"
             ;
 }


 if (access(selpath, 
# 2018 "project/nnn/src/nnn.c" 3 4
                    (1<<2) 
# 2018 "project/nnn/src/nnn.c"
                         | 
# 2018 "project/nnn/src/nnn.c" 3 4
                           (1<<1)
# 2018 "project/nnn/src/nnn.c"
                               ) == -1) {
  
# 2019 "project/nnn/src/nnn.c" 3 4
 (*__error()) 
# 2019 "project/nnn/src/nnn.c"
       == 
# 2019 "project/nnn/src/nnn.c" 3 4
          2 
# 2019 "project/nnn/src/nnn.c"
                 ? printmsg(messages[3]) : printwait(strerror(
# 2019 "project/nnn/src/nnn.c" 3 4
                                                        (*__error())
# 2019 "project/nnn/src/nnn.c"
                                                        ), 
# 2019 "project/nnn/src/nnn.c" 3 4
                                                        ((void *)0)
# 2019 "project/nnn/src/nnn.c"
                                                        );
  return 
# 2020 "project/nnn/src/nnn.c" 3 4
        0
# 2020 "project/nnn/src/nnn.c"
             ;
 }

 return 
# 2023 "project/nnn/src/nnn.c" 3 4
       1
# 2023 "project/nnn/src/nnn.c"
           ;
}

static void export_file_list(void)
{
 if (!ndents)
  return;

 struct entry *pdent = pdents;
 int fd = create_tmp_file();

 if (fd == -1) {
  ;
  return;
 }

 for (int r = 0; r < ndents; ++pdent, ++r) {
  if (write(fd, pdent->name, pdent->nlen - 1) != (pdent->nlen - 1))
   break;

  if ((r != ndents - 1) && (write(fd, "\n", 1) != 1))
   break;
 }

 if (close(fd)) {
  ;
 }

 spawn(editor, g_tmpfpath, 
# 2051 "project/nnn/src/nnn.c" 3 4
                          ((void *)0)
# 2051 "project/nnn/src/nnn.c"
                              , 
# 2051 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 2051 "project/nnn/src/nnn.c"
                                    , (0x08 | 0x01));

 if (xconfirm(get_input(messages[39])))
  unlink(g_tmpfpath);
}

static 
# 2057 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2057 "project/nnn/src/nnn.c"
           init_fcolors(void)
{
 char *f_colors = getenv(env_cfg[5]);

 if (!f_colors || !*f_colors)
  f_colors = gcolors;

 for (uchar_t id = (4 + 1); *f_colors && id <= ((((((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1); ++id) {
  fcolors[id] = xchartohex(*f_colors) << 4;
  if (*++f_colors) {
   fcolors[id] += xchartohex(*f_colors);
   if (fcolors[id])
    init_pair(id, fcolors[id], -1);
  } else
   return 
# 2071 "project/nnn/src/nnn.c" 3 4
         0
# 2071 "project/nnn/src/nnn.c"
              ;
  ++f_colors;
 }

 return 
# 2075 "project/nnn/src/nnn.c" 3 4
       1
# 2075 "project/nnn/src/nnn.c"
           ;
}


static 
# 2079 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2079 "project/nnn/src/nnn.c"
           initcurses(void *oldmask)
{




 if (g_state.picker) {
  if (!newterm(
# 2086 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 2086 "project/nnn/src/nnn.c"
                  , 
# 2086 "project/nnn/src/nnn.c" 3 4
                    __stderrp
# 2086 "project/nnn/src/nnn.c"
                          , 
# 2086 "project/nnn/src/nnn.c" 3 4
                            __stdinp
# 2086 "project/nnn/src/nnn.c"
                                 )) {
   msg("newterm!");
   return 
# 2088 "project/nnn/src/nnn.c" 3 4
         0
# 2088 "project/nnn/src/nnn.c"
              ;
  }
 } else if (!initscr()) {
  msg("initscr!");
  ;
  return 
# 2093 "project/nnn/src/nnn.c" 3 4
        0
# 2093 "project/nnn/src/nnn.c"
             ;
 }

 cbreak();
 noecho();
 nonl();

 keypad(stdscr, 
# 2100 "project/nnn/src/nnn.c" 3 4
               1
# 2100 "project/nnn/src/nnn.c"
                   );


 mousemask(
# 2103 "project/nnn/src/nnn.c" 3 4
          ((002L) << (((1) - 1) * 6)) 
# 2103 "project/nnn/src/nnn.c"
                          | 
# 2103 "project/nnn/src/nnn.c" 3 4
                            ((010L) << (((1) - 1) * 6)) 
# 2103 "project/nnn/src/nnn.c"
                                                   | 
# 2103 "project/nnn/src/nnn.c" 3 4
                                                     ((002L) << (((2) - 1) * 6)) 
# 2103 "project/nnn/src/nnn.c"
                                                                     | 
# 2103 "project/nnn/src/nnn.c" 3 4
                                                                       ((002L) << (((3) - 1) * 6))
# 2103 "project/nnn/src/nnn.c"
                                                                                      ,
    (mmask_t *)oldmask);




 mouseinterval(0);

 curs_set(
# 2111 "project/nnn/src/nnn.c" 3 4
         0
# 2111 "project/nnn/src/nnn.c"
              );

 char *colors = getenv(env_cfg[4]);

 if (colors || !getenv("NO_COLOR")) {
  uint_t *pcode;
  
# 2117 "project/nnn/src/nnn.c" 3 4
 _Bool 
# 2117 "project/nnn/src/nnn.c"
      ext = 
# 2117 "project/nnn/src/nnn.c" 3 4
            0
# 2117 "project/nnn/src/nnn.c"
                 ;

  start_color();
  use_default_colors();


  if (COLORS >= 256) {
   if (!(g_state.oldcolor || init_fcolors())) {
    endwin();
    msg(env_cfg[5]);
    return 
# 2127 "project/nnn/src/nnn.c" 3 4
          0
# 2127 "project/nnn/src/nnn.c"
               ;
   }
  } else
   g_state.oldcolor = 1;

  ;
  ;

  if (colors && *colors == '#') {
   char *sep = strchr(colors, ';');

   if (!g_state.oldcolor && COLORS >= 256) {
    ++colors;
    ext = 
# 2140 "project/nnn/src/nnn.c" 3 4
         1
# 2140 "project/nnn/src/nnn.c"
             ;






    if (sep)
     *sep = '\0';
   } else {
    colors = sep;
    if (colors)
     ++colors;
   }
  }


  for (uchar_t i = 0; i < 4; ++i) {
   pcode = &g_ctx[i].color;

   if (colors && *colors) {
    if (ext) {
     *pcode = xchartohex(*colors) << 4;
     if (*++colors)
      fcolors[i + 1] = *pcode += xchartohex(*colors);
     else {
      endwin();
      msg(env_cfg[4]);
      return 
# 2168 "project/nnn/src/nnn.c" 3 4
            0
# 2168 "project/nnn/src/nnn.c"
                 ;
     }
    } else
     *pcode = (*colors < '0' || *colors > '7') ? 4 : *colors - '0';
    ++colors;
   } else
    *pcode = 4;

   init_pair(i + 1, *pcode, -1);
  }
 }
# 2206 "project/nnn/src/nnn.c"
 
# 2206 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 2206 "project/nnn/src/nnn.c"
1000
# 2206 "project/nnn/src/nnn.c" 3 4
)
# 2206 "project/nnn/src/nnn.c"
            ;
 set_escdelay(25);
 return 
# 2208 "project/nnn/src/nnn.c" 3 4
       1
# 2208 "project/nnn/src/nnn.c"
           ;
}


static char *parseargs(char *cmd, char **argv, int *pindex)
{
 int count = 0;
 size_t len = xstrlen(cmd) + 1;
 char *line = (char *)malloc(len);

 if (!line) {
  ;
  return 
# 2220 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 2220 "project/nnn/src/nnn.c"
            ;
 }

 xstrsncpy(line, cmd, len);
 argv[count++] = line;
 cmd = line;

 while (*line) {
  if (((*line) == ' ' || (*line) == '\t')) {
   *line++ = '\0';

   if (!*line)
    break;

   argv[count++] = line;
   if (count == 10) {
    count = -1;
    break;
   }
  }

  ++line;
 }

 if (count == -1 || count > (10 - 4)) {
  free(cmd);
  cmd = 
# 2246 "project/nnn/src/nnn.c" 3 4
       ((void *)0)
# 2246 "project/nnn/src/nnn.c"
           ;
  ;
 }

 *pindex = count;
 return cmd;
}

static void enable_signals(void)
{
 struct sigaction dfl_act = {.
# 2256 "project/nnn/src/nnn.c" 3 4
                             __sigaction_u.__sa_handler 
# 2256 "project/nnn/src/nnn.c"
                                        = 
# 2256 "project/nnn/src/nnn.c" 3 4
                                          (void (*)(int))0
# 2256 "project/nnn/src/nnn.c"
                                                 };

 sigaction(
# 2258 "project/nnn/src/nnn.c" 3 4
          1
# 2258 "project/nnn/src/nnn.c"
                , &dfl_act, 
# 2258 "project/nnn/src/nnn.c" 3 4
                            ((void *)0)
# 2258 "project/nnn/src/nnn.c"
                                );
 sigaction(
# 2259 "project/nnn/src/nnn.c" 3 4
          2
# 2259 "project/nnn/src/nnn.c"
                , &dfl_act, 
# 2259 "project/nnn/src/nnn.c" 3 4
                            ((void *)0)
# 2259 "project/nnn/src/nnn.c"
                                );
 sigaction(
# 2260 "project/nnn/src/nnn.c" 3 4
          3
# 2260 "project/nnn/src/nnn.c"
                 , &dfl_act, 
# 2260 "project/nnn/src/nnn.c" 3 4
                             ((void *)0)
# 2260 "project/nnn/src/nnn.c"
                                 );
 sigaction(
# 2261 "project/nnn/src/nnn.c" 3 4
          18
# 2261 "project/nnn/src/nnn.c"
                 , &dfl_act, 
# 2261 "project/nnn/src/nnn.c" 3 4
                             ((void *)0)
# 2261 "project/nnn/src/nnn.c"
                                 );
 sigaction(
# 2262 "project/nnn/src/nnn.c" 3 4
          28
# 2262 "project/nnn/src/nnn.c"
                  , &dfl_act, 
# 2262 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 2262 "project/nnn/src/nnn.c"
                                  );
}

static pid_t xfork(uchar_t flag)
{
 pid_t p = fork();

 if (p > 0) {

  sigaction(
# 2271 "project/nnn/src/nnn.c" 3 4
           1
# 2271 "project/nnn/src/nnn.c"
                 , &(struct sigaction){.
# 2271 "project/nnn/src/nnn.c" 3 4
                                        __sigaction_u.__sa_handler 
# 2271 "project/nnn/src/nnn.c"
                                                   = 
# 2271 "project/nnn/src/nnn.c" 3 4
                                                     (void (*)(int))1
# 2271 "project/nnn/src/nnn.c"
                                                            }, &oldsighup);
  sigaction(
# 2272 "project/nnn/src/nnn.c" 3 4
           18
# 2272 "project/nnn/src/nnn.c"
                  , &(struct sigaction){.
# 2272 "project/nnn/src/nnn.c" 3 4
                                         __sigaction_u.__sa_handler 
# 2272 "project/nnn/src/nnn.c"
                                                    = 
# 2272 "project/nnn/src/nnn.c" 3 4
                                                      (void (*)(int))0
# 2272 "project/nnn/src/nnn.c"
                                                             }, &oldsigtstp);
  sigaction(
# 2273 "project/nnn/src/nnn.c" 3 4
           28
# 2273 "project/nnn/src/nnn.c"
                   , &(struct sigaction){.
# 2273 "project/nnn/src/nnn.c" 3 4
                                          __sigaction_u.__sa_handler 
# 2273 "project/nnn/src/nnn.c"
                                                     = 
# 2273 "project/nnn/src/nnn.c" 3 4
                                                       (void (*)(int))1
# 2273 "project/nnn/src/nnn.c"
                                                              }, &oldsigwinch);
 } else if (p == 0) {

  if (flag & 0x02) {
   p = fork();

   if (p > 0)
    _exit(
# 2280 "project/nnn/src/nnn.c" 3 4
         0
# 2280 "project/nnn/src/nnn.c"
                     );
   else if (p == 0) {
    enable_signals();
    setsid();
    return p;
   }

   perror("fork");
   _exit(
# 2288 "project/nnn/src/nnn.c" 3 4
        1
# 2288 "project/nnn/src/nnn.c"
                    );
  }


  enable_signals();
 }


 if (flag & 0x02)
  waitpid(p, 
# 2297 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 2297 "project/nnn/src/nnn.c"
                , 0);

 if (p == -1)
  perror("fork");
 return p;
}

static int join(pid_t p, uchar_t flag)
{
 int status = 0xFFFF;

 if (!(flag & 0x02)) {

  do {
  } while (waitpid(p, &status, 0) == -1);

  if (
# 2313 "project/nnn/src/nnn.c" 3 4
     (((*(int *)&(
# 2313 "project/nnn/src/nnn.c"
     status
# 2313 "project/nnn/src/nnn.c" 3 4
     )) & 0177) == 0)
# 2313 "project/nnn/src/nnn.c"
                      ) {
   status = 
# 2314 "project/nnn/src/nnn.c" 3 4
           (((*(int *)&(
# 2314 "project/nnn/src/nnn.c"
           status
# 2314 "project/nnn/src/nnn.c" 3 4
           )) >> 8) & 0x000000ff)
# 2314 "project/nnn/src/nnn.c"
                              ;
   ;
  }
 }


 sigaction(
# 2320 "project/nnn/src/nnn.c" 3 4
          1
# 2320 "project/nnn/src/nnn.c"
                , &oldsighup, 
# 2320 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 2320 "project/nnn/src/nnn.c"
                                  );
 sigaction(
# 2321 "project/nnn/src/nnn.c" 3 4
          18
# 2321 "project/nnn/src/nnn.c"
                 , &oldsigtstp, 
# 2321 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 2321 "project/nnn/src/nnn.c"
                                    );
 sigaction(
# 2322 "project/nnn/src/nnn.c" 3 4
          28
# 2322 "project/nnn/src/nnn.c"
                  , &oldsigwinch, 
# 2322 "project/nnn/src/nnn.c" 3 4
                                  ((void *)0)
# 2322 "project/nnn/src/nnn.c"
                                      );

 return status;
}





static int spawn(char *file, char *arg1, char *arg2, char *arg3, ushort_t flag)
{
 pid_t pid;
 int status = 0, retstatus = 0xFFFF;
 char *argv[10] = {0};
 char *cmd = 
# 2336 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 2336 "project/nnn/src/nnn.c"
                ;

 if (!file || !*file)
  return retstatus;


 if (!arg1 && arg2) {
  arg1 = arg2;
  if (arg3) {
   arg2 = arg3;
   arg3 = 
# 2346 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 2346 "project/nnn/src/nnn.c"
             ;
  } else
   arg2 = 
# 2348 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 2348 "project/nnn/src/nnn.c"
             ;
 }

 if (flag & 0x01) {
  cmd = parseargs(file, argv, &status);
  if (!cmd)
   return -1;
 } else
  argv[status++] = file;

 argv[status] = arg1;
 argv[++status] = arg2;
 argv[++status] = arg3;

 if (flag & 0x08)
  endwin();

 pid = xfork(flag);
 if (pid == 0) {

  if (flag & 0x04) {
   int fd = open("/dev/null", 
# 2369 "project/nnn/src/nnn.c" 3 4
                             0x0001
# 2369 "project/nnn/src/nnn.c"
                                     , 0200);

   if (flag & 0x40)
    dup2(fd, 
# 2372 "project/nnn/src/nnn.c" 3 4
            0
# 2372 "project/nnn/src/nnn.c"
                        );
   dup2(fd, 
# 2373 "project/nnn/src/nnn.c" 3 4
           1
# 2373 "project/nnn/src/nnn.c"
                        );
   dup2(fd, 
# 2374 "project/nnn/src/nnn.c" 3 4
           2
# 2374 "project/nnn/src/nnn.c"
                        );
   close(fd);
  } else if (flag & 0x100) {

   if (!isatty(
# 2378 "project/nnn/src/nnn.c" 3 4
              1
# 2378 "project/nnn/src/nnn.c"
                           )) {
    int fd = open(ctermid(
# 2379 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 2379 "project/nnn/src/nnn.c"
                             ), 
# 2379 "project/nnn/src/nnn.c" 3 4
                                0x0001
# 2379 "project/nnn/src/nnn.c"
                                        , 0200);
    dup2(fd, 
# 2380 "project/nnn/src/nnn.c" 3 4
            1
# 2380 "project/nnn/src/nnn.c"
                         );
    close(fd);
   }
  }

  execvp(*argv, argv);
  _exit(
# 2386 "project/nnn/src/nnn.c" 3 4
       0
# 2386 "project/nnn/src/nnn.c"
                   );
 } else {
  retstatus = join(pid, flag);
  ;

  if ((flag & 0x10) || ((flag & 0x20) && retstatus)) {
   status = write(
# 2392 "project/nnn/src/nnn.c" 3 4
                 1
# 2392 "project/nnn/src/nnn.c"
                              , messages[22], xstrlen(messages[22]));
   (void)status;
   while ((read(
# 2394 "project/nnn/src/nnn.c" 3 4
               0
# 2394 "project/nnn/src/nnn.c"
                           , &status, 1) > 0) && (status != '\n'));
  }

  if (flag & 0x08)
   
# 2398 "project/nnn/src/nnn.c" 3 4
  wrefresh(stdscr)
# 2398 "project/nnn/src/nnn.c"
           ;

  free(cmd);
 }

 return retstatus;
}


static char *xgetenv(const char * const name, char *fallback)
{
 char *value = getenv(name);

 return value && value[0] ? value : fallback;
}


static inline uint_t xgetenv_val(const char *name)
{
 char *str = getenv(name);

 if (str && str[0])
  return atoi(str);

 return 0;
}


static 
# 2426 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2426 "project/nnn/src/nnn.c"
           xdiraccess(const char *path)
{
 DIR *dirp = opendir(path);

 if (!dirp) {
  printwait(strerror(
# 2431 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 2431 "project/nnn/src/nnn.c"
 ), 
# 2431 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 2431 "project/nnn/src/nnn.c"
 );
  return 
# 2432 "project/nnn/src/nnn.c" 3 4
        0
# 2432 "project/nnn/src/nnn.c"
             ;
 }

 closedir(dirp);
 return 
# 2436 "project/nnn/src/nnn.c" 3 4
       1
# 2436 "project/nnn/src/nnn.c"
           ;
}

static 
# 2439 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2439 "project/nnn/src/nnn.c"
           plugscript(const char *plugin, uchar_t flags)
{
 mkpath(plgpath, plugin, g_buf);
 if (!access(g_buf, 
# 2442 "project/nnn/src/nnn.c" 3 4
                   (1<<0)
# 2442 "project/nnn/src/nnn.c"
                       )) {
  spawn(g_buf, 
# 2443 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 2443 "project/nnn/src/nnn.c"
                  , 
# 2443 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 2443 "project/nnn/src/nnn.c"
                        , 
# 2443 "project/nnn/src/nnn.c" 3 4
                          ((void *)0)
# 2443 "project/nnn/src/nnn.c"
                              , flags);
  return 
# 2444 "project/nnn/src/nnn.c" 3 4
        1
# 2444 "project/nnn/src/nnn.c"
            ;
 }

 return 
# 2447 "project/nnn/src/nnn.c" 3 4
       0
# 2447 "project/nnn/src/nnn.c"
            ;
}

static void opstr(char *buf, char *op)
{
 
# 2452 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 2452 "project/nnn/src/nnn.c"
buf
# 2452 "project/nnn/src/nnn.c" 3 4
, 
# 2452 "project/nnn/src/nnn.c"
(
# 2452 "project/nnn/src/nnn.c" 3 4
1024 
# 2452 "project/nnn/src/nnn.c"
+ ((
# 2452 "project/nnn/src/nnn.c" 3 4
255 
# 2452 "project/nnn/src/nnn.c"
+ 1) << 1))
# 2452 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 2452 "project/nnn/src/nnn.c"
buf
# 2452 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 2452 "project/nnn/src/nnn.c"
"xargs -0 sh -c '%s \"$0\" \"$@\" . < /dev/tty' < %s", op, selpath
# 2452 "project/nnn/src/nnn.c" 3 4
)
               
# 2453 "project/nnn/src/nnn.c"
              ;
}

static 
# 2456 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2456 "project/nnn/src/nnn.c"
           rmmulstr(char *buf)
{
 char r = confirm_force(
# 2458 "project/nnn/src/nnn.c" 3 4
                       1
# 2458 "project/nnn/src/nnn.c"
                           );
 if (!r)
  return 
# 2460 "project/nnn/src/nnn.c" 3 4
        0
# 2460 "project/nnn/src/nnn.c"
             ;

 if (!g_state.trash)
  
# 2463 "project/nnn/src/nnn.c" 3 4
 __builtin___snprintf_chk (
# 2463 "project/nnn/src/nnn.c"
 buf
# 2463 "project/nnn/src/nnn.c" 3 4
 , 
# 2463 "project/nnn/src/nnn.c"
 (
# 2463 "project/nnn/src/nnn.c" 3 4
 1024 
# 2463 "project/nnn/src/nnn.c"
 + ((
# 2463 "project/nnn/src/nnn.c" 3 4
 255 
# 2463 "project/nnn/src/nnn.c"
 + 1) << 1))
# 2463 "project/nnn/src/nnn.c" 3 4
 , 0, __builtin_object_size (
# 2463 "project/nnn/src/nnn.c"
 buf
# 2463 "project/nnn/src/nnn.c" 3 4
 , 2 > 1 ? 1 : 0), 
# 2463 "project/nnn/src/nnn.c"
 "xargs -0 sh -c 'rm -%cr \"$0\" \"$@\" < /dev/tty' < %s", r, selpath
# 2463 "project/nnn/src/nnn.c" 3 4
 )
               
# 2464 "project/nnn/src/nnn.c"
              ;
 else
  
# 2466 "project/nnn/src/nnn.c" 3 4
 __builtin___snprintf_chk (
# 2466 "project/nnn/src/nnn.c"
 buf
# 2466 "project/nnn/src/nnn.c" 3 4
 , 
# 2466 "project/nnn/src/nnn.c"
 (
# 2466 "project/nnn/src/nnn.c" 3 4
 1024 
# 2466 "project/nnn/src/nnn.c"
 + ((
# 2466 "project/nnn/src/nnn.c" 3 4
 255 
# 2466 "project/nnn/src/nnn.c"
 + 1) << 1))
# 2466 "project/nnn/src/nnn.c" 3 4
 , 0, __builtin_object_size (
# 2466 "project/nnn/src/nnn.c"
 buf
# 2466 "project/nnn/src/nnn.c" 3 4
 , 2 > 1 ? 1 : 0), 
# 2466 "project/nnn/src/nnn.c"
 "xargs -0 %s < %s", utils[(g_state.trash == 1) ? 18 : 19], selpath
# 2466 "project/nnn/src/nnn.c" 3 4
 )
                                                                           
# 2467 "project/nnn/src/nnn.c"
                                                                          ;

 return 
# 2469 "project/nnn/src/nnn.c" 3 4
       1
# 2469 "project/nnn/src/nnn.c"
           ;
}


static 
# 2473 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2473 "project/nnn/src/nnn.c"
           xrm(char * const fpath)
{
 char r = confirm_force(
# 2475 "project/nnn/src/nnn.c" 3 4
                       0
# 2475 "project/nnn/src/nnn.c"
                            );
 if (!r)
  return 
# 2477 "project/nnn/src/nnn.c" 3 4
        0
# 2477 "project/nnn/src/nnn.c"
             ;

 if (!g_state.trash) {
  char rm_opts[] = "-ir";

  rm_opts[1] = r;
  spawn("rm", rm_opts, fpath, 
# 2483 "project/nnn/src/nnn.c" 3 4
                             ((void *)0)
# 2483 "project/nnn/src/nnn.c"
                                 , 0x08 | 0x20);
 } else
  spawn(utils[(g_state.trash == 1) ? 18 : 19],
        fpath, 
# 2486 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 2486 "project/nnn/src/nnn.c"
                  , 
# 2486 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 2486 "project/nnn/src/nnn.c"
                        , 0x08 | 0x01);

 return (access(fpath, 
# 2488 "project/nnn/src/nnn.c" 3 4
                      0
# 2488 "project/nnn/src/nnn.c"
                          ) == -1);
}

static void xrmfromsel(char *path, char *fpath)
{

 
# 2494 "project/nnn/src/nnn.c" 3 4
_Bool 
# 2494 "project/nnn/src/nnn.c"
     selected = 
# 2494 "project/nnn/src/nnn.c" 3 4
                1
# 2494 "project/nnn/src/nnn.c"
                    ;


 if ((pdents[cur].flags & 0x01) && scanselforpath(fpath, 
# 2497 "project/nnn/src/nnn.c" 3 4
                                                                 0
# 2497 "project/nnn/src/nnn.c"
                                                                      ))
  clearselection();
 else if (pdents[cur].flags & 0x10) {
  --nselected;
  rmfromselbuf(mkpath(path, pdents[cur].name, g_sel));
 }

 else
  selected = 
# 2505 "project/nnn/src/nnn.c" 3 4
            0
# 2505 "project/nnn/src/nnn.c"
                 ;

 if (selected && cfg.x11)
  plugscript(utils[16], 0x02 | 0x04);

}

static uint_t lines_in_file(int fd, char *buf, size_t buflen)
{
 ssize_t len;
 uint_t count = 0;

 while ((len = read(fd, buf, buflen)) > 0)
  while (len)
   count += (buf[--len] == '\n');


 return ((len < 0) ? 0 : count);
}

static 
# 2525 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2525 "project/nnn/src/nnn.c"
           cpmv_rename(int choice, const char *path)
{
 int fd;
 uint_t count = 0, lines = 0;
 
# 2529 "project/nnn/src/nnn.c" 3 4
_Bool 
# 2529 "project/nnn/src/nnn.c"
     ret = 
# 2529 "project/nnn/src/nnn.c" 3 4
           0
# 2529 "project/nnn/src/nnn.c"
                ;
 char *cmd = (choice == 'c' ? cp : mv);
 char buf[sizeof(patterns[1]) + sizeof(cmd) + (
# 2531 "project/nnn/src/nnn.c" 3 4
                                                      1024 
# 2531 "project/nnn/src/nnn.c"
                                                               << 1)];

 fd = create_tmp_file();
 if (fd == -1)
  return ret;


 if (!selbufpos) {
  
# 2539 "project/nnn/src/nnn.c" 3 4
 __builtin___snprintf_chk (
# 2539 "project/nnn/src/nnn.c"
 buf
# 2539 "project/nnn/src/nnn.c" 3 4
 , 
# 2539 "project/nnn/src/nnn.c"
 sizeof(buf)
# 2539 "project/nnn/src/nnn.c" 3 4
 , 0, __builtin_object_size (
# 2539 "project/nnn/src/nnn.c"
 buf
# 2539 "project/nnn/src/nnn.c" 3 4
 , 2 > 1 ? 1 : 0), 
# 2539 "project/nnn/src/nnn.c"
 "tr '\\0' '\\n' < %s > %s", selpath, g_tmpfpath
# 2539 "project/nnn/src/nnn.c" 3 4
 )
# 2539 "project/nnn/src/nnn.c"
                                                                            ;
  spawn(utils[7], buf, 
# 2540 "project/nnn/src/nnn.c" 3 4
                                 ((void *)0)
# 2540 "project/nnn/src/nnn.c"
                                     , 
# 2540 "project/nnn/src/nnn.c" 3 4
                                       ((void *)0)
# 2540 "project/nnn/src/nnn.c"
                                           , (0x08 | 0x01));

  count = lines_in_file(fd, buf, sizeof(buf));
  if (!count)
   goto finish;
 } else
  seltofile(fd, &count);

 close(fd);

 
# 2550 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 2550 "project/nnn/src/nnn.c"
buf
# 2550 "project/nnn/src/nnn.c" 3 4
, 
# 2550 "project/nnn/src/nnn.c"
sizeof(buf)
# 2550 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 2550 "project/nnn/src/nnn.c"
buf
# 2550 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 2550 "project/nnn/src/nnn.c"
patterns[0], g_tmpfpath
# 2550 "project/nnn/src/nnn.c" 3 4
)
# 2550 "project/nnn/src/nnn.c"
                                                           ;
 spawn(utils[7], buf, 
# 2551 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 2551 "project/nnn/src/nnn.c"
                                    , 
# 2551 "project/nnn/src/nnn.c" 3 4
                                      ((void *)0)
# 2551 "project/nnn/src/nnn.c"
                                          , (0x08 | 0x01));

 spawn((cfg.waitedit ? enveditor : editor), g_tmpfpath, 
# 2553 "project/nnn/src/nnn.c" 3 4
                                                       ((void *)0)
# 2553 "project/nnn/src/nnn.c"
                                                           , 
# 2553 "project/nnn/src/nnn.c" 3 4
                                                             ((void *)0)
# 2553 "project/nnn/src/nnn.c"
                                                                 , (0x08 | 0x01));

 fd = open(g_tmpfpath, 
# 2555 "project/nnn/src/nnn.c" 3 4
                      0x0000
# 2555 "project/nnn/src/nnn.c"
                              );
 if (fd == -1)
  goto finish;

 lines = lines_in_file(fd, buf, sizeof(buf));
 ;
 ;
 if (!lines || (2 * count != lines)) {
  ;
  goto finish;
 }

 
# 2567 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 2567 "project/nnn/src/nnn.c"
buf
# 2567 "project/nnn/src/nnn.c" 3 4
, 
# 2567 "project/nnn/src/nnn.c"
sizeof(buf)
# 2567 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 2567 "project/nnn/src/nnn.c"
buf
# 2567 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 2567 "project/nnn/src/nnn.c"
patterns[1], path, g_tmpfpath, cmd
# 2567 "project/nnn/src/nnn.c" 3 4
)
# 2567 "project/nnn/src/nnn.c"
                                                                      ;
 if (!spawn(utils[7], buf, 
# 2568 "project/nnn/src/nnn.c" 3 4
                                     ((void *)0)
# 2568 "project/nnn/src/nnn.c"
                                         , 
# 2568 "project/nnn/src/nnn.c" 3 4
                                           ((void *)0)
# 2568 "project/nnn/src/nnn.c"
                                               , (0x08 | 0x01) | 0x20))
  ret = 
# 2569 "project/nnn/src/nnn.c" 3 4
       1
# 2569 "project/nnn/src/nnn.c"
           ;
finish:
 if (fd >= 0)
  close(fd);

 return ret;
}

static 
# 2577 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2577 "project/nnn/src/nnn.c"
           cpmvrm_selection(enum action sel, char *path)
{
 int r;

 if (isselfileempty()) {
  if (nselected)
   clearselection();
  printmsg(messages[3]);
  return 
# 2585 "project/nnn/src/nnn.c" 3 4
        0
# 2585 "project/nnn/src/nnn.c"
             ;
 }

 if (!selsafe())
  return 
# 2589 "project/nnn/src/nnn.c" 3 4
        0
# 2589 "project/nnn/src/nnn.c"
             ;

 switch (sel) {
 case SEL_CP:
  opstr(g_buf, cp);
  break;
 case SEL_MV:
  opstr(g_buf, mv);
  break;
 case SEL_CPMVAS:
  r = get_input(messages[7]);
  if (r != 'c' && r != 'm') {
   printmsg(messages[40]);
   return 
# 2602 "project/nnn/src/nnn.c" 3 4
         0
# 2602 "project/nnn/src/nnn.c"
              ;
  }

  if (!cpmv_rename(r, path)) {
   printmsg(messages[5]);
   return 
# 2607 "project/nnn/src/nnn.c" 3 4
         0
# 2607 "project/nnn/src/nnn.c"
              ;
  }
  break;
 default:
  if (!rmmulstr(g_buf)) {
   printmsg(messages[4]);
   return 
# 2613 "project/nnn/src/nnn.c" 3 4
         0
# 2613 "project/nnn/src/nnn.c"
              ;
  }
 }

 if (sel != SEL_CPMVAS && spawn(utils[7], g_buf, 
# 2617 "project/nnn/src/nnn.c" 3 4
                                                           ((void *)0)
# 2617 "project/nnn/src/nnn.c"
                                                               , 
# 2617 "project/nnn/src/nnn.c" 3 4
                                                                 ((void *)0)
# 2617 "project/nnn/src/nnn.c"
                                                                     , (0x08 | 0x01) | 0x20)) {
  printmsg(messages[5]);
  return 
# 2619 "project/nnn/src/nnn.c" 3 4
        0
# 2619 "project/nnn/src/nnn.c"
             ;
 }


 clearselection();

 return 
# 2625 "project/nnn/src/nnn.c" 3 4
       1
# 2625 "project/nnn/src/nnn.c"
           ;
}


static 
# 2629 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 2629 "project/nnn/src/nnn.c"
           batch_rename(void)
{
 int fd1, fd2;
 uint_t count = 0, lines = 0;
 
# 2633 "project/nnn/src/nnn.c" 3 4
_Bool 
# 2633 "project/nnn/src/nnn.c"
     dir = 
# 2633 "project/nnn/src/nnn.c" 3 4
           0
# 2633 "project/nnn/src/nnn.c"
                , ret = 
# 2633 "project/nnn/src/nnn.c" 3 4
                        0
# 2633 "project/nnn/src/nnn.c"
                             ;
 char foriginal[64] = {0};
 static const char batchrenamecmd[] = "paste -d'\n' %s %s | ""gsed"" 'N; /^\\(.*\\)\\n\\1$/!p;d' | "
          "tr '\n' '\\0' | xargs -0 -n2 sh -c 'mv -i \"$0\" \"$@\" <"
          " /dev/tty'";
 char buf[sizeof(batchrenamecmd) + (
# 2638 "project/nnn/src/nnn.c" 3 4
                                   1024 
# 2638 "project/nnn/src/nnn.c"
                                            << 1)];
 int i = get_cur_or_sel();

 if (!i)
  return ret;

 if (i == 'c') {
  selbufpos = 0;
  dir = 
# 2646 "project/nnn/src/nnn.c" 3 4
       1
# 2646 "project/nnn/src/nnn.c"
           ;
 }

 fd1 = create_tmp_file();
 if (fd1 == -1)
  return ret;

 xstrsncpy(foriginal, g_tmpfpath, xstrlen(g_tmpfpath) + 1);

 fd2 = create_tmp_file();
 if (fd2 == -1) {
  unlink(foriginal);
  close(fd1);
  return ret;
 }

 if (dir)
  for (i = 0; i < ndents; ++i)
   appendfpath(pdents[i].name, 
# 2664 "project/nnn/src/nnn.c" 3 4
                              255
# 2664 "project/nnn/src/nnn.c"
                                      );

 seltofile(fd1, &count);
 seltofile(fd2, 
# 2667 "project/nnn/src/nnn.c" 3 4
               ((void *)0)
# 2667 "project/nnn/src/nnn.c"
                   );
 close(fd2);

 if (dir)
  selbufpos = 0;

 spawn((cfg.waitedit ? enveditor : editor), g_tmpfpath, 
# 2673 "project/nnn/src/nnn.c" 3 4
                                                       ((void *)0)
# 2673 "project/nnn/src/nnn.c"
                                                           , 
# 2673 "project/nnn/src/nnn.c" 3 4
                                                             ((void *)0)
# 2673 "project/nnn/src/nnn.c"
                                                                 , (0x08 | 0x01));


 fd2 = open(g_tmpfpath, 
# 2676 "project/nnn/src/nnn.c" 3 4
                       0x0000
# 2676 "project/nnn/src/nnn.c"
                               );
 if (fd2 == -1)
  goto finish;

 lines = lines_in_file(fd2, buf, sizeof(buf));
 ;
 ;
 if (!lines || (count != lines)) {
  ;
  goto finish;
 }

 
# 2688 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 2688 "project/nnn/src/nnn.c"
buf
# 2688 "project/nnn/src/nnn.c" 3 4
, 
# 2688 "project/nnn/src/nnn.c"
sizeof(buf)
# 2688 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 2688 "project/nnn/src/nnn.c"
buf
# 2688 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 2688 "project/nnn/src/nnn.c"
batchrenamecmd, foriginal, g_tmpfpath
# 2688 "project/nnn/src/nnn.c" 3 4
)
# 2688 "project/nnn/src/nnn.c"
                                                                 ;
 spawn(utils[7], buf, 
# 2689 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 2689 "project/nnn/src/nnn.c"
                                    , 
# 2689 "project/nnn/src/nnn.c" 3 4
                                      ((void *)0)
# 2689 "project/nnn/src/nnn.c"
                                          , (0x08 | 0x01));
 ret = 
# 2690 "project/nnn/src/nnn.c" 3 4
      1
# 2690 "project/nnn/src/nnn.c"
          ;

finish:
 if (fd1 >= 0)
  close(fd1);
 unlink(foriginal);

 if (fd2 >= 0)
  close(fd2);
 unlink(g_tmpfpath);

 return ret;
}


static void get_archive_cmd(char *cmd, const char *archive)
{
 uchar_t i = 3;

 if (getutil(utils[1]))
  i = 0;
 else if (getutil(utils[2]))
  i = 1;
 else if (is_suffix(archive, ".zip"))
  i = 2;


 xstrsncpy(cmd, archive_cmd[i], 16);
}

static void archive_selection(const char *cmd, const char *archive, const char *curpath)
{

 char *buf = (char *)malloc((70 + xstrlen(cmd) + xstrlen(archive)
           + xstrlen(curpath) + xstrlen(selpath)) * sizeof(char));
 if (!buf) {
  ;
  printwait(strerror(
# 2727 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 2727 "project/nnn/src/nnn.c"
 ), 
# 2727 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 2727 "project/nnn/src/nnn.c"
 );
  return;
 }

 
# 2731 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 2731 "project/nnn/src/nnn.c"
buf
# 2731 "project/nnn/src/nnn.c" 3 4
, 
# 2731 "project/nnn/src/nnn.c"
(
# 2731 "project/nnn/src/nnn.c" 3 4
1024 
# 2731 "project/nnn/src/nnn.c"
+ ((
# 2731 "project/nnn/src/nnn.c" 3 4
255 
# 2731 "project/nnn/src/nnn.c"
+ 1) << 1))
# 2731 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 2731 "project/nnn/src/nnn.c"
buf
# 2731 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 2731 "project/nnn/src/nnn.c"
"tr '\\0' '\n' < '%s' | ""gsed"" -e 's|^%s/||' | tr '\n' '\\0' | xargs -0 %s %s", selpath, curpath, cmd, archive
# 2731 "project/nnn/src/nnn.c" 3 4
)






   
# 2738 "project/nnn/src/nnn.c"
  ;
 spawn(utils[7], buf, 
# 2739 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 2739 "project/nnn/src/nnn.c"
                                    , 
# 2739 "project/nnn/src/nnn.c" 3 4
                                      ((void *)0)
# 2739 "project/nnn/src/nnn.c"
                                          , (0x08 | 0x01) | 0x10);
 free(buf);
}

static void write_lastdir(const char *curpath, const char *outfile)
{
 if (!outfile)
  xstrsncpy(cfgpath + xstrlen(cfgpath), "/.lastd", 8);
 else
  convert_tilde(outfile, g_buf);

 int fd = open(outfile
   ? (outfile[0] == '~' ? g_buf : outfile)
   : cfgpath, 
# 2752 "project/nnn/src/nnn.c" 3 4
             0x00000200 
# 2752 "project/nnn/src/nnn.c"
                     | 
# 2752 "project/nnn/src/nnn.c" 3 4
                       0x0001 
# 2752 "project/nnn/src/nnn.c"
                                | 
# 2752 "project/nnn/src/nnn.c" 3 4
                                  0x00000400
# 2752 "project/nnn/src/nnn.c"
                                         , 0666);

 if (fd != -1) {
  dprintf(fd, "cd \"%s\"", curpath);
  close(fd);
 }
}
# 2768 "project/nnn/src/nnn.c"
static int xstricmp(const char * const s1, const char * const s2)
{
 char *p1, *p2;

 long long v1 = strtoll(s1, &p1, 10);
 long long v2 = strtoll(s2, &p2, 10);


 if (s1 != p1 || s2 != p2) {

  if (s1 != p1 && s2 != p2) {
   if (v2 > v1)
    return -1;

   if (v1 > v2)
    return 1;
  }


  if (s1 == p1)
   return 1;


  if (s2 == p2)
   return -1;
 }



 return strcoll(s1, s2);



}
# 2818 "project/nnn/src/nnn.c"
static int xstrverscasecmp(const char * const s1, const char * const s2)
{
 const uchar_t *p1 = (const uchar_t *)s1;
 const uchar_t *p2 = (const uchar_t *)s2;
 int state, diff;
 uchar_t c1, c2;





 static const uint8_t next_state[] = {

             0x0, 0x3, 0x9,
             0x0, 0x3, 0x3,
             0x0, 0x6, 0x6,
             0x0, 0x6, 0x9
 };

 static const int8_t result_type[] __attribute__ ((aligned)) = {


             2, 2, 2, 2, 3, 2, 2, 2, 2,
             2, -1, -1, 1, 3, 3, 1, 3, 3,
             2, 2, 2, 2, 2, 2, 2, 2, 2,
             2, 1, 1, -1, 2, 2, -1, 2, 2
 };

 if (p1 == p2)
  return 0;

 c1 = (((*p1) >= 'a' && (*p1) <= 'z') ? ((*p1) - 'a' + 'A') : (*p1));
 ++p1;
 c2 = (((*p2) >= 'a' && (*p2) <= 'z') ? ((*p2) - 'a' + 'A') : (*p2));
 ++p2;


 state = 0x0 + ((c1 == '0') + (((unsigned int) (c1) - '0' <= 9) != 0));

 while ((diff = c1 - c2) == 0) {
  if (c1 == '\0')
   return diff;

  state = next_state[state];
  c1 = (((*p1) >= 'a' && (*p1) <= 'z') ? ((*p1) - 'a' + 'A') : (*p1));
  ++p1;
  c2 = (((*p2) >= 'a' && (*p2) <= 'z') ? ((*p2) - 'a' + 'A') : (*p2));
  ++p2;
  state += (c1 == '0') + (((unsigned int) (c1) - '0' <= 9) != 0);
 }

 state = result_type[state * 3 + (((c2 == '0') + (((unsigned int) (c2) - '0' <= 9) != 0)))];

 switch (state) {
 case 2:
  return diff;
 case 3:
  while (((unsigned int) (*p1++) - '0' <= 9))
   if (!((unsigned int) (*p2++) - '0' <= 9))
    return 1;
  return ((unsigned int) (*p2) - '0' <= 9) ? -1 : diff;
 default:
  return state;
 }
}

static int (*namecmpfn)(const char * const s1, const char * const s2) = &xstricmp;

static char * (*fnstrstr)(const char *haystack, const char *needle) = &strcasestr;




static int regflags = 
# 2891 "project/nnn/src/nnn.c" 3 4
                     0004 
# 2891 "project/nnn/src/nnn.c"
                               | 
# 2891 "project/nnn/src/nnn.c" 3 4
                                 0001 
# 2891 "project/nnn/src/nnn.c"
                                              | 
# 2891 "project/nnn/src/nnn.c" 3 4
                                                0002
# 2891 "project/nnn/src/nnn.c"
                                                         ;
# 2905 "project/nnn/src/nnn.c"
static int setfilter(regex_t *regex, const char *filter)
{
 return regcomp(regex, filter, regflags);
}


static int visible_re(const fltrexp_t *fltrexp, const char *fname)
{



 return regexec(fltrexp->regex, fname, 0, 
# 2916 "project/nnn/src/nnn.c" 3 4
                                         ((void *)0)
# 2916 "project/nnn/src/nnn.c"
                                             , 0) == 0;

}

static int visible_str(const fltrexp_t *fltrexp, const char *fname)
{
 return fnstrstr(fname, fltrexp->str) != 
# 2922 "project/nnn/src/nnn.c" 3 4
                                        ((void *)0)
# 2922 "project/nnn/src/nnn.c"
                                            ;
}

static int (*filterfn)(const fltrexp_t *fltr, const char *fname) = &visible_str;

static void clearfilter(void)
{
 char *fltr = g_ctx[cfg.curctx].c_fltr;

 if (fltr[1]) {
  fltr[48 - 1] = fltr[1];
  fltr[1] = '\0';
 }
}

static int entrycmp(const void *va, const void *vb)
{
 const struct entry *pa = (pEntry)va;
 const struct entry *pb = (pEntry)vb;

 if ((pb->flags & 0x01) != (pa->flags & 0x01)) {
  if (pb->flags & 0x01)
   return 1;
  return -1;
 }


 if (cfg.timeorder) {
  if (pb->sec > pa->sec)
   return 1;
  if (pb->sec < pa->sec)
   return -1;

  if (pb->nsec > pa->nsec)
   return 1;
  if (pb->nsec < pa->nsec)
   return -1;
 } else if (cfg.sizeorder) {
  if (pb->size > pa->size)
   return 1;
  if (pb->size < pa->size)
   return -1;
 } else if (cfg.blkorder) {
  if (pb->blocks > pa->blocks)
   return 1;
  if (pb->blocks < pa->blocks)
   return -1;
 } else if (cfg.extnorder && !(pb->flags & 0x01)) {
  char *extna = xextension(pa->name, pa->nlen - 1);
  char *extnb = xextension(pb->name, pb->nlen - 1);

  if (extna || extnb) {
   if (!extna)
    return -1;

   if (!extnb)
    return 1;

   int ret = strcasecmp(extna, extnb);

   if (ret)
    return ret;
  }
 }

 return namecmpfn(pa->name, pb->name);
}

static int reventrycmp(const void *va, const void *vb)
{
 if ((((pEntry)vb)->flags & 0x01)
     != (((pEntry)va)->flags & 0x01)) {
  if (((pEntry)vb)->flags & 0x01)
   return 1;
  return -1;
 }

 return -entrycmp(va, vb);
}

static int (*entrycmpfn)(const void *va, const void *vb) = &entrycmp;


static int handle_alt_key(wint_t *wch)
{
 
# 3007 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 3007 "project/nnn/src/nnn.c"
0
# 3007 "project/nnn/src/nnn.c" 3 4
)
# 3007 "project/nnn/src/nnn.c"
          ;

 int r = 
# 3009 "project/nnn/src/nnn.c" 3 4
        wget_wch(stdscr,
# 3009 "project/nnn/src/nnn.c"
        wch
# 3009 "project/nnn/src/nnn.c" 3 4
        )
# 3009 "project/nnn/src/nnn.c"
                    ;

 if (r == 
# 3011 "project/nnn/src/nnn.c" 3 4
         (-1)
# 3011 "project/nnn/src/nnn.c"
            )
  *wch = (27);
 
# 3013 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 3013 "project/nnn/src/nnn.c"
-1
# 3013 "project/nnn/src/nnn.c" 3 4
)
# 3013 "project/nnn/src/nnn.c"
              ;

 return r;
}

static inline int handle_event(void)
{
 if (nselected && isselfileempty())
  clearselection();
 return (('L') & 0x1f);
}






static int nextsel(int presel)
{



 int c = presel;
 uint_t i;
 
# 3037 "project/nnn/src/nnn.c" 3 4
_Bool 
# 3037 "project/nnn/src/nnn.c"
     escaped = 
# 3037 "project/nnn/src/nnn.c" 3 4
               0
# 3037 "project/nnn/src/nnn.c"
                    ;

 if (c == 0 || c == '$') {
try_quit:
  c = 
# 3041 "project/nnn/src/nnn.c" 3 4
     wgetch(stdscr)
# 3041 "project/nnn/src/nnn.c"
            ;




  if (c == 
# 3046 "project/nnn/src/nnn.c" 3 4
          0632
# 3046 "project/nnn/src/nnn.c"
                    )
   handle_key_resize();



  if (c == (27)) {
   
# 3052 "project/nnn/src/nnn.c" 3 4
  wtimeout(stdscr,
# 3052 "project/nnn/src/nnn.c"
  0
# 3052 "project/nnn/src/nnn.c" 3 4
  )
# 3052 "project/nnn/src/nnn.c"
            ;
   c = 
# 3053 "project/nnn/src/nnn.c" 3 4
      wgetch(stdscr)
# 3053 "project/nnn/src/nnn.c"
             ;
   if (c != 
# 3054 "project/nnn/src/nnn.c" 3 4
           (-1)
# 3054 "project/nnn/src/nnn.c"
              ) {
    if (c == (27))
     c = (('L') & 0x1f);
    else {
     ungetch(c);
     c = ';';
    }
    
# 3061 "project/nnn/src/nnn.c" 3 4
   wtimeout(stdscr,
# 3061 "project/nnn/src/nnn.c"
   1000
# 3061 "project/nnn/src/nnn.c" 3 4
   )
# 3061 "project/nnn/src/nnn.c"
               ;
   } else if (escaped) {
    
# 3063 "project/nnn/src/nnn.c" 3 4
   wtimeout(stdscr,
# 3063 "project/nnn/src/nnn.c"
   1000
# 3063 "project/nnn/src/nnn.c" 3 4
   )
# 3063 "project/nnn/src/nnn.c"
               ;
    c = (('Q') & 0x1f);
   } else {

    if (!g_state.fifomode)
     notify_fifo(
# 3068 "project/nnn/src/nnn.c" 3 4
                1
# 3068 "project/nnn/src/nnn.c"
                    );

    escaped = 
# 3070 "project/nnn/src/nnn.c" 3 4
             1
# 3070 "project/nnn/src/nnn.c"
                 ;
    
# 3071 "project/nnn/src/nnn.c" 3 4
   wtimeout(stdscr,
# 3071 "project/nnn/src/nnn.c"
   1000
# 3071 "project/nnn/src/nnn.c" 3 4
   )
# 3071 "project/nnn/src/nnn.c"
               ;
    goto try_quit;
   }
  }

  if (c == 
# 3076 "project/nnn/src/nnn.c" 3 4
          (-1) 
# 3076 "project/nnn/src/nnn.c"
              && presel == '$')
   c = (cfg.filtermode || (g_ctx[cfg.curctx].c_fltr[1])) ? '/' : (('L') & 0x1f);
  else if (c == '/' || c == (('L') & 0x1f))

   clearfilter();
 }

 if (c == -1) {
  ++idle;
# 3117 "project/nnn/src/nnn.c"
  if (!cfg.blkorder && event_fd >= 0 && (idle & 1)) {
   struct kevent event_data[1];

   
# 3120 "project/nnn/src/nnn.c" 3 4
  __builtin___memset_chk (
# 3120 "project/nnn/src/nnn.c"
  (void *)event_data
# 3120 "project/nnn/src/nnn.c" 3 4
  , 
# 3120 "project/nnn/src/nnn.c"
  0x0, sizeof(struct kevent) * 1
# 3120 "project/nnn/src/nnn.c" 3 4
  , __builtin_object_size (
# 3120 "project/nnn/src/nnn.c"
  (void *)event_data
# 3120 "project/nnn/src/nnn.c" 3 4
  , 0))
# 3120 "project/nnn/src/nnn.c"
                                                                          ;
   if (kevent(kq, events_to_monitor, 1,
       event_data, 1, &gtimeout) > 0)
    c = handle_event();
  }




 } else
  idle = 0;

 for (i = 0; i < (int)(sizeof(bindings) / sizeof(*(bindings))); ++i)
  if (c == bindings[i].sym)
   return bindings[i].act;

 return 0;
}

static int getorderstr(char *sort)
{
 int i = 0;

 if (cfg.showhidden)
  sort[i++] = 'H';

 if (cfg.timeorder)
  sort[i++] = (cfg.timetype == 2) ? 'M' : ((cfg.timetype == 0) ? 'A' : 'C');
 else if (cfg.sizeorder)
  sort[i++] = 'S';
 else if (cfg.extnorder)
  sort[i++] = 'E';

 if (entrycmpfn == &reventrycmp)
  sort[i++] = 'R';

 if (namecmpfn == &xstrverscasecmp)
  sort[i++] = 'V';

 if (i)
  sort[i] = ' ';

 return i;
}

static void showfilterinfo(void)
{
 int i = 0;
 char info[48] = "\0\0\0\0\0";

 i = getorderstr(info);

 
# 3172 "project/nnn/src/nnn.c" 3 4
__builtin___snprintf_chk (
# 3172 "project/nnn/src/nnn.c"
info + i
# 3172 "project/nnn/src/nnn.c" 3 4
, 
# 3172 "project/nnn/src/nnn.c"
48 - i - 1
# 3172 "project/nnn/src/nnn.c" 3 4
, 0, __builtin_object_size (
# 3172 "project/nnn/src/nnn.c"
info + i
# 3172 "project/nnn/src/nnn.c" 3 4
, 2 > 1 ? 1 : 0), 
# 3172 "project/nnn/src/nnn.c"
"  %s [/], %s [:]", (cfg.regex ? "reg" : "str"), ((fnstrstr == &strcasestr) ? "ic" : "noic")
# 3172 "project/nnn/src/nnn.c" 3 4
)

                                               
# 3174 "project/nnn/src/nnn.c"
                                              ;

 if (cfg.fileinfo && ndents && get_output("file", "-b", pdents[cur].name, -1, 
# 3176 "project/nnn/src/nnn.c" 3 4
                                                                             0
# 3176 "project/nnn/src/nnn.c"
                                                                                  , 
# 3176 "project/nnn/src/nnn.c" 3 4
                                                                                    0
# 3176 "project/nnn/src/nnn.c"
                                                                                         ))
  
# 3177 "project/nnn/src/nnn.c" 3 4
 (wmove(stdscr,
# 3177 "project/nnn/src/nnn.c"
 xlines - 2
# 3177 "project/nnn/src/nnn.c" 3 4
 ,
# 3177 "project/nnn/src/nnn.c"
 2
# 3177 "project/nnn/src/nnn.c" 3 4
 ) == (-1) ? (-1) : waddnstr(stdscr,
# 3177 "project/nnn/src/nnn.c"
 g_buf
# 3177 "project/nnn/src/nnn.c" 3 4
 ,-1))
# 3177 "project/nnn/src/nnn.c"
                               ;

 
# 3179 "project/nnn/src/nnn.c" 3 4
(wmove(stdscr,
# 3179 "project/nnn/src/nnn.c"
xlines - 2
# 3179 "project/nnn/src/nnn.c" 3 4
,
# 3179 "project/nnn/src/nnn.c"
xcols - xstrlen(info)
# 3179 "project/nnn/src/nnn.c" 3 4
) == (-1) ? (-1) : waddnstr(stdscr,
# 3179 "project/nnn/src/nnn.c"
info
# 3179 "project/nnn/src/nnn.c" 3 4
,-1))
# 3179 "project/nnn/src/nnn.c"
                                                 ;
}

static void showfilter(char *str)
{
 
# 3184 "project/nnn/src/nnn.c" 3 4
wattr_on(stdscr, (attr_t)(((
# 3184 "project/nnn/src/nnn.c"
cfg.curctx + 1
# 3184 "project/nnn/src/nnn.c" 3 4
) << ((0) + 8))), ((void *)0))
# 3184 "project/nnn/src/nnn.c"
                                  ;
 showfilterinfo();
 printmsg(str);

}

static inline void swap_ent(int id1, int id2)
{
 struct entry _dent, *pdent1 = &pdents[id1], *pdent2 = &pdents[id2];

 *(&_dent) = *pdent1;
 *pdent1 = *pdent2;
 *pdent2 = *(&_dent);
}




static int fill(const char *fltr, regex_t *re)

{



 fltrexp_t fltrexp = { .regex = re, .str = fltr };


 for (int count = 0; count < ndents; ++count) {
  if (filterfn(&fltrexp, pdents[count].name) == 0) {
   if (count != --ndents) {
    swap_ent(count, ndents);
    --count;
   }

   continue;
  }
 }

 return ndents;
}

static int matches(const char *fltr)
{
# 3239 "project/nnn/src/nnn.c"
 regex_t re;


 if (cfg.regex && setfilter(&re, fltr))
  return -1;

 ndents = fill(fltr, &re);

 if (cfg.regex)
  regfree(&re);


 qsort((pdents), (ndents), sizeof(*(pdents)), (entrycmpfn));

 return ndents;
}





static int dentfind(const char *fname, int n)
{
 for (int i = 0; i < n; ++i)
  if ((*(fname) != *(pdents[i].name) ? -1 : strcmp((fname), (pdents[i].name))) == 0)
   return i;

 return 0;
}

static int filterentries(char *path, char *lastname)
{
 wchar_t *wln = (wchar_t *)
# 3271 "project/nnn/src/nnn.c" 3 4
                          __builtin_alloca(
# 3271 "project/nnn/src/nnn.c"
                          sizeof(wchar_t) * 48
# 3271 "project/nnn/src/nnn.c" 3 4
                          )
# 3271 "project/nnn/src/nnn.c"
                                                             ;
 char *ln = g_ctx[cfg.curctx].c_fltr;
 wint_t ch[2] = {0};
 int r, total = ndents, len;
 char *pln = g_ctx[cfg.curctx].c_fltr + 1;

 ;

 if (ndents && (ln[0] == '/' || ln[0] == '\\') && *pln) {
  if (matches(pln) != -1) {
   move_cursor(dentfind(lastname, ndents), 0);
   redraw(path);
  }

  if (!cfg.filtermode) {
   statusbar(path);
   return 0;
  }

  len = mbstowcs(wln, ln, 48);
 } else {
  ln[0] = wln[0] = cfg.regex ? '\\' : '/';
  ln[1] = wln[1] = '\0';
  len = 1;
 }

 
# 3297 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 3297 "project/nnn/src/nnn.c"
-1
# 3297 "project/nnn/src/nnn.c" 3 4
)
# 3297 "project/nnn/src/nnn.c"
              ;
 curs_set(
# 3298 "project/nnn/src/nnn.c" 3 4
         1
# 3298 "project/nnn/src/nnn.c"
             );
 showfilter(ln);

 while ((r = 
# 3301 "project/nnn/src/nnn.c" 3 4
            wget_wch(stdscr,
# 3301 "project/nnn/src/nnn.c"
            ch
# 3301 "project/nnn/src/nnn.c" 3 4
            )
# 3301 "project/nnn/src/nnn.c"
                       ) != 
# 3301 "project/nnn/src/nnn.c" 3 4
                            (-1)
# 3301 "project/nnn/src/nnn.c"
                               ) {



  switch (*ch) {

  case 0:
  case 
# 3308 "project/nnn/src/nnn.c" 3 4
      0632
# 3308 "project/nnn/src/nnn.c"
                :
   clearoldprompt();
   redraw(path);
   showfilter(ln);
   continue;

  case 
# 3314 "project/nnn/src/nnn.c" 3 4
      0512
# 3314 "project/nnn/src/nnn.c"
            :
  case 
# 3315 "project/nnn/src/nnn.c" 3 4
      0407
# 3315 "project/nnn/src/nnn.c"
                   :
  case '\b':
  case (127):
   if (len != 1) {
    wln[--len] = '\0';
    wcstombs(ln, wln, 48);
    ndents = total;
   } else {
    *ch = '/';
    goto end;
   }

  case (('L') & 0x1f):
   if (*ch == (('L') & 0x1f)) {
    if (wln[1]) {
     ln[48 - 1] = ln[1];
     ln[1] = wln[1] = '\0';
     len = 1;
     ndents = total;
    } else if (ln[48 - 1]) {
     ln[1] = ln[48 - 1];
     ln[48 - 1] = '\0';
     len = mbstowcs(wln, ln, 48);
    } else
     goto end;
   }


   cur = 0;

   if (matches(pln) != -1)
    redraw(path);

   showfilter(ln);
   continue;

  case 
# 3351 "project/nnn/src/nnn.c" 3 4
      0631
# 3351 "project/nnn/src/nnn.c"
               :
   goto end;

  case (27):
   if (handle_alt_key(ch) != 
# 3355 "project/nnn/src/nnn.c" 3 4
                            (-1)
# 3355 "project/nnn/src/nnn.c"
                               ) {
    if (*ch == (27))
     *ch = 'q';
    else {
     unget_wch(*ch);
     *ch = ';';
    }
   }
   goto end;
  }

  if (r != 
# 3366 "project/nnn/src/nnn.c" 3 4
          (0)
# 3366 "project/nnn/src/nnn.c"
            )
   break;


  if (*ch < 128 && keyname(*ch)[0] == '^' && *ch != '^')
   goto end;

  if (len == 1) {
   if (*ch == '?')
    goto end;

   if (cfg.filtermode) {
    switch (*ch) {
    case '\'':
    case '+':
    case ',':
    case '-':
    case '.':
    case ';':
    case '=':
    case '>':
    case '@':
    case ']':
    case '`':
    case '~':
     goto end;
    }
   }


   if (*ch == ':') {
    fnstrstr = (fnstrstr == &strcasestr) ? &strstr : &strcasestr;



    regflags ^= 
# 3401 "project/nnn/src/nnn.c" 3 4
               0002
# 3401 "project/nnn/src/nnn.c"
                        ;

    showfilter(ln);
    continue;
   }


   if (*ch == '/') {
    ln[0] = (ln[0] == '/') ? '\\' : '/';
    wln[0] = (uchar_t)ln[0];
    cfg.regex ^= 1;
    filterfn = cfg.regex ? &visible_re : &visible_str;
    showfilter(ln);
    continue;
   }


   cur = 0;
  } else if (len == 48 - 1)
   continue;

  wln[len] = (wchar_t)*ch;
  wln[++len] = '\0';
  wcstombs(ln, wln, 48);
# 3435 "project/nnn/src/nnn.c"
  if (matches(pln) == -1) {
   showfilter(ln);

   continue;
  }


  if (ndents == 1 && cfg.filtermode
      && cfg.autoselect && (pdents[0].flags & 0x01)) {
   *ch = 
# 3444 "project/nnn/src/nnn.c" 3 4
        0527
# 3444 "project/nnn/src/nnn.c"
                 ;
   cur = 0;
   goto end;
  }
# 3456 "project/nnn/src/nnn.c"
  redraw(path);
  showfilter(ln);
 }
end:


 if (ln[1])
  ln[48 - 1] = ln[1];


 xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 3466 "project/nnn/src/nnn.c" 3 4
255 
# 3466 "project/nnn/src/nnn.c"
+ 1);

 curs_set(
# 3468 "project/nnn/src/nnn.c" 3 4
         0
# 3468 "project/nnn/src/nnn.c"
              );
 
# 3469 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 3469 "project/nnn/src/nnn.c"
1000
# 3469 "project/nnn/src/nnn.c" 3 4
)
# 3469 "project/nnn/src/nnn.c"
            ;


 return *ch;
}


static char *xreadline(const char *prefill, const char *prompt)
{
 size_t len, pos;
 int x, r;
 const int WCHAR_T_WIDTH = sizeof(wchar_t);
 wint_t ch[2] = {0};
 wchar_t * const buf = malloc(sizeof(wchar_t) * 256);

 if (!buf)
  printerr(3485);

 
# 3487 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 3487 "project/nnn/src/nnn.c"
-1
# 3487 "project/nnn/src/nnn.c" 3 4
)
# 3487 "project/nnn/src/nnn.c"
              ;
 printmsg(prompt);

 if (prefill) {
  ;
  len = pos = mbstowcs(buf, prefill, 256);
 } else
  len = (size_t)-1;

 if (len == (size_t)-1) {
  buf[0] = '\0';
  len = pos = 0;
 }

 x = getcurx(stdscr);
 curs_set(
# 3502 "project/nnn/src/nnn.c" 3 4
         1
# 3502 "project/nnn/src/nnn.c"
             );

 while (1) {
  buf[len] = ' ';
  
# 3506 "project/nnn/src/nnn.c" 3 4
 wattr_on(stdscr, (attr_t)(((
# 3506 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 3506 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8))), ((void *)0))
# 3506 "project/nnn/src/nnn.c"
                                   ;
  if (pos > (size_t)(xcols - x)) {
   
# 3508 "project/nnn/src/nnn.c" 3 4
  (wmove(stdscr,
# 3508 "project/nnn/src/nnn.c"
  xlines - 1
# 3508 "project/nnn/src/nnn.c" 3 4
  ,
# 3508 "project/nnn/src/nnn.c"
  x
# 3508 "project/nnn/src/nnn.c" 3 4
  ) == (-1) ? (-1) : waddnwstr(stdscr,
# 3508 "project/nnn/src/nnn.c"
  buf + (pos - (xcols - x) + 1)
# 3508 "project/nnn/src/nnn.c" 3 4
  ,
# 3508 "project/nnn/src/nnn.c"
  xcols - x
# 3508 "project/nnn/src/nnn.c" 3 4
  ))
# 3508 "project/nnn/src/nnn.c"
                                                                     ;
   
# 3509 "project/nnn/src/nnn.c" 3 4
  wmove(stdscr,
# 3509 "project/nnn/src/nnn.c"
  xlines - 1
# 3509 "project/nnn/src/nnn.c" 3 4
  ,
# 3509 "project/nnn/src/nnn.c"
  xcols - 1
# 3509 "project/nnn/src/nnn.c" 3 4
  )
# 3509 "project/nnn/src/nnn.c"
                             ;
  } else {
   
# 3511 "project/nnn/src/nnn.c" 3 4
  (wmove(stdscr,
# 3511 "project/nnn/src/nnn.c"
  xlines - 1
# 3511 "project/nnn/src/nnn.c" 3 4
  ,
# 3511 "project/nnn/src/nnn.c"
  x
# 3511 "project/nnn/src/nnn.c" 3 4
  ) == (-1) ? (-1) : waddnwstr(stdscr,
# 3511 "project/nnn/src/nnn.c"
  buf
# 3511 "project/nnn/src/nnn.c" 3 4
  ,
# 3511 "project/nnn/src/nnn.c"
  len + 1
# 3511 "project/nnn/src/nnn.c" 3 4
  ))
# 3511 "project/nnn/src/nnn.c"
                                         ;
   
# 3512 "project/nnn/src/nnn.c" 3 4
  wmove(stdscr,
# 3512 "project/nnn/src/nnn.c"
  xlines - 1
# 3512 "project/nnn/src/nnn.c" 3 4
  ,
# 3512 "project/nnn/src/nnn.c"
  x + wcswidth(buf, pos)
# 3512 "project/nnn/src/nnn.c" 3 4
  )
# 3512 "project/nnn/src/nnn.c"
                                          ;
  }
  
# 3514 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(((
# 3514 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 3514 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8))), ((void *)0))
# 3514 "project/nnn/src/nnn.c"
                                    ;

  r = 
# 3516 "project/nnn/src/nnn.c" 3 4
     wget_wch(stdscr,
# 3516 "project/nnn/src/nnn.c"
     ch
# 3516 "project/nnn/src/nnn.c" 3 4
     )
# 3516 "project/nnn/src/nnn.c"
                ;
  if (r == 
# 3517 "project/nnn/src/nnn.c" 3 4
          (-1)
# 3517 "project/nnn/src/nnn.c"
             )
   continue;

  if (r == 
# 3520 "project/nnn/src/nnn.c" 3 4
          (0)
# 3520 "project/nnn/src/nnn.c"
            ) {
   switch (*ch) {
   case 
# 3522 "project/nnn/src/nnn.c" 3 4
       0527
# 3522 "project/nnn/src/nnn.c"
                :
   case '\n':
   case '\r':
    goto END;
   case (('D') & 0x1f):
    if (pos < len)
     ++pos;
    else if (!(pos || len)) {
     len = 0;
     goto END;
    } else
     continue;

   case (127):
   case '\b':
    if (pos > 0) {
     
# 3538 "project/nnn/src/nnn.c" 3 4
    __builtin___memmove_chk (
# 3538 "project/nnn/src/nnn.c"
    buf + pos - 1
# 3538 "project/nnn/src/nnn.c" 3 4
    , 
# 3538 "project/nnn/src/nnn.c"
    buf + pos, (len - pos) * WCHAR_T_WIDTH
# 3538 "project/nnn/src/nnn.c" 3 4
    , __builtin_object_size (
# 3538 "project/nnn/src/nnn.c"
    buf + pos - 1
# 3538 "project/nnn/src/nnn.c" 3 4
    , 0))
                                  
# 3539 "project/nnn/src/nnn.c"
                                 ;
     --len, --pos;
    }
    continue;
   case '\t':
    if (!(len || pos) && ndents)
     len = pos = mbstowcs(buf, pdents[cur].name, 256);
    continue;
   case (('F') & 0x1f):
    if (pos < len)
     ++pos;
    continue;
   case (('B') & 0x1f):
    if (pos > 0)
     --pos;
    continue;
   case (('W') & 0x1f):
    printmsg(prompt);
    do {
     if (pos == 0)
      break;
     
# 3560 "project/nnn/src/nnn.c" 3 4
    __builtin___memmove_chk (
# 3560 "project/nnn/src/nnn.c"
    buf + pos - 1
# 3560 "project/nnn/src/nnn.c" 3 4
    , 
# 3560 "project/nnn/src/nnn.c"
    buf + pos, (len - pos) * WCHAR_T_WIDTH
# 3560 "project/nnn/src/nnn.c" 3 4
    , __builtin_object_size (
# 3560 "project/nnn/src/nnn.c"
    buf + pos - 1
# 3560 "project/nnn/src/nnn.c" 3 4
    , 0))
                                  
# 3561 "project/nnn/src/nnn.c"
                                 ;
     --pos, --len;
    } while (buf[pos - 1] != ' ' && buf[pos - 1] != '/');
    continue;
   case (('K') & 0x1f):
    printmsg(prompt);
    len = pos;
    continue;
   case (('L') & 0x1f):
    printmsg(prompt);
    len = pos = 0;
    continue;
   case (('A') & 0x1f):
    pos = 0;
    continue;
   case (('E') & 0x1f):
    pos = len;
    continue;
   case (('U') & 0x1f):
    printmsg(prompt);
    
# 3581 "project/nnn/src/nnn.c" 3 4
   __builtin___memmove_chk (
# 3581 "project/nnn/src/nnn.c"
   buf
# 3581 "project/nnn/src/nnn.c" 3 4
   , 
# 3581 "project/nnn/src/nnn.c"
   buf + pos, (len - pos) * WCHAR_T_WIDTH
# 3581 "project/nnn/src/nnn.c" 3 4
   , __builtin_object_size (
# 3581 "project/nnn/src/nnn.c"
   buf
# 3581 "project/nnn/src/nnn.c" 3 4
   , 0))
# 3581 "project/nnn/src/nnn.c"
                                                       ;
    len -= pos;
    pos = 0;
    continue;
   case (27):
    if (handle_alt_key(ch) != 
# 3586 "project/nnn/src/nnn.c" 3 4
                             (-1)
# 3586 "project/nnn/src/nnn.c"
                                )
     continue;

    len = 0;
    goto END;
   }


   if (*ch < 128 && keyname(*ch)[0] == '^')
    continue;

   if (pos < 256 - 1) {
    
# 3598 "project/nnn/src/nnn.c" 3 4
   __builtin___memmove_chk (
# 3598 "project/nnn/src/nnn.c"
   buf + pos + 1
# 3598 "project/nnn/src/nnn.c" 3 4
   , 
# 3598 "project/nnn/src/nnn.c"
   buf + pos, (len - pos) * WCHAR_T_WIDTH
# 3598 "project/nnn/src/nnn.c" 3 4
   , __builtin_object_size (
# 3598 "project/nnn/src/nnn.c"
   buf + pos + 1
# 3598 "project/nnn/src/nnn.c" 3 4
   , 0))
                                 
# 3599 "project/nnn/src/nnn.c"
                                ;
    buf[pos] = *ch;
    ++len, ++pos;
    continue;
   }
  } else {
   switch (*ch) {

   case 
# 3607 "project/nnn/src/nnn.c" 3 4
       0632
# 3607 "project/nnn/src/nnn.c"
                 :
    clearoldprompt();
    xlines = LINES;
    printmsg(prompt);
    break;

   case 
# 3613 "project/nnn/src/nnn.c" 3 4
       0404
# 3613 "project/nnn/src/nnn.c"
               :
    if (pos > 0)
     --pos;
    break;
   case 
# 3617 "project/nnn/src/nnn.c" 3 4
       0405
# 3617 "project/nnn/src/nnn.c"
                :
    if (pos < len)
     ++pos;
    break;
   case 
# 3621 "project/nnn/src/nnn.c" 3 4
       0407
# 3621 "project/nnn/src/nnn.c"
                    :
    if (pos > 0) {
     
# 3623 "project/nnn/src/nnn.c" 3 4
    __builtin___memmove_chk (
# 3623 "project/nnn/src/nnn.c"
    buf + pos - 1
# 3623 "project/nnn/src/nnn.c" 3 4
    , 
# 3623 "project/nnn/src/nnn.c"
    buf + pos, (len - pos) * WCHAR_T_WIDTH
# 3623 "project/nnn/src/nnn.c" 3 4
    , __builtin_object_size (
# 3623 "project/nnn/src/nnn.c"
    buf + pos - 1
# 3623 "project/nnn/src/nnn.c" 3 4
    , 0))
                                  
# 3624 "project/nnn/src/nnn.c"
                                 ;
     --len, --pos;
    }
    break;
   case 
# 3628 "project/nnn/src/nnn.c" 3 4
       0512
# 3628 "project/nnn/src/nnn.c"
             :
    if (pos < len) {
     
# 3630 "project/nnn/src/nnn.c" 3 4
    __builtin___memmove_chk (
# 3630 "project/nnn/src/nnn.c"
    buf + pos
# 3630 "project/nnn/src/nnn.c" 3 4
    , 
# 3630 "project/nnn/src/nnn.c"
    buf + pos + 1, (len - pos - 1) * WCHAR_T_WIDTH
# 3630 "project/nnn/src/nnn.c" 3 4
    , __builtin_object_size (
# 3630 "project/nnn/src/nnn.c"
    buf + pos
# 3630 "project/nnn/src/nnn.c" 3 4
    , 0))
                                      
# 3631 "project/nnn/src/nnn.c"
                                     ;
     --len;
    }
    break;
   case 
# 3635 "project/nnn/src/nnn.c" 3 4
       0550
# 3635 "project/nnn/src/nnn.c"
              :
    pos = len;
    break;
   case 
# 3638 "project/nnn/src/nnn.c" 3 4
       0406
# 3638 "project/nnn/src/nnn.c"
               :
    pos = 0;
    break;
   case 
# 3641 "project/nnn/src/nnn.c" 3 4
       0403
# 3641 "project/nnn/src/nnn.c"
             :
   case 
# 3642 "project/nnn/src/nnn.c" 3 4
       0402
# 3642 "project/nnn/src/nnn.c"
               :
    if (prompt && lastcmd && ((*(prompt) != *(">>> ") ? -1 : strcmp((prompt), (">>> "))) == 0)) {
     printmsg(prompt);
     len = pos = mbstowcs(buf, lastcmd, 256);
    }
   default:
    break;
   }
  }
 }

END:
 curs_set(
# 3654 "project/nnn/src/nnn.c" 3 4
         0
# 3654 "project/nnn/src/nnn.c"
              );
 
# 3655 "project/nnn/src/nnn.c" 3 4
wtimeout(stdscr,
# 3655 "project/nnn/src/nnn.c"
1000
# 3655 "project/nnn/src/nnn.c" 3 4
)
# 3655 "project/nnn/src/nnn.c"
            ;
 printmsg("");

 buf[len] = '\0';

 pos = wcstombs(g_buf, buf, 256 - 1);
 if (pos >= 256 - 1)
  g_buf[256 - 1] = '\0';

 free(buf);
 return g_buf;
}





static char *getreadline(const char *prompt)
{
 endwin();

 char *input = readline(prompt);

 
# 3678 "project/nnn/src/nnn.c" 3 4
wrefresh(stdscr)
# 3678 "project/nnn/src/nnn.c"
         ;

 if (input && input[0]) {
  add_history(input);
  xstrsncpy(g_buf, input, (
# 3682 "project/nnn/src/nnn.c" 3 4
                         1024 
# 3682 "project/nnn/src/nnn.c"
                         + ((
# 3682 "project/nnn/src/nnn.c" 3 4
                         255 
# 3682 "project/nnn/src/nnn.c"
                         + 1) << 1)));
  free(input);
  return g_buf;
 }

 free(input);
 return 
# 3688 "project/nnn/src/nnn.c" 3 4
       ((void *)0)
# 3688 "project/nnn/src/nnn.c"
           ;
}






static int xlink(char *prefix, char *path, char *curfname, char *buf, int *presel, int type)
{
 int count = 0, choice;
 char *psel = pselbuf, *fname;
 size_t pos = 0, len, r;
 int (*link_fn)(const char *, const char *) = 
# 3701 "project/nnn/src/nnn.c" 3 4
                                             ((void *)0)
# 3701 "project/nnn/src/nnn.c"
                                                 ;
 char lnpath[
# 3702 "project/nnn/src/nnn.c" 3 4
            1024
# 3702 "project/nnn/src/nnn.c"
                    ];

 choice = get_cur_or_sel();
 if (!choice)
  return -1;

 if (type == 's')
  link_fn = &symlink;
 else
  link_fn = &link;

 if (choice == 'c' || (nselected == 1)) {
  mkpath(path, prefix, lnpath);
  mkpath(path, (choice == 'c') ? curfname : pselbuf, buf);

  if (!link_fn(buf, lnpath)) {
   if (choice == 's')
    clearselection();
   return 1;
  }

  printwait(strerror(
# 3723 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 3723 "project/nnn/src/nnn.c"
 ), presel);
  return -1;
 }

 while (pos < selbufpos) {
  len = xstrlen(psel);
  fname = xbasename(psel);

  r = xstrsncpy(buf, prefix, 
# 3731 "project/nnn/src/nnn.c" 3 4
                            255 
# 3731 "project/nnn/src/nnn.c"
                                     + 1);
  xstrsncpy(buf + r - 1, fname, 
# 3732 "project/nnn/src/nnn.c" 3 4
                               255 
# 3732 "project/nnn/src/nnn.c"
                                        - r);
  mkpath(path, buf, lnpath);

  if (!link_fn(psel, lnpath))
   ++count;

  pos += len + 1;
  psel += len + 1;
 }

 clearselection();
 return count;
}

static 
# 3746 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 3746 "project/nnn/src/nnn.c"
           parsekvpair(kv **arr, char **envcpy, const uchar_t id, uchar_t *items)
{
 
# 3748 "project/nnn/src/nnn.c" 3 4
_Bool 
# 3748 "project/nnn/src/nnn.c"
     new = 
# 3748 "project/nnn/src/nnn.c" 3 4
           1
# 3748 "project/nnn/src/nnn.c"
               ;
 const uchar_t INCR = 8;
 uint_t i = 0;
 kv *kvarr = 
# 3751 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 3751 "project/nnn/src/nnn.c"
                ;
 char *ptr = getenv(env_cfg[id]);

 if (!ptr || !*ptr)
  return 
# 3755 "project/nnn/src/nnn.c" 3 4
        1
# 3755 "project/nnn/src/nnn.c"
            ;

 *envcpy = xstrdup(ptr);
 if (!*envcpy) {
  perror(xitoa(3759));
  return 
# 3760 "project/nnn/src/nnn.c" 3 4
        0
# 3760 "project/nnn/src/nnn.c"
             ;
 }

 ptr = *envcpy;

 while (*ptr && i < 100) {
  if (new) {
   if (!(i & (INCR - 1))) {
    kvarr = xrealloc(kvarr, sizeof(kv) * (i + INCR));
    *arr = kvarr;
    if (!kvarr) {
     perror(xitoa(3771));
     return 
# 3772 "project/nnn/src/nnn.c" 3 4
           0
# 3772 "project/nnn/src/nnn.c"
                ;
    }
    
# 3774 "project/nnn/src/nnn.c" 3 4
   __builtin___memset_chk (
# 3774 "project/nnn/src/nnn.c"
   kvarr + i
# 3774 "project/nnn/src/nnn.c" 3 4
   , 
# 3774 "project/nnn/src/nnn.c"
   0, sizeof(kv) * INCR
# 3774 "project/nnn/src/nnn.c" 3 4
   , __builtin_object_size (
# 3774 "project/nnn/src/nnn.c"
   kvarr + i
# 3774 "project/nnn/src/nnn.c" 3 4
   , 0))
# 3774 "project/nnn/src/nnn.c"
                                          ;
   }
   kvarr[i].key = (uchar_t)*ptr;
   if (*++ptr != ':' || *++ptr == '\0' || *ptr == ';')
    return 
# 3778 "project/nnn/src/nnn.c" 3 4
          0
# 3778 "project/nnn/src/nnn.c"
               ;
   kvarr[i].off = ptr - *envcpy;
   ++i;

   new = 
# 3782 "project/nnn/src/nnn.c" 3 4
        0
# 3782 "project/nnn/src/nnn.c"
             ;
  }

  if (*ptr == ';') {
   *ptr = '\0';
   new = 
# 3787 "project/nnn/src/nnn.c" 3 4
        1
# 3787 "project/nnn/src/nnn.c"
            ;
  }

  ++ptr;
 }

 *items = i;
 return (i != 0);
}







static char *get_kv_val(kv *kvarr, char *buf, int key, uchar_t max, uchar_t id)
{
 char *val;

 if (!kvarr)
  return 
# 3808 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 3808 "project/nnn/src/nnn.c"
            ;

 for (int r = 0; kvarr[r].key && r < max; ++r) {
  if (kvarr[r].key == key) {

   if (id == 2)
    return pluginstr + kvarr[r].off;

   val = bmstr + kvarr[r].off;
   convert_tilde(val, g_buf);
   return abspath(((val[0] == '~') ? g_buf : val), 
# 3818 "project/nnn/src/nnn.c" 3 4
                                                  ((void *)0)
# 3818 "project/nnn/src/nnn.c"
                                                      , buf);
  }
 }

 ;
 return 
# 3823 "project/nnn/src/nnn.c" 3 4
       ((void *)0)
# 3823 "project/nnn/src/nnn.c"
           ;
}

static int get_kv_key(kv *kvarr, char *val, uchar_t max, uchar_t id)
{
 if (!kvarr)
  return -1;

 if (id != 11)
  return -1;

 for (int r = 0; kvarr[r].key && r < max; ++r) {
  if ((*((orderstr + kvarr[r].off)) != *(val) ? -1 : strcmp(((orderstr + kvarr[r].off)), (val))) == 0)
   return kvarr[r].key;
 }

 return -1;
}

static void resetdircolor(int flags)
{

 if (g_state.dircolor && !(flags & 0x01)) {
  
# 3846 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(((
# 3846 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 3846 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8)) 
# 3846 "project/nnn/src/nnn.c"
 | 
# 3846 "project/nnn/src/nnn.c" 3 4
 ((1U) << ((13) + 8))), ((void *)0))
# 3846 "project/nnn/src/nnn.c"
                                             ;
  g_state.dircolor = 0;
 }
}
# 3864 "project/nnn/src/nnn.c"
static wchar_t *unescape(const char *str, uint_t maxcols)
{
 wchar_t * const wbuf = (wchar_t *)g_buf;
 wchar_t *buf = wbuf;
 size_t len = mbstowcs(wbuf, str, maxcols);

 len = wcswidth(wbuf, len);

 if (len >= maxcols) {
  size_t lencount = maxcols;

  while (len > maxcols)
   len = wcswidth(wbuf, --lencount);

  wbuf[lencount] = L'\0';
 }


 while (*buf) {
  if (*buf <= '\x1f' || *buf == '\x7f')
   *buf = '\?';

  ++buf;
 }

 return wbuf;
}

static off_t get_size(off_t size, off_t *pval, int comp)
{
 off_t rem = *pval;
 off_t quo = rem / 10;

 if ((rem - (quo * 10)) >= 5) {
  rem = quo + 1;
  if (rem == comp) {
   ++size;
   rem = 0;
  }
 } else
  rem = quo;

 *pval = rem;
 return size;
}

static char *coolsize(off_t size)
{
 const char * const U = "BKMGTPEZY";
 static char size_buf[12];
 off_t rem = 0;
 size_t ret;
 int i = 0;

 while (size >= 1024) {
  rem = size & (0x3FF);
  size >>= 10;
  ++i;
 }

 if (i == 1) {
  rem = (rem * 1000) >> 10;
  rem /= 10;
  size = get_size(size, &rem, 10);
 } else if (i == 2) {
  rem = (rem * 1000) >> 10;
  size = get_size(size, &rem, 100);
 } else if (i > 2) {
  rem = (rem * 10000) >> 10;
  size = get_size(size, &rem, 1000);
 }

 if (i > 0 && i < 6 && rem) {
  ret = xstrsncpy(size_buf, xitoa(size), 12);
  size_buf[ret - 1] = '.';

  char *frac = xitoa(rem);
  size_t toprint = i > 3 ? 3 : i;
  size_t len = xstrlen(frac);

  if (len < toprint) {
   size_buf[ret] = size_buf[ret + 1] = size_buf[ret + 2] = '0';
   xstrsncpy(size_buf + ret + (toprint - len), frac, len + 1);
  } else
   xstrsncpy(size_buf + ret, frac, toprint + 1);

  ret += toprint;
 } else {
  ret = xstrsncpy(size_buf, size ? xitoa(size) : "0", 12);
  --ret;
 }

 size_buf[ret] = U[i];
 size_buf[ret + 1] = '\0';

 return size_buf;
}


static char *get_lsperms(mode_t mode)
{
 static const char * const rwx[] = {"---", "--x", "-w-", "-wx", "r--", "r-x", "rw-", "rwx"};
 static char bits[11] = {'\0'};

 switch (mode & 
# 3968 "project/nnn/src/nnn.c" 3 4
               0170000
# 3968 "project/nnn/src/nnn.c"
                     ) {
 case 
# 3969 "project/nnn/src/nnn.c" 3 4
     0100000
# 3969 "project/nnn/src/nnn.c"
            :
  bits[0] = '-';
  break;
 case 
# 3972 "project/nnn/src/nnn.c" 3 4
     0040000
# 3972 "project/nnn/src/nnn.c"
            :
  bits[0] = 'd';
  break;
 case 
# 3975 "project/nnn/src/nnn.c" 3 4
     0120000
# 3975 "project/nnn/src/nnn.c"
            :
  bits[0] = 'l';
  break;
 case 
# 3978 "project/nnn/src/nnn.c" 3 4
     0140000
# 3978 "project/nnn/src/nnn.c"
             :
  bits[0] = 's';
  break;
 case 
# 3981 "project/nnn/src/nnn.c" 3 4
     0010000
# 3981 "project/nnn/src/nnn.c"
            :
  bits[0] = 'p';
  break;
 case 
# 3984 "project/nnn/src/nnn.c" 3 4
     0060000
# 3984 "project/nnn/src/nnn.c"
            :
  bits[0] = 'b';
  break;
 case 
# 3987 "project/nnn/src/nnn.c" 3 4
     0020000
# 3987 "project/nnn/src/nnn.c"
            :
  bits[0] = 'c';
  break;
 default:
  bits[0] = '?';
  break;
 }

 xstrsncpy(&bits[1], rwx[(mode >> 6) & 7], 4);
 xstrsncpy(&bits[4], rwx[(mode >> 3) & 7], 4);
 xstrsncpy(&bits[7], rwx[(mode & 7)], 4);

 if (mode & 
# 3999 "project/nnn/src/nnn.c" 3 4
           0004000
# 3999 "project/nnn/src/nnn.c"
                  )
  bits[3] = (mode & 0100) ? 's' : 'S';
 if (mode & 
# 4001 "project/nnn/src/nnn.c" 3 4
           0002000
# 4001 "project/nnn/src/nnn.c"
                  )
  bits[6] = (mode & 0010) ? 's' : 'l';
 if (mode & 
# 4003 "project/nnn/src/nnn.c" 3 4
           0001000
# 4003 "project/nnn/src/nnn.c"
                  )
  bits[9] = (mode & 0001) ? 't' : 'T';

 return bits;
}
# 4070 "project/nnn/src/nnn.c"
static void print_time(const time_t *timep)
{
 struct tm t;

 localtime_r(timep, &t);
 printw("%s-%02d-%02d %02d:%02d",
  xitoa(t.tm_year + 1900), t.tm_mon + 1, t.tm_mday, t.tm_hour, t.tm_min);
}

static char get_detail_ind(const mode_t mode)
{
 switch (mode & 
# 4081 "project/nnn/src/nnn.c" 3 4
               0170000
# 4081 "project/nnn/src/nnn.c"
                     ) {
 case 
# 4082 "project/nnn/src/nnn.c" 3 4
     0040000
# 4082 "project/nnn/src/nnn.c"
            :
 case 
# 4083 "project/nnn/src/nnn.c" 3 4
     0100000
# 4083 "project/nnn/src/nnn.c"
            : return ' ';
 case 
# 4084 "project/nnn/src/nnn.c" 3 4
     0120000
# 4084 "project/nnn/src/nnn.c"
            : return '@';
 case 
# 4085 "project/nnn/src/nnn.c" 3 4
     0140000
# 4085 "project/nnn/src/nnn.c"
             : return '=';
 case 
# 4086 "project/nnn/src/nnn.c" 3 4
     0010000
# 4086 "project/nnn/src/nnn.c"
            : return '|';
 case 
# 4087 "project/nnn/src/nnn.c" 3 4
     0060000
# 4087 "project/nnn/src/nnn.c"
            : return 'b';
 case 
# 4088 "project/nnn/src/nnn.c" 3 4
     0020000
# 4088 "project/nnn/src/nnn.c"
            : return 'c';
 }
 return '?';
}


static uchar_t get_color_pair_name_ind(const struct entry *ent, char *pind, int *pattr)
{
 switch (ent->mode & 
# 4096 "project/nnn/src/nnn.c" 3 4
                    0170000
# 4096 "project/nnn/src/nnn.c"
                          ) {
 case 
# 4097 "project/nnn/src/nnn.c" 3 4
     0100000
# 4097 "project/nnn/src/nnn.c"
            :
  if (!ent->size) {
   if (ent->mode & 0100)
    *pind = '*';
   return ((((((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1);
  }
  if (ent->flags & 0x02) {
   if (ent->mode & 0100)
    *pind = '*';
   return ((((((4 + 1) + 1) + 1) + 1) + 1) + 1);
  }
  if (ent->mode & 0100) {
   *pind = '*';
   return ((((4 + 1) + 1) + 1) + 1);
  }
  return (((((4 + 1) + 1) + 1) + 1) + 1);
 case 
# 4113 "project/nnn/src/nnn.c" 3 4
     0040000
# 4113 "project/nnn/src/nnn.c"
            :
  *pind = '/';
  if (g_state.oldcolor)
   return (((4 + 1) + 1) + 1);
  *pattr |= 
# 4117 "project/nnn/src/nnn.c" 3 4
           ((1U) << ((13) + 8))
# 4117 "project/nnn/src/nnn.c"
                 ;
  return g_state.dirctx ? cfg.curctx + 1 : (((4 + 1) + 1) + 1);
 case 
# 4119 "project/nnn/src/nnn.c" 3 4
     0120000
# 4119 "project/nnn/src/nnn.c"
            :
  if (ent->flags & 0x01) {
   *pind = '/';
   *pattr |= g_state.oldcolor ? 
# 4122 "project/nnn/src/nnn.c" 3 4
                               ((1U) << ((12) + 8)) 
# 4122 "project/nnn/src/nnn.c"
                                     : 
# 4122 "project/nnn/src/nnn.c" 3 4
                                       ((1U) << ((13) + 8))
# 4122 "project/nnn/src/nnn.c"
                                             ;
  } else {
   *pind = '@';
   if (g_state.oldcolor)
    *pattr |= 
# 4126 "project/nnn/src/nnn.c" 3 4
             ((1U) << ((12) + 8))
# 4126 "project/nnn/src/nnn.c"
                  ;
  }
  if (!g_state.oldcolor || cfg.showdetail)
   return (ent->flags & 0x04) ? (((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) : (((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1);
  return 0;
 case 
# 4131 "project/nnn/src/nnn.c" 3 4
     0140000
# 4131 "project/nnn/src/nnn.c"
             :
  *pind = '=';
  return (((((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1);
 case 
# 4134 "project/nnn/src/nnn.c" 3 4
     0010000
# 4134 "project/nnn/src/nnn.c"
            :
  *pind = '|';
  return ((((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1);
 case 
# 4137 "project/nnn/src/nnn.c" 3 4
     0060000
# 4137 "project/nnn/src/nnn.c"
            :
  return (4 + 1);
 case 
# 4139 "project/nnn/src/nnn.c" 3 4
     0020000
# 4139 "project/nnn/src/nnn.c"
            :
  return ((4 + 1) + 1);
 }

 *pind = '?';
 return ((((((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1);
}

static void printent(const struct entry *ent, uint_t namecols, 
# 4147 "project/nnn/src/nnn.c" 3 4
                                                              _Bool 
# 4147 "project/nnn/src/nnn.c"
                                                                   sel)
{
 char ind = '\0';
 int attrs;

 if (cfg.showdetail) {
  int type = ent->mode & 
# 4153 "project/nnn/src/nnn.c" 3 4
                        0170000
# 4153 "project/nnn/src/nnn.c"
                              ;
  char perms[6] = {' ', ' ', (char)('0' + ((ent->mode >> 6) & 7)),
    (char)('0' + ((ent->mode >> 3) & 7)),
    (char)('0' + (ent->mode & 7)), '\0'};

  
# 4158 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 4158 "project/nnn/src/nnn.c"
 ' '
# 4158 "project/nnn/src/nnn.c" 3 4
 )
# 4158 "project/nnn/src/nnn.c"
           ;
  attrs = g_state.oldcolor ? (resetdircolor(ent->flags), 
# 4159 "project/nnn/src/nnn.c" 3 4
                                                        ((1U) << ((12) + 8))
# 4159 "project/nnn/src/nnn.c"
                                                             )
      : (fcolors[((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1)] ? 
# 4160 "project/nnn/src/nnn.c" 3 4
                         ((
# 4160 "project/nnn/src/nnn.c"
                         ((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1)
# 4160 "project/nnn/src/nnn.c" 3 4
                         ) << ((0) + 8)) 
# 4160 "project/nnn/src/nnn.c"
                                           : 0);
  if (attrs)
   
# 4162 "project/nnn/src/nnn.c" 3 4
  wattr_on(stdscr, (attr_t)(
# 4162 "project/nnn/src/nnn.c"
  attrs
# 4162 "project/nnn/src/nnn.c" 3 4
  ), ((void *)0))
# 4162 "project/nnn/src/nnn.c"
               ;


  print_time(&ent->sec);

  printw("%s%9s ", perms, (type == 
# 4167 "project/nnn/src/nnn.c" 3 4
                                  0100000 
# 4167 "project/nnn/src/nnn.c"
                                          || type == 
# 4167 "project/nnn/src/nnn.c" 3 4
                                                     0040000
# 4167 "project/nnn/src/nnn.c"
                                                            )
   ? coolsize(cfg.blkorder ? (blkcnt_t)ent->blocks << blk_shift : ent->size)
   : (type = (uchar_t)get_detail_ind(ent->mode), (char *)&type));

  if (attrs)
   
# 4172 "project/nnn/src/nnn.c" 3 4
  wattr_off(stdscr, (attr_t)(
# 4172 "project/nnn/src/nnn.c"
  attrs
# 4172 "project/nnn/src/nnn.c" 3 4
  ), ((void *)0))
# 4172 "project/nnn/src/nnn.c"
                ;
 }

 attrs = 0;

 uchar_t color_pair = get_color_pair_name_ind(ent, &ind, &attrs);

 
# 4179 "project/nnn/src/nnn.c" 3 4
waddch(stdscr,
# 4179 "project/nnn/src/nnn.c"
(ent->flags & 0x10) ? '+' | 
# 4179 "project/nnn/src/nnn.c" 3 4
((1U) << ((10) + 8)) 
# 4179 "project/nnn/src/nnn.c"
| 
# 4179 "project/nnn/src/nnn.c" 3 4
((1U) << ((13) + 8)) 
# 4179 "project/nnn/src/nnn.c"
: ' '
# 4179 "project/nnn/src/nnn.c" 3 4
)
# 4179 "project/nnn/src/nnn.c"
                                                                    ;

 if (g_state.oldcolor)
  resetdircolor(ent->flags);
 else {
  if (ent->flags & 0x08)
   color_pair = ((((((((4 + 1) + 1) + 1) + 1) + 1) + 1) + 1) + 1);
  if (color_pair && fcolors[color_pair])
   attrs |= 
# 4187 "project/nnn/src/nnn.c" 3 4
           ((
# 4187 "project/nnn/src/nnn.c"
           color_pair
# 4187 "project/nnn/src/nnn.c" 3 4
           ) << ((0) + 8))
# 4187 "project/nnn/src/nnn.c"
                                 ;



 }

 if (sel)
  attrs |= 
# 4194 "project/nnn/src/nnn.c" 3 4
          ((1U) << ((10) + 8))
# 4194 "project/nnn/src/nnn.c"
                   ;
 if (attrs)
  
# 4196 "project/nnn/src/nnn.c" 3 4
 wattr_on(stdscr, (attr_t)(
# 4196 "project/nnn/src/nnn.c"
 attrs
# 4196 "project/nnn/src/nnn.c" 3 4
 ), ((void *)0))
# 4196 "project/nnn/src/nnn.c"
              ;
 if (!ind)
  ++namecols;


 
# 4201 "project/nnn/src/nnn.c" 3 4
waddnwstr(stdscr,
# 4201 "project/nnn/src/nnn.c"
unescape(ent->name, namecols)
# 4201 "project/nnn/src/nnn.c" 3 4
,-1)
# 4201 "project/nnn/src/nnn.c"
                                      ;




 if (attrs)
  
# 4207 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(
# 4207 "project/nnn/src/nnn.c"
 attrs
# 4207 "project/nnn/src/nnn.c" 3 4
 ), ((void *)0))
# 4207 "project/nnn/src/nnn.c"
               ;
 if (ind)
  
# 4209 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 4209 "project/nnn/src/nnn.c"
 ind
# 4209 "project/nnn/src/nnn.c" 3 4
 )
# 4209 "project/nnn/src/nnn.c"
           ;
}

static void savecurctx(char *path, char *curname, int nextctx)
{
 settings tmpcfg = cfg;
 context *ctxr = &g_ctx[nextctx];


 if (curname)
  xstrsncpy(g_ctx[tmpcfg.curctx].c_name, curname, 
# 4219 "project/nnn/src/nnn.c" 3 4
                                                 255 
# 4219 "project/nnn/src/nnn.c"
                                                          + 1);
 else
  g_ctx[tmpcfg.curctx].c_name[0] = '\0';

 g_ctx[tmpcfg.curctx].c_cfg = tmpcfg;

 if (ctxr->c_cfg.ctxactive) {
  tmpcfg = ctxr->c_cfg;

  if (order) {
   cfgsort[4] = cfgsort[nextctx];
   cfgsort[nextctx] = '0';
  }
 } else {
  ctxr->c_cfg.ctxactive = 1;
  xstrsncpy(ctxr->c_path, path, 
# 4234 "project/nnn/src/nnn.c" 3 4
                               1024
# 4234 "project/nnn/src/nnn.c"
                                       );
  ctxr->c_last[0] = ctxr->c_name[0] = ctxr->c_fltr[0] = ctxr->c_fltr[1] = '\0';
  ctxr->c_cfg = tmpcfg;

  if (cfgsort[cfg.curctx] == 'z')
   cfgsort[nextctx] = 'z';
 }

 tmpcfg.curctx = nextctx;
 cfg = tmpcfg;
}


static void save_session(const char *sname, int *presel)
{
 int fd, i;
 session_header_t header;
 
# 4251 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4251 "project/nnn/src/nnn.c"
     status = 
# 4251 "project/nnn/src/nnn.c" 3 4
              0
# 4251 "project/nnn/src/nnn.c"
                   ;
 char ssnpath[
# 4252 "project/nnn/src/nnn.c" 3 4
             1024
# 4252 "project/nnn/src/nnn.c"
                     ];
 char spath[
# 4253 "project/nnn/src/nnn.c" 3 4
           1024
# 4253 "project/nnn/src/nnn.c"
                   ];

 
# 4255 "project/nnn/src/nnn.c" 3 4
__builtin___memset_chk (
# 4255 "project/nnn/src/nnn.c"
&header
# 4255 "project/nnn/src/nnn.c" 3 4
, 
# 4255 "project/nnn/src/nnn.c"
0, sizeof(session_header_t)
# 4255 "project/nnn/src/nnn.c" 3 4
, __builtin_object_size (
# 4255 "project/nnn/src/nnn.c"
&header
# 4255 "project/nnn/src/nnn.c" 3 4
, 0))
# 4255 "project/nnn/src/nnn.c"
                                            ;

 header.ver = 1;

 for (i = 0; i < 4; ++i) {
  if (g_ctx[i].c_cfg.ctxactive) {
   if (cfg.curctx == i && ndents)

    xstrsncpy(g_ctx[i].c_name, pdents[cur].name, 
# 4263 "project/nnn/src/nnn.c" 3 4
                                                255 
# 4263 "project/nnn/src/nnn.c"
                                                         + 1);
   header.pathln[i] = strnlen(g_ctx[i].c_path, 
# 4264 "project/nnn/src/nnn.c" 3 4
                                              1024
# 4264 "project/nnn/src/nnn.c"
                                                      ) + 1;
   header.lastln[i] = strnlen(g_ctx[i].c_last, 
# 4265 "project/nnn/src/nnn.c" 3 4
                                              1024
# 4265 "project/nnn/src/nnn.c"
                                                      ) + 1;
   header.nameln[i] = strnlen(g_ctx[i].c_name, 
# 4266 "project/nnn/src/nnn.c" 3 4
                                              255
# 4266 "project/nnn/src/nnn.c"
                                                      ) + 1;
   header.fltrln[i] = 48;
  }
 }

 mkpath(cfgpath, toks[1], ssnpath);
 mkpath(ssnpath, sname, spath);

 fd = open(spath, 
# 4274 "project/nnn/src/nnn.c" 3 4
                 0x00000200 
# 4274 "project/nnn/src/nnn.c"
                         | 
# 4274 "project/nnn/src/nnn.c" 3 4
                           0x0001 
# 4274 "project/nnn/src/nnn.c"
                                    | 
# 4274 "project/nnn/src/nnn.c" 3 4
                                      0x00000400
# 4274 "project/nnn/src/nnn.c"
                                             , 0666);
 if (fd == -1) {
  printwait(messages[23], presel);
  return;
 }

 if ((write(fd, &header, sizeof(header)) != (ssize_t)sizeof(header))
  || (write(fd, &cfg, sizeof(cfg)) != (ssize_t)sizeof(cfg)))
  goto END;

 for (i = 0; i < 4; ++i)
  if ((write(fd, &g_ctx[i].c_cfg, sizeof(settings)) != (ssize_t)sizeof(settings))
   || (write(fd, &g_ctx[i].color, sizeof(uint_t)) != (ssize_t)sizeof(uint_t))
   || (header.nameln[i] > 0
       && write(fd, g_ctx[i].c_name, header.nameln[i]) != (ssize_t)header.nameln[i])
   || (header.lastln[i] > 0
       && write(fd, g_ctx[i].c_last, header.lastln[i]) != (ssize_t)header.lastln[i])
   || (header.fltrln[i] > 0
       && write(fd, g_ctx[i].c_fltr, header.fltrln[i]) != (ssize_t)header.fltrln[i])
   || (header.pathln[i] > 0
       && write(fd, g_ctx[i].c_path, header.pathln[i]) != (ssize_t)header.pathln[i]))
   goto END;

 status = 
# 4297 "project/nnn/src/nnn.c" 3 4
         1
# 4297 "project/nnn/src/nnn.c"
             ;

END:
 close(fd);

 if (!status)
  printwait(messages[5], presel);
}

static 
# 4306 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4306 "project/nnn/src/nnn.c"
           load_session(const char *sname, char **path, char **lastdir, char **lastname, 
# 4306 "project/nnn/src/nnn.c" 3 4
                                                                                         _Bool 
# 4306 "project/nnn/src/nnn.c"
                                                                                              restore)
{
 int fd, i = 0;
 session_header_t header;
 
# 4310 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4310 "project/nnn/src/nnn.c"
     has_loaded_dynamically = !(sname || restore);
 
# 4311 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4311 "project/nnn/src/nnn.c"
     status = (sname && g_state.picker);
 char ssnpath[
# 4312 "project/nnn/src/nnn.c" 3 4
             1024
# 4312 "project/nnn/src/nnn.c"
                     ];
 char spath[
# 4313 "project/nnn/src/nnn.c" 3 4
           1024
# 4313 "project/nnn/src/nnn.c"
                   ];

 mkpath(cfgpath, toks[1], ssnpath);

 if (!restore) {
  sname = sname ? sname : xreadline(
# 4318 "project/nnn/src/nnn.c" 3 4
                                   ((void *)0)
# 4318 "project/nnn/src/nnn.c"
                                       , messages[6]);
  if (!sname[0])
   return 
# 4320 "project/nnn/src/nnn.c" 3 4
         0
# 4320 "project/nnn/src/nnn.c"
              ;

  mkpath(ssnpath, sname, spath);


  if ((sname[0] == '@') && !sname[1])
   has_loaded_dynamically = 
# 4326 "project/nnn/src/nnn.c" 3 4
                           0
# 4326 "project/nnn/src/nnn.c"
                                ;
 } else
  mkpath(ssnpath, "@", spath);

 if (has_loaded_dynamically)
  save_session("@", 
# 4331 "project/nnn/src/nnn.c" 3 4
                   ((void *)0)
# 4331 "project/nnn/src/nnn.c"
                       );

 fd = open(spath, 
# 4333 "project/nnn/src/nnn.c" 3 4
                 0x0000
# 4333 "project/nnn/src/nnn.c"
                         , 0666);
 if (fd == -1) {
  if (!status) {
   printmsg(messages[23]);
   xdelay((350000));
  }
  return 
# 4339 "project/nnn/src/nnn.c" 3 4
        0
# 4339 "project/nnn/src/nnn.c"
             ;
 }

 status = 
# 4342 "project/nnn/src/nnn.c" 3 4
         0
# 4342 "project/nnn/src/nnn.c"
              ;

 if ((read(fd, &header, sizeof(header)) != (ssize_t)sizeof(header))
  || (header.ver != 1)
  || (read(fd, &cfg, sizeof(cfg)) != (ssize_t)sizeof(cfg)))
  goto END;

 g_ctx[cfg.curctx].c_name[0] = g_ctx[cfg.curctx].c_last[0]
  = g_ctx[cfg.curctx].c_fltr[0] = g_ctx[cfg.curctx].c_fltr[1] = '\0';

 for (; i < 4; ++i)
  if ((read(fd, &g_ctx[i].c_cfg, sizeof(settings)) != (ssize_t)sizeof(settings))
   || (read(fd, &g_ctx[i].color, sizeof(uint_t)) != (ssize_t)sizeof(uint_t))
   || (header.nameln[i] > 0
       && read(fd, g_ctx[i].c_name, header.nameln[i]) != (ssize_t)header.nameln[i])
   || (header.lastln[i] > 0
       && read(fd, g_ctx[i].c_last, header.lastln[i]) != (ssize_t)header.lastln[i])
   || (header.fltrln[i] > 0
       && read(fd, g_ctx[i].c_fltr, header.fltrln[i]) != (ssize_t)header.fltrln[i])
   || (header.pathln[i] > 0
       && read(fd, g_ctx[i].c_path, header.pathln[i]) != (ssize_t)header.pathln[i]))
   goto END;

 *path = g_ctx[cfg.curctx].c_path;
 *lastdir = g_ctx[cfg.curctx].c_last;
 *lastname = g_ctx[cfg.curctx].c_name;
 set_sort_flags('\0');
 status = 
# 4369 "project/nnn/src/nnn.c" 3 4
         1
# 4369 "project/nnn/src/nnn.c"
             ;

END:
 close(fd);

 if (!status) {
  printmsg(messages[5]);
  xdelay((350000));
 } else if (restore)
  unlink(spath);

 return status;
}


static uchar_t get_free_ctx(void)
{
 uchar_t r = cfg.curctx;

 do
  r = (r + 1) & ~4;
 while (g_ctx[r].c_cfg.ctxactive && (r != cfg.curctx));

 return r;
}


static void set_smart_ctx(int ctx, char *nextpath, char **path, char *file, char **lastname, char **lastdir)
{
 if (ctx == '+')
  ctx = (int)(get_free_ctx() + 1);

 if (ctx == 0 || ctx == cfg.curctx + 1) {
  xstrsncpy(*lastdir, *path, 
# 4402 "project/nnn/src/nnn.c" 3 4
                            1024
# 4402 "project/nnn/src/nnn.c"
                                    );
  xstrsncpy(*path, nextpath, 
# 4403 "project/nnn/src/nnn.c" 3 4
                            1024
# 4403 "project/nnn/src/nnn.c"
                                    );
 } else {
  --ctx;

  g_ctx[ctx].c_cfg.ctxactive = 0;
  ;
  savecurctx(nextpath, file, ctx);
  *path = g_ctx[ctx].c_path;
  *lastdir = g_ctx[ctx].c_last;
  *lastname = g_ctx[ctx].c_name;
 }
}





static 
# 4420 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4420 "project/nnn/src/nnn.c"
           get_output(char *file, char *arg1, char *arg2, int fdout, 
# 4420 "project/nnn/src/nnn.c" 3 4
                                                                     _Bool 
# 4420 "project/nnn/src/nnn.c"
                                                                          multi, 
# 4420 "project/nnn/src/nnn.c" 3 4
                                                                                 _Bool 
# 4420 "project/nnn/src/nnn.c"
                                                                                      page)
{
 pid_t pid;
 int pipefd[2];
 int index = 0, flags;
 
# 4425 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4425 "project/nnn/src/nnn.c"
     ret = 
# 4425 "project/nnn/src/nnn.c" 3 4
           0
# 4425 "project/nnn/src/nnn.c"
                ;
 
# 4426 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4426 "project/nnn/src/nnn.c"
     tmpfile = ((fdout == -1) && page);
 char *argv[10] = {0};
 char *cmd = 
# 4428 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 4428 "project/nnn/src/nnn.c"
                ;
 int fd = -1;
 ssize_t len;

 if (tmpfile) {
  fdout = create_tmp_file();
  if (fdout == -1)
   return 
# 4435 "project/nnn/src/nnn.c" 3 4
         0
# 4435 "project/nnn/src/nnn.c"
              ;
 }

 if (multi) {
  cmd = parseargs(file, argv, &index);
  if (!cmd)
   return 
# 4441 "project/nnn/src/nnn.c" 3 4
         0
# 4441 "project/nnn/src/nnn.c"
              ;
 } else
  argv[index++] = file;

 argv[index] = arg1;
 argv[++index] = arg2;

 if (pipe(pipefd) == -1) {
  free(cmd);
  printerr(4450);
 }

 for (index = 0; index < 2; ++index) {

  flags = fcntl(pipefd[index], 
# 4455 "project/nnn/src/nnn.c" 3 4
                              3
# 4455 "project/nnn/src/nnn.c"
                                     , 0);


  flags |= 
# 4458 "project/nnn/src/nnn.c" 3 4
          0x00000004
# 4458 "project/nnn/src/nnn.c"
                    ;


  fcntl(pipefd[index], 
# 4461 "project/nnn/src/nnn.c" 3 4
                      4
# 4461 "project/nnn/src/nnn.c"
                             , flags);
 }

 pid = fork();
 if (pid == 0) {

  close(pipefd[0]);
  dup2(pipefd[1], 
# 4468 "project/nnn/src/nnn.c" 3 4
                 1
# 4468 "project/nnn/src/nnn.c"
                              );
  dup2(pipefd[1], 
# 4469 "project/nnn/src/nnn.c" 3 4
                 2
# 4469 "project/nnn/src/nnn.c"
                              );
  close(pipefd[1]);
  execvp(*argv, argv);
  _exit(
# 4472 "project/nnn/src/nnn.c" 3 4
       0
# 4472 "project/nnn/src/nnn.c"
                   );
 }


 waitpid(pid, 
# 4476 "project/nnn/src/nnn.c" 3 4
             ((void *)0)
# 4476 "project/nnn/src/nnn.c"
                 , 0);
 close(pipefd[1]);
 free(cmd);

 while ((len = read(pipefd[0], g_buf, (
# 4480 "project/nnn/src/nnn.c" 3 4
                                     1024 
# 4480 "project/nnn/src/nnn.c"
                                     + ((
# 4480 "project/nnn/src/nnn.c" 3 4
                                     255 
# 4480 "project/nnn/src/nnn.c"
                                     + 1) << 1)) - 1)) > 0) {
  ret = 
# 4481 "project/nnn/src/nnn.c" 3 4
       1
# 4481 "project/nnn/src/nnn.c"
           ;
  if (fdout == -1)
   break;
  if (write(fdout, g_buf, len) != len)
   break;
 }

 close(pipefd[0]);
 if (!page)
  return ret;

 if (tmpfile) {
  close(fdout);
  close(fd);
 }

 spawn(pager, g_tmpfpath, 
# 4497 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 4497 "project/nnn/src/nnn.c"
                             , 
# 4497 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 4497 "project/nnn/src/nnn.c"
                                   , (0x08 | 0x01) | 0x100);

 if (tmpfile)
  unlink(g_tmpfpath);

 return 
# 4502 "project/nnn/src/nnn.c" 3 4
       1
# 4502 "project/nnn/src/nnn.c"
           ;
}




static 
# 4508 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4508 "project/nnn/src/nnn.c"
           show_stats(char *fpath)
{
 static char * const cmds[] = {

  ("file " "-bIL"),

  "file -b",
  "stat",
 };

 size_t r = (sizeof(cmds) / sizeof(*(cmds)));
 int fd = create_tmp_file();
 if (fd == -1)
  return 
# 4521 "project/nnn/src/nnn.c" 3 4
        0
# 4521 "project/nnn/src/nnn.c"
             ;

 while (r)
  get_output(cmds[--r], fpath, 
# 4524 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 4524 "project/nnn/src/nnn.c"
                                  , fd, 
# 4524 "project/nnn/src/nnn.c" 3 4
                                        1
# 4524 "project/nnn/src/nnn.c"
                                            , 
# 4524 "project/nnn/src/nnn.c" 3 4
                                              0
# 4524 "project/nnn/src/nnn.c"
                                                   );

 close(fd);

 spawn(pager, g_tmpfpath, 
# 4528 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 4528 "project/nnn/src/nnn.c"
                             , 
# 4528 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 4528 "project/nnn/src/nnn.c"
                                   , (0x08 | 0x01) | 0x100);
 unlink(g_tmpfpath);
 return 
# 4530 "project/nnn/src/nnn.c" 3 4
       1
# 4530 "project/nnn/src/nnn.c"
           ;
}

static 
# 4533 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4533 "project/nnn/src/nnn.c"
           xchmod(const char *fpath, mode_t mode)
{

 (0100 & mode) ? (mode &= ~0111) : (mode |= 0111);

 return (chmod(fpath, mode) == 0);
}

static size_t get_fs_info(const char *path, 
# 4541 "project/nnn/src/nnn.c" 3 4
                                           _Bool 
# 4541 "project/nnn/src/nnn.c"
                                                type)
{
 struct statvfs svb;

 if (statvfs(path, &svb) == -1)
  return 0;

 if (type == 1)
  return (size_t)svb.f_blocks << ffs((int)(svb.f_frsize >> 1));

 return (size_t)svb.f_bavail << ffs((int)(svb.f_frsize >> 1));
}


static 
# 4555 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4555 "project/nnn/src/nnn.c"
           xmktree(char *path, 
# 4555 "project/nnn/src/nnn.c" 3 4
                               _Bool 
# 4555 "project/nnn/src/nnn.c"
                                    dir)
{
 char *p = path;
 char *slash = path;

 if (!p || !*p)
  return 
# 4561 "project/nnn/src/nnn.c" 3 4
        0
# 4561 "project/nnn/src/nnn.c"
             ;


 ++p;

 while (*p != '\0') {
  if (*p == '/') {
   slash = p;
   *p = '\0';
  } else {
   ++p;
   continue;
  }


  if (mkdir(path, 0777) == -1 && 
# 4576 "project/nnn/src/nnn.c" 3 4
                                (*__error()) 
# 4576 "project/nnn/src/nnn.c"
                                      != 
# 4576 "project/nnn/src/nnn.c" 3 4
                                         17
# 4576 "project/nnn/src/nnn.c"
                                               ) {
# 4586 "project/nnn/src/nnn.c"
   ;
   ;
   *slash = '/';
   return 
# 4589 "project/nnn/src/nnn.c" 3 4
         0
# 4589 "project/nnn/src/nnn.c"
              ;
  }





  *slash = '/';
  ++p;
 }

 if (dir) {
  if (mkdir(path, 0777) == -1 && 
# 4601 "project/nnn/src/nnn.c" 3 4
                                (*__error()) 
# 4601 "project/nnn/src/nnn.c"
                                      != 
# 4601 "project/nnn/src/nnn.c" 3 4
                                         17
# 4601 "project/nnn/src/nnn.c"
                                               ) {
   ;
   ;
   return 
# 4604 "project/nnn/src/nnn.c" 3 4
         0
# 4604 "project/nnn/src/nnn.c"
              ;
  }
 } else {
  int fd = open(path, 
# 4607 "project/nnn/src/nnn.c" 3 4
                     0x00000200
# 4607 "project/nnn/src/nnn.c"
                            , 0666);

  if (fd == -1 && 
# 4609 "project/nnn/src/nnn.c" 3 4
                 (*__error()) 
# 4609 "project/nnn/src/nnn.c"
                       != 
# 4609 "project/nnn/src/nnn.c" 3 4
                          17
# 4609 "project/nnn/src/nnn.c"
                                ) {
   ;
   ;
   return 
# 4612 "project/nnn/src/nnn.c" 3 4
         0
# 4612 "project/nnn/src/nnn.c"
              ;
  }

  close(fd);
 }

 return 
# 4618 "project/nnn/src/nnn.c" 3 4
       1
# 4618 "project/nnn/src/nnn.c"
           ;
}


static 
# 4622 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4622 "project/nnn/src/nnn.c"
           handle_archive(char *fpath , char op)
{
 char arg[] = "-tvf";
 char *util, *outdir = 
# 4625 "project/nnn/src/nnn.c" 3 4
                      ((void *)0)
# 4625 "project/nnn/src/nnn.c"
                          ;
 
# 4626 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4626 "project/nnn/src/nnn.c"
     x_to = 
# 4626 "project/nnn/src/nnn.c" 3 4
            0
# 4626 "project/nnn/src/nnn.c"
                 ;
 
# 4627 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4627 "project/nnn/src/nnn.c"
     is_atool = getutil(utils[1]);

 if (op == 'x') {
  outdir = xreadline(is_atool ? "." : xbasename(fpath), messages[19]);
  if (!outdir || !*outdir) {
   printwait(messages[4], 
# 4632 "project/nnn/src/nnn.c" 3 4
                                  ((void *)0)
# 4632 "project/nnn/src/nnn.c"
                                      );
   return 
# 4633 "project/nnn/src/nnn.c" 3 4
         0
# 4633 "project/nnn/src/nnn.c"
              ;
  }

  if (!(*outdir == '.' && outdir[1] == '\0')) {
   if (!xmktree(outdir, 
# 4637 "project/nnn/src/nnn.c" 3 4
                       1
# 4637 "project/nnn/src/nnn.c"
                           ) || (chdir(outdir) == -1)) {
    printwait(strerror(
# 4638 "project/nnn/src/nnn.c" 3 4
   (*__error())
# 4638 "project/nnn/src/nnn.c"
   ), 
# 4638 "project/nnn/src/nnn.c" 3 4
   ((void *)0)
# 4638 "project/nnn/src/nnn.c"
   );
    return 
# 4639 "project/nnn/src/nnn.c" 3 4
          0
# 4639 "project/nnn/src/nnn.c"
               ;
   }

   outdir = getcwd(
# 4642 "project/nnn/src/nnn.c" 3 4
                  ((void *)0)
# 4642 "project/nnn/src/nnn.c"
                      , 0);
   x_to = 
# 4643 "project/nnn/src/nnn.c" 3 4
         1
# 4643 "project/nnn/src/nnn.c"
             ;
  }
 }

 if (is_atool) {
  util = utils[1];
  arg[1] = op;
  arg[2] = '\0';
 } else if (getutil(utils[2])) {
  util = utils[2];
  if (op == 'x')
   arg[1] = op;
 } else if (is_suffix(fpath, ".zip")) {
  util = utils[3];
  arg[1] = (op == 'l') ? 'v' : '\0';
  arg[2] = '\0';
 } else {
  util = utils[4];
  if (op == 'x')
   arg[1] = op;
 }

 if (op == 'x')
  spawn(util, arg, fpath, 
# 4666 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 4666 "project/nnn/src/nnn.c"
                             , 0x08 | 0x01);
 else
  get_output(util, arg, fpath, -1, 
# 4668 "project/nnn/src/nnn.c" 3 4
                                  1
# 4668 "project/nnn/src/nnn.c"
                                      , 
# 4668 "project/nnn/src/nnn.c" 3 4
                                        1
# 4668 "project/nnn/src/nnn.c"
                                            );

 if (x_to) {
  if (chdir(xdirname(fpath)) == -1) {
   printwait(strerror(
# 4672 "project/nnn/src/nnn.c" 3 4
  (*__error())
# 4672 "project/nnn/src/nnn.c"
  ), 
# 4672 "project/nnn/src/nnn.c" 3 4
  ((void *)0)
# 4672 "project/nnn/src/nnn.c"
  );
   free(outdir);
   return 
# 4674 "project/nnn/src/nnn.c" 3 4
         0
# 4674 "project/nnn/src/nnn.c"
              ;
  }
  xstrsncpy(fpath, outdir, 
# 4676 "project/nnn/src/nnn.c" 3 4
                          1024
# 4676 "project/nnn/src/nnn.c"
                                  );
  free(outdir);
 } else if (op == 'x')
  fpath[0] = '\0';

 return 
# 4681 "project/nnn/src/nnn.c" 3 4
       1
# 4681 "project/nnn/src/nnn.c"
           ;
}

static char *visit_parent(char *path, char *newpath, int *presel)
{
 char *dir;


 if (((path)[1] == '\0' && (path)[0] == '/')) {

  if (cfg.filtermode && presel)
   *presel = '/';
  return 
# 4693 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 4693 "project/nnn/src/nnn.c"
            ;
 }


 if (newpath)
  xstrsncpy(newpath, path, 
# 4698 "project/nnn/src/nnn.c" 3 4
                          1024
# 4698 "project/nnn/src/nnn.c"
                                  );
 else
  newpath = path;

 dir = xdirname(newpath);
 if (chdir(dir) == -1) {
  printwait(strerror(
# 4704 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 4704 "project/nnn/src/nnn.c"
 ), presel);
  return 
# 4705 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 4705 "project/nnn/src/nnn.c"
            ;
 }

 return dir;
}

static void valid_parent(char *path, char *lastname)
{

 xstrsncpy(lastname, xbasename(path), 
# 4714 "project/nnn/src/nnn.c" 3 4
                                     255 
# 4714 "project/nnn/src/nnn.c"
                                              + 1);

 while (!((path)[1] == '\0' && (path)[0] == '/'))
  if (visit_parent(path, 
# 4717 "project/nnn/src/nnn.c" 3 4
                        ((void *)0)
# 4717 "project/nnn/src/nnn.c"
                            , 
# 4717 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 4717 "project/nnn/src/nnn.c"
                                  ))
   break;

 printwait(strerror(
# 4720 "project/nnn/src/nnn.c" 3 4
(*__error())
# 4720 "project/nnn/src/nnn.c"
), 
# 4720 "project/nnn/src/nnn.c" 3 4
((void *)0)
# 4720 "project/nnn/src/nnn.c"
);
 xdelay((350000));
}

static 
# 4724 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4724 "project/nnn/src/nnn.c"
           archive_mount(char *newpath)
{
 char *str = "install archivemount";
 char *dir, *cmd = str + 8;
 char *name = pdents[cur].name;
 size_t len = pdents[cur].nlen;
 char mntpath[
# 4730 "project/nnn/src/nnn.c" 3 4
             1024
# 4730 "project/nnn/src/nnn.c"
                     ];

 if (!getutil(cmd)) {
  printmsg(str);
  return 
# 4734 "project/nnn/src/nnn.c" 3 4
        0
# 4734 "project/nnn/src/nnn.c"
             ;
 }

 dir = xstrdup(name);
 if (!dir) {
  printmsg(messages[5]);
  return 
# 4740 "project/nnn/src/nnn.c" 3 4
        0
# 4740 "project/nnn/src/nnn.c"
             ;
 }

 while (len > 1)
  if (dir[--len] == '.') {
   dir[len] = '\0';
   break;
  }

 ;


 mkpath(cfgpath, toks[2], mntpath);
 mkpath(mntpath, dir, newpath);
 free(dir);

 if (!xmktree(newpath, 
# 4756 "project/nnn/src/nnn.c" 3 4
                      1
# 4756 "project/nnn/src/nnn.c"
                          )) {
  printwait(strerror(
# 4757 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 4757 "project/nnn/src/nnn.c"
 ), 
# 4757 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 4757 "project/nnn/src/nnn.c"
 );
  return 
# 4758 "project/nnn/src/nnn.c" 3 4
        0
# 4758 "project/nnn/src/nnn.c"
             ;
 }


 ;
 ;
 if (spawn(cmd, name, newpath, 
# 4764 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 4764 "project/nnn/src/nnn.c"
                                  , 0x08)) {
  printmsg(messages[5]);
  return 
# 4766 "project/nnn/src/nnn.c" 3 4
        0
# 4766 "project/nnn/src/nnn.c"
             ;
 }

 return 
# 4769 "project/nnn/src/nnn.c" 3 4
       1
# 4769 "project/nnn/src/nnn.c"
           ;
}

static 
# 4772 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4772 "project/nnn/src/nnn.c"
           remote_mount(char *newpath)
{
 uchar_t flag = (0x08 | 0x01);
 int opt;
 char *tmp, *env;
 
# 4777 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4777 "project/nnn/src/nnn.c"
     r = getutil(utils[10]), s = getutil(utils[9]);
 char mntpath[
# 4778 "project/nnn/src/nnn.c" 3 4
             1024
# 4778 "project/nnn/src/nnn.c"
                     ];

 if (!(r || s)) {
  printmsg("install sshfs/rclone");
  return 
# 4782 "project/nnn/src/nnn.c" 3 4
        0
# 4782 "project/nnn/src/nnn.c"
             ;
 }

 if (r && s)
  opt = get_input(messages[30]);
 else
  opt = (!s) ? 'r' : 's';

 if (opt == 's')
  env = xgetenv("NNN_SSHFS", utils[9]);
 else if (opt == 'r') {
  flag |= 0x02 | 0x04;
  env = xgetenv("NNN_RCLONE", "rclone mount");
 } else {
  printmsg(messages[40]);
  return 
# 4797 "project/nnn/src/nnn.c" 3 4
        0
# 4797 "project/nnn/src/nnn.c"
             ;
 }

 tmp = xreadline(
# 4800 "project/nnn/src/nnn.c" 3 4
                ((void *)0)
# 4800 "project/nnn/src/nnn.c"
                    , "host[:dir] > ");
 if (!tmp[0]) {
  printmsg(messages[4]);
  return 
# 4803 "project/nnn/src/nnn.c" 3 4
        0
# 4803 "project/nnn/src/nnn.c"
             ;
 }

 char *div = strchr(tmp, ':');

 if (div)
  *div = '\0';


 mkpath(cfgpath, toks[2], mntpath);
 mkpath(mntpath, tmp, newpath);
 if (!xmktree(newpath, 
# 4814 "project/nnn/src/nnn.c" 3 4
                      1
# 4814 "project/nnn/src/nnn.c"
                          )) {
  printwait(strerror(
# 4815 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 4815 "project/nnn/src/nnn.c"
 ), 
# 4815 "project/nnn/src/nnn.c" 3 4
 ((void *)0)
# 4815 "project/nnn/src/nnn.c"
 );
  return 
# 4816 "project/nnn/src/nnn.c" 3 4
        0
# 4816 "project/nnn/src/nnn.c"
             ;
 }

 if (!div) {
  size_t len = xstrlen(tmp);

  tmp[len] = ':';
  tmp[len + 1] = '\0';
 } else
  *div = ':';


 if (opt == 's') {
  if (spawn(env, tmp, newpath, 
# 4829 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 4829 "project/nnn/src/nnn.c"
                                  , flag)) {
   printmsg(messages[5]);
   return 
# 4831 "project/nnn/src/nnn.c" 3 4
         0
# 4831 "project/nnn/src/nnn.c"
              ;
  }
 } else {
  spawn(env, tmp, newpath, 
# 4834 "project/nnn/src/nnn.c" 3 4
                          ((void *)0)
# 4834 "project/nnn/src/nnn.c"
                              , flag);
  printmsg(messages[31]);
  xdelay((350000) << 2);
 }

 return 
# 4839 "project/nnn/src/nnn.c" 3 4
       1
# 4839 "project/nnn/src/nnn.c"
           ;
}






static 
# 4847 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 4847 "project/nnn/src/nnn.c"
           unmount(char *name, char *newpath, int *presel, char *currentpath)
{

 static char cmd[] = "umount";




 char *tmp = name;
 struct stat sb, psb;
 
# 4857 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4857 "project/nnn/src/nnn.c"
     child = 
# 4857 "project/nnn/src/nnn.c" 3 4
             0
# 4857 "project/nnn/src/nnn.c"
                  ;
 
# 4858 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4858 "project/nnn/src/nnn.c"
     parent = 
# 4858 "project/nnn/src/nnn.c" 3 4
              0
# 4858 "project/nnn/src/nnn.c"
                   ;
 
# 4859 "project/nnn/src/nnn.c" 3 4
_Bool 
# 4859 "project/nnn/src/nnn.c"
     hovered = 
# 4859 "project/nnn/src/nnn.c" 3 4
               0
# 4859 "project/nnn/src/nnn.c"
                    ;
 char mntpath[
# 4860 "project/nnn/src/nnn.c" 3 4
             1024
# 4860 "project/nnn/src/nnn.c"
                     ];
# 4870 "project/nnn/src/nnn.c"
 mkpath(cfgpath, toks[2], mntpath);

 if (tmp && strcmp(mntpath, currentpath) == 0) {
  mkpath(mntpath, tmp, newpath);
  child = lstat(newpath, &sb) != -1;
  parent = lstat(xdirname(newpath), &psb) != -1;
  if (!child && !parent) {
   *presel = '$';
   return 
# 4878 "project/nnn/src/nnn.c" 3 4
         0
# 4878 "project/nnn/src/nnn.c"
              ;
  }
 }

 if (!tmp || !child || !
# 4882 "project/nnn/src/nnn.c" 3 4
                       (((
# 4882 "project/nnn/src/nnn.c"
                       sb.st_mode
# 4882 "project/nnn/src/nnn.c" 3 4
                       ) & 0170000) == 0040000) 
# 4882 "project/nnn/src/nnn.c"
                                           || (child && parent && sb.st_dev == psb.st_dev)) {
  tmp = xreadline(
# 4883 "project/nnn/src/nnn.c" 3 4
                 ((void *)0)
# 4883 "project/nnn/src/nnn.c"
                     , messages[16]);
  if (!tmp[0])
   return 
# 4885 "project/nnn/src/nnn.c" 3 4
         0
# 4885 "project/nnn/src/nnn.c"
              ;
  if (name && (tmp[0] == '-') && (tmp[1] == '\0')) {
   mkpath(currentpath, name, newpath);
   hovered = 
# 4888 "project/nnn/src/nnn.c" 3 4
            1
# 4888 "project/nnn/src/nnn.c"
                ;
  }
 }

 if (!hovered)
  mkpath(mntpath, tmp, newpath);

 if (!xdiraccess(newpath)) {
  *presel = '$';
  return 
# 4897 "project/nnn/src/nnn.c" 3 4
        0
# 4897 "project/nnn/src/nnn.c"
             ;
 }


 if (spawn(cmd, newpath, 
# 4901 "project/nnn/src/nnn.c" 3 4
                        ((void *)0)
# 4901 "project/nnn/src/nnn.c"
                            , 
# 4901 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 4901 "project/nnn/src/nnn.c"
                                  , 0x08)) {



  if (!xconfirm(get_input(messages[37])))
   return 
# 4906 "project/nnn/src/nnn.c" 3 4
         0
# 4906 "project/nnn/src/nnn.c"
              ;


  if (spawn(cmd, "-l", newpath, 
# 4909 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 4909 "project/nnn/src/nnn.c"
                                   , 0x08)) {





   printwait(messages[5], presel);
   return 
# 4916 "project/nnn/src/nnn.c" 3 4
         0
# 4916 "project/nnn/src/nnn.c"
              ;
  }
 }

 if (rmdir(newpath) == -1) {
  printwait(strerror(
# 4921 "project/nnn/src/nnn.c" 3 4
 (*__error())
# 4921 "project/nnn/src/nnn.c"
 ), presel);
  return 
# 4922 "project/nnn/src/nnn.c" 3 4
        0
# 4922 "project/nnn/src/nnn.c"
             ;
 }

 return 
# 4925 "project/nnn/src/nnn.c" 3 4
       1
# 4925 "project/nnn/src/nnn.c"
           ;
}

static void lock_terminal(void)
{
 spawn(xgetenv("NNN_LOCKER", utils[5]), 
# 4930 "project/nnn/src/nnn.c" 3 4
                                                 ((void *)0)
# 4930 "project/nnn/src/nnn.c"
                                                     , 
# 4930 "project/nnn/src/nnn.c" 3 4
                                                       ((void *)0)
# 4930 "project/nnn/src/nnn.c"
                                                           , 
# 4930 "project/nnn/src/nnn.c" 3 4
                                                             ((void *)0)
# 4930 "project/nnn/src/nnn.c"
                                                                 , (0x08 | 0x01));
}

static void printkv(kv *kvarr, int fd, uchar_t max, uchar_t id)
{
 char *val = (id == 1) ? bmstr : pluginstr;

 for (uchar_t i = 0; i < max && kvarr[i].key; ++i)
  dprintf(fd, " %c: %s\n", (char)kvarr[i].key, val + kvarr[i].off);
}

static void printkeys(kv *kvarr, char *buf, uchar_t max)
{
 uchar_t i = 0;

 for (; i < max && kvarr[i].key; ++i) {
  buf[i << 1] = ' ';
  buf[(i << 1) + 1] = kvarr[i].key;
 }

 buf[i << 1] = '\0';
}

static size_t handle_bookmark(const char *bmark, char *newpath)
{
 int fd = '\r';
 size_t r;

 if (maxbm || bmark) {
  r = xstrsncpy(g_buf, messages[34], (
# 4959 "project/nnn/src/nnn.c" 3 4
                                          1024 
# 4959 "project/nnn/src/nnn.c"
                                          + ((
# 4959 "project/nnn/src/nnn.c" 3 4
                                          255 
# 4959 "project/nnn/src/nnn.c"
                                          + 1) << 1)));

  if (bmark) {
   g_buf[--r] = ' ';
   g_buf[++r] = ',';
   g_buf[++r] = '\0';
   ++r;
  }
  printkeys(bookmark, g_buf + r - 1, maxbm);
  printmsg(g_buf);
  fd = get_input(
# 4969 "project/nnn/src/nnn.c" 3 4
                ((void *)0)
# 4969 "project/nnn/src/nnn.c"
                    );
 }

 r = 
# 4972 "project/nnn/src/nnn.c" 3 4
    0
# 4972 "project/nnn/src/nnn.c"
         ;
 if (fd == ',')
  bmark ? xstrsncpy(newpath, bmark, 
# 4974 "project/nnn/src/nnn.c" 3 4
                                   1024
# 4974 "project/nnn/src/nnn.c"
                                           ) : (r = 27);
 else if (fd == '\r')
  mkpath(cfgpath, toks[0], newpath);
 else if (!get_kv_val(bookmark, newpath, fd, maxbm, 1))
  r = 40;

 if (!r && chdir(newpath) == -1)
  r = 24;

 return r;
}

static void add_bookmark(char *path, char *newpath, int *presel)
{
 char *dir = xbasename(path);

 dir = xreadline(dir[0] ? dir : 
# 4990 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 4990 "project/nnn/src/nnn.c"
                                   , "name: ");
 if (dir && *dir) {
  size_t r = mkpath(cfgpath, toks[0], newpath);

  newpath[r - 1] = '/';
  xstrsncpy(newpath + r, dir, 
# 4995 "project/nnn/src/nnn.c" 3 4
                             1024 
# 4995 "project/nnn/src/nnn.c"
                                      - r);
  printwait((symlink(path, newpath) == -1) ? strerror(
# 4996 "project/nnn/src/nnn.c" 3 4
                                                     (*__error())
# 4996 "project/nnn/src/nnn.c"
                                                          ) : newpath, presel);
 } else
  printwait(messages[4], presel);
}
# 5009 "project/nnn/src/nnn.c"
static void show_help(const char *path)
{
 const char *start, *end;
 const char helpstr[] = {
 "0\n"
 "1NAVIGATION\n"
        "9Up k  Up%-16cPgUp ^U  Page up\n"
        "9Dn j  Down%-14cPgDn ^D  Page down\n"
        "9Lt h  Parent%-12c~ ` @ -  ~, /, start, prev\n"
    "5Ret Rt l  Open%-20c'  First file/match\n"
        "9g ^A  Top%-21c.  Toggle hidden\n"
        "9G ^E  End%-21c+  Toggle auto-advance\n"
       "8B (,)  Book(mark)%-11cb ^/  Select bookmark\n"
  "a1-4  Context%-11c(Sh)Tab  Cycle/new context\n"
     "62Esc ^Q  Quit%-20cq  Quit context\n"
   "b^G  QuitCD%-18cQ  Pick/err, quit\n"
 "0\n"
 "1FILTER & PROMPT\n"
    "c/  Filter%-17c^N  Toggle type-to-nav\n"
  "aEsc  Exit prompt%-12c^L  Toggle last filter\n"
   "d%-20cAlt+Esc  Unfilter, quit context\n"
 "0\n"
 "1FILES\n"
        "9o ^O  Open with%-15cn  Create new/link\n"
        "9f ^F  File stats%-14cd  Detail mode toggle\n"
   "b^R  Rename/dup%-14cr  Batch rename\n"
    "cz  Archive%-17ce  Edit file\n"
    "c*  Toggle exe%-14c>  Export list\n"
    "5Space ^J  (Un)select%-12cm-m  Select range/clear\n"
           "ca  Select all%-14cA  Invert sel\n"
        "9p ^P  Copy here%-12cw ^W  Cp/mv sel as\n"
        "9v ^V  Move here%-15cE  Edit sel list\n"
        "9x ^X  Delete%-16cEsc  Send to FIFO\n"
 "0\n"
 "1MISC\n"
       "8Alt ;  Select plugin%-11c=  Launch app\n"
        "9! ^]  Shell%-19c]  Cmd prompt\n"
    "cc  Connect remote%-10cu  Unmount remote/archive\n"
        "9t ^T  Sort toggles%-12cs  Manage session\n"
    "cT  Set time type%-11c0  Lock\n"
   "b^L  Redraw%-18c?  Help, conf\n"
 };

 int fd = create_tmp_file();
 if (fd == -1)
  return;

 dprintf(fd, "  |V\\_\n"
      "  /. \\\\\n"
      " (;^; ||\n"
      "   /___3\n"
      "  (___n))\n");

 char *prog = xgetenv(env_cfg[12], 
# 5062 "project/nnn/src/nnn.c" 3 4
                                        ((void *)0)
# 5062 "project/nnn/src/nnn.c"
                                            );
 if (prog)
  get_output(prog, 
# 5064 "project/nnn/src/nnn.c" 3 4
                  ((void *)0)
# 5064 "project/nnn/src/nnn.c"
                      , 
# 5064 "project/nnn/src/nnn.c" 3 4
                        ((void *)0)
# 5064 "project/nnn/src/nnn.c"
                            , fd, 
# 5064 "project/nnn/src/nnn.c" 3 4
                                  1
# 5064 "project/nnn/src/nnn.c"
                                      , 
# 5064 "project/nnn/src/nnn.c" 3 4
                                        0
# 5064 "project/nnn/src/nnn.c"
                                             );

 start = end = helpstr;
 while (*end) {
  if (*end == '\n') {
   
# 5069 "project/nnn/src/nnn.c" 3 4
  __builtin___snprintf_chk (
# 5069 "project/nnn/src/nnn.c"
  g_buf
# 5069 "project/nnn/src/nnn.c" 3 4
  , 
# 5069 "project/nnn/src/nnn.c"
  (
# 5069 "project/nnn/src/nnn.c" 3 4
  1024 
# 5069 "project/nnn/src/nnn.c"
  + ((
# 5069 "project/nnn/src/nnn.c" 3 4
  255 
# 5069 "project/nnn/src/nnn.c"
  + 1) << 1))
# 5069 "project/nnn/src/nnn.c" 3 4
  , 0, __builtin_object_size (
# 5069 "project/nnn/src/nnn.c"
  g_buf
# 5069 "project/nnn/src/nnn.c" 3 4
  , 2 > 1 ? 1 : 0), 
# 5069 "project/nnn/src/nnn.c"
  "%*c%.*s", xchartohex(*start), ' ', (int)(end - start), start + 1
# 5069 "project/nnn/src/nnn.c" 3 4
  )
                                                            
# 5070 "project/nnn/src/nnn.c"
                                                           ;
   dprintf(fd, g_buf, ' ');
   start = end + 1;
  }

  ++end;
 }

 dprintf(fd, "\nLOCATIONS:\n");
 for (uchar_t i = 0; i < 4; ++i)
  if (g_ctx[i].c_cfg.ctxactive)
   dprintf(fd, " %u: %s\n", i + 1, g_ctx[i].c_path);

 dprintf(fd, "\nVOLUME: %s of ", coolsize(get_fs_info(path, 0)));
 dprintf(fd, "%s free\n\n", coolsize(get_fs_info(path, 1)));

 if (bookmark) {
  dprintf(fd, "BOOKMARKS\n");
  printkv(bookmark, fd, maxbm, 1);
  dprintf(fd, "\n");
 }

 if (plug) {
  dprintf(fd, "PLUGIN KEYS\n");
  printkv(plug, fd, maxplug, 2);
  dprintf(fd, "\n");
 }

 for (uchar_t i = 3; i <= 13; ++i) {
  start = getenv(env_cfg[i]);
  if (start)
   dprintf(fd, "%s: %s\n", env_cfg[i], start);
 }

 if (selpath)
  dprintf(fd, "SELECTION FILE: %s\n", selpath);

 dprintf(fd, "\nv%s\n%s\n", "4.4", "BSD 2-Clause\nhttps://github.com/jarun/nnn");
 close(fd);

 spawn(pager, g_tmpfpath, 
# 5110 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 5110 "project/nnn/src/nnn.c"
                             , 
# 5110 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 5110 "project/nnn/src/nnn.c"
                                   , (0x08 | 0x01) | 0x100);
 unlink(g_tmpfpath);
}

static void setexports(void)
{
 char dvar[] = "d0";
 char fvar[] = "f0";

 if (ndents) {
  setenv(envs[4], pdents[cur].name, 1);
  xstrsncpy(g_ctx[cfg.curctx].c_name, pdents[cur].name, 
# 5121 "project/nnn/src/nnn.c" 3 4
                                                       255 
# 5121 "project/nnn/src/nnn.c"
                                                                + 1);
 } else if (g_ctx[cfg.curctx].c_name[0])
  g_ctx[cfg.curctx].c_name[0] = '\0';

 for (uchar_t i = 0; i < 4; ++i) {
  if (g_ctx[i].c_cfg.ctxactive) {
   dvar[1] = fvar[1] = '1' + i;
   setenv(dvar, g_ctx[i].c_path, 1);

   if (g_ctx[i].c_name[0]) {
    mkpath(g_ctx[i].c_path, g_ctx[i].c_name, g_buf);
    setenv(fvar, g_buf, 1);
   }
  }
 }
}

static 
# 5138 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 5138 "project/nnn/src/nnn.c"
           run_cmd_as_plugin(const char *file, char *runfile, uchar_t flags)
{
 size_t len;

 xstrsncpy(g_buf, file, 
# 5142 "project/nnn/src/nnn.c" 3 4
                       1024
# 5142 "project/nnn/src/nnn.c"
                               );

 len = xstrlen(g_buf);
 if (len > 1 && g_buf[len - 1] == '*') {
  flags &= ~0x10;
  g_buf[len - 1] = '\0';
  --len;
 }

 if (flags & 0x80)
  get_output(g_buf, 
# 5152 "project/nnn/src/nnn.c" 3 4
                   ((void *)0)
# 5152 "project/nnn/src/nnn.c"
                       , 
# 5152 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 5152 "project/nnn/src/nnn.c"
                             , -1, 
# 5152 "project/nnn/src/nnn.c" 3 4
                                   1
# 5152 "project/nnn/src/nnn.c"
                                       , 
# 5152 "project/nnn/src/nnn.c" 3 4
                                         1
# 5152 "project/nnn/src/nnn.c"
                                             );
 else if (flags & 0x04) {
  if (is_suffix(g_buf, " $nnn"))
   g_buf[len - 5] = '\0';
  else
   runfile = 
# 5157 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 5157 "project/nnn/src/nnn.c"
                ;
  spawn(g_buf, runfile, 
# 5158 "project/nnn/src/nnn.c" 3 4
                       ((void *)0)
# 5158 "project/nnn/src/nnn.c"
                           , 
# 5158 "project/nnn/src/nnn.c" 3 4
                             ((void *)0)
# 5158 "project/nnn/src/nnn.c"
                                 , flags);
 } else
  spawn(utils[7], g_buf, 
# 5160 "project/nnn/src/nnn.c" 3 4
                                   ((void *)0)
# 5160 "project/nnn/src/nnn.c"
                                       , 
# 5160 "project/nnn/src/nnn.c" 3 4
                                         ((void *)0)
# 5160 "project/nnn/src/nnn.c"
                                             , flags);

 return 
# 5162 "project/nnn/src/nnn.c" 3 4
       1
# 5162 "project/nnn/src/nnn.c"
           ;
}

static 
# 5165 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 5165 "project/nnn/src/nnn.c"
           plctrl_init(void)
{
 size_t len;


 g_tmpfpath[tmpfplen - 1] = '\0';
 len = xstrsncpy(g_pipepath, g_tmpfpath, 64);
 g_pipepath[len - 1] = '/';
 len = xstrsncpy(g_pipepath + len, "nnn-pipe.", 64 - len) + len;
 xstrsncpy(g_pipepath + len - 1, xitoa(getpid()), 64 - len);
 setenv(env_cfg[7], g_pipepath, 
# 5175 "project/nnn/src/nnn.c" 3 4
                                      1
# 5175 "project/nnn/src/nnn.c"
                                          );

 return 
# 5177 "project/nnn/src/nnn.c" 3 4
       0
# 5177 "project/nnn/src/nnn.c"
                   ;
}

static void rmlistpath(void)
{
 if (listpath) {
  ;
  ;
  spawn(utils[20], listpath, 
# 5185 "project/nnn/src/nnn.c" 3 4
                                    ((void *)0)
# 5185 "project/nnn/src/nnn.c"
                                        , 
# 5185 "project/nnn/src/nnn.c" 3 4
                                          ((void *)0)
# 5185 "project/nnn/src/nnn.c"
                                              , 0x04 | 0x01);

  if (listpath != initpath)
   free(listpath);
  listpath = 
# 5189 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 5189 "project/nnn/src/nnn.c"
                ;
 }
}

static ssize_t read_nointr(int fd, void *buf, size_t count)
{
 ssize_t len;

 do
  len = read(fd, buf, count);
 while (len == -1 && 
# 5199 "project/nnn/src/nnn.c" 3 4
                    (*__error()) 
# 5199 "project/nnn/src/nnn.c"
                          == 
# 5199 "project/nnn/src/nnn.c" 3 4
                             4
# 5199 "project/nnn/src/nnn.c"
                                  );

 return len;
}

static char *readpipe(int fd, char *ctxnum, char **path)
{
 char ctx, *nextpath = 
# 5206 "project/nnn/src/nnn.c" 3 4
                      ((void *)0)
# 5206 "project/nnn/src/nnn.c"
                          ;

 if (read_nointr(fd, g_buf, 1) != 1)
  return 
# 5209 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 5209 "project/nnn/src/nnn.c"
            ;

 if (g_buf[0] == '-') {
  clearselection();
  if (read_nointr(fd, g_buf, 1) != 1)
   return 
# 5214 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 5214 "project/nnn/src/nnn.c"
             ;
 }

 if (g_buf[0] == '+')
  ctx = (char)(get_free_ctx() + 1);
 else if (g_buf[0] < '0')
  return 
# 5220 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 5220 "project/nnn/src/nnn.c"
            ;
 else {
  ctx = g_buf[0] - '0';
  if (ctx > 4)
   return 
# 5224 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 5224 "project/nnn/src/nnn.c"
             ;
 }

 if (read_nointr(fd, g_buf, 1) != 1)
  return 
# 5228 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 5228 "project/nnn/src/nnn.c"
            ;

 char op = g_buf[0];

 if (op == 'c') {
  ssize_t len = read_nointr(fd, g_buf, 
# 5233 "project/nnn/src/nnn.c" 3 4
                                      1024
# 5233 "project/nnn/src/nnn.c"
                                              );

  if (len <= 0)
   return 
# 5236 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 5236 "project/nnn/src/nnn.c"
             ;

  g_buf[len] = '\0';
  if (g_buf[0] == '/') {
   nextpath = g_buf;
   len = xstrlen(g_buf);
   while (--len && (g_buf[len] == '/'))
    g_buf[len] = '\0';
  }
 } else if (op == 'l') {
  rmlistpath();
  nextpath = load_input(fd, *path);
 } else if (op == 'p') {
  free(selpath);
  selpath = 
# 5250 "project/nnn/src/nnn.c" 3 4
           ((void *)0)
# 5250 "project/nnn/src/nnn.c"
               ;
  clearselection();
  g_state.picker = 0;
  g_state.picked = 1;
 }

 *ctxnum = ctx;

 return nextpath;
}

static 
# 5261 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 5261 "project/nnn/src/nnn.c"
           run_plugin(char **path, const char *file, char *runfile, char **lastname, char **lastdir)
{
 pid_t p;
 char ctx = 0;
 uchar_t flags = 0;
 
# 5266 "project/nnn/src/nnn.c" 3 4
_Bool 
# 5266 "project/nnn/src/nnn.c"
     cmd_as_plugin = 
# 5266 "project/nnn/src/nnn.c" 3 4
                     0
# 5266 "project/nnn/src/nnn.c"
                          ;
 char *nextpath;

 if (!g_state.pluginit) {
  plctrl_init();
  g_state.pluginit = 1;
 }

 setexports();


 if (*file == '!') {
  flags = 0x01 | 0x10;
  ++file;

  if (*file == '|') {
   flags |= 0x80;
   ++file;
  } else if (*file == '&') {
   flags = 0x04 | 0x02;
   ++file;
  }

  if (!*file)
   return 
# 5290 "project/nnn/src/nnn.c" 3 4
         0
# 5290 "project/nnn/src/nnn.c"
              ;

  if ((flags & 0x04) || (flags & 0x80))
   return run_cmd_as_plugin(file, runfile, flags);

  cmd_as_plugin = 
# 5295 "project/nnn/src/nnn.c" 3 4
                 1
# 5295 "project/nnn/src/nnn.c"
                     ;
 }

 if (mkfifo(g_pipepath, 0600) != 0)
  return 
# 5299 "project/nnn/src/nnn.c" 3 4
        0
# 5299 "project/nnn/src/nnn.c"
             ;

 endwin();

 p = fork();

 if (!p) {
  int wfd = open(g_pipepath, 
# 5306 "project/nnn/src/nnn.c" 3 4
                            0x0001 
# 5306 "project/nnn/src/nnn.c"
                                     | 
# 5306 "project/nnn/src/nnn.c" 3 4
                                       0x01000000
# 5306 "project/nnn/src/nnn.c"
                                                );

  if (wfd == -1)
   _exit(
# 5309 "project/nnn/src/nnn.c" 3 4
        1
# 5309 "project/nnn/src/nnn.c"
                    );

  if (!cmd_as_plugin) {
   char *sel = 
# 5312 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 5312 "project/nnn/src/nnn.c"
                  ;
   char std[2] = "-";


   mkpath(plgpath, file, g_buf);

   if (g_state.picker)
    sel = selpath ? selpath : std;

   if (runfile && runfile[0]) {
    xstrsncpy(*lastname, runfile, 
# 5322 "project/nnn/src/nnn.c" 3 4
                                 255
# 5322 "project/nnn/src/nnn.c"
                                         );
    spawn(g_buf, *lastname, *path, sel, 0);
   } else
    spawn(g_buf, 
# 5325 "project/nnn/src/nnn.c" 3 4
                ((void *)0)
# 5325 "project/nnn/src/nnn.c"
                    , *path, sel, 0);
  } else
   run_cmd_as_plugin(file, 
# 5327 "project/nnn/src/nnn.c" 3 4
                          ((void *)0)
# 5327 "project/nnn/src/nnn.c"
                              , flags);

  close(wfd);
  _exit(
# 5330 "project/nnn/src/nnn.c" 3 4
       0
# 5330 "project/nnn/src/nnn.c"
                   );
 }

 int rfd;

 do
  rfd = open(g_pipepath, 
# 5336 "project/nnn/src/nnn.c" 3 4
                        0x0000
# 5336 "project/nnn/src/nnn.c"
                                );
 while (rfd == -1 && 
# 5337 "project/nnn/src/nnn.c" 3 4
                    (*__error()) 
# 5337 "project/nnn/src/nnn.c"
                          == 
# 5337 "project/nnn/src/nnn.c" 3 4
                             4
# 5337 "project/nnn/src/nnn.c"
                                  );

 nextpath = readpipe(rfd, &ctx, path);
 if (nextpath)
  set_smart_ctx(ctx, nextpath, path, runfile, lastname, lastdir);

 close(rfd);


 waitpid(p, 
# 5346 "project/nnn/src/nnn.c" 3 4
           ((void *)0)
# 5346 "project/nnn/src/nnn.c"
               , 0);

 
# 5348 "project/nnn/src/nnn.c" 3 4
wrefresh(stdscr)
# 5348 "project/nnn/src/nnn.c"
         ;

 unlink(g_pipepath);

 return 
# 5352 "project/nnn/src/nnn.c" 3 4
       1
# 5352 "project/nnn/src/nnn.c"
           ;
}

static 
# 5355 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 5355 "project/nnn/src/nnn.c"
           launch_app(char *newpath)
{
 int r = 0x08;
 char *tmp = newpath;

 mkpath(plgpath, utils[6], newpath);

 if (!getutil(utils[14]) || access(newpath, 
# 5362 "project/nnn/src/nnn.c" 3 4
                                                 (1<<0)
# 5362 "project/nnn/src/nnn.c"
                                                     ) < 0) {
  tmp = xreadline(
# 5363 "project/nnn/src/nnn.c" 3 4
                 ((void *)0)
# 5363 "project/nnn/src/nnn.c"
                     , messages[32]);
  r = 0x02 | 0x04 | 0x01;
 }

 if (tmp && *tmp)
  spawn(tmp, (r == 0x08) ? "0" : 
# 5368 "project/nnn/src/nnn.c" 3 4
                                    ((void *)0)
# 5368 "project/nnn/src/nnn.c"
                                        , 
# 5368 "project/nnn/src/nnn.c" 3 4
                                          ((void *)0)
# 5368 "project/nnn/src/nnn.c"
                                              , 
# 5368 "project/nnn/src/nnn.c" 3 4
                                                ((void *)0)
# 5368 "project/nnn/src/nnn.c"
                                                    , r);

 return 
# 5370 "project/nnn/src/nnn.c" 3 4
       0
# 5370 "project/nnn/src/nnn.c"
            ;
}


static 
# 5374 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 5374 "project/nnn/src/nnn.c"
           prompt_run(void)
{
 
# 5376 "project/nnn/src/nnn.c" 3 4
_Bool 
# 5376 "project/nnn/src/nnn.c"
     ret = 
# 5376 "project/nnn/src/nnn.c" 3 4
           0
# 5376 "project/nnn/src/nnn.c"
                ;
 char *cmdline, *next;
 int cnt_j, cnt_J;
 size_t len;

 const char *xargs_j = "xargs -0 -I{} %s < %s";
 const char *xargs_J = "xargs -0 %s < %s";
 char cmd[(
# 5383 "project/nnn/src/nnn.c" 3 4
         1024 
# 5383 "project/nnn/src/nnn.c"
         + ((
# 5383 "project/nnn/src/nnn.c" 3 4
         255 
# 5383 "project/nnn/src/nnn.c"
         + 1) << 1)) + 32];

 while (1) {

  if (g_state.picker) {

   cmdline = xreadline(
# 5389 "project/nnn/src/nnn.c" 3 4
                      ((void *)0)
# 5389 "project/nnn/src/nnn.c"
                          , ">>> ");

  } else
   cmdline = getreadline("\n"">>> ");


  if (!cmdline || !cmdline[0])
   break;

  free(lastcmd);
  lastcmd = xstrdup(cmdline);
  ret = 
# 5400 "project/nnn/src/nnn.c" 3 4
       1
# 5400 "project/nnn/src/nnn.c"
           ;

  len = xstrlen(cmdline);

  cnt_j = 0;
  next = cmdline;
  while ((next = strstr(next, "%j"))) {
   ++cnt_j;


   next[0] = '{';
   next[1] = '}';

   ++next;
  }

  cnt_J = 0;
  next = cmdline;
  while ((next = strstr(next, "%J"))) {
   ++cnt_J;


   if (next == cmdline + len - 2) {
    cmdline[len - 2] = '\0';
   }

   ++next;
  }


  if (cnt_j && cnt_J)
   break;

  if (cnt_j)
   
# 5434 "project/nnn/src/nnn.c" 3 4
  __builtin___snprintf_chk (
# 5434 "project/nnn/src/nnn.c"
  cmd
# 5434 "project/nnn/src/nnn.c" 3 4
  , 
# 5434 "project/nnn/src/nnn.c"
  (
# 5434 "project/nnn/src/nnn.c" 3 4
  1024 
# 5434 "project/nnn/src/nnn.c"
  + ((
# 5434 "project/nnn/src/nnn.c" 3 4
  255 
# 5434 "project/nnn/src/nnn.c"
  + 1) << 1)) + 32
# 5434 "project/nnn/src/nnn.c" 3 4
  , 0, __builtin_object_size (
# 5434 "project/nnn/src/nnn.c"
  cmd
# 5434 "project/nnn/src/nnn.c" 3 4
  , 2 > 1 ? 1 : 0), 
# 5434 "project/nnn/src/nnn.c"
  xargs_j, cmdline, selpath
# 5434 "project/nnn/src/nnn.c" 3 4
  )
# 5434 "project/nnn/src/nnn.c"
                                                            ;
  else if (cnt_J)
   
# 5436 "project/nnn/src/nnn.c" 3 4
  __builtin___snprintf_chk (
# 5436 "project/nnn/src/nnn.c"
  cmd
# 5436 "project/nnn/src/nnn.c" 3 4
  , 
# 5436 "project/nnn/src/nnn.c"
  (
# 5436 "project/nnn/src/nnn.c" 3 4
  1024 
# 5436 "project/nnn/src/nnn.c"
  + ((
# 5436 "project/nnn/src/nnn.c" 3 4
  255 
# 5436 "project/nnn/src/nnn.c"
  + 1) << 1)) + 32
# 5436 "project/nnn/src/nnn.c" 3 4
  , 0, __builtin_object_size (
# 5436 "project/nnn/src/nnn.c"
  cmd
# 5436 "project/nnn/src/nnn.c" 3 4
  , 2 > 1 ? 1 : 0), 
# 5436 "project/nnn/src/nnn.c"
  xargs_J, cmdline, selpath
# 5436 "project/nnn/src/nnn.c" 3 4
  )
# 5436 "project/nnn/src/nnn.c"
                                                            ;

  spawn(shell, "-c", (cnt_j || cnt_J) ? cmd : cmdline, 
# 5438 "project/nnn/src/nnn.c" 3 4
                                                      ((void *)0)
# 5438 "project/nnn/src/nnn.c"
                                                          , (0x08 | 0x01) | 0x10);
 }

 return ret;
}

static 
# 5444 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 5444 "project/nnn/src/nnn.c"
           handle_cmd(enum action sel, char *newpath)
{
 endselection(
# 5446 "project/nnn/src/nnn.c" 3 4
             0
# 5446 "project/nnn/src/nnn.c"
                  );

 if (sel == SEL_LAUNCH)
  return launch_app(newpath);

 setexports();

 if (sel == SEL_PROMPT)
  return prompt_run();


 char *tmp = getenv(env_cfg[6]);
 int r = tmp ? atoi(tmp) : 0;

 setenv(env_cfg[6], xitoa(r + 1), 1);
 spawn(shell, 
# 5461 "project/nnn/src/nnn.c" 3 4
             ((void *)0)
# 5461 "project/nnn/src/nnn.c"
                 , 
# 5461 "project/nnn/src/nnn.c" 3 4
                   ((void *)0)
# 5461 "project/nnn/src/nnn.c"
                       , 
# 5461 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 5461 "project/nnn/src/nnn.c"
                             , (0x08 | 0x01));
 setenv(env_cfg[6], xitoa(r), 1);
 return 
# 5463 "project/nnn/src/nnn.c" 3 4
       1
# 5463 "project/nnn/src/nnn.c"
           ;
}

static void dentfree(void)
{
 free(pnamebuf);
 free(pdents);
 free(mark);


 free(core_blocks);
 free(core_data);
 free(core_files);
}

static void *du_thread(void *p_data)
{
 thread_data *pdata = (thread_data *)p_data;
 char *path[2] = {pdata->path, 
# 5481 "project/nnn/src/nnn.c" 3 4
                              ((void *)0)
# 5481 "project/nnn/src/nnn.c"
                                  };
 ullong_t tfiles = 0;
 blkcnt_t tblocks = 0;
 struct stat *sb;
 FTS *tree = fts_open(path, 
# 5485 "project/nnn/src/nnn.c" 3 4
                           0x010 
# 5485 "project/nnn/src/nnn.c"
                                        | 
# 5485 "project/nnn/src/nnn.c" 3 4
                                          0x040 
# 5485 "project/nnn/src/nnn.c"
                                                   | 
# 5485 "project/nnn/src/nnn.c" 3 4
                                                     0x004
# 5485 "project/nnn/src/nnn.c"
                                                                , 0);
 FTSENT *node;

 while ((node = fts_read(tree))) {
  if (node->fts_info & 
# 5489 "project/nnn/src/nnn.c" 3 4
                      1
# 5489 "project/nnn/src/nnn.c"
                           ) {
   if (g_state.interrupt)
    break;
   continue;
  }

  sb = node->fts_statp;

  if (cfg.apparentsz) {
   if (sb->st_size && (((node->fts_info & 
# 5498 "project/nnn/src/nnn.c" 3 4
                     8
# 5498 "project/nnn/src/nnn.c"
                     ) && (sb->st_nlink <= 1 || test_set_bit((uint_t)sb->st_ino))) || node->fts_info & 
# 5498 "project/nnn/src/nnn.c" 3 4
                     6
# 5498 "project/nnn/src/nnn.c"
                     ))
    tblocks += sb->st_size;
  } else if (sb->st_blocks && (((node->fts_info & 
# 5500 "project/nnn/src/nnn.c" 3 4
                             8
# 5500 "project/nnn/src/nnn.c"
                             ) && (sb->st_nlink <= 1 || test_set_bit((uint_t)sb->st_ino))) || node->fts_info & 
# 5500 "project/nnn/src/nnn.c" 3 4
                             6
# 5500 "project/nnn/src/nnn.c"
                             ))
   tblocks += sb->st_blocks;

  ++tfiles;
 }

 fts_close(tree);

 if (pdata->entnum >= 0)
  pdents[pdata->entnum].blocks = tblocks;

 if (!pdata->mntpoint) {
  core_blocks[pdata->core] += tblocks;
  core_files[pdata->core] += tfiles;
 } else
  core_files[pdata->core] += 1;

 pthread_mutex_lock(&running_mutex);
 threadbmp |= (1 << pdata->core);
 --active_threads;
 pthread_mutex_unlock(&running_mutex);

 return 
# 5522 "project/nnn/src/nnn.c" 3 4
       ((void *)0)
# 5522 "project/nnn/src/nnn.c"
           ;
}

static void dirwalk(char *path, int entnum, 
# 5525 "project/nnn/src/nnn.c" 3 4
                                           _Bool 
# 5525 "project/nnn/src/nnn.c"
                                                mountpoint)
{

 while (active_threads == (4));

 if (g_state.interrupt)
  return;

 pthread_mutex_lock(&running_mutex);
 int core = ffs(threadbmp) - 1;

 threadbmp &= ~(1 << core);
 ++active_threads;
 pthread_mutex_unlock(&running_mutex);

 xstrsncpy(core_data[core].path, path, 
# 5540 "project/nnn/src/nnn.c" 3 4
                                      1024
# 5540 "project/nnn/src/nnn.c"
                                              );
 core_data[core].entnum = entnum;
 core_data[core].core = (ushort_t)core;
 core_data[core].mntpoint = mountpoint;

 pthread_t tid = 0;

 pthread_create(&tid, 
# 5547 "project/nnn/src/nnn.c" 3 4
                     ((void *)0)
# 5547 "project/nnn/src/nnn.c"
                         , du_thread, (void *)&(core_data[core]));

 
# 5549 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 5549 "project/nnn/src/nnn.c"
xlines - 1
# 5549 "project/nnn/src/nnn.c" 3 4
,
# 5549 "project/nnn/src/nnn.c"
0
# 5549 "project/nnn/src/nnn.c" 3 4
)
# 5549 "project/nnn/src/nnn.c"
          ;
 
# 5550 "project/nnn/src/nnn.c" 3 4
waddnstr(stdscr,
# 5550 "project/nnn/src/nnn.c"
xbasename(path)
# 5550 "project/nnn/src/nnn.c" 3 4
,-1)
# 5550 "project/nnn/src/nnn.c"
                       ;
 
# 5551 "project/nnn/src/nnn.c" 3 4
waddnstr(stdscr,
# 5551 "project/nnn/src/nnn.c"
" [^C aborts]\n"
# 5551 "project/nnn/src/nnn.c" 3 4
,-1)
# 5551 "project/nnn/src/nnn.c"
                        ;
 
# 5552 "project/nnn/src/nnn.c" 3 4
wrefresh(stdscr)
# 5552 "project/nnn/src/nnn.c"
         ;
}

static void prep_threads(void)
{
 if (!g_state.duinit) {

  threadbmp >>= (32 - (4));

  core_blocks = calloc((4), sizeof(blkcnt_t));
  core_data = calloc((4), sizeof(thread_data));
  core_files = calloc((4), sizeof(ullong_t));





  g_state.duinit = 
# 5569 "project/nnn/src/nnn.c" 3 4
                  1
# 5569 "project/nnn/src/nnn.c"
                      ;
 } else {
  
# 5571 "project/nnn/src/nnn.c" 3 4
 __builtin___memset_chk (
# 5571 "project/nnn/src/nnn.c"
 core_blocks
# 5571 "project/nnn/src/nnn.c" 3 4
 , 
# 5571 "project/nnn/src/nnn.c"
 0, (4) * sizeof(blkcnt_t)
# 5571 "project/nnn/src/nnn.c" 3 4
 , __builtin_object_size (
# 5571 "project/nnn/src/nnn.c"
 core_blocks
# 5571 "project/nnn/src/nnn.c" 3 4
 , 0))
# 5571 "project/nnn/src/nnn.c"
                                                          ;
  
# 5572 "project/nnn/src/nnn.c" 3 4
 __builtin___memset_chk (
# 5572 "project/nnn/src/nnn.c"
 core_data
# 5572 "project/nnn/src/nnn.c" 3 4
 , 
# 5572 "project/nnn/src/nnn.c"
 0, (4) * sizeof(thread_data)
# 5572 "project/nnn/src/nnn.c" 3 4
 , __builtin_object_size (
# 5572 "project/nnn/src/nnn.c"
 core_data
# 5572 "project/nnn/src/nnn.c" 3 4
 , 0))
# 5572 "project/nnn/src/nnn.c"
                                                           ;
  
# 5573 "project/nnn/src/nnn.c" 3 4
 __builtin___memset_chk (
# 5573 "project/nnn/src/nnn.c"
 core_files
# 5573 "project/nnn/src/nnn.c" 3 4
 , 
# 5573 "project/nnn/src/nnn.c"
 0, (4) * sizeof(ullong_t)
# 5573 "project/nnn/src/nnn.c" 3 4
 , __builtin_object_size (
# 5573 "project/nnn/src/nnn.c"
 core_files
# 5573 "project/nnn/src/nnn.c" 3 4
 , 0))
# 5573 "project/nnn/src/nnn.c"
                                                         ;
 }
}


static 
# 5578 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 5578 "project/nnn/src/nnn.c"
           selforparent(const char *path)
{
 return path[0] == '.' && (path[1] == '\0' || (path[1] == '.' && path[2] == '\0'));
}

static int dentfill(char *path, struct entry **ppdents)
{
 uchar_t entflags = 0;
 int flags = 0;
 struct dirent *dp;
 char *namep, *pnb, *buf;
 struct entry *dentp;
 size_t off = 0, namebuflen = 0x800;
 struct stat sb_path, sb;
 DIR *dirp = opendir(path);

 ndents = 0;

 ;

 if (!dirp)
  return 0;

 int fd = dirfd(dirp);

 if (cfg.blkorder) {
  num_files = 0;
  dir_blocks = 0;
  buf = g_buf;

  if (fstatat(fd, path, &sb_path, 0) == -1)
   goto exit;

  if (!ihashbmp) {
   ihashbmp = calloc(1, ((0xFFFFFF) >> 6) << 3);
   if (!ihashbmp)
    goto exit;
  } else
   
# 5616 "project/nnn/src/nnn.c" 3 4
  __builtin___memset_chk (
# 5616 "project/nnn/src/nnn.c"
  ihashbmp
# 5616 "project/nnn/src/nnn.c" 3 4
  , 
# 5616 "project/nnn/src/nnn.c"
  0, ((0xFFFFFF) >> 6) << 3
# 5616 "project/nnn/src/nnn.c" 3 4
  , __builtin_object_size (
# 5616 "project/nnn/src/nnn.c"
  ihashbmp
# 5616 "project/nnn/src/nnn.c" 3 4
  , 0))
# 5616 "project/nnn/src/nnn.c"
                                       ;

  prep_threads();

  
# 5620 "project/nnn/src/nnn.c" 3 4
 wattr_on(stdscr, (attr_t)(((
# 5620 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 5620 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8))), ((void *)0))
# 5620 "project/nnn/src/nnn.c"
                                   ;
 }





 dp = readdir(dirp);
 if (!dp)
  goto exit;




 if (cfg.blkorder || dp->d_type == 
# 5634 "project/nnn/src/nnn.c" 3 4
                                  0
# 5634 "project/nnn/src/nnn.c"
                                            ) {







  flags = 
# 5642 "project/nnn/src/nnn.c" 3 4
         0x0020
# 5642 "project/nnn/src/nnn.c"
                            ;
 }


 do {
  namep = dp->d_name;

  if (selforparent(namep))
   continue;

  if (!cfg.showhidden && namep[0] == '.') {
   if (!cfg.blkorder)
    continue;

   if (fstatat(fd, namep, &sb, 
# 5656 "project/nnn/src/nnn.c" 3 4
                              0x0020
# 5656 "project/nnn/src/nnn.c"
                                                 ) == -1)
    continue;

   if (
# 5659 "project/nnn/src/nnn.c" 3 4
      (((
# 5659 "project/nnn/src/nnn.c"
      sb.st_mode
# 5659 "project/nnn/src/nnn.c" 3 4
      ) & 0170000) == 0040000)
# 5659 "project/nnn/src/nnn.c"
                         ) {
    if (sb_path.st_dev == sb.st_dev) {
     mkpath(path, namep, buf);
     dirwalk(buf, -1, 
# 5662 "project/nnn/src/nnn.c" 3 4
                     0
# 5662 "project/nnn/src/nnn.c"
                          );

     if (g_state.interrupt)
      goto exit;

    }
   } else {

    if (sb.st_nlink <= 1 || test_set_bit((uint_t)sb.st_ino))
     dir_blocks += (cfg.apparentsz ? sb.st_size : sb.st_blocks);
    ++num_files;
   }

   continue;
  }

  if (fstatat(fd, namep, &sb, flags) == -1) {
   if (flags || (fstatat(fd, namep, &sb, 
# 5679 "project/nnn/src/nnn.c" 3 4
                                        0x0020
# 5679 "project/nnn/src/nnn.c"
                                                           ) == -1)) {

    ;
    if (!flags) {
     ;
     ;
    }

    entflags = 0x08;
    
# 5688 "project/nnn/src/nnn.c" 3 4
   __builtin___memset_chk (
# 5688 "project/nnn/src/nnn.c"
   &sb
# 5688 "project/nnn/src/nnn.c" 3 4
   , 
# 5688 "project/nnn/src/nnn.c"
   0, sizeof(struct stat)
# 5688 "project/nnn/src/nnn.c" 3 4
   , __builtin_object_size (
# 5688 "project/nnn/src/nnn.c"
   &sb
# 5688 "project/nnn/src/nnn.c" 3 4
   , 0))
# 5688 "project/nnn/src/nnn.c"
                                      ;
   } else
    entflags = 0x04;
  }

  if (ndents == total_dents) {
   if (cfg.blkorder)
    while (active_threads);

   total_dents += 64;
   *ppdents = xrealloc(*ppdents, total_dents * sizeof(**ppdents));
   if (!*ppdents) {
    free(pnamebuf);
    closedir(dirp);
    printerr(5702);
   }
   ;
  }


  if (namebuflen - off < 
# 5708 "project/nnn/src/nnn.c" 3 4
                        255 
# 5708 "project/nnn/src/nnn.c"
                                 + 1) {
   namebuflen += 0x800;

   pnb = pnamebuf;
   pnamebuf = (char *)xrealloc(pnamebuf, namebuflen);
   if (!pnamebuf) {
    free(*ppdents);
    closedir(dirp);
    printerr(5716);
   }
   ;


   if (pnb != pnamebuf) {
    dentp = *ppdents;
    dentp->name = pnamebuf;

    for (int count = 1; count < ndents; ++dentp, ++count)

     (dentp + 1)->name = (char *)((size_t)dentp->name + dentp->nlen);
   }
  }

  dentp = *ppdents + ndents;


  dentp->name = (char *)((size_t)pnamebuf + off);
  dentp->nlen = xstrsncpy(dentp->name, namep, 
# 5735 "project/nnn/src/nnn.c" 3 4
                                             255 
# 5735 "project/nnn/src/nnn.c"
                                                      + 1);
  off += dentp->nlen;


  if (cfg.timetype == 2) {
   dentp->sec = sb.
# 5740 "project/nnn/src/nnn.c" 3 4
                  st_mtimespec.tv_sec
# 5740 "project/nnn/src/nnn.c"
                          ;

   dentp->nsec = (uint_t)sb.st_mtimespec.tv_nsec;



  } else if (cfg.timetype == 0) {
   dentp->sec = sb.
# 5747 "project/nnn/src/nnn.c" 3 4
                  st_atimespec.tv_sec
# 5747 "project/nnn/src/nnn.c"
                          ;

   dentp->nsec = (uint_t)sb.st_atimespec.tv_nsec;



  } else {
   dentp->sec = sb.
# 5754 "project/nnn/src/nnn.c" 3 4
                  st_ctimespec.tv_sec
# 5754 "project/nnn/src/nnn.c"
                          ;

   dentp->nsec = (uint_t)sb.st_ctimespec.tv_nsec;



  }


  if (!flags && dp->d_type == 
# 5763 "project/nnn/src/nnn.c" 3 4
                             10
# 5763 "project/nnn/src/nnn.c"
                                   ) {

   dentp->mode = (sb.st_mode & ~
# 5765 "project/nnn/src/nnn.c" 3 4
                               0170000
# 5765 "project/nnn/src/nnn.c"
                                     ) | 
# 5765 "project/nnn/src/nnn.c" 3 4
                                         0120000
# 5765 "project/nnn/src/nnn.c"
                                                ;
   dentp->size = listpath ? sb.st_size : 0;
  } else {
   dentp->mode = sb.st_mode;
   dentp->size = sb.st_size;
  }






  dentp->uid = sb.st_uid;
  dentp->gid = sb.st_gid;


  dentp->flags = 
# 5781 "project/nnn/src/nnn.c" 3 4
                (((
# 5781 "project/nnn/src/nnn.c"
                sb.st_mode
# 5781 "project/nnn/src/nnn.c" 3 4
                ) & 0170000) == 0040000) 
# 5781 "project/nnn/src/nnn.c"
                                    ? 0 : ((sb.st_nlink > 1) ? 0x02 : 0);
  if (entflags) {
   dentp->flags |= entflags;
   entflags = 0;
  }

  if (cfg.blkorder) {
   if (
# 5788 "project/nnn/src/nnn.c" 3 4
      (((
# 5788 "project/nnn/src/nnn.c"
      sb.st_mode
# 5788 "project/nnn/src/nnn.c" 3 4
      ) & 0170000) == 0040000)
# 5788 "project/nnn/src/nnn.c"
                         ) {
    mkpath(path, namep, buf);


    dirwalk(buf, ndents, (sb_path.st_dev != sb.st_dev));

    if (g_state.interrupt)
     goto exit;
   } else {
    dentp->blocks = (cfg.apparentsz ? sb.st_size : sb.st_blocks);

    if (sb.st_nlink <= 1 || test_set_bit((uint_t)sb.st_ino))
     dir_blocks += dentp->blocks;
    ++num_files;
   }
  }

  if (flags) {

   if (
# 5807 "project/nnn/src/nnn.c" 3 4
      (((
# 5807 "project/nnn/src/nnn.c"
      sb.st_mode
# 5807 "project/nnn/src/nnn.c" 3 4
      ) & 0170000) == 0120000)
# 5807 "project/nnn/src/nnn.c"
                         ) {
    sb.st_mode = 0;
    fstatat(fd, namep, &sb, 0);
   }

   if (
# 5812 "project/nnn/src/nnn.c" 3 4
      (((
# 5812 "project/nnn/src/nnn.c"
      sb.st_mode
# 5812 "project/nnn/src/nnn.c" 3 4
      ) & 0170000) == 0040000)
# 5812 "project/nnn/src/nnn.c"
                         )
    dentp->flags |= 0x01;

  } else if (dp->d_type == 
# 5815 "project/nnn/src/nnn.c" 3 4
                          4 
# 5815 "project/nnn/src/nnn.c"
                                 || ((dp->d_type == 
# 5815 "project/nnn/src/nnn.c" 3 4
                                                    10
      
# 5816 "project/nnn/src/nnn.c"
     || dp->d_type == 
# 5816 "project/nnn/src/nnn.c" 3 4
                      0
# 5816 "project/nnn/src/nnn.c"
                                ) && 
# 5816 "project/nnn/src/nnn.c" 3 4
                                     (((
# 5816 "project/nnn/src/nnn.c"
                                     sb.st_mode
# 5816 "project/nnn/src/nnn.c" 3 4
                                     ) & 0170000) == 0040000)
# 5816 "project/nnn/src/nnn.c"
                                                        )) {
   dentp->flags |= 0x01;

  }

  ++ndents;
 } while ((dp = readdir(dirp)));

exit:
 if (cfg.blkorder) {
  while (active_threads);

  
# 5828 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(((
# 5828 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 5828 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8))), ((void *)0))
# 5828 "project/nnn/src/nnn.c"
                                    ;
  for (int i = 0; i < (4); ++i) {
   num_files += core_files[i];
   dir_blocks += core_blocks[i];
  }
 }


 if (closedir(dirp) == -1)
  printerr(5837);

 return ndents;
}

static void populate(char *path, char *lastname)
{






 ndents = dentfill(path, &pdents);
 if (!ndents)
  return;

 qsort((pdents), (ndents), sizeof(*(pdents)), (entrycmpfn));
# 5863 "project/nnn/src/nnn.c"
 move_cursor(*lastname ? dentfind(lastname, ndents) : 0, 0);


 last_curscroll = -1;
}


static void notify_fifo(
# 5870 "project/nnn/src/nnn.c" 3 4
                       _Bool 
# 5870 "project/nnn/src/nnn.c"
                            force)
{
 if (!fifopath)
  return;

 if (fifofd == -1) {
  fifofd = open(fifopath, 
# 5876 "project/nnn/src/nnn.c" 3 4
                         0x0001
# 5876 "project/nnn/src/nnn.c"
                                 |
# 5876 "project/nnn/src/nnn.c" 3 4
                                  0x00000004
# 5876 "project/nnn/src/nnn.c"
                                            |
# 5876 "project/nnn/src/nnn.c" 3 4
                                             0x01000000
# 5876 "project/nnn/src/nnn.c"
                                                      );
  if (fifofd == -1) {
   if (
# 5878 "project/nnn/src/nnn.c" 3 4
      (*__error()) 
# 5878 "project/nnn/src/nnn.c"
            != 
# 5878 "project/nnn/src/nnn.c" 3 4
               6
# 5878 "project/nnn/src/nnn.c"
                    )


    fifopath = 
# 5881 "project/nnn/src/nnn.c" 3 4
              ((void *)0)
# 5881 "project/nnn/src/nnn.c"
                  ;
   return;
  }
 }

 static struct entry lastentry;

 if (!force && !memcmp(&lastentry, &pdents[cur], sizeof(struct entry)))
  return;

 lastentry = pdents[cur];

 char path[
# 5893 "project/nnn/src/nnn.c" 3 4
          1024
# 5893 "project/nnn/src/nnn.c"
                  ];
 size_t len = mkpath(g_ctx[cfg.curctx].c_path, ndents ? pdents[cur].name : "", path);

 path[len - 1] = '\n';

 ssize_t ret = write(fifofd, path, len);

 if (ret != (ssize_t)len && !(ret == -1 && (
# 5900 "project/nnn/src/nnn.c" 3 4
                                           (*__error()) 
# 5900 "project/nnn/src/nnn.c"
                                                 == 
# 5900 "project/nnn/src/nnn.c" 3 4
                                                    35 
# 5900 "project/nnn/src/nnn.c"
                                                           || 
# 5900 "project/nnn/src/nnn.c" 3 4
                                                              (*__error()) 
# 5900 "project/nnn/src/nnn.c"
                                                                    == 
# 5900 "project/nnn/src/nnn.c" 3 4
                                                                       32
# 5900 "project/nnn/src/nnn.c"
                                                                            ))) {
  ;
 }
}

static void send_to_explorer(int *presel)
{
 if (nselected) {
  int fd = open(fifopath, 
# 5908 "project/nnn/src/nnn.c" 3 4
                         0x0001
# 5908 "project/nnn/src/nnn.c"
                                 |
# 5908 "project/nnn/src/nnn.c" 3 4
                                  0x00000004
# 5908 "project/nnn/src/nnn.c"
                                            |
# 5908 "project/nnn/src/nnn.c" 3 4
                                             0x01000000
# 5908 "project/nnn/src/nnn.c"
                                                      , 0600);
  if ((fd == -1) || (seltofile(fd, 
# 5909 "project/nnn/src/nnn.c" 3 4
                                  ((void *)0)
# 5909 "project/nnn/src/nnn.c"
                                      ) != (size_t)(selbufpos)))
   printwait(strerror(
# 5910 "project/nnn/src/nnn.c" 3 4
  (*__error())
# 5910 "project/nnn/src/nnn.c"
  ), presel);
  else {
   resetselind();
   clearselection();
  }
  if (fd > 1)
   close(fd);
 } else
  notify_fifo(
# 5918 "project/nnn/src/nnn.c" 3 4
             1
# 5918 "project/nnn/src/nnn.c"
                 );
}


static void move_cursor(int target, int ignore_scrolloff)
{
 int onscreen = xlines - 4;

 target = ((0) > (((ndents - 1) < (target) ? (ndents - 1) : (target))) ? (0) : (((ndents - 1) < (target) ? (ndents - 1) : (target))));
 last_curscroll = curscroll;
 last = cur;
 cur = target;

 if (!ignore_scrolloff) {
  int delta = target - last;
  int scrolloff = ((3) < (onscreen >> 1) ? (3) : (onscreen >> 1));
# 5942 "project/nnn/src/nnn.c"
  if (((cur < (curscroll + scrolloff)) && delta < 0)
      || ((cur > (curscroll + onscreen - scrolloff - 1)) && delta > 0))
   curscroll += delta;
 }
 curscroll = ((curscroll) < (((cur) < (ndents - onscreen) ? (cur) : (ndents - onscreen))) ? (curscroll) : (((cur) < (ndents - onscreen) ? (cur) : (ndents - onscreen))));
 curscroll = ((curscroll) > (((cur - (onscreen - 1)) > (0) ? (cur - (onscreen - 1)) : (0))) ? (curscroll) : (((cur - (onscreen - 1)) > (0) ? (cur - (onscreen - 1)) : (0))));


 if (!g_state.fifomode)
  notify_fifo(
# 5951 "project/nnn/src/nnn.c" 3 4
             0
# 5951 "project/nnn/src/nnn.c"
                  );

}

static void handle_screen_move(enum action sel)
{
 int onscreen;

 switch (sel) {
 case SEL_NEXT:
  if (ndents && (cfg.rollover || (cur != ndents - 1)))
   move_cursor((cur + 1) % ndents, 0);
  break;
 case SEL_PREV:
  if (ndents && (cfg.rollover || cur))
   move_cursor((cur + ndents - 1) % ndents, 0);
  break;
 case SEL_PGDN:
  onscreen = xlines - 4;
  move_cursor(curscroll + (onscreen - 1), 1);
  curscroll += onscreen - 1;
  break;
 case SEL_CTRL_D:
  onscreen = xlines - 4;
  move_cursor(curscroll + (onscreen - 1), 1);
  curscroll += onscreen >> 1;
  break;
 case SEL_PGUP:
  onscreen = xlines - 4;
  move_cursor(curscroll, 1);
  curscroll -= onscreen - 1;
  break;
 case SEL_CTRL_U:
  onscreen = xlines - 4;
  move_cursor(curscroll, 1);
  curscroll -= onscreen >> 1;
  break;
 case SEL_HOME:
  move_cursor(0, 1);
  break;
 case SEL_END:
  move_cursor(ndents - 1, 1);
  break;
 default:
 {
  int c = get_input(messages[38]);

  if (!c)
   break;

  c = (((c) >= 'a' && (c) <= 'z') ? ((c) - 'a' + 'A') : (c));

  int r = (c == (((*pdents[cur].name) >= 'a' && (*pdents[cur].name) <= 'z') ? ((*pdents[cur].name) - 'a' + 'A') : (*pdents[cur].name))) ? (cur + 1) : 0;

  for (; r < ndents; ++r) {
   if (((c == '\'') && !(pdents[r].flags & 0x01))
       || (c == (((*pdents[r].name) >= 'a' && (*pdents[r].name) <= 'z') ? ((*pdents[r].name) - 'a' + 'A') : (*pdents[r].name)))) {
    move_cursor((r) % ndents, 0);
    break;
   }
  }
  break;
 }
 }
}

static void handle_openwith(const char *path, const char *name, char *newpath, char *tmp)
{

 int r = get_input(messages[12]);

 r = (r == 'c' ? (0x08 | 0x01) :
      (r == 'g' ? 0x02 | 0x04 | 0x01 : 0));
 if (r) {
  mkpath(path, name, newpath);
  spawn(tmp, newpath, 
# 6026 "project/nnn/src/nnn.c" 3 4
                     ((void *)0)
# 6026 "project/nnn/src/nnn.c"
                         , 
# 6026 "project/nnn/src/nnn.c" 3 4
                           ((void *)0)
# 6026 "project/nnn/src/nnn.c"
                               , r);
 }
}

static void copynextname(char *lastname)
{
 if (cur) {
  cur += (cur != (ndents - 1)) ? 1 : -1;
  xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 6034 "project/nnn/src/nnn.c" 3 4
 255 
# 6034 "project/nnn/src/nnn.c"
 + 1);
 } else
  lastname[0] = '\0';
}

static int handle_context_switch(enum action sel)
{
 int r = -1;

 switch (sel) {
 case SEL_CYCLE:
 case SEL_CYCLER:

  r = cfg.curctx;
  if (sel == SEL_CYCLE)
   do
    r = (r + 1) & ~4;
   while (!g_ctx[r].c_cfg.ctxactive);
  else {
   do
    r = (r + 1) & ~4;
   while (g_ctx[r].c_cfg.ctxactive && (r != cfg.curctx));

   if (r == cfg.curctx)
    do
     r = (r + (4 - 1)) & (4 - 1);
    while (!g_ctx[r].c_cfg.ctxactive);
  }
 default:
  if (sel >= SEL_CTX1)
   r = sel - SEL_CTX1;

  if (cfg.curctx == r) {
   if (sel == SEL_CYCLE)
    (r == 4 - 1) ? (r = 0) : ++r;
   else if (sel == SEL_CYCLER)
    (r == 0) ? (r = 4 - 1) : --r;
   else
    return -1;
  }
 }

 return r;
}

static int set_sort_flags(int r)
{
 
# 6081 "project/nnn/src/nnn.c" 3 4
_Bool 
# 6081 "project/nnn/src/nnn.c"
     session = (r == '\0');
 
# 6082 "project/nnn/src/nnn.c" 3 4
_Bool 
# 6082 "project/nnn/src/nnn.c"
     reverse = 
# 6082 "project/nnn/src/nnn.c" 3 4
               0
# 6082 "project/nnn/src/nnn.c"
                    ;

 if (((r) >= 'A' && (r) <= 'Z') && (r != 'R') && (r != 'C')) {
  reverse = 
# 6085 "project/nnn/src/nnn.c" 3 4
           1
# 6085 "project/nnn/src/nnn.c"
               ;
  r = (((r) >= 'A' && (r) <= 'Z') ? ((r) - 'A' + 'a') : (r));
 }


 if (session) {
  if (cfg.apparentsz) {
   cfg.apparentsz = 0;
   r = 'a';
  } else if (cfg.blkorder) {
   cfg.blkorder = 0;
   r = 'd';
  }

  if (cfg.version)
   namecmpfn = &xstrverscasecmp;

  if (cfg.reverse)
   entrycmpfn = &reventrycmp;
 } else if (r == (('T') & 0x1f)) {

  if (cfg.timeorder)
   r = 's';
  else if (cfg.sizeorder)
   r = 'c';
  else
   r = 't';
 }

 switch (r) {
 case 'a':
  cfg.apparentsz ^= 1;
  if (cfg.apparentsz) {
   cfg.blkorder = 1;
   blk_shift = 0;
  } else
   cfg.blkorder = 0;

 case 'd':
  if (r == 'd') {
   if (!cfg.apparentsz)
    cfg.blkorder ^= 1;
   cfg.apparentsz = 0;
   blk_shift = ffs(
# 6128 "project/nnn/src/nnn.c" 3 4
                  512
# 6128 "project/nnn/src/nnn.c"
                           ) - 1;
  }

  if (cfg.blkorder)
   cfg.showdetail = 1;
  cfg.timeorder = 0;
  cfg.sizeorder = 0;
  cfg.extnorder = 0;
  if (!session) {
   cfg.reverse = 0;
   entrycmpfn = &entrycmp;
  }
  endselection(
# 6140 "project/nnn/src/nnn.c" 3 4
              1
# 6140 "project/nnn/src/nnn.c"
                  );
  break;
 case 'c':
  cfg.timeorder = 0;
  cfg.sizeorder = 0;
  cfg.apparentsz = 0;
  cfg.blkorder = 0;
  cfg.extnorder = 0;
  cfg.reverse = 0;
  cfg.version = 0;
  entrycmpfn = &entrycmp;
  namecmpfn = &xstricmp;
  break;
 case 'e':
  cfg.extnorder ^= 1;
  cfg.sizeorder = 0;
  cfg.timeorder = 0;
  cfg.apparentsz = 0;
  cfg.blkorder = 0;
  cfg.reverse = 0;
  entrycmpfn = &entrycmp;
  break;
 case 'r':
  cfg.reverse ^= 1;
  entrycmpfn = cfg.reverse ? &reventrycmp : &entrycmp;
  break;
 case 's':
  cfg.sizeorder ^= 1;
  cfg.timeorder = 0;
  cfg.apparentsz = 0;
  cfg.blkorder = 0;
  cfg.extnorder = 0;
  cfg.reverse = 0;
  entrycmpfn = &entrycmp;
  break;
 case 't':
  cfg.timeorder ^= 1;
  cfg.sizeorder = 0;
  cfg.apparentsz = 0;
  cfg.blkorder = 0;
  cfg.extnorder = 0;
  cfg.reverse = 0;
  entrycmpfn = &entrycmp;
  break;
 case 'v':
  cfg.version ^= 1;
  namecmpfn = cfg.version ? &xstrverscasecmp : &xstricmp;
  cfg.timeorder = 0;
  cfg.sizeorder = 0;
  cfg.apparentsz = 0;
  cfg.blkorder = 0;
  cfg.extnorder = 0;
  break;
 default:
  return 0;
 }

 if (reverse) {
  cfg.reverse = 1;
  entrycmpfn = &reventrycmp;
 }

 cfgsort[cfg.curctx] = (uchar_t)r;

 return r;
}

static 
# 6207 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 6207 "project/nnn/src/nnn.c"
           set_time_type(int *presel)
{
 
# 6209 "project/nnn/src/nnn.c" 3 4
_Bool 
# 6209 "project/nnn/src/nnn.c"
     ret = 
# 6209 "project/nnn/src/nnn.c" 3 4
           0
# 6209 "project/nnn/src/nnn.c"
                ;
 char buf[] = "'a'ccess / 'c'hange / 'm'od [ ]";

 buf[sizeof(buf) - 3] = cfg.timetype == 2 ? 'm' : (cfg.timetype == 0 ? 'a' : 'c');

 int r = get_input(buf);

 if (r == 'a' || r == 'c' || r == 'm') {
  r = (r == 'm') ? 2 : ((r == 'a') ? 0 : 1);
  if (cfg.timetype != r) {
   cfg.timetype = r;

   if (cfg.filtermode || g_ctx[cfg.curctx].c_fltr[1])
    *presel = '/';

   ret = 
# 6224 "project/nnn/src/nnn.c" 3 4
        1
# 6224 "project/nnn/src/nnn.c"
            ;
  } else
   r = 41;
 } else
  r = 40;

 if (!ret)
  printwait(messages[r], presel);

 return ret;
}

static void statusbar(char *path)
{
 int i = 0, len = 0;
 char *ptr;
 pEntry pent = &pdents[cur];

 if (!ndents) {
  printmsg("0/0");
  return;
 }


 if (
# 6248 "project/nnn/src/nnn.c" 3 4
    (((
# 6248 "project/nnn/src/nnn.c"
    pent->mode
# 6248 "project/nnn/src/nnn.c" 3 4
    ) & 0170000) == 0100000)
# 6248 "project/nnn/src/nnn.c"
                       ) {
  i = (int)(pent->nlen - 1);
  ptr = xextension(pent->name, i);
  if (ptr)
   len = i - (ptr - pent->name);
  if (!ptr || len > 5 || len < 2)
   ptr = "\b";
 } else
  ptr = "\b";

 
# 6258 "project/nnn/src/nnn.c" 3 4
wattr_on(stdscr, (attr_t)(((
# 6258 "project/nnn/src/nnn.c"
cfg.curctx + 1
# 6258 "project/nnn/src/nnn.c" 3 4
) << ((0) + 8))), ((void *)0))
# 6258 "project/nnn/src/nnn.c"
                                  ;

 if (cfg.fileinfo && get_output("file", "-b", pdents[cur].name, -1, 
# 6260 "project/nnn/src/nnn.c" 3 4
                                                                   0
# 6260 "project/nnn/src/nnn.c"
                                                                        , 
# 6260 "project/nnn/src/nnn.c" 3 4
                                                                          0
# 6260 "project/nnn/src/nnn.c"
                                                                               ))
  
# 6261 "project/nnn/src/nnn.c" 3 4
 (wmove(stdscr,
# 6261 "project/nnn/src/nnn.c"
 xlines - 2
# 6261 "project/nnn/src/nnn.c" 3 4
 ,
# 6261 "project/nnn/src/nnn.c"
 2
# 6261 "project/nnn/src/nnn.c" 3 4
 ) == (-1) ? (-1) : waddnstr(stdscr,
# 6261 "project/nnn/src/nnn.c"
 g_buf
# 6261 "project/nnn/src/nnn.c" 3 4
 ,-1))
# 6261 "project/nnn/src/nnn.c"
                               ;

 
# 6263 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 6263 "project/nnn/src/nnn.c"
xlines - 1
# 6263 "project/nnn/src/nnn.c" 3 4
,
# 6263 "project/nnn/src/nnn.c"
0
# 6263 "project/nnn/src/nnn.c" 3 4
)
# 6263 "project/nnn/src/nnn.c"
          ;

 printw("%d/%s ", cur + 1, xitoa(ndents));

 if (g_state.selmode || nselected) {
  
# 6268 "project/nnn/src/nnn.c" 3 4
 wattr_on(stdscr, (attr_t)(((1U) << ((10) + 8))), ((void *)0))
# 6268 "project/nnn/src/nnn.c"
                  ;
  
# 6269 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6269 "project/nnn/src/nnn.c"
 ' '
# 6269 "project/nnn/src/nnn.c" 3 4
 )
# 6269 "project/nnn/src/nnn.c"
           ;
  if (g_state.rangesel)
   
# 6271 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6271 "project/nnn/src/nnn.c"
  '*'
# 6271 "project/nnn/src/nnn.c" 3 4
  )
# 6271 "project/nnn/src/nnn.c"
            ;
  else if (g_state.selmode)
   
# 6273 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6273 "project/nnn/src/nnn.c"
  '+'
# 6273 "project/nnn/src/nnn.c" 3 4
  )
# 6273 "project/nnn/src/nnn.c"
            ;
  if (nselected)
   
# 6275 "project/nnn/src/nnn.c" 3 4
  waddnstr(stdscr,
# 6275 "project/nnn/src/nnn.c"
  xitoa(nselected)
# 6275 "project/nnn/src/nnn.c" 3 4
  ,-1)
# 6275 "project/nnn/src/nnn.c"
                          ;
  
# 6276 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6276 "project/nnn/src/nnn.c"
 ' '
# 6276 "project/nnn/src/nnn.c" 3 4
 )
# 6276 "project/nnn/src/nnn.c"
           ;
  
# 6277 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(((1U) << ((10) + 8))), ((void *)0))
# 6277 "project/nnn/src/nnn.c"
                   ;
  
# 6278 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6278 "project/nnn/src/nnn.c"
 ' '
# 6278 "project/nnn/src/nnn.c" 3 4
 )
# 6278 "project/nnn/src/nnn.c"
           ;
 }

 if (cfg.blkorder) {
  char buf[24];

  xstrsncpy(buf, coolsize(dir_blocks << blk_shift), 12);

  printw("%cu:%s free:%s files:%llu %lluB %s\n",
         (cfg.apparentsz ? 'a' : 'd'), buf, coolsize(get_fs_info(path, 0)),
         num_files, (ullong_t)pent->blocks << blk_shift, ptr);
 } else {
  char sort[] = "\0\0\0\0\0";

  if (getorderstr(sort))
   
# 6293 "project/nnn/src/nnn.c" 3 4
  waddnstr(stdscr,
# 6293 "project/nnn/src/nnn.c"
  sort
# 6293 "project/nnn/src/nnn.c" 3 4
  ,-1)
# 6293 "project/nnn/src/nnn.c"
              ;


  print_time(&pent->sec);

  
# 6298 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6298 "project/nnn/src/nnn.c"
 ' '
# 6298 "project/nnn/src/nnn.c" 3 4
 )
# 6298 "project/nnn/src/nnn.c"
           ;
  
# 6299 "project/nnn/src/nnn.c" 3 4
 waddnstr(stdscr,
# 6299 "project/nnn/src/nnn.c"
 get_lsperms(pent->mode)
# 6299 "project/nnn/src/nnn.c" 3 4
 ,-1)
# 6299 "project/nnn/src/nnn.c"
                                ;
  
# 6300 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6300 "project/nnn/src/nnn.c"
 ' '
# 6300 "project/nnn/src/nnn.c" 3 4
 )
# 6300 "project/nnn/src/nnn.c"
           ;

  if (g_state.uidgid) {
   
# 6303 "project/nnn/src/nnn.c" 3 4
  waddnstr(stdscr,
# 6303 "project/nnn/src/nnn.c"
  getpwname(pent->uid)
# 6303 "project/nnn/src/nnn.c" 3 4
  ,-1)
# 6303 "project/nnn/src/nnn.c"
                              ;
   
# 6304 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6304 "project/nnn/src/nnn.c"
  ':'
# 6304 "project/nnn/src/nnn.c" 3 4
  )
# 6304 "project/nnn/src/nnn.c"
            ;
   
# 6305 "project/nnn/src/nnn.c" 3 4
  waddnstr(stdscr,
# 6305 "project/nnn/src/nnn.c"
  getgrname(pent->gid)
# 6305 "project/nnn/src/nnn.c" 3 4
  ,-1)
# 6305 "project/nnn/src/nnn.c"
                              ;
   
# 6306 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6306 "project/nnn/src/nnn.c"
  ' '
# 6306 "project/nnn/src/nnn.c" 3 4
  )
# 6306 "project/nnn/src/nnn.c"
            ;
  }

  if (
# 6309 "project/nnn/src/nnn.c" 3 4
     (((
# 6309 "project/nnn/src/nnn.c"
     pent->mode
# 6309 "project/nnn/src/nnn.c" 3 4
     ) & 0170000) == 0120000)
# 6309 "project/nnn/src/nnn.c"
                        ) {
   if (!cfg.fileinfo) {
    i = readlink(pent->name, g_buf, 
# 6311 "project/nnn/src/nnn.c" 3 4
                                   1024
# 6311 "project/nnn/src/nnn.c"
                                           );
    
# 6312 "project/nnn/src/nnn.c" 3 4
   waddnstr(stdscr,
# 6312 "project/nnn/src/nnn.c"
   coolsize(i >= 0 ? i : pent->size)
# 6312 "project/nnn/src/nnn.c" 3 4
   ,-1)
# 6312 "project/nnn/src/nnn.c"
                                            ;
    if (i > 1) {
     int y;

     
# 6316 "project/nnn/src/nnn.c" 3 4
    waddnstr(stdscr,
# 6316 "project/nnn/src/nnn.c"
    " ->"
# 6316 "project/nnn/src/nnn.c" 3 4
    ,-1)
# 6316 "project/nnn/src/nnn.c"
                 ;
     
# 6317 "project/nnn/src/nnn.c" 3 4
    (
# 6317 "project/nnn/src/nnn.c"
    len 
# 6317 "project/nnn/src/nnn.c" 3 4
    = getcury(
# 6317 "project/nnn/src/nnn.c"
    stdscr
# 6317 "project/nnn/src/nnn.c" 3 4
    ), 
# 6317 "project/nnn/src/nnn.c"
    y 
# 6317 "project/nnn/src/nnn.c" 3 4
    = getcurx(
# 6317 "project/nnn/src/nnn.c"
    stdscr
# 6317 "project/nnn/src/nnn.c" 3 4
    ))
# 6317 "project/nnn/src/nnn.c"
                         ;
     i = ((i) < (xcols - y) ? (i) : (xcols - y));
     g_buf[i] = '\0';
     
# 6320 "project/nnn/src/nnn.c" 3 4
    waddnstr(stdscr,
# 6320 "project/nnn/src/nnn.c"
    g_buf
# 6320 "project/nnn/src/nnn.c" 3 4
    ,-1)
# 6320 "project/nnn/src/nnn.c"
                 ;
    }
   }
  } else {
   
# 6324 "project/nnn/src/nnn.c" 3 4
  waddnstr(stdscr,
# 6324 "project/nnn/src/nnn.c"
  coolsize(pent->size)
# 6324 "project/nnn/src/nnn.c" 3 4
  ,-1)
# 6324 "project/nnn/src/nnn.c"
                              ;
   
# 6325 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6325 "project/nnn/src/nnn.c"
  ' '
# 6325 "project/nnn/src/nnn.c" 3 4
  )
# 6325 "project/nnn/src/nnn.c"
            ;
   
# 6326 "project/nnn/src/nnn.c" 3 4
  waddnstr(stdscr,
# 6326 "project/nnn/src/nnn.c"
  ptr
# 6326 "project/nnn/src/nnn.c" 3 4
  ,-1)
# 6326 "project/nnn/src/nnn.c"
             ;
   if (pent->flags & 0x02) {
    struct stat sb;

    if (stat(pent->name, &sb) != -1) {
     
# 6331 "project/nnn/src/nnn.c" 3 4
    waddch(stdscr,
# 6331 "project/nnn/src/nnn.c"
    ' '
# 6331 "project/nnn/src/nnn.c" 3 4
    )
# 6331 "project/nnn/src/nnn.c"
              ;
     
# 6332 "project/nnn/src/nnn.c" 3 4
    waddnstr(stdscr,
# 6332 "project/nnn/src/nnn.c"
    xitoa((int)sb.st_nlink)
# 6332 "project/nnn/src/nnn.c" 3 4
    ,-1)
# 6332 "project/nnn/src/nnn.c"
                                   ;
     
# 6333 "project/nnn/src/nnn.c" 3 4
    waddch(stdscr,
# 6333 "project/nnn/src/nnn.c"
    '-'
# 6333 "project/nnn/src/nnn.c" 3 4
    )
# 6333 "project/nnn/src/nnn.c"
              ;
     
# 6334 "project/nnn/src/nnn.c" 3 4
    waddnstr(stdscr,
# 6334 "project/nnn/src/nnn.c"
    xitoa((int)sb.st_ino)
# 6334 "project/nnn/src/nnn.c" 3 4
    ,-1)
# 6334 "project/nnn/src/nnn.c"
                                 ;
    }
   }
  }
  
# 6338 "project/nnn/src/nnn.c" 3 4
 wclrtoeol(stdscr)
# 6338 "project/nnn/src/nnn.c"
           ;
 }

 
# 6341 "project/nnn/src/nnn.c" 3 4
wattr_off(stdscr, (attr_t)(((
# 6341 "project/nnn/src/nnn.c"
cfg.curctx + 1
# 6341 "project/nnn/src/nnn.c" 3 4
) << ((0) + 8))), ((void *)0))
# 6341 "project/nnn/src/nnn.c"
                                   ;

 
# 6343 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 6343 "project/nnn/src/nnn.c"
cur + 2 - curscroll
# 6343 "project/nnn/src/nnn.c" 3 4
,
# 6343 "project/nnn/src/nnn.c"
0
# 6343 "project/nnn/src/nnn.c" 3 4
)
# 6343 "project/nnn/src/nnn.c"
          ;
}

static inline void markhovered(void)
{
 if (cfg.showdetail && ndents) {
  
# 6349 "project/nnn/src/nnn.c" 3 4
 wmove(stdscr,
# 6349 "project/nnn/src/nnn.c"
 cur + 2 - curscroll
# 6349 "project/nnn/src/nnn.c" 3 4
 ,
# 6349 "project/nnn/src/nnn.c"
 0
# 6349 "project/nnn/src/nnn.c" 3 4
 )
# 6349 "project/nnn/src/nnn.c"
           ;



  
# 6353 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6353 "project/nnn/src/nnn.c"
 ' ' | 
# 6353 "project/nnn/src/nnn.c" 3 4
 ((1U) << ((10) + 8)))
# 6353 "project/nnn/src/nnn.c"
                       ;

 }
}

static int adjust_cols(int n)
{




 if (cfg.showdetail) {

  if (n < 36)
   cfg.showdetail ^= 1;
  else
   n -= 32;
 }


 return (n - 2);
}

static void draw_line(int ncols)
{
 
# 6378 "project/nnn/src/nnn.c" 3 4
_Bool 
# 6378 "project/nnn/src/nnn.c"
     dir = 
# 6378 "project/nnn/src/nnn.c" 3 4
           0
# 6378 "project/nnn/src/nnn.c"
                ;

 ncols = adjust_cols(ncols);

 if (g_state.oldcolor && (pdents[last].flags & 0x01)) {
  
# 6383 "project/nnn/src/nnn.c" 3 4
 wattr_on(stdscr, (attr_t)(((
# 6383 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 6383 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8)) 
# 6383 "project/nnn/src/nnn.c"
 | 
# 6383 "project/nnn/src/nnn.c" 3 4
 ((1U) << ((13) + 8))), ((void *)0))
# 6383 "project/nnn/src/nnn.c"
                                            ;
  dir = 
# 6384 "project/nnn/src/nnn.c" 3 4
       1
# 6384 "project/nnn/src/nnn.c"
           ;
 }

 
# 6387 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 6387 "project/nnn/src/nnn.c"
2 + last - curscroll
# 6387 "project/nnn/src/nnn.c" 3 4
,
# 6387 "project/nnn/src/nnn.c"
0
# 6387 "project/nnn/src/nnn.c" 3 4
)
# 6387 "project/nnn/src/nnn.c"
                             ;
 printent(&pdents[last], ncols, 
# 6388 "project/nnn/src/nnn.c" 3 4
                               0
# 6388 "project/nnn/src/nnn.c"
                                    );

 if (g_state.oldcolor && (pdents[cur].flags & 0x01)) {
  if (!dir) {
   
# 6392 "project/nnn/src/nnn.c" 3 4
  wattr_on(stdscr, (attr_t)(((
# 6392 "project/nnn/src/nnn.c"
  cfg.curctx + 1
# 6392 "project/nnn/src/nnn.c" 3 4
  ) << ((0) + 8)) 
# 6392 "project/nnn/src/nnn.c"
  | 
# 6392 "project/nnn/src/nnn.c" 3 4
  ((1U) << ((13) + 8))), ((void *)0))
# 6392 "project/nnn/src/nnn.c"
                                             ;
   dir = 
# 6393 "project/nnn/src/nnn.c" 3 4
        1
# 6393 "project/nnn/src/nnn.c"
            ;
  }
 } else if (dir) {
  
# 6396 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(((
# 6396 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 6396 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8)) 
# 6396 "project/nnn/src/nnn.c"
 | 
# 6396 "project/nnn/src/nnn.c" 3 4
 ((1U) << ((13) + 8))), ((void *)0))
# 6396 "project/nnn/src/nnn.c"
                                             ;
  dir = 
# 6397 "project/nnn/src/nnn.c" 3 4
       0
# 6397 "project/nnn/src/nnn.c"
            ;
 }

 
# 6400 "project/nnn/src/nnn.c" 3 4
wmove(stdscr,
# 6400 "project/nnn/src/nnn.c"
2 + cur - curscroll
# 6400 "project/nnn/src/nnn.c" 3 4
,
# 6400 "project/nnn/src/nnn.c"
0
# 6400 "project/nnn/src/nnn.c" 3 4
)
# 6400 "project/nnn/src/nnn.c"
                            ;
 printent(&pdents[cur], ncols, 
# 6401 "project/nnn/src/nnn.c" 3 4
                              1
# 6401 "project/nnn/src/nnn.c"
                                  );


 if (dir)
  
# 6405 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(((
# 6405 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 6405 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8)) 
# 6405 "project/nnn/src/nnn.c"
 | 
# 6405 "project/nnn/src/nnn.c" 3 4
 ((1U) << ((13) + 8))), ((void *)0))
# 6405 "project/nnn/src/nnn.c"
                                             ;

 markhovered();
}

static void redraw(char *path)
{
 
# 6412 "project/nnn/src/nnn.c" 3 4
(
# 6412 "project/nnn/src/nnn.c"
xlines 
# 6412 "project/nnn/src/nnn.c" 3 4
= getmaxy(
# 6412 "project/nnn/src/nnn.c"
stdscr
# 6412 "project/nnn/src/nnn.c" 3 4
), 
# 6412 "project/nnn/src/nnn.c"
xcols 
# 6412 "project/nnn/src/nnn.c" 3 4
= getmaxx(
# 6412 "project/nnn/src/nnn.c"
stdscr
# 6412 "project/nnn/src/nnn.c" 3 4
))
# 6412 "project/nnn/src/nnn.c"
                               ;

 int ncols = (xcols <= 
# 6414 "project/nnn/src/nnn.c" 3 4
                      1024
# 6414 "project/nnn/src/nnn.c"
                              ) ? xcols : 
# 6414 "project/nnn/src/nnn.c" 3 4
                                          1024
# 6414 "project/nnn/src/nnn.c"
                                                  ;
 int onscreen = xlines - 4;
 int i, j = 1;


 if (g_state.move) {
  g_state.move = 0;

  if (ndents && (last_curscroll == curscroll))
   return draw_line(ncols);
 }

 ;


 
# 6429 "project/nnn/src/nnn.c" 3 4
werase(stdscr)
# 6429 "project/nnn/src/nnn.c"
       ;


 move_cursor(cur, 1);


 if (ncols <= (4 * 2)) {
  printmsg(messages[29]);
  return;
 }


 ;

 for (i = 0; i < 4; ++i) {
  if (!g_ctx[i].c_cfg.ctxactive)
   
# 6445 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6445 "project/nnn/src/nnn.c"
  i + '1'
# 6445 "project/nnn/src/nnn.c" 3 4
  )
# 6445 "project/nnn/src/nnn.c"
                ;
  else
   
# 6447 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6447 "project/nnn/src/nnn.c"
  (i + '1') | (
# 6447 "project/nnn/src/nnn.c" 3 4
  ((
# 6447 "project/nnn/src/nnn.c"
  i + 1
# 6447 "project/nnn/src/nnn.c" 3 4
  ) << ((0) + 8)) 
# 6447 "project/nnn/src/nnn.c"
  | 
# 6447 "project/nnn/src/nnn.c" 3 4
  ((1U) << ((13) + 8)) 
# 6447 "project/nnn/src/nnn.c"
  | ((cfg.curctx != i) ? 
# 6447 "project/nnn/src/nnn.c" 3 4
  ((1U) << ((9) + 8)) 
# 6447 "project/nnn/src/nnn.c"
  : 
# 6447 "project/nnn/src/nnn.c" 3 4
  ((1U) << ((10) + 8))
# 6447 "project/nnn/src/nnn.c"
  ))
# 6447 "project/nnn/src/nnn.c" 3 4
  )

                                                     
# 6449 "project/nnn/src/nnn.c"
                                                    ;

  
# 6451 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6451 "project/nnn/src/nnn.c"
 ' '
# 6451 "project/nnn/src/nnn.c" 3 4
 )
# 6451 "project/nnn/src/nnn.c"
           ;
 }

 
# 6454 "project/nnn/src/nnn.c" 3 4
wattr_on(stdscr, (attr_t)(((1U) << ((9) + 8)) 
# 6454 "project/nnn/src/nnn.c"
| 
# 6454 "project/nnn/src/nnn.c" 3 4
((
# 6454 "project/nnn/src/nnn.c"
cfg.curctx + 1
# 6454 "project/nnn/src/nnn.c" 3 4
) << ((0) + 8))), ((void *)0))
# 6454 "project/nnn/src/nnn.c"
                                                ;


 
# 6457 "project/nnn/src/nnn.c" 3 4
_Bool 
# 6457 "project/nnn/src/nnn.c"
     in_home = set_tilde_in_path(path);
 char *ptr = in_home ? &path[homelen - 1] : path;

 i = (int)xstrlen(ptr);
 if ((i + (4 * 2)) <= ncols)
  
# 6462 "project/nnn/src/nnn.c" 3 4
 waddnstr(stdscr,
# 6462 "project/nnn/src/nnn.c"
 ptr
# 6462 "project/nnn/src/nnn.c" 3 4
 ,
# 6462 "project/nnn/src/nnn.c"
 ncols - (4 * 2)
# 6462 "project/nnn/src/nnn.c" 3 4
 )
# 6462 "project/nnn/src/nnn.c"
                                      ;
 else {
  char *base = xmemrchr((uchar_t *)ptr, '/', i);

  if (in_home) {
   
# 6467 "project/nnn/src/nnn.c" 3 4
  waddch(stdscr,
# 6467 "project/nnn/src/nnn.c"
  *ptr
# 6467 "project/nnn/src/nnn.c" 3 4
  )
# 6467 "project/nnn/src/nnn.c"
             ;
   ++ptr;
   i = 1;
  } else
   i = 0;

  if (ptr && (base != ptr)) {
   while (ptr < base) {
    if (*ptr == '/') {
     i += 2;
     if (ncols < i + (4 * 2)) {
      base = 
# 6478 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 6478 "project/nnn/src/nnn.c"
                ;
      break;
     }

     
# 6482 "project/nnn/src/nnn.c" 3 4
    waddch(stdscr,
# 6482 "project/nnn/src/nnn.c"
    *ptr
# 6482 "project/nnn/src/nnn.c" 3 4
    )
# 6482 "project/nnn/src/nnn.c"
               ;
     
# 6483 "project/nnn/src/nnn.c" 3 4
    waddch(stdscr,
# 6483 "project/nnn/src/nnn.c"
    *(++ptr)
# 6483 "project/nnn/src/nnn.c" 3 4
    )
# 6483 "project/nnn/src/nnn.c"
                   ;
    }
    ++ptr;
   }
  }

  if (base)
   
# 6490 "project/nnn/src/nnn.c" 3 4
  waddnstr(stdscr,
# 6490 "project/nnn/src/nnn.c"
  base
# 6490 "project/nnn/src/nnn.c" 3 4
  ,
# 6490 "project/nnn/src/nnn.c"
  ncols - ((4 * 2) + i)
# 6490 "project/nnn/src/nnn.c" 3 4
  )
# 6490 "project/nnn/src/nnn.c"
                                              ;
 }

 if (in_home)
  reset_tilde_in_path(path);

 
# 6496 "project/nnn/src/nnn.c" 3 4
wattr_off(stdscr, (attr_t)(((1U) << ((9) + 8)) 
# 6496 "project/nnn/src/nnn.c"
| 
# 6496 "project/nnn/src/nnn.c" 3 4
((
# 6496 "project/nnn/src/nnn.c"
cfg.curctx + 1
# 6496 "project/nnn/src/nnn.c" 3 4
) << ((0) + 8))), ((void *)0))
# 6496 "project/nnn/src/nnn.c"
                                                 ;


 if (curscroll > 0) {
  
# 6500 "project/nnn/src/nnn.c" 3 4
 wmove(stdscr,
# 6500 "project/nnn/src/nnn.c"
 1
# 6500 "project/nnn/src/nnn.c" 3 4
 ,
# 6500 "project/nnn/src/nnn.c"
 0
# 6500 "project/nnn/src/nnn.c" 3 4
 )
# 6500 "project/nnn/src/nnn.c"
           ;



  
# 6504 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6504 "project/nnn/src/nnn.c"
 '^'
# 6504 "project/nnn/src/nnn.c" 3 4
 )
# 6504 "project/nnn/src/nnn.c"
           ;

 }

 if (g_state.oldcolor) {
  
# 6509 "project/nnn/src/nnn.c" 3 4
 wattr_on(stdscr, (attr_t)(((
# 6509 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 6509 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8)) 
# 6509 "project/nnn/src/nnn.c"
 | 
# 6509 "project/nnn/src/nnn.c" 3 4
 ((1U) << ((13) + 8))), ((void *)0))
# 6509 "project/nnn/src/nnn.c"
                                            ;
  g_state.dircolor = 1;
 }

 onscreen = ((onscreen + curscroll) < (ndents) ? (onscreen + curscroll) : (ndents));

 ncols = adjust_cols(ncols);

 int len = scanselforpath(path, 
# 6517 "project/nnn/src/nnn.c" 3 4
                               0
# 6517 "project/nnn/src/nnn.c"
                                    );


 for (i = curscroll; i < onscreen; ++i) {
  
# 6521 "project/nnn/src/nnn.c" 3 4
 wmove(stdscr,
# 6521 "project/nnn/src/nnn.c"
 ++j
# 6521 "project/nnn/src/nnn.c" 3 4
 ,
# 6521 "project/nnn/src/nnn.c"
 0
# 6521 "project/nnn/src/nnn.c" 3 4
 )
# 6521 "project/nnn/src/nnn.c"
             ;

  if (len)
   findmarkentry(len, &pdents[i]);

  printent(&pdents[i], ncols, i == cur);
 }


 if (g_state.dircolor) {
  
# 6531 "project/nnn/src/nnn.c" 3 4
 wattr_off(stdscr, (attr_t)(((
# 6531 "project/nnn/src/nnn.c"
 cfg.curctx + 1
# 6531 "project/nnn/src/nnn.c" 3 4
 ) << ((0) + 8)) 
# 6531 "project/nnn/src/nnn.c"
 | 
# 6531 "project/nnn/src/nnn.c" 3 4
 ((1U) << ((13) + 8))), ((void *)0))
# 6531 "project/nnn/src/nnn.c"
                                             ;
  g_state.dircolor = 0;
 }


 if (onscreen < ndents) {
  
# 6537 "project/nnn/src/nnn.c" 3 4
 wmove(stdscr,
# 6537 "project/nnn/src/nnn.c"
 xlines - 2
# 6537 "project/nnn/src/nnn.c" 3 4
 ,
# 6537 "project/nnn/src/nnn.c"
 0
# 6537 "project/nnn/src/nnn.c" 3 4
 )
# 6537 "project/nnn/src/nnn.c"
                    ;



  
# 6541 "project/nnn/src/nnn.c" 3 4
 waddch(stdscr,
# 6541 "project/nnn/src/nnn.c"
 'v'
# 6541 "project/nnn/src/nnn.c" 3 4
 )
# 6541 "project/nnn/src/nnn.c"
           ;

 }

 markhovered();
}

static 
# 6548 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 6548 "project/nnn/src/nnn.c"
           cdprep(char *lastdir, char *lastname, char *path, char *newpath)
{
 if (lastname)
  lastname[0] = '\0';


 xstrsncpy(lastdir, path, 
# 6554 "project/nnn/src/nnn.c" 3 4
                         1024
# 6554 "project/nnn/src/nnn.c"
                                 );


 xstrsncpy(path, newpath, 
# 6557 "project/nnn/src/nnn.c" 3 4
                         1024
# 6557 "project/nnn/src/nnn.c"
                                 );
 ;

 clearfilter();
 return cfg.filtermode;
}

static 
# 6564 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 6564 "project/nnn/src/nnn.c"
           browse(char *ipath, const char *session, int pkey)
{
 char newpath[
# 6566 "project/nnn/src/nnn.c" 3 4
             1024
# 6566 "project/nnn/src/nnn.c"
                     ] __attribute__ ((aligned)),
      rundir[
# 6567 "project/nnn/src/nnn.c" 3 4
            1024
# 6567 "project/nnn/src/nnn.c"
                    ] __attribute__ ((aligned)),
      runfile[
# 6568 "project/nnn/src/nnn.c" 3 4
             255 
# 6568 "project/nnn/src/nnn.c"
                      + 1] __attribute__ ((aligned));
 char *path, *lastdir, *lastname, *dir, *tmp;
 pEntry pent;
 enum action sel;
 struct stat sb;
 int r = -1, presel, selstartid = 0, selendid = 0;
 const uchar_t opener_flags = (cfg.cliopener ? (0x08 | 0x01) : (0x04 | 0x40 | 0x02));
 
# 6575 "project/nnn/src/nnn.c" 3 4
_Bool 
# 6575 "project/nnn/src/nnn.c"
     watch = 
# 6575 "project/nnn/src/nnn.c" 3 4
             0
# 6575 "project/nnn/src/nnn.c"
                  , cd = 
# 6575 "project/nnn/src/nnn.c" 3 4
                         1
# 6575 "project/nnn/src/nnn.c"
                             ;
 ino_t inode = 0;


 MEVENT event = {0};
 struct timespec mousetimings[2] = {{.tv_sec = 0, .tv_nsec = 0}, {.tv_sec = 0, .tv_nsec = 0} };
 int mousedent[2] = {-1, -1};
 
# 6582 "project/nnn/src/nnn.c" 3 4
_Bool 
# 6582 "project/nnn/src/nnn.c"
     currentmouse = 1, rightclicksel = 0;


 atexit(dentfree);

 
# 6587 "project/nnn/src/nnn.c" 3 4
(
# 6587 "project/nnn/src/nnn.c"
xlines 
# 6587 "project/nnn/src/nnn.c" 3 4
= getmaxy(
# 6587 "project/nnn/src/nnn.c"
stdscr
# 6587 "project/nnn/src/nnn.c" 3 4
), 
# 6587 "project/nnn/src/nnn.c"
xcols 
# 6587 "project/nnn/src/nnn.c" 3 4
= getmaxx(
# 6587 "project/nnn/src/nnn.c"
stdscr
# 6587 "project/nnn/src/nnn.c" 3 4
))
# 6587 "project/nnn/src/nnn.c"
                               ;



 if (!session || !load_session(session, &path, &lastdir, &lastname, 
# 6591 "project/nnn/src/nnn.c" 3 4
                                                                   0
# 6591 "project/nnn/src/nnn.c"
                                                                        )) {



  g_ctx[0].c_last[0] = '\0';
  lastdir = g_ctx[0].c_last;

  if (g_state.initfile) {
   xstrsncpy(g_ctx[0].c_name, xbasename(ipath), sizeof(g_ctx[0].c_name));
   xdirname(ipath);
  } else
   g_ctx[0].c_name[0] = '\0';

  lastname = g_ctx[0].c_name;

  xstrsncpy(g_ctx[0].c_path, ipath, 
# 6606 "project/nnn/src/nnn.c" 3 4
                                   1024
# 6606 "project/nnn/src/nnn.c"
                                           );

  if (g_state.initfile) {
   free(initpath);
   initpath = ipath = getcwd(
# 6610 "project/nnn/src/nnn.c" 3 4
                            ((void *)0)
# 6610 "project/nnn/src/nnn.c"
                                , 0);
  }
  path = g_ctx[0].c_path;

  g_ctx[0].c_fltr[0] = g_ctx[0].c_fltr[1] = '\0';
  g_ctx[0].c_cfg = cfg;

 }


 newpath[0] = rundir[0] = runfile[0] = '\0';

 presel = pkey ? ';' : ((cfg.filtermode
   || (session && (g_ctx[cfg.curctx].c_fltr[0] == '/'
    || g_ctx[cfg.curctx].c_fltr[0] == '\\')
    && g_ctx[cfg.curctx].c_fltr[1])) ? '/' : 0);

 pdents = xrealloc(pdents, total_dents * sizeof(struct entry));
 if (!pdents)
  printerr(6629);


 pnamebuf = (char *)xrealloc(pnamebuf, 0x800);
 if (!pnamebuf)
  printerr(6634);

begin:




 if (chdir(path) == -1) {
  ;
  valid_parent(path, lastname);
  (cfg.filtermode ? (presel = '/') : (watch = 
# 6644 "project/nnn/src/nnn.c" 3 4
 1
# 6644 "project/nnn/src/nnn.c"
 ));
 }


 xterm_cfg(path);
# 6658 "project/nnn/src/nnn.c"
 if ((presel == '/' || watch) && event_fd >= 0) {
  close(event_fd);
  event_fd = -1;
  watch = 
# 6661 "project/nnn/src/nnn.c" 3 4
         0
# 6661 "project/nnn/src/nnn.c"
              ;
 }
# 6671 "project/nnn/src/nnn.c"
 if (order && cd) {
  if (cfgsort[cfg.curctx] != '0') {
   if (cfgsort[cfg.curctx] == 'z')
    set_sort_flags('c');
   if ((!cfgsort[cfg.curctx] || (cfgsort[cfg.curctx] == 'c'))
       && ((r = get_kv_key(order, path, maxorder, 11)) > 0)) {
    set_sort_flags(r);
    cfgsort[cfg.curctx] = 'z';
   }
  } else
   cfgsort[cfg.curctx] = cfgsort[4];
 }
 cd = 
# 6683 "project/nnn/src/nnn.c" 3 4
     1
# 6683 "project/nnn/src/nnn.c"
         ;

 populate(path, lastname);
 if (g_state.interrupt) {
  g_state.interrupt = cfg.apparentsz = cfg.blkorder = 0;
  blk_shift = 9;
  presel = (('L') & 0x1f);
 }





 if (presel != '/' && event_fd == -1) {

  event_fd = open(path, 
# 6698 "project/nnn/src/nnn.c" 3 4
                       0x00008000
# 6698 "project/nnn/src/nnn.c"
                                );



  if (event_fd >= 0)
   
# 6703 "project/nnn/src/nnn.c" 3 4
  do { struct kevent *__kevp__ = (
# 6703 "project/nnn/src/nnn.c"
  &events_to_monitor[0]
# 6703 "project/nnn/src/nnn.c" 3 4
  ); __kevp__->ident = (
# 6703 "project/nnn/src/nnn.c"
  event_fd
# 6703 "project/nnn/src/nnn.c" 3 4
  ); __kevp__->filter = ((-4)); __kevp__->flags = (0x0001 
# 6703 "project/nnn/src/nnn.c"
  | 
# 6703 "project/nnn/src/nnn.c" 3 4
  0x0020); __kevp__->fflags = (
# 6703 "project/nnn/src/nnn.c"
  KQUEUE_FFLAGS
# 6703 "project/nnn/src/nnn.c" 3 4
  ); __kevp__->data = (
# 6703 "project/nnn/src/nnn.c"
  0
# 6703 "project/nnn/src/nnn.c" 3 4
  ); __kevp__->udata = (
# 6703 "project/nnn/src/nnn.c"
  path
# 6703 "project/nnn/src/nnn.c" 3 4
  ); } while(0)
                                                    
# 6704 "project/nnn/src/nnn.c"
                                                   ;
 }




 while (1) {

  if ((presel != '/') || !(g_ctx[cfg.curctx].c_fltr[1])) {
   redraw(path);
   statusbar(path);
  }

nochange:

  if (getppid() == 1)
   _exit(
# 6720 "project/nnn/src/nnn.c" 3 4
        1
# 6720 "project/nnn/src/nnn.c"
                    );


  if (chdir(path) == -1)
   goto begin;


  if (!isatty(
# 6727 "project/nnn/src/nnn.c" 3 4
             0
# 6727 "project/nnn/src/nnn.c"
                         ) && !g_state.picker)
   return 
# 6728 "project/nnn/src/nnn.c" 3 4
         1
# 6728 "project/nnn/src/nnn.c"
                     ;

  sel = nextsel(presel);
  if (presel)
   presel = 0;

  switch (sel) {

  case SEL_CLICK:
   if (getmouse(&event) != 
# 6737 "project/nnn/src/nnn.c" 3 4
                          (0)
# 6737 "project/nnn/src/nnn.c"
                            )
    goto nochange;


   if (event.bstate == 
# 6741 "project/nnn/src/nnn.c" 3 4
                      ((002L) << (((1) - 1) * 6)) 
# 6741 "project/nnn/src/nnn.c"
                                      && event.y == 0) {

    r = event.x >> 1;


    if (r >= 4)
     sel = SEL_BACK;
    else if (r >= 0 && r != cfg.curctx) {
     savecurctx(path, ndents ? pdents[cur].name : 
# 6749 "project/nnn/src/nnn.c" 3 4
                                                 ((void *)0)
# 6749 "project/nnn/src/nnn.c"
                                                     , r);


     path = g_ctx[r].c_path;
     lastdir = g_ctx[r].c_last;
     lastname = g_ctx[r].c_name;

     (cfg.filtermode ? (presel = '/') : (watch = 
# 6756 "project/nnn/src/nnn.c" 3 4
    1
# 6756 "project/nnn/src/nnn.c"
    ));
     goto begin;
    }
   }


  case SEL_BACK:

   if (sel == SEL_BACK) {

    dir = visit_parent(path, newpath, &presel);
    if (!dir)
     goto nochange;


    xstrsncpy(lastname, xbasename(path), 
# 6771 "project/nnn/src/nnn.c" 3 4
                                        255 
# 6771 "project/nnn/src/nnn.c"
                                                 + 1);

    cdprep(lastdir, 
# 6773 "project/nnn/src/nnn.c" 3 4
                   ((void *)0)
# 6773 "project/nnn/src/nnn.c"
                       , path, dir) ? (presel = '/') : (watch = 
# 6773 "project/nnn/src/nnn.c" 3 4
                                                                   1
# 6773 "project/nnn/src/nnn.c"
                                                                       );
    goto begin;

   }




   if (event.bstate == 
# 6781 "project/nnn/src/nnn.c" 3 4
                      ((002L) << (((2) - 1) * 6))
# 6781 "project/nnn/src/nnn.c"
                                     ) {
    presel = middle_click_key;
    goto nochange;
   }
# 6803 "project/nnn/src/nnn.c"
   if (event.y >= xlines - 2 && event.bstate == 
# 6803 "project/nnn/src/nnn.c" 3 4
                                               ((002L) << (((1) - 1) * 6))
# 6803 "project/nnn/src/nnn.c"
                                                              ) {
    clearfilter();
    cfg.filtermode ^= 1;
    if (cfg.filtermode) {
     presel = '/';
     goto nochange;
    }


    watch = 
# 6812 "project/nnn/src/nnn.c" 3 4
           1
# 6812 "project/nnn/src/nnn.c"
               ;
    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 6813 "project/nnn/src/nnn.c" 3 4
   255 
# 6813 "project/nnn/src/nnn.c"
   + 1);
    cd = 
# 6814 "project/nnn/src/nnn.c" 3 4
        0
# 6814 "project/nnn/src/nnn.c"
             ;
    goto begin;
   }


   if (event.y >= 2 && event.y <= ndents + 1 &&
     (event.bstate == 
# 6820 "project/nnn/src/nnn.c" 3 4
                     ((002L) << (((1) - 1) * 6)) 
# 6820 "project/nnn/src/nnn.c"
                                     ||
      event.bstate == 
# 6821 "project/nnn/src/nnn.c" 3 4
                     ((002L) << (((3) - 1) * 6))
# 6821 "project/nnn/src/nnn.c"
                                    )) {
    r = curscroll + (event.y - 2);
    if (r != cur)
     move_cursor(r, 1);

    else if ((event.bstate == 
# 6826 "project/nnn/src/nnn.c" 3 4
                             ((002L) << (((1) - 1) * 6))
# 6826 "project/nnn/src/nnn.c"
                                            ) && !g_state.fifomode)
     notify_fifo(
# 6827 "project/nnn/src/nnn.c" 3 4
                1
# 6827 "project/nnn/src/nnn.c"
                    );


    if (event.bstate == 
# 6830 "project/nnn/src/nnn.c" 3 4
                       ((002L) << (((3) - 1) * 6))
# 6830 "project/nnn/src/nnn.c"
                                      ) {
     rightclicksel = 1;
     presel = ' ';
     goto nochange;
    }

    currentmouse ^= 1;
    clock_gettime(

        
# 6839 "project/nnn/src/nnn.c" 3 4
       _CLOCK_MONOTONIC_RAW
# 6839 "project/nnn/src/nnn.c"
                          ,





        &mousetimings[currentmouse]);
    mousedent[currentmouse] = cur;


    if ((mousedent[0] != mousedent[1]) ||
      ((((((mousetimings[0].tv_sec) <= (mousetimings[1].tv_sec)) ? ((mousetimings[1].tv_sec) - (mousetimings[0].tv_sec)) : ((mousetimings[0].tv_sec) - (mousetimings[1].tv_sec))) << 30)
      + ((((mousetimings[0].tv_nsec) <= (mousetimings[1].tv_nsec)) ? ((mousetimings[1].tv_nsec) - (mousetimings[0].tv_nsec)) : ((mousetimings[0].tv_nsec) - (mousetimings[1].tv_nsec)))))
     > (400000000)))
     break;

    mousetimings[currentmouse].tv_sec = 0;
    mousedent[currentmouse] = -1;
    sel = SEL_OPEN;
   } else {
    if (cfg.filtermode || (g_ctx[cfg.curctx].c_fltr[1]))
     presel = '/';
    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 6861 "project/nnn/src/nnn.c" 3 4
   255 
# 6861 "project/nnn/src/nnn.c"
   + 1);
    goto nochange;
   }


  case SEL_NAV_IN:
  case SEL_OPEN:

   if (!ndents) {
    cd = 
# 6870 "project/nnn/src/nnn.c" 3 4
        0
# 6870 "project/nnn/src/nnn.c"
             ;
    goto begin;
   }

   pent = &pdents[cur];
   mkpath(path, pent->name, newpath);
   ;


   if (pent->flags & 0x01) {
    if (chdir(newpath) == -1) {
     printwait(strerror(
# 6881 "project/nnn/src/nnn.c" 3 4
    (*__error())
# 6881 "project/nnn/src/nnn.c"
    ), &presel);
     goto nochange;
    }

    cdprep(lastdir, lastname, path, newpath)
     ? (presel = '/') : (watch = 
# 6886 "project/nnn/src/nnn.c" 3 4
                                   1
# 6886 "project/nnn/src/nnn.c"
                                       );
    goto begin;
   }


   if (stat(newpath, &sb) == -1) {
    printwait(strerror(
# 6892 "project/nnn/src/nnn.c" 3 4
   (*__error())
# 6892 "project/nnn/src/nnn.c"
   ), &presel);
    goto nochange;
   }
   ;


   if (!
# 6898 "project/nnn/src/nnn.c" 3 4
       (((
# 6898 "project/nnn/src/nnn.c"
       sb.st_mode
# 6898 "project/nnn/src/nnn.c" 3 4
       ) & 0170000) == 0100000)
# 6898 "project/nnn/src/nnn.c"
                          ) {
    printwait(messages[26], &presel);
    goto nochange;
                        }


   if (g_state.runplugin) {
    g_state.runplugin = 0;

    if ((g_state.runctx == cfg.curctx) && !strcmp(path, plgpath)) {
     endselection(
# 6908 "project/nnn/src/nnn.c" 3 4
                 0
# 6908 "project/nnn/src/nnn.c"
                      );

     xstrsncpy(path, rundir, 
# 6910 "project/nnn/src/nnn.c" 3 4
                            1024
# 6910 "project/nnn/src/nnn.c"
                                    );
     rundir[0] = '\0';
     clearfilter();

     if (chdir(path) == -1
         || !run_plugin(&path, pent->name,
            runfile, &lastname, &lastdir)) {
      ;
     }

     if (g_state.picked)
      return 
# 6921 "project/nnn/src/nnn.c" 3 4
            0
# 6921 "project/nnn/src/nnn.c"
                        ;

     if (runfile[0]) {
      xstrsncpy(lastname, runfile, 
# 6924 "project/nnn/src/nnn.c" 3 4
                                  255 
# 6924 "project/nnn/src/nnn.c"
                                           + 1);
      runfile[0] = '\0';
     }
     (cfg.filtermode ? (presel = '/') : (watch = 
# 6927 "project/nnn/src/nnn.c" 3 4
    1
# 6927 "project/nnn/src/nnn.c"
    ));
     goto begin;
    }
   }


   if (g_state.fifomode && (sel == SEL_OPEN)) {
    send_to_explorer(&presel);
    break;
   }


   if (g_state.picker && (sel == SEL_OPEN)) {
    if (nselected == 0)
     appendfpath(newpath, mkpath(path, pent->name, newpath));
    return 
# 6942 "project/nnn/src/nnn.c" 3 4
          0
# 6942 "project/nnn/src/nnn.c"
                      ;
   }

   if (sel == SEL_NAV_IN) {

    if (listpath && 
# 6947 "project/nnn/src/nnn.c" 3 4
                   (((
# 6947 "project/nnn/src/nnn.c"
                   pent->mode
# 6947 "project/nnn/src/nnn.c" 3 4
                   ) & 0170000) == 0120000)
        
# 6948 "project/nnn/src/nnn.c"
       && is_prefix(path, listpath, xstrlen(listpath))) {
     if (!realpath(pent->name, newpath)) {
      printwait(strerror(
# 6950 "project/nnn/src/nnn.c" 3 4
     (*__error())
# 6950 "project/nnn/src/nnn.c"
     ), &presel);
      goto nochange;
     }

     xdirname(newpath);

     if (chdir(newpath) == -1) {
      printwait(strerror(
# 6957 "project/nnn/src/nnn.c" 3 4
     (*__error())
# 6957 "project/nnn/src/nnn.c"
     ), &presel);
      goto nochange;
     }

     cdprep(lastdir, 
# 6961 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 6961 "project/nnn/src/nnn.c"
                        , path, newpath)
            ? (presel = '/') : (watch = 
# 6962 "project/nnn/src/nnn.c" 3 4
                                          1
# 6962 "project/nnn/src/nnn.c"
                                              );
     xstrsncpy(lastname, pent->name, 
# 6963 "project/nnn/src/nnn.c" 3 4
                                    255 
# 6963 "project/nnn/src/nnn.c"
                                             + 1);
     goto begin;
    }


    if (cfg.nonavopen)
     goto nochange;
   }

   if (!sb.st_size) {
    printwait(messages[25], &presel);
    goto nochange;
   }

   if (cfg.useeditor

       && get_output("file", "-bIL", newpath, -1, 
# 6979 "project/nnn/src/nnn.c" 3 4
                                                         0
# 6979 "project/nnn/src/nnn.c"
                                                              , 
# 6979 "project/nnn/src/nnn.c" 3 4
                                                                0
# 6979 "project/nnn/src/nnn.c"
                                                                     )
       && is_prefix(g_buf, "text/", 5)





   ) {
    spawn(editor, newpath, 
# 6987 "project/nnn/src/nnn.c" 3 4
                          ((void *)0)
# 6987 "project/nnn/src/nnn.c"
                              , 
# 6987 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 6987 "project/nnn/src/nnn.c"
                                    , (0x08 | 0x01));
    if (cfg.filtermode) {
     presel = '/';
     clearfilter();
    }
    continue;
   }


   tmp = xextension(pent->name, pent->nlen - 1);




   if (tmp && !regexec(&archive_re, tmp, 0, 
# 7001 "project/nnn/src/nnn.c" 3 4
                                           ((void *)0)
# 7001 "project/nnn/src/nnn.c"
                                               , 0)) {

    r = get_input(messages[33]);
    if (r == 'l' || r == 'x') {
     mkpath(path, pent->name, newpath);
     if (!handle_archive(newpath, r)) {
      presel = '$';
      goto nochange;
     }
     if (r == 'l') {
      statusbar(path);
      goto nochange;
     }
    }

    if ((r == 'm') && !archive_mount(newpath)) {
     presel = '$';
     goto nochange;
    }

    if (r == 'x' || r == 'm') {
     if (newpath[0])
      set_smart_ctx('+', newpath, &path,
             ndents ? pdents[cur].name : 
# 7024 "project/nnn/src/nnn.c" 3 4
                                        ((void *)0)
# 7024 "project/nnn/src/nnn.c"
                                            ,
             &lastname, &lastdir);
     else
      xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7027 "project/nnn/src/nnn.c" 3 4
     255 
# 7027 "project/nnn/src/nnn.c"
     + 1);
     clearfilter();
     goto begin;
    }

    if (r != 'o') {
     printwait(messages[40], &presel);
     goto nochange;
    }
   }


   spawn(opener, newpath, 
# 7039 "project/nnn/src/nnn.c" 3 4
                         ((void *)0)
# 7039 "project/nnn/src/nnn.c"
                             , 
# 7039 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 7039 "project/nnn/src/nnn.c"
                                   , opener_flags);


   if (g_state.autonext && cur != ndents - 1)
    move_cursor((cur + 1) % ndents, 0);
   if (cfg.filtermode) {
    presel = '/';
    clearfilter();
   }
   continue;
  case SEL_NEXT:
  case SEL_PREV:
  case SEL_PGDN:
  case SEL_CTRL_D:
  case SEL_PGUP:
  case SEL_CTRL_U:
  case SEL_HOME:
  case SEL_END:
  case SEL_FIRST:
   if (ndents) {
    g_state.move = 1;
    handle_screen_move(sel);
   }
   break;
  case SEL_CDHOME:
  case SEL_CDBEGIN:
  case SEL_CDLAST:
  case SEL_CDROOT:
   dir = (sel == SEL_CDHOME) ? home
    : ((sel == SEL_CDBEGIN) ? ipath
    : ((sel == SEL_CDLAST) ? lastdir
    : "/" ));

   if (!dir || !*dir) {
    printwait(messages[27], &presel);
    goto nochange;
   }

   if (strcmp(path, dir) == 0) {
    if (dir == ipath) {
     if (cfg.filtermode)
      presel = '/';
     goto nochange;
    }
    dir = lastdir;
   }

   if (chdir(dir) == -1) {
    presel = '$';
    goto nochange;
   }


   xstrsncpy(newpath, dir, 
# 7092 "project/nnn/src/nnn.c" 3 4
                          1024
# 7092 "project/nnn/src/nnn.c"
                                  );
  case SEL_BMOPEN:
   if (sel == SEL_BMOPEN) {
    r = (int)handle_bookmark(mark, newpath);
    if (r) {
     printwait(messages[r], &presel);
     goto nochange;
    }

    if (strcmp(path, newpath) == 0)
     break;
   }


   cdprep(lastdir, listpath && sel == SEL_CDLAST ? 
# 7106 "project/nnn/src/nnn.c" 3 4
                                                  ((void *)0) 
# 7106 "project/nnn/src/nnn.c"
                                                       : lastname, path, newpath)
          ? (presel = '/') : (watch = 
# 7107 "project/nnn/src/nnn.c" 3 4
                                        1
# 7107 "project/nnn/src/nnn.c"
                                            );
   goto begin;
  case SEL_REMOTE:
   if ((sel == SEL_REMOTE) && !remote_mount(newpath)) {
    presel = '$';
    goto nochange;
   }

   set_smart_ctx('+', newpath, &path,
          ndents ? pdents[cur].name : 
# 7116 "project/nnn/src/nnn.c" 3 4
                                     ((void *)0)
# 7116 "project/nnn/src/nnn.c"
                                         , &lastname, &lastdir);
   clearfilter();
   goto begin;
  case SEL_CYCLE:
  case SEL_CYCLER:
  case SEL_CTX1:
  case SEL_CTX2:
  case SEL_CTX3:
  case SEL_CTX4:






   r = handle_context_switch(sel);
   if (r < 0)
    continue;
   savecurctx(path, ndents ? pdents[cur].name : 
# 7134 "project/nnn/src/nnn.c" 3 4
                                               ((void *)0)
# 7134 "project/nnn/src/nnn.c"
                                                   , r);


   path = g_ctx[r].c_path;
   lastdir = g_ctx[r].c_last;
   lastname = g_ctx[r].c_name;
   tmp = g_ctx[r].c_fltr;

   if (cfg.filtermode || ((tmp[0] == '/' || tmp[0] == '\\') && tmp[1]))
    presel = '/';
   else
    watch = 
# 7145 "project/nnn/src/nnn.c" 3 4
           1
# 7145 "project/nnn/src/nnn.c"
               ;

   goto begin;
  case SEL_MARK:
   free(mark);
   mark = xstrdup(path);
   printwait(mark, &presel);
   goto nochange;
  case SEL_BMARK:
   add_bookmark(path, newpath, &presel);
   goto nochange;
  case SEL_FLTR:
   if (!ndents)
    goto nochange;







   if (event_fd >= 0) {
    close(event_fd);
    event_fd = -1;
   }






   presel = filterentries(path, lastname);
   if (presel == (27)) {
    presel = 0;
    break;
   }
   if (presel == '/') {
    cd = 
# 7182 "project/nnn/src/nnn.c" 3 4
        0
# 7182 "project/nnn/src/nnn.c"
             ;
    goto begin;
   }
   goto nochange;
  case SEL_MFLTR:
  case SEL_HIDDEN:
  case SEL_DETAIL:
  case SEL_SORT:
   switch (sel) {
   case SEL_MFLTR:
    cfg.filtermode ^= 1;
    if (cfg.filtermode) {
     presel = '/';
     clearfilter();
     goto nochange;
    }

    watch = 
# 7199 "project/nnn/src/nnn.c" 3 4
           1
# 7199 "project/nnn/src/nnn.c"
               ;
   case SEL_HIDDEN:
    if (sel == SEL_HIDDEN) {
     cfg.showhidden ^= 1;
     if (cfg.filtermode)
      presel = '/';
     clearfilter();
    }
    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7207 "project/nnn/src/nnn.c" 3 4
   255 
# 7207 "project/nnn/src/nnn.c"
   + 1);
    cd = 
# 7208 "project/nnn/src/nnn.c" 3 4
        0
# 7208 "project/nnn/src/nnn.c"
             ;
    goto begin;
   case SEL_DETAIL:
    cfg.showdetail ^= 1;
    cfg.blkorder = 0;
    continue;
   default:
    r = set_sort_flags(get_input(messages[36]));
    if (!r) {
     printwait(messages[40], &presel);
     goto nochange;
    }
   }

   if (cfg.filtermode || (g_ctx[cfg.curctx].c_fltr[1]))
    presel = '/';

   if (ndents) {
    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7226 "project/nnn/src/nnn.c" 3 4
   255 
# 7226 "project/nnn/src/nnn.c"
   + 1);

    if (r == 'd' || r == 'a') {
     presel = 0;
     goto begin;
    }

    qsort((pdents), (ndents), sizeof(*(pdents)), (entrycmpfn));
    move_cursor(ndents ? dentfind(lastname, ndents) : 0, 0);
   }
   continue;
  case SEL_STATS:
  case SEL_CHMODX:
   if (ndents) {
    tmp = (listpath && (*(path) != *(listpath) ? -1 : strcmp((path), (listpath))) == 0) ? listroot : path;
    mkpath(tmp, pdents[cur].name, newpath);

    if ((sel == SEL_STATS && !show_stats(newpath))
        || (lstat(newpath, &sb) == -1)
        || (sel == SEL_CHMODX && !xchmod(newpath, sb.st_mode))) {
     printwait(strerror(
# 7246 "project/nnn/src/nnn.c" 3 4
    (*__error())
# 7246 "project/nnn/src/nnn.c"
    ), &presel);
     goto nochange;
    }

    if (sel == SEL_CHMODX)
     pdents[cur].mode ^= 0111;
   }
   break;
  case SEL_REDRAW:
  case SEL_RENAMEMUL:
  case SEL_HELP:
  case SEL_AUTONEXT:
  case SEL_EDIT:
  case SEL_LOCK:
  {
   
# 7261 "project/nnn/src/nnn.c" 3 4
  _Bool 
# 7261 "project/nnn/src/nnn.c"
       refresh = 
# 7261 "project/nnn/src/nnn.c" 3 4
                 0
# 7261 "project/nnn/src/nnn.c"
                      ;

   if (ndents)
    mkpath(path, pdents[cur].name, newpath);
   else if (sel == SEL_EDIT)
    goto nochange;

   switch (sel) {
   case SEL_REDRAW:
    refresh = 
# 7270 "project/nnn/src/nnn.c" 3 4
             1
# 7270 "project/nnn/src/nnn.c"
                 ;
    break;
   case SEL_RENAMEMUL:
    endselection(
# 7273 "project/nnn/src/nnn.c" 3 4
                1
# 7273 "project/nnn/src/nnn.c"
                    );
    setenv("INCLUDE_HIDDEN", xitoa(cfg.showhidden), 1);
    setenv("NNN_LIST", listpath ? listroot : "", 1);

    if (!(getutil(utils[8])
          && plugscript(utils[17], (0x08 | 0x01)))

        && !batch_rename()

    ) {
     printwait(messages[5], &presel);
     goto nochange;
    }
    clearselection();
    refresh = 
# 7287 "project/nnn/src/nnn.c" 3 4
             1
# 7287 "project/nnn/src/nnn.c"
                 ;
    break;
   case SEL_HELP:
    show_help(path);
   case SEL_AUTONEXT:
    if (sel == SEL_AUTONEXT)
     g_state.autonext ^= 1;
    if (cfg.filtermode)
     presel = '/';
    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7296 "project/nnn/src/nnn.c" 3 4
   255 
# 7296 "project/nnn/src/nnn.c"
   + 1);
    goto nochange;
   case SEL_EDIT:
    if (!g_state.picker)
     spawn(editor, newpath, 
# 7300 "project/nnn/src/nnn.c" 3 4
                           ((void *)0)
# 7300 "project/nnn/src/nnn.c"
                               , 
# 7300 "project/nnn/src/nnn.c" 3 4
                                 ((void *)0)
# 7300 "project/nnn/src/nnn.c"
                                     , (0x08 | 0x01));
    continue;
   default:
    lock_terminal();
    break;
   }




   if ((cfg.filtermode || (g_ctx[cfg.curctx].c_fltr[1])) && !refresh) {
    presel = '/';
    goto nochange;
   }


   xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7316 "project/nnn/src/nnn.c" 3 4
  255 
# 7316 "project/nnn/src/nnn.c"
  + 1);

   cd = 
# 7318 "project/nnn/src/nnn.c" 3 4
       0
# 7318 "project/nnn/src/nnn.c"
            ;
   goto begin;
  }
  case SEL_SEL:
   if (!ndents)
    goto nochange;

   startselection();
   if (g_state.rangesel)
    g_state.rangesel = 0;


   pdents[cur].flags ^= 0x10;

   if (pdents[cur].flags & 0x10) {
    ++nselected;
    appendfpath(newpath, mkpath(path, pdents[cur].name, newpath));
    writesel(pselbuf, selbufpos - 1);
   } else {
    --nselected;
    rmfromselbuf(mkpath(path, pdents[cur].name, g_sel));
   }


   if (cfg.x11)
    plugscript(utils[16], 0x02 | 0x04);


   if (rightclicksel)
    rightclicksel = 0;
   else


    if (!g_state.stayonsel && (cur != ndents - 1))
     move_cursor((cur + 1) % ndents, 0);
   break;
  case SEL_SELMUL:
   if (!ndents)
    goto nochange;

   startselection();
   g_state.rangesel ^= 1;

   if (stat(path, &sb) == -1) {
    printwait(strerror(
# 7362 "project/nnn/src/nnn.c" 3 4
   (*__error())
# 7362 "project/nnn/src/nnn.c"
   ), &presel);
    goto nochange;
   }

   if (g_state.rangesel) {
    inode = sb.st_ino;
    selstartid = cur;
    continue;
   }

   if (inode != sb.st_ino) {
    printwait(messages[42], &presel);
    goto nochange;
   }

   if (cur < selstartid) {
    selendid = selstartid;
    selstartid = cur;
   } else
    selendid = cur;


   if (selstartid == selendid) {
    resetselind();
    clearselection();
    break;
   }
  case SEL_SELALL:
  case SEL_SELINV:
   if (sel == SEL_SELALL || sel == SEL_SELINV) {
    if (!ndents)
     goto nochange;

    startselection();
    if (g_state.rangesel)
     g_state.rangesel = 0;

    selstartid = 0;
    selendid = ndents - 1;
   }

   if ((nselected > 1000) || (nselected && (ndents > 1000))) {
    printmsg("processing...");
    
# 7405 "project/nnn/src/nnn.c" 3 4
   wrefresh(stdscr)
# 7405 "project/nnn/src/nnn.c"
            ;
   }

   r = scanselforpath(path, 
# 7408 "project/nnn/src/nnn.c" 3 4
                           1
# 7408 "project/nnn/src/nnn.c"
                               );
   ((sel == SEL_SELINV) && findselpos)
    ? invertselbuf(r) : addtoselbuf(r, selstartid, selendid);


   if (cfg.x11)
    plugscript(utils[16], 0x02 | 0x04);

   continue;
  case SEL_SELEDIT:
   r = editselection();
   if (r <= 0) {
    r = !r ? 3 : 5;
    printwait(messages[r], &presel);
   } else {

    if (cfg.x11)
     plugscript(utils[16], 0x02 | 0x04);

    cfg.filtermode ? presel = '/' : statusbar(path);
   }
   goto nochange;
  case SEL_CP:
  case SEL_MV:
  case SEL_CPMVAS:
  case SEL_RM:
  {
   if (sel == SEL_RM) {
    r = get_cur_or_sel();
    if (!r) {
     statusbar(path);
     goto nochange;
    }

    if (r == 'c') {
     tmp = (listpath && (*(path) != *(listpath) ? -1 : strcmp((path), (listpath))) == 0)
           ? listroot : path;
     mkpath(tmp, pdents[cur].name, newpath);
     if (!xrm(newpath))
      continue;

     xrmfromsel(tmp, newpath);

     copynextname(lastname);

     if (cfg.filtermode || (g_ctx[cfg.curctx].c_fltr[1]))
      presel = '/';
     cd = 
# 7455 "project/nnn/src/nnn.c" 3 4
         0
# 7455 "project/nnn/src/nnn.c"
              ;
     goto begin;
    }
   }

   (nselected == 1 && (sel == SEL_CP || sel == SEL_MV))
    ? mkpath(path, xbasename(pselbuf), newpath)
    : (newpath[0] = '\0');

   endselection(
# 7464 "project/nnn/src/nnn.c" 3 4
               1
# 7464 "project/nnn/src/nnn.c"
                   );

   if (!cpmvrm_selection(sel, path)) {
    presel = '$';
    goto nochange;
   }

   if (cfg.filtermode)
    presel = '/';
   clearfilter();



   if (cfg.x11)
    plugscript(utils[15], 0x02 | 0x04);


   if (newpath[0] && !access(newpath, 
# 7481 "project/nnn/src/nnn.c" 3 4
                                     0
# 7481 "project/nnn/src/nnn.c"
                                         ))
    xstrsncpy(lastname, xbasename(newpath), 
# 7482 "project/nnn/src/nnn.c" 3 4
                                           255
# 7482 "project/nnn/src/nnn.c"
                                                   +1);
   else
    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7484 "project/nnn/src/nnn.c" 3 4
   255 
# 7484 "project/nnn/src/nnn.c"
   + 1);
   cd = 
# 7485 "project/nnn/src/nnn.c" 3 4
       0
# 7485 "project/nnn/src/nnn.c"
            ;
   goto begin;
  }
  case SEL_ARCHIVE:
  case SEL_OPENWITH:
  case SEL_NEW:
  case SEL_RENAME:
  {
   int fd, ret = 'n';

   if (!ndents && (sel == SEL_OPENWITH || sel == SEL_RENAME))
    break;

   if (sel != SEL_OPENWITH)
    endselection(
# 7499 "project/nnn/src/nnn.c" 3 4
                1
# 7499 "project/nnn/src/nnn.c"
                    );

   switch (sel) {
   case SEL_ARCHIVE:
    r = get_cur_or_sel();
    if (!r) {
     statusbar(path);
     goto nochange;
    }

    if (r == 's') {
     if (!selsafe()) {
      presel = '$';
      goto nochange;
     }

     tmp = 
# 7515 "project/nnn/src/nnn.c" 3 4
          ((void *)0)
# 7515 "project/nnn/src/nnn.c"
              ;
    } else
     tmp = pdents[cur].name;

    tmp = xreadline(tmp, messages[17]);
    break;
   case SEL_OPENWITH:

    if (g_state.picker) {

     tmp = xreadline(
# 7525 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 7525 "project/nnn/src/nnn.c"
                        , messages[18]);

    } else
     tmp = getreadline(messages[18]);

    break;
   case SEL_NEW:
    r = get_input(messages[11]);
    if (r == 'f' || r == 'd')
     tmp = xreadline(
# 7534 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 7534 "project/nnn/src/nnn.c"
                        , messages[19]);
    else if (r == 's' || r == 'h')
     tmp = xreadline(
# 7536 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 7536 "project/nnn/src/nnn.c"
                        ,
      messages[nselected <= 1?19:20]);
    else
     tmp = 
# 7539 "project/nnn/src/nnn.c" 3 4
          ((void *)0)
# 7539 "project/nnn/src/nnn.c"
              ;
    break;
   default:
    tmp = xreadline(pdents[cur].name, "");
    break;
   }

   if (!tmp || !*tmp)
    break;

   switch (sel) {
   case SEL_ARCHIVE:
    if (r == 'c' && strcmp(tmp, pdents[cur].name) == 0)
     goto nochange;

    mkpath(path, tmp, newpath);
    if (access(newpath, 
# 7555 "project/nnn/src/nnn.c" 3 4
                       0
# 7555 "project/nnn/src/nnn.c"
                           ) == 0) {
     if (!xconfirm(get_input(messages[13]))) {
      statusbar(path);
      goto nochange;
     }
    }
    get_archive_cmd(newpath, tmp);
    (r == 's') ? archive_selection(newpath, tmp, path)
        : spawn(newpath, tmp, pdents[cur].name,
         
# 7564 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 7564 "project/nnn/src/nnn.c"
            , (0x08 | 0x01) | 0x10);

    mkpath(path, tmp, newpath);
    if (access(newpath, 
# 7567 "project/nnn/src/nnn.c" 3 4
                       0
# 7567 "project/nnn/src/nnn.c"
                           ) == 0) {
     xstrsncpy(lastname, tmp, 
# 7568 "project/nnn/src/nnn.c" 3 4
                             255 
# 7568 "project/nnn/src/nnn.c"
                                      + 1);
     clearfilter();
     clearselection();
     cd = 
# 7571 "project/nnn/src/nnn.c" 3 4
         0
# 7571 "project/nnn/src/nnn.c"
              ;
     goto begin;
    }
    continue;
   case SEL_OPENWITH:
    handle_openwith(path, pdents[cur].name, newpath, tmp);

    cfg.filtermode ? presel = '/' : statusbar(path);
    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7579 "project/nnn/src/nnn.c" 3 4
   255 
# 7579 "project/nnn/src/nnn.c"
   + 1);
    goto nochange;
   case SEL_RENAME:

    if (strcmp(tmp, pdents[cur].name) == 0) {
     tmp = xreadline(pdents[cur].name, messages[21]);
     if (!tmp || !tmp[0] || !strcmp(tmp, pdents[cur].name)) {
      cfg.filtermode ? presel = '/' : statusbar(path);
      xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7587 "project/nnn/src/nnn.c" 3 4
     255 
# 7587 "project/nnn/src/nnn.c"
     + 1);
      goto nochange;
     }
     ret = 'd';
    }
    break;
   default:
    break;
   }



   fd = open(path, 
# 7599 "project/nnn/src/nnn.c" 3 4
                  0x0000 
# 7599 "project/nnn/src/nnn.c"
                           | 
# 7599 "project/nnn/src/nnn.c" 3 4
                             0x00100000
# 7599 "project/nnn/src/nnn.c"
                                        );



   if (fd == -1) {
    printwait(strerror(
# 7604 "project/nnn/src/nnn.c" 3 4
   (*__error())
# 7604 "project/nnn/src/nnn.c"
   ), &presel);
    goto nochange;
   }


   if (fstatat(fd, tmp, &sb, 
# 7609 "project/nnn/src/nnn.c" 3 4
                            0x0020
# 7609 "project/nnn/src/nnn.c"
                                               ) == 0) {
    if (sel == SEL_RENAME) {

     if (!xconfirm(get_input(messages[13]))) {
      close(fd);
      break;
     }
    } else {

     close(fd);
     printwait(messages[28], &presel);
     goto nochange;
    }
   }

   if (sel == SEL_RENAME) {

    if (ret == 'd')
     spawn("cp -rp", pdents[cur].name, tmp, 
# 7627 "project/nnn/src/nnn.c" 3 4
                                           ((void *)0)
# 7627 "project/nnn/src/nnn.c"
                                               , ((0x08 | 0x01) | 0x04));
    else if (renameat(fd, pdents[cur].name, fd, tmp) != 0) {
     close(fd);
     printwait(strerror(
# 7630 "project/nnn/src/nnn.c" 3 4
    (*__error())
# 7630 "project/nnn/src/nnn.c"
    ), &presel);
     goto nochange;
    }
    close(fd);
    xstrsncpy(lastname, tmp, 
# 7634 "project/nnn/src/nnn.c" 3 4
                            255 
# 7634 "project/nnn/src/nnn.c"
                                     + 1);
   } else {
    close(fd);
    presel = 0;


    if (r == 'f' || r == 'd') {
     mkpath(path, tmp, newpath);
     ret = xmktree(newpath, r == 'f' ? 
# 7642 "project/nnn/src/nnn.c" 3 4
                                      0 
# 7642 "project/nnn/src/nnn.c"
                                            : 
# 7642 "project/nnn/src/nnn.c" 3 4
                                              1
# 7642 "project/nnn/src/nnn.c"
                                                  );
    } else if (r == 's' || r == 'h') {
     if (tmp[0] == '@' && tmp[1] == '\0')
      tmp[0] = '\0';
     ret = xlink(tmp, path, (ndents ? pdents[cur].name : 
# 7646 "project/nnn/src/nnn.c" 3 4
                                                        ((void *)0)
# 7646 "project/nnn/src/nnn.c"
                                                            ),
        newpath, &presel, r);
    }

    if (!ret)
     printwait(messages[5], &presel);

    if (ret <= 0)
     goto nochange;

    if (r == 'f' || r == 'd')
     xstrsncpy(lastname, tmp, 
# 7657 "project/nnn/src/nnn.c" 3 4
                             255 
# 7657 "project/nnn/src/nnn.c"
                                      + 1);
    else if (ndents) {
     if (cfg.filtermode)
      presel = '/';
     xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7661 "project/nnn/src/nnn.c" 3 4
    255 
# 7661 "project/nnn/src/nnn.c"
    + 1);
    }
    clearfilter();
   }

   cd = 
# 7666 "project/nnn/src/nnn.c" 3 4
       0
# 7666 "project/nnn/src/nnn.c"
            ;
   goto begin;
  }
  case SEL_PLUGIN:

   if (!xdiraccess(plgpath)) {
    printwait(strerror(
# 7672 "project/nnn/src/nnn.c" 3 4
   (*__error())
# 7672 "project/nnn/src/nnn.c"
   ), &presel);
    goto nochange;
   }

   if (!pkey) {
    r = xstrsncpy(g_buf, messages[34], (
# 7677 "project/nnn/src/nnn.c" 3 4
                                            1024 
# 7677 "project/nnn/src/nnn.c"
                                            + ((
# 7677 "project/nnn/src/nnn.c" 3 4
                                            255 
# 7677 "project/nnn/src/nnn.c"
                                            + 1) << 1)));
    printkeys(plug, g_buf + r - 1, maxplug);
    printmsg(g_buf);
    r = get_input(
# 7680 "project/nnn/src/nnn.c" 3 4
                 ((void *)0)
# 7680 "project/nnn/src/nnn.c"
                     );
   } else {
    r = pkey;
    pkey = '\0';
   }

   if (r != '\r') {
    endselection(
# 7687 "project/nnn/src/nnn.c" 3 4
                0
# 7687 "project/nnn/src/nnn.c"
                     );
    tmp = get_kv_val(plug, 
# 7688 "project/nnn/src/nnn.c" 3 4
                          ((void *)0)
# 7688 "project/nnn/src/nnn.c"
                              , r, maxplug, 2);
    if (!tmp) {
     printwait(messages[40], &presel);
     goto nochange;
    }

    if (tmp[0] == '-' && tmp[1]) {
     ++tmp;
     r = 
# 7696 "project/nnn/src/nnn.c" 3 4
        0
# 7696 "project/nnn/src/nnn.c"
             ;
    } else
     r = 
# 7698 "project/nnn/src/nnn.c" 3 4
        1
# 7698 "project/nnn/src/nnn.c"
            ;

    if (!run_plugin(&path, tmp, (ndents ? pdents[cur].name : 
# 7700 "project/nnn/src/nnn.c" 3 4
                                                            ((void *)0)
# 7700 "project/nnn/src/nnn.c"
                                                                ),
        &lastname, &lastdir)) {
     printwait(messages[5], &presel);
     goto nochange;
    }

    if (g_state.picked)
     return 
# 7707 "project/nnn/src/nnn.c" 3 4
           0
# 7707 "project/nnn/src/nnn.c"
                       ;

    xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7709 "project/nnn/src/nnn.c" 3 4
   255 
# 7709 "project/nnn/src/nnn.c"
   + 1);

    if (!r) {
     cfg.filtermode ? presel = '/' : statusbar(path);
     goto nochange;
    }
   } else {
    g_state.runplugin ^= 1;
    if (!g_state.runplugin && rundir[0]) {




     if (strcmp(path, plgpath) == 0) {
      xstrsncpy(path, rundir, 
# 7723 "project/nnn/src/nnn.c" 3 4
                             1024
# 7723 "project/nnn/src/nnn.c"
                                     );
      xstrsncpy(lastname, runfile, 
# 7724 "project/nnn/src/nnn.c" 3 4
                                  255 
# 7724 "project/nnn/src/nnn.c"
                                           + 1);
      rundir[0] = runfile[0] = '\0';
      (cfg.filtermode ? (presel = '/') : (watch = 
# 7726 "project/nnn/src/nnn.c" 3 4
     1
# 7726 "project/nnn/src/nnn.c"
     ));
      goto begin;
     }


     g_state.runplugin = 1;
    }

    xstrsncpy(lastdir, path, 
# 7734 "project/nnn/src/nnn.c" 3 4
                            1024
# 7734 "project/nnn/src/nnn.c"
                                    );
    xstrsncpy(rundir, path, 
# 7735 "project/nnn/src/nnn.c" 3 4
                           1024
# 7735 "project/nnn/src/nnn.c"
                                   );
    xstrsncpy(path, plgpath, 
# 7736 "project/nnn/src/nnn.c" 3 4
                            1024
# 7736 "project/nnn/src/nnn.c"
                                    );
    if (ndents)
     xstrsncpy(runfile, pdents[cur].name, 
# 7738 "project/nnn/src/nnn.c" 3 4
                                         255
# 7738 "project/nnn/src/nnn.c"
                                                 );
    g_state.runctx = cfg.curctx;
    lastname[0] = '\0';
   }
   (cfg.filtermode ? (presel = '/') : (watch = 
# 7742 "project/nnn/src/nnn.c" 3 4
  1
# 7742 "project/nnn/src/nnn.c"
  ));
   clearfilter();
   goto begin;
  case SEL_SHELL:
  case SEL_LAUNCH:
  case SEL_PROMPT:
   r = handle_cmd(sel, newpath);


   if (cfg.filtermode)
    presel = '/';


   xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7755 "project/nnn/src/nnn.c" 3 4
  255 
# 7755 "project/nnn/src/nnn.c"
  + 1);

   if (!r)
    goto nochange;


   cd = 
# 7761 "project/nnn/src/nnn.c" 3 4
       0
# 7761 "project/nnn/src/nnn.c"
            ;
   goto begin;
  case SEL_UMOUNT:
   presel = 0;
   if (!unmount((ndents ? pdents[cur].name : 
# 7765 "project/nnn/src/nnn.c" 3 4
                                            ((void *)0)
# 7765 "project/nnn/src/nnn.c"
                                                ), newpath, &presel, path)) {
    if (presel == 0)
     statusbar(path);
    goto nochange;
   }


   copynextname(lastname);
   cd = 
# 7773 "project/nnn/src/nnn.c" 3 4
       0
# 7773 "project/nnn/src/nnn.c"
            ;
   goto begin;

  case SEL_SESSIONS:
   r = get_input(messages[14]);

   if (r == 's') {
    tmp = xreadline(
# 7780 "project/nnn/src/nnn.c" 3 4
                   ((void *)0)
# 7780 "project/nnn/src/nnn.c"
                       , messages[6]);
    if (tmp && *tmp)
     save_session(tmp, &presel);
   } else if (r == 'l' || r == 'r') {
    if (load_session(
# 7784 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 7784 "project/nnn/src/nnn.c"
                        , &path, &lastdir, &lastname, r == 'r')) {
     (cfg.filtermode ? (presel = '/') : (watch = 
# 7785 "project/nnn/src/nnn.c" 3 4
    1
# 7785 "project/nnn/src/nnn.c"
    ));
     goto begin;
    }
   }

   statusbar(path);
   goto nochange;

  case SEL_EXPORT:
   export_file_list();
   cfg.filtermode ? presel = '/' : statusbar(path);
   goto nochange;
  case SEL_TIMETYPE:
   if (!set_time_type(&presel))
    goto nochange;
   cd = 
# 7800 "project/nnn/src/nnn.c" 3 4
       0
# 7800 "project/nnn/src/nnn.c"
            ;
   goto begin;
  case SEL_QUITCTX:
  case SEL_QUITCD:
  case SEL_QUIT:
  case SEL_QUITERR:
   if (sel == SEL_QUITCTX) {
    int ctx = cfg.curctx;

    for (r = (ctx + 1) & ~4;
         (r != ctx) && !g_ctx[r].c_cfg.ctxactive;
         r = ((r + 1) & ~4)) {
    };

    if (r != ctx) {
     g_ctx[ctx].c_cfg.ctxactive = 0;


     path = g_ctx[r].c_path;
     lastdir = g_ctx[r].c_last;
     lastname = g_ctx[r].c_name;

     cfg = g_ctx[r].c_cfg;

     cfg.curctx = r;
     (cfg.filtermode ? (presel = '/') : (watch = 
# 7825 "project/nnn/src/nnn.c" 3 4
    1
# 7825 "project/nnn/src/nnn.c"
    ));
     goto begin;
    }
   } else if (!g_state.forcequit) {
    for (r = 0; r < 4; ++r)
     if (r != cfg.curctx && g_ctx[r].c_cfg.ctxactive) {
      r = get_input(messages[15]);
      break;
     }

    if (!(r == 4 || xconfirm(r)))
     break;
   }


   tmp = getenv("NNN_TMPFILE");
   if ((sel == SEL_QUITCD) || tmp) {
    write_lastdir(path, tmp);

    if ((sel == SEL_QUITCD) && g_state.picker)
     selbufpos = 0;
   }

   if (sel != SEL_QUITERR)
    return 
# 7849 "project/nnn/src/nnn.c" 3 4
          0
# 7849 "project/nnn/src/nnn.c"
                      ;

   if (selbufpos && !g_state.picker) {

    g_state.picker = 1;
    free(selpath);
    selpath = 
# 7855 "project/nnn/src/nnn.c" 3 4
             ((void *)0)
# 7855 "project/nnn/src/nnn.c"
                 ;
    return 
# 7856 "project/nnn/src/nnn.c" 3 4
          0
# 7856 "project/nnn/src/nnn.c"
                      ;
   }

   return 
# 7859 "project/nnn/src/nnn.c" 3 4
         1
# 7859 "project/nnn/src/nnn.c"
                     ;
  default:
   if (xlines != LINES || xcols != COLS)
    continue;

   if (idletimeout && idle == idletimeout) {
    lock_terminal();
    idle = 0;
   }

   xstrsncpy(lastname, ndents ? pdents[cur].name : "\0", 
# 7869 "project/nnn/src/nnn.c" 3 4
  255 
# 7869 "project/nnn/src/nnn.c"
  + 1);
   goto nochange;
  }
 }
}

static char *make_tmp_tree(char **paths, ssize_t entries, const char *prefix)
{


 int err;
 struct stat sb;
 char *slash, *tmp;
 ssize_t len = xstrlen(prefix);
 char *tmpdir = malloc(
# 7883 "project/nnn/src/nnn.c" 3 4
                      1024
# 7883 "project/nnn/src/nnn.c"
                              );

 if (!tmpdir) {
  ;
  return 
# 7887 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 7887 "project/nnn/src/nnn.c"
            ;
 }

 tmp = tmpdir + tmpfplen - 1;
 xstrsncpy(tmpdir, g_tmpfpath, tmpfplen);
 xstrsncpy(tmp, "/nnnXXXXXX", 11);


 tmp += 10;


 if (!prefix[1] && (prefix[0] == '/'))
  len = 0;

 if (!mkdtemp(tmpdir)) {
  free(tmpdir);

  ;
  return 
# 7905 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 7905 "project/nnn/src/nnn.c"
            ;
 }

 listpath = tmpdir;

 for (ssize_t i = 0; i < entries; ++i) {
  if (!paths[i])
   continue;

  err = stat(paths[i], &sb);
  if (err && 
# 7915 "project/nnn/src/nnn.c" 3 4
            (*__error()) 
# 7915 "project/nnn/src/nnn.c"
                  == 
# 7915 "project/nnn/src/nnn.c" 3 4
                     2
# 7915 "project/nnn/src/nnn.c"
                           )
   continue;


  xstrsncpy(tmp, paths[i] + len, xstrlen(paths[i]) - len + 1);


  slash = xmemrchr((uchar_t *)tmp, '/', xstrlen(paths[i]) - len);
  if (slash)
   *slash = '\0';

  xmktree(tmpdir, 
# 7926 "project/nnn/src/nnn.c" 3 4
                 1
# 7926 "project/nnn/src/nnn.c"
                     );

  if (slash)
   *slash = '/';

  if (symlink(paths[i], tmpdir)) {
   ;
   ;
  }
 }


 *tmp = '\0';
 return tmpdir;
}

static char *load_input(int fd, const char *path)
{
 ssize_t i, chunk_count = 1, chunk = (ssize_t)(512 * 1024) , entries = 0;
 char *input = malloc(sizeof(char) * chunk), *tmpdir = 
# 7945 "project/nnn/src/nnn.c" 3 4
                                                      ((void *)0)
# 7945 "project/nnn/src/nnn.c"
                                                          ;
 char cwd[
# 7946 "project/nnn/src/nnn.c" 3 4
         1024
# 7946 "project/nnn/src/nnn.c"
                 ], *next;
 size_t offsets[(1 << 16)];
 char **paths = 
# 7948 "project/nnn/src/nnn.c" 3 4
               ((void *)0)
# 7948 "project/nnn/src/nnn.c"
                   ;
 ssize_t input_read, total_read = 0, off = 0;
 int msgnum = 0;

 if (!input) {
  ;
  return 
# 7954 "project/nnn/src/nnn.c" 3 4
        ((void *)0)
# 7954 "project/nnn/src/nnn.c"
            ;
 }

 if (!path) {
  if (!getcwd(cwd, 
# 7958 "project/nnn/src/nnn.c" 3 4
                  1024
# 7958 "project/nnn/src/nnn.c"
                          )) {
   free(input);
   return 
# 7960 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 7960 "project/nnn/src/nnn.c"
             ;
  }
 } else
  xstrsncpy(cwd, path, 
# 7963 "project/nnn/src/nnn.c" 3 4
                      1024
# 7963 "project/nnn/src/nnn.c"
                              );

 while (chunk_count < 512) {
  input_read = read(fd, input + total_read, chunk);
  if (input_read < 0) {
   ;
   goto malloc_1;
  }

  if (input_read == 0)
   break;

  total_read += input_read;
  ++chunk_count;

  while (off < total_read) {
   next = memchr(input + off, '\0', total_read - off) + 1;
   if (next == (void *)1)
    break;

   if (next - input == off + 1) {
    off = next - input;
    continue;
   }

   if (entries == (1 << 16)) {
    msgnum = 10;
    goto malloc_1;
   }

   offsets[entries++] = off;
   off = next - input;
  }

  if (chunk_count == 512) {
   msgnum = 10;
   goto malloc_1;
  }


  if (chunk_count == (total_read - input_read) / chunk)
   continue;

  chunk_count = total_read / chunk;
  if (total_read % chunk)
   ++chunk_count;

  input = xrealloc(input, (chunk_count + 1) * chunk);
  if (!input)
   return 
# 8012 "project/nnn/src/nnn.c" 3 4
         ((void *)0)
# 8012 "project/nnn/src/nnn.c"
             ;
 }

 if (off != total_read) {
  if (entries == (1 << 16)) {
   msgnum = 10;
   goto malloc_1;
  }

  offsets[entries++] = off;
 }

 ;
 ;
 ;

 if (!entries) {
  msgnum = 1;
  goto malloc_1;
 }

 input[total_read] = '\0';

 paths = malloc(entries * sizeof(char *));
 if (!paths)
  goto malloc_1;

 for (i = 0; i < entries; ++i)
  paths[i] = input + offsets[i];

 listroot = malloc(sizeof(char) * 
# 8042 "project/nnn/src/nnn.c" 3 4
                                 1024
# 8042 "project/nnn/src/nnn.c"
                                         );
 if (!listroot)
  goto malloc_1;
 listroot[0] = '\0';

 ;

 for (i = 0; i < entries; ++i) {
  if (paths[i][0] == '\n' || selforparent(paths[i])) {
   paths[i] = 
# 8051 "project/nnn/src/nnn.c" 3 4
             ((void *)0)
# 8051 "project/nnn/src/nnn.c"
                 ;
   continue;
  }

  paths[i] = abspath(paths[i], cwd, 
# 8055 "project/nnn/src/nnn.c" 3 4
                                   ((void *)0)
# 8055 "project/nnn/src/nnn.c"
                                       );
  if (!paths[i]) {
   entries = i;
   goto malloc_2;

  }

  ;

  xstrsncpy(g_buf, paths[i], 
# 8064 "project/nnn/src/nnn.c" 3 4
                            1024
# 8064 "project/nnn/src/nnn.c"
                                    );
  if (!common_prefix(xdirname(g_buf), listroot)) {
   entries = i + 1;
   goto malloc_2;
  }

  ;
 }

 ;

 if (listroot[0])
  tmpdir = make_tmp_tree(paths, entries, listroot);

malloc_2:
 for (i = entries - 1; i >= 0; --i)
  free(paths[i]);
malloc_1:
 if (msgnum) {
  if (home) {
   printmsg(messages[msgnum]);
   xdelay((350000));
  } else
   msg(messages[msgnum]);
 }
 free(input);
 free(paths);
 return tmpdir;
}

static void check_key_collision(void)
{
 int key;
 
# 8097 "project/nnn/src/nnn.c" 3 4
_Bool 
# 8097 "project/nnn/src/nnn.c"
     bitmap[
# 8097 "project/nnn/src/nnn.c" 3 4
            0777
# 8097 "project/nnn/src/nnn.c"
                   ] = {
# 8097 "project/nnn/src/nnn.c" 3 4
                        0
# 8097 "project/nnn/src/nnn.c"
                             };

 for (ullong_t i = 0; i < sizeof(bindings) / sizeof(struct key); ++i) {
  key = bindings[i].sym;

  if (bitmap[key])
   dprintf(
# 8103 "project/nnn/src/nnn.c" 3 4
          2
# 8103 "project/nnn/src/nnn.c"
                       , "key collision! [%s]\n", keyname(key));
  else
   bitmap[key] = 
# 8105 "project/nnn/src/nnn.c" 3 4
                1
# 8105 "project/nnn/src/nnn.c"
                    ;
 }
}

static void usage(void)
{
 dprintf(
# 8111 "project/nnn/src/nnn.c" 3 4
        2
# 8111 "project/nnn/src/nnn.c"
                     ,
  "%s: nnn [OPTIONS] [PATH]\n\n"
  "The unorthodox terminal file manager.\n\n"
  "positional args:\n"
  "  PATH   start dir/file [default: .]\n\n"
  "optional args:\n"

  " -a      auto NNN_FIFO\n"

  " -A      no dir auto-select\n"
  " -b key  open bookmark key (trumps -s/S)\n"
  " -c      cli-only NNN_OPENER (trumps -e)\n"
  " -C      8-color scheme\n"
  " -d      detail mode\n"
  " -D      dirs in context color\n"
  " -e      text in $VISUAL/$EDITOR/vi\n"
  " -E      internal edits in EDITOR\n"

  " -f      use readline history file\n"


  " -F val  fifo mode [0:preview 1:explore]\n"

  " -g      regex filters\n"
  " -H      show hidden files\n"
  " -i      show current file info\n"
  " -J      no auto-proceed on select\n"
  " -K      detect key collision\n"
  " -l val  set scroll lines\n"
  " -n      type-to-nav mode\n"
  " -o      open files only on Enter\n"
  " -p file selection file [-:stdout]\n"
  " -P key  run plugin key\n"
  " -Q      no quit confirmation\n"
  " -r      use advcpmv patched cp, mv\n"
  " -R      no rollover at edges\n"

  " -s name load session by name\n"
  " -S      persistent session\n"

  " -t secs timeout to lock\n"
  " -T key  sort order [a/d/e/r/s/t/v]\n"
  " -u      use selection (no prompt)\n"

  " -U      show user and group\n"

  " -V      show version\n"

  " -x      notis, selection sync, xterm title\n"

  " -h      show help\n\n"
  "v%s\n%s\n", __func__, "4.4", "BSD 2-Clause\nhttps://github.com/jarun/nnn");
}

static 
# 8165 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 8165 "project/nnn/src/nnn.c"
           setup_config(void)
{
 size_t r, len;
 char *xdgcfg = getenv("XDG_CONFIG_HOME");
 
# 8169 "project/nnn/src/nnn.c" 3 4
_Bool 
# 8169 "project/nnn/src/nnn.c"
     xdg = 
# 8169 "project/nnn/src/nnn.c" 3 4
           0
# 8169 "project/nnn/src/nnn.c"
                ;


 if (xdgcfg && xdgcfg[0]) {
  ;
  if (xdgcfg[0] == '~') {
   r = xstrsncpy(g_buf, home, 
# 8175 "project/nnn/src/nnn.c" 3 4
                             1024
# 8175 "project/nnn/src/nnn.c"
                                     );
   xstrsncpy(g_buf + r - 1, xdgcfg + 1, 
# 8176 "project/nnn/src/nnn.c" 3 4
                                       1024
# 8176 "project/nnn/src/nnn.c"
                                               );
   xdgcfg = g_buf;
   ;
  }

  if (!xdiraccess(xdgcfg)) {
   perror(xitoa(8182));
   return 
# 8183 "project/nnn/src/nnn.c" 3 4
         0
# 8183 "project/nnn/src/nnn.c"
              ;
  }

  len = xstrlen(xdgcfg) + xstrlen("/nnn/bookmarks") + 1;
  xdg = 
# 8187 "project/nnn/src/nnn.c" 3 4
       1
# 8187 "project/nnn/src/nnn.c"
           ;
 }

 if (!xdg)
  len = xstrlen(home) + xstrlen("/.config/nnn/bookmarks") + 1;

 cfgpath = (char *)malloc(len);
 plgpath = (char *)malloc(len);
 if (!cfgpath || !plgpath) {
  perror(xitoa(8196));
  return 
# 8197 "project/nnn/src/nnn.c" 3 4
        0
# 8197 "project/nnn/src/nnn.c"
             ;
 }

 if (xdg) {
  xstrsncpy(cfgpath, xdgcfg, len);
  r = len - xstrlen("/nnn/bookmarks");
 } else {
  r = xstrsncpy(cfgpath, home, len);


  xstrsncpy(cfgpath + r - 1, "/.config", len - r);
  ;
  r += 8;
 }


 xstrsncpy(cfgpath + r - 1, "/nnn", len - r);
 ;


 for (r = 0; r < (sizeof(toks) / sizeof(*(toks))); ++r) {
  mkpath(cfgpath, toks[r], plgpath);
  if (!xmktree(plgpath, 
# 8219 "project/nnn/src/nnn.c" 3 4
                       1
# 8219 "project/nnn/src/nnn.c"
                           )) {
   ;
   perror(xitoa(8221));
   return 
# 8222 "project/nnn/src/nnn.c" 3 4
         0
# 8222 "project/nnn/src/nnn.c"
              ;
  }
 }


 if (!g_state.picker) {
  char *env_sel = xgetenv(env_cfg[9], 
# 8228 "project/nnn/src/nnn.c" 3 4
                                           ((void *)0)
# 8228 "project/nnn/src/nnn.c"
                                               );

  selpath = env_sel ? xstrdup(env_sel)
      : (char *)malloc(len + 3);

  if (!selpath) {
   perror(xitoa(8234));
   return 
# 8235 "project/nnn/src/nnn.c" 3 4
         0
# 8235 "project/nnn/src/nnn.c"
              ;
  }

  if (!env_sel) {
   r = xstrsncpy(selpath, cfgpath, len + 3);
   xstrsncpy(selpath + r - 1, "/.selection", 12);
   ;
  }
 }

 return 
# 8245 "project/nnn/src/nnn.c" 3 4
       1
# 8245 "project/nnn/src/nnn.c"
           ;
}

static 
# 8248 "project/nnn/src/nnn.c" 3 4
      _Bool 
# 8248 "project/nnn/src/nnn.c"
           set_tmp_path(void)
{
 char *tmp = "/tmp";
 char *path = xdiraccess(tmp) ? tmp : getenv("TMPDIR");

 if (!path) {
  msg("set TMPDIR");
  return 
# 8255 "project/nnn/src/nnn.c" 3 4
        0
# 8255 "project/nnn/src/nnn.c"
             ;
 }

 tmpfplen = (uchar_t)xstrsncpy(g_tmpfpath, path, 64);
 ;
 ;

 return 
# 8262 "project/nnn/src/nnn.c" 3 4
       1
# 8262 "project/nnn/src/nnn.c"
           ;
}

static void cleanup(void)
{

 if (cfg.x11 && !g_state.picker) {
  printf("\033[23;0t");
  fflush(
# 8270 "project/nnn/src/nnn.c" 3 4
        __stdoutp
# 8270 "project/nnn/src/nnn.c"
              );

  free(hostname);
 }

 free(selpath);
 free(plgpath);
 free(cfgpath);
 free(initpath);
 free(bmstr);
 free(pluginstr);
 free(listroot);
 free(ihashbmp);
 free(bookmark);
 free(plug);
 free(lastcmd);

 if (g_state.autofifo)
  unlink(fifopath);

 if (g_state.pluginit)
  unlink(g_pipepath);



}

int main(int argc, char *argv[])
{
 char *arg = 
# 8299 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 8299 "project/nnn/src/nnn.c"
                ;
 char *session = 
# 8300 "project/nnn/src/nnn.c" 3 4
                ((void *)0)
# 8300 "project/nnn/src/nnn.c"
                    ;
 int fd, opt, sort = 0, pkey = '\0';

 mmask_t mask;
 char *middle_click_env = xgetenv(env_cfg[8], "\0");

 middle_click_key = (middle_click_env[0] == '^' && middle_click_env[1])
       ? ((middle_click_env[1]) & 0x1f)
       : (uchar_t)middle_click_env[0];


 const char * const env_opts = xgetenv(env_cfg[0], 
# 8311 "project/nnn/src/nnn.c" 3 4
                                                         ((void *)0)
# 8311 "project/nnn/src/nnn.c"
                                                             );
 int env_opts_id = env_opts ? (int)xstrlen(env_opts) : -1;

 
# 8314 "project/nnn/src/nnn.c" 3 4
_Bool 
# 8314 "project/nnn/src/nnn.c"
     rlhist = 
# 8314 "project/nnn/src/nnn.c" 3 4
              0
# 8314 "project/nnn/src/nnn.c"
                   ;


 while ((opt = (env_opts_id > 0
         ? env_opts[--env_opts_id]
         : getopt(argc, argv, "aAb:cCdDeEfF:gHiJKl:nop:P:QrRs:St:T:uUVxh"))) != -1) {
  switch (opt) {

  case 'a':
   g_state.autofifo = 1;
   break;

  case 'A':
   cfg.autoselect = 0;
   break;
  case 'b':
   if (env_opts_id < 0)
    arg = optarg;
   break;
  case 'c':
   cfg.cliopener = 1;
   break;
  case 'C':
   g_state.oldcolor = 1;
   break;
  case 'd':
   cfg.showdetail = 1;
   break;
  case 'D':
   g_state.dirctx = 1;
   break;
  case 'e':
   cfg.useeditor = 1;
   break;
  case 'E':
   cfg.waitedit = 1;
   break;
  case 'f':

   rlhist = 
# 8353 "project/nnn/src/nnn.c" 3 4
           1
# 8353 "project/nnn/src/nnn.c"
               ;

   break;

  case 'F':
   if (env_opts_id < 0) {
    fd = atoi(optarg);
    if ((fd < 0) || (fd > 1))
     return 
# 8361 "project/nnn/src/nnn.c" 3 4
           1
# 8361 "project/nnn/src/nnn.c"
                       ;
    g_state.fifomode = fd;
   }
   break;

  case 'g':
   cfg.regex = 1;
   filterfn = &visible_re;
   break;
  case 'H':
   cfg.showhidden = 1;
   break;
  case 'i':
   cfg.fileinfo = 1;
   break;
  case 'J':
   g_state.stayonsel = 1;
   break;
  case 'K':
   check_key_collision();
   return 
# 8381 "project/nnn/src/nnn.c" 3 4
         0
# 8381 "project/nnn/src/nnn.c"
                     ;
  case 'l':
   if (env_opts_id < 0)
    scroll_lines = atoi(optarg);
   break;
  case 'n':
   cfg.filtermode = 1;
   break;
  case 'o':
   cfg.nonavopen = 1;
   break;
  case 'p':
   if (env_opts_id >= 0)
    break;

   g_state.picker = 1;
   if (!(optarg[0] == '-' && optarg[1] == '\0')) {
    fd = open(optarg, 
# 8398 "project/nnn/src/nnn.c" 3 4
                     0x0001 
# 8398 "project/nnn/src/nnn.c"
                              | 
# 8398 "project/nnn/src/nnn.c" 3 4
                                0x00000200
# 8398 "project/nnn/src/nnn.c"
                                       , 0600);
    if (fd == -1) {
     perror(xitoa(8400));
     return 
# 8401 "project/nnn/src/nnn.c" 3 4
           1
# 8401 "project/nnn/src/nnn.c"
                       ;
    }

    close(fd);
    selpath = abspath(optarg, 
# 8405 "project/nnn/src/nnn.c" 3 4
                             ((void *)0)
# 8405 "project/nnn/src/nnn.c"
                                 , 
# 8405 "project/nnn/src/nnn.c" 3 4
                                   ((void *)0)
# 8405 "project/nnn/src/nnn.c"
                                       );
    unlink(selpath);
   }
   break;
  case 'P':
   if (env_opts_id < 0 && !optarg[1])
    pkey = (uchar_t)optarg[0];
   break;
  case 'Q':
   g_state.forcequit = 1;
   break;
  case 'r':




   break;
  case 'R':
   cfg.rollover = 0;
   break;

  case 's':
   if (env_opts_id < 0)
    session = optarg;
   break;
  case 'S':
   g_state.prstssn = 1;
   if (!session)
    session = "@";
   break;

  case 't':
   if (env_opts_id < 0)
    idletimeout = atoi(optarg);
   break;
  case 'T':
   if (env_opts_id < 0)
    sort = (uchar_t)optarg[0];
   break;
  case 'u':
   cfg.prefersel = 1;
   break;
  case 'U':
   g_state.uidgid = 1;
   break;
  case 'V':
   dprintf(
# 8451 "project/nnn/src/nnn.c" 3 4
          1
# 8451 "project/nnn/src/nnn.c"
                       , "%s\n", "4.4");
   return 
# 8452 "project/nnn/src/nnn.c" 3 4
         0
# 8452 "project/nnn/src/nnn.c"
                     ;
  case 'x':
   cfg.x11 = 1;
   break;
  case 'h':
   usage();
   return 
# 8458 "project/nnn/src/nnn.c" 3 4
         0
# 8458 "project/nnn/src/nnn.c"
                     ;
  default:
   usage();
   return 
# 8461 "project/nnn/src/nnn.c" 3 4
         1
# 8461 "project/nnn/src/nnn.c"
                     ;
  }
  if (env_opts_id == 0)
   env_opts_id = -1;
 }







 if (!set_tmp_path())
  return 
# 8474 "project/nnn/src/nnn.c" 3 4
        1
# 8474 "project/nnn/src/nnn.c"
                    ;

 atexit(cleanup);


 if (!isatty(
# 8479 "project/nnn/src/nnn.c" 3 4
            0
# 8479 "project/nnn/src/nnn.c"
                        )) {

  initpath = load_input(
# 8481 "project/nnn/src/nnn.c" 3 4
                       0
# 8481 "project/nnn/src/nnn.c"
                                   , 
# 8481 "project/nnn/src/nnn.c" 3 4
                                     ((void *)0)
# 8481 "project/nnn/src/nnn.c"
                                         );
  if (!initpath)
   return 
# 8483 "project/nnn/src/nnn.c" 3 4
         1
# 8483 "project/nnn/src/nnn.c"
                     ;


  if (!isatty(
# 8486 "project/nnn/src/nnn.c" 3 4
             1
# 8486 "project/nnn/src/nnn.c"
                          )) {
   fd = open(ctermid(
# 8487 "project/nnn/src/nnn.c" 3 4
                    ((void *)0)
# 8487 "project/nnn/src/nnn.c"
                        ), 
# 8487 "project/nnn/src/nnn.c" 3 4
                           0x0000
# 8487 "project/nnn/src/nnn.c"
                                   , 0400);
   dup2(fd, 
# 8488 "project/nnn/src/nnn.c" 3 4
           0
# 8488 "project/nnn/src/nnn.c"
                       );
   close(fd);
  } else
   dup2(
# 8491 "project/nnn/src/nnn.c" 3 4
       1
# 8491 "project/nnn/src/nnn.c"
                    , 
# 8491 "project/nnn/src/nnn.c" 3 4
                      0
# 8491 "project/nnn/src/nnn.c"
                                  );

  if (session)
   session = 
# 8494 "project/nnn/src/nnn.c" 3 4
            ((void *)0)
# 8494 "project/nnn/src/nnn.c"
                ;
 }

 home = getenv("HOME");
 if (!home) {
  msg("set HOME");
  return 
# 8500 "project/nnn/src/nnn.c" 3 4
        1
# 8500 "project/nnn/src/nnn.c"
                    ;
 }
 ;
 homelen = (uchar_t)xstrlen(home);

 if (!setup_config())
  return 
# 8506 "project/nnn/src/nnn.c" 3 4
        1
# 8506 "project/nnn/src/nnn.c"
                    ;


 opener = xgetenv(env_cfg[3], utils[0]);
 ;


 if (!parsekvpair(&bookmark, &bmstr, 1, &maxbm)) {
  msg(env_cfg[1]);
  return 
# 8515 "project/nnn/src/nnn.c" 3 4
        1
# 8515 "project/nnn/src/nnn.c"
                    ;
 }


 if (!parsekvpair(&plug, &pluginstr, 2, &maxplug)) {
  msg(env_cfg[2]);
  return 
# 8521 "project/nnn/src/nnn.c" 3 4
        1
# 8521 "project/nnn/src/nnn.c"
                    ;
 }


 if (!parsekvpair(&order, &orderstr, 11, &maxorder)) {
  msg(env_cfg[11]);
  return 
# 8527 "project/nnn/src/nnn.c" 3 4
        1
# 8527 "project/nnn/src/nnn.c"
                    ;
 }

 if (!initpath) {
  if (arg) {
   if (!arg[1])
    initpath = get_kv_val(bookmark, 
# 8533 "project/nnn/src/nnn.c" 3 4
                                   ((void *)0)
# 8533 "project/nnn/src/nnn.c"
                                       , *arg, maxbm, 1);

   if (!initpath) {
    msg(messages[40]);
    return 
# 8537 "project/nnn/src/nnn.c" 3 4
          1
# 8537 "project/nnn/src/nnn.c"
                      ;
   }

   if (session)
    session = 
# 8541 "project/nnn/src/nnn.c" 3 4
             ((void *)0)
# 8541 "project/nnn/src/nnn.c"
                 ;
  } else if (argc == optind) {

   char *startpath = getenv("PWD");

   initpath = startpath ? xstrdup(startpath) : getcwd(
# 8546 "project/nnn/src/nnn.c" 3 4
                                                     ((void *)0)
# 8546 "project/nnn/src/nnn.c"
                                                         , 0);
   if (!initpath)
    initpath = "/";
  } else {
   arg = argv[optind];
   ;
   if (xstrlen(arg) > 7 && is_prefix(arg, "file://", 7))
    arg = arg + 7;
   initpath = abspath(arg, 
# 8554 "project/nnn/src/nnn.c" 3 4
                          ((void *)0)
# 8554 "project/nnn/src/nnn.c"
                              , 
# 8554 "project/nnn/src/nnn.c" 3 4
                                ((void *)0)
# 8554 "project/nnn/src/nnn.c"
                                    );
   ;
   if (!initpath) {
    perror(xitoa(8557));
    return 
# 8558 "project/nnn/src/nnn.c" 3 4
          1
# 8558 "project/nnn/src/nnn.c"
                      ;
   }






   struct stat sb;

   if (stat(initpath, &sb) == -1) {
    perror(xitoa(8569));
    return 
# 8570 "project/nnn/src/nnn.c" 3 4
          1
# 8570 "project/nnn/src/nnn.c"
                      ;
   }

   if (!
# 8573 "project/nnn/src/nnn.c" 3 4
       (((
# 8573 "project/nnn/src/nnn.c"
       sb.st_mode
# 8573 "project/nnn/src/nnn.c" 3 4
       ) & 0170000) == 0040000)
# 8573 "project/nnn/src/nnn.c"
                          )
    g_state.initfile = 1;

   if (session)
    session = 
# 8577 "project/nnn/src/nnn.c" 3 4
             ((void *)0)
# 8577 "project/nnn/src/nnn.c"
                 ;
  }
 }


 enveditor = getenv(env_cfg[10]);



 if (setfilter(&archive_re, (enveditor ? enveditor : patterns[2]))) {

  msg(messages[35]);
  return 
# 8589 "project/nnn/src/nnn.c" 3 4
        1
# 8589 "project/nnn/src/nnn.c"
                    ;
 }


 if (cfg.cliopener)
  cfg.useeditor = 0;


 enveditor = xgetenv(envs[2], utils[11]);
 editor = xgetenv(envs[1], enveditor);
 ;
 ;
 ;


 pager = xgetenv(envs[3], utils[12]);
 ;


 shell = xgetenv(envs[0], utils[13]);
 ;

 ;



 if (g_state.autofifo) {
  g_tmpfpath[tmpfplen - 1] = '\0';

  size_t r = mkpath(g_tmpfpath, "nnn-fifo.", g_buf);

  xstrsncpy(g_buf + r - 1, xitoa(getpid()), 
# 8620 "project/nnn/src/nnn.c" 3 4
                                           1024 
# 8620 "project/nnn/src/nnn.c"
                                                    - r);
  setenv("NNN_FIFO", g_buf, 
# 8621 "project/nnn/src/nnn.c" 3 4
                           1
# 8621 "project/nnn/src/nnn.c"
                               );
 }

 fifopath = xgetenv("NNN_FIFO", 
# 8624 "project/nnn/src/nnn.c" 3 4
                               ((void *)0)
# 8624 "project/nnn/src/nnn.c"
                                   );
 if (fifopath) {
  if (mkfifo(fifopath, 0600) != 0 && !(
# 8626 "project/nnn/src/nnn.c" 3 4
                                      (*__error()) 
# 8626 "project/nnn/src/nnn.c"
                                            == 
# 8626 "project/nnn/src/nnn.c" 3 4
                                               17 
# 8626 "project/nnn/src/nnn.c"
                                                      && access(fifopath, 
# 8626 "project/nnn/src/nnn.c" 3 4
                                                                          (1<<1)
# 8626 "project/nnn/src/nnn.c"
                                                                              ) == 0)) {
   perror(xitoa(8627));
   return 
# 8628 "project/nnn/src/nnn.c" 3 4
         1
# 8628 "project/nnn/src/nnn.c"
                     ;
  }

  sigaction(
# 8631 "project/nnn/src/nnn.c" 3 4
           13
# 8631 "project/nnn/src/nnn.c"
                  , &(struct sigaction){.
# 8631 "project/nnn/src/nnn.c" 3 4
                                         __sigaction_u.__sa_handler 
# 8631 "project/nnn/src/nnn.c"
                                                    = 
# 8631 "project/nnn/src/nnn.c" 3 4
                                                      (void (*)(int))1
# 8631 "project/nnn/src/nnn.c"
                                                             }, 
# 8631 "project/nnn/src/nnn.c" 3 4
                                                                ((void *)0)
# 8631 "project/nnn/src/nnn.c"
                                                                    );
 }
# 8643 "project/nnn/src/nnn.c"
 kq = kqueue();
 if (kq < 0) {
  perror(xitoa(8645));
  return 
# 8646 "project/nnn/src/nnn.c" 3 4
        1
# 8646 "project/nnn/src/nnn.c"
                    ;
 }
# 8657 "project/nnn/src/nnn.c"
 opt = xgetenv_val(env_cfg[13]);
 if (opt && opt <= 2)
  g_state.trash = opt;


 struct sigaction act = {.
# 8662 "project/nnn/src/nnn.c" 3 4
                         __sigaction_u.__sa_handler 
# 8662 "project/nnn/src/nnn.c"
                                    = sigint_handler};

 if (sigaction(
# 8664 "project/nnn/src/nnn.c" 3 4
              2
# 8664 "project/nnn/src/nnn.c"
                    , &act, 
# 8664 "project/nnn/src/nnn.c" 3 4
                            ((void *)0)
# 8664 "project/nnn/src/nnn.c"
                                ) < 0) {
  perror(xitoa(8665));
  return 
# 8666 "project/nnn/src/nnn.c" 3 4
        1
# 8666 "project/nnn/src/nnn.c"
                    ;
 }

 act.
# 8669 "project/nnn/src/nnn.c" 3 4
    __sigaction_u.__sa_handler 
# 8669 "project/nnn/src/nnn.c"
               = clean_exit_sighandler;

 if (sigaction(
# 8671 "project/nnn/src/nnn.c" 3 4
              15
# 8671 "project/nnn/src/nnn.c"
                     , &act, 
# 8671 "project/nnn/src/nnn.c" 3 4
                             ((void *)0)
# 8671 "project/nnn/src/nnn.c"
                                 ) < 0 || sigaction(
# 8671 "project/nnn/src/nnn.c" 3 4
                                                    1
# 8671 "project/nnn/src/nnn.c"
                                                          , &act, 
# 8671 "project/nnn/src/nnn.c" 3 4
                                                                  ((void *)0)
# 8671 "project/nnn/src/nnn.c"
                                                                      ) < 0) {
  perror(xitoa(8672));
  return 
# 8673 "project/nnn/src/nnn.c" 3 4
        1
# 8673 "project/nnn/src/nnn.c"
                    ;
 }

 act.
# 8676 "project/nnn/src/nnn.c" 3 4
    __sigaction_u.__sa_handler 
# 8676 "project/nnn/src/nnn.c"
               = 
# 8676 "project/nnn/src/nnn.c" 3 4
                 (void (*)(int))1
# 8676 "project/nnn/src/nnn.c"
                        ;

 if (sigaction(
# 8678 "project/nnn/src/nnn.c" 3 4
              3
# 8678 "project/nnn/src/nnn.c"
                     , &act, 
# 8678 "project/nnn/src/nnn.c" 3 4
                             ((void *)0)
# 8678 "project/nnn/src/nnn.c"
                                 ) < 0) {
  perror(xitoa(8679));
  return 
# 8680 "project/nnn/src/nnn.c" 3 4
        1
# 8680 "project/nnn/src/nnn.c"
                    ;
 }



 setlocale(
# 8685 "project/nnn/src/nnn.c" 3 4
          0
# 8685 "project/nnn/src/nnn.c"
                , "");
# 8697 "project/nnn/src/nnn.c"
 rl_variable_bind("completion-ignore-case", "on");



 rl_bind_key('\t', rl_complete);

 if (rlhist) {
  mkpath(cfgpath, ".history", g_buf);
  read_history(g_buf);
 }



 if (cfg.x11 && !g_state.picker) {

  printf("\033[22;0t");
  fflush(
# 8713 "project/nnn/src/nnn.c" 3 4
        __stdoutp
# 8713 "project/nnn/src/nnn.c"
              );

  hostname = malloc(
# 8715 "project/nnn/src/nnn.c" 3 4
                   255 
# 8715 "project/nnn/src/nnn.c"
                                        + 1);
  if (!hostname) {
   perror(xitoa(8717));
   return 
# 8718 "project/nnn/src/nnn.c" 3 4
         1
# 8718 "project/nnn/src/nnn.c"
                     ;
  }
  gethostname(hostname, 
# 8720 "project/nnn/src/nnn.c" 3 4
                       255
# 8720 "project/nnn/src/nnn.c"
                                           );
  hostname[
# 8721 "project/nnn/src/nnn.c" 3 4
          255
# 8721 "project/nnn/src/nnn.c"
                              ] = '\0';
 }



 if (!initcurses(&mask))



  return 
# 8730 "project/nnn/src/nnn.c" 3 4
        1
# 8730 "project/nnn/src/nnn.c"
                    ;

 if (sort)
  set_sort_flags(sort);

 opt = browse(initpath, session, pkey);


 if (session && g_state.prstssn)
  save_session(session, 
# 8739 "project/nnn/src/nnn.c" 3 4
                       ((void *)0)
# 8739 "project/nnn/src/nnn.c"
                           );



 mousemask(mask, 
# 8743 "project/nnn/src/nnn.c" 3 4
                ((void *)0)
# 8743 "project/nnn/src/nnn.c"
                    );


 endwin();


 if (rlhist) {
  mkpath(cfgpath, ".history", g_buf);
  write_history(g_buf);
 }


 if (g_state.picker) {
  if (selbufpos) {
   fd = selpath ? open(selpath, 
# 8757 "project/nnn/src/nnn.c" 3 4
                               0x0001 
# 8757 "project/nnn/src/nnn.c"
                                        | 
# 8757 "project/nnn/src/nnn.c" 3 4
                                          0x00000200 
# 8757 "project/nnn/src/nnn.c"
                                                  | 
# 8757 "project/nnn/src/nnn.c" 3 4
                                                    0x00000400
# 8757 "project/nnn/src/nnn.c"
                                                           , 0600) : 
# 8757 "project/nnn/src/nnn.c" 3 4
                                                                     1
# 8757 "project/nnn/src/nnn.c"
                                                                                  ;
   if ((fd == -1) || (seltofile(fd, 
# 8758 "project/nnn/src/nnn.c" 3 4
                                   ((void *)0)
# 8758 "project/nnn/src/nnn.c"
                                       ) != (size_t)(selbufpos)))
    perror(xitoa(8759));

   if (fd > 1)
    close(fd);
  }
 } else if (selpath)
  unlink(selpath);


 rmlistpath();





 regfree(&archive_re);



 free(pselbuf);







 if (event_fd >= 0)
  close(event_fd);
 close(kq);





 if (!g_state.fifomode)
  notify_fifo(
# 8795 "project/nnn/src/nnn.c" 3 4
             0
# 8795 "project/nnn/src/nnn.c"
                  );
 if (fifofd != -1)
  close(fifofd);


 return opt;
}
