# 0 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
# 0 "<built-in>"
# 0 "<command-line>"
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"

# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdint.h" 1 3 4
# 9 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdint.h" 3 4
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 1 3 4
# 27 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int8_t.h" 3 4

# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int8_t.h" 3 4
typedef signed char int8_t;
# 28 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int16_t.h" 3 4
typedef short int16_t;
# 29 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int32_t.h" 3 4
typedef int int32_t;
# 30 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_int64_t.h" 3 4
typedef long long int64_t;
# 31 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint8_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint8_t.h" 3 4
typedef unsigned char uint8_t;
# 33 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint16_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint16_t.h" 3 4
typedef unsigned short uint16_t;
# 34 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint32_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint32_t.h" 3 4
typedef unsigned int uint32_t;
# 35 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint64_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uint64_t.h" 3 4
typedef unsigned long long uint64_t;
# 36 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4


typedef int8_t int_least8_t;
typedef int16_t int_least16_t;
typedef int32_t int_least32_t;
typedef int64_t int_least64_t;
typedef uint8_t uint_least8_t;
typedef uint16_t uint_least16_t;
typedef uint32_t uint_least32_t;
typedef uint64_t uint_least64_t;



typedef int8_t int_fast8_t;
typedef int16_t int_fast16_t;
typedef int32_t int_fast32_t;
typedef int64_t int_fast64_t;
typedef uint8_t uint_fast8_t;
typedef uint16_t uint_fast16_t;
typedef uint32_t uint_fast32_t;
typedef uint64_t uint_fast64_t;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 1 3 4
# 649 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_symbol_aliasing.h" 1 3 4
# 650 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 2 3 4
# 715 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_posix_availability.h" 1 3 4
# 716 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/cdefs.h" 2 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_types.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_types.h" 1 3 4
# 37 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_types.h" 3 4
typedef signed char __int8_t;



typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;
typedef long long __int64_t;
typedef unsigned long long __uint64_t;

typedef long __darwin_intptr_t;
typedef unsigned int __darwin_natural_t;
# 70 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/_types.h" 3 4
typedef int __darwin_ct_rune_t;





typedef union {
 char __mbstate8[128];
 long long _mbstateL;
} __mbstate_t;

typedef __mbstate_t __darwin_mbstate_t;


typedef long int __darwin_ptrdiff_t;







typedef long unsigned int __darwin_size_t;





typedef __builtin_va_list __darwin_va_list;





typedef int __darwin_wchar_t;




typedef __darwin_wchar_t __darwin_rune_t;


typedef int __darwin_wint_t;




typedef unsigned long __darwin_clock_t;
typedef __uint32_t __darwin_socklen_t;
typedef long __darwin_ssize_t;
typedef long __darwin_time_t;
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/_types.h" 2 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 2 3 4
# 55 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 3 4
typedef __int64_t __darwin_blkcnt_t;
typedef __int32_t __darwin_blksize_t;
typedef __int32_t __darwin_dev_t;
typedef unsigned int __darwin_fsblkcnt_t;
typedef unsigned int __darwin_fsfilcnt_t;
typedef __uint32_t __darwin_gid_t;
typedef __uint32_t __darwin_id_t;
typedef __uint64_t __darwin_ino64_t;

typedef __darwin_ino64_t __darwin_ino_t;



typedef __darwin_natural_t __darwin_mach_port_name_t;
typedef __darwin_mach_port_name_t __darwin_mach_port_t;
typedef __uint16_t __darwin_mode_t;
typedef __int64_t __darwin_off_t;
typedef __int32_t __darwin_pid_t;
typedef __uint32_t __darwin_sigset_t;
typedef __int32_t __darwin_suseconds_t;
typedef __uint32_t __darwin_uid_t;
typedef __uint32_t __darwin_useconds_t;
typedef unsigned char __darwin_uuid_t[16];
typedef char __darwin_uuid_string_t[37];

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_types.h" 1 3 4
# 57 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_pthread/_pthread_types.h" 3 4
struct __darwin_pthread_handler_rec {
 void (*__routine)(void *);
 void *__arg;
 struct __darwin_pthread_handler_rec *__next;
};

struct _opaque_pthread_attr_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_cond_t {
 long __sig;
 char __opaque[40];
};

struct _opaque_pthread_condattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_mutex_t {
 long __sig;
 char __opaque[56];
};

struct _opaque_pthread_mutexattr_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_once_t {
 long __sig;
 char __opaque[8];
};

struct _opaque_pthread_rwlock_t {
 long __sig;
 char __opaque[192];
};

struct _opaque_pthread_rwlockattr_t {
 long __sig;
 char __opaque[16];
};

struct _opaque_pthread_t {
 long __sig;
 struct __darwin_pthread_handler_rec *__cleanup_stack;
 char __opaque[8176];
};

typedef struct _opaque_pthread_attr_t __darwin_pthread_attr_t;
typedef struct _opaque_pthread_cond_t __darwin_pthread_cond_t;
typedef struct _opaque_pthread_condattr_t __darwin_pthread_condattr_t;
typedef unsigned long __darwin_pthread_key_t;
typedef struct _opaque_pthread_mutex_t __darwin_pthread_mutex_t;
typedef struct _opaque_pthread_mutexattr_t __darwin_pthread_mutexattr_t;
typedef struct _opaque_pthread_once_t __darwin_pthread_once_t;
typedef struct _opaque_pthread_rwlock_t __darwin_pthread_rwlock_t;
typedef struct _opaque_pthread_rwlockattr_t __darwin_pthread_rwlockattr_t;
typedef struct _opaque_pthread_t *__darwin_pthread_t;
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types.h" 2 3 4
# 62 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/types.h" 1 3 4
# 35 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 1 3 4
# 81 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int8_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int8_t.h" 3 4
typedef unsigned char u_int8_t;
# 82 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int16_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int16_t.h" 3 4
typedef unsigned short u_int16_t;
# 83 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int32_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int32_t.h" 3 4
typedef unsigned int u_int32_t;
# 84 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int64_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_u_int64_t.h" 3 4
typedef unsigned long long u_int64_t;
# 85 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4


typedef int64_t register_t;




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uintptr_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_uintptr_t.h" 3 4
typedef unsigned long uintptr_t;
# 94 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/i386/types.h" 2 3 4



typedef u_int64_t user_addr_t;
typedef u_int64_t user_size_t;
typedef int64_t user_ssize_t;
typedef int64_t user_long_t;
typedef u_int64_t user_ulong_t;
typedef int64_t user_time_t;
typedef int64_t user_off_t;







typedef u_int64_t syscall_arg_t;
# 36 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/machine/types.h" 2 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_intptr_t.h" 2 3 4

typedef __darwin_intptr_t intptr_t;
# 63 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_intmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_intmax_t.h" 3 4
typedef long int intmax_t;
# 68 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uintmax_t.h" 1 3 4
# 32 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types/_uintmax_t.h" 3 4
typedef long unsigned int uintmax_t;
# 69 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/stdint.h" 2 3 4
# 10 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdint.h" 2 3 4
# 3 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 2
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 1 3 4
# 143 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
typedef long int ptrdiff_t;
# 209 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
typedef long unsigned int size_t;
# 321 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
typedef int wchar_t;
# 415 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
# 426 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 3 4
} max_align_t;
# 4 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 2
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stdbool.h" 1 3 4
# 5 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 2

# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 1
       


# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 1 3 4
# 5 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 2

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 1 3 4
# 61 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types.h" 1 3 4
# 40 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/_types.h" 3 4
typedef int __darwin_nl_item;
typedef int __darwin_wctrans_t;

typedef __uint32_t __darwin_wctype_t;
# 62 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4

# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 1 3 4
# 135 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/AvailabilityVersions.h" 1 3 4
# 136 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 2 3 4
# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include-fixed/AvailabilityInternal.h" 1 3 4
# 137 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/Availability.h" 2 3 4
# 64 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_size_t.h" 1 3 4
# 65 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_null.h" 1 3 4
# 66 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4




void *memchr(const void *__s, int __c, size_t __n);
int memcmp(const void *__s1, const void *__s2, size_t __n);
void *memcpy(void *__dst, const void *__src, size_t __n);
void *memmove(void *__dst, const void *__src, size_t __len);
void *memset(void *__b, int __c, size_t __len);
char *strcat(char *__s1, const char *__s2);
char *strchr(const char *__s, int __c);
int strcmp(const char *__s1, const char *__s2);
int strcoll(const char *__s1, const char *__s2);
char *strcpy(char *__dst, const char *__src);
size_t strcspn(const char *__s, const char *__charset);
char *strerror(int __errnum) __asm("_" "strerror" );
size_t strlen(const char *__s);
char *strncat(char *__s1, const char *__s2, size_t __n);
int strncmp(const char *__s1, const char *__s2, size_t __n);
char *strncpy(char *__dst, const char *__src, size_t __n);
char *strpbrk(const char *__s, const char *__charset);
char *strrchr(const char *__s, int __c);
size_t strspn(const char *__s, const char *__charset);
char *strstr(const char *__big, const char *__little);
char *strtok(char *__str, const char *__sep);
size_t strxfrm(char *__s1, const char *__s2, size_t __n);

# 103 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

char *strtok_r(char *__str, const char *__sep, char **__lasts);

# 115 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

int strerror_r(int __errnum, char *__strerrbuf, size_t __buflen);
char *strdup(const char *__s1);
void *memccpy(void *__dst, const void *__src, int __c, size_t __n);

# 129 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4

char *stpcpy(char *__dst, const char *__src);
char *stpncpy(char *__dst, const char *__src, size_t __n) ;
char *strndup(const char *__s1, size_t __n) ;
size_t strnlen(const char *__s1, size_t __n) ;
char *strsignal(int __sig);






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_rsize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_rsize_t.h" 3 4
typedef __darwin_size_t rsize_t;
# 142 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_errno_t.h" 1 3 4
# 30 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_errno_t.h" 3 4
typedef int errno_t;
# 143 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4


errno_t memset_s(void *__s, rsize_t __smax, int __c, rsize_t __n) ;






# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ssize_t.h" 1 3 4
# 31 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/sys/_types/_ssize_t.h" 3 4
typedef __darwin_ssize_t ssize_t;
# 153 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4


void *memmem(const void *__big, size_t __big_len, const void *__little, size_t __little_len) ;
void memset_pattern4(void *__b, const void *__pattern4, size_t __len) ;
void memset_pattern8(void *__b, const void *__pattern8, size_t __len) ;
void memset_pattern16(void *__b, const void *__pattern16, size_t __len) ;

char *strcasestr(const char *__big, const char *__little);
char *strnstr(const char *__big, const char *__little, size_t __len);
size_t strlcat(char *__dst, const char *__source, size_t __size);
size_t strlcpy(char *__dst, const char *__source, size_t __size);
void strmode(int __mode, char *__bp);
char *strsep(char **__stringp, const char *__delim);


void swab(const void * restrict, void * restrict, ssize_t);



int timingsafe_bcmp(const void *__b1, const void *__b2, size_t __len);



int strsignal_r(int __sig, char *__strsignalbuf, size_t __buflen);







# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 1 3 4
# 67 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 3 4



int bcmp(const void *, const void *, size_t) ;
void bcopy(const void *, void *, size_t) ;
void bzero(void *, size_t) ;
char *index(const char *, int) ;
char *rindex(const char *, int) ;


int ffs(int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);





int ffsl(long) ;
int ffsll(long long) ;
int fls(int) ;
int flsl(long) ;
int flsll(long long) ;


# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 1 3 4
# 93 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 2 3 4




# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_strings.h" 1 3 4
# 33 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_strings.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_common.h" 1 3 4
# 34 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_strings.h" 2 3 4
# 98 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/strings.h" 2 3 4
# 185 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4
# 194 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 3 4
# 1 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/secure/_string.h" 1 3 4
# 195 "/Library/Developer/CommandLineTools/SDKs/MacOSX11.sdk/usr/include/string.h" 2 3 4
# 7 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 2

# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/feature_flags.h" 1

       
# 9 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 2
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/operations.h" 1

       


# 4 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/operations.h"
enum Operation {
ARM64_ERROR=0,
ARM64_ABS=1,
ARM64_ADC=2,
ARM64_ADCLB=3,
ARM64_ADCLT=4,
ARM64_ADCS=5,
ARM64_ADD=6,
ARM64_ADDG=7,
ARM64_ADDHN=8,
ARM64_ADDHN2=9,
ARM64_ADDHNB=10,
ARM64_ADDHNT=11,
ARM64_ADDP=12,
ARM64_ADDPL=13,
ARM64_ADDS=14,
ARM64_ADDV=15,
ARM64_ADDVL=16,
ARM64_ADR=17,
ARM64_ADRP=18,
ARM64_AESD=19,
ARM64_AESE=20,
ARM64_AESIMC=21,
ARM64_AESMC=22,
ARM64_AND=23,
ARM64_ANDS=24,
ARM64_ANDV=25,
ARM64_ASR=26,
ARM64_ASRD=27,
ARM64_ASRR=28,
ARM64_ASRV=29,
ARM64_AT=30,
ARM64_AUTDA=31,
ARM64_AUTDB=32,
ARM64_AUTDZA=33,
ARM64_AUTDZB=34,
ARM64_AUTIA=35,
ARM64_AUTIA1716=36,
ARM64_AUTIASP=37,
ARM64_AUTIAZ=38,
ARM64_AUTIB=39,
ARM64_AUTIB1716=40,
ARM64_AUTIBSP=41,
ARM64_AUTIBZ=42,
ARM64_AUTIZA=43,
ARM64_AUTIZB=44,
ARM64_AXFLAG=45,
ARM64_B=46,
ARM64_BCAX=47,
ARM64_BDEP=48,
ARM64_BEXT=49,
ARM64_BFC=50,
ARM64_BFCVT=51,
ARM64_BFCVTN=52,
ARM64_BFCVTN2=53,
ARM64_BFCVTNT=54,
ARM64_BFDOT=55,
ARM64_BFI=56,
ARM64_BFM=57,
ARM64_BFMLAL=58,
ARM64_BFMLALB=59,
ARM64_BFMLALT=60,
ARM64_BFMMLA=61,
ARM64_BFXIL=62,
ARM64_BGRP=63,
ARM64_BIC=64,
ARM64_BICS=65,
ARM64_BIF=66,
ARM64_BIT=67,
ARM64_BL=68,
ARM64_BLR=69,
ARM64_BLRAA=70,
ARM64_BLRAAZ=71,
ARM64_BLRAB=72,
ARM64_BLRABZ=73,
ARM64_BR=74,
ARM64_BRAA=75,
ARM64_BRAAZ=76,
ARM64_BRAB=77,
ARM64_BRABZ=78,
ARM64_BRK=79,
ARM64_BRKA=80,
ARM64_BRKAS=81,
ARM64_BRKB=82,
ARM64_BRKBS=83,
ARM64_BRKN=84,
ARM64_BRKNS=85,
ARM64_BRKPA=86,
ARM64_BRKPAS=87,
ARM64_BRKPB=88,
ARM64_BRKPBS=89,
ARM64_BSL=90,
ARM64_BSL1N=91,
ARM64_BSL2N=92,
ARM64_BTI=93,
ARM64_B_AL=94,
ARM64_B_CC=95,
ARM64_B_CS=96,
ARM64_B_EQ=97,
ARM64_B_GE=98,
ARM64_B_GT=99,
ARM64_B_HI=100,
ARM64_B_LE=101,
ARM64_B_LS=102,
ARM64_B_LT=103,
ARM64_B_MI=104,
ARM64_B_NE=105,
ARM64_B_NV=106,
ARM64_B_PL=107,
ARM64_B_VC=108,
ARM64_B_VS=109,
ARM64_CADD=110,
ARM64_CAS=111,
ARM64_CASA=112,
ARM64_CASAB=113,
ARM64_CASAH=114,
ARM64_CASAL=115,
ARM64_CASALB=116,
ARM64_CASALH=117,
ARM64_CASB=118,
ARM64_CASH=119,
ARM64_CASL=120,
ARM64_CASLB=121,
ARM64_CASLH=122,
ARM64_CASP=123,
ARM64_CASPA=124,
ARM64_CASPAL=125,
ARM64_CASPL=126,
ARM64_CBNZ=127,
ARM64_CBZ=128,
ARM64_CCMN=129,
ARM64_CCMP=130,
ARM64_CDOT=131,
ARM64_CFINV=132,
ARM64_CFP=133,
ARM64_CINC=134,
ARM64_CINV=135,
ARM64_CLASTA=136,
ARM64_CLASTB=137,
ARM64_CLREX=138,
ARM64_CLS=139,
ARM64_CLZ=140,
ARM64_CMEQ=141,
ARM64_CMGE=142,
ARM64_CMGT=143,
ARM64_CMHI=144,
ARM64_CMHS=145,
ARM64_CMLA=146,
ARM64_CMLE=147,
ARM64_CMLT=148,
ARM64_CMN=149,
ARM64_CMP=150,
ARM64_CMPEQ=151,
ARM64_CMPGE=152,
ARM64_CMPGT=153,
ARM64_CMPHI=154,
ARM64_CMPHS=155,
ARM64_CMPLE=156,
ARM64_CMPLO=157,
ARM64_CMPLS=158,
ARM64_CMPLT=159,
ARM64_CMPNE=160,
ARM64_CMPP=161,
ARM64_CMTST=162,
ARM64_CNEG=163,
ARM64_CNOT=164,
ARM64_CNT=165,
ARM64_CNTB=166,
ARM64_CNTD=167,
ARM64_CNTH=168,
ARM64_CNTP=169,
ARM64_CNTW=170,
ARM64_COMPACT=171,
ARM64_CPP=172,
ARM64_CPY=173,
ARM64_CRC32B=174,
ARM64_CRC32CB=175,
ARM64_CRC32CH=176,
ARM64_CRC32CW=177,
ARM64_CRC32CX=178,
ARM64_CRC32H=179,
ARM64_CRC32W=180,
ARM64_CRC32X=181,
ARM64_CSDB=182,
ARM64_CSEL=183,
ARM64_CSET=184,
ARM64_CSETM=185,
ARM64_CSINC=186,
ARM64_CSINV=187,
ARM64_CSNEG=188,
ARM64_CTERMEQ=189,
ARM64_CTERMNE=190,
ARM64_DC=191,
ARM64_DCPS1=192,
ARM64_DCPS2=193,
ARM64_DCPS3=194,
ARM64_DECB=195,
ARM64_DECD=196,
ARM64_DECH=197,
ARM64_DECP=198,
ARM64_DECW=199,
ARM64_DGH=200,
ARM64_DMB=201,
ARM64_DRPS=202,
ARM64_DSB=203,
ARM64_DUP=204,
ARM64_DUPM=205,
ARM64_DVP=206,
ARM64_EON=207,
ARM64_EOR=208,
ARM64_EOR3=209,
ARM64_EORBT=210,
ARM64_EORS=211,
ARM64_EORTB=212,
ARM64_EORV=213,
ARM64_ERET=214,
ARM64_ERETAA=215,
ARM64_ERETAB=216,
ARM64_ESB=217,
ARM64_EXT=218,
ARM64_EXTR=219,
ARM64_FABD=220,
ARM64_FABS=221,
ARM64_FACGE=222,
ARM64_FACGT=223,
ARM64_FACLE=224,
ARM64_FACLT=225,
ARM64_FADD=226,
ARM64_FADDA=227,
ARM64_FADDP=228,
ARM64_FADDV=229,
ARM64_FCADD=230,
ARM64_FCCMP=231,
ARM64_FCCMPE=232,
ARM64_FCMEQ=233,
ARM64_FCMGE=234,
ARM64_FCMGT=235,
ARM64_FCMLA=236,
ARM64_FCMLE=237,
ARM64_FCMLT=238,
ARM64_FCMNE=239,
ARM64_FCMP=240,
ARM64_FCMPE=241,
ARM64_FCMUO=242,
ARM64_FCPY=243,
ARM64_FCSEL=244,
ARM64_FCVT=245,
ARM64_FCVTAS=246,
ARM64_FCVTAU=247,
ARM64_FCVTL=248,
ARM64_FCVTL2=249,
ARM64_FCVTLT=250,
ARM64_FCVTMS=251,
ARM64_FCVTMU=252,
ARM64_FCVTN=253,
ARM64_FCVTN2=254,
ARM64_FCVTNS=255,
ARM64_FCVTNT=256,
ARM64_FCVTNU=257,
ARM64_FCVTPS=258,
ARM64_FCVTPU=259,
ARM64_FCVTX=260,
ARM64_FCVTXN=261,
ARM64_FCVTXN2=262,
ARM64_FCVTXNT=263,
ARM64_FCVTZS=264,
ARM64_FCVTZU=265,
ARM64_FDIV=266,
ARM64_FDIVR=267,
ARM64_FDUP=268,
ARM64_FEXPA=269,
ARM64_FJCVTZS=270,
ARM64_FLOGB=271,
ARM64_FMAD=272,
ARM64_FMADD=273,
ARM64_FMAX=274,
ARM64_FMAXNM=275,
ARM64_FMAXNMP=276,
ARM64_FMAXNMV=277,
ARM64_FMAXP=278,
ARM64_FMAXV=279,
ARM64_FMIN=280,
ARM64_FMINNM=281,
ARM64_FMINNMP=282,
ARM64_FMINNMV=283,
ARM64_FMINP=284,
ARM64_FMINV=285,
ARM64_FMLA=286,
ARM64_FMLAL=287,
ARM64_FMLAL2=288,
ARM64_FMLALB=289,
ARM64_FMLALT=290,
ARM64_FMLS=291,
ARM64_FMLSL=292,
ARM64_FMLSL2=293,
ARM64_FMLSLB=294,
ARM64_FMLSLT=295,
ARM64_FMMLA=296,
ARM64_FMOV=297,
ARM64_FMSB=298,
ARM64_FMSUB=299,
ARM64_FMUL=300,
ARM64_FMULX=301,
ARM64_FNEG=302,
ARM64_FNMAD=303,
ARM64_FNMADD=304,
ARM64_FNMLA=305,
ARM64_FNMLS=306,
ARM64_FNMSB=307,
ARM64_FNMSUB=308,
ARM64_FNMUL=309,
ARM64_FRECPE=310,
ARM64_FRECPS=311,
ARM64_FRECPX=312,
ARM64_FRINT32X=313,
ARM64_FRINT32Z=314,
ARM64_FRINT64X=315,
ARM64_FRINT64Z=316,
ARM64_FRINTA=317,
ARM64_FRINTI=318,
ARM64_FRINTM=319,
ARM64_FRINTN=320,
ARM64_FRINTP=321,
ARM64_FRINTX=322,
ARM64_FRINTZ=323,
ARM64_FRSQRTE=324,
ARM64_FRSQRTS=325,
ARM64_FSCALE=326,
ARM64_FSQRT=327,
ARM64_FSUB=328,
ARM64_FSUBR=329,
ARM64_FTMAD=330,
ARM64_FTSMUL=331,
ARM64_FTSSEL=332,
ARM64_GMI=333,
ARM64_HINT=334,
ARM64_HISTCNT=335,
ARM64_HISTSEG=336,
ARM64_HLT=337,
ARM64_HVC=338,
ARM64_IC=339,
ARM64_INCB=340,
ARM64_INCD=341,
ARM64_INCH=342,
ARM64_INCP=343,
ARM64_INCW=344,
ARM64_INDEX=345,
ARM64_INS=346,
ARM64_INSR=347,
ARM64_IRG=348,
ARM64_ISB=349,
ARM64_LASTA=350,
ARM64_LASTB=351,
ARM64_LD1=352,
ARM64_LD1B=353,
ARM64_LD1D=354,
ARM64_LD1H=355,
ARM64_LD1R=356,
ARM64_LD1RB=357,
ARM64_LD1RD=358,
ARM64_LD1RH=359,
ARM64_LD1ROB=360,
ARM64_LD1ROD=361,
ARM64_LD1ROH=362,
ARM64_LD1ROW=363,
ARM64_LD1RQB=364,
ARM64_LD1RQD=365,
ARM64_LD1RQH=366,
ARM64_LD1RQW=367,
ARM64_LD1RSB=368,
ARM64_LD1RSH=369,
ARM64_LD1RSW=370,
ARM64_LD1RW=371,
ARM64_LD1SB=372,
ARM64_LD1SH=373,
ARM64_LD1SW=374,
ARM64_LD1W=375,
ARM64_LD2=376,
ARM64_LD2B=377,
ARM64_LD2D=378,
ARM64_LD2H=379,
ARM64_LD2R=380,
ARM64_LD2W=381,
ARM64_LD3=382,
ARM64_LD3B=383,
ARM64_LD3D=384,
ARM64_LD3H=385,
ARM64_LD3R=386,
ARM64_LD3W=387,
ARM64_LD4=388,
ARM64_LD4B=389,
ARM64_LD4D=390,
ARM64_LD4H=391,
ARM64_LD4R=392,
ARM64_LD4W=393,
ARM64_LD64B=394,
ARM64_LDADD=395,
ARM64_LDADDA=396,
ARM64_LDADDAB=397,
ARM64_LDADDAH=398,
ARM64_LDADDAL=399,
ARM64_LDADDALB=400,
ARM64_LDADDALH=401,
ARM64_LDADDB=402,
ARM64_LDADDH=403,
ARM64_LDADDL=404,
ARM64_LDADDLB=405,
ARM64_LDADDLH=406,
ARM64_LDAPR=407,
ARM64_LDAPRB=408,
ARM64_LDAPRH=409,
ARM64_LDAPUR=410,
ARM64_LDAPURB=411,
ARM64_LDAPURH=412,
ARM64_LDAPURSB=413,
ARM64_LDAPURSH=414,
ARM64_LDAPURSW=415,
ARM64_LDAR=416,
ARM64_LDARB=417,
ARM64_LDARH=418,
ARM64_LDAXP=419,
ARM64_LDAXR=420,
ARM64_LDAXRB=421,
ARM64_LDAXRH=422,
ARM64_LDCLR=423,
ARM64_LDCLRA=424,
ARM64_LDCLRAB=425,
ARM64_LDCLRAH=426,
ARM64_LDCLRAL=427,
ARM64_LDCLRALB=428,
ARM64_LDCLRALH=429,
ARM64_LDCLRB=430,
ARM64_LDCLRH=431,
ARM64_LDCLRL=432,
ARM64_LDCLRLB=433,
ARM64_LDCLRLH=434,
ARM64_LDEOR=435,
ARM64_LDEORA=436,
ARM64_LDEORAB=437,
ARM64_LDEORAH=438,
ARM64_LDEORAL=439,
ARM64_LDEORALB=440,
ARM64_LDEORALH=441,
ARM64_LDEORB=442,
ARM64_LDEORH=443,
ARM64_LDEORL=444,
ARM64_LDEORLB=445,
ARM64_LDEORLH=446,
ARM64_LDFF1B=447,
ARM64_LDFF1D=448,
ARM64_LDFF1H=449,
ARM64_LDFF1SB=450,
ARM64_LDFF1SH=451,
ARM64_LDFF1SW=452,
ARM64_LDFF1W=453,
ARM64_LDG=454,
ARM64_LDGM=455,
ARM64_LDLAR=456,
ARM64_LDLARB=457,
ARM64_LDLARH=458,
ARM64_LDNF1B=459,
ARM64_LDNF1D=460,
ARM64_LDNF1H=461,
ARM64_LDNF1SB=462,
ARM64_LDNF1SH=463,
ARM64_LDNF1SW=464,
ARM64_LDNF1W=465,
ARM64_LDNP=466,
ARM64_LDNT1B=467,
ARM64_LDNT1D=468,
ARM64_LDNT1H=469,
ARM64_LDNT1SB=470,
ARM64_LDNT1SH=471,
ARM64_LDNT1SW=472,
ARM64_LDNT1W=473,
ARM64_LDP=474,
ARM64_LDPSW=475,
ARM64_LDR=476,
ARM64_LDRAA=477,
ARM64_LDRAB=478,
ARM64_LDRB=479,
ARM64_LDRH=480,
ARM64_LDRSB=481,
ARM64_LDRSH=482,
ARM64_LDRSW=483,
ARM64_LDSET=484,
ARM64_LDSETA=485,
ARM64_LDSETAB=486,
ARM64_LDSETAH=487,
ARM64_LDSETAL=488,
ARM64_LDSETALB=489,
ARM64_LDSETALH=490,
ARM64_LDSETB=491,
ARM64_LDSETH=492,
ARM64_LDSETL=493,
ARM64_LDSETLB=494,
ARM64_LDSETLH=495,
ARM64_LDSMAX=496,
ARM64_LDSMAXA=497,
ARM64_LDSMAXAB=498,
ARM64_LDSMAXAH=499,
ARM64_LDSMAXAL=500,
ARM64_LDSMAXALB=501,
ARM64_LDSMAXALH=502,
ARM64_LDSMAXB=503,
ARM64_LDSMAXH=504,
ARM64_LDSMAXL=505,
ARM64_LDSMAXLB=506,
ARM64_LDSMAXLH=507,
ARM64_LDSMIN=508,
ARM64_LDSMINA=509,
ARM64_LDSMINAB=510,
ARM64_LDSMINAH=511,
ARM64_LDSMINAL=512,
ARM64_LDSMINALB=513,
ARM64_LDSMINALH=514,
ARM64_LDSMINB=515,
ARM64_LDSMINH=516,
ARM64_LDSMINL=517,
ARM64_LDSMINLB=518,
ARM64_LDSMINLH=519,
ARM64_LDTR=520,
ARM64_LDTRB=521,
ARM64_LDTRH=522,
ARM64_LDTRSB=523,
ARM64_LDTRSH=524,
ARM64_LDTRSW=525,
ARM64_LDUMAX=526,
ARM64_LDUMAXA=527,
ARM64_LDUMAXAB=528,
ARM64_LDUMAXAH=529,
ARM64_LDUMAXAL=530,
ARM64_LDUMAXALB=531,
ARM64_LDUMAXALH=532,
ARM64_LDUMAXB=533,
ARM64_LDUMAXH=534,
ARM64_LDUMAXL=535,
ARM64_LDUMAXLB=536,
ARM64_LDUMAXLH=537,
ARM64_LDUMIN=538,
ARM64_LDUMINA=539,
ARM64_LDUMINAB=540,
ARM64_LDUMINAH=541,
ARM64_LDUMINAL=542,
ARM64_LDUMINALB=543,
ARM64_LDUMINALH=544,
ARM64_LDUMINB=545,
ARM64_LDUMINH=546,
ARM64_LDUMINL=547,
ARM64_LDUMINLB=548,
ARM64_LDUMINLH=549,
ARM64_LDUR=550,
ARM64_LDURB=551,
ARM64_LDURH=552,
ARM64_LDURSB=553,
ARM64_LDURSH=554,
ARM64_LDURSW=555,
ARM64_LDXP=556,
ARM64_LDXR=557,
ARM64_LDXRB=558,
ARM64_LDXRH=559,
ARM64_LSL=560,
ARM64_LSLR=561,
ARM64_LSLV=562,
ARM64_LSR=563,
ARM64_LSRR=564,
ARM64_LSRV=565,
ARM64_MAD=566,
ARM64_MADD=567,
ARM64_MATCH=568,
ARM64_MLA=569,
ARM64_MLS=570,
ARM64_MNEG=571,
ARM64_MOV=572,
ARM64_MOVI=573,
ARM64_MOVK=574,
ARM64_MOVN=575,
ARM64_MOVPRFX=576,
ARM64_MOVS=577,
ARM64_MOVZ=578,
ARM64_MRS=579,
ARM64_MSB=580,
ARM64_MSR=581,
ARM64_MSUB=582,
ARM64_MUL=583,
ARM64_MVN=584,
ARM64_MVNI=585,
ARM64_NAND=586,
ARM64_NANDS=587,
ARM64_NBSL=588,
ARM64_NEG=589,
ARM64_NEGS=590,
ARM64_NGC=591,
ARM64_NGCS=592,
ARM64_NMATCH=593,
ARM64_NOP=594,
ARM64_NOR=595,
ARM64_NORS=596,
ARM64_NOT=597,
ARM64_NOTS=598,
ARM64_ORN=599,
ARM64_ORNS=600,
ARM64_ORR=601,
ARM64_ORRS=602,
ARM64_ORV=603,
ARM64_PACDA=604,
ARM64_PACDB=605,
ARM64_PACDZA=606,
ARM64_PACDZB=607,
ARM64_PACGA=608,
ARM64_PACIA=609,
ARM64_PACIA1716=610,
ARM64_PACIASP=611,
ARM64_PACIAZ=612,
ARM64_PACIB=613,
ARM64_PACIB1716=614,
ARM64_PACIBSP=615,
ARM64_PACIBZ=616,
ARM64_PACIZA=617,
ARM64_PACIZB=618,
ARM64_PFALSE=619,
ARM64_PFIRST=620,
ARM64_PMUL=621,
ARM64_PMULL=622,
ARM64_PMULL2=623,
ARM64_PMULLB=624,
ARM64_PMULLT=625,
ARM64_PNEXT=626,
ARM64_PRFB=627,
ARM64_PRFD=628,
ARM64_PRFH=629,
ARM64_PRFM=630,
ARM64_PRFUM=631,
ARM64_PRFW=632,
ARM64_PSB=633,
ARM64_PSSBB=634,
ARM64_PTEST=635,
ARM64_PTRUE=636,
ARM64_PTRUES=637,
ARM64_PUNPKHI=638,
ARM64_PUNPKLO=639,
ARM64_RADDHN=640,
ARM64_RADDHN2=641,
ARM64_RADDHNB=642,
ARM64_RADDHNT=643,
ARM64_RAX1=644,
ARM64_RBIT=645,
ARM64_RDFFR=646,
ARM64_RDFFRS=647,
ARM64_RDVL=648,
ARM64_RET=649,
ARM64_RETAA=650,
ARM64_RETAB=651,
ARM64_REV=652,
ARM64_REV16=653,
ARM64_REV32=654,
ARM64_REV64=655,
ARM64_REVB=656,
ARM64_REVH=657,
ARM64_REVW=658,
ARM64_RMIF=659,
ARM64_ROR=660,
ARM64_RORV=661,
ARM64_RSHRN=662,
ARM64_RSHRN2=663,
ARM64_RSHRNB=664,
ARM64_RSHRNT=665,
ARM64_RSUBHN=666,
ARM64_RSUBHN2=667,
ARM64_RSUBHNB=668,
ARM64_RSUBHNT=669,
ARM64_SABA=670,
ARM64_SABAL=671,
ARM64_SABAL2=672,
ARM64_SABALB=673,
ARM64_SABALT=674,
ARM64_SABD=675,
ARM64_SABDL=676,
ARM64_SABDL2=677,
ARM64_SABDLB=678,
ARM64_SABDLT=679,
ARM64_SADALP=680,
ARM64_SADDL=681,
ARM64_SADDL2=682,
ARM64_SADDLB=683,
ARM64_SADDLBT=684,
ARM64_SADDLP=685,
ARM64_SADDLT=686,
ARM64_SADDLV=687,
ARM64_SADDV=688,
ARM64_SADDW=689,
ARM64_SADDW2=690,
ARM64_SADDWB=691,
ARM64_SADDWT=692,
ARM64_SB=693,
ARM64_SBC=694,
ARM64_SBCLB=695,
ARM64_SBCLT=696,
ARM64_SBCS=697,
ARM64_SBFIZ=698,
ARM64_SBFM=699,
ARM64_SBFX=700,
ARM64_SCVTF=701,
ARM64_SDIV=702,
ARM64_SDIVR=703,
ARM64_SDOT=704,
ARM64_SEL=705,
ARM64_SETF16=706,
ARM64_SETF8=707,
ARM64_SETFFR=708,
ARM64_SEV=709,
ARM64_SEVL=710,
ARM64_SHA1C=711,
ARM64_SHA1H=712,
ARM64_SHA1M=713,
ARM64_SHA1P=714,
ARM64_SHA1SU0=715,
ARM64_SHA1SU1=716,
ARM64_SHA256H=717,
ARM64_SHA256H2=718,
ARM64_SHA256SU0=719,
ARM64_SHA256SU1=720,
ARM64_SHA512H=721,
ARM64_SHA512H2=722,
ARM64_SHA512SU0=723,
ARM64_SHA512SU1=724,
ARM64_SHADD=725,
ARM64_SHL=726,
ARM64_SHLL=727,
ARM64_SHLL2=728,
ARM64_SHRN=729,
ARM64_SHRN2=730,
ARM64_SHRNB=731,
ARM64_SHRNT=732,
ARM64_SHSUB=733,
ARM64_SHSUBR=734,
ARM64_SLI=735,
ARM64_SM3PARTW1=736,
ARM64_SM3PARTW2=737,
ARM64_SM3SS1=738,
ARM64_SM3TT1A=739,
ARM64_SM3TT1B=740,
ARM64_SM3TT2A=741,
ARM64_SM3TT2B=742,
ARM64_SM4E=743,
ARM64_SM4EKEY=744,
ARM64_SMADDL=745,
ARM64_SMAX=746,
ARM64_SMAXP=747,
ARM64_SMAXV=748,
ARM64_SMC=749,
ARM64_SMIN=750,
ARM64_SMINP=751,
ARM64_SMINV=752,
ARM64_SMLAL=753,
ARM64_SMLAL2=754,
ARM64_SMLALB=755,
ARM64_SMLALT=756,
ARM64_SMLSL=757,
ARM64_SMLSL2=758,
ARM64_SMLSLB=759,
ARM64_SMLSLT=760,
ARM64_SMMLA=761,
ARM64_SMNEGL=762,
ARM64_SMOV=763,
ARM64_SMSUBL=764,
ARM64_SMULH=765,
ARM64_SMULL=766,
ARM64_SMULL2=767,
ARM64_SMULLB=768,
ARM64_SMULLT=769,
ARM64_SPLICE=770,
ARM64_SQABS=771,
ARM64_SQADD=772,
ARM64_SQCADD=773,
ARM64_SQDECB=774,
ARM64_SQDECD=775,
ARM64_SQDECH=776,
ARM64_SQDECP=777,
ARM64_SQDECW=778,
ARM64_SQDMLAL=779,
ARM64_SQDMLAL2=780,
ARM64_SQDMLALB=781,
ARM64_SQDMLALBT=782,
ARM64_SQDMLALT=783,
ARM64_SQDMLSL=784,
ARM64_SQDMLSL2=785,
ARM64_SQDMLSLB=786,
ARM64_SQDMLSLBT=787,
ARM64_SQDMLSLT=788,
ARM64_SQDMULH=789,
ARM64_SQDMULL=790,
ARM64_SQDMULL2=791,
ARM64_SQDMULLB=792,
ARM64_SQDMULLT=793,
ARM64_SQINCB=794,
ARM64_SQINCD=795,
ARM64_SQINCH=796,
ARM64_SQINCP=797,
ARM64_SQINCW=798,
ARM64_SQNEG=799,
ARM64_SQRDCMLAH=800,
ARM64_SQRDMLAH=801,
ARM64_SQRDMLSH=802,
ARM64_SQRDMULH=803,
ARM64_SQRSHL=804,
ARM64_SQRSHLR=805,
ARM64_SQRSHRN=806,
ARM64_SQRSHRN2=807,
ARM64_SQRSHRNB=808,
ARM64_SQRSHRNT=809,
ARM64_SQRSHRUN=810,
ARM64_SQRSHRUN2=811,
ARM64_SQRSHRUNB=812,
ARM64_SQRSHRUNT=813,
ARM64_SQSHL=814,
ARM64_SQSHLR=815,
ARM64_SQSHLU=816,
ARM64_SQSHRN=817,
ARM64_SQSHRN2=818,
ARM64_SQSHRNB=819,
ARM64_SQSHRNT=820,
ARM64_SQSHRUN=821,
ARM64_SQSHRUN2=822,
ARM64_SQSHRUNB=823,
ARM64_SQSHRUNT=824,
ARM64_SQSUB=825,
ARM64_SQSUBR=826,
ARM64_SQXTN=827,
ARM64_SQXTN2=828,
ARM64_SQXTNB=829,
ARM64_SQXTNT=830,
ARM64_SQXTUN=831,
ARM64_SQXTUN2=832,
ARM64_SQXTUNB=833,
ARM64_SQXTUNT=834,
ARM64_SRHADD=835,
ARM64_SRI=836,
ARM64_SRSHL=837,
ARM64_SRSHLR=838,
ARM64_SRSHR=839,
ARM64_SRSRA=840,
ARM64_SSBB=841,
ARM64_SSHL=842,
ARM64_SSHLL=843,
ARM64_SSHLL2=844,
ARM64_SSHLLB=845,
ARM64_SSHLLT=846,
ARM64_SSHR=847,
ARM64_SSRA=848,
ARM64_SSUBL=849,
ARM64_SSUBL2=850,
ARM64_SSUBLB=851,
ARM64_SSUBLBT=852,
ARM64_SSUBLT=853,
ARM64_SSUBLTB=854,
ARM64_SSUBW=855,
ARM64_SSUBW2=856,
ARM64_SSUBWB=857,
ARM64_SSUBWT=858,
ARM64_ST1=859,
ARM64_ST1B=860,
ARM64_ST1D=861,
ARM64_ST1H=862,
ARM64_ST1W=863,
ARM64_ST2=864,
ARM64_ST2B=865,
ARM64_ST2D=866,
ARM64_ST2G=867,
ARM64_ST2H=868,
ARM64_ST2W=869,
ARM64_ST3=870,
ARM64_ST3B=871,
ARM64_ST3D=872,
ARM64_ST3H=873,
ARM64_ST3W=874,
ARM64_ST4=875,
ARM64_ST4B=876,
ARM64_ST4D=877,
ARM64_ST4H=878,
ARM64_ST4W=879,
ARM64_ST64B=880,
ARM64_ST64BV=881,
ARM64_ST64BV0=882,
ARM64_STADD=883,
ARM64_STADDB=884,
ARM64_STADDH=885,
ARM64_STADDL=886,
ARM64_STADDLB=887,
ARM64_STADDLH=888,
ARM64_STCLR=889,
ARM64_STCLRB=890,
ARM64_STCLRH=891,
ARM64_STCLRL=892,
ARM64_STCLRLB=893,
ARM64_STCLRLH=894,
ARM64_STEOR=895,
ARM64_STEORB=896,
ARM64_STEORH=897,
ARM64_STEORL=898,
ARM64_STEORLB=899,
ARM64_STEORLH=900,
ARM64_STG=901,
ARM64_STGM=902,
ARM64_STGP=903,
ARM64_STLLR=904,
ARM64_STLLRB=905,
ARM64_STLLRH=906,
ARM64_STLR=907,
ARM64_STLRB=908,
ARM64_STLRH=909,
ARM64_STLUR=910,
ARM64_STLURB=911,
ARM64_STLURH=912,
ARM64_STLXP=913,
ARM64_STLXR=914,
ARM64_STLXRB=915,
ARM64_STLXRH=916,
ARM64_STNP=917,
ARM64_STNT1B=918,
ARM64_STNT1D=919,
ARM64_STNT1H=920,
ARM64_STNT1W=921,
ARM64_STP=922,
ARM64_STR=923,
ARM64_STRB=924,
ARM64_STRH=925,
ARM64_STSET=926,
ARM64_STSETB=927,
ARM64_STSETH=928,
ARM64_STSETL=929,
ARM64_STSETLB=930,
ARM64_STSETLH=931,
ARM64_STSMAX=932,
ARM64_STSMAXB=933,
ARM64_STSMAXH=934,
ARM64_STSMAXL=935,
ARM64_STSMAXLB=936,
ARM64_STSMAXLH=937,
ARM64_STSMIN=938,
ARM64_STSMINB=939,
ARM64_STSMINH=940,
ARM64_STSMINL=941,
ARM64_STSMINLB=942,
ARM64_STSMINLH=943,
ARM64_STTR=944,
ARM64_STTRB=945,
ARM64_STTRH=946,
ARM64_STUMAX=947,
ARM64_STUMAXB=948,
ARM64_STUMAXH=949,
ARM64_STUMAXL=950,
ARM64_STUMAXLB=951,
ARM64_STUMAXLH=952,
ARM64_STUMIN=953,
ARM64_STUMINB=954,
ARM64_STUMINH=955,
ARM64_STUMINL=956,
ARM64_STUMINLB=957,
ARM64_STUMINLH=958,
ARM64_STUR=959,
ARM64_STURB=960,
ARM64_STURH=961,
ARM64_STXP=962,
ARM64_STXR=963,
ARM64_STXRB=964,
ARM64_STXRH=965,
ARM64_STZ2G=966,
ARM64_STZG=967,
ARM64_STZGM=968,
ARM64_SUB=969,
ARM64_SUBG=970,
ARM64_SUBHN=971,
ARM64_SUBHN2=972,
ARM64_SUBHNB=973,
ARM64_SUBHNT=974,
ARM64_SUBP=975,
ARM64_SUBPS=976,
ARM64_SUBR=977,
ARM64_SUBS=978,
ARM64_SUDOT=979,
ARM64_SUNPKHI=980,
ARM64_SUNPKLO=981,
ARM64_SUQADD=982,
ARM64_SVC=983,
ARM64_SWP=984,
ARM64_SWPA=985,
ARM64_SWPAB=986,
ARM64_SWPAH=987,
ARM64_SWPAL=988,
ARM64_SWPALB=989,
ARM64_SWPALH=990,
ARM64_SWPB=991,
ARM64_SWPH=992,
ARM64_SWPL=993,
ARM64_SWPLB=994,
ARM64_SWPLH=995,
ARM64_SXTB=996,
ARM64_SXTH=997,
ARM64_SXTL=998,
ARM64_SXTL2=999,
ARM64_SXTW=1000,
ARM64_SYS=1001,
ARM64_SYSL=1002,
ARM64_TBL=1003,
ARM64_TBNZ=1004,
ARM64_TBX=1005,
ARM64_TBZ=1006,
ARM64_TCANCEL=1007,
ARM64_TCOMMIT=1008,
ARM64_TLBI=1009,
ARM64_TRN1=1010,
ARM64_TRN2=1011,
ARM64_TSB=1012,
ARM64_TST=1013,
ARM64_TSTART=1014,
ARM64_TTEST=1015,
ARM64_UABA=1016,
ARM64_UABAL=1017,
ARM64_UABAL2=1018,
ARM64_UABALB=1019,
ARM64_UABALT=1020,
ARM64_UABD=1021,
ARM64_UABDL=1022,
ARM64_UABDL2=1023,
ARM64_UABDLB=1024,
ARM64_UABDLT=1025,
ARM64_UADALP=1026,
ARM64_UADDL=1027,
ARM64_UADDL2=1028,
ARM64_UADDLB=1029,
ARM64_UADDLP=1030,
ARM64_UADDLT=1031,
ARM64_UADDLV=1032,
ARM64_UADDV=1033,
ARM64_UADDW=1034,
ARM64_UADDW2=1035,
ARM64_UADDWB=1036,
ARM64_UADDWT=1037,
ARM64_UBFIZ=1038,
ARM64_UBFM=1039,
ARM64_UBFX=1040,
ARM64_UCVTF=1041,
ARM64_UDF=1042,
ARM64_UDIV=1043,
ARM64_UDIVR=1044,
ARM64_UDOT=1045,
ARM64_UHADD=1046,
ARM64_UHSUB=1047,
ARM64_UHSUBR=1048,
ARM64_UMADDL=1049,
ARM64_UMAX=1050,
ARM64_UMAXP=1051,
ARM64_UMAXV=1052,
ARM64_UMIN=1053,
ARM64_UMINP=1054,
ARM64_UMINV=1055,
ARM64_UMLAL=1056,
ARM64_UMLAL2=1057,
ARM64_UMLALB=1058,
ARM64_UMLALT=1059,
ARM64_UMLSL=1060,
ARM64_UMLSL2=1061,
ARM64_UMLSLB=1062,
ARM64_UMLSLT=1063,
ARM64_UMMLA=1064,
ARM64_UMNEGL=1065,
ARM64_UMOV=1066,
ARM64_UMSUBL=1067,
ARM64_UMULH=1068,
ARM64_UMULL=1069,
ARM64_UMULL2=1070,
ARM64_UMULLB=1071,
ARM64_UMULLT=1072,
ARM64_UQADD=1073,
ARM64_UQDECB=1074,
ARM64_UQDECD=1075,
ARM64_UQDECH=1076,
ARM64_UQDECP=1077,
ARM64_UQDECW=1078,
ARM64_UQINCB=1079,
ARM64_UQINCD=1080,
ARM64_UQINCH=1081,
ARM64_UQINCP=1082,
ARM64_UQINCW=1083,
ARM64_UQRSHL=1084,
ARM64_UQRSHLR=1085,
ARM64_UQRSHRN=1086,
ARM64_UQRSHRN2=1087,
ARM64_UQRSHRNB=1088,
ARM64_UQRSHRNT=1089,
ARM64_UQSHL=1090,
ARM64_UQSHLR=1091,
ARM64_UQSHRN=1092,
ARM64_UQSHRN2=1093,
ARM64_UQSHRNB=1094,
ARM64_UQSHRNT=1095,
ARM64_UQSUB=1096,
ARM64_UQSUBR=1097,
ARM64_UQXTN=1098,
ARM64_UQXTN2=1099,
ARM64_UQXTNB=1100,
ARM64_UQXTNT=1101,
ARM64_URECPE=1102,
ARM64_URHADD=1103,
ARM64_URSHL=1104,
ARM64_URSHLR=1105,
ARM64_URSHR=1106,
ARM64_URSQRTE=1107,
ARM64_URSRA=1108,
ARM64_USDOT=1109,
ARM64_USHL=1110,
ARM64_USHLL=1111,
ARM64_USHLL2=1112,
ARM64_USHLLB=1113,
ARM64_USHLLT=1114,
ARM64_USHR=1115,
ARM64_USMMLA=1116,
ARM64_USQADD=1117,
ARM64_USRA=1118,
ARM64_USUBL=1119,
ARM64_USUBL2=1120,
ARM64_USUBLB=1121,
ARM64_USUBLT=1122,
ARM64_USUBW=1123,
ARM64_USUBW2=1124,
ARM64_USUBWB=1125,
ARM64_USUBWT=1126,
ARM64_UUNPKHI=1127,
ARM64_UUNPKLO=1128,
ARM64_UXTB=1129,
ARM64_UXTH=1130,
ARM64_UXTL=1131,
ARM64_UXTL2=1132,
ARM64_UXTW=1133,
ARM64_UZP1=1134,
ARM64_UZP2=1135,
ARM64_WFE=1136,
ARM64_WFET=1137,
ARM64_WFI=1138,
ARM64_WFIT=1139,
ARM64_WHILEGE=1140,
ARM64_WHILEGT=1141,
ARM64_WHILEHI=1142,
ARM64_WHILEHS=1143,
ARM64_WHILELE=1144,
ARM64_WHILELO=1145,
ARM64_WHILELS=1146,
ARM64_WHILELT=1147,
ARM64_WHILERW=1148,
ARM64_WHILEWR=1149,
ARM64_WRFFR=1150,
ARM64_XAFLAG=1151,
ARM64_XAR=1152,
ARM64_XPACD=1153,
ARM64_XPACI=1154,
ARM64_XPACLRI=1155,
ARM64_XTN=1156,
ARM64_XTN2=1157,
ARM64_YIELD=1158,
ARM64_ZIP1=1159,
ARM64_ZIP2=1160,
};
const char *operation_to_str(enum Operation oper);
# 10 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 2
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/encodings_dec.h" 1

       





enum ENCODING {
ENC_UNKNOWN=0,
ENC_ABS_ASIMDMISC_R=1,
ENC_ABS_ASISDMISC_R=2,
ENC_ADCS_32_ADDSUB_CARRY=3,
ENC_ADCS_64_ADDSUB_CARRY=4,
ENC_ADC_32_ADDSUB_CARRY=5,
ENC_ADC_64_ADDSUB_CARRY=6,
ENC_ADDG_64_ADDSUB_IMMTAGS=7,
ENC_ADDHN_ASIMDDIFF_N=8,
ENC_ADDP_ASIMDSAME_ONLY=9,
ENC_ADDP_ASISDPAIR_ONLY=10,
ENC_ADDS_32S_ADDSUB_EXT=11,
ENC_ADDS_32S_ADDSUB_IMM=12,
ENC_ADDS_32_ADDSUB_SHIFT=13,
ENC_ADDS_64S_ADDSUB_EXT=14,
ENC_ADDS_64S_ADDSUB_IMM=15,
ENC_ADDS_64_ADDSUB_SHIFT=16,
ENC_ADDV_ASIMDALL_ONLY=17,
ENC_ADD_32_ADDSUB_EXT=18,
ENC_ADD_32_ADDSUB_IMM=19,
ENC_ADD_32_ADDSUB_SHIFT=20,
ENC_ADD_64_ADDSUB_EXT=21,
ENC_ADD_64_ADDSUB_IMM=22,
ENC_ADD_64_ADDSUB_SHIFT=23,
ENC_ADD_ASIMDSAME_ONLY=24,
ENC_ADD_ASISDSAME_ONLY=25,
ENC_ADRP_ONLY_PCRELADDR=26,
ENC_ADR_ONLY_PCRELADDR=27,
ENC_AESD_B_CRYPTOAES=28,
ENC_AESE_B_CRYPTOAES=29,
ENC_AESIMC_B_CRYPTOAES=30,
ENC_AESMC_B_CRYPTOAES=31,
ENC_ANDS_32S_LOG_IMM=32,
ENC_ANDS_32_LOG_SHIFT=33,
ENC_ANDS_64S_LOG_IMM=34,
ENC_ANDS_64_LOG_SHIFT=35,
ENC_AND_32_LOG_IMM=36,
ENC_AND_32_LOG_SHIFT=37,
ENC_AND_64_LOG_IMM=38,
ENC_AND_64_LOG_SHIFT=39,
ENC_AND_ASIMDSAME_ONLY=40,
ENC_ASRV_32_DP_2SRC=41,
ENC_ASRV_64_DP_2SRC=42,
ENC_ASR_ASRV_32_DP_2SRC=43,
ENC_ASR_ASRV_64_DP_2SRC=44,
ENC_ASR_SBFM_32M_BITFIELD=45,
ENC_ASR_SBFM_64M_BITFIELD=46,
ENC_AT_SYS_CR_SYSTEMINSTRS=47,
ENC_AUTDA_64P_DP_1SRC=48,
ENC_AUTDB_64P_DP_1SRC=49,
ENC_AUTDZA_64Z_DP_1SRC=50,
ENC_AUTDZB_64Z_DP_1SRC=51,
ENC_AUTIA1716_HI_HINTS=52,
ENC_AUTIASP_HI_HINTS=53,
ENC_AUTIAZ_HI_HINTS=54,
ENC_AUTIA_64P_DP_1SRC=55,
ENC_AUTIB1716_HI_HINTS=56,
ENC_AUTIBSP_HI_HINTS=57,
ENC_AUTIBZ_HI_HINTS=58,
ENC_AUTIB_64P_DP_1SRC=59,
ENC_AUTIZA_64Z_DP_1SRC=60,
ENC_AUTIZB_64Z_DP_1SRC=61,
ENC_AXFLAG_M_PSTATE=62,
ENC_BCAX_VVV16_CRYPTO4=63,
ENC_BFCVTN_ASIMDMISC_4S=64,
ENC_BFCVT_BS_FLOATDP1=65,
ENC_BFC_BFM_32M_BITFIELD=66,
ENC_BFC_BFM_64M_BITFIELD=67,
ENC_BFDOT_ASIMDELEM_E=68,
ENC_BFDOT_ASIMDSAME2_D=69,
ENC_BFI_BFM_32M_BITFIELD=70,
ENC_BFI_BFM_64M_BITFIELD=71,
ENC_BFMLAL_ASIMDELEM_F=72,
ENC_BFMLAL_ASIMDSAME2_F_=73,
ENC_BFMMLA_ASIMDSAME2_E=74,
ENC_BFM_32M_BITFIELD=75,
ENC_BFM_64M_BITFIELD=76,
ENC_BFXIL_BFM_32M_BITFIELD=77,
ENC_BFXIL_BFM_64M_BITFIELD=78,
ENC_BICS_32_LOG_SHIFT=79,
ENC_BICS_64_LOG_SHIFT=80,
ENC_BIC_32_LOG_SHIFT=81,
ENC_BIC_64_LOG_SHIFT=82,
ENC_BIC_AND_Z_ZI_=83,
ENC_BIC_ASIMDIMM_L_HL=84,
ENC_BIC_ASIMDIMM_L_SL=85,
ENC_BIC_ASIMDSAME_ONLY=86,
ENC_BIF_ASIMDSAME_ONLY=87,
ENC_BIT_ASIMDSAME_ONLY=88,
ENC_BLRAAZ_64_BRANCH_REG=89,
ENC_BLRAA_64P_BRANCH_REG=90,
ENC_BLRABZ_64_BRANCH_REG=91,
ENC_BLRAB_64P_BRANCH_REG=92,
ENC_BLR_64_BRANCH_REG=93,
ENC_BL_ONLY_BRANCH_IMM=94,
ENC_BRAAZ_64_BRANCH_REG=95,
ENC_BRAA_64P_BRANCH_REG=96,
ENC_BRABZ_64_BRANCH_REG=97,
ENC_BRAB_64P_BRANCH_REG=98,
ENC_BRK_EX_EXCEPTION=99,
ENC_BR_64_BRANCH_REG=100,
ENC_BSL_ASIMDSAME_ONLY=101,
ENC_BTI_HB_HINTS=102,
ENC_B_ONLY_BRANCH_IMM=103,
ENC_B_ONLY_CONDBRANCH=104,
ENC_CASAB_C32_COMSWAP=105,
ENC_CASAH_C32_COMSWAP=106,
ENC_CASALB_C32_COMSWAP=107,
ENC_CASALH_C32_COMSWAP=108,
ENC_CASAL_C32_COMSWAP=109,
ENC_CASAL_C64_COMSWAP=110,
ENC_CASA_C32_COMSWAP=111,
ENC_CASA_C64_COMSWAP=112,
ENC_CASB_C32_COMSWAP=113,
ENC_CASH_C32_COMSWAP=114,
ENC_CASLB_C32_COMSWAP=115,
ENC_CASLH_C32_COMSWAP=116,
ENC_CASL_C32_COMSWAP=117,
ENC_CASL_C64_COMSWAP=118,
ENC_CASPAL_CP32_COMSWAPPR=119,
ENC_CASPAL_CP64_COMSWAPPR=120,
ENC_CASPA_CP32_COMSWAPPR=121,
ENC_CASPA_CP64_COMSWAPPR=122,
ENC_CASPL_CP32_COMSWAPPR=123,
ENC_CASPL_CP64_COMSWAPPR=124,
ENC_CASP_CP32_COMSWAPPR=125,
ENC_CASP_CP64_COMSWAPPR=126,
ENC_CAS_C32_COMSWAP=127,
ENC_CAS_C64_COMSWAP=128,
ENC_CBNZ_32_COMPBRANCH=129,
ENC_CBNZ_64_COMPBRANCH=130,
ENC_CBZ_32_COMPBRANCH=131,
ENC_CBZ_64_COMPBRANCH=132,
ENC_CCMN_32_CONDCMP_IMM=133,
ENC_CCMN_32_CONDCMP_REG=134,
ENC_CCMN_64_CONDCMP_IMM=135,
ENC_CCMN_64_CONDCMP_REG=136,
ENC_CCMP_32_CONDCMP_IMM=137,
ENC_CCMP_32_CONDCMP_REG=138,
ENC_CCMP_64_CONDCMP_IMM=139,
ENC_CCMP_64_CONDCMP_REG=140,
ENC_CFINV_M_PSTATE=141,
ENC_CFP_SYS_CR_SYSTEMINSTRS=142,
ENC_CINC_CSINC_32_CONDSEL=143,
ENC_CINC_CSINC_64_CONDSEL=144,
ENC_CINV_CSINV_32_CONDSEL=145,
ENC_CINV_CSINV_64_CONDSEL=146,
ENC_CLREX_BN_BARRIERS=147,
ENC_CLS_32_DP_1SRC=148,
ENC_CLS_64_DP_1SRC=149,
ENC_CLS_ASIMDMISC_R=150,
ENC_CLZ_32_DP_1SRC=151,
ENC_CLZ_64_DP_1SRC=152,
ENC_CLZ_ASIMDMISC_R=153,
ENC_CMEQ_ASIMDMISC_Z=154,
ENC_CMEQ_ASIMDSAME_ONLY=155,
ENC_CMEQ_ASISDMISC_Z=156,
ENC_CMEQ_ASISDSAME_ONLY=157,
ENC_CMGE_ASIMDMISC_Z=158,
ENC_CMGE_ASIMDSAME_ONLY=159,
ENC_CMGE_ASISDMISC_Z=160,
ENC_CMGE_ASISDSAME_ONLY=161,
ENC_CMGT_ASIMDMISC_Z=162,
ENC_CMGT_ASIMDSAME_ONLY=163,
ENC_CMGT_ASISDMISC_Z=164,
ENC_CMGT_ASISDSAME_ONLY=165,
ENC_CMHI_ASIMDSAME_ONLY=166,
ENC_CMHI_ASISDSAME_ONLY=167,
ENC_CMHS_ASIMDSAME_ONLY=168,
ENC_CMHS_ASISDSAME_ONLY=169,
ENC_CMLE_ASIMDMISC_Z=170,
ENC_CMLE_ASISDMISC_Z=171,
ENC_CMLT_ASIMDMISC_Z=172,
ENC_CMLT_ASISDMISC_Z=173,
ENC_CMN_ADDS_32S_ADDSUB_EXT=174,
ENC_CMN_ADDS_32S_ADDSUB_IMM=175,
ENC_CMN_ADDS_32_ADDSUB_SHIFT=176,
ENC_CMN_ADDS_64S_ADDSUB_EXT=177,
ENC_CMN_ADDS_64S_ADDSUB_IMM=178,
ENC_CMN_ADDS_64_ADDSUB_SHIFT=179,
ENC_CMPLE_CMPGE_P_P_ZZ_=180,
ENC_CMPLO_CMPHI_P_P_ZZ_=181,
ENC_CMPLS_CMPHS_P_P_ZZ_=182,
ENC_CMPLT_CMPGT_P_P_ZZ_=183,
ENC_CMPP_SUBPS_64S_DP_2SRC=184,
ENC_CMP_SUBS_32S_ADDSUB_EXT=185,
ENC_CMP_SUBS_32S_ADDSUB_IMM=186,
ENC_CMP_SUBS_32_ADDSUB_SHIFT=187,
ENC_CMP_SUBS_64S_ADDSUB_EXT=188,
ENC_CMP_SUBS_64S_ADDSUB_IMM=189,
ENC_CMP_SUBS_64_ADDSUB_SHIFT=190,
ENC_CMTST_ASIMDSAME_ONLY=191,
ENC_CMTST_ASISDSAME_ONLY=192,
ENC_CNEG_CSNEG_32_CONDSEL=193,
ENC_CNEG_CSNEG_64_CONDSEL=194,
ENC_CNT_ASIMDMISC_R=195,
ENC_CPP_SYS_CR_SYSTEMINSTRS=196,
ENC_CRC32B_32C_DP_2SRC=197,
ENC_CRC32CB_32C_DP_2SRC=198,
ENC_CRC32CH_32C_DP_2SRC=199,
ENC_CRC32CW_32C_DP_2SRC=200,
ENC_CRC32CX_64C_DP_2SRC=201,
ENC_CRC32H_32C_DP_2SRC=202,
ENC_CRC32W_32C_DP_2SRC=203,
ENC_CRC32X_64C_DP_2SRC=204,
ENC_CSDB_HI_HINTS=205,
ENC_CSEL_32_CONDSEL=206,
ENC_CSEL_64_CONDSEL=207,
ENC_CSETM_CSINV_32_CONDSEL=208,
ENC_CSETM_CSINV_64_CONDSEL=209,
ENC_CSET_CSINC_32_CONDSEL=210,
ENC_CSET_CSINC_64_CONDSEL=211,
ENC_CSINC_32_CONDSEL=212,
ENC_CSINC_64_CONDSEL=213,
ENC_CSINV_32_CONDSEL=214,
ENC_CSINV_64_CONDSEL=215,
ENC_CSNEG_32_CONDSEL=216,
ENC_CSNEG_64_CONDSEL=217,
ENC_DCPS1_DC_EXCEPTION=218,
ENC_DCPS2_DC_EXCEPTION=219,
ENC_DCPS3_DC_EXCEPTION=220,
ENC_DC_SYS_CR_SYSTEMINSTRS=221,
ENC_DGH_HI_HINTS=222,
ENC_DMB_BO_BARRIERS=223,
ENC_DRPS_64E_BRANCH_REG=224,
ENC_DSB_BO_BARRIERS=225,
ENC_DSB_BON_BARRIERS=226,
ENC_DUP_ASIMDINS_DR_R=227,
ENC_DUP_ASIMDINS_DV_V=228,
ENC_DUP_ASISDONE_ONLY=229,
ENC_DVP_SYS_CR_SYSTEMINSTRS=230,
ENC_EON_32_LOG_SHIFT=231,
ENC_EON_64_LOG_SHIFT=232,
ENC_EON_EOR_Z_ZI_=233,
ENC_EOR3_VVV16_CRYPTO4=234,
ENC_EOR_32_LOG_IMM=235,
ENC_EOR_32_LOG_SHIFT=236,
ENC_EOR_64_LOG_IMM=237,
ENC_EOR_64_LOG_SHIFT=238,
ENC_EOR_ASIMDSAME_ONLY=239,
ENC_ERETAA_64E_BRANCH_REG=240,
ENC_ERETAB_64E_BRANCH_REG=241,
ENC_ERET_64E_BRANCH_REG=242,
ENC_ESB_HI_HINTS=243,
ENC_EXTR_32_EXTRACT=244,
ENC_EXTR_64_EXTRACT=245,
ENC_EXT_ASIMDEXT_ONLY=246,
ENC_FABD_ASIMDSAME_ONLY=247,
ENC_FABD_ASIMDSAMEFP16_ONLY=248,
ENC_FABD_ASISDSAME_ONLY=249,
ENC_FABD_ASISDSAMEFP16_ONLY=250,
ENC_FABS_D_FLOATDP1=251,
ENC_FABS_H_FLOATDP1=252,
ENC_FABS_S_FLOATDP1=253,
ENC_FABS_ASIMDMISC_R=254,
ENC_FABS_ASIMDMISCFP16_R=255,
ENC_FACGE_ASIMDSAME_ONLY=256,
ENC_FACGE_ASIMDSAMEFP16_ONLY=257,
ENC_FACGE_ASISDSAME_ONLY=258,
ENC_FACGE_ASISDSAMEFP16_ONLY=259,
ENC_FACGT_ASIMDSAME_ONLY=260,
ENC_FACGT_ASIMDSAMEFP16_ONLY=261,
ENC_FACGT_ASISDSAME_ONLY=262,
ENC_FACGT_ASISDSAMEFP16_ONLY=263,
ENC_FACLE_FACGE_P_P_ZZ_=264,
ENC_FACLT_FACGT_P_P_ZZ_=265,
ENC_FADDP_ASIMDSAME_ONLY=266,
ENC_FADDP_ASIMDSAMEFP16_ONLY=267,
ENC_FADDP_ASISDPAIR_ONLY_H=268,
ENC_FADDP_ASISDPAIR_ONLY_SD=269,
ENC_FADD_D_FLOATDP2=270,
ENC_FADD_H_FLOATDP2=271,
ENC_FADD_S_FLOATDP2=272,
ENC_FADD_ASIMDSAME_ONLY=273,
ENC_FADD_ASIMDSAMEFP16_ONLY=274,
ENC_FCADD_ASIMDSAME2_C=275,
ENC_FCCMPE_D_FLOATCCMP=276,
ENC_FCCMPE_H_FLOATCCMP=277,
ENC_FCCMPE_S_FLOATCCMP=278,
ENC_FCCMP_D_FLOATCCMP=279,
ENC_FCCMP_H_FLOATCCMP=280,
ENC_FCCMP_S_FLOATCCMP=281,
ENC_FCMEQ_ASIMDMISC_FZ=282,
ENC_FCMEQ_ASIMDMISCFP16_FZ=283,
ENC_FCMEQ_ASIMDSAME_ONLY=284,
ENC_FCMEQ_ASIMDSAMEFP16_ONLY=285,
ENC_FCMEQ_ASISDMISC_FZ=286,
ENC_FCMEQ_ASISDMISCFP16_FZ=287,
ENC_FCMEQ_ASISDSAME_ONLY=288,
ENC_FCMEQ_ASISDSAMEFP16_ONLY=289,
ENC_FCMGE_ASIMDMISC_FZ=290,
ENC_FCMGE_ASIMDMISCFP16_FZ=291,
ENC_FCMGE_ASIMDSAME_ONLY=292,
ENC_FCMGE_ASIMDSAMEFP16_ONLY=293,
ENC_FCMGE_ASISDMISC_FZ=294,
ENC_FCMGE_ASISDMISCFP16_FZ=295,
ENC_FCMGE_ASISDSAME_ONLY=296,
ENC_FCMGE_ASISDSAMEFP16_ONLY=297,
ENC_FCMGT_ASIMDMISC_FZ=298,
ENC_FCMGT_ASIMDMISCFP16_FZ=299,
ENC_FCMGT_ASIMDSAME_ONLY=300,
ENC_FCMGT_ASIMDSAMEFP16_ONLY=301,
ENC_FCMGT_ASISDMISC_FZ=302,
ENC_FCMGT_ASISDMISCFP16_FZ=303,
ENC_FCMGT_ASISDSAME_ONLY=304,
ENC_FCMGT_ASISDSAMEFP16_ONLY=305,
ENC_FCMLA_ASIMDELEM_C_H=306,
ENC_FCMLA_ASIMDELEM_C_S=307,
ENC_FCMLA_ASIMDSAME2_C=308,
ENC_FCMLE_ASIMDMISC_FZ=309,
ENC_FCMLE_ASIMDMISCFP16_FZ=310,
ENC_FCMLE_ASISDMISC_FZ=311,
ENC_FCMLE_ASISDMISCFP16_FZ=312,
ENC_FCMLE_FCMGE_P_P_ZZ_=313,
ENC_FCMLT_ASIMDMISC_FZ=314,
ENC_FCMLT_ASIMDMISCFP16_FZ=315,
ENC_FCMLT_ASISDMISC_FZ=316,
ENC_FCMLT_ASISDMISCFP16_FZ=317,
ENC_FCMLT_FCMGT_P_P_ZZ_=318,
ENC_FCMPE_DZ_FLOATCMP=319,
ENC_FCMPE_D_FLOATCMP=320,
ENC_FCMPE_HZ_FLOATCMP=321,
ENC_FCMPE_H_FLOATCMP=322,
ENC_FCMPE_SZ_FLOATCMP=323,
ENC_FCMPE_S_FLOATCMP=324,
ENC_FCMP_DZ_FLOATCMP=325,
ENC_FCMP_D_FLOATCMP=326,
ENC_FCMP_HZ_FLOATCMP=327,
ENC_FCMP_H_FLOATCMP=328,
ENC_FCMP_SZ_FLOATCMP=329,
ENC_FCMP_S_FLOATCMP=330,
ENC_FCSEL_D_FLOATSEL=331,
ENC_FCSEL_H_FLOATSEL=332,
ENC_FCSEL_S_FLOATSEL=333,
ENC_FCVTAS_32D_FLOAT2INT=334,
ENC_FCVTAS_32H_FLOAT2INT=335,
ENC_FCVTAS_32S_FLOAT2INT=336,
ENC_FCVTAS_64D_FLOAT2INT=337,
ENC_FCVTAS_64H_FLOAT2INT=338,
ENC_FCVTAS_64S_FLOAT2INT=339,
ENC_FCVTAS_ASIMDMISC_R=340,
ENC_FCVTAS_ASIMDMISCFP16_R=341,
ENC_FCVTAS_ASISDMISC_R=342,
ENC_FCVTAS_ASISDMISCFP16_R=343,
ENC_FCVTAU_32D_FLOAT2INT=344,
ENC_FCVTAU_32H_FLOAT2INT=345,
ENC_FCVTAU_32S_FLOAT2INT=346,
ENC_FCVTAU_64D_FLOAT2INT=347,
ENC_FCVTAU_64H_FLOAT2INT=348,
ENC_FCVTAU_64S_FLOAT2INT=349,
ENC_FCVTAU_ASIMDMISC_R=350,
ENC_FCVTAU_ASIMDMISCFP16_R=351,
ENC_FCVTAU_ASISDMISC_R=352,
ENC_FCVTAU_ASISDMISCFP16_R=353,
ENC_FCVTL_ASIMDMISC_L=354,
ENC_FCVTMS_32D_FLOAT2INT=355,
ENC_FCVTMS_32H_FLOAT2INT=356,
ENC_FCVTMS_32S_FLOAT2INT=357,
ENC_FCVTMS_64D_FLOAT2INT=358,
ENC_FCVTMS_64H_FLOAT2INT=359,
ENC_FCVTMS_64S_FLOAT2INT=360,
ENC_FCVTMS_ASIMDMISC_R=361,
ENC_FCVTMS_ASIMDMISCFP16_R=362,
ENC_FCVTMS_ASISDMISC_R=363,
ENC_FCVTMS_ASISDMISCFP16_R=364,
ENC_FCVTMU_32D_FLOAT2INT=365,
ENC_FCVTMU_32H_FLOAT2INT=366,
ENC_FCVTMU_32S_FLOAT2INT=367,
ENC_FCVTMU_64D_FLOAT2INT=368,
ENC_FCVTMU_64H_FLOAT2INT=369,
ENC_FCVTMU_64S_FLOAT2INT=370,
ENC_FCVTMU_ASIMDMISC_R=371,
ENC_FCVTMU_ASIMDMISCFP16_R=372,
ENC_FCVTMU_ASISDMISC_R=373,
ENC_FCVTMU_ASISDMISCFP16_R=374,
ENC_FCVTNS_32D_FLOAT2INT=375,
ENC_FCVTNS_32H_FLOAT2INT=376,
ENC_FCVTNS_32S_FLOAT2INT=377,
ENC_FCVTNS_64D_FLOAT2INT=378,
ENC_FCVTNS_64H_FLOAT2INT=379,
ENC_FCVTNS_64S_FLOAT2INT=380,
ENC_FCVTNS_ASIMDMISC_R=381,
ENC_FCVTNS_ASIMDMISCFP16_R=382,
ENC_FCVTNS_ASISDMISC_R=383,
ENC_FCVTNS_ASISDMISCFP16_R=384,
ENC_FCVTNU_32D_FLOAT2INT=385,
ENC_FCVTNU_32H_FLOAT2INT=386,
ENC_FCVTNU_32S_FLOAT2INT=387,
ENC_FCVTNU_64D_FLOAT2INT=388,
ENC_FCVTNU_64H_FLOAT2INT=389,
ENC_FCVTNU_64S_FLOAT2INT=390,
ENC_FCVTNU_ASIMDMISC_R=391,
ENC_FCVTNU_ASIMDMISCFP16_R=392,
ENC_FCVTNU_ASISDMISC_R=393,
ENC_FCVTNU_ASISDMISCFP16_R=394,
ENC_FCVTN_ASIMDMISC_N=395,
ENC_FCVTPS_32D_FLOAT2INT=396,
ENC_FCVTPS_32H_FLOAT2INT=397,
ENC_FCVTPS_32S_FLOAT2INT=398,
ENC_FCVTPS_64D_FLOAT2INT=399,
ENC_FCVTPS_64H_FLOAT2INT=400,
ENC_FCVTPS_64S_FLOAT2INT=401,
ENC_FCVTPS_ASIMDMISC_R=402,
ENC_FCVTPS_ASIMDMISCFP16_R=403,
ENC_FCVTPS_ASISDMISC_R=404,
ENC_FCVTPS_ASISDMISCFP16_R=405,
ENC_FCVTPU_32D_FLOAT2INT=406,
ENC_FCVTPU_32H_FLOAT2INT=407,
ENC_FCVTPU_32S_FLOAT2INT=408,
ENC_FCVTPU_64D_FLOAT2INT=409,
ENC_FCVTPU_64H_FLOAT2INT=410,
ENC_FCVTPU_64S_FLOAT2INT=411,
ENC_FCVTPU_ASIMDMISC_R=412,
ENC_FCVTPU_ASIMDMISCFP16_R=413,
ENC_FCVTPU_ASISDMISC_R=414,
ENC_FCVTPU_ASISDMISCFP16_R=415,
ENC_FCVTXN_ASIMDMISC_N=416,
ENC_FCVTXN_ASISDMISC_N=417,
ENC_FCVTZS_32D_FLOAT2FIX=418,
ENC_FCVTZS_32D_FLOAT2INT=419,
ENC_FCVTZS_32H_FLOAT2FIX=420,
ENC_FCVTZS_32H_FLOAT2INT=421,
ENC_FCVTZS_32S_FLOAT2FIX=422,
ENC_FCVTZS_32S_FLOAT2INT=423,
ENC_FCVTZS_64D_FLOAT2FIX=424,
ENC_FCVTZS_64D_FLOAT2INT=425,
ENC_FCVTZS_64H_FLOAT2FIX=426,
ENC_FCVTZS_64H_FLOAT2INT=427,
ENC_FCVTZS_64S_FLOAT2FIX=428,
ENC_FCVTZS_64S_FLOAT2INT=429,
ENC_FCVTZS_ASIMDMISC_R=430,
ENC_FCVTZS_ASIMDMISCFP16_R=431,
ENC_FCVTZS_ASIMDSHF_C=432,
ENC_FCVTZS_ASISDMISC_R=433,
ENC_FCVTZS_ASISDMISCFP16_R=434,
ENC_FCVTZS_ASISDSHF_C=435,
ENC_FCVTZU_32D_FLOAT2FIX=436,
ENC_FCVTZU_32D_FLOAT2INT=437,
ENC_FCVTZU_32H_FLOAT2FIX=438,
ENC_FCVTZU_32H_FLOAT2INT=439,
ENC_FCVTZU_32S_FLOAT2FIX=440,
ENC_FCVTZU_32S_FLOAT2INT=441,
ENC_FCVTZU_64D_FLOAT2FIX=442,
ENC_FCVTZU_64D_FLOAT2INT=443,
ENC_FCVTZU_64H_FLOAT2FIX=444,
ENC_FCVTZU_64H_FLOAT2INT=445,
ENC_FCVTZU_64S_FLOAT2FIX=446,
ENC_FCVTZU_64S_FLOAT2INT=447,
ENC_FCVTZU_ASIMDMISC_R=448,
ENC_FCVTZU_ASIMDMISCFP16_R=449,
ENC_FCVTZU_ASIMDSHF_C=450,
ENC_FCVTZU_ASISDMISC_R=451,
ENC_FCVTZU_ASISDMISCFP16_R=452,
ENC_FCVTZU_ASISDSHF_C=453,
ENC_FCVT_DH_FLOATDP1=454,
ENC_FCVT_DS_FLOATDP1=455,
ENC_FCVT_HD_FLOATDP1=456,
ENC_FCVT_HS_FLOATDP1=457,
ENC_FCVT_SD_FLOATDP1=458,
ENC_FCVT_SH_FLOATDP1=459,
ENC_FDIV_D_FLOATDP2=460,
ENC_FDIV_H_FLOATDP2=461,
ENC_FDIV_S_FLOATDP2=462,
ENC_FDIV_ASIMDSAME_ONLY=463,
ENC_FDIV_ASIMDSAMEFP16_ONLY=464,
ENC_FJCVTZS_32D_FLOAT2INT=465,
ENC_FMADD_D_FLOATDP3=466,
ENC_FMADD_H_FLOATDP3=467,
ENC_FMADD_S_FLOATDP3=468,
ENC_FMAXNMP_ASIMDSAME_ONLY=469,
ENC_FMAXNMP_ASIMDSAMEFP16_ONLY=470,
ENC_FMAXNMP_ASISDPAIR_ONLY_H=471,
ENC_FMAXNMP_ASISDPAIR_ONLY_SD=472,
ENC_FMAXNMV_ASIMDALL_ONLY_H=473,
ENC_FMAXNMV_ASIMDALL_ONLY_SD=474,
ENC_FMAXNM_D_FLOATDP2=475,
ENC_FMAXNM_H_FLOATDP2=476,
ENC_FMAXNM_S_FLOATDP2=477,
ENC_FMAXNM_ASIMDSAME_ONLY=478,
ENC_FMAXNM_ASIMDSAMEFP16_ONLY=479,
ENC_FMAXP_ASIMDSAME_ONLY=480,
ENC_FMAXP_ASIMDSAMEFP16_ONLY=481,
ENC_FMAXP_ASISDPAIR_ONLY_H=482,
ENC_FMAXP_ASISDPAIR_ONLY_SD=483,
ENC_FMAXV_ASIMDALL_ONLY_H=484,
ENC_FMAXV_ASIMDALL_ONLY_SD=485,
ENC_FMAX_D_FLOATDP2=486,
ENC_FMAX_H_FLOATDP2=487,
ENC_FMAX_S_FLOATDP2=488,
ENC_FMAX_ASIMDSAME_ONLY=489,
ENC_FMAX_ASIMDSAMEFP16_ONLY=490,
ENC_FMINNMP_ASIMDSAME_ONLY=491,
ENC_FMINNMP_ASIMDSAMEFP16_ONLY=492,
ENC_FMINNMP_ASISDPAIR_ONLY_H=493,
ENC_FMINNMP_ASISDPAIR_ONLY_SD=494,
ENC_FMINNMV_ASIMDALL_ONLY_H=495,
ENC_FMINNMV_ASIMDALL_ONLY_SD=496,
ENC_FMINNM_D_FLOATDP2=497,
ENC_FMINNM_H_FLOATDP2=498,
ENC_FMINNM_S_FLOATDP2=499,
ENC_FMINNM_ASIMDSAME_ONLY=500,
ENC_FMINNM_ASIMDSAMEFP16_ONLY=501,
ENC_FMINP_ASIMDSAME_ONLY=502,
ENC_FMINP_ASIMDSAMEFP16_ONLY=503,
ENC_FMINP_ASISDPAIR_ONLY_H=504,
ENC_FMINP_ASISDPAIR_ONLY_SD=505,
ENC_FMINV_ASIMDALL_ONLY_H=506,
ENC_FMINV_ASIMDALL_ONLY_SD=507,
ENC_FMIN_D_FLOATDP2=508,
ENC_FMIN_H_FLOATDP2=509,
ENC_FMIN_S_FLOATDP2=510,
ENC_FMIN_ASIMDSAME_ONLY=511,
ENC_FMIN_ASIMDSAMEFP16_ONLY=512,
ENC_FMLAL2_ASIMDELEM_LH=513,
ENC_FMLAL2_ASIMDSAME_F=514,
ENC_FMLAL_ASIMDELEM_LH=515,
ENC_FMLAL_ASIMDSAME_F=516,
ENC_FMLA_ASIMDELEM_RH_H=517,
ENC_FMLA_ASIMDELEM_R_SD=518,
ENC_FMLA_ASIMDSAME_ONLY=519,
ENC_FMLA_ASIMDSAMEFP16_ONLY=520,
ENC_FMLA_ASISDELEM_RH_H=521,
ENC_FMLA_ASISDELEM_R_SD=522,
ENC_FMLSL2_ASIMDELEM_LH=523,
ENC_FMLSL2_ASIMDSAME_F=524,
ENC_FMLSL_ASIMDELEM_LH=525,
ENC_FMLSL_ASIMDSAME_F=526,
ENC_FMLS_ASIMDELEM_RH_H=527,
ENC_FMLS_ASIMDELEM_R_SD=528,
ENC_FMLS_ASIMDSAME_ONLY=529,
ENC_FMLS_ASIMDSAMEFP16_ONLY=530,
ENC_FMLS_ASISDELEM_RH_H=531,
ENC_FMLS_ASISDELEM_R_SD=532,
ENC_FMOV_32H_FLOAT2INT=533,
ENC_FMOV_32S_FLOAT2INT=534,
ENC_FMOV_64D_FLOAT2INT=535,
ENC_FMOV_64H_FLOAT2INT=536,
ENC_FMOV_64VX_FLOAT2INT=537,
ENC_FMOV_D64_FLOAT2INT=538,
ENC_FMOV_D_FLOATDP1=539,
ENC_FMOV_D_FLOATIMM=540,
ENC_FMOV_H32_FLOAT2INT=541,
ENC_FMOV_H64_FLOAT2INT=542,
ENC_FMOV_H_FLOATDP1=543,
ENC_FMOV_H_FLOATIMM=544,
ENC_FMOV_S32_FLOAT2INT=545,
ENC_FMOV_S_FLOATDP1=546,
ENC_FMOV_S_FLOATIMM=547,
ENC_FMOV_V64I_FLOAT2INT=548,
ENC_FMOV_ASIMDIMM_D2_D=549,
ENC_FMOV_ASIMDIMM_H_H=550,
ENC_FMOV_ASIMDIMM_S_S=551,
ENC_FMOV_CPY_Z_P_I_=552,
ENC_FMOV_DUP_Z_I_=553,
ENC_FMOV_FCPY_Z_P_I_=554,
ENC_FMOV_FDUP_Z_I_=555,
ENC_FMSUB_D_FLOATDP3=556,
ENC_FMSUB_H_FLOATDP3=557,
ENC_FMSUB_S_FLOATDP3=558,
ENC_FMULX_ASIMDELEM_RH_H=559,
ENC_FMULX_ASIMDELEM_R_SD=560,
ENC_FMULX_ASIMDSAME_ONLY=561,
ENC_FMULX_ASIMDSAMEFP16_ONLY=562,
ENC_FMULX_ASISDELEM_RH_H=563,
ENC_FMULX_ASISDELEM_R_SD=564,
ENC_FMULX_ASISDSAME_ONLY=565,
ENC_FMULX_ASISDSAMEFP16_ONLY=566,
ENC_FMUL_D_FLOATDP2=567,
ENC_FMUL_H_FLOATDP2=568,
ENC_FMUL_S_FLOATDP2=569,
ENC_FMUL_ASIMDELEM_RH_H=570,
ENC_FMUL_ASIMDELEM_R_SD=571,
ENC_FMUL_ASIMDSAME_ONLY=572,
ENC_FMUL_ASIMDSAMEFP16_ONLY=573,
ENC_FMUL_ASISDELEM_RH_H=574,
ENC_FMUL_ASISDELEM_R_SD=575,
ENC_FNEG_D_FLOATDP1=576,
ENC_FNEG_H_FLOATDP1=577,
ENC_FNEG_S_FLOATDP1=578,
ENC_FNEG_ASIMDMISC_R=579,
ENC_FNEG_ASIMDMISCFP16_R=580,
ENC_FNMADD_D_FLOATDP3=581,
ENC_FNMADD_H_FLOATDP3=582,
ENC_FNMADD_S_FLOATDP3=583,
ENC_FNMSUB_D_FLOATDP3=584,
ENC_FNMSUB_H_FLOATDP3=585,
ENC_FNMSUB_S_FLOATDP3=586,
ENC_FNMUL_D_FLOATDP2=587,
ENC_FNMUL_H_FLOATDP2=588,
ENC_FNMUL_S_FLOATDP2=589,
ENC_FRECPE_ASIMDMISC_R=590,
ENC_FRECPE_ASIMDMISCFP16_R=591,
ENC_FRECPE_ASISDMISC_R=592,
ENC_FRECPE_ASISDMISCFP16_R=593,
ENC_FRECPS_ASIMDSAME_ONLY=594,
ENC_FRECPS_ASIMDSAMEFP16_ONLY=595,
ENC_FRECPS_ASISDSAME_ONLY=596,
ENC_FRECPS_ASISDSAMEFP16_ONLY=597,
ENC_FRECPX_ASISDMISC_R=598,
ENC_FRECPX_ASISDMISCFP16_R=599,
ENC_FRINT32X_D_FLOATDP1=600,
ENC_FRINT32X_S_FLOATDP1=601,
ENC_FRINT32X_ASIMDMISC_R=602,
ENC_FRINT32Z_D_FLOATDP1=603,
ENC_FRINT32Z_S_FLOATDP1=604,
ENC_FRINT32Z_ASIMDMISC_R=605,
ENC_FRINT64X_D_FLOATDP1=606,
ENC_FRINT64X_S_FLOATDP1=607,
ENC_FRINT64X_ASIMDMISC_R=608,
ENC_FRINT64Z_D_FLOATDP1=609,
ENC_FRINT64Z_S_FLOATDP1=610,
ENC_FRINT64Z_ASIMDMISC_R=611,
ENC_FRINTA_D_FLOATDP1=612,
ENC_FRINTA_H_FLOATDP1=613,
ENC_FRINTA_S_FLOATDP1=614,
ENC_FRINTA_ASIMDMISC_R=615,
ENC_FRINTA_ASIMDMISCFP16_R=616,
ENC_FRINTI_D_FLOATDP1=617,
ENC_FRINTI_H_FLOATDP1=618,
ENC_FRINTI_S_FLOATDP1=619,
ENC_FRINTI_ASIMDMISC_R=620,
ENC_FRINTI_ASIMDMISCFP16_R=621,
ENC_FRINTM_D_FLOATDP1=622,
ENC_FRINTM_H_FLOATDP1=623,
ENC_FRINTM_S_FLOATDP1=624,
ENC_FRINTM_ASIMDMISC_R=625,
ENC_FRINTM_ASIMDMISCFP16_R=626,
ENC_FRINTN_D_FLOATDP1=627,
ENC_FRINTN_H_FLOATDP1=628,
ENC_FRINTN_S_FLOATDP1=629,
ENC_FRINTN_ASIMDMISC_R=630,
ENC_FRINTN_ASIMDMISCFP16_R=631,
ENC_FRINTP_D_FLOATDP1=632,
ENC_FRINTP_H_FLOATDP1=633,
ENC_FRINTP_S_FLOATDP1=634,
ENC_FRINTP_ASIMDMISC_R=635,
ENC_FRINTP_ASIMDMISCFP16_R=636,
ENC_FRINTX_D_FLOATDP1=637,
ENC_FRINTX_H_FLOATDP1=638,
ENC_FRINTX_S_FLOATDP1=639,
ENC_FRINTX_ASIMDMISC_R=640,
ENC_FRINTX_ASIMDMISCFP16_R=641,
ENC_FRINTZ_D_FLOATDP1=642,
ENC_FRINTZ_H_FLOATDP1=643,
ENC_FRINTZ_S_FLOATDP1=644,
ENC_FRINTZ_ASIMDMISC_R=645,
ENC_FRINTZ_ASIMDMISCFP16_R=646,
ENC_FRSQRTE_ASIMDMISC_R=647,
ENC_FRSQRTE_ASIMDMISCFP16_R=648,
ENC_FRSQRTE_ASISDMISC_R=649,
ENC_FRSQRTE_ASISDMISCFP16_R=650,
ENC_FRSQRTS_ASIMDSAME_ONLY=651,
ENC_FRSQRTS_ASIMDSAMEFP16_ONLY=652,
ENC_FRSQRTS_ASISDSAME_ONLY=653,
ENC_FRSQRTS_ASISDSAMEFP16_ONLY=654,
ENC_FSQRT_D_FLOATDP1=655,
ENC_FSQRT_H_FLOATDP1=656,
ENC_FSQRT_S_FLOATDP1=657,
ENC_FSQRT_ASIMDMISC_R=658,
ENC_FSQRT_ASIMDMISCFP16_R=659,
ENC_FSUB_D_FLOATDP2=660,
ENC_FSUB_H_FLOATDP2=661,
ENC_FSUB_S_FLOATDP2=662,
ENC_FSUB_ASIMDSAME_ONLY=663,
ENC_FSUB_ASIMDSAMEFP16_ONLY=664,
ENC_GMI_64G_DP_2SRC=665,
ENC_HINT_HM_HINTS=666,
ENC_HLT_EX_EXCEPTION=667,
ENC_HVC_EX_EXCEPTION=668,
ENC_IC_SYS_CR_SYSTEMINSTRS=669,
ENC_INS_ASIMDINS_IR_R=670,
ENC_INS_ASIMDINS_IV_V=671,
ENC_IRG_64I_DP_2SRC=672,
ENC_ISB_BI_BARRIERS=673,
ENC_LD1R_ASISDLSO_R1=674,
ENC_LD1R_ASISDLSOP_R1_I=675,
ENC_LD1R_ASISDLSOP_RX1_R=676,
ENC_LD1_ASISDLSE_R1_1V=677,
ENC_LD1_ASISDLSE_R2_2V=678,
ENC_LD1_ASISDLSE_R3_3V=679,
ENC_LD1_ASISDLSE_R4_4V=680,
ENC_LD1_ASISDLSEP_I1_I1=681,
ENC_LD1_ASISDLSEP_I2_I2=682,
ENC_LD1_ASISDLSEP_I3_I3=683,
ENC_LD1_ASISDLSEP_I4_I4=684,
ENC_LD1_ASISDLSEP_R1_R1=685,
ENC_LD1_ASISDLSEP_R2_R2=686,
ENC_LD1_ASISDLSEP_R3_R3=687,
ENC_LD1_ASISDLSEP_R4_R4=688,
ENC_LD1_ASISDLSO_B1_1B=689,
ENC_LD1_ASISDLSO_D1_1D=690,
ENC_LD1_ASISDLSO_H1_1H=691,
ENC_LD1_ASISDLSO_S1_1S=692,
ENC_LD1_ASISDLSOP_B1_I1B=693,
ENC_LD1_ASISDLSOP_BX1_R1B=694,
ENC_LD1_ASISDLSOP_D1_I1D=695,
ENC_LD1_ASISDLSOP_DX1_R1D=696,
ENC_LD1_ASISDLSOP_H1_I1H=697,
ENC_LD1_ASISDLSOP_HX1_R1H=698,
ENC_LD1_ASISDLSOP_S1_I1S=699,
ENC_LD1_ASISDLSOP_SX1_R1S=700,
ENC_LD2R_ASISDLSO_R2=701,
ENC_LD2R_ASISDLSOP_R2_I=702,
ENC_LD2R_ASISDLSOP_RX2_R=703,
ENC_LD2_ASISDLSE_R2=704,
ENC_LD2_ASISDLSEP_I2_I=705,
ENC_LD2_ASISDLSEP_R2_R=706,
ENC_LD2_ASISDLSO_B2_2B=707,
ENC_LD2_ASISDLSO_D2_2D=708,
ENC_LD2_ASISDLSO_H2_2H=709,
ENC_LD2_ASISDLSO_S2_2S=710,
ENC_LD2_ASISDLSOP_B2_I2B=711,
ENC_LD2_ASISDLSOP_BX2_R2B=712,
ENC_LD2_ASISDLSOP_D2_I2D=713,
ENC_LD2_ASISDLSOP_DX2_R2D=714,
ENC_LD2_ASISDLSOP_H2_I2H=715,
ENC_LD2_ASISDLSOP_HX2_R2H=716,
ENC_LD2_ASISDLSOP_S2_I2S=717,
ENC_LD2_ASISDLSOP_SX2_R2S=718,
ENC_LD3R_ASISDLSO_R3=719,
ENC_LD3R_ASISDLSOP_R3_I=720,
ENC_LD3R_ASISDLSOP_RX3_R=721,
ENC_LD3_ASISDLSE_R3=722,
ENC_LD3_ASISDLSEP_I3_I=723,
ENC_LD3_ASISDLSEP_R3_R=724,
ENC_LD3_ASISDLSO_B3_3B=725,
ENC_LD3_ASISDLSO_D3_3D=726,
ENC_LD3_ASISDLSO_H3_3H=727,
ENC_LD3_ASISDLSO_S3_3S=728,
ENC_LD3_ASISDLSOP_B3_I3B=729,
ENC_LD3_ASISDLSOP_BX3_R3B=730,
ENC_LD3_ASISDLSOP_D3_I3D=731,
ENC_LD3_ASISDLSOP_DX3_R3D=732,
ENC_LD3_ASISDLSOP_H3_I3H=733,
ENC_LD3_ASISDLSOP_HX3_R3H=734,
ENC_LD3_ASISDLSOP_S3_I3S=735,
ENC_LD3_ASISDLSOP_SX3_R3S=736,
ENC_LD4R_ASISDLSO_R4=737,
ENC_LD4R_ASISDLSOP_R4_I=738,
ENC_LD4R_ASISDLSOP_RX4_R=739,
ENC_LD4_ASISDLSE_R4=740,
ENC_LD4_ASISDLSEP_I4_I=741,
ENC_LD4_ASISDLSEP_R4_R=742,
ENC_LD4_ASISDLSO_B4_4B=743,
ENC_LD4_ASISDLSO_D4_4D=744,
ENC_LD4_ASISDLSO_H4_4H=745,
ENC_LD4_ASISDLSO_S4_4S=746,
ENC_LD4_ASISDLSOP_B4_I4B=747,
ENC_LD4_ASISDLSOP_BX4_R4B=748,
ENC_LD4_ASISDLSOP_D4_I4D=749,
ENC_LD4_ASISDLSOP_DX4_R4D=750,
ENC_LD4_ASISDLSOP_H4_I4H=751,
ENC_LD4_ASISDLSOP_HX4_R4H=752,
ENC_LD4_ASISDLSOP_S4_I4S=753,
ENC_LD4_ASISDLSOP_SX4_R4S=754,
ENC_LD64B_64L_MEMOP=755,
ENC_LDADDAB_32_MEMOP=756,
ENC_LDADDAH_32_MEMOP=757,
ENC_LDADDALB_32_MEMOP=758,
ENC_LDADDALH_32_MEMOP=759,
ENC_LDADDAL_32_MEMOP=760,
ENC_LDADDAL_64_MEMOP=761,
ENC_LDADDA_32_MEMOP=762,
ENC_LDADDA_64_MEMOP=763,
ENC_LDADDB_32_MEMOP=764,
ENC_LDADDH_32_MEMOP=765,
ENC_LDADDLB_32_MEMOP=766,
ENC_LDADDLH_32_MEMOP=767,
ENC_LDADDL_32_MEMOP=768,
ENC_LDADDL_64_MEMOP=769,
ENC_LDADD_32_MEMOP=770,
ENC_LDADD_64_MEMOP=771,
ENC_LDAPRB_32L_MEMOP=772,
ENC_LDAPRH_32L_MEMOP=773,
ENC_LDAPR_32L_MEMOP=774,
ENC_LDAPR_64L_MEMOP=775,
ENC_LDAPURB_32_LDAPSTL_UNSCALED=776,
ENC_LDAPURH_32_LDAPSTL_UNSCALED=777,
ENC_LDAPURSB_32_LDAPSTL_UNSCALED=778,
ENC_LDAPURSB_64_LDAPSTL_UNSCALED=779,
ENC_LDAPURSH_32_LDAPSTL_UNSCALED=780,
ENC_LDAPURSH_64_LDAPSTL_UNSCALED=781,
ENC_LDAPURSW_64_LDAPSTL_UNSCALED=782,
ENC_LDAPUR_32_LDAPSTL_UNSCALED=783,
ENC_LDAPUR_64_LDAPSTL_UNSCALED=784,
ENC_LDARB_LR32_LDSTORD=785,
ENC_LDARH_LR32_LDSTORD=786,
ENC_LDAR_LR32_LDSTORD=787,
ENC_LDAR_LR64_LDSTORD=788,
ENC_LDAXP_LP32_LDSTEXCLP=789,
ENC_LDAXP_LP64_LDSTEXCLP=790,
ENC_LDAXRB_LR32_LDSTEXCLR=791,
ENC_LDAXRH_LR32_LDSTEXCLR=792,
ENC_LDAXR_LR32_LDSTEXCLR=793,
ENC_LDAXR_LR64_LDSTEXCLR=794,
ENC_LDCLRAB_32_MEMOP=795,
ENC_LDCLRAH_32_MEMOP=796,
ENC_LDCLRALB_32_MEMOP=797,
ENC_LDCLRALH_32_MEMOP=798,
ENC_LDCLRAL_32_MEMOP=799,
ENC_LDCLRAL_64_MEMOP=800,
ENC_LDCLRA_32_MEMOP=801,
ENC_LDCLRA_64_MEMOP=802,
ENC_LDCLRB_32_MEMOP=803,
ENC_LDCLRH_32_MEMOP=804,
ENC_LDCLRLB_32_MEMOP=805,
ENC_LDCLRLH_32_MEMOP=806,
ENC_LDCLRL_32_MEMOP=807,
ENC_LDCLRL_64_MEMOP=808,
ENC_LDCLR_32_MEMOP=809,
ENC_LDCLR_64_MEMOP=810,
ENC_LDEORAB_32_MEMOP=811,
ENC_LDEORAH_32_MEMOP=812,
ENC_LDEORALB_32_MEMOP=813,
ENC_LDEORALH_32_MEMOP=814,
ENC_LDEORAL_32_MEMOP=815,
ENC_LDEORAL_64_MEMOP=816,
ENC_LDEORA_32_MEMOP=817,
ENC_LDEORA_64_MEMOP=818,
ENC_LDEORB_32_MEMOP=819,
ENC_LDEORH_32_MEMOP=820,
ENC_LDEORLB_32_MEMOP=821,
ENC_LDEORLH_32_MEMOP=822,
ENC_LDEORL_32_MEMOP=823,
ENC_LDEORL_64_MEMOP=824,
ENC_LDEOR_32_MEMOP=825,
ENC_LDEOR_64_MEMOP=826,
ENC_LDGM_64BULK_LDSTTAGS=827,
ENC_LDG_64LOFFSET_LDSTTAGS=828,
ENC_LDLARB_LR32_LDSTORD=829,
ENC_LDLARH_LR32_LDSTORD=830,
ENC_LDLAR_LR32_LDSTORD=831,
ENC_LDLAR_LR64_LDSTORD=832,
ENC_LDNP_32_LDSTNAPAIR_OFFS=833,
ENC_LDNP_64_LDSTNAPAIR_OFFS=834,
ENC_LDNP_D_LDSTNAPAIR_OFFS=835,
ENC_LDNP_Q_LDSTNAPAIR_OFFS=836,
ENC_LDNP_S_LDSTNAPAIR_OFFS=837,
ENC_LDPSW_64_LDSTPAIR_OFF=838,
ENC_LDPSW_64_LDSTPAIR_POST=839,
ENC_LDPSW_64_LDSTPAIR_PRE=840,
ENC_LDP_32_LDSTPAIR_OFF=841,
ENC_LDP_32_LDSTPAIR_POST=842,
ENC_LDP_32_LDSTPAIR_PRE=843,
ENC_LDP_64_LDSTPAIR_OFF=844,
ENC_LDP_64_LDSTPAIR_POST=845,
ENC_LDP_64_LDSTPAIR_PRE=846,
ENC_LDP_D_LDSTPAIR_OFF=847,
ENC_LDP_D_LDSTPAIR_POST=848,
ENC_LDP_D_LDSTPAIR_PRE=849,
ENC_LDP_Q_LDSTPAIR_OFF=850,
ENC_LDP_Q_LDSTPAIR_POST=851,
ENC_LDP_Q_LDSTPAIR_PRE=852,
ENC_LDP_S_LDSTPAIR_OFF=853,
ENC_LDP_S_LDSTPAIR_POST=854,
ENC_LDP_S_LDSTPAIR_PRE=855,
ENC_LDRAA_64W_LDST_PAC=856,
ENC_LDRAA_64_LDST_PAC=857,
ENC_LDRAB_64W_LDST_PAC=858,
ENC_LDRAB_64_LDST_PAC=859,
ENC_LDRB_32BL_LDST_REGOFF=860,
ENC_LDRB_32B_LDST_REGOFF=861,
ENC_LDRB_32_LDST_IMMPOST=862,
ENC_LDRB_32_LDST_IMMPRE=863,
ENC_LDRB_32_LDST_POS=864,
ENC_LDRH_32_LDST_IMMPOST=865,
ENC_LDRH_32_LDST_IMMPRE=866,
ENC_LDRH_32_LDST_POS=867,
ENC_LDRH_32_LDST_REGOFF=868,
ENC_LDRSB_32BL_LDST_REGOFF=869,
ENC_LDRSB_32B_LDST_REGOFF=870,
ENC_LDRSB_32_LDST_IMMPOST=871,
ENC_LDRSB_32_LDST_IMMPRE=872,
ENC_LDRSB_32_LDST_POS=873,
ENC_LDRSB_64BL_LDST_REGOFF=874,
ENC_LDRSB_64B_LDST_REGOFF=875,
ENC_LDRSB_64_LDST_IMMPOST=876,
ENC_LDRSB_64_LDST_IMMPRE=877,
ENC_LDRSB_64_LDST_POS=878,
ENC_LDRSH_32_LDST_IMMPOST=879,
ENC_LDRSH_32_LDST_IMMPRE=880,
ENC_LDRSH_32_LDST_POS=881,
ENC_LDRSH_32_LDST_REGOFF=882,
ENC_LDRSH_64_LDST_IMMPOST=883,
ENC_LDRSH_64_LDST_IMMPRE=884,
ENC_LDRSH_64_LDST_POS=885,
ENC_LDRSH_64_LDST_REGOFF=886,
ENC_LDRSW_64_LDST_IMMPOST=887,
ENC_LDRSW_64_LDST_IMMPRE=888,
ENC_LDRSW_64_LDST_POS=889,
ENC_LDRSW_64_LDST_REGOFF=890,
ENC_LDRSW_64_LOADLIT=891,
ENC_LDR_32_LDST_IMMPOST=892,
ENC_LDR_32_LDST_IMMPRE=893,
ENC_LDR_32_LDST_POS=894,
ENC_LDR_32_LDST_REGOFF=895,
ENC_LDR_32_LOADLIT=896,
ENC_LDR_64_LDST_IMMPOST=897,
ENC_LDR_64_LDST_IMMPRE=898,
ENC_LDR_64_LDST_POS=899,
ENC_LDR_64_LDST_REGOFF=900,
ENC_LDR_64_LOADLIT=901,
ENC_LDR_BL_LDST_REGOFF=902,
ENC_LDR_B_LDST_IMMPOST=903,
ENC_LDR_B_LDST_IMMPRE=904,
ENC_LDR_B_LDST_POS=905,
ENC_LDR_B_LDST_REGOFF=906,
ENC_LDR_D_LDST_IMMPOST=907,
ENC_LDR_D_LDST_IMMPRE=908,
ENC_LDR_D_LDST_POS=909,
ENC_LDR_D_LDST_REGOFF=910,
ENC_LDR_D_LOADLIT=911,
ENC_LDR_H_LDST_IMMPOST=912,
ENC_LDR_H_LDST_IMMPRE=913,
ENC_LDR_H_LDST_POS=914,
ENC_LDR_H_LDST_REGOFF=915,
ENC_LDR_Q_LDST_IMMPOST=916,
ENC_LDR_Q_LDST_IMMPRE=917,
ENC_LDR_Q_LDST_POS=918,
ENC_LDR_Q_LDST_REGOFF=919,
ENC_LDR_Q_LOADLIT=920,
ENC_LDR_S_LDST_IMMPOST=921,
ENC_LDR_S_LDST_IMMPRE=922,
ENC_LDR_S_LDST_POS=923,
ENC_LDR_S_LDST_REGOFF=924,
ENC_LDR_S_LOADLIT=925,
ENC_LDSETAB_32_MEMOP=926,
ENC_LDSETAH_32_MEMOP=927,
ENC_LDSETALB_32_MEMOP=928,
ENC_LDSETALH_32_MEMOP=929,
ENC_LDSETAL_32_MEMOP=930,
ENC_LDSETAL_64_MEMOP=931,
ENC_LDSETA_32_MEMOP=932,
ENC_LDSETA_64_MEMOP=933,
ENC_LDSETB_32_MEMOP=934,
ENC_LDSETH_32_MEMOP=935,
ENC_LDSETLB_32_MEMOP=936,
ENC_LDSETLH_32_MEMOP=937,
ENC_LDSETL_32_MEMOP=938,
ENC_LDSETL_64_MEMOP=939,
ENC_LDSET_32_MEMOP=940,
ENC_LDSET_64_MEMOP=941,
ENC_LDSMAXAB_32_MEMOP=942,
ENC_LDSMAXAH_32_MEMOP=943,
ENC_LDSMAXALB_32_MEMOP=944,
ENC_LDSMAXALH_32_MEMOP=945,
ENC_LDSMAXAL_32_MEMOP=946,
ENC_LDSMAXAL_64_MEMOP=947,
ENC_LDSMAXA_32_MEMOP=948,
ENC_LDSMAXA_64_MEMOP=949,
ENC_LDSMAXB_32_MEMOP=950,
ENC_LDSMAXH_32_MEMOP=951,
ENC_LDSMAXLB_32_MEMOP=952,
ENC_LDSMAXLH_32_MEMOP=953,
ENC_LDSMAXL_32_MEMOP=954,
ENC_LDSMAXL_64_MEMOP=955,
ENC_LDSMAX_32_MEMOP=956,
ENC_LDSMAX_64_MEMOP=957,
ENC_LDSMINAB_32_MEMOP=958,
ENC_LDSMINAH_32_MEMOP=959,
ENC_LDSMINALB_32_MEMOP=960,
ENC_LDSMINALH_32_MEMOP=961,
ENC_LDSMINAL_32_MEMOP=962,
ENC_LDSMINAL_64_MEMOP=963,
ENC_LDSMINA_32_MEMOP=964,
ENC_LDSMINA_64_MEMOP=965,
ENC_LDSMINB_32_MEMOP=966,
ENC_LDSMINH_32_MEMOP=967,
ENC_LDSMINLB_32_MEMOP=968,
ENC_LDSMINLH_32_MEMOP=969,
ENC_LDSMINL_32_MEMOP=970,
ENC_LDSMINL_64_MEMOP=971,
ENC_LDSMIN_32_MEMOP=972,
ENC_LDSMIN_64_MEMOP=973,
ENC_LDTRB_32_LDST_UNPRIV=974,
ENC_LDTRH_32_LDST_UNPRIV=975,
ENC_LDTRSB_32_LDST_UNPRIV=976,
ENC_LDTRSB_64_LDST_UNPRIV=977,
ENC_LDTRSH_32_LDST_UNPRIV=978,
ENC_LDTRSH_64_LDST_UNPRIV=979,
ENC_LDTRSW_64_LDST_UNPRIV=980,
ENC_LDTR_32_LDST_UNPRIV=981,
ENC_LDTR_64_LDST_UNPRIV=982,
ENC_LDUMAXAB_32_MEMOP=983,
ENC_LDUMAXAH_32_MEMOP=984,
ENC_LDUMAXALB_32_MEMOP=985,
ENC_LDUMAXALH_32_MEMOP=986,
ENC_LDUMAXAL_32_MEMOP=987,
ENC_LDUMAXAL_64_MEMOP=988,
ENC_LDUMAXA_32_MEMOP=989,
ENC_LDUMAXA_64_MEMOP=990,
ENC_LDUMAXB_32_MEMOP=991,
ENC_LDUMAXH_32_MEMOP=992,
ENC_LDUMAXLB_32_MEMOP=993,
ENC_LDUMAXLH_32_MEMOP=994,
ENC_LDUMAXL_32_MEMOP=995,
ENC_LDUMAXL_64_MEMOP=996,
ENC_LDUMAX_32_MEMOP=997,
ENC_LDUMAX_64_MEMOP=998,
ENC_LDUMINAB_32_MEMOP=999,
ENC_LDUMINAH_32_MEMOP=1000,
ENC_LDUMINALB_32_MEMOP=1001,
ENC_LDUMINALH_32_MEMOP=1002,
ENC_LDUMINAL_32_MEMOP=1003,
ENC_LDUMINAL_64_MEMOP=1004,
ENC_LDUMINA_32_MEMOP=1005,
ENC_LDUMINA_64_MEMOP=1006,
ENC_LDUMINB_32_MEMOP=1007,
ENC_LDUMINH_32_MEMOP=1008,
ENC_LDUMINLB_32_MEMOP=1009,
ENC_LDUMINLH_32_MEMOP=1010,
ENC_LDUMINL_32_MEMOP=1011,
ENC_LDUMINL_64_MEMOP=1012,
ENC_LDUMIN_32_MEMOP=1013,
ENC_LDUMIN_64_MEMOP=1014,
ENC_LDURB_32_LDST_UNSCALED=1015,
ENC_LDURH_32_LDST_UNSCALED=1016,
ENC_LDURSB_32_LDST_UNSCALED=1017,
ENC_LDURSB_64_LDST_UNSCALED=1018,
ENC_LDURSH_32_LDST_UNSCALED=1019,
ENC_LDURSH_64_LDST_UNSCALED=1020,
ENC_LDURSW_64_LDST_UNSCALED=1021,
ENC_LDUR_32_LDST_UNSCALED=1022,
ENC_LDUR_64_LDST_UNSCALED=1023,
ENC_LDUR_B_LDST_UNSCALED=1024,
ENC_LDUR_D_LDST_UNSCALED=1025,
ENC_LDUR_H_LDST_UNSCALED=1026,
ENC_LDUR_Q_LDST_UNSCALED=1027,
ENC_LDUR_S_LDST_UNSCALED=1028,
ENC_LDXP_LP32_LDSTEXCLP=1029,
ENC_LDXP_LP64_LDSTEXCLP=1030,
ENC_LDXRB_LR32_LDSTEXCLR=1031,
ENC_LDXRH_LR32_LDSTEXCLR=1032,
ENC_LDXR_LR32_LDSTEXCLR=1033,
ENC_LDXR_LR64_LDSTEXCLR=1034,
ENC_LSLV_32_DP_2SRC=1035,
ENC_LSLV_64_DP_2SRC=1036,
ENC_LSL_LSLV_32_DP_2SRC=1037,
ENC_LSL_LSLV_64_DP_2SRC=1038,
ENC_LSL_UBFM_32M_BITFIELD=1039,
ENC_LSL_UBFM_64M_BITFIELD=1040,
ENC_LSRV_32_DP_2SRC=1041,
ENC_LSRV_64_DP_2SRC=1042,
ENC_LSR_LSRV_32_DP_2SRC=1043,
ENC_LSR_LSRV_64_DP_2SRC=1044,
ENC_LSR_UBFM_32M_BITFIELD=1045,
ENC_LSR_UBFM_64M_BITFIELD=1046,
ENC_MADD_32A_DP_3SRC=1047,
ENC_MADD_64A_DP_3SRC=1048,
ENC_MLA_ASIMDELEM_R=1049,
ENC_MLA_ASIMDSAME_ONLY=1050,
ENC_MLS_ASIMDELEM_R=1051,
ENC_MLS_ASIMDSAME_ONLY=1052,
ENC_MNEG_MSUB_32A_DP_3SRC=1053,
ENC_MNEG_MSUB_64A_DP_3SRC=1054,
ENC_MOVI_ASIMDIMM_D2_D=1055,
ENC_MOVI_ASIMDIMM_D_DS=1056,
ENC_MOVI_ASIMDIMM_L_HL=1057,
ENC_MOVI_ASIMDIMM_L_SL=1058,
ENC_MOVI_ASIMDIMM_M_SM=1059,
ENC_MOVI_ASIMDIMM_N_B=1060,
ENC_MOVK_32_MOVEWIDE=1061,
ENC_MOVK_64_MOVEWIDE=1062,
ENC_MOVN_32_MOVEWIDE=1063,
ENC_MOVN_64_MOVEWIDE=1064,
ENC_MOVS_ANDS_P_P_PP_Z=1065,
ENC_MOVS_ORRS_P_P_PP_Z=1066,
ENC_MOVZ_32_MOVEWIDE=1067,
ENC_MOVZ_64_MOVEWIDE=1068,
ENC_MOV_ADD_32_ADDSUB_IMM=1069,
ENC_MOV_ADD_64_ADDSUB_IMM=1070,
ENC_MOV_DUP_ASISDONE_ONLY=1071,
ENC_MOV_INS_ASIMDINS_IR_R=1072,
ENC_MOV_INS_ASIMDINS_IV_V=1073,
ENC_MOV_MOVN_32_MOVEWIDE=1074,
ENC_MOV_MOVN_64_MOVEWIDE=1075,
ENC_MOV_MOVZ_32_MOVEWIDE=1076,
ENC_MOV_MOVZ_64_MOVEWIDE=1077,
ENC_MOV_ORR_32_LOG_IMM=1078,
ENC_MOV_ORR_32_LOG_SHIFT=1079,
ENC_MOV_ORR_64_LOG_IMM=1080,
ENC_MOV_ORR_64_LOG_SHIFT=1081,
ENC_MOV_ORR_ASIMDSAME_ONLY=1082,
ENC_MOV_UMOV_ASIMDINS_W_W=1083,
ENC_MOV_UMOV_ASIMDINS_X_X=1084,
ENC_MOV_AND_P_P_PP_Z=1085,
ENC_MOV_CPY_Z_O_I_=1086,
ENC_MOV_CPY_Z_P_I_=1087,
ENC_MOV_CPY_Z_P_R_=1088,
ENC_MOV_CPY_Z_P_V_=1089,
ENC_MOV_DUP_Z_I_=1090,
ENC_MOV_DUP_Z_R_=1091,
ENC_MOV_DUP_Z_ZI_=1092,
ENC_MOV_DUP_Z_ZI_2=1093,
ENC_MOV_DUPM_Z_I_=1094,
ENC_MOV_ORR_P_P_PP_Z=1095,
ENC_MOV_ORR_Z_ZZ_=1096,
ENC_MOV_SEL_P_P_PP_=1097,
ENC_MOV_SEL_Z_P_ZZ_=1098,
ENC_MRS_RS_SYSTEMMOVE=1099,
ENC_MSR_SI_PSTATE=1100,
ENC_MSR_SR_SYSTEMMOVE=1101,
ENC_MSUB_32A_DP_3SRC=1102,
ENC_MSUB_64A_DP_3SRC=1103,
ENC_MUL_MADD_32A_DP_3SRC=1104,
ENC_MUL_MADD_64A_DP_3SRC=1105,
ENC_MUL_ASIMDELEM_R=1106,
ENC_MUL_ASIMDSAME_ONLY=1107,
ENC_MVNI_ASIMDIMM_L_HL=1108,
ENC_MVNI_ASIMDIMM_L_SL=1109,
ENC_MVNI_ASIMDIMM_M_SM=1110,
ENC_MVN_NOT_ASIMDMISC_R=1111,
ENC_MVN_ORN_32_LOG_SHIFT=1112,
ENC_MVN_ORN_64_LOG_SHIFT=1113,
ENC_NEGS_SUBS_32_ADDSUB_SHIFT=1114,
ENC_NEGS_SUBS_64_ADDSUB_SHIFT=1115,
ENC_NEG_SUB_32_ADDSUB_SHIFT=1116,
ENC_NEG_SUB_64_ADDSUB_SHIFT=1117,
ENC_NEG_ASIMDMISC_R=1118,
ENC_NEG_ASISDMISC_R=1119,
ENC_NGCS_SBCS_32_ADDSUB_CARRY=1120,
ENC_NGCS_SBCS_64_ADDSUB_CARRY=1121,
ENC_NGC_SBC_32_ADDSUB_CARRY=1122,
ENC_NGC_SBC_64_ADDSUB_CARRY=1123,
ENC_NOP_HI_HINTS=1124,
ENC_NOTS_EORS_P_P_PP_Z=1125,
ENC_NOT_ASIMDMISC_R=1126,
ENC_NOT_EOR_P_P_PP_Z=1127,
ENC_ORN_32_LOG_SHIFT=1128,
ENC_ORN_64_LOG_SHIFT=1129,
ENC_ORN_ASIMDSAME_ONLY=1130,
ENC_ORN_ORR_Z_ZI_=1131,
ENC_ORR_32_LOG_IMM=1132,
ENC_ORR_32_LOG_SHIFT=1133,
ENC_ORR_64_LOG_IMM=1134,
ENC_ORR_64_LOG_SHIFT=1135,
ENC_ORR_ASIMDIMM_L_HL=1136,
ENC_ORR_ASIMDIMM_L_SL=1137,
ENC_ORR_ASIMDSAME_ONLY=1138,
ENC_PACDA_64P_DP_1SRC=1139,
ENC_PACDB_64P_DP_1SRC=1140,
ENC_PACDZA_64Z_DP_1SRC=1141,
ENC_PACDZB_64Z_DP_1SRC=1142,
ENC_PACGA_64P_DP_2SRC=1143,
ENC_PACIA1716_HI_HINTS=1144,
ENC_PACIASP_HI_HINTS=1145,
ENC_PACIAZ_HI_HINTS=1146,
ENC_PACIA_64P_DP_1SRC=1147,
ENC_PACIB1716_HI_HINTS=1148,
ENC_PACIBSP_HI_HINTS=1149,
ENC_PACIBZ_HI_HINTS=1150,
ENC_PACIB_64P_DP_1SRC=1151,
ENC_PACIZA_64Z_DP_1SRC=1152,
ENC_PACIZB_64Z_DP_1SRC=1153,
ENC_PMULL_ASIMDDIFF_L=1154,
ENC_PMUL_ASIMDSAME_ONLY=1155,
ENC_PRFM_P_LDST_POS=1156,
ENC_PRFM_P_LDST_REGOFF=1157,
ENC_PRFM_P_LOADLIT=1158,
ENC_PRFUM_P_LDST_UNSCALED=1159,
ENC_PSB_HC_HINTS=1160,
ENC_PSSBB_DSB_BO_BARRIERS=1161,
ENC_RADDHN_ASIMDDIFF_N=1162,
ENC_RAX1_VVV2_CRYPTOSHA512_3=1163,
ENC_RBIT_32_DP_1SRC=1164,
ENC_RBIT_64_DP_1SRC=1165,
ENC_RBIT_ASIMDMISC_R=1166,
ENC_RESERVED_21_ASIMDELEM=1167,
ENC_RESERVED_35_ASIMDELEM=1168,
ENC_RESERVED_36_ASISDSAME=1169,
ENC_RESERVED_37_ASISDSAME=1170,
ENC_RESERVED_38_ASISDSAME=1171,
ENC_RESERVED_39_ASISDSAME=1172,
ENC_RESERVED_42_ASISDSAME=1173,
ENC_RESERVED_44_ASISDSAME=1174,
ENC_RESERVED_45_ASISDSAME=1175,
ENC_RESERVED_46_ASISDSAME=1176,
ENC_RESERVED_47_ASISDSAME=1177,
ENC_RESERVED_48_ASISDSAME=1178,
ENC_RESERVED_50_ASISDSAME=1179,
ENC_RESERVED_52_ASISDSAME=1180,
ENC_RESERVED_53_ASISDSAME=1181,
ENC_RESERVED_54_ASISDSAME=1182,
ENC_RESERVED_57_ASISDSAME=1183,
ENC_RESERVED_67_ASISDSAME=1184,
ENC_RESERVED_68_ASISDSAME=1185,
ENC_RESERVED_69_ASISDSAME=1186,
ENC_RESERVED_70_ASISDSAME=1187,
ENC_RESERVED_72_ASISDSAME=1188,
ENC_RESERVED_74_ASISDSAME=1189,
ENC_RETAA_64E_BRANCH_REG=1190,
ENC_RETAB_64E_BRANCH_REG=1191,
ENC_RET_64R_BRANCH_REG=1192,
ENC_REV16_32_DP_1SRC=1193,
ENC_REV16_64_DP_1SRC=1194,
ENC_REV16_ASIMDMISC_R=1195,
ENC_REV32_64_DP_1SRC=1196,
ENC_REV32_ASIMDMISC_R=1197,
ENC_REV64_REV_64_DP_1SRC=1198,
ENC_REV64_ASIMDMISC_R=1199,
ENC_REV_32_DP_1SRC=1200,
ENC_REV_64_DP_1SRC=1201,
ENC_RMIF_ONLY_RMIF=1202,
ENC_RORV_32_DP_2SRC=1203,
ENC_RORV_64_DP_2SRC=1204,
ENC_ROR_EXTR_32_EXTRACT=1205,
ENC_ROR_EXTR_64_EXTRACT=1206,
ENC_ROR_RORV_32_DP_2SRC=1207,
ENC_ROR_RORV_64_DP_2SRC=1208,
ENC_RSHRN_ASIMDSHF_N=1209,
ENC_RSUBHN_ASIMDDIFF_N=1210,
ENC_SABAL_ASIMDDIFF_L=1211,
ENC_SABA_ASIMDSAME_ONLY=1212,
ENC_SABDL_ASIMDDIFF_L=1213,
ENC_SABD_ASIMDSAME_ONLY=1214,
ENC_SADALP_ASIMDMISC_P=1215,
ENC_SADDLP_ASIMDMISC_P=1216,
ENC_SADDLV_ASIMDALL_ONLY=1217,
ENC_SADDL_ASIMDDIFF_L=1218,
ENC_SADDW_ASIMDDIFF_W=1219,
ENC_SBCS_32_ADDSUB_CARRY=1220,
ENC_SBCS_64_ADDSUB_CARRY=1221,
ENC_SBC_32_ADDSUB_CARRY=1222,
ENC_SBC_64_ADDSUB_CARRY=1223,
ENC_SBFIZ_SBFM_32M_BITFIELD=1224,
ENC_SBFIZ_SBFM_64M_BITFIELD=1225,
ENC_SBFM_32M_BITFIELD=1226,
ENC_SBFM_64M_BITFIELD=1227,
ENC_SBFX_SBFM_32M_BITFIELD=1228,
ENC_SBFX_SBFM_64M_BITFIELD=1229,
ENC_SB_ONLY_BARRIERS=1230,
ENC_SCVTF_D32_FLOAT2FIX=1231,
ENC_SCVTF_D32_FLOAT2INT=1232,
ENC_SCVTF_D64_FLOAT2FIX=1233,
ENC_SCVTF_D64_FLOAT2INT=1234,
ENC_SCVTF_H32_FLOAT2FIX=1235,
ENC_SCVTF_H32_FLOAT2INT=1236,
ENC_SCVTF_H64_FLOAT2FIX=1237,
ENC_SCVTF_H64_FLOAT2INT=1238,
ENC_SCVTF_S32_FLOAT2FIX=1239,
ENC_SCVTF_S32_FLOAT2INT=1240,
ENC_SCVTF_S64_FLOAT2FIX=1241,
ENC_SCVTF_S64_FLOAT2INT=1242,
ENC_SCVTF_ASIMDMISC_R=1243,
ENC_SCVTF_ASIMDMISCFP16_R=1244,
ENC_SCVTF_ASIMDSHF_C=1245,
ENC_SCVTF_ASISDMISC_R=1246,
ENC_SCVTF_ASISDMISCFP16_R=1247,
ENC_SCVTF_ASISDSHF_C=1248,
ENC_SDIV_32_DP_2SRC=1249,
ENC_SDIV_64_DP_2SRC=1250,
ENC_SDOT_ASIMDELEM_D=1251,
ENC_SDOT_ASIMDSAME2_D=1252,
ENC_SETF16_ONLY_SETF=1253,
ENC_SETF8_ONLY_SETF=1254,
ENC_SEVL_HI_HINTS=1255,
ENC_SEV_HI_HINTS=1256,
ENC_SHA1C_QSV_CRYPTOSHA3=1257,
ENC_SHA1H_SS_CRYPTOSHA2=1258,
ENC_SHA1M_QSV_CRYPTOSHA3=1259,
ENC_SHA1P_QSV_CRYPTOSHA3=1260,
ENC_SHA1SU0_VVV_CRYPTOSHA3=1261,
ENC_SHA1SU1_VV_CRYPTOSHA2=1262,
ENC_SHA256H2_QQV_CRYPTOSHA3=1263,
ENC_SHA256H_QQV_CRYPTOSHA3=1264,
ENC_SHA256SU0_VV_CRYPTOSHA2=1265,
ENC_SHA256SU1_VVV_CRYPTOSHA3=1266,
ENC_SHA512H2_QQV_CRYPTOSHA512_3=1267,
ENC_SHA512H_QQV_CRYPTOSHA512_3=1268,
ENC_SHA512SU0_VV2_CRYPTOSHA512_2=1269,
ENC_SHA512SU1_VVV2_CRYPTOSHA512_3=1270,
ENC_SHADD_ASIMDSAME_ONLY=1271,
ENC_SHLL_ASIMDMISC_S=1272,
ENC_SHL_ASIMDSHF_R=1273,
ENC_SHL_ASISDSHF_R=1274,
ENC_SHRN_ASIMDSHF_N=1275,
ENC_SHSUB_ASIMDSAME_ONLY=1276,
ENC_SLI_ASIMDSHF_R=1277,
ENC_SLI_ASISDSHF_R=1278,
ENC_SM3PARTW1_VVV4_CRYPTOSHA512_3=1279,
ENC_SM3PARTW2_VVV4_CRYPTOSHA512_3=1280,
ENC_SM3SS1_VVV4_CRYPTO4=1281,
ENC_SM3TT1A_VVV4_CRYPTO3_IMM2=1282,
ENC_SM3TT1B_VVV4_CRYPTO3_IMM2=1283,
ENC_SM3TT2A_VVV4_CRYPTO3_IMM2=1284,
ENC_SM3TT2B_VVV_CRYPTO3_IMM2=1285,
ENC_SM4EKEY_VVV4_CRYPTOSHA512_3=1286,
ENC_SM4E_VV4_CRYPTOSHA512_2=1287,
ENC_SMADDL_64WA_DP_3SRC=1288,
ENC_SMAXP_ASIMDSAME_ONLY=1289,
ENC_SMAXV_ASIMDALL_ONLY=1290,
ENC_SMAX_ASIMDSAME_ONLY=1291,
ENC_SMC_EX_EXCEPTION=1292,
ENC_SMINP_ASIMDSAME_ONLY=1293,
ENC_SMINV_ASIMDALL_ONLY=1294,
ENC_SMIN_ASIMDSAME_ONLY=1295,
ENC_SMLAL_ASIMDDIFF_L=1296,
ENC_SMLAL_ASIMDELEM_L=1297,
ENC_SMLSL_ASIMDDIFF_L=1298,
ENC_SMLSL_ASIMDELEM_L=1299,
ENC_SMMLA_ASIMDSAME2_G=1300,
ENC_SMNEGL_SMSUBL_64WA_DP_3SRC=1301,
ENC_SMOV_ASIMDINS_W_W=1302,
ENC_SMOV_ASIMDINS_X_X=1303,
ENC_SMSUBL_64WA_DP_3SRC=1304,
ENC_SMULH_64_DP_3SRC=1305,
ENC_SMULL_SMADDL_64WA_DP_3SRC=1306,
ENC_SMULL_ASIMDDIFF_L=1307,
ENC_SMULL_ASIMDELEM_L=1308,
ENC_SQABS_ASIMDMISC_R=1309,
ENC_SQABS_ASISDMISC_R=1310,
ENC_SQADD_ASIMDSAME_ONLY=1311,
ENC_SQADD_ASISDSAME_ONLY=1312,
ENC_SQDMLAL_ASIMDDIFF_L=1313,
ENC_SQDMLAL_ASIMDELEM_L=1314,
ENC_SQDMLAL_ASISDDIFF_ONLY=1315,
ENC_SQDMLAL_ASISDELEM_L=1316,
ENC_SQDMLSL_ASIMDDIFF_L=1317,
ENC_SQDMLSL_ASIMDELEM_L=1318,
ENC_SQDMLSL_ASISDDIFF_ONLY=1319,
ENC_SQDMLSL_ASISDELEM_L=1320,
ENC_SQDMULH_ASIMDELEM_R=1321,
ENC_SQDMULH_ASIMDSAME_ONLY=1322,
ENC_SQDMULH_ASISDELEM_R=1323,
ENC_SQDMULH_ASISDSAME_ONLY=1324,
ENC_SQDMULL_ASIMDDIFF_L=1325,
ENC_SQDMULL_ASIMDELEM_L=1326,
ENC_SQDMULL_ASISDDIFF_ONLY=1327,
ENC_SQDMULL_ASISDELEM_L=1328,
ENC_SQNEG_ASIMDMISC_R=1329,
ENC_SQNEG_ASISDMISC_R=1330,
ENC_SQRDMLAH_ASIMDELEM_R=1331,
ENC_SQRDMLAH_ASIMDSAME2_ONLY=1332,
ENC_SQRDMLAH_ASISDELEM_R=1333,
ENC_SQRDMLAH_ASISDSAME2_ONLY=1334,
ENC_SQRDMLSH_ASIMDELEM_R=1335,
ENC_SQRDMLSH_ASIMDSAME2_ONLY=1336,
ENC_SQRDMLSH_ASISDELEM_R=1337,
ENC_SQRDMLSH_ASISDSAME2_ONLY=1338,
ENC_SQRDMULH_ASIMDELEM_R=1339,
ENC_SQRDMULH_ASIMDSAME_ONLY=1340,
ENC_SQRDMULH_ASISDELEM_R=1341,
ENC_SQRDMULH_ASISDSAME_ONLY=1342,
ENC_SQRSHL_ASIMDSAME_ONLY=1343,
ENC_SQRSHL_ASISDSAME_ONLY=1344,
ENC_SQRSHRN_ASIMDSHF_N=1345,
ENC_SQRSHRN_ASISDSHF_N=1346,
ENC_SQRSHRUN_ASIMDSHF_N=1347,
ENC_SQRSHRUN_ASISDSHF_N=1348,
ENC_SQSHLU_ASIMDSHF_R=1349,
ENC_SQSHLU_ASISDSHF_R=1350,
ENC_SQSHL_ASIMDSAME_ONLY=1351,
ENC_SQSHL_ASIMDSHF_R=1352,
ENC_SQSHL_ASISDSAME_ONLY=1353,
ENC_SQSHL_ASISDSHF_R=1354,
ENC_SQSHRN_ASIMDSHF_N=1355,
ENC_SQSHRN_ASISDSHF_N=1356,
ENC_SQSHRUN_ASIMDSHF_N=1357,
ENC_SQSHRUN_ASISDSHF_N=1358,
ENC_SQSUB_ASIMDSAME_ONLY=1359,
ENC_SQSUB_ASISDSAME_ONLY=1360,
ENC_SQXTN_ASIMDMISC_N=1361,
ENC_SQXTN_ASISDMISC_N=1362,
ENC_SQXTUN_ASIMDMISC_N=1363,
ENC_SQXTUN_ASISDMISC_N=1364,
ENC_SRHADD_ASIMDSAME_ONLY=1365,
ENC_SRI_ASIMDSHF_R=1366,
ENC_SRI_ASISDSHF_R=1367,
ENC_SRSHL_ASIMDSAME_ONLY=1368,
ENC_SRSHL_ASISDSAME_ONLY=1369,
ENC_SRSHR_ASIMDSHF_R=1370,
ENC_SRSHR_ASISDSHF_R=1371,
ENC_SRSRA_ASIMDSHF_R=1372,
ENC_SRSRA_ASISDSHF_R=1373,
ENC_SSBB_DSB_BO_BARRIERS=1374,
ENC_SSHLL_ASIMDSHF_L=1375,
ENC_SSHL_ASIMDSAME_ONLY=1376,
ENC_SSHL_ASISDSAME_ONLY=1377,
ENC_SSHR_ASIMDSHF_R=1378,
ENC_SSHR_ASISDSHF_R=1379,
ENC_SSRA_ASIMDSHF_R=1380,
ENC_SSRA_ASISDSHF_R=1381,
ENC_SSUBL_ASIMDDIFF_L=1382,
ENC_SSUBW_ASIMDDIFF_W=1383,
ENC_ST1_ASISDLSE_R1_1V=1384,
ENC_ST1_ASISDLSE_R2_2V=1385,
ENC_ST1_ASISDLSE_R3_3V=1386,
ENC_ST1_ASISDLSE_R4_4V=1387,
ENC_ST1_ASISDLSEP_I1_I1=1388,
ENC_ST1_ASISDLSEP_I2_I2=1389,
ENC_ST1_ASISDLSEP_I3_I3=1390,
ENC_ST1_ASISDLSEP_I4_I4=1391,
ENC_ST1_ASISDLSEP_R1_R1=1392,
ENC_ST1_ASISDLSEP_R2_R2=1393,
ENC_ST1_ASISDLSEP_R3_R3=1394,
ENC_ST1_ASISDLSEP_R4_R4=1395,
ENC_ST1_ASISDLSO_B1_1B=1396,
ENC_ST1_ASISDLSO_D1_1D=1397,
ENC_ST1_ASISDLSO_H1_1H=1398,
ENC_ST1_ASISDLSO_S1_1S=1399,
ENC_ST1_ASISDLSOP_B1_I1B=1400,
ENC_ST1_ASISDLSOP_BX1_R1B=1401,
ENC_ST1_ASISDLSOP_D1_I1D=1402,
ENC_ST1_ASISDLSOP_DX1_R1D=1403,
ENC_ST1_ASISDLSOP_H1_I1H=1404,
ENC_ST1_ASISDLSOP_HX1_R1H=1405,
ENC_ST1_ASISDLSOP_S1_I1S=1406,
ENC_ST1_ASISDLSOP_SX1_R1S=1407,
ENC_ST2G_64SOFFSET_LDSTTAGS=1408,
ENC_ST2G_64SPOST_LDSTTAGS=1409,
ENC_ST2G_64SPRE_LDSTTAGS=1410,
ENC_ST2_ASISDLSE_R2=1411,
ENC_ST2_ASISDLSEP_I2_I=1412,
ENC_ST2_ASISDLSEP_R2_R=1413,
ENC_ST2_ASISDLSO_B2_2B=1414,
ENC_ST2_ASISDLSO_D2_2D=1415,
ENC_ST2_ASISDLSO_H2_2H=1416,
ENC_ST2_ASISDLSO_S2_2S=1417,
ENC_ST2_ASISDLSOP_B2_I2B=1418,
ENC_ST2_ASISDLSOP_BX2_R2B=1419,
ENC_ST2_ASISDLSOP_D2_I2D=1420,
ENC_ST2_ASISDLSOP_DX2_R2D=1421,
ENC_ST2_ASISDLSOP_H2_I2H=1422,
ENC_ST2_ASISDLSOP_HX2_R2H=1423,
ENC_ST2_ASISDLSOP_S2_I2S=1424,
ENC_ST2_ASISDLSOP_SX2_R2S=1425,
ENC_ST3_ASISDLSE_R3=1426,
ENC_ST3_ASISDLSEP_I3_I=1427,
ENC_ST3_ASISDLSEP_R3_R=1428,
ENC_ST3_ASISDLSO_B3_3B=1429,
ENC_ST3_ASISDLSO_D3_3D=1430,
ENC_ST3_ASISDLSO_H3_3H=1431,
ENC_ST3_ASISDLSO_S3_3S=1432,
ENC_ST3_ASISDLSOP_B3_I3B=1433,
ENC_ST3_ASISDLSOP_BX3_R3B=1434,
ENC_ST3_ASISDLSOP_D3_I3D=1435,
ENC_ST3_ASISDLSOP_DX3_R3D=1436,
ENC_ST3_ASISDLSOP_H3_I3H=1437,
ENC_ST3_ASISDLSOP_HX3_R3H=1438,
ENC_ST3_ASISDLSOP_S3_I3S=1439,
ENC_ST3_ASISDLSOP_SX3_R3S=1440,
ENC_ST4_ASISDLSE_R4=1441,
ENC_ST4_ASISDLSEP_I4_I=1442,
ENC_ST4_ASISDLSEP_R4_R=1443,
ENC_ST4_ASISDLSO_B4_4B=1444,
ENC_ST4_ASISDLSO_D4_4D=1445,
ENC_ST4_ASISDLSO_H4_4H=1446,
ENC_ST4_ASISDLSO_S4_4S=1447,
ENC_ST4_ASISDLSOP_B4_I4B=1448,
ENC_ST4_ASISDLSOP_BX4_R4B=1449,
ENC_ST4_ASISDLSOP_D4_I4D=1450,
ENC_ST4_ASISDLSOP_DX4_R4D=1451,
ENC_ST4_ASISDLSOP_H4_I4H=1452,
ENC_ST4_ASISDLSOP_HX4_R4H=1453,
ENC_ST4_ASISDLSOP_S4_I4S=1454,
ENC_ST4_ASISDLSOP_SX4_R4S=1455,
ENC_ST64BV0_64_MEMOP=1456,
ENC_ST64BV_64_MEMOP=1457,
ENC_ST64B_64L_MEMOP=1458,
ENC_STADDB_LDADDB_32_MEMOP=1459,
ENC_STADDH_LDADDH_32_MEMOP=1460,
ENC_STADDLB_LDADDLB_32_MEMOP=1461,
ENC_STADDLH_LDADDLH_32_MEMOP=1462,
ENC_STADDL_LDADDL_32_MEMOP=1463,
ENC_STADDL_LDADDL_64_MEMOP=1464,
ENC_STADD_LDADD_32_MEMOP=1465,
ENC_STADD_LDADD_64_MEMOP=1466,
ENC_STCLRB_LDCLRB_32_MEMOP=1467,
ENC_STCLRH_LDCLRH_32_MEMOP=1468,
ENC_STCLRLB_LDCLRLB_32_MEMOP=1469,
ENC_STCLRLH_LDCLRLH_32_MEMOP=1470,
ENC_STCLRL_LDCLRL_32_MEMOP=1471,
ENC_STCLRL_LDCLRL_64_MEMOP=1472,
ENC_STCLR_LDCLR_32_MEMOP=1473,
ENC_STCLR_LDCLR_64_MEMOP=1474,
ENC_STEORB_LDEORB_32_MEMOP=1475,
ENC_STEORH_LDEORH_32_MEMOP=1476,
ENC_STEORLB_LDEORLB_32_MEMOP=1477,
ENC_STEORLH_LDEORLH_32_MEMOP=1478,
ENC_STEORL_LDEORL_32_MEMOP=1479,
ENC_STEORL_LDEORL_64_MEMOP=1480,
ENC_STEOR_LDEOR_32_MEMOP=1481,
ENC_STEOR_LDEOR_64_MEMOP=1482,
ENC_STGM_64BULK_LDSTTAGS=1483,
ENC_STGP_64_LDSTPAIR_OFF=1484,
ENC_STGP_64_LDSTPAIR_POST=1485,
ENC_STGP_64_LDSTPAIR_PRE=1486,
ENC_STG_64SOFFSET_LDSTTAGS=1487,
ENC_STG_64SPOST_LDSTTAGS=1488,
ENC_STG_64SPRE_LDSTTAGS=1489,
ENC_STLLRB_SL32_LDSTORD=1490,
ENC_STLLRH_SL32_LDSTORD=1491,
ENC_STLLR_SL32_LDSTORD=1492,
ENC_STLLR_SL64_LDSTORD=1493,
ENC_STLRB_SL32_LDSTORD=1494,
ENC_STLRH_SL32_LDSTORD=1495,
ENC_STLR_SL32_LDSTORD=1496,
ENC_STLR_SL64_LDSTORD=1497,
ENC_STLURB_32_LDAPSTL_UNSCALED=1498,
ENC_STLURH_32_LDAPSTL_UNSCALED=1499,
ENC_STLUR_32_LDAPSTL_UNSCALED=1500,
ENC_STLUR_64_LDAPSTL_UNSCALED=1501,
ENC_STLXP_SP32_LDSTEXCLP=1502,
ENC_STLXP_SP64_LDSTEXCLP=1503,
ENC_STLXRB_SR32_LDSTEXCLR=1504,
ENC_STLXRH_SR32_LDSTEXCLR=1505,
ENC_STLXR_SR32_LDSTEXCLR=1506,
ENC_STLXR_SR64_LDSTEXCLR=1507,
ENC_STNP_32_LDSTNAPAIR_OFFS=1508,
ENC_STNP_64_LDSTNAPAIR_OFFS=1509,
ENC_STNP_D_LDSTNAPAIR_OFFS=1510,
ENC_STNP_Q_LDSTNAPAIR_OFFS=1511,
ENC_STNP_S_LDSTNAPAIR_OFFS=1512,
ENC_STP_32_LDSTPAIR_OFF=1513,
ENC_STP_32_LDSTPAIR_POST=1514,
ENC_STP_32_LDSTPAIR_PRE=1515,
ENC_STP_64_LDSTPAIR_OFF=1516,
ENC_STP_64_LDSTPAIR_POST=1517,
ENC_STP_64_LDSTPAIR_PRE=1518,
ENC_STP_D_LDSTPAIR_OFF=1519,
ENC_STP_D_LDSTPAIR_POST=1520,
ENC_STP_D_LDSTPAIR_PRE=1521,
ENC_STP_Q_LDSTPAIR_OFF=1522,
ENC_STP_Q_LDSTPAIR_POST=1523,
ENC_STP_Q_LDSTPAIR_PRE=1524,
ENC_STP_S_LDSTPAIR_OFF=1525,
ENC_STP_S_LDSTPAIR_POST=1526,
ENC_STP_S_LDSTPAIR_PRE=1527,
ENC_STRB_32BL_LDST_REGOFF=1528,
ENC_STRB_32B_LDST_REGOFF=1529,
ENC_STRB_32_LDST_IMMPOST=1530,
ENC_STRB_32_LDST_IMMPRE=1531,
ENC_STRB_32_LDST_POS=1532,
ENC_STRH_32_LDST_IMMPOST=1533,
ENC_STRH_32_LDST_IMMPRE=1534,
ENC_STRH_32_LDST_POS=1535,
ENC_STRH_32_LDST_REGOFF=1536,
ENC_STR_32_LDST_IMMPOST=1537,
ENC_STR_32_LDST_IMMPRE=1538,
ENC_STR_32_LDST_POS=1539,
ENC_STR_32_LDST_REGOFF=1540,
ENC_STR_64_LDST_IMMPOST=1541,
ENC_STR_64_LDST_IMMPRE=1542,
ENC_STR_64_LDST_POS=1543,
ENC_STR_64_LDST_REGOFF=1544,
ENC_STR_BL_LDST_REGOFF=1545,
ENC_STR_B_LDST_IMMPOST=1546,
ENC_STR_B_LDST_IMMPRE=1547,
ENC_STR_B_LDST_POS=1548,
ENC_STR_B_LDST_REGOFF=1549,
ENC_STR_D_LDST_IMMPOST=1550,
ENC_STR_D_LDST_IMMPRE=1551,
ENC_STR_D_LDST_POS=1552,
ENC_STR_D_LDST_REGOFF=1553,
ENC_STR_H_LDST_IMMPOST=1554,
ENC_STR_H_LDST_IMMPRE=1555,
ENC_STR_H_LDST_POS=1556,
ENC_STR_H_LDST_REGOFF=1557,
ENC_STR_Q_LDST_IMMPOST=1558,
ENC_STR_Q_LDST_IMMPRE=1559,
ENC_STR_Q_LDST_POS=1560,
ENC_STR_Q_LDST_REGOFF=1561,
ENC_STR_S_LDST_IMMPOST=1562,
ENC_STR_S_LDST_IMMPRE=1563,
ENC_STR_S_LDST_POS=1564,
ENC_STR_S_LDST_REGOFF=1565,
ENC_STSETB_LDSETB_32_MEMOP=1566,
ENC_STSETH_LDSETH_32_MEMOP=1567,
ENC_STSETLB_LDSETLB_32_MEMOP=1568,
ENC_STSETLH_LDSETLH_32_MEMOP=1569,
ENC_STSETL_LDSETL_32_MEMOP=1570,
ENC_STSETL_LDSETL_64_MEMOP=1571,
ENC_STSET_LDSET_32_MEMOP=1572,
ENC_STSET_LDSET_64_MEMOP=1573,
ENC_STSMAXB_LDSMAXB_32_MEMOP=1574,
ENC_STSMAXH_LDSMAXH_32_MEMOP=1575,
ENC_STSMAXLB_LDSMAXLB_32_MEMOP=1576,
ENC_STSMAXLH_LDSMAXLH_32_MEMOP=1577,
ENC_STSMAXL_LDSMAXL_32_MEMOP=1578,
ENC_STSMAXL_LDSMAXL_64_MEMOP=1579,
ENC_STSMAX_LDSMAX_32_MEMOP=1580,
ENC_STSMAX_LDSMAX_64_MEMOP=1581,
ENC_STSMINB_LDSMINB_32_MEMOP=1582,
ENC_STSMINH_LDSMINH_32_MEMOP=1583,
ENC_STSMINLB_LDSMINLB_32_MEMOP=1584,
ENC_STSMINLH_LDSMINLH_32_MEMOP=1585,
ENC_STSMINL_LDSMINL_32_MEMOP=1586,
ENC_STSMINL_LDSMINL_64_MEMOP=1587,
ENC_STSMIN_LDSMIN_32_MEMOP=1588,
ENC_STSMIN_LDSMIN_64_MEMOP=1589,
ENC_STTRB_32_LDST_UNPRIV=1590,
ENC_STTRH_32_LDST_UNPRIV=1591,
ENC_STTR_32_LDST_UNPRIV=1592,
ENC_STTR_64_LDST_UNPRIV=1593,
ENC_STUMAXB_LDUMAXB_32_MEMOP=1594,
ENC_STUMAXH_LDUMAXH_32_MEMOP=1595,
ENC_STUMAXLB_LDUMAXLB_32_MEMOP=1596,
ENC_STUMAXLH_LDUMAXLH_32_MEMOP=1597,
ENC_STUMAXL_LDUMAXL_32_MEMOP=1598,
ENC_STUMAXL_LDUMAXL_64_MEMOP=1599,
ENC_STUMAX_LDUMAX_32_MEMOP=1600,
ENC_STUMAX_LDUMAX_64_MEMOP=1601,
ENC_STUMINB_LDUMINB_32_MEMOP=1602,
ENC_STUMINH_LDUMINH_32_MEMOP=1603,
ENC_STUMINLB_LDUMINLB_32_MEMOP=1604,
ENC_STUMINLH_LDUMINLH_32_MEMOP=1605,
ENC_STUMINL_LDUMINL_32_MEMOP=1606,
ENC_STUMINL_LDUMINL_64_MEMOP=1607,
ENC_STUMIN_LDUMIN_32_MEMOP=1608,
ENC_STUMIN_LDUMIN_64_MEMOP=1609,
ENC_STURB_32_LDST_UNSCALED=1610,
ENC_STURH_32_LDST_UNSCALED=1611,
ENC_STUR_32_LDST_UNSCALED=1612,
ENC_STUR_64_LDST_UNSCALED=1613,
ENC_STUR_B_LDST_UNSCALED=1614,
ENC_STUR_D_LDST_UNSCALED=1615,
ENC_STUR_H_LDST_UNSCALED=1616,
ENC_STUR_Q_LDST_UNSCALED=1617,
ENC_STUR_S_LDST_UNSCALED=1618,
ENC_STXP_SP32_LDSTEXCLP=1619,
ENC_STXP_SP64_LDSTEXCLP=1620,
ENC_STXRB_SR32_LDSTEXCLR=1621,
ENC_STXRH_SR32_LDSTEXCLR=1622,
ENC_STXR_SR32_LDSTEXCLR=1623,
ENC_STXR_SR64_LDSTEXCLR=1624,
ENC_STZ2G_64SOFFSET_LDSTTAGS=1625,
ENC_STZ2G_64SPOST_LDSTTAGS=1626,
ENC_STZ2G_64SPRE_LDSTTAGS=1627,
ENC_STZGM_64BULK_LDSTTAGS=1628,
ENC_STZG_64SOFFSET_LDSTTAGS=1629,
ENC_STZG_64SPOST_LDSTTAGS=1630,
ENC_STZG_64SPRE_LDSTTAGS=1631,
ENC_SUBG_64_ADDSUB_IMMTAGS=1632,
ENC_SUBHN_ASIMDDIFF_N=1633,
ENC_SUBPS_64S_DP_2SRC=1634,
ENC_SUBP_64S_DP_2SRC=1635,
ENC_SUBS_32S_ADDSUB_EXT=1636,
ENC_SUBS_32S_ADDSUB_IMM=1637,
ENC_SUBS_32_ADDSUB_SHIFT=1638,
ENC_SUBS_64S_ADDSUB_EXT=1639,
ENC_SUBS_64S_ADDSUB_IMM=1640,
ENC_SUBS_64_ADDSUB_SHIFT=1641,
ENC_SUB_32_ADDSUB_EXT=1642,
ENC_SUB_32_ADDSUB_IMM=1643,
ENC_SUB_32_ADDSUB_SHIFT=1644,
ENC_SUB_64_ADDSUB_EXT=1645,
ENC_SUB_64_ADDSUB_IMM=1646,
ENC_SUB_64_ADDSUB_SHIFT=1647,
ENC_SUB_ASIMDSAME_ONLY=1648,
ENC_SUB_ASISDSAME_ONLY=1649,
ENC_SUDOT_ASIMDELEM_D=1650,
ENC_SUQADD_ASIMDMISC_R=1651,
ENC_SUQADD_ASISDMISC_R=1652,
ENC_SVC_EX_EXCEPTION=1653,
ENC_SWPAB_32_MEMOP=1654,
ENC_SWPAH_32_MEMOP=1655,
ENC_SWPALB_32_MEMOP=1656,
ENC_SWPALH_32_MEMOP=1657,
ENC_SWPAL_32_MEMOP=1658,
ENC_SWPAL_64_MEMOP=1659,
ENC_SWPA_32_MEMOP=1660,
ENC_SWPA_64_MEMOP=1661,
ENC_SWPB_32_MEMOP=1662,
ENC_SWPH_32_MEMOP=1663,
ENC_SWPLB_32_MEMOP=1664,
ENC_SWPLH_32_MEMOP=1665,
ENC_SWPL_32_MEMOP=1666,
ENC_SWPL_64_MEMOP=1667,
ENC_SWP_32_MEMOP=1668,
ENC_SWP_64_MEMOP=1669,
ENC_SXTB_SBFM_32M_BITFIELD=1670,
ENC_SXTB_SBFM_64M_BITFIELD=1671,
ENC_SXTH_SBFM_32M_BITFIELD=1672,
ENC_SXTH_SBFM_64M_BITFIELD=1673,
ENC_SXTL_SSHLL_ASIMDSHF_L=1674,
ENC_SXTW_SBFM_64M_BITFIELD=1675,
ENC_SYSL_RC_SYSTEMINSTRS=1676,
ENC_SYS_CR_SYSTEMINSTRS=1677,
ENC_TBL_ASIMDTBL_L1_1=1678,
ENC_TBL_ASIMDTBL_L2_2=1679,
ENC_TBL_ASIMDTBL_L3_3=1680,
ENC_TBL_ASIMDTBL_L4_4=1681,
ENC_TBNZ_ONLY_TESTBRANCH=1682,
ENC_TBX_ASIMDTBL_L1_1=1683,
ENC_TBX_ASIMDTBL_L2_2=1684,
ENC_TBX_ASIMDTBL_L3_3=1685,
ENC_TBX_ASIMDTBL_L4_4=1686,
ENC_TBZ_ONLY_TESTBRANCH=1687,
ENC_TCANCEL_EX_EXCEPTION=1688,
ENC_TCOMMIT_ONLY_BARRIERS=1689,
ENC_TLBI_SYS_CR_SYSTEMINSTRS=1690,
ENC_TRN1_ASIMDPERM_ONLY=1691,
ENC_TRN2_ASIMDPERM_ONLY=1692,
ENC_TSB_HC_HINTS=1693,
ENC_TSTART_BR_SYSTEMRESULT=1694,
ENC_TST_ANDS_32S_LOG_IMM=1695,
ENC_TST_ANDS_32_LOG_SHIFT=1696,
ENC_TST_ANDS_64S_LOG_IMM=1697,
ENC_TST_ANDS_64_LOG_SHIFT=1698,
ENC_TTEST_BR_SYSTEMRESULT=1699,
ENC_UABAL_ASIMDDIFF_L=1700,
ENC_UABA_ASIMDSAME_ONLY=1701,
ENC_UABDL_ASIMDDIFF_L=1702,
ENC_UABD_ASIMDSAME_ONLY=1703,
ENC_UADALP_ASIMDMISC_P=1704,
ENC_UADDLP_ASIMDMISC_P=1705,
ENC_UADDLV_ASIMDALL_ONLY=1706,
ENC_UADDL_ASIMDDIFF_L=1707,
ENC_UADDW_ASIMDDIFF_W=1708,
ENC_UBFIZ_UBFM_32M_BITFIELD=1709,
ENC_UBFIZ_UBFM_64M_BITFIELD=1710,
ENC_UBFM_32M_BITFIELD=1711,
ENC_UBFM_64M_BITFIELD=1712,
ENC_UBFX_UBFM_32M_BITFIELD=1713,
ENC_UBFX_UBFM_64M_BITFIELD=1714,
ENC_UCVTF_D32_FLOAT2FIX=1715,
ENC_UCVTF_D32_FLOAT2INT=1716,
ENC_UCVTF_D64_FLOAT2FIX=1717,
ENC_UCVTF_D64_FLOAT2INT=1718,
ENC_UCVTF_H32_FLOAT2FIX=1719,
ENC_UCVTF_H32_FLOAT2INT=1720,
ENC_UCVTF_H64_FLOAT2FIX=1721,
ENC_UCVTF_H64_FLOAT2INT=1722,
ENC_UCVTF_S32_FLOAT2FIX=1723,
ENC_UCVTF_S32_FLOAT2INT=1724,
ENC_UCVTF_S64_FLOAT2FIX=1725,
ENC_UCVTF_S64_FLOAT2INT=1726,
ENC_UCVTF_ASIMDMISC_R=1727,
ENC_UCVTF_ASIMDMISCFP16_R=1728,
ENC_UCVTF_ASIMDSHF_C=1729,
ENC_UCVTF_ASISDMISC_R=1730,
ENC_UCVTF_ASISDMISCFP16_R=1731,
ENC_UCVTF_ASISDSHF_C=1732,
ENC_UDF_ONLY_PERM_UNDEF=1733,
ENC_UDIV_32_DP_2SRC=1734,
ENC_UDIV_64_DP_2SRC=1735,
ENC_UDOT_ASIMDELEM_D=1736,
ENC_UDOT_ASIMDSAME2_D=1737,
ENC_UHADD_ASIMDSAME_ONLY=1738,
ENC_UHSUB_ASIMDSAME_ONLY=1739,
ENC_UMADDL_64WA_DP_3SRC=1740,
ENC_UMAXP_ASIMDSAME_ONLY=1741,
ENC_UMAXV_ASIMDALL_ONLY=1742,
ENC_UMAX_ASIMDSAME_ONLY=1743,
ENC_UMINP_ASIMDSAME_ONLY=1744,
ENC_UMINV_ASIMDALL_ONLY=1745,
ENC_UMIN_ASIMDSAME_ONLY=1746,
ENC_UMLAL_ASIMDDIFF_L=1747,
ENC_UMLAL_ASIMDELEM_L=1748,
ENC_UMLSL_ASIMDDIFF_L=1749,
ENC_UMLSL_ASIMDELEM_L=1750,
ENC_UMMLA_ASIMDSAME2_G=1751,
ENC_UMNEGL_UMSUBL_64WA_DP_3SRC=1752,
ENC_UMOV_ASIMDINS_W_W=1753,
ENC_UMOV_ASIMDINS_X_X=1754,
ENC_UMSUBL_64WA_DP_3SRC=1755,
ENC_UMULH_64_DP_3SRC=1756,
ENC_UMULL_UMADDL_64WA_DP_3SRC=1757,
ENC_UMULL_ASIMDDIFF_L=1758,
ENC_UMULL_ASIMDELEM_L=1759,
ENC_UNALLOCATED_100_ASIMDSAME=1760,
ENC_UNALLOCATED_10_ADDSUB_EXT=1761,
ENC_UNALLOCATED_10_ADDSUB_IMMTAGS=1762,
ENC_UNALLOCATED_10_ADDSUB_SHIFT=1763,
ENC_UNALLOCATED_10_BARRIERS=1764,
ENC_UNALLOCATED_10_BRANCH_REG=1765,
ENC_UNALLOCATED_10_COMSWAP=1766,
ENC_UNALLOCATED_10_COMSWAPPR=1767,
ENC_UNALLOCATED_10_CONDCMP_IMM=1768,
ENC_UNALLOCATED_10_CONDCMP_REG=1769,
ENC_UNALLOCATED_10_CONDSEL=1770,
ENC_UNALLOCATED_10_DP_1SRC=1771,
ENC_UNALLOCATED_10_EXCEPTION=1772,
ENC_UNALLOCATED_10_FLOAT2FIX=1773,
ENC_UNALLOCATED_10_FLOAT2INT=1774,
ENC_UNALLOCATED_10_FLOATCCMP=1775,
ENC_UNALLOCATED_10_FLOATCMP=1776,
ENC_UNALLOCATED_10_FLOATDP1=1777,
ENC_UNALLOCATED_10_FLOATDP2=1778,
ENC_UNALLOCATED_10_FLOATDP3=1779,
ENC_UNALLOCATED_10_FLOATIMM=1780,
ENC_UNALLOCATED_10_FLOATSEL=1781,
ENC_UNALLOCATED_10_LOG_IMM=1782,
ENC_UNALLOCATED_10_LOG_SHIFT=1783,
ENC_UNALLOCATED_10_MOVEWIDE=1784,
ENC_UNALLOCATED_10_PSTATE=1785,
ENC_UNALLOCATED_10_RMIF=1786,
ENC_UNALLOCATED_10_SETF=1787,
ENC_UNALLOCATED_10_SYSTEMRESULT=1788,
ENC_UNALLOCATED_11_ADDSUB_EXT=1789,
ENC_UNALLOCATED_11_ADDSUB_IMMTAGS=1790,
ENC_UNALLOCATED_11_ADDSUB_SHIFT=1791,
ENC_UNALLOCATED_11_ASIMDALL=1792,
ENC_UNALLOCATED_11_ASIMDELEM=1793,
ENC_UNALLOCATED_11_ASIMDEXT=1794,
ENC_UNALLOCATED_11_ASIMDINS=1795,
ENC_UNALLOCATED_11_ASIMDMISCFP16=1796,
ENC_UNALLOCATED_11_ASIMDPERM=1797,
ENC_UNALLOCATED_11_ASIMDSAME2=1798,
ENC_UNALLOCATED_11_ASIMDTBL=1799,
ENC_UNALLOCATED_11_ASISDDIFF=1800,
ENC_UNALLOCATED_11_ASISDELEM=1801,
ENC_UNALLOCATED_11_ASISDLSO=1802,
ENC_UNALLOCATED_11_ASISDLSOP=1803,
ENC_UNALLOCATED_11_ASISDMISC=1804,
ENC_UNALLOCATED_11_ASISDMISCFP16=1805,
ENC_UNALLOCATED_11_ASISDPAIR=1806,
ENC_UNALLOCATED_11_ASISDSAME=1807,
ENC_UNALLOCATED_11_ASISDSAME2=1808,
ENC_UNALLOCATED_11_ASISDSHF=1809,
ENC_UNALLOCATED_11_BARRIERS=1810,
ENC_UNALLOCATED_11_BITFIELD=1811,
ENC_UNALLOCATED_11_CONDBRANCH=1812,
ENC_UNALLOCATED_11_CONDCMP_IMM=1813,
ENC_UNALLOCATED_11_CONDCMP_REG=1814,
ENC_UNALLOCATED_11_CONDSEL=1815,
ENC_UNALLOCATED_11_CRYPTOAES=1816,
ENC_UNALLOCATED_11_CRYPTOSHA2=1817,
ENC_UNALLOCATED_11_CRYPTOSHA3=1818,
ENC_UNALLOCATED_11_CRYPTOSHA512_2=1819,
ENC_UNALLOCATED_11_DP_1SRC=1820,
ENC_UNALLOCATED_11_DP_2SRC=1821,
ENC_UNALLOCATED_11_EXTRACT=1822,
ENC_UNALLOCATED_11_FLOAT2FIX=1823,
ENC_UNALLOCATED_11_FLOAT2INT=1824,
ENC_UNALLOCATED_11_FLOATCCMP=1825,
ENC_UNALLOCATED_11_FLOATCMP=1826,
ENC_UNALLOCATED_11_FLOATDP1=1827,
ENC_UNALLOCATED_11_FLOATDP2=1828,
ENC_UNALLOCATED_11_FLOATDP3=1829,
ENC_UNALLOCATED_11_FLOATIMM=1830,
ENC_UNALLOCATED_11_FLOATSEL=1831,
ENC_UNALLOCATED_11_RMIF=1832,
ENC_UNALLOCATED_11_SETF=1833,
ENC_UNALLOCATED_11_SYSTEMRESULT=1834,
ENC_UNALLOCATED_120=1835,
ENC_UNALLOCATED_121=1836,
ENC_UNALLOCATED_122=1837,
ENC_UNALLOCATED_123=1838,
ENC_UNALLOCATED_124=1839,
ENC_UNALLOCATED_125=1840,
ENC_UNALLOCATED_126=1841,
ENC_UNALLOCATED_127=1842,
ENC_UNALLOCATED_128=1843,
ENC_UNALLOCATED_129=1844,
ENC_UNALLOCATED_12_ADDSUB_EXT=1845,
ENC_UNALLOCATED_12_ASIMDALL=1846,
ENC_UNALLOCATED_12_ASIMDEXT=1847,
ENC_UNALLOCATED_12_ASIMDINS=1848,
ENC_UNALLOCATED_12_ASIMDMISCFP16=1849,
ENC_UNALLOCATED_12_ASIMDTBL=1850,
ENC_UNALLOCATED_12_ASISDDIFF=1851,
ENC_UNALLOCATED_12_ASISDLSE=1852,
ENC_UNALLOCATED_12_ASISDMISC=1853,
ENC_UNALLOCATED_12_ASISDMISCFP16=1854,
ENC_UNALLOCATED_12_ASISDONE=1855,
ENC_UNALLOCATED_12_ASISDPAIR=1856,
ENC_UNALLOCATED_12_BARRIERS=1857,
ENC_UNALLOCATED_12_BITFIELD=1858,
ENC_UNALLOCATED_12_BRANCH_REG=1859,
ENC_UNALLOCATED_12_CONDBRANCH=1860,
ENC_UNALLOCATED_12_CONDCMP_IMM=1861,
ENC_UNALLOCATED_12_CONDCMP_REG=1862,
ENC_UNALLOCATED_12_CRYPTOAES=1863,
ENC_UNALLOCATED_12_CRYPTOSHA2=1864,
ENC_UNALLOCATED_12_CRYPTOSHA3=1865,
ENC_UNALLOCATED_12_DP_1SRC=1866,
ENC_UNALLOCATED_12_EXTRACT=1867,
ENC_UNALLOCATED_12_FLOAT2FIX=1868,
ENC_UNALLOCATED_12_FLOAT2INT=1869,
ENC_UNALLOCATED_12_FLOATCCMP=1870,
ENC_UNALLOCATED_12_FLOATCMP=1871,
ENC_UNALLOCATED_12_FLOATDP1=1872,
ENC_UNALLOCATED_12_FLOATDP2=1873,
ENC_UNALLOCATED_12_FLOATDP3=1874,
ENC_UNALLOCATED_12_FLOATIMM=1875,
ENC_UNALLOCATED_12_FLOATSEL=1876,
ENC_UNALLOCATED_12_LDSTNAPAIR_OFFS=1877,
ENC_UNALLOCATED_12_SYSTEMINSTRSWITHREG=1878,
ENC_UNALLOCATED_12_SYSTEMRESULT=1879,
ENC_UNALLOCATED_130=1880,
ENC_UNALLOCATED_131=1881,
ENC_UNALLOCATED_132=1882,
ENC_UNALLOCATED_133=1883,
ENC_UNALLOCATED_134=1884,
ENC_UNALLOCATED_135=1885,
ENC_UNALLOCATED_136=1886,
ENC_UNALLOCATED_137=1887,
ENC_UNALLOCATED_138=1888,
ENC_UNALLOCATED_139=1889,
ENC_UNALLOCATED_13_ADDSUB_EXT=1890,
ENC_UNALLOCATED_13_ASIMDELEM=1891,
ENC_UNALLOCATED_13_ASIMDMISCFP16=1892,
ENC_UNALLOCATED_13_ASIMDSAME2=1893,
ENC_UNALLOCATED_13_ASIMDSHF=1894,
ENC_UNALLOCATED_13_ASISDDIFF=1895,
ENC_UNALLOCATED_13_ASISDELEM=1896,
ENC_UNALLOCATED_13_ASISDLSEP=1897,
ENC_UNALLOCATED_13_ASISDMISCFP16=1898,
ENC_UNALLOCATED_13_ASISDONE=1899,
ENC_UNALLOCATED_13_ASISDSAME2=1900,
ENC_UNALLOCATED_13_ASISDSAMEFP16=1901,
ENC_UNALLOCATED_13_BRANCH_REG=1902,
ENC_UNALLOCATED_13_CRYPTOAES=1903,
ENC_UNALLOCATED_13_DP_1SRC=1904,
ENC_UNALLOCATED_13_EXTRACT=1905,
ENC_UNALLOCATED_13_FLOAT2FIX=1906,
ENC_UNALLOCATED_13_FLOAT2INT=1907,
ENC_UNALLOCATED_13_FLOATCMP=1908,
ENC_UNALLOCATED_13_FLOATDP2=1909,
ENC_UNALLOCATED_13_FLOATIMM=1910,
ENC_UNALLOCATED_13_LDSTTAGS=1911,
ENC_UNALLOCATED_13_MOVEWIDE=1912,
ENC_UNALLOCATED_13_RMIF=1913,
ENC_UNALLOCATED_13_SYSTEMINSTRSWITHREG=1914,
ENC_UNALLOCATED_13_SYSTEMRESULT=1915,
ENC_UNALLOCATED_140=1916,
ENC_UNALLOCATED_141=1917,
ENC_UNALLOCATED_142=1918,
ENC_UNALLOCATED_143=1919,
ENC_UNALLOCATED_144=1920,
ENC_UNALLOCATED_145=1921,
ENC_UNALLOCATED_146=1922,
ENC_UNALLOCATED_147=1923,
ENC_UNALLOCATED_148=1924,
ENC_UNALLOCATED_149=1925,
ENC_UNALLOCATED_14_ADDSUB_IMMTAGS=1926,
ENC_UNALLOCATED_14_ASIMDMISC=1927,
ENC_UNALLOCATED_14_ASISDELEM=1928,
ENC_UNALLOCATED_14_ASISDLSE=1929,
ENC_UNALLOCATED_14_ASISDLSO=1930,
ENC_UNALLOCATED_14_ASISDLSOP=1931,
ENC_UNALLOCATED_14_ASISDONE=1932,
ENC_UNALLOCATED_14_ASISDSAME=1933,
ENC_UNALLOCATED_14_ASISDSAMEFP16=1934,
ENC_UNALLOCATED_14_ASISDSHF=1935,
ENC_UNALLOCATED_14_BARRIERS=1936,
ENC_UNALLOCATED_14_CRYPTO4=1937,
ENC_UNALLOCATED_14_DP_1SRC=1938,
ENC_UNALLOCATED_14_DP_2SRC=1939,
ENC_UNALLOCATED_14_DP_3SRC=1940,
ENC_UNALLOCATED_14_FLOAT2FIX=1941,
ENC_UNALLOCATED_14_FLOAT2INT=1942,
ENC_UNALLOCATED_14_FLOATCMP=1943,
ENC_UNALLOCATED_14_FLOATDP2=1944,
ENC_UNALLOCATED_14_FLOATIMM=1945,
ENC_UNALLOCATED_14_LDST_PAC=1946,
ENC_UNALLOCATED_14_RMIF=1947,
ENC_UNALLOCATED_14_SETF=1948,
ENC_UNALLOCATED_14_SYSTEMINSTRSWITHREG=1949,
ENC_UNALLOCATED_150=1950,
ENC_UNALLOCATED_151=1951,
ENC_UNALLOCATED_152=1952,
ENC_UNALLOCATED_153=1953,
ENC_UNALLOCATED_154=1954,
ENC_UNALLOCATED_154_MEMOP=1955,
ENC_UNALLOCATED_155=1956,
ENC_UNALLOCATED_155_MEMOP=1957,
ENC_UNALLOCATED_156=1958,
ENC_UNALLOCATED_156_MEMOP=1959,
ENC_UNALLOCATED_157=1960,
ENC_UNALLOCATED_158=1961,
ENC_UNALLOCATED_158_MEMOP=1962,
ENC_UNALLOCATED_159=1963,
ENC_UNALLOCATED_159_MEMOP=1964,
ENC_UNALLOCATED_15_ASIMDALL=1965,
ENC_UNALLOCATED_15_ASIMDINS=1966,
ENC_UNALLOCATED_15_ASIMDPERM=1967,
ENC_UNALLOCATED_15_ASISDDIFF=1968,
ENC_UNALLOCATED_15_ASISDMISC=1969,
ENC_UNALLOCATED_15_ASISDONE=1970,
ENC_UNALLOCATED_15_ASISDSAME=1971,
ENC_UNALLOCATED_15_ASISDSAME2=1972,
ENC_UNALLOCATED_15_BRANCH_REG=1973,
ENC_UNALLOCATED_15_DP_1SRC=1974,
ENC_UNALLOCATED_15_DP_2SRC=1975,
ENC_UNALLOCATED_15_EXCEPTION=1976,
ENC_UNALLOCATED_15_FLOAT2FIX=1977,
ENC_UNALLOCATED_15_FLOATCMP=1978,
ENC_UNALLOCATED_15_FLOATDP2=1979,
ENC_UNALLOCATED_15_FLOATIMM=1980,
ENC_UNALLOCATED_15_LDST_PAC=1981,
ENC_UNALLOCATED_15_LDSTTAGS=1982,
ENC_UNALLOCATED_15_SETF=1983,
ENC_UNALLOCATED_160=1984,
ENC_UNALLOCATED_160_MEMOP=1985,
ENC_UNALLOCATED_161=1986,
ENC_UNALLOCATED_161_MEMOP=1987,
ENC_UNALLOCATED_162=1988,
ENC_UNALLOCATED_162_MEMOP=1989,
ENC_UNALLOCATED_163=1990,
ENC_UNALLOCATED_163_MEMOP=1991,
ENC_UNALLOCATED_164=1992,
ENC_UNALLOCATED_165=1993,
ENC_UNALLOCATED_165_MEMOP=1994,
ENC_UNALLOCATED_166=1995,
ENC_UNALLOCATED_166_MEMOP=1996,
ENC_UNALLOCATED_167=1997,
ENC_UNALLOCATED_167_MEMOP=1998,
ENC_UNALLOCATED_168=1999,
ENC_UNALLOCATED_168_MEMOP=2000,
ENC_UNALLOCATED_169=2001,
ENC_UNALLOCATED_169_MEMOP=2002,
ENC_UNALLOCATED_16_ASIMDALL=2003,
ENC_UNALLOCATED_16_ASIMDELEM=2004,
ENC_UNALLOCATED_16_ASIMDSAMEFP16=2005,
ENC_UNALLOCATED_16_ASIMDSHF=2006,
ENC_UNALLOCATED_16_ASISDDIFF=2007,
ENC_UNALLOCATED_16_ASISDELEM=2008,
ENC_UNALLOCATED_16_ASISDLSE=2009,
ENC_UNALLOCATED_16_ASISDLSEP=2010,
ENC_UNALLOCATED_16_ASISDLSO=2011,
ENC_UNALLOCATED_16_ASISDLSOP=2012,
ENC_UNALLOCATED_16_ASISDMISC=2013,
ENC_UNALLOCATED_16_ASISDSAME2=2014,
ENC_UNALLOCATED_16_CRYPTOSHA2=2015,
ENC_UNALLOCATED_16_DP_1SRC=2016,
ENC_UNALLOCATED_16_DP_3SRC=2017,
ENC_UNALLOCATED_16_EXCEPTION=2018,
ENC_UNALLOCATED_16_EXTRACT=2019,
ENC_UNALLOCATED_16_FLOAT2FIX=2020,
ENC_UNALLOCATED_16_FLOATCMP=2021,
ENC_UNALLOCATED_16_FLOATIMM=2022,
ENC_UNALLOCATED_16_SETF=2023,
ENC_UNALLOCATED_170=2024,
ENC_UNALLOCATED_170_MEMOP=2025,
ENC_UNALLOCATED_171=2026,
ENC_UNALLOCATED_172=2027,
ENC_UNALLOCATED_172_MEMOP=2028,
ENC_UNALLOCATED_173=2029,
ENC_UNALLOCATED_173_MEMOP=2030,
ENC_UNALLOCATED_174=2031,
ENC_UNALLOCATED_174_MEMOP=2032,
ENC_UNALLOCATED_175=2033,
ENC_UNALLOCATED_175_MEMOP=2034,
ENC_UNALLOCATED_176=2035,
ENC_UNALLOCATED_177=2036,
ENC_UNALLOCATED_178=2037,
ENC_UNALLOCATED_179=2038,
ENC_UNALLOCATED_17_ASIMDELEM=2039,
ENC_UNALLOCATED_17_ASIMDINS=2040,
ENC_UNALLOCATED_17_ASIMDSAME2=2041,
ENC_UNALLOCATED_17_ASISDELEM=2042,
ENC_UNALLOCATED_17_ASISDONE=2043,
ENC_UNALLOCATED_17_ASISDSAME2=2044,
ENC_UNALLOCATED_17_ASISDSAMEFP16=2045,
ENC_UNALLOCATED_17_ASISDSHF=2046,
ENC_UNALLOCATED_17_BARRIERS=2047,
ENC_UNALLOCATED_17_BRANCH_REG=2048,
ENC_UNALLOCATED_17_CRYPTOSHA2=2049,
ENC_UNALLOCATED_17_DP_1SRC=2050,
ENC_UNALLOCATED_17_EXTRACT=2051,
ENC_UNALLOCATED_17_FLOAT2FIX=2052,
ENC_UNALLOCATED_17_FLOATCMP=2053,
ENC_UNALLOCATED_17_FLOATDP1=2054,
ENC_UNALLOCATED_17_FLOATIMM=2055,
ENC_UNALLOCATED_17_LOADLIT=2056,
ENC_UNALLOCATED_17_SETF=2057,
ENC_UNALLOCATED_180=2058,
ENC_UNALLOCATED_180_MEMOP=2059,
ENC_UNALLOCATED_181=2060,
ENC_UNALLOCATED_181_MEMOP=2061,
ENC_UNALLOCATED_182=2062,
ENC_UNALLOCATED_182_MEMOP=2063,
ENC_UNALLOCATED_183=2064,
ENC_UNALLOCATED_183_MEMOP=2065,
ENC_UNALLOCATED_184=2066,
ENC_UNALLOCATED_185=2067,
ENC_UNALLOCATED_185_MEMOP=2068,
ENC_UNALLOCATED_186=2069,
ENC_UNALLOCATED_186_MEMOP=2070,
ENC_UNALLOCATED_187=2071,
ENC_UNALLOCATED_187_MEMOP=2072,
ENC_UNALLOCATED_188=2073,
ENC_UNALLOCATED_188_MEMOP=2074,
ENC_UNALLOCATED_189=2075,
ENC_UNALLOCATED_189_MEMOP=2076,
ENC_UNALLOCATED_18_ASIMDINS=2077,
ENC_UNALLOCATED_18_ASIMDSAMEFP16=2078,
ENC_UNALLOCATED_18_ASISDDIFF=2079,
ENC_UNALLOCATED_18_ASISDLSO=2080,
ENC_UNALLOCATED_18_ASISDLSOP=2081,
ENC_UNALLOCATED_18_BARRIERS=2082,
ENC_UNALLOCATED_18_BRANCH_REG=2083,
ENC_UNALLOCATED_18_CRYPTOAES=2084,
ENC_UNALLOCATED_18_CRYPTOSHA2=2085,
ENC_UNALLOCATED_18_CRYPTOSHA512_3=2086,
ENC_UNALLOCATED_18_DP_1SRC=2087,
ENC_UNALLOCATED_18_DP_3SRC=2088,
ENC_UNALLOCATED_18_EXCEPTION=2089,
ENC_UNALLOCATED_18_EXTRACT=2090,
ENC_UNALLOCATED_190=2091,
ENC_UNALLOCATED_191=2092,
ENC_UNALLOCATED_192=2093,
ENC_UNALLOCATED_193=2094,
ENC_UNALLOCATED_194=2095,
ENC_UNALLOCATED_195=2096,
ENC_UNALLOCATED_196=2097,
ENC_UNALLOCATED_197=2098,
ENC_UNALLOCATED_198=2099,
ENC_UNALLOCATED_199=2100,
ENC_UNALLOCATED_19_ASIMDALL=2101,
ENC_UNALLOCATED_19_ASIMDMISCFP16=2102,
ENC_UNALLOCATED_19_ASIMDSAME2=2103,
ENC_UNALLOCATED_19_ASIMDSHF=2104,
ENC_UNALLOCATED_19_ASISDDIFF=2105,
ENC_UNALLOCATED_19_ASISDELEM=2106,
ENC_UNALLOCATED_19_ASISDLSEP=2107,
ENC_UNALLOCATED_19_ASISDMISCFP16=2108,
ENC_UNALLOCATED_19_ASISDPAIR=2109,
ENC_UNALLOCATED_19_ASISDSAMEFP16=2110,
ENC_UNALLOCATED_19_BARRIERS=2111,
ENC_UNALLOCATED_19_BITFIELD=2112,
ENC_UNALLOCATED_19_BRANCH_REG=2113,
ENC_UNALLOCATED_19_CRYPTOAES=2114,
ENC_UNALLOCATED_19_CRYPTOSHA2=2115,
ENC_UNALLOCATED_19_DP_1SRC=2116,
ENC_UNALLOCATED_19_EXCEPTION=2117,
ENC_UNALLOCATED_19_FLOATDP1=2118,
ENC_UNALLOCATED_200=2119,
ENC_UNALLOCATED_201=2120,
ENC_UNALLOCATED_202=2121,
ENC_UNALLOCATED_203=2122,
ENC_UNALLOCATED_204=2123,
ENC_UNALLOCATED_205=2124,
ENC_UNALLOCATED_206=2125,
ENC_UNALLOCATED_207=2126,
ENC_UNALLOCATED_208=2127,
ENC_UNALLOCATED_209=2128,
ENC_UNALLOCATED_20_ASIMDSAME2=2129,
ENC_UNALLOCATED_20_ASISDELEM=2130,
ENC_UNALLOCATED_20_ASISDLSE=2131,
ENC_UNALLOCATED_20_ASISDMISCFP16=2132,
ENC_UNALLOCATED_20_ASISDPAIR=2133,
ENC_UNALLOCATED_20_ASISDSHF=2134,
ENC_UNALLOCATED_20_BARRIERS=2135,
ENC_UNALLOCATED_20_BRANCH_REG=2136,
ENC_UNALLOCATED_20_CRYPTOSHA3=2137,
ENC_UNALLOCATED_20_DP_1SRC=2138,
ENC_UNALLOCATED_20_DP_2SRC=2139,
ENC_UNALLOCATED_20_DP_3SRC=2140,
ENC_UNALLOCATED_210=2141,
ENC_UNALLOCATED_211=2142,
ENC_UNALLOCATED_212=2143,
ENC_UNALLOCATED_213=2144,
ENC_UNALLOCATED_214=2145,
ENC_UNALLOCATED_215=2146,
ENC_UNALLOCATED_216=2147,
ENC_UNALLOCATED_217=2148,
ENC_UNALLOCATED_218=2149,
ENC_UNALLOCATED_219=2150,
ENC_UNALLOCATED_21_ASIMDALL=2151,
ENC_UNALLOCATED_21_ASIMDINS=2152,
ENC_UNALLOCATED_21_ASIMDSAME2=2153,
ENC_UNALLOCATED_21_ASISDDIFF=2154,
ENC_UNALLOCATED_21_ASISDLSO=2155,
ENC_UNALLOCATED_21_ASISDLSOP=2156,
ENC_UNALLOCATED_21_ASISDMISCFP16=2157,
ENC_UNALLOCATED_21_ASISDSAMEFP16=2158,
ENC_UNALLOCATED_21_BRANCH_REG=2159,
ENC_UNALLOCATED_21_DP_1SRC=2160,
ENC_UNALLOCATED_21_DP_2SRC=2161,
ENC_UNALLOCATED_21_DP_3SRC=2162,
ENC_UNALLOCATED_21_EXCEPTION=2163,
ENC_UNALLOCATED_21_LDAPSTL_UNSCALED=2164,
ENC_UNALLOCATED_21_LDST_IMMPOST=2165,
ENC_UNALLOCATED_21_LDST_IMMPRE=2166,
ENC_UNALLOCATED_21_LDST_UNPRIV=2167,
ENC_UNALLOCATED_21_LDSTNAPAIR_OFFS=2168,
ENC_UNALLOCATED_220=2169,
ENC_UNALLOCATED_221=2170,
ENC_UNALLOCATED_222=2171,
ENC_UNALLOCATED_223=2172,
ENC_UNALLOCATED_224=2173,
ENC_UNALLOCATED_225=2174,
ENC_UNALLOCATED_226=2175,
ENC_UNALLOCATED_227=2176,
ENC_UNALLOCATED_228=2177,
ENC_UNALLOCATED_229=2178,
ENC_UNALLOCATED_22_ASIMDMISCFP16=2179,
ENC_UNALLOCATED_22_ASIMDSAME2=2180,
ENC_UNALLOCATED_22_ASIMDSHF=2181,
ENC_UNALLOCATED_22_ASISDDIFF=2182,
ENC_UNALLOCATED_22_ASISDELEM=2183,
ENC_UNALLOCATED_22_ASISDLSE=2184,
ENC_UNALLOCATED_22_ASISDMISCFP16=2185,
ENC_UNALLOCATED_22_DP_3SRC=2186,
ENC_UNALLOCATED_22_EXCEPTION=2187,
ENC_UNALLOCATED_22_LDSTPAIR_OFF=2188,
ENC_UNALLOCATED_22_LDSTPAIR_POST=2189,
ENC_UNALLOCATED_22_LDSTPAIR_PRE=2190,
ENC_UNALLOCATED_230=2191,
ENC_UNALLOCATED_231=2192,
ENC_UNALLOCATED_232=2193,
ENC_UNALLOCATED_233=2194,
ENC_UNALLOCATED_234=2195,
ENC_UNALLOCATED_235=2196,
ENC_UNALLOCATED_236=2197,
ENC_UNALLOCATED_237=2198,
ENC_UNALLOCATED_238=2199,
ENC_UNALLOCATED_239=2200,
ENC_UNALLOCATED_23_ASIMDSHF=2201,
ENC_UNALLOCATED_23_ASISDELEM=2202,
ENC_UNALLOCATED_23_ASISDLSE=2203,
ENC_UNALLOCATED_23_ASISDLSO=2204,
ENC_UNALLOCATED_23_ASISDLSOP=2205,
ENC_UNALLOCATED_23_ASISDSAMEFP16=2206,
ENC_UNALLOCATED_23_ASISDSHF=2207,
ENC_UNALLOCATED_23_BRANCH_REG=2208,
ENC_UNALLOCATED_23_DP_3SRC=2209,
ENC_UNALLOCATED_23_EXCEPTION=2210,
ENC_UNALLOCATED_240=2211,
ENC_UNALLOCATED_241=2212,
ENC_UNALLOCATED_242=2213,
ENC_UNALLOCATED_243=2214,
ENC_UNALLOCATED_244=2215,
ENC_UNALLOCATED_245=2216,
ENC_UNALLOCATED_246=2217,
ENC_UNALLOCATED_247=2218,
ENC_UNALLOCATED_248=2219,
ENC_UNALLOCATED_249=2220,
ENC_UNALLOCATED_24_ASIMDALL=2221,
ENC_UNALLOCATED_24_ASIMDINS=2222,
ENC_UNALLOCATED_24_ASIMDMISC=2223,
ENC_UNALLOCATED_24_ASISDMISC=2224,
ENC_UNALLOCATED_24_ASISDSHF=2225,
ENC_UNALLOCATED_24_BRANCH_REG=2226,
ENC_UNALLOCATED_24_DP_2SRC=2227,
ENC_UNALLOCATED_24_EXCEPTION=2228,
ENC_UNALLOCATED_24_LDAPSTL_UNSCALED=2229,
ENC_UNALLOCATED_24_LDST_IMMPOST=2230,
ENC_UNALLOCATED_24_LDST_IMMPRE=2231,
ENC_UNALLOCATED_24_LDST_POS=2232,
ENC_UNALLOCATED_24_LDST_UNPRIV=2233,
ENC_UNALLOCATED_24_LDST_UNSCALED=2234,
ENC_UNALLOCATED_250=2235,
ENC_UNALLOCATED_251=2236,
ENC_UNALLOCATED_252=2237,
ENC_UNALLOCATED_253=2238,
ENC_UNALLOCATED_254=2239,
ENC_UNALLOCATED_255=2240,
ENC_UNALLOCATED_256=2241,
ENC_UNALLOCATED_257=2242,
ENC_UNALLOCATED_258=2243,
ENC_UNALLOCATED_259=2244,
ENC_UNALLOCATED_25_ASIMDELEM=2245,
ENC_UNALLOCATED_25_ASIMDSAMEFP16=2246,
ENC_UNALLOCATED_25_ASIMDSHF=2247,
ENC_UNALLOCATED_25_ASISDELEM=2248,
ENC_UNALLOCATED_25_ASISDLSE=2249,
ENC_UNALLOCATED_25_ASISDLSO=2250,
ENC_UNALLOCATED_25_ASISDLSOP=2251,
ENC_UNALLOCATED_25_ASISDPAIR=2252,
ENC_UNALLOCATED_25_ASISDSAMEFP16=2253,
ENC_UNALLOCATED_25_BARRIERS=2254,
ENC_UNALLOCATED_25_DP_2SRC=2255,
ENC_UNALLOCATED_25_DP_3SRC=2256,
ENC_UNALLOCATED_25_LDAPSTL_UNSCALED=2257,
ENC_UNALLOCATED_25_LDST_UNPRIV=2258,
ENC_UNALLOCATED_260=2259,
ENC_UNALLOCATED_261=2260,
ENC_UNALLOCATED_262=2261,
ENC_UNALLOCATED_263=2262,
ENC_UNALLOCATED_264=2263,
ENC_UNALLOCATED_265=2264,
ENC_UNALLOCATED_266=2265,
ENC_UNALLOCATED_267=2266,
ENC_UNALLOCATED_268=2267,
ENC_UNALLOCATED_269=2268,
ENC_UNALLOCATED_26_ASIMDALL=2269,
ENC_UNALLOCATED_26_ASIMDELEM=2270,
ENC_UNALLOCATED_26_ASIMDIMM=2271,
ENC_UNALLOCATED_26_ASIMDMISCFP16=2272,
ENC_UNALLOCATED_26_ASIMDSAME2=2273,
ENC_UNALLOCATED_26_ASIMDSAMEFP16=2274,
ENC_UNALLOCATED_26_ASISDELEM=2275,
ENC_UNALLOCATED_26_ASISDLSEP=2276,
ENC_UNALLOCATED_26_ASISDLSO=2277,
ENC_UNALLOCATED_26_ASISDLSOP=2278,
ENC_UNALLOCATED_26_ASISDPAIR=2279,
ENC_UNALLOCATED_26_ASISDSHF=2280,
ENC_UNALLOCATED_26_BRANCH_REG=2281,
ENC_UNALLOCATED_26_FLOATDP1=2282,
ENC_UNALLOCATED_270=2283,
ENC_UNALLOCATED_271=2284,
ENC_UNALLOCATED_272=2285,
ENC_UNALLOCATED_273=2286,
ENC_UNALLOCATED_274=2287,
ENC_UNALLOCATED_275=2288,
ENC_UNALLOCATED_276=2289,
ENC_UNALLOCATED_277=2290,
ENC_UNALLOCATED_278=2291,
ENC_UNALLOCATED_279=2292,
ENC_UNALLOCATED_27_ASIMDALL=2293,
ENC_UNALLOCATED_27_ASIMDELEM=2294,
ENC_UNALLOCATED_27_ASIMDIMM=2295,
ENC_UNALLOCATED_27_ASIMDSAME2=2296,
ENC_UNALLOCATED_27_ASISDLSE=2297,
ENC_UNALLOCATED_27_ASISDMISC=2298,
ENC_UNALLOCATED_27_ASISDPAIR=2299,
ENC_UNALLOCATED_27_ASISDSAMEFP16=2300,
ENC_UNALLOCATED_27_DP_3SRC=2301,
ENC_UNALLOCATED_280=2302,
ENC_UNALLOCATED_281=2303,
ENC_UNALLOCATED_282=2304,
ENC_UNALLOCATED_283=2305,
ENC_UNALLOCATED_284=2306,
ENC_UNALLOCATED_285=2307,
ENC_UNALLOCATED_286=2308,
ENC_UNALLOCATED_287=2309,
ENC_UNALLOCATED_288=2310,
ENC_UNALLOCATED_289=2311,
ENC_UNALLOCATED_28_ASIMDIMM=2312,
ENC_UNALLOCATED_28_ASIMDSAME2=2313,
ENC_UNALLOCATED_28_ASIMDSHF=2314,
ENC_UNALLOCATED_28_ASISDELEM=2315,
ENC_UNALLOCATED_28_BRANCH_REG=2316,
ENC_UNALLOCATED_28_DP_1SRC=2317,
ENC_UNALLOCATED_28_EXCEPTION=2318,
ENC_UNALLOCATED_28_LDST_REGOFF=2319,
ENC_UNALLOCATED_290=2320,
ENC_UNALLOCATED_291=2321,
ENC_UNALLOCATED_292=2322,
ENC_UNALLOCATED_293=2323,
ENC_UNALLOCATED_294=2324,
ENC_UNALLOCATED_295=2325,
ENC_UNALLOCATED_296=2326,
ENC_UNALLOCATED_297=2327,
ENC_UNALLOCATED_298=2328,
ENC_UNALLOCATED_299=2329,
ENC_UNALLOCATED_29_ASIMDALL=2330,
ENC_UNALLOCATED_29_ASIMDELEM=2331,
ENC_UNALLOCATED_29_ASIMDIMM=2332,
ENC_UNALLOCATED_29_ASIMDSAMEFP16=2333,
ENC_UNALLOCATED_29_ASIMDSHF=2334,
ENC_UNALLOCATED_29_ASISDELEM=2335,
ENC_UNALLOCATED_29_ASISDLSE=2336,
ENC_UNALLOCATED_29_ASISDLSEP=2337,
ENC_UNALLOCATED_29_ASISDLSO=2338,
ENC_UNALLOCATED_29_ASISDLSOP=2339,
ENC_UNALLOCATED_29_ASISDPAIR=2340,
ENC_UNALLOCATED_29_ASISDSHF=2341,
ENC_UNALLOCATED_29_BRANCH_REG=2342,
ENC_UNALLOCATED_29_DP_3SRC=2343,
ENC_UNALLOCATED_29_EXCEPTION=2344,
ENC_UNALLOCATED_300=2345,
ENC_UNALLOCATED_301=2346,
ENC_UNALLOCATED_302=2347,
ENC_UNALLOCATED_30_ASIMDIMM=2348,
ENC_UNALLOCATED_30_ASISDLSEP=2349,
ENC_UNALLOCATED_30_ASISDPAIR=2350,
ENC_UNALLOCATED_30_ASISDSAME=2351,
ENC_UNALLOCATED_30_ASISDSHF=2352,
ENC_UNALLOCATED_30_BRANCH_REG=2353,
ENC_UNALLOCATED_30_DP_3SRC=2354,
ENC_UNALLOCATED_30_EXCEPTION=2355,
ENC_UNALLOCATED_31_ASIMDIMM=2356,
ENC_UNALLOCATED_31_ASIMDSAME2=2357,
ENC_UNALLOCATED_31_ASIMDSAMEFP16=2358,
ENC_UNALLOCATED_31_ASIMDSHF=2359,
ENC_UNALLOCATED_31_ASISDLSO=2360,
ENC_UNALLOCATED_31_ASISDLSOP=2361,
ENC_UNALLOCATED_31_BRANCH_REG=2362,
ENC_UNALLOCATED_31_DP_3SRC=2363,
ENC_UNALLOCATED_31_EXCEPTION=2364,
ENC_UNALLOCATED_32_ASIMDALL=2365,
ENC_UNALLOCATED_32_ASIMDDIFF=2366,
ENC_UNALLOCATED_32_ASIMDELEM=2367,
ENC_UNALLOCATED_32_ASIMDSAME2=2368,
ENC_UNALLOCATED_32_ASISDELEM=2369,
ENC_UNALLOCATED_32_ASISDSHF=2370,
ENC_UNALLOCATED_32_BRANCH_REG=2371,
ENC_UNALLOCATED_32_DP_3SRC=2372,
ENC_UNALLOCATED_32_EXCEPTION=2373,
ENC_UNALLOCATED_33_ASIMDELEM=2374,
ENC_UNALLOCATED_33_ASIMDSAMEFP16=2375,
ENC_UNALLOCATED_33_ASISDLSE=2376,
ENC_UNALLOCATED_33_ASISDLSEP=2377,
ENC_UNALLOCATED_33_ASISDLSO=2378,
ENC_UNALLOCATED_33_ASISDLSOP=2379,
ENC_UNALLOCATED_33_ASISDMISC=2380,
ENC_UNALLOCATED_33_ASISDMISCFP16=2381,
ENC_UNALLOCATED_33_FLOATDP1=2382,
ENC_UNALLOCATED_34_ASIMDALL=2383,
ENC_UNALLOCATED_34_ASIMDDIFF=2384,
ENC_UNALLOCATED_34_ASIMDMISC=2385,
ENC_UNALLOCATED_34_ASIMDSAME2=2386,
ENC_UNALLOCATED_34_ASIMDSHF=2387,
ENC_UNALLOCATED_34_ASISDLSO=2388,
ENC_UNALLOCATED_34_ASISDLSOP=2389,
ENC_UNALLOCATED_34_ASISDMISC=2390,
ENC_UNALLOCATED_34_BRANCH_REG=2391,
ENC_UNALLOCATED_34_DP_1SRC=2392,
ENC_UNALLOCATED_34_DP_2SRC=2393,
ENC_UNALLOCATED_34_FLOATDP1=2394,
ENC_UNALLOCATED_35_ASIMDALL=2395,
ENC_UNALLOCATED_35_ASIMDSAME2=2396,
ENC_UNALLOCATED_35_ASISDELEM=2397,
ENC_UNALLOCATED_35_ASISDLSE=2398,
ENC_UNALLOCATED_35_ASISDMISC=2399,
ENC_UNALLOCATED_35_ASISDSAME=2400,
ENC_UNALLOCATED_35_ASISDSHF=2401,
ENC_UNALLOCATED_35_BRANCH_REG=2402,
ENC_UNALLOCATED_35_DP_2SRC=2403,
ENC_UNALLOCATED_35_LDST_IMMPOST=2404,
ENC_UNALLOCATED_35_LDST_IMMPRE=2405,
ENC_UNALLOCATED_35_LDST_POS=2406,
ENC_UNALLOCATED_35_LDST_UNSCALED=2407,
ENC_UNALLOCATED_36_ASISDLSE=2408,
ENC_UNALLOCATED_36_ASISDLSEP=2409,
ENC_UNALLOCATED_36_ASISDMISC=2410,
ENC_UNALLOCATED_36_ASISDSHF=2411,
ENC_UNALLOCATED_36_DP_2SRC=2412,
ENC_UNALLOCATED_36_LDST_IMMPOST=2413,
ENC_UNALLOCATED_36_LDST_IMMPRE=2414,
ENC_UNALLOCATED_36_LDST_POS=2415,
ENC_UNALLOCATED_36_LDST_UNSCALED=2416,
ENC_UNALLOCATED_37_ASIMDMISC=2417,
ENC_UNALLOCATED_37_ASISDELEM=2418,
ENC_UNALLOCATED_37_ASISDLSO=2419,
ENC_UNALLOCATED_37_ASISDLSOP=2420,
ENC_UNALLOCATED_37_BRANCH_REG=2421,
ENC_UNALLOCATED_38_ASIMDDIFF=2422,
ENC_UNALLOCATED_38_ASIMDSAME2=2423,
ENC_UNALLOCATED_38_ASISDMISC=2424,
ENC_UNALLOCATED_38_ASISDMISCFP16=2425,
ENC_UNALLOCATED_38_ASISDSHF=2426,
ENC_UNALLOCATED_38_DP_2SRC=2427,
ENC_UNALLOCATED_39_ASIMDALL=2428,
ENC_UNALLOCATED_39_ASIMDELEM=2429,
ENC_UNALLOCATED_39_ASISDELEM=2430,
ENC_UNALLOCATED_39_ASISDLSEP=2431,
ENC_UNALLOCATED_39_ASISDLSO=2432,
ENC_UNALLOCATED_39_ASISDLSOP=2433,
ENC_UNALLOCATED_39_ASISDMISCFP16=2434,
ENC_UNALLOCATED_39_BRANCH_REG=2435,
ENC_UNALLOCATED_39_FLOAT2INT=2436,
ENC_UNALLOCATED_40_ASIMDALL=2437,
ENC_UNALLOCATED_40_ASIMDDIFF=2438,
ENC_UNALLOCATED_40_ASIMDELEM=2439,
ENC_UNALLOCATED_40_BRANCH_REG=2440,
ENC_UNALLOCATED_40_FLOAT2INT=2441,
ENC_UNALLOCATED_40_FLOATDP1=2442,
ENC_UNALLOCATED_41_ASIMDDIFF=2443,
ENC_UNALLOCATED_41_ASIMDMISCFP16=2444,
ENC_UNALLOCATED_41_ASISDLSO=2445,
ENC_UNALLOCATED_41_ASISDLSOP=2446,
ENC_UNALLOCATED_41_ASISDMISC=2447,
ENC_UNALLOCATED_41_ASISDMISCFP16=2448,
ENC_UNALLOCATED_41_BRANCH_REG=2449,
ENC_UNALLOCATED_41_FLOAT2INT=2450,
ENC_UNALLOCATED_41_LDST_REGOFF=2451,
ENC_UNALLOCATED_42_ASIMDELEM=2452,
ENC_UNALLOCATED_42_ASIMDSAMEFP16=2453,
ENC_UNALLOCATED_42_ASISDELEM=2454,
ENC_UNALLOCATED_42_ASISDLSO=2455,
ENC_UNALLOCATED_42_ASISDLSOP=2456,
ENC_UNALLOCATED_42_ASISDMISC=2457,
ENC_UNALLOCATED_42_BRANCH_REG=2458,
ENC_UNALLOCATED_42_LDST_REGOFF=2459,
ENC_UNALLOCATED_43_ASIMDMISC=2460,
ENC_UNALLOCATED_43_ASISDELEM=2461,
ENC_UNALLOCATED_43_ASISDSAME=2462,
ENC_UNALLOCATED_43_BRANCH_REG=2463,
ENC_UNALLOCATED_44_ASIMDELEM=2464,
ENC_UNALLOCATED_44_ASISDMISC=2465,
ENC_UNALLOCATED_44_ASISDSHF=2466,
ENC_UNALLOCATED_44_BRANCH_REG=2467,
ENC_UNALLOCATED_45_ASIMDSHF=2468,
ENC_UNALLOCATED_45_ASISDLSO=2469,
ENC_UNALLOCATED_45_ASISDLSOP=2470,
ENC_UNALLOCATED_45_ASISDMISC=2471,
ENC_UNALLOCATED_45_ASISDSHF=2472,
ENC_UNALLOCATED_46_ASIMDMISC=2473,
ENC_UNALLOCATED_46_ASIMDMISCFP16=2474,
ENC_UNALLOCATED_46_ASIMDSHF=2475,
ENC_UNALLOCATED_46_ASISDLSEP=2476,
ENC_UNALLOCATED_46_ASISDMISC=2477,
ENC_UNALLOCATED_46_BRANCH_REG=2478,
ENC_UNALLOCATED_47_ASIMDELEM=2479,
ENC_UNALLOCATED_47_ASIMDMISCFP16=2480,
ENC_UNALLOCATED_47_ASIMDSHF=2481,
ENC_UNALLOCATED_47_BRANCH_REG=2482,
ENC_UNALLOCATED_47_DP_2SRC=2483,
ENC_UNALLOCATED_48_ASIMDMISCFP16=2484,
ENC_UNALLOCATED_48_ASISDLSO=2485,
ENC_UNALLOCATED_48_ASISDLSOP=2486,
ENC_UNALLOCATED_48_ASISDSHF=2487,
ENC_UNALLOCATED_48_BRANCH_REG=2488,
ENC_UNALLOCATED_48_DP_2SRC=2489,
ENC_UNALLOCATED_48_FLOATDP1=2490,
ENC_UNALLOCATED_49_ASIMDMISC=2491,
ENC_UNALLOCATED_49_ASISDLSEP=2492,
ENC_UNALLOCATED_49_ASISDLSO=2493,
ENC_UNALLOCATED_49_ASISDLSOP=2494,
ENC_UNALLOCATED_49_ASISDSAME=2495,
ENC_UNALLOCATED_49_ASISDSHF=2496,
ENC_UNALLOCATED_49_BRANCH_REG=2497,
ENC_UNALLOCATED_49_DP_2SRC=2498,
ENC_UNALLOCATED_50_ASIMDSHF=2499,
ENC_UNALLOCATED_50_ASISDLSEP=2500,
ENC_UNALLOCATED_50_DP_2SRC=2501,
ENC_UNALLOCATED_51_ASIMDSHF=2502,
ENC_UNALLOCATED_51_ASISDLSO=2503,
ENC_UNALLOCATED_51_ASISDLSOP=2504,
ENC_UNALLOCATED_51_ASISDSAME=2505,
ENC_UNALLOCATED_51_BRANCH_REG=2506,
ENC_UNALLOCATED_51_DP_2SRC=2507,
ENC_UNALLOCATED_52_BRANCH_REG=2508,
ENC_UNALLOCATED_53_ASIMDELEM=2509,
ENC_UNALLOCATED_53_ASIMDMISC=2510,
ENC_UNALLOCATED_53_BRANCH_REG=2511,
ENC_UNALLOCATED_54_ASISDLSO=2512,
ENC_UNALLOCATED_54_ASISDLSOP=2513,
ENC_UNALLOCATED_55_ASIMDELEM=2514,
ENC_UNALLOCATED_55_BRANCH_REG=2515,
ENC_UNALLOCATED_55_FLOATDP1=2516,
ENC_UNALLOCATED_56_ASISDLSO=2517,
ENC_UNALLOCATED_56_ASISDLSOP=2518,
ENC_UNALLOCATED_56_BRANCH_REG=2519,
ENC_UNALLOCATED_56_FLOATDP1=2520,
ENC_UNALLOCATED_57_ASIMDELEM=2521,
ENC_UNALLOCATED_57_ASIMDMISC=2522,
ENC_UNALLOCATED_57_ASISDMISC=2523,
ENC_UNALLOCATED_57_BRANCH_REG=2524,
ENC_UNALLOCATED_57_FLOATDP1=2525,
ENC_UNALLOCATED_58_ASIMDMISC=2526,
ENC_UNALLOCATED_58_ASISDLSO=2527,
ENC_UNALLOCATED_58_ASISDLSOP=2528,
ENC_UNALLOCATED_58_ASISDSAME=2529,
ENC_UNALLOCATED_58_BRANCH_REG=2530,
ENC_UNALLOCATED_59_ASISDLSO=2531,
ENC_UNALLOCATED_59_ASISDLSOP=2532,
ENC_UNALLOCATED_59_BRANCH_REG=2533,
ENC_UNALLOCATED_60_ASIMDMISC=2534,
ENC_UNALLOCATED_60_BRANCH_REG=2535,
ENC_UNALLOCATED_61_ASIMDMISC=2536,
ENC_UNALLOCATED_61_ASISDLSO=2537,
ENC_UNALLOCATED_61_ASISDLSOP=2538,
ENC_UNALLOCATED_61_ASISDSAME=2539,
ENC_UNALLOCATED_61_BRANCH_REG=2540,
ENC_UNALLOCATED_62_ASISDMISC=2541,
ENC_UNALLOCATED_63_ASISDMISC=2542,
ENC_UNALLOCATED_63_ASISDSAME=2543,
ENC_UNALLOCATED_63_BRANCH_REG=2544,
ENC_UNALLOCATED_64_ASIMDSAME=2545,
ENC_UNALLOCATED_64_ASISDLSO=2546,
ENC_UNALLOCATED_64_ASISDLSOP=2547,
ENC_UNALLOCATED_64_BRANCH_REG=2548,
ENC_UNALLOCATED_64_FLOATDP1=2549,
ENC_UNALLOCATED_65_ASIMDMISC=2550,
ENC_UNALLOCATED_65_ASISDMISC=2551,
ENC_UNALLOCATED_65_ASISDSAME=2552,
ENC_UNALLOCATED_65_BRANCH_REG=2553,
ENC_UNALLOCATED_66_ASISDLSO=2554,
ENC_UNALLOCATED_66_ASISDLSOP=2555,
ENC_UNALLOCATED_66_BRANCH_REG=2556,
ENC_UNALLOCATED_67_BRANCH_REG=2557,
ENC_UNALLOCATED_68_ASISDLSO=2558,
ENC_UNALLOCATED_68_ASISDLSOP=2559,
ENC_UNALLOCATED_68_BRANCH_REG=2560,
ENC_UNALLOCATED_68_FLOAT2INT=2561,
ENC_UNALLOCATED_69_ASISDLSO=2562,
ENC_UNALLOCATED_69_ASISDLSOP=2563,
ENC_UNALLOCATED_69_FLOAT2INT=2564,
ENC_UNALLOCATED_70_FLOATDP1=2565,
ENC_UNALLOCATED_71_ASIMDSAME=2566,
ENC_UNALLOCATED_71_ASISDLSO=2567,
ENC_UNALLOCATED_71_ASISDLSOP=2568,
ENC_UNALLOCATED_71_BRANCH_REG=2569,
ENC_UNALLOCATED_71_FLOAT2INT=2570,
ENC_UNALLOCATED_72_BRANCH_REG=2571,
ENC_UNALLOCATED_72_FLOAT2INT=2572,
ENC_UNALLOCATED_73_BRANCH_REG=2573,
ENC_UNALLOCATED_73_FLOAT2INT=2574,
ENC_UNALLOCATED_73_FLOATDP1=2575,
ENC_UNALLOCATED_74_ASIMDSAME=2576,
ENC_UNALLOCATED_74_ASISDLSO=2577,
ENC_UNALLOCATED_74_ASISDLSOP=2578,
ENC_UNALLOCATED_74_BRANCH_REG=2579,
ENC_UNALLOCATED_75_BRANCH_REG=2580,
ENC_UNALLOCATED_76_ASISDLSO=2581,
ENC_UNALLOCATED_76_ASISDLSOP=2582,
ENC_UNALLOCATED_76_FLOAT2INT=2583,
ENC_UNALLOCATED_77_FLOAT2INT=2584,
ENC_UNALLOCATED_78_ASISDLSO=2585,
ENC_UNALLOCATED_78_ASISDLSOP=2586,
ENC_UNALLOCATED_78_BRANCH_REG=2587,
ENC_UNALLOCATED_78_FLOAT2INT=2588,
ENC_UNALLOCATED_79_ASISDLSO=2589,
ENC_UNALLOCATED_79_ASISDLSOP=2590,
ENC_UNALLOCATED_79_BRANCH_REG=2591,
ENC_UNALLOCATED_79_FLOAT2INT=2592,
ENC_UNALLOCATED_80_BRANCH_REG=2593,
ENC_UNALLOCATED_80_FLOAT2INT=2594,
ENC_UNALLOCATED_81_ASIMDSAME=2595,
ENC_UNALLOCATED_81_ASISDLSO=2596,
ENC_UNALLOCATED_81_ASISDLSOP=2597,
ENC_UNALLOCATED_81_BRANCH_REG=2598,
ENC_UNALLOCATED_82_ASIMDSAME=2599,
ENC_UNALLOCATED_82_BRANCH_REG=2600,
ENC_UNALLOCATED_83_BRANCH_REG=2601,
ENC_UNALLOCATED_85_ASIMDSAME=2602,
ENC_UNALLOCATED_88_ASIMDMISC=2603,
ENC_UNALLOCATED_88_ASIMDSAME=2604,
ENC_UNALLOCATED_91_ASIMDMISC=2605,
ENC_UNALLOCATED_91_ASIMDSAME=2606,
ENC_UQADD_ASIMDSAME_ONLY=2607,
ENC_UQADD_ASISDSAME_ONLY=2608,
ENC_UQRSHL_ASIMDSAME_ONLY=2609,
ENC_UQRSHL_ASISDSAME_ONLY=2610,
ENC_UQRSHRN_ASIMDSHF_N=2611,
ENC_UQRSHRN_ASISDSHF_N=2612,
ENC_UQSHL_ASIMDSAME_ONLY=2613,
ENC_UQSHL_ASIMDSHF_R=2614,
ENC_UQSHL_ASISDSAME_ONLY=2615,
ENC_UQSHL_ASISDSHF_R=2616,
ENC_UQSHRN_ASIMDSHF_N=2617,
ENC_UQSHRN_ASISDSHF_N=2618,
ENC_UQSUB_ASIMDSAME_ONLY=2619,
ENC_UQSUB_ASISDSAME_ONLY=2620,
ENC_UQXTN_ASIMDMISC_N=2621,
ENC_UQXTN_ASISDMISC_N=2622,
ENC_URECPE_ASIMDMISC_R=2623,
ENC_URHADD_ASIMDSAME_ONLY=2624,
ENC_URSHL_ASIMDSAME_ONLY=2625,
ENC_URSHL_ASISDSAME_ONLY=2626,
ENC_URSHR_ASIMDSHF_R=2627,
ENC_URSHR_ASISDSHF_R=2628,
ENC_URSQRTE_ASIMDMISC_R=2629,
ENC_URSRA_ASIMDSHF_R=2630,
ENC_URSRA_ASISDSHF_R=2631,
ENC_USDOT_ASIMDELEM_D=2632,
ENC_USDOT_ASIMDSAME2_D=2633,
ENC_USHLL_ASIMDSHF_L=2634,
ENC_USHL_ASIMDSAME_ONLY=2635,
ENC_USHL_ASISDSAME_ONLY=2636,
ENC_USHR_ASIMDSHF_R=2637,
ENC_USHR_ASISDSHF_R=2638,
ENC_USMMLA_ASIMDSAME2_G=2639,
ENC_USQADD_ASIMDMISC_R=2640,
ENC_USQADD_ASISDMISC_R=2641,
ENC_USRA_ASIMDSHF_R=2642,
ENC_USRA_ASISDSHF_R=2643,
ENC_USUBL_ASIMDDIFF_L=2644,
ENC_USUBW_ASIMDDIFF_W=2645,
ENC_UXTB_UBFM_32M_BITFIELD=2646,
ENC_UXTH_UBFM_32M_BITFIELD=2647,
ENC_UXTL_USHLL_ASIMDSHF_L=2648,
ENC_UZP1_ASIMDPERM_ONLY=2649,
ENC_UZP2_ASIMDPERM_ONLY=2650,
ENC_WFET_ONLY_SYSTEMINSTRSWITHREG=2651,
ENC_WFE_HI_HINTS=2652,
ENC_WFIT_ONLY_SYSTEMINSTRSWITHREG=2653,
ENC_WFI_HI_HINTS=2654,
ENC_XAFLAG_M_PSTATE=2655,
ENC_XAR_VVV2_CRYPTO3_IMM6=2656,
ENC_XPACD_64Z_DP_1SRC=2657,
ENC_XPACI_64Z_DP_1SRC=2658,
ENC_XPACLRI_HI_HINTS=2659,
ENC_XTN_ASIMDMISC_N=2660,
ENC_YIELD_HI_HINTS=2661,
ENC_ZIP1_ASIMDPERM_ONLY=2662,
ENC_ZIP2_ASIMDPERM_ONLY=2663,
ENC_ABS_Z_P_Z_=2664,
ENC_ADCLB_Z_ZZZ_=2665,
ENC_ADCLT_Z_ZZZ_=2666,
ENC_ADD_Z_P_ZZ_=2667,
ENC_ADD_Z_ZI_=2668,
ENC_ADD_Z_ZZ_=2669,
ENC_ADDHNB_Z_ZZ_=2670,
ENC_ADDHNT_Z_ZZ_=2671,
ENC_ADDP_Z_P_ZZ_=2672,
ENC_ADDPL_R_RI_=2673,
ENC_ADDVL_R_RI_=2674,
ENC_ADR_Z_AZ_D_S32_SCALED=2675,
ENC_ADR_Z_AZ_D_U32_SCALED=2676,
ENC_ADR_Z_AZ_SD_SAME_SCALED=2677,
ENC_AESD_Z_ZZ_=2678,
ENC_AESE_Z_ZZ_=2679,
ENC_AESIMC_Z_Z_=2680,
ENC_AESMC_Z_Z_=2681,
ENC_AND_P_P_PP_Z=2682,
ENC_AND_Z_P_ZZ_=2683,
ENC_AND_Z_ZI_=2684,
ENC_AND_Z_ZZ_=2685,
ENC_ANDS_P_P_PP_Z=2686,
ENC_ANDV_R_P_Z_=2687,
ENC_ASR_Z_P_ZI_=2688,
ENC_ASR_Z_P_ZW_=2689,
ENC_ASR_Z_P_ZZ_=2690,
ENC_ASR_Z_ZI_=2691,
ENC_ASR_Z_ZW_=2692,
ENC_ASRD_Z_P_ZI_=2693,
ENC_ASRR_Z_P_ZZ_=2694,
ENC_BCAX_Z_ZZZ_=2695,
ENC_BDEP_Z_ZZ_=2696,
ENC_BEXT_Z_ZZ_=2697,
ENC_BFCVT_Z_P_Z_S2BF=2698,
ENC_BFCVTNT_Z_P_Z_S2BF=2699,
ENC_BFDOT_Z_ZZZ_=2700,
ENC_BFDOT_Z_ZZZI_=2701,
ENC_BFMLALB_Z_ZZZ_=2702,
ENC_BFMLALB_Z_ZZZI_=2703,
ENC_BFMLALT_Z_ZZZ_=2704,
ENC_BFMLALT_Z_ZZZI_=2705,
ENC_BFMMLA_Z_ZZZ_=2706,
ENC_BGRP_Z_ZZ_=2707,
ENC_BIC_P_P_PP_Z=2708,
ENC_BIC_Z_P_ZZ_=2709,
ENC_BIC_Z_ZZ_=2710,
ENC_BICS_P_P_PP_Z=2711,
ENC_BRKA_P_P_P_=2712,
ENC_BRKAS_P_P_P_Z=2713,
ENC_BRKB_P_P_P_=2714,
ENC_BRKBS_P_P_P_Z=2715,
ENC_BRKN_P_P_PP_=2716,
ENC_BRKNS_P_P_PP_=2717,
ENC_BRKPA_P_P_PP_=2718,
ENC_BRKPAS_P_P_PP_=2719,
ENC_BRKPB_P_P_PP_=2720,
ENC_BRKPBS_P_P_PP_=2721,
ENC_BSL1N_Z_ZZZ_=2722,
ENC_BSL2N_Z_ZZZ_=2723,
ENC_BSL_Z_ZZZ_=2724,
ENC_CADD_Z_ZZ_=2725,
ENC_CDOT_Z_ZZZ_=2726,
ENC_CDOT_Z_ZZZI_D=2727,
ENC_CDOT_Z_ZZZI_S=2728,
ENC_CLASTA_R_P_Z_=2729,
ENC_CLASTA_V_P_Z_=2730,
ENC_CLASTA_Z_P_ZZ_=2731,
ENC_CLASTB_R_P_Z_=2732,
ENC_CLASTB_V_P_Z_=2733,
ENC_CLASTB_Z_P_ZZ_=2734,
ENC_CLS_Z_P_Z_=2735,
ENC_CLZ_Z_P_Z_=2736,
ENC_CMLA_Z_ZZZ_=2737,
ENC_CMLA_Z_ZZZI_H=2738,
ENC_CMLA_Z_ZZZI_S=2739,
ENC_CMPEQ_P_P_ZI_=2740,
ENC_CMPEQ_P_P_ZW_=2741,
ENC_CMPEQ_P_P_ZZ_=2742,
ENC_CMPGE_P_P_ZI_=2743,
ENC_CMPGE_P_P_ZW_=2744,
ENC_CMPGE_P_P_ZZ_=2745,
ENC_CMPGT_P_P_ZI_=2746,
ENC_CMPGT_P_P_ZW_=2747,
ENC_CMPGT_P_P_ZZ_=2748,
ENC_CMPHI_P_P_ZI_=2749,
ENC_CMPHI_P_P_ZW_=2750,
ENC_CMPHI_P_P_ZZ_=2751,
ENC_CMPHS_P_P_ZI_=2752,
ENC_CMPHS_P_P_ZW_=2753,
ENC_CMPHS_P_P_ZZ_=2754,
ENC_CMPLE_P_P_ZI_=2755,
ENC_CMPLE_P_P_ZW_=2756,
ENC_CMPLO_P_P_ZI_=2757,
ENC_CMPLO_P_P_ZW_=2758,
ENC_CMPLS_P_P_ZI_=2759,
ENC_CMPLS_P_P_ZW_=2760,
ENC_CMPLT_P_P_ZI_=2761,
ENC_CMPLT_P_P_ZW_=2762,
ENC_CMPNE_P_P_ZI_=2763,
ENC_CMPNE_P_P_ZW_=2764,
ENC_CMPNE_P_P_ZZ_=2765,
ENC_CNOT_Z_P_Z_=2766,
ENC_CNT_Z_P_Z_=2767,
ENC_CNTB_R_S_=2768,
ENC_CNTD_R_S_=2769,
ENC_CNTH_R_S_=2770,
ENC_CNTP_R_P_P_=2771,
ENC_CNTW_R_S_=2772,
ENC_COMPACT_Z_P_Z_=2773,
ENC_CPY_Z_O_I_=2774,
ENC_CPY_Z_P_I_=2775,
ENC_CPY_Z_P_R_=2776,
ENC_CPY_Z_P_V_=2777,
ENC_CTERMEQ_RR_=2778,
ENC_CTERMNE_RR_=2779,
ENC_DECB_R_RS_=2780,
ENC_DECD_R_RS_=2781,
ENC_DECD_Z_ZS_=2782,
ENC_DECH_R_RS_=2783,
ENC_DECH_Z_ZS_=2784,
ENC_DECP_R_P_R_=2785,
ENC_DECP_Z_P_Z_=2786,
ENC_DECW_R_RS_=2787,
ENC_DECW_Z_ZS_=2788,
ENC_DUP_Z_I_=2789,
ENC_DUP_Z_R_=2790,
ENC_DUP_Z_ZI_=2791,
ENC_DUPM_Z_I_=2792,
ENC_EOR3_Z_ZZZ_=2793,
ENC_EOR_P_P_PP_Z=2794,
ENC_EOR_Z_P_ZZ_=2795,
ENC_EOR_Z_ZI_=2796,
ENC_EOR_Z_ZZ_=2797,
ENC_EORBT_Z_ZZ_=2798,
ENC_EORS_P_P_PP_Z=2799,
ENC_EORTB_Z_ZZ_=2800,
ENC_EORV_R_P_Z_=2801,
ENC_EXT_Z_ZI_CON=2802,
ENC_EXT_Z_ZI_DES=2803,
ENC_FABD_Z_P_ZZ_=2804,
ENC_FABS_Z_P_Z_=2805,
ENC_FACGE_P_P_ZZ_=2806,
ENC_FACGT_P_P_ZZ_=2807,
ENC_FADD_Z_P_ZS_=2808,
ENC_FADD_Z_P_ZZ_=2809,
ENC_FADD_Z_ZZ_=2810,
ENC_FADDA_V_P_Z_=2811,
ENC_FADDP_Z_P_ZZ_=2812,
ENC_FADDV_V_P_Z_=2813,
ENC_FCADD_Z_P_ZZ_=2814,
ENC_FCMEQ_P_P_Z0_=2815,
ENC_FCMEQ_P_P_ZZ_=2816,
ENC_FCMGE_P_P_Z0_=2817,
ENC_FCMGE_P_P_ZZ_=2818,
ENC_FCMGT_P_P_Z0_=2819,
ENC_FCMGT_P_P_ZZ_=2820,
ENC_FCMLA_Z_P_ZZZ_=2821,
ENC_FCMLA_Z_ZZZI_H=2822,
ENC_FCMLA_Z_ZZZI_S=2823,
ENC_FCMLE_P_P_Z0_=2824,
ENC_FCMLT_P_P_Z0_=2825,
ENC_FCMNE_P_P_Z0_=2826,
ENC_FCMNE_P_P_ZZ_=2827,
ENC_FCMUO_P_P_ZZ_=2828,
ENC_FCPY_Z_P_I_=2829,
ENC_FCVT_Z_P_Z_D2H=2830,
ENC_FCVT_Z_P_Z_D2S=2831,
ENC_FCVT_Z_P_Z_H2D=2832,
ENC_FCVT_Z_P_Z_H2S=2833,
ENC_FCVT_Z_P_Z_S2D=2834,
ENC_FCVT_Z_P_Z_S2H=2835,
ENC_FCVTLT_Z_P_Z_H2S=2836,
ENC_FCVTLT_Z_P_Z_S2D=2837,
ENC_FCVTNT_Z_P_Z_D2S=2838,
ENC_FCVTNT_Z_P_Z_S2H=2839,
ENC_FCVTX_Z_P_Z_D2S=2840,
ENC_FCVTXNT_Z_P_Z_D2S=2841,
ENC_FCVTZS_Z_P_Z_D2W=2842,
ENC_FCVTZS_Z_P_Z_D2X=2843,
ENC_FCVTZS_Z_P_Z_FP162H=2844,
ENC_FCVTZS_Z_P_Z_FP162W=2845,
ENC_FCVTZS_Z_P_Z_FP162X=2846,
ENC_FCVTZS_Z_P_Z_S2W=2847,
ENC_FCVTZS_Z_P_Z_S2X=2848,
ENC_FCVTZU_Z_P_Z_D2W=2849,
ENC_FCVTZU_Z_P_Z_D2X=2850,
ENC_FCVTZU_Z_P_Z_FP162H=2851,
ENC_FCVTZU_Z_P_Z_FP162W=2852,
ENC_FCVTZU_Z_P_Z_FP162X=2853,
ENC_FCVTZU_Z_P_Z_S2W=2854,
ENC_FCVTZU_Z_P_Z_S2X=2855,
ENC_FDIV_Z_P_ZZ_=2856,
ENC_FDIVR_Z_P_ZZ_=2857,
ENC_FDUP_Z_I_=2858,
ENC_FEXPA_Z_Z_=2859,
ENC_FLOGB_Z_P_Z_=2860,
ENC_FMAD_Z_P_ZZZ_=2861,
ENC_FMAX_Z_P_ZS_=2862,
ENC_FMAX_Z_P_ZZ_=2863,
ENC_FMAXNM_Z_P_ZS_=2864,
ENC_FMAXNM_Z_P_ZZ_=2865,
ENC_FMAXNMP_Z_P_ZZ_=2866,
ENC_FMAXNMV_V_P_Z_=2867,
ENC_FMAXP_Z_P_ZZ_=2868,
ENC_FMAXV_V_P_Z_=2869,
ENC_FMIN_Z_P_ZS_=2870,
ENC_FMIN_Z_P_ZZ_=2871,
ENC_FMINNM_Z_P_ZS_=2872,
ENC_FMINNM_Z_P_ZZ_=2873,
ENC_FMINNMP_Z_P_ZZ_=2874,
ENC_FMINNMV_V_P_Z_=2875,
ENC_FMINP_Z_P_ZZ_=2876,
ENC_FMINV_V_P_Z_=2877,
ENC_FMLA_Z_P_ZZZ_=2878,
ENC_FMLA_Z_ZZZI_D=2879,
ENC_FMLA_Z_ZZZI_H=2880,
ENC_FMLA_Z_ZZZI_S=2881,
ENC_FMLALB_Z_ZZZ_=2882,
ENC_FMLALB_Z_ZZZI_S=2883,
ENC_FMLALT_Z_ZZZ_=2884,
ENC_FMLALT_Z_ZZZI_S=2885,
ENC_FMLS_Z_P_ZZZ_=2886,
ENC_FMLS_Z_ZZZI_D=2887,
ENC_FMLS_Z_ZZZI_H=2888,
ENC_FMLS_Z_ZZZI_S=2889,
ENC_FMLSLB_Z_ZZZ_=2890,
ENC_FMLSLB_Z_ZZZI_S=2891,
ENC_FMLSLT_Z_ZZZ_=2892,
ENC_FMLSLT_Z_ZZZI_S=2893,
ENC_FMMLA_Z_ZZZ_D=2894,
ENC_FMMLA_Z_ZZZ_S=2895,
ENC_FMSB_Z_P_ZZZ_=2896,
ENC_FMUL_Z_P_ZS_=2897,
ENC_FMUL_Z_P_ZZ_=2898,
ENC_FMUL_Z_ZZ_=2899,
ENC_FMUL_Z_ZZI_D=2900,
ENC_FMUL_Z_ZZI_H=2901,
ENC_FMUL_Z_ZZI_S=2902,
ENC_FMULX_Z_P_ZZ_=2903,
ENC_FNEG_Z_P_Z_=2904,
ENC_FNMAD_Z_P_ZZZ_=2905,
ENC_FNMLA_Z_P_ZZZ_=2906,
ENC_FNMLS_Z_P_ZZZ_=2907,
ENC_FNMSB_Z_P_ZZZ_=2908,
ENC_FRECPE_Z_Z_=2909,
ENC_FRECPS_Z_ZZ_=2910,
ENC_FRECPX_Z_P_Z_=2911,
ENC_FRINTA_Z_P_Z_=2912,
ENC_FRINTI_Z_P_Z_=2913,
ENC_FRINTM_Z_P_Z_=2914,
ENC_FRINTN_Z_P_Z_=2915,
ENC_FRINTP_Z_P_Z_=2916,
ENC_FRINTX_Z_P_Z_=2917,
ENC_FRINTZ_Z_P_Z_=2918,
ENC_FRSQRTE_Z_Z_=2919,
ENC_FRSQRTS_Z_ZZ_=2920,
ENC_FSCALE_Z_P_ZZ_=2921,
ENC_FSQRT_Z_P_Z_=2922,
ENC_FSUB_Z_P_ZS_=2923,
ENC_FSUB_Z_P_ZZ_=2924,
ENC_FSUB_Z_ZZ_=2925,
ENC_FSUBR_Z_P_ZS_=2926,
ENC_FSUBR_Z_P_ZZ_=2927,
ENC_FTMAD_Z_ZZI_=2928,
ENC_FTSMUL_Z_ZZ_=2929,
ENC_FTSSEL_Z_ZZ_=2930,
ENC_HISTCNT_Z_P_ZZ_=2931,
ENC_HISTSEG_Z_ZZ_=2932,
ENC_INCB_R_RS_=2933,
ENC_INCD_R_RS_=2934,
ENC_INCD_Z_ZS_=2935,
ENC_INCH_R_RS_=2936,
ENC_INCH_Z_ZS_=2937,
ENC_INCP_R_P_R_=2938,
ENC_INCP_Z_P_Z_=2939,
ENC_INCW_R_RS_=2940,
ENC_INCW_Z_ZS_=2941,
ENC_INDEX_Z_II_=2942,
ENC_INDEX_Z_IR_=2943,
ENC_INDEX_Z_RI_=2944,
ENC_INDEX_Z_RR_=2945,
ENC_INSR_Z_R_=2946,
ENC_INSR_Z_V_=2947,
ENC_LASTA_R_P_Z_=2948,
ENC_LASTA_V_P_Z_=2949,
ENC_LASTB_R_P_Z_=2950,
ENC_LASTB_V_P_Z_=2951,
ENC_LD1B_Z_P_AI_D=2952,
ENC_LD1B_Z_P_AI_S=2953,
ENC_LD1B_Z_P_BI_U16=2954,
ENC_LD1B_Z_P_BI_U32=2955,
ENC_LD1B_Z_P_BI_U64=2956,
ENC_LD1B_Z_P_BI_U8=2957,
ENC_LD1B_Z_P_BR_U16=2958,
ENC_LD1B_Z_P_BR_U32=2959,
ENC_LD1B_Z_P_BR_U64=2960,
ENC_LD1B_Z_P_BR_U8=2961,
ENC_LD1B_Z_P_BZ_D_64_UNSCALED=2962,
ENC_LD1B_Z_P_BZ_D_X32_UNSCALED=2963,
ENC_LD1B_Z_P_BZ_S_X32_UNSCALED=2964,
ENC_LD1D_Z_P_AI_D=2965,
ENC_LD1D_Z_P_BI_U64=2966,
ENC_LD1D_Z_P_BR_U64=2967,
ENC_LD1D_Z_P_BZ_D_64_SCALED=2968,
ENC_LD1D_Z_P_BZ_D_64_UNSCALED=2969,
ENC_LD1D_Z_P_BZ_D_X32_SCALED=2970,
ENC_LD1D_Z_P_BZ_D_X32_UNSCALED=2971,
ENC_LD1H_Z_P_AI_D=2972,
ENC_LD1H_Z_P_AI_S=2973,
ENC_LD1H_Z_P_BI_U16=2974,
ENC_LD1H_Z_P_BI_U32=2975,
ENC_LD1H_Z_P_BI_U64=2976,
ENC_LD1H_Z_P_BR_U16=2977,
ENC_LD1H_Z_P_BR_U32=2978,
ENC_LD1H_Z_P_BR_U64=2979,
ENC_LD1H_Z_P_BZ_D_64_SCALED=2980,
ENC_LD1H_Z_P_BZ_D_64_UNSCALED=2981,
ENC_LD1H_Z_P_BZ_D_X32_SCALED=2982,
ENC_LD1H_Z_P_BZ_D_X32_UNSCALED=2983,
ENC_LD1H_Z_P_BZ_S_X32_SCALED=2984,
ENC_LD1H_Z_P_BZ_S_X32_UNSCALED=2985,
ENC_LD1RB_Z_P_BI_U16=2986,
ENC_LD1RB_Z_P_BI_U32=2987,
ENC_LD1RB_Z_P_BI_U64=2988,
ENC_LD1RB_Z_P_BI_U8=2989,
ENC_LD1RD_Z_P_BI_U64=2990,
ENC_LD1RH_Z_P_BI_U16=2991,
ENC_LD1RH_Z_P_BI_U32=2992,
ENC_LD1RH_Z_P_BI_U64=2993,
ENC_LD1ROB_Z_P_BI_U8=2994,
ENC_LD1ROB_Z_P_BR_CONTIGUOUS=2995,
ENC_LD1ROD_Z_P_BI_U64=2996,
ENC_LD1ROD_Z_P_BR_CONTIGUOUS=2997,
ENC_LD1ROH_Z_P_BI_U16=2998,
ENC_LD1ROH_Z_P_BR_CONTIGUOUS=2999,
ENC_LD1ROW_Z_P_BI_U32=3000,
ENC_LD1ROW_Z_P_BR_CONTIGUOUS=3001,
ENC_LD1RQB_Z_P_BI_U8=3002,
ENC_LD1RQB_Z_P_BR_CONTIGUOUS=3003,
ENC_LD1RQD_Z_P_BI_U64=3004,
ENC_LD1RQD_Z_P_BR_CONTIGUOUS=3005,
ENC_LD1RQH_Z_P_BI_U16=3006,
ENC_LD1RQH_Z_P_BR_CONTIGUOUS=3007,
ENC_LD1RQW_Z_P_BI_U32=3008,
ENC_LD1RQW_Z_P_BR_CONTIGUOUS=3009,
ENC_LD1RSB_Z_P_BI_S16=3010,
ENC_LD1RSB_Z_P_BI_S32=3011,
ENC_LD1RSB_Z_P_BI_S64=3012,
ENC_LD1RSH_Z_P_BI_S32=3013,
ENC_LD1RSH_Z_P_BI_S64=3014,
ENC_LD1RSW_Z_P_BI_S64=3015,
ENC_LD1RW_Z_P_BI_U32=3016,
ENC_LD1RW_Z_P_BI_U64=3017,
ENC_LD1SB_Z_P_AI_D=3018,
ENC_LD1SB_Z_P_AI_S=3019,
ENC_LD1SB_Z_P_BI_S16=3020,
ENC_LD1SB_Z_P_BI_S32=3021,
ENC_LD1SB_Z_P_BI_S64=3022,
ENC_LD1SB_Z_P_BR_S16=3023,
ENC_LD1SB_Z_P_BR_S32=3024,
ENC_LD1SB_Z_P_BR_S64=3025,
ENC_LD1SB_Z_P_BZ_D_64_UNSCALED=3026,
ENC_LD1SB_Z_P_BZ_D_X32_UNSCALED=3027,
ENC_LD1SB_Z_P_BZ_S_X32_UNSCALED=3028,
ENC_LD1SH_Z_P_AI_D=3029,
ENC_LD1SH_Z_P_AI_S=3030,
ENC_LD1SH_Z_P_BI_S32=3031,
ENC_LD1SH_Z_P_BI_S64=3032,
ENC_LD1SH_Z_P_BR_S32=3033,
ENC_LD1SH_Z_P_BR_S64=3034,
ENC_LD1SH_Z_P_BZ_D_64_SCALED=3035,
ENC_LD1SH_Z_P_BZ_D_64_UNSCALED=3036,
ENC_LD1SH_Z_P_BZ_D_X32_SCALED=3037,
ENC_LD1SH_Z_P_BZ_D_X32_UNSCALED=3038,
ENC_LD1SH_Z_P_BZ_S_X32_SCALED=3039,
ENC_LD1SH_Z_P_BZ_S_X32_UNSCALED=3040,
ENC_LD1SW_Z_P_AI_D=3041,
ENC_LD1SW_Z_P_BI_S64=3042,
ENC_LD1SW_Z_P_BR_S64=3043,
ENC_LD1SW_Z_P_BZ_D_64_SCALED=3044,
ENC_LD1SW_Z_P_BZ_D_64_UNSCALED=3045,
ENC_LD1SW_Z_P_BZ_D_X32_SCALED=3046,
ENC_LD1SW_Z_P_BZ_D_X32_UNSCALED=3047,
ENC_LD1W_Z_P_AI_D=3048,
ENC_LD1W_Z_P_AI_S=3049,
ENC_LD1W_Z_P_BI_U32=3050,
ENC_LD1W_Z_P_BI_U64=3051,
ENC_LD1W_Z_P_BR_U32=3052,
ENC_LD1W_Z_P_BR_U64=3053,
ENC_LD1W_Z_P_BZ_D_64_SCALED=3054,
ENC_LD1W_Z_P_BZ_D_64_UNSCALED=3055,
ENC_LD1W_Z_P_BZ_D_X32_SCALED=3056,
ENC_LD1W_Z_P_BZ_D_X32_UNSCALED=3057,
ENC_LD1W_Z_P_BZ_S_X32_SCALED=3058,
ENC_LD1W_Z_P_BZ_S_X32_UNSCALED=3059,
ENC_LD2B_Z_P_BI_CONTIGUOUS=3060,
ENC_LD2B_Z_P_BR_CONTIGUOUS=3061,
ENC_LD2D_Z_P_BI_CONTIGUOUS=3062,
ENC_LD2D_Z_P_BR_CONTIGUOUS=3063,
ENC_LD2H_Z_P_BI_CONTIGUOUS=3064,
ENC_LD2H_Z_P_BR_CONTIGUOUS=3065,
ENC_LD2W_Z_P_BI_CONTIGUOUS=3066,
ENC_LD2W_Z_P_BR_CONTIGUOUS=3067,
ENC_LD3B_Z_P_BI_CONTIGUOUS=3068,
ENC_LD3B_Z_P_BR_CONTIGUOUS=3069,
ENC_LD3D_Z_P_BI_CONTIGUOUS=3070,
ENC_LD3D_Z_P_BR_CONTIGUOUS=3071,
ENC_LD3H_Z_P_BI_CONTIGUOUS=3072,
ENC_LD3H_Z_P_BR_CONTIGUOUS=3073,
ENC_LD3W_Z_P_BI_CONTIGUOUS=3074,
ENC_LD3W_Z_P_BR_CONTIGUOUS=3075,
ENC_LD4B_Z_P_BI_CONTIGUOUS=3076,
ENC_LD4B_Z_P_BR_CONTIGUOUS=3077,
ENC_LD4D_Z_P_BI_CONTIGUOUS=3078,
ENC_LD4D_Z_P_BR_CONTIGUOUS=3079,
ENC_LD4H_Z_P_BI_CONTIGUOUS=3080,
ENC_LD4H_Z_P_BR_CONTIGUOUS=3081,
ENC_LD4W_Z_P_BI_CONTIGUOUS=3082,
ENC_LD4W_Z_P_BR_CONTIGUOUS=3083,
ENC_LDFF1B_Z_P_AI_D=3084,
ENC_LDFF1B_Z_P_AI_S=3085,
ENC_LDFF1B_Z_P_BR_U16=3086,
ENC_LDFF1B_Z_P_BR_U32=3087,
ENC_LDFF1B_Z_P_BR_U64=3088,
ENC_LDFF1B_Z_P_BR_U8=3089,
ENC_LDFF1B_Z_P_BZ_D_64_UNSCALED=3090,
ENC_LDFF1B_Z_P_BZ_D_X32_UNSCALED=3091,
ENC_LDFF1B_Z_P_BZ_S_X32_UNSCALED=3092,
ENC_LDFF1D_Z_P_AI_D=3093,
ENC_LDFF1D_Z_P_BR_U64=3094,
ENC_LDFF1D_Z_P_BZ_D_64_SCALED=3095,
ENC_LDFF1D_Z_P_BZ_D_64_UNSCALED=3096,
ENC_LDFF1D_Z_P_BZ_D_X32_SCALED=3097,
ENC_LDFF1D_Z_P_BZ_D_X32_UNSCALED=3098,
ENC_LDFF1H_Z_P_AI_D=3099,
ENC_LDFF1H_Z_P_AI_S=3100,
ENC_LDFF1H_Z_P_BR_U16=3101,
ENC_LDFF1H_Z_P_BR_U32=3102,
ENC_LDFF1H_Z_P_BR_U64=3103,
ENC_LDFF1H_Z_P_BZ_D_64_SCALED=3104,
ENC_LDFF1H_Z_P_BZ_D_64_UNSCALED=3105,
ENC_LDFF1H_Z_P_BZ_D_X32_SCALED=3106,
ENC_LDFF1H_Z_P_BZ_D_X32_UNSCALED=3107,
ENC_LDFF1H_Z_P_BZ_S_X32_SCALED=3108,
ENC_LDFF1H_Z_P_BZ_S_X32_UNSCALED=3109,
ENC_LDFF1SB_Z_P_AI_D=3110,
ENC_LDFF1SB_Z_P_AI_S=3111,
ENC_LDFF1SB_Z_P_BR_S16=3112,
ENC_LDFF1SB_Z_P_BR_S32=3113,
ENC_LDFF1SB_Z_P_BR_S64=3114,
ENC_LDFF1SB_Z_P_BZ_D_64_UNSCALED=3115,
ENC_LDFF1SB_Z_P_BZ_D_X32_UNSCALED=3116,
ENC_LDFF1SB_Z_P_BZ_S_X32_UNSCALED=3117,
ENC_LDFF1SH_Z_P_AI_D=3118,
ENC_LDFF1SH_Z_P_AI_S=3119,
ENC_LDFF1SH_Z_P_BR_S32=3120,
ENC_LDFF1SH_Z_P_BR_S64=3121,
ENC_LDFF1SH_Z_P_BZ_D_64_SCALED=3122,
ENC_LDFF1SH_Z_P_BZ_D_64_UNSCALED=3123,
ENC_LDFF1SH_Z_P_BZ_D_X32_SCALED=3124,
ENC_LDFF1SH_Z_P_BZ_D_X32_UNSCALED=3125,
ENC_LDFF1SH_Z_P_BZ_S_X32_SCALED=3126,
ENC_LDFF1SH_Z_P_BZ_S_X32_UNSCALED=3127,
ENC_LDFF1SW_Z_P_AI_D=3128,
ENC_LDFF1SW_Z_P_BR_S64=3129,
ENC_LDFF1SW_Z_P_BZ_D_64_SCALED=3130,
ENC_LDFF1SW_Z_P_BZ_D_64_UNSCALED=3131,
ENC_LDFF1SW_Z_P_BZ_D_X32_SCALED=3132,
ENC_LDFF1SW_Z_P_BZ_D_X32_UNSCALED=3133,
ENC_LDFF1W_Z_P_AI_D=3134,
ENC_LDFF1W_Z_P_AI_S=3135,
ENC_LDFF1W_Z_P_BR_U32=3136,
ENC_LDFF1W_Z_P_BR_U64=3137,
ENC_LDFF1W_Z_P_BZ_D_64_SCALED=3138,
ENC_LDFF1W_Z_P_BZ_D_64_UNSCALED=3139,
ENC_LDFF1W_Z_P_BZ_D_X32_SCALED=3140,
ENC_LDFF1W_Z_P_BZ_D_X32_UNSCALED=3141,
ENC_LDFF1W_Z_P_BZ_S_X32_SCALED=3142,
ENC_LDFF1W_Z_P_BZ_S_X32_UNSCALED=3143,
ENC_LDNF1B_Z_P_BI_U16=3144,
ENC_LDNF1B_Z_P_BI_U32=3145,
ENC_LDNF1B_Z_P_BI_U64=3146,
ENC_LDNF1B_Z_P_BI_U8=3147,
ENC_LDNF1D_Z_P_BI_U64=3148,
ENC_LDNF1H_Z_P_BI_U16=3149,
ENC_LDNF1H_Z_P_BI_U32=3150,
ENC_LDNF1H_Z_P_BI_U64=3151,
ENC_LDNF1SB_Z_P_BI_S16=3152,
ENC_LDNF1SB_Z_P_BI_S32=3153,
ENC_LDNF1SB_Z_P_BI_S64=3154,
ENC_LDNF1SH_Z_P_BI_S32=3155,
ENC_LDNF1SH_Z_P_BI_S64=3156,
ENC_LDNF1SW_Z_P_BI_S64=3157,
ENC_LDNF1W_Z_P_BI_U32=3158,
ENC_LDNF1W_Z_P_BI_U64=3159,
ENC_LDNT1B_Z_P_AR_D_64_UNSCALED=3160,
ENC_LDNT1B_Z_P_AR_S_X32_UNSCALED=3161,
ENC_LDNT1B_Z_P_BI_CONTIGUOUS=3162,
ENC_LDNT1B_Z_P_BR_CONTIGUOUS=3163,
ENC_LDNT1D_Z_P_AR_D_64_UNSCALED=3164,
ENC_LDNT1D_Z_P_BI_CONTIGUOUS=3165,
ENC_LDNT1D_Z_P_BR_CONTIGUOUS=3166,
ENC_LDNT1H_Z_P_AR_D_64_UNSCALED=3167,
ENC_LDNT1H_Z_P_AR_S_X32_UNSCALED=3168,
ENC_LDNT1H_Z_P_BI_CONTIGUOUS=3169,
ENC_LDNT1H_Z_P_BR_CONTIGUOUS=3170,
ENC_LDNT1SB_Z_P_AR_D_64_UNSCALED=3171,
ENC_LDNT1SB_Z_P_AR_S_X32_UNSCALED=3172,
ENC_LDNT1SH_Z_P_AR_D_64_UNSCALED=3173,
ENC_LDNT1SH_Z_P_AR_S_X32_UNSCALED=3174,
ENC_LDNT1SW_Z_P_AR_D_64_UNSCALED=3175,
ENC_LDNT1W_Z_P_AR_D_64_UNSCALED=3176,
ENC_LDNT1W_Z_P_AR_S_X32_UNSCALED=3177,
ENC_LDNT1W_Z_P_BI_CONTIGUOUS=3178,
ENC_LDNT1W_Z_P_BR_CONTIGUOUS=3179,
ENC_LDR_P_BI_=3180,
ENC_LDR_Z_BI_=3181,
ENC_LSL_Z_P_ZI_=3182,
ENC_LSL_Z_P_ZW_=3183,
ENC_LSL_Z_P_ZZ_=3184,
ENC_LSL_Z_ZI_=3185,
ENC_LSL_Z_ZW_=3186,
ENC_LSLR_Z_P_ZZ_=3187,
ENC_LSR_Z_P_ZI_=3188,
ENC_LSR_Z_P_ZW_=3189,
ENC_LSR_Z_P_ZZ_=3190,
ENC_LSR_Z_ZI_=3191,
ENC_LSR_Z_ZW_=3192,
ENC_LSRR_Z_P_ZZ_=3193,
ENC_MAD_Z_P_ZZZ_=3194,
ENC_MATCH_P_P_ZZ_=3195,
ENC_MLA_Z_P_ZZZ_=3196,
ENC_MLA_Z_ZZZI_D=3197,
ENC_MLA_Z_ZZZI_H=3198,
ENC_MLA_Z_ZZZI_S=3199,
ENC_MLS_Z_P_ZZZ_=3200,
ENC_MLS_Z_ZZZI_D=3201,
ENC_MLS_Z_ZZZI_H=3202,
ENC_MLS_Z_ZZZI_S=3203,
ENC_MOVPRFX_Z_P_Z_=3204,
ENC_MOVPRFX_Z_Z_=3205,
ENC_MSB_Z_P_ZZZ_=3206,
ENC_MUL_Z_P_ZZ_=3207,
ENC_MUL_Z_ZI_=3208,
ENC_MUL_Z_ZZ_=3209,
ENC_MUL_Z_ZZI_D=3210,
ENC_MUL_Z_ZZI_H=3211,
ENC_MUL_Z_ZZI_S=3212,
ENC_NAND_P_P_PP_Z=3213,
ENC_NANDS_P_P_PP_Z=3214,
ENC_NBSL_Z_ZZZ_=3215,
ENC_NEG_Z_P_Z_=3216,
ENC_NMATCH_P_P_ZZ_=3217,
ENC_NOR_P_P_PP_Z=3218,
ENC_NORS_P_P_PP_Z=3219,
ENC_NOT_Z_P_Z_=3220,
ENC_ORN_P_P_PP_Z=3221,
ENC_ORNS_P_P_PP_Z=3222,
ENC_ORR_P_P_PP_Z=3223,
ENC_ORR_Z_P_ZZ_=3224,
ENC_ORR_Z_ZI_=3225,
ENC_ORR_Z_ZZ_=3226,
ENC_ORRS_P_P_PP_Z=3227,
ENC_ORV_R_P_Z_=3228,
ENC_PFALSE_P_=3229,
ENC_PFIRST_P_P_P_=3230,
ENC_PMUL_Z_ZZ_=3231,
ENC_PMULLB_Z_ZZ_=3232,
ENC_PMULLT_Z_ZZ_=3233,
ENC_PNEXT_P_P_P_=3234,
ENC_PRFB_I_P_AI_D=3235,
ENC_PRFB_I_P_AI_S=3236,
ENC_PRFB_I_P_BI_S=3237,
ENC_PRFB_I_P_BR_S=3238,
ENC_PRFB_I_P_BZ_D_64_SCALED=3239,
ENC_PRFB_I_P_BZ_D_X32_SCALED=3240,
ENC_PRFB_I_P_BZ_S_X32_SCALED=3241,
ENC_PRFD_I_P_AI_D=3242,
ENC_PRFD_I_P_AI_S=3243,
ENC_PRFD_I_P_BI_S=3244,
ENC_PRFD_I_P_BR_S=3245,
ENC_PRFD_I_P_BZ_D_64_SCALED=3246,
ENC_PRFD_I_P_BZ_D_X32_SCALED=3247,
ENC_PRFD_I_P_BZ_S_X32_SCALED=3248,
ENC_PRFH_I_P_AI_D=3249,
ENC_PRFH_I_P_AI_S=3250,
ENC_PRFH_I_P_BI_S=3251,
ENC_PRFH_I_P_BR_S=3252,
ENC_PRFH_I_P_BZ_D_64_SCALED=3253,
ENC_PRFH_I_P_BZ_D_X32_SCALED=3254,
ENC_PRFH_I_P_BZ_S_X32_SCALED=3255,
ENC_PRFW_I_P_AI_D=3256,
ENC_PRFW_I_P_AI_S=3257,
ENC_PRFW_I_P_BI_S=3258,
ENC_PRFW_I_P_BR_S=3259,
ENC_PRFW_I_P_BZ_D_64_SCALED=3260,
ENC_PRFW_I_P_BZ_D_X32_SCALED=3261,
ENC_PRFW_I_P_BZ_S_X32_SCALED=3262,
ENC_PTEST_P_P_=3263,
ENC_PTRUE_P_S_=3264,
ENC_PTRUES_P_S_=3265,
ENC_PUNPKHI_P_P_=3266,
ENC_PUNPKLO_P_P_=3267,
ENC_RADDHNB_Z_ZZ_=3268,
ENC_RADDHNT_Z_ZZ_=3269,
ENC_RAX1_Z_ZZ_=3270,
ENC_RBIT_Z_P_Z_=3271,
ENC_RDFFR_P_F_=3272,
ENC_RDFFR_P_P_F_=3273,
ENC_RDFFRS_P_P_F_=3274,
ENC_RDVL_R_I_=3275,
ENC_REV_P_P_=3276,
ENC_REV_Z_Z_=3277,
ENC_REVB_Z_Z_=3278,
ENC_REVH_Z_Z_=3279,
ENC_REVW_Z_Z_=3280,
ENC_RSHRNB_Z_ZI_=3281,
ENC_RSHRNT_Z_ZI_=3282,
ENC_RSUBHNB_Z_ZZ_=3283,
ENC_RSUBHNT_Z_ZZ_=3284,
ENC_SABA_Z_ZZZ_=3285,
ENC_SABALB_Z_ZZZ_=3286,
ENC_SABALT_Z_ZZZ_=3287,
ENC_SABD_Z_P_ZZ_=3288,
ENC_SABDLB_Z_ZZ_=3289,
ENC_SABDLT_Z_ZZ_=3290,
ENC_SADALP_Z_P_Z_=3291,
ENC_SADDLB_Z_ZZ_=3292,
ENC_SADDLBT_Z_ZZ_=3293,
ENC_SADDLT_Z_ZZ_=3294,
ENC_SADDV_R_P_Z_=3295,
ENC_SADDWB_Z_ZZ_=3296,
ENC_SADDWT_Z_ZZ_=3297,
ENC_SBCLB_Z_ZZZ_=3298,
ENC_SBCLT_Z_ZZZ_=3299,
ENC_SCVTF_Z_P_Z_H2FP16=3300,
ENC_SCVTF_Z_P_Z_W2D=3301,
ENC_SCVTF_Z_P_Z_W2FP16=3302,
ENC_SCVTF_Z_P_Z_W2S=3303,
ENC_SCVTF_Z_P_Z_X2D=3304,
ENC_SCVTF_Z_P_Z_X2FP16=3305,
ENC_SCVTF_Z_P_Z_X2S=3306,
ENC_SDIV_Z_P_ZZ_=3307,
ENC_SDIVR_Z_P_ZZ_=3308,
ENC_SDOT_Z_ZZZ_=3309,
ENC_SDOT_Z_ZZZI_D=3310,
ENC_SDOT_Z_ZZZI_S=3311,
ENC_SEL_P_P_PP_=3312,
ENC_SEL_Z_P_ZZ_=3313,
ENC_SETFFR_F_=3314,
ENC_SHADD_Z_P_ZZ_=3315,
ENC_SHRNB_Z_ZI_=3316,
ENC_SHRNT_Z_ZI_=3317,
ENC_SHSUB_Z_P_ZZ_=3318,
ENC_SHSUBR_Z_P_ZZ_=3319,
ENC_SLI_Z_ZZI_=3320,
ENC_SM4E_Z_ZZ_=3321,
ENC_SM4EKEY_Z_ZZ_=3322,
ENC_SMAX_Z_P_ZZ_=3323,
ENC_SMAX_Z_ZI_=3324,
ENC_SMAXP_Z_P_ZZ_=3325,
ENC_SMAXV_R_P_Z_=3326,
ENC_SMIN_Z_P_ZZ_=3327,
ENC_SMIN_Z_ZI_=3328,
ENC_SMINP_Z_P_ZZ_=3329,
ENC_SMINV_R_P_Z_=3330,
ENC_SMLALB_Z_ZZZ_=3331,
ENC_SMLALB_Z_ZZZI_D=3332,
ENC_SMLALB_Z_ZZZI_S=3333,
ENC_SMLALT_Z_ZZZ_=3334,
ENC_SMLALT_Z_ZZZI_D=3335,
ENC_SMLALT_Z_ZZZI_S=3336,
ENC_SMLSLB_Z_ZZZ_=3337,
ENC_SMLSLB_Z_ZZZI_D=3338,
ENC_SMLSLB_Z_ZZZI_S=3339,
ENC_SMLSLT_Z_ZZZ_=3340,
ENC_SMLSLT_Z_ZZZI_D=3341,
ENC_SMLSLT_Z_ZZZI_S=3342,
ENC_SMMLA_Z_ZZZ_=3343,
ENC_SMULH_Z_P_ZZ_=3344,
ENC_SMULH_Z_ZZ_=3345,
ENC_SMULLB_Z_ZZ_=3346,
ENC_SMULLB_Z_ZZI_D=3347,
ENC_SMULLB_Z_ZZI_S=3348,
ENC_SMULLT_Z_ZZ_=3349,
ENC_SMULLT_Z_ZZI_D=3350,
ENC_SMULLT_Z_ZZI_S=3351,
ENC_SPLICE_Z_P_ZZ_CON=3352,
ENC_SPLICE_Z_P_ZZ_DES=3353,
ENC_SQABS_Z_P_Z_=3354,
ENC_SQADD_Z_P_ZZ_=3355,
ENC_SQADD_Z_ZI_=3356,
ENC_SQADD_Z_ZZ_=3357,
ENC_SQCADD_Z_ZZ_=3358,
ENC_SQDECB_R_RS_SX=3359,
ENC_SQDECB_R_RS_X=3360,
ENC_SQDECD_R_RS_SX=3361,
ENC_SQDECD_R_RS_X=3362,
ENC_SQDECD_Z_ZS_=3363,
ENC_SQDECH_R_RS_SX=3364,
ENC_SQDECH_R_RS_X=3365,
ENC_SQDECH_Z_ZS_=3366,
ENC_SQDECP_R_P_R_SX=3367,
ENC_SQDECP_R_P_R_X=3368,
ENC_SQDECP_Z_P_Z_=3369,
ENC_SQDECW_R_RS_SX=3370,
ENC_SQDECW_R_RS_X=3371,
ENC_SQDECW_Z_ZS_=3372,
ENC_SQDMLALB_Z_ZZZ_=3373,
ENC_SQDMLALB_Z_ZZZI_D=3374,
ENC_SQDMLALB_Z_ZZZI_S=3375,
ENC_SQDMLALBT_Z_ZZZ_=3376,
ENC_SQDMLALT_Z_ZZZ_=3377,
ENC_SQDMLALT_Z_ZZZI_D=3378,
ENC_SQDMLALT_Z_ZZZI_S=3379,
ENC_SQDMLSLB_Z_ZZZ_=3380,
ENC_SQDMLSLB_Z_ZZZI_D=3381,
ENC_SQDMLSLB_Z_ZZZI_S=3382,
ENC_SQDMLSLBT_Z_ZZZ_=3383,
ENC_SQDMLSLT_Z_ZZZ_=3384,
ENC_SQDMLSLT_Z_ZZZI_D=3385,
ENC_SQDMLSLT_Z_ZZZI_S=3386,
ENC_SQDMULH_Z_ZZ_=3387,
ENC_SQDMULH_Z_ZZI_D=3388,
ENC_SQDMULH_Z_ZZI_H=3389,
ENC_SQDMULH_Z_ZZI_S=3390,
ENC_SQDMULLB_Z_ZZ_=3391,
ENC_SQDMULLB_Z_ZZI_D=3392,
ENC_SQDMULLB_Z_ZZI_S=3393,
ENC_SQDMULLT_Z_ZZ_=3394,
ENC_SQDMULLT_Z_ZZI_D=3395,
ENC_SQDMULLT_Z_ZZI_S=3396,
ENC_SQINCB_R_RS_SX=3397,
ENC_SQINCB_R_RS_X=3398,
ENC_SQINCD_R_RS_SX=3399,
ENC_SQINCD_R_RS_X=3400,
ENC_SQINCD_Z_ZS_=3401,
ENC_SQINCH_R_RS_SX=3402,
ENC_SQINCH_R_RS_X=3403,
ENC_SQINCH_Z_ZS_=3404,
ENC_SQINCP_R_P_R_SX=3405,
ENC_SQINCP_R_P_R_X=3406,
ENC_SQINCP_Z_P_Z_=3407,
ENC_SQINCW_R_RS_SX=3408,
ENC_SQINCW_R_RS_X=3409,
ENC_SQINCW_Z_ZS_=3410,
ENC_SQNEG_Z_P_Z_=3411,
ENC_SQRDCMLAH_Z_ZZZ_=3412,
ENC_SQRDCMLAH_Z_ZZZI_H=3413,
ENC_SQRDCMLAH_Z_ZZZI_S=3414,
ENC_SQRDMLAH_Z_ZZZ_=3415,
ENC_SQRDMLAH_Z_ZZZI_D=3416,
ENC_SQRDMLAH_Z_ZZZI_H=3417,
ENC_SQRDMLAH_Z_ZZZI_S=3418,
ENC_SQRDMLSH_Z_ZZZ_=3419,
ENC_SQRDMLSH_Z_ZZZI_D=3420,
ENC_SQRDMLSH_Z_ZZZI_H=3421,
ENC_SQRDMLSH_Z_ZZZI_S=3422,
ENC_SQRDMULH_Z_ZZ_=3423,
ENC_SQRDMULH_Z_ZZI_D=3424,
ENC_SQRDMULH_Z_ZZI_H=3425,
ENC_SQRDMULH_Z_ZZI_S=3426,
ENC_SQRSHL_Z_P_ZZ_=3427,
ENC_SQRSHLR_Z_P_ZZ_=3428,
ENC_SQRSHRNB_Z_ZI_=3429,
ENC_SQRSHRNT_Z_ZI_=3430,
ENC_SQRSHRUNB_Z_ZI_=3431,
ENC_SQRSHRUNT_Z_ZI_=3432,
ENC_SQSHL_Z_P_ZI_=3433,
ENC_SQSHL_Z_P_ZZ_=3434,
ENC_SQSHLR_Z_P_ZZ_=3435,
ENC_SQSHLU_Z_P_ZI_=3436,
ENC_SQSHRNB_Z_ZI_=3437,
ENC_SQSHRNT_Z_ZI_=3438,
ENC_SQSHRUNB_Z_ZI_=3439,
ENC_SQSHRUNT_Z_ZI_=3440,
ENC_SQSUB_Z_P_ZZ_=3441,
ENC_SQSUB_Z_ZI_=3442,
ENC_SQSUB_Z_ZZ_=3443,
ENC_SQSUBR_Z_P_ZZ_=3444,
ENC_SQXTNB_Z_ZZ_=3445,
ENC_SQXTNT_Z_ZZ_=3446,
ENC_SQXTUNB_Z_ZZ_=3447,
ENC_SQXTUNT_Z_ZZ_=3448,
ENC_SRHADD_Z_P_ZZ_=3449,
ENC_SRI_Z_ZZI_=3450,
ENC_SRSHL_Z_P_ZZ_=3451,
ENC_SRSHLR_Z_P_ZZ_=3452,
ENC_SRSHR_Z_P_ZI_=3453,
ENC_SRSRA_Z_ZI_=3454,
ENC_SSHLLB_Z_ZI_=3455,
ENC_SSHLLT_Z_ZI_=3456,
ENC_SSRA_Z_ZI_=3457,
ENC_SSUBLB_Z_ZZ_=3458,
ENC_SSUBLBT_Z_ZZ_=3459,
ENC_SSUBLT_Z_ZZ_=3460,
ENC_SSUBLTB_Z_ZZ_=3461,
ENC_SSUBWB_Z_ZZ_=3462,
ENC_SSUBWT_Z_ZZ_=3463,
ENC_ST1B_Z_P_AI_D=3464,
ENC_ST1B_Z_P_AI_S=3465,
ENC_ST1B_Z_P_BI_=3466,
ENC_ST1B_Z_P_BR_=3467,
ENC_ST1B_Z_P_BZ_D_64_UNSCALED=3468,
ENC_ST1B_Z_P_BZ_D_X32_UNSCALED=3469,
ENC_ST1B_Z_P_BZ_S_X32_UNSCALED=3470,
ENC_ST1D_Z_P_AI_D=3471,
ENC_ST1D_Z_P_BI_=3472,
ENC_ST1D_Z_P_BR_=3473,
ENC_ST1D_Z_P_BZ_D_64_SCALED=3474,
ENC_ST1D_Z_P_BZ_D_64_UNSCALED=3475,
ENC_ST1D_Z_P_BZ_D_X32_SCALED=3476,
ENC_ST1D_Z_P_BZ_D_X32_UNSCALED=3477,
ENC_ST1H_Z_P_AI_D=3478,
ENC_ST1H_Z_P_AI_S=3479,
ENC_ST1H_Z_P_BI_=3480,
ENC_ST1H_Z_P_BR_=3481,
ENC_ST1H_Z_P_BZ_D_64_SCALED=3482,
ENC_ST1H_Z_P_BZ_D_64_UNSCALED=3483,
ENC_ST1H_Z_P_BZ_D_X32_SCALED=3484,
ENC_ST1H_Z_P_BZ_D_X32_UNSCALED=3485,
ENC_ST1H_Z_P_BZ_S_X32_SCALED=3486,
ENC_ST1H_Z_P_BZ_S_X32_UNSCALED=3487,
ENC_ST1W_Z_P_AI_D=3488,
ENC_ST1W_Z_P_AI_S=3489,
ENC_ST1W_Z_P_BI_=3490,
ENC_ST1W_Z_P_BR_=3491,
ENC_ST1W_Z_P_BZ_D_64_SCALED=3492,
ENC_ST1W_Z_P_BZ_D_64_UNSCALED=3493,
ENC_ST1W_Z_P_BZ_D_X32_SCALED=3494,
ENC_ST1W_Z_P_BZ_D_X32_UNSCALED=3495,
ENC_ST1W_Z_P_BZ_S_X32_SCALED=3496,
ENC_ST1W_Z_P_BZ_S_X32_UNSCALED=3497,
ENC_ST2B_Z_P_BI_CONTIGUOUS=3498,
ENC_ST2B_Z_P_BR_CONTIGUOUS=3499,
ENC_ST2D_Z_P_BI_CONTIGUOUS=3500,
ENC_ST2D_Z_P_BR_CONTIGUOUS=3501,
ENC_ST2H_Z_P_BI_CONTIGUOUS=3502,
ENC_ST2H_Z_P_BR_CONTIGUOUS=3503,
ENC_ST2W_Z_P_BI_CONTIGUOUS=3504,
ENC_ST2W_Z_P_BR_CONTIGUOUS=3505,
ENC_ST3B_Z_P_BI_CONTIGUOUS=3506,
ENC_ST3B_Z_P_BR_CONTIGUOUS=3507,
ENC_ST3D_Z_P_BI_CONTIGUOUS=3508,
ENC_ST3D_Z_P_BR_CONTIGUOUS=3509,
ENC_ST3H_Z_P_BI_CONTIGUOUS=3510,
ENC_ST3H_Z_P_BR_CONTIGUOUS=3511,
ENC_ST3W_Z_P_BI_CONTIGUOUS=3512,
ENC_ST3W_Z_P_BR_CONTIGUOUS=3513,
ENC_ST4B_Z_P_BI_CONTIGUOUS=3514,
ENC_ST4B_Z_P_BR_CONTIGUOUS=3515,
ENC_ST4D_Z_P_BI_CONTIGUOUS=3516,
ENC_ST4D_Z_P_BR_CONTIGUOUS=3517,
ENC_ST4H_Z_P_BI_CONTIGUOUS=3518,
ENC_ST4H_Z_P_BR_CONTIGUOUS=3519,
ENC_ST4W_Z_P_BI_CONTIGUOUS=3520,
ENC_ST4W_Z_P_BR_CONTIGUOUS=3521,
ENC_STNT1B_Z_P_AR_D_64_UNSCALED=3522,
ENC_STNT1B_Z_P_AR_S_X32_UNSCALED=3523,
ENC_STNT1B_Z_P_BI_CONTIGUOUS=3524,
ENC_STNT1B_Z_P_BR_CONTIGUOUS=3525,
ENC_STNT1D_Z_P_AR_D_64_UNSCALED=3526,
ENC_STNT1D_Z_P_BI_CONTIGUOUS=3527,
ENC_STNT1D_Z_P_BR_CONTIGUOUS=3528,
ENC_STNT1H_Z_P_AR_D_64_UNSCALED=3529,
ENC_STNT1H_Z_P_AR_S_X32_UNSCALED=3530,
ENC_STNT1H_Z_P_BI_CONTIGUOUS=3531,
ENC_STNT1H_Z_P_BR_CONTIGUOUS=3532,
ENC_STNT1W_Z_P_AR_D_64_UNSCALED=3533,
ENC_STNT1W_Z_P_AR_S_X32_UNSCALED=3534,
ENC_STNT1W_Z_P_BI_CONTIGUOUS=3535,
ENC_STNT1W_Z_P_BR_CONTIGUOUS=3536,
ENC_STR_P_BI_=3537,
ENC_STR_Z_BI_=3538,
ENC_SUB_Z_P_ZZ_=3539,
ENC_SUB_Z_ZI_=3540,
ENC_SUB_Z_ZZ_=3541,
ENC_SUBHNB_Z_ZZ_=3542,
ENC_SUBHNT_Z_ZZ_=3543,
ENC_SUBR_Z_P_ZZ_=3544,
ENC_SUBR_Z_ZI_=3545,
ENC_SUDOT_Z_ZZZI_S=3546,
ENC_SUNPKHI_Z_Z_=3547,
ENC_SUNPKLO_Z_Z_=3548,
ENC_SUQADD_Z_P_ZZ_=3549,
ENC_SXTB_Z_P_Z_=3550,
ENC_SXTH_Z_P_Z_=3551,
ENC_SXTW_Z_P_Z_=3552,
ENC_TBL_Z_ZZ_1=3553,
ENC_TBL_Z_ZZ_2=3554,
ENC_TBX_Z_ZZ_=3555,
ENC_TRN1_P_PP_=3556,
ENC_TRN1_Z_ZZ_=3557,
ENC_TRN1_Z_ZZ_Q=3558,
ENC_TRN2_P_PP_=3559,
ENC_TRN2_Z_ZZ_=3560,
ENC_TRN2_Z_ZZ_Q=3561,
ENC_UABA_Z_ZZZ_=3562,
ENC_UABALB_Z_ZZZ_=3563,
ENC_UABALT_Z_ZZZ_=3564,
ENC_UABD_Z_P_ZZ_=3565,
ENC_UABDLB_Z_ZZ_=3566,
ENC_UABDLT_Z_ZZ_=3567,
ENC_UADALP_Z_P_Z_=3568,
ENC_UADDLB_Z_ZZ_=3569,
ENC_UADDLT_Z_ZZ_=3570,
ENC_UADDV_R_P_Z_=3571,
ENC_UADDWB_Z_ZZ_=3572,
ENC_UADDWT_Z_ZZ_=3573,
ENC_UCVTF_Z_P_Z_H2FP16=3574,
ENC_UCVTF_Z_P_Z_W2D=3575,
ENC_UCVTF_Z_P_Z_W2FP16=3576,
ENC_UCVTF_Z_P_Z_W2S=3577,
ENC_UCVTF_Z_P_Z_X2D=3578,
ENC_UCVTF_Z_P_Z_X2FP16=3579,
ENC_UCVTF_Z_P_Z_X2S=3580,
ENC_UDIV_Z_P_ZZ_=3581,
ENC_UDIVR_Z_P_ZZ_=3582,
ENC_UDOT_Z_ZZZ_=3583,
ENC_UDOT_Z_ZZZI_D=3584,
ENC_UDOT_Z_ZZZI_S=3585,
ENC_UHADD_Z_P_ZZ_=3586,
ENC_UHSUB_Z_P_ZZ_=3587,
ENC_UHSUBR_Z_P_ZZ_=3588,
ENC_UMAX_Z_P_ZZ_=3589,
ENC_UMAX_Z_ZI_=3590,
ENC_UMAXP_Z_P_ZZ_=3591,
ENC_UMAXV_R_P_Z_=3592,
ENC_UMIN_Z_P_ZZ_=3593,
ENC_UMIN_Z_ZI_=3594,
ENC_UMINP_Z_P_ZZ_=3595,
ENC_UMINV_R_P_Z_=3596,
ENC_UMLALB_Z_ZZZ_=3597,
ENC_UMLALB_Z_ZZZI_D=3598,
ENC_UMLALB_Z_ZZZI_S=3599,
ENC_UMLALT_Z_ZZZ_=3600,
ENC_UMLALT_Z_ZZZI_D=3601,
ENC_UMLALT_Z_ZZZI_S=3602,
ENC_UMLSLB_Z_ZZZ_=3603,
ENC_UMLSLB_Z_ZZZI_D=3604,
ENC_UMLSLB_Z_ZZZI_S=3605,
ENC_UMLSLT_Z_ZZZ_=3606,
ENC_UMLSLT_Z_ZZZI_D=3607,
ENC_UMLSLT_Z_ZZZI_S=3608,
ENC_UMMLA_Z_ZZZ_=3609,
ENC_UMULH_Z_P_ZZ_=3610,
ENC_UMULH_Z_ZZ_=3611,
ENC_UMULLB_Z_ZZ_=3612,
ENC_UMULLB_Z_ZZI_D=3613,
ENC_UMULLB_Z_ZZI_S=3614,
ENC_UMULLT_Z_ZZ_=3615,
ENC_UMULLT_Z_ZZI_D=3616,
ENC_UMULLT_Z_ZZI_S=3617,
ENC_UQADD_Z_P_ZZ_=3618,
ENC_UQADD_Z_ZI_=3619,
ENC_UQADD_Z_ZZ_=3620,
ENC_UQDECB_R_RS_UW=3621,
ENC_UQDECB_R_RS_X=3622,
ENC_UQDECD_R_RS_UW=3623,
ENC_UQDECD_R_RS_X=3624,
ENC_UQDECD_Z_ZS_=3625,
ENC_UQDECH_R_RS_UW=3626,
ENC_UQDECH_R_RS_X=3627,
ENC_UQDECH_Z_ZS_=3628,
ENC_UQDECP_R_P_R_UW=3629,
ENC_UQDECP_R_P_R_X=3630,
ENC_UQDECP_Z_P_Z_=3631,
ENC_UQDECW_R_RS_UW=3632,
ENC_UQDECW_R_RS_X=3633,
ENC_UQDECW_Z_ZS_=3634,
ENC_UQINCB_R_RS_UW=3635,
ENC_UQINCB_R_RS_X=3636,
ENC_UQINCD_R_RS_UW=3637,
ENC_UQINCD_R_RS_X=3638,
ENC_UQINCD_Z_ZS_=3639,
ENC_UQINCH_R_RS_UW=3640,
ENC_UQINCH_R_RS_X=3641,
ENC_UQINCH_Z_ZS_=3642,
ENC_UQINCP_R_P_R_UW=3643,
ENC_UQINCP_R_P_R_X=3644,
ENC_UQINCP_Z_P_Z_=3645,
ENC_UQINCW_R_RS_UW=3646,
ENC_UQINCW_R_RS_X=3647,
ENC_UQINCW_Z_ZS_=3648,
ENC_UQRSHL_Z_P_ZZ_=3649,
ENC_UQRSHLR_Z_P_ZZ_=3650,
ENC_UQRSHRNB_Z_ZI_=3651,
ENC_UQRSHRNT_Z_ZI_=3652,
ENC_UQSHL_Z_P_ZI_=3653,
ENC_UQSHL_Z_P_ZZ_=3654,
ENC_UQSHLR_Z_P_ZZ_=3655,
ENC_UQSHRNB_Z_ZI_=3656,
ENC_UQSHRNT_Z_ZI_=3657,
ENC_UQSUB_Z_P_ZZ_=3658,
ENC_UQSUB_Z_ZI_=3659,
ENC_UQSUB_Z_ZZ_=3660,
ENC_UQSUBR_Z_P_ZZ_=3661,
ENC_UQXTNB_Z_ZZ_=3662,
ENC_UQXTNT_Z_ZZ_=3663,
ENC_URECPE_Z_P_Z_=3664,
ENC_URHADD_Z_P_ZZ_=3665,
ENC_URSHL_Z_P_ZZ_=3666,
ENC_URSHLR_Z_P_ZZ_=3667,
ENC_URSHR_Z_P_ZI_=3668,
ENC_URSQRTE_Z_P_Z_=3669,
ENC_URSRA_Z_ZI_=3670,
ENC_USDOT_Z_ZZZ_S=3671,
ENC_USDOT_Z_ZZZI_S=3672,
ENC_USHLLB_Z_ZI_=3673,
ENC_USHLLT_Z_ZI_=3674,
ENC_USMMLA_Z_ZZZ_=3675,
ENC_USQADD_Z_P_ZZ_=3676,
ENC_USRA_Z_ZI_=3677,
ENC_USUBLB_Z_ZZ_=3678,
ENC_USUBLT_Z_ZZ_=3679,
ENC_USUBWB_Z_ZZ_=3680,
ENC_USUBWT_Z_ZZ_=3681,
ENC_UUNPKHI_Z_Z_=3682,
ENC_UUNPKLO_Z_Z_=3683,
ENC_UXTB_Z_P_Z_=3684,
ENC_UXTH_Z_P_Z_=3685,
ENC_UXTW_Z_P_Z_=3686,
ENC_UZP1_P_PP_=3687,
ENC_UZP1_Z_ZZ_=3688,
ENC_UZP1_Z_ZZ_Q=3689,
ENC_UZP2_P_PP_=3690,
ENC_UZP2_Z_ZZ_=3691,
ENC_UZP2_Z_ZZ_Q=3692,
ENC_WHILEGE_P_P_RR_=3693,
ENC_WHILEGT_P_P_RR_=3694,
ENC_WHILEHI_P_P_RR_=3695,
ENC_WHILEHS_P_P_RR_=3696,
ENC_WHILELE_P_P_RR_=3697,
ENC_WHILELO_P_P_RR_=3698,
ENC_WHILELS_P_P_RR_=3699,
ENC_WHILELT_P_P_RR_=3700,
ENC_WHILERW_P_RR_=3701,
ENC_WHILEWR_P_RR_=3702,
ENC_WRFFR_F_P_=3703,
ENC_XAR_Z_ZZI_=3704,
ENC_ZIP1_P_PP_=3705,
ENC_ZIP1_Z_ZZ_=3706,
ENC_ZIP1_Z_ZZ_Q=3707,
ENC_ZIP2_P_PP_=3708,
ENC_ZIP2_Z_ZZ_=3709,
ENC_ZIP2_Z_ZZ_Q=3710,
};
enum Operation enc_to_oper(enum ENCODING);
enum Operation enc_to_oper2(enum ENCODING);
# 11 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 2
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/regs.h" 1
       

# 1 "/usr/local/Cellar/gcc/11.2.0_3/lib/gcc/11/gcc/x86_64-apple-darwin20/11/include/stddef.h" 1 3 4
# 4 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/regs.h" 2
# 18 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/regs.h"
enum Register {
 REG_NONE,
 REG_W0, REG_W1, REG_W2, REG_W3, REG_W4, REG_W5, REG_W6, REG_W7,
 REG_W8, REG_W9, REG_W10, REG_W11, REG_W12, REG_W13, REG_W14, REG_W15,
 REG_W16, REG_W17, REG_W18, REG_W19, REG_W20, REG_W21, REG_W22, REG_W23,
 REG_W24, REG_W25, REG_W26, REG_W27, REG_W28, REG_W29, REG_W30, REG_WZR, REG_WSP,
 REG_X0, REG_X1, REG_X2, REG_X3, REG_X4, REG_X5, REG_X6, REG_X7,
 REG_X8, REG_X9, REG_X10, REG_X11, REG_X12, REG_X13, REG_X14, REG_X15,
 REG_X16, REG_X17, REG_X18, REG_X19, REG_X20, REG_X21, REG_X22, REG_X23,
 REG_X24, REG_X25, REG_X26, REG_X27, REG_X28, REG_X29, REG_X30, REG_XZR, REG_SP,
 REG_V0, REG_V1, REG_V2, REG_V3, REG_V4, REG_V5, REG_V6, REG_V7,
 REG_V8, REG_V9, REG_V10, REG_V11, REG_V12, REG_V13, REG_V14, REG_V15,
 REG_V16, REG_V17, REG_V18, REG_V19, REG_V20, REG_V21, REG_V22, REG_V23,
 REG_V24, REG_V25, REG_V26, REG_V27, REG_V28, REG_V29, REG_V30, REG_VZR, REG_V31,
 REG_B0, REG_B1, REG_B2, REG_B3, REG_B4, REG_B5, REG_B6, REG_B7,
 REG_B8, REG_B9, REG_B10, REG_B11, REG_B12, REG_B13, REG_B14, REG_B15,
 REG_B16, REG_B17, REG_B18, REG_B19, REG_B20, REG_B21, REG_B22, REG_B23,
 REG_B24, REG_B25, REG_B26, REG_B27, REG_B28, REG_B29, REG_B30, REG_BZR, REG_B31,
 REG_H0, REG_H1, REG_H2, REG_H3, REG_H4, REG_H5, REG_H6, REG_H7,
 REG_H8, REG_H9, REG_H10, REG_H11, REG_H12, REG_H13, REG_H14, REG_H15,
 REG_H16, REG_H17, REG_H18, REG_H19, REG_H20, REG_H21, REG_H22, REG_H23,
 REG_H24, REG_H25, REG_H26, REG_H27, REG_H28, REG_H29, REG_H30, REG_HZR, REG_H31,
 REG_S0, REG_S1, REG_S2, REG_S3, REG_S4, REG_S5, REG_S6, REG_S7,
 REG_S8, REG_S9, REG_S10, REG_S11, REG_S12, REG_S13, REG_S14, REG_S15,
 REG_S16, REG_S17, REG_S18, REG_S19, REG_S20, REG_S21, REG_S22, REG_S23,
 REG_S24, REG_S25, REG_S26, REG_S27, REG_S28, REG_S29, REG_S30, REG_SZR, REG_S31,
 REG_D0, REG_D1, REG_D2, REG_D3, REG_D4, REG_D5, REG_D6, REG_D7,
 REG_D8, REG_D9, REG_D10, REG_D11, REG_D12, REG_D13, REG_D14, REG_D15,
 REG_D16, REG_D17, REG_D18, REG_D19, REG_D20, REG_D21, REG_D22, REG_D23,
 REG_D24, REG_D25, REG_D26, REG_D27, REG_D28, REG_D29, REG_D30, REG_DZR, REG_D31,
 REG_Q0, REG_Q1, REG_Q2, REG_Q3, REG_Q4, REG_Q5, REG_Q6, REG_Q7,
 REG_Q8, REG_Q9, REG_Q10, REG_Q11, REG_Q12, REG_Q13, REG_Q14, REG_Q15,
 REG_Q16, REG_Q17, REG_Q18, REG_Q19, REG_Q20, REG_Q21, REG_Q22, REG_Q23,
 REG_Q24, REG_Q25, REG_Q26, REG_Q27, REG_Q28, REG_Q29, REG_Q30, REG_QZR, REG_Q31,

 REG_V0_B0, REG_V0_B1, REG_V0_B2, REG_V0_B3, REG_V0_B4, REG_V0_B5, REG_V0_B6, REG_V0_B7,
 REG_V0_B8, REG_V0_B9, REG_V0_B10, REG_V0_B11, REG_V0_B12, REG_V0_B13, REG_V0_B14, REG_V0_B15,
 REG_V1_B0, REG_V1_B1, REG_V1_B2, REG_V1_B3, REG_V1_B4, REG_V1_B5, REG_V1_B6, REG_V1_B7,
 REG_V1_B8, REG_V1_B9, REG_V1_B10, REG_V1_B11, REG_V1_B12, REG_V1_B13, REG_V1_B14, REG_V1_B15,
 REG_V2_B0, REG_V2_B1, REG_V2_B2, REG_V2_B3, REG_V2_B4, REG_V2_B5, REG_V2_B6, REG_V2_B7,
 REG_V2_B8, REG_V2_B9, REG_V2_B10, REG_V2_B11, REG_V2_B12, REG_V2_B13, REG_V2_B14, REG_V2_B15,
 REG_V3_B0, REG_V3_B1, REG_V3_B2, REG_V3_B3, REG_V3_B4, REG_V3_B5, REG_V3_B6, REG_V3_B7,
 REG_V3_B8, REG_V3_B9, REG_V3_B10, REG_V3_B11, REG_V3_B12, REG_V3_B13, REG_V3_B14, REG_V3_B15,
 REG_V4_B0, REG_V4_B1, REG_V4_B2, REG_V4_B3, REG_V4_B4, REG_V4_B5, REG_V4_B6, REG_V4_B7,
 REG_V4_B8, REG_V4_B9, REG_V4_B10, REG_V4_B11, REG_V4_B12, REG_V4_B13, REG_V4_B14, REG_V4_B15,
 REG_V5_B0, REG_V5_B1, REG_V5_B2, REG_V5_B3, REG_V5_B4, REG_V5_B5, REG_V5_B6, REG_V5_B7,
 REG_V5_B8, REG_V5_B9, REG_V5_B10, REG_V5_B11, REG_V5_B12, REG_V5_B13, REG_V5_B14, REG_V5_B15,
 REG_V6_B0, REG_V6_B1, REG_V6_B2, REG_V6_B3, REG_V6_B4, REG_V6_B5, REG_V6_B6, REG_V6_B7,
 REG_V6_B8, REG_V6_B9, REG_V6_B10, REG_V6_B11, REG_V6_B12, REG_V6_B13, REG_V6_B14, REG_V6_B15,
 REG_V7_B0, REG_V7_B1, REG_V7_B2, REG_V7_B3, REG_V7_B4, REG_V7_B5, REG_V7_B6, REG_V7_B7,
 REG_V7_B8, REG_V7_B9, REG_V7_B10, REG_V7_B11, REG_V7_B12, REG_V7_B13, REG_V7_B14, REG_V7_B15,
 REG_V8_B0, REG_V8_B1, REG_V8_B2, REG_V8_B3, REG_V8_B4, REG_V8_B5, REG_V8_B6, REG_V8_B7,
 REG_V8_B8, REG_V8_B9, REG_V8_B10, REG_V8_B11, REG_V8_B12, REG_V8_B13, REG_V8_B14, REG_V8_B15,
 REG_V9_B0, REG_V9_B1, REG_V9_B2, REG_V9_B3, REG_V9_B4, REG_V9_B5, REG_V9_B6, REG_V9_B7,
 REG_V9_B8, REG_V9_B9, REG_V9_B10, REG_V9_B11, REG_V9_B12, REG_V9_B13, REG_V9_B14, REG_V9_B15,
 REG_V10_B0, REG_V10_B1, REG_V10_B2, REG_V10_B3, REG_V10_B4, REG_V10_B5, REG_V10_B6, REG_V10_B7,
 REG_V10_B8, REG_V10_B9, REG_V10_B10, REG_V10_B11, REG_V10_B12, REG_V10_B13, REG_V10_B14, REG_V10_B15,
 REG_V11_B0, REG_V11_B1, REG_V11_B2, REG_V11_B3, REG_V11_B4, REG_V11_B5, REG_V11_B6, REG_V11_B7,
 REG_V11_B8, REG_V11_B9, REG_V11_B10, REG_V11_B11, REG_V11_B12, REG_V11_B13, REG_V11_B14, REG_V11_B15,
 REG_V12_B0, REG_V12_B1, REG_V12_B2, REG_V12_B3, REG_V12_B4, REG_V12_B5, REG_V12_B6, REG_V12_B7,
 REG_V12_B8, REG_V12_B9, REG_V12_B10, REG_V12_B11, REG_V12_B12, REG_V12_B13, REG_V12_B14, REG_V12_B15,
 REG_V13_B0, REG_V13_B1, REG_V13_B2, REG_V13_B3, REG_V13_B4, REG_V13_B5, REG_V13_B6, REG_V13_B7,
 REG_V13_B8, REG_V13_B9, REG_V13_B10, REG_V13_B11, REG_V13_B12, REG_V13_B13, REG_V13_B14, REG_V13_B15,
 REG_V14_B0, REG_V14_B1, REG_V14_B2, REG_V14_B3, REG_V14_B4, REG_V14_B5, REG_V14_B6, REG_V14_B7,
 REG_V14_B8, REG_V14_B9, REG_V14_B10, REG_V14_B11, REG_V14_B12, REG_V14_B13, REG_V14_B14, REG_V14_B15,
 REG_V15_B0, REG_V15_B1, REG_V15_B2, REG_V15_B3, REG_V15_B4, REG_V15_B5, REG_V15_B6, REG_V15_B7,
 REG_V15_B8, REG_V15_B9, REG_V15_B10, REG_V15_B11, REG_V15_B12, REG_V15_B13, REG_V15_B14, REG_V15_B15,
 REG_V16_B0, REG_V16_B1, REG_V16_B2, REG_V16_B3, REG_V16_B4, REG_V16_B5, REG_V16_B6, REG_V16_B7,
 REG_V16_B8, REG_V16_B9, REG_V16_B10, REG_V16_B11, REG_V16_B12, REG_V16_B13, REG_V16_B14, REG_V16_B15,
 REG_V17_B0, REG_V17_B1, REG_V17_B2, REG_V17_B3, REG_V17_B4, REG_V17_B5, REG_V17_B6, REG_V17_B7,
 REG_V17_B8, REG_V17_B9, REG_V17_B10, REG_V17_B11, REG_V17_B12, REG_V17_B13, REG_V17_B14, REG_V17_B15,
 REG_V18_B0, REG_V18_B1, REG_V18_B2, REG_V18_B3, REG_V18_B4, REG_V18_B5, REG_V18_B6, REG_V18_B7,
 REG_V18_B8, REG_V18_B9, REG_V18_B10, REG_V18_B11, REG_V18_B12, REG_V18_B13, REG_V18_B14, REG_V18_B15,
 REG_V19_B0, REG_V19_B1, REG_V19_B2, REG_V19_B3, REG_V19_B4, REG_V19_B5, REG_V19_B6, REG_V19_B7,
 REG_V19_B8, REG_V19_B9, REG_V19_B10, REG_V19_B11, REG_V19_B12, REG_V19_B13, REG_V19_B14, REG_V19_B15,
 REG_V20_B0, REG_V20_B1, REG_V20_B2, REG_V20_B3, REG_V20_B4, REG_V20_B5, REG_V20_B6, REG_V20_B7,
 REG_V20_B8, REG_V20_B9, REG_V20_B10, REG_V20_B11, REG_V20_B12, REG_V20_B13, REG_V20_B14, REG_V20_B15,
 REG_V21_B0, REG_V21_B1, REG_V21_B2, REG_V21_B3, REG_V21_B4, REG_V21_B5, REG_V21_B6, REG_V21_B7,
 REG_V21_B8, REG_V21_B9, REG_V21_B10, REG_V21_B11, REG_V21_B12, REG_V21_B13, REG_V21_B14, REG_V21_B15,
 REG_V22_B0, REG_V22_B1, REG_V22_B2, REG_V22_B3, REG_V22_B4, REG_V22_B5, REG_V22_B6, REG_V22_B7,
 REG_V22_B8, REG_V22_B9, REG_V22_B10, REG_V22_B11, REG_V22_B12, REG_V22_B13, REG_V22_B14, REG_V22_B15,
 REG_V23_B0, REG_V23_B1, REG_V23_B2, REG_V23_B3, REG_V23_B4, REG_V23_B5, REG_V23_B6, REG_V23_B7,
 REG_V23_B8, REG_V23_B9, REG_V23_B10, REG_V23_B11, REG_V23_B12, REG_V23_B13, REG_V23_B14, REG_V23_B15,
 REG_V24_B0, REG_V24_B1, REG_V24_B2, REG_V24_B3, REG_V24_B4, REG_V24_B5, REG_V24_B6, REG_V24_B7,
 REG_V24_B8, REG_V24_B9, REG_V24_B10, REG_V24_B11, REG_V24_B12, REG_V24_B13, REG_V24_B14, REG_V24_B15,
 REG_V25_B0, REG_V25_B1, REG_V25_B2, REG_V25_B3, REG_V25_B4, REG_V25_B5, REG_V25_B6, REG_V25_B7,
 REG_V25_B8, REG_V25_B9, REG_V25_B10, REG_V25_B11, REG_V25_B12, REG_V25_B13, REG_V25_B14, REG_V25_B15,
 REG_V26_B0, REG_V26_B1, REG_V26_B2, REG_V26_B3, REG_V26_B4, REG_V26_B5, REG_V26_B6, REG_V26_B7,
 REG_V26_B8, REG_V26_B9, REG_V26_B10, REG_V26_B11, REG_V26_B12, REG_V26_B13, REG_V26_B14, REG_V26_B15,
 REG_V27_B0, REG_V27_B1, REG_V27_B2, REG_V27_B3, REG_V27_B4, REG_V27_B5, REG_V27_B6, REG_V27_B7,
 REG_V27_B8, REG_V27_B9, REG_V27_B10, REG_V27_B11, REG_V27_B12, REG_V27_B13, REG_V27_B14, REG_V27_B15,
 REG_V28_B0, REG_V28_B1, REG_V28_B2, REG_V28_B3, REG_V28_B4, REG_V28_B5, REG_V28_B6, REG_V28_B7,
 REG_V28_B8, REG_V28_B9, REG_V28_B10, REG_V28_B11, REG_V28_B12, REG_V28_B13, REG_V28_B14, REG_V28_B15,
 REG_V29_B0, REG_V29_B1, REG_V29_B2, REG_V29_B3, REG_V29_B4, REG_V29_B5, REG_V29_B6, REG_V29_B7,
 REG_V29_B8, REG_V29_B9, REG_V29_B10, REG_V29_B11, REG_V29_B12, REG_V29_B13, REG_V29_B14, REG_V29_B15,
 REG_V30_B0, REG_V30_B1, REG_V30_B2, REG_V30_B3, REG_V30_B4, REG_V30_B5, REG_V30_B6, REG_V30_B7,
 REG_V30_B8, REG_V30_B9, REG_V30_B10, REG_V30_B11, REG_V30_B12, REG_V30_B13, REG_V30_B14, REG_V30_B15,
 REG_V31_B0, REG_V31_B1, REG_V31_B2, REG_V31_B3, REG_V31_B4, REG_V31_B5, REG_V31_B6, REG_V31_B7,
 REG_V31_B8, REG_V31_B9, REG_V31_B10, REG_V31_B11, REG_V31_B12, REG_V31_B13, REG_V31_B14, REG_V31_B15,

 REG_V0_H0, REG_V0_H1, REG_V0_H2, REG_V0_H3, REG_V0_H4, REG_V0_H5, REG_V0_H6, REG_V0_H7,
 REG_V1_H0, REG_V1_H1, REG_V1_H2, REG_V1_H3, REG_V1_H4, REG_V1_H5, REG_V1_H6, REG_V1_H7,
 REG_V2_H0, REG_V2_H1, REG_V2_H2, REG_V2_H3, REG_V2_H4, REG_V2_H5, REG_V2_H6, REG_V2_H7,
 REG_V3_H0, REG_V3_H1, REG_V3_H2, REG_V3_H3, REG_V3_H4, REG_V3_H5, REG_V3_H6, REG_V3_H7,
 REG_V4_H0, REG_V4_H1, REG_V4_H2, REG_V4_H3, REG_V4_H4, REG_V4_H5, REG_V4_H6, REG_V4_H7,
 REG_V5_H0, REG_V5_H1, REG_V5_H2, REG_V5_H3, REG_V5_H4, REG_V5_H5, REG_V5_H6, REG_V5_H7,
 REG_V6_H0, REG_V6_H1, REG_V6_H2, REG_V6_H3, REG_V6_H4, REG_V6_H5, REG_V6_H6, REG_V6_H7,
 REG_V7_H0, REG_V7_H1, REG_V7_H2, REG_V7_H3, REG_V7_H4, REG_V7_H5, REG_V7_H6, REG_V7_H7,
 REG_V8_H0, REG_V8_H1, REG_V8_H2, REG_V8_H3, REG_V8_H4, REG_V8_H5, REG_V8_H6, REG_V8_H7,
 REG_V9_H0, REG_V9_H1, REG_V9_H2, REG_V9_H3, REG_V9_H4, REG_V9_H5, REG_V9_H6, REG_V9_H7,
 REG_V10_H0, REG_V10_H1, REG_V10_H2, REG_V10_H3, REG_V10_H4, REG_V10_H5, REG_V10_H6, REG_V10_H7,
 REG_V11_H0, REG_V11_H1, REG_V11_H2, REG_V11_H3, REG_V11_H4, REG_V11_H5, REG_V11_H6, REG_V11_H7,
 REG_V12_H0, REG_V12_H1, REG_V12_H2, REG_V12_H3, REG_V12_H4, REG_V12_H5, REG_V12_H6, REG_V12_H7,
 REG_V13_H0, REG_V13_H1, REG_V13_H2, REG_V13_H3, REG_V13_H4, REG_V13_H5, REG_V13_H6, REG_V13_H7,
 REG_V14_H0, REG_V14_H1, REG_V14_H2, REG_V14_H3, REG_V14_H4, REG_V14_H5, REG_V14_H6, REG_V14_H7,
 REG_V15_H0, REG_V15_H1, REG_V15_H2, REG_V15_H3, REG_V15_H4, REG_V15_H5, REG_V15_H6, REG_V15_H7,
 REG_V16_H0, REG_V16_H1, REG_V16_H2, REG_V16_H3, REG_V16_H4, REG_V16_H5, REG_V16_H6, REG_V16_H7,
 REG_V17_H0, REG_V17_H1, REG_V17_H2, REG_V17_H3, REG_V17_H4, REG_V17_H5, REG_V17_H6, REG_V17_H7,
 REG_V18_H0, REG_V18_H1, REG_V18_H2, REG_V18_H3, REG_V18_H4, REG_V18_H5, REG_V18_H6, REG_V18_H7,
 REG_V19_H0, REG_V19_H1, REG_V19_H2, REG_V19_H3, REG_V19_H4, REG_V19_H5, REG_V19_H6, REG_V19_H7,
 REG_V20_H0, REG_V20_H1, REG_V20_H2, REG_V20_H3, REG_V20_H4, REG_V20_H5, REG_V20_H6, REG_V20_H7,
 REG_V21_H0, REG_V21_H1, REG_V21_H2, REG_V21_H3, REG_V21_H4, REG_V21_H5, REG_V21_H6, REG_V21_H7,
 REG_V22_H0, REG_V22_H1, REG_V22_H2, REG_V22_H3, REG_V22_H4, REG_V22_H5, REG_V22_H6, REG_V22_H7,
 REG_V23_H0, REG_V23_H1, REG_V23_H2, REG_V23_H3, REG_V23_H4, REG_V23_H5, REG_V23_H6, REG_V23_H7,
 REG_V24_H0, REG_V24_H1, REG_V24_H2, REG_V24_H3, REG_V24_H4, REG_V24_H5, REG_V24_H6, REG_V24_H7,
 REG_V25_H0, REG_V25_H1, REG_V25_H2, REG_V25_H3, REG_V25_H4, REG_V25_H5, REG_V25_H6, REG_V25_H7,
 REG_V26_H0, REG_V26_H1, REG_V26_H2, REG_V26_H3, REG_V26_H4, REG_V26_H5, REG_V26_H6, REG_V26_H7,
 REG_V27_H0, REG_V27_H1, REG_V27_H2, REG_V27_H3, REG_V27_H4, REG_V27_H5, REG_V27_H6, REG_V27_H7,
 REG_V28_H0, REG_V28_H1, REG_V28_H2, REG_V28_H3, REG_V28_H4, REG_V28_H5, REG_V28_H6, REG_V28_H7,
 REG_V29_H0, REG_V29_H1, REG_V29_H2, REG_V29_H3, REG_V29_H4, REG_V29_H5, REG_V29_H6, REG_V29_H7,
 REG_V30_H0, REG_V30_H1, REG_V30_H2, REG_V30_H3, REG_V30_H4, REG_V30_H5, REG_V30_H6, REG_V30_H7,
 REG_V31_H0, REG_V31_H1, REG_V31_H2, REG_V31_H3, REG_V31_H4, REG_V31_H5, REG_V31_H6, REG_V31_H7,

 REG_V0_S0, REG_V0_S1, REG_V0_S2, REG_V0_S3, REG_V1_S0, REG_V1_S1, REG_V1_S2, REG_V1_S3,
 REG_V2_S0, REG_V2_S1, REG_V2_S2, REG_V2_S3, REG_V3_S0, REG_V3_S1, REG_V3_S2, REG_V3_S3,
 REG_V4_S0, REG_V4_S1, REG_V4_S2, REG_V4_S3, REG_V5_S0, REG_V5_S1, REG_V5_S2, REG_V5_S3,
 REG_V6_S0, REG_V6_S1, REG_V6_S2, REG_V6_S3, REG_V7_S0, REG_V7_S1, REG_V7_S2, REG_V7_S3,
 REG_V8_S0, REG_V8_S1, REG_V8_S2, REG_V8_S3, REG_V9_S0, REG_V9_S1, REG_V9_S2, REG_V9_S3,
 REG_V10_S0, REG_V10_S1, REG_V10_S2, REG_V10_S3, REG_V11_S0, REG_V11_S1, REG_V11_S2, REG_V11_S3,
 REG_V12_S0, REG_V12_S1, REG_V12_S2, REG_V12_S3, REG_V13_S0, REG_V13_S1, REG_V13_S2, REG_V13_S3,
 REG_V14_S0, REG_V14_S1, REG_V14_S2, REG_V14_S3, REG_V15_S0, REG_V15_S1, REG_V15_S2, REG_V15_S3,
 REG_V16_S0, REG_V16_S1, REG_V16_S2, REG_V16_S3, REG_V17_S0, REG_V17_S1, REG_V17_S2, REG_V17_S3,
 REG_V18_S0, REG_V18_S1, REG_V18_S2, REG_V18_S3, REG_V19_S0, REG_V19_S1, REG_V19_S2, REG_V19_S3,
 REG_V20_S0, REG_V20_S1, REG_V20_S2, REG_V20_S3, REG_V21_S0, REG_V21_S1, REG_V21_S2, REG_V21_S3,
 REG_V22_S0, REG_V22_S1, REG_V22_S2, REG_V22_S3, REG_V23_S0, REG_V23_S1, REG_V23_S2, REG_V23_S3,
 REG_V24_S0, REG_V24_S1, REG_V24_S2, REG_V24_S3, REG_V25_S0, REG_V25_S1, REG_V25_S2, REG_V25_S3,
 REG_V26_S0, REG_V26_S1, REG_V26_S2, REG_V26_S3, REG_V27_S0, REG_V27_S1, REG_V27_S2, REG_V27_S3,
 REG_V28_S0, REG_V28_S1, REG_V28_S2, REG_V28_S3, REG_V29_S0, REG_V29_S1, REG_V29_S2, REG_V29_S3,
 REG_V30_S0, REG_V30_S1, REG_V30_S2, REG_V30_S3, REG_V31_S0, REG_V31_S1, REG_V31_S2, REG_V31_S3,

 REG_V0_D0, REG_V0_D1, REG_V1_D0, REG_V1_D1, REG_V2_D0, REG_V2_D1, REG_V3_D0, REG_V3_D1,
 REG_V4_D0, REG_V4_D1, REG_V5_D0, REG_V5_D1, REG_V6_D0, REG_V6_D1, REG_V7_D0, REG_V7_D1,
 REG_V8_D0, REG_V8_D1, REG_V9_D0, REG_V9_D1, REG_V10_D0, REG_V10_D1, REG_V11_D0, REG_V11_D1,
 REG_V12_D0, REG_V12_D1, REG_V13_D0, REG_V13_D1, REG_V14_D0, REG_V14_D1, REG_V15_D0, REG_V15_D1,
 REG_V16_D0, REG_V16_D1, REG_V17_D0, REG_V17_D1, REG_V18_D0, REG_V18_D1, REG_V19_D0, REG_V19_D1,
 REG_V20_D0, REG_V20_D1, REG_V21_D0, REG_V21_D1, REG_V22_D0, REG_V22_D1, REG_V23_D0, REG_V23_D1,
 REG_V24_D0, REG_V24_D1, REG_V25_D0, REG_V25_D1, REG_V26_D0, REG_V26_D1, REG_V27_D0, REG_V27_D1,
 REG_V28_D0, REG_V28_D1, REG_V29_D0, REG_V29_D1, REG_V30_D0, REG_V30_D1, REG_V31_D0, REG_V31_D1,


 REG_Z0, REG_Z1, REG_Z2, REG_Z3, REG_Z4, REG_Z5, REG_Z6, REG_Z7,
 REG_Z8, REG_Z9, REG_Z10, REG_Z11, REG_Z12, REG_Z13, REG_Z14, REG_Z15,
 REG_Z16, REG_Z17, REG_Z18, REG_Z19, REG_Z20, REG_Z21, REG_Z22, REG_Z23,
 REG_Z24, REG_Z25, REG_Z26, REG_Z27, REG_Z28, REG_Z29, REG_Z30, REG_ZZR, REG_Z31,
 REG_P0, REG_P1, REG_P2, REG_P3, REG_P4, REG_P5, REG_P6, REG_P7,
 REG_P8, REG_P9, REG_P10, REG_P11, REG_P12, REG_P13, REG_P14, REG_P15,
 REG_P16, REG_P17, REG_P18, REG_P19, REG_P20, REG_P21, REG_P22, REG_P23,
 REG_P24, REG_P25, REG_P26, REG_P27, REG_P28, REG_P29, REG_P30, REG_P31,
 REG_PF0, REG_PF1, REG_PF2, REG_PF3, REG_PF4, REG_PF5, REG_PF6, REG_PF7,
 REG_PF8, REG_PF9, REG_PF10, REG_PF11, REG_PF12, REG_PF13, REG_PF14, REG_PF15,
 REG_PF16, REG_PF17, REG_PF18, REG_PF19, REG_PF20, REG_PF21, REG_PF22, REG_PF23,
 REG_PF24, REG_PF25, REG_PF26, REG_PF27, REG_PF28, REG_PF29, REG_PF30, REG_PF31,
 REG_END
};




const char *get_register_name(enum Register);
size_t get_register_size(enum Register);
# 12 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 2
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/sysregs.h" 1
       

enum SystemReg {
 SYSREG_NONE=32769,
 REG_OSDTRRX_EL1=32770,
 REG_DBGBVR0_EL1=32772,
 REG_DBGBCR0_EL1=32773,
 REG_DBGWVR0_EL1=32774,
 REG_DBGWCR0_EL1=32775,
 REG_DBGBVR1_EL1=32780,
 REG_DBGBCR1_EL1=32781,
 REG_DBGWVR1_EL1=32782,
 REG_DBGWCR1_EL1=32783,
 REG_MDCCINT_EL1=32784,
 REG_MDSCR_EL1=32786,
 REG_DBGBVR2_EL1=32788,
 REG_DBGBCR2_EL1=32789,
 REG_DBGWVR2_EL1=32790,
 REG_DBGWCR2_EL1=32791,
 REG_OSDTRTX_EL1=32794,
 REG_DBGBVR3_EL1=32796,
 REG_DBGBCR3_EL1=32797,
 REG_DBGWVR3_EL1=32798,
 REG_DBGWCR3_EL1=32799,
 REG_DBGBVR4_EL1=32804,
 REG_DBGBCR4_EL1=32805,
 REG_DBGWVR4_EL1=32806,
 REG_DBGWCR4_EL1=32807,
 REG_DBGBVR5_EL1=32812,
 REG_DBGBCR5_EL1=32813,
 REG_DBGWVR5_EL1=32814,
 REG_DBGWCR5_EL1=32815,
 REG_OSECCR_EL1=32818,
 REG_DBGBVR6_EL1=32820,
 REG_DBGBCR6_EL1=32821,
 REG_DBGWVR6_EL1=32822,
 REG_DBGWCR6_EL1=32823,
 REG_DBGBVR7_EL1=32828,
 REG_DBGBCR7_EL1=32829,
 REG_DBGWVR7_EL1=32830,
 REG_DBGWCR7_EL1=32831,
 REG_DBGBVR8_EL1=32836,
 REG_DBGBCR8_EL1=32837,
 REG_DBGWVR8_EL1=32838,
 REG_DBGWCR8_EL1=32839,
 REG_DBGBVR9_EL1=32844,
 REG_DBGBCR9_EL1=32845,
 REG_DBGWVR9_EL1=32846,
 REG_DBGWCR9_EL1=32847,
 REG_DBGBVR10_EL1=32852,
 REG_DBGBCR10_EL1=32853,
 REG_DBGWVR10_EL1=32854,
 REG_DBGWCR10_EL1=32855,
 REG_DBGBVR11_EL1=32860,
 REG_DBGBCR11_EL1=32861,
 REG_DBGWVR11_EL1=32862,
 REG_DBGWCR11_EL1=32863,
 REG_DBGBVR12_EL1=32868,
 REG_DBGBCR12_EL1=32869,
 REG_DBGWVR12_EL1=32870,
 REG_DBGWCR12_EL1=32871,
 REG_DBGBVR13_EL1=32876,
 REG_DBGBCR13_EL1=32877,
 REG_DBGWVR13_EL1=32878,
 REG_DBGWCR13_EL1=32879,
 REG_DBGBVR14_EL1=32884,
 REG_DBGBCR14_EL1=32885,
 REG_DBGWVR14_EL1=32886,
 REG_DBGWCR14_EL1=32887,
 REG_DBGBVR15_EL1=32892,
 REG_DBGBCR15_EL1=32893,
 REG_DBGWVR15_EL1=32894,
 REG_DBGWCR15_EL1=32895,
 REG_OSLAR_EL1=32900,
 REG_OSDLR_EL1=32924,
 REG_DBGPRCR_EL1=32932,
 REG_DBGCLAIMSET_EL1=33734,
 REG_DBGCLAIMCLR_EL1=33742,
 REG_TRCTRACEIDR=34817,
 REG_TRCVICTLR=34818,
 REG_TRCSEQEVR0=34820,
 REG_TRCCNTRLDVR0=34821,
 REG_TRCIMSPEC0=34823,
 REG_TRCPRGCTLR=34824,
 REG_TRCQCTLR=34825,
 REG_TRCVIIECTLR=34826,
 REG_TRCSEQEVR1=34828,
 REG_TRCCNTRLDVR1=34829,
 REG_TRCIMSPEC1=34831,
 REG_TRCPROCSELR=34832,
 REG_TRCVISSCTLR=34834,
 REG_TRCSEQEVR2=34836,
 REG_TRCCNTRLDVR2=34837,
 REG_TRCIMSPEC2=34839,
 REG_TRCVIPCSSCTLR=34842,
 REG_TRCCNTRLDVR3=34845,
 REG_TRCIMSPEC3=34847,
 REG_TRCCONFIGR=34848,
 REG_TRCCNTCTLR0=34853,
 REG_TRCIMSPEC4=34855,
 REG_TRCCNTCTLR1=34861,
 REG_TRCIMSPEC5=34863,
 REG_TRCAUXCTLR=34864,
 REG_TRCSEQRSTEVR=34868,
 REG_TRCCNTCTLR2=34869,
 REG_TRCIMSPEC6=34871,
 REG_TRCSEQSTR=34876,
 REG_TRCCNTCTLR3=34877,
 REG_TRCIMSPEC7=34879,
 REG_TRCEVENTCTL0R=34880,
 REG_TRCVDCTLR=34882,
 REG_TRCEXTINSELR=34884,
 REG_TRCCNTVR0=34885,
 REG_TRCEVENTCTL1R=34888,
 REG_TRCVDSACCTLR=34890,
 REG_TRCEXTINSELR1=34892,
 REG_TRCCNTVR1=34893,
 REG_TRCRSR=34896,
 REG_TRCVDARCCTLR=34898,
 REG_TRCEXTINSELR2=34900,
 REG_TRCCNTVR2=34901,
 REG_TRCSTALLCTLR=34904,
 REG_TRCEXTINSELR3=34908,
 REG_TRCCNTVR3=34909,
 REG_TRCTSCTLR=34912,
 REG_TRCSYNCPR=34920,
 REG_TRCCCCTLR=34928,
 REG_TRCBBCTLR=34936,
 REG_TRCRSCTLR16=34945,
 REG_TRCSSCCR0=34946,
 REG_TRCSSPCICR0=34947,
 REG_TRCOSLAR=34948,
 REG_TRCRSCTLR17=34953,
 REG_TRCSSCCR1=34954,
 REG_TRCSSPCICR1=34955,
 REG_TRCRSCTLR2=34960,
 REG_TRCRSCTLR18=34961,
 REG_TRCSSCCR2=34962,
 REG_TRCSSPCICR2=34963,
 REG_TRCRSCTLR3=34968,
 REG_TRCRSCTLR19=34969,
 REG_TRCSSCCR3=34970,
 REG_TRCSSPCICR3=34971,
 REG_TRCRSCTLR4=34976,
 REG_TRCRSCTLR20=34977,
 REG_TRCSSCCR4=34978,
 REG_TRCSSPCICR4=34979,
 REG_TRCPDCR=34980,
 REG_TRCRSCTLR5=34984,
 REG_TRCRSCTLR21=34985,
 REG_TRCSSCCR5=34986,
 REG_TRCSSPCICR5=34987,
 REG_TRCRSCTLR6=34992,
 REG_TRCRSCTLR22=34993,
 REG_TRCSSCCR6=34994,
 REG_TRCSSPCICR6=34995,
 REG_TRCRSCTLR7=35000,
 REG_TRCRSCTLR23=35001,
 REG_TRCSSCCR7=35002,
 REG_TRCSSPCICR7=35003,
 REG_TRCRSCTLR8=35008,
 REG_TRCRSCTLR24=35009,
 REG_TRCSSCSR0=35010,
 REG_TRCRSCTLR9=35016,
 REG_TRCRSCTLR25=35017,
 REG_TRCSSCSR1=35018,
 REG_TRCRSCTLR10=35024,
 REG_TRCRSCTLR26=35025,
 REG_TRCSSCSR2=35026,
 REG_TRCRSCTLR11=35032,
 REG_TRCRSCTLR27=35033,
 REG_TRCSSCSR3=35034,
 REG_TRCRSCTLR12=35040,
 REG_TRCRSCTLR28=35041,
 REG_TRCSSCSR4=35042,
 REG_TRCRSCTLR13=35048,
 REG_TRCRSCTLR29=35049,
 REG_TRCSSCSR5=35050,
 REG_TRCRSCTLR14=35056,
 REG_TRCRSCTLR30=35057,
 REG_TRCSSCSR6=35058,
 REG_TRCRSCTLR15=35064,
 REG_TRCRSCTLR31=35065,
 REG_TRCSSCSR7=35066,
 REG_TRCACVR0=35072,
 REG_TRCACVR8=35073,
 REG_TRCACATR0=35074,
 REG_TRCACATR8=35075,
 REG_TRCDVCVR0=35076,
 REG_TRCDVCVR4=35077,
 REG_TRCDVCMR0=35078,
 REG_TRCDVCMR4=35079,
 REG_TRCACVR1=35088,
 REG_TRCACVR9=35089,
 REG_TRCACATR1=35090,
 REG_TRCACATR9=35091,
 REG_TRCACVR2=35104,
 REG_TRCACVR10=35105,
 REG_TRCACATR2=35106,
 REG_TRCACATR10=35107,
 REG_TRCDVCVR1=35108,
 REG_TRCDVCVR5=35109,
 REG_TRCDVCMR1=35110,
 REG_TRCDVCMR5=35111,
 REG_TRCACVR3=35120,
 REG_TRCACVR11=35121,
 REG_TRCACATR3=35122,
 REG_TRCACATR11=35123,
 REG_TRCACVR4=35136,
 REG_TRCACVR12=35137,
 REG_TRCACATR4=35138,
 REG_TRCACATR12=35139,
 REG_TRCDVCVR2=35140,
 REG_TRCDVCVR6=35141,
 REG_TRCDVCMR2=35142,
 REG_TRCDVCMR6=35143,
 REG_TRCACVR5=35152,
 REG_TRCACVR13=35153,
 REG_TRCACATR5=35154,
 REG_TRCACATR13=35155,
 REG_TRCACVR6=35168,
 REG_TRCACVR14=35169,
 REG_TRCACATR6=35170,
 REG_TRCACATR14=35171,
 REG_TRCDVCVR3=35172,
 REG_TRCDVCVR7=35173,
 REG_TRCDVCMR3=35174,
 REG_TRCDVCMR7=35175,
 REG_TRCACVR7=35184,
 REG_TRCACVR15=35185,
 REG_TRCACATR7=35186,
 REG_TRCACATR15=35187,
 REG_TRCCIDCVR0=35200,
 REG_TRCVMIDCVR0=35201,
 REG_TRCCIDCCTLR0=35202,
 REG_TRCCIDCCTLR1=35210,
 REG_TRCCIDCVR1=35216,
 REG_TRCVMIDCVR1=35217,
 REG_TRCVMIDCCTLR0=35218,
 REG_TRCVMIDCCTLR1=35226,
 REG_TRCCIDCVR2=35232,
 REG_TRCVMIDCVR2=35233,
 REG_TRCCIDCVR3=35248,
 REG_TRCVMIDCVR3=35249,
 REG_TRCCIDCVR4=35264,
 REG_TRCVMIDCVR4=35265,
 REG_TRCCIDCVR5=35280,
 REG_TRCVMIDCVR5=35281,
 REG_TRCCIDCVR6=35296,
 REG_TRCVMIDCVR6=35297,
 REG_TRCCIDCVR7=35312,
 REG_TRCVMIDCVR7=35313,
 REG_TRCITCTRL=35716,
 REG_TRCCLAIMSET=35782,
 REG_TRCCLAIMCLR=35790,
 REG_TRCLAR=35814,
 REG_TEECR32_EL1=36864,
 REG_TEEHBR32_EL1=36992,
 REG_DBGDTR_EL0=38944,
 REG_DBGDTRTX_EL0=38952,
 REG_DBGVCR32_EL2=41016,
 REG_SCTLR_EL1=49280,
 REG_ACTLR_EL1=49281,
 REG_CPACR_EL1=49282,
 REG_RGSR_EL1=49285,
 REG_GCR_EL1=49286,
 REG_TRFCR_EL1=49297,
 REG_TTBR0_EL1=49408,
 REG_TTBR1_EL1=49409,
 REG_TCR_EL1=49410,
 REG_APIAKEYLO_EL1=49416,
 REG_APIAKEYHI_EL1=49417,
 REG_APIBKEYLO_EL1=49418,
 REG_APIBKEYHI_EL1=49419,
 REG_APDAKEYLO_EL1=49424,
 REG_APDAKEYHI_EL1=49425,
 REG_APDBKEYLO_EL1=49426,
 REG_APDBKEYHI_EL1=49427,
 REG_APGAKEYLO_EL1=49432,
 REG_APGAKEYHI_EL1=49433,
 REG_SPSR_EL1=49664,
 REG_ELR_EL1=49665,
 REG_SP_EL0=49672,
 REG_SPSEL=49680,
 REG_CURRENTEL=49682,
 REG_PAN=49683,
 REG_UAO=49684,
 REG_ICC_PMR_EL1=49712,
 REG_AFSR0_EL1=49800,
 REG_AFSR1_EL1=49801,
 REG_ESR_EL1=49808,
 REG_ERRSELR_EL1=49817,
 REG_ERXCTLR_EL1=49825,
 REG_ERXSTATUS_EL1=49826,
 REG_ERXADDR_EL1=49827,
 REG_ERXPFGCTL_EL1=49829,
 REG_ERXPFGCDN_EL1=49830,
 REG_ERXMISC0_EL1=49832,
 REG_ERXMISC1_EL1=49833,
 REG_ERXMISC2_EL1=49834,
 REG_ERXMISC3_EL1=49835,
 REG_ERXTS_EL1=49839,
 REG_TFSR_EL1=49840,
 REG_TFSRE0_EL1=49841,
 REG_FAR_EL1=49920,
 REG_PAR_EL1=50080,
 REG_PMSCR_EL1=50376,
 REG_PMSICR_EL1=50378,
 REG_PMSIRR_EL1=50379,
 REG_PMSFCR_EL1=50380,
 REG_PMSEVFR_EL1=50381,
 REG_PMSLATFR_EL1=50382,
 REG_PMSIDR_EL1=50383,
 REG_PMBLIMITR_EL1=50384,
 REG_PMBPTR_EL1=50385,
 REG_PMBSR_EL1=50387,
 REG_PMBIDR_EL1=50391,
 REG_TRBLIMITR_EL1=50392,
 REG_TRBPTR_EL1=50393,
 REG_TRBBASER_EL1=50394,
 REG_TRBSR_EL1=50395,
 REG_TRBMAR_EL1=50396,
 REG_TRBTRG_EL1=50398,
 REG_PMINTENSET_EL1=50417,
 REG_PMINTENCLR_EL1=50418,
 REG_PMMIR_EL1=50422,
 REG_MAIR_EL1=50448,
 REG_AMAIR_EL1=50456,
 REG_LORSA_EL1=50464,
 REG_LOREA_EL1=50465,
 REG_LORN_EL1=50466,
 REG_LORC_EL1=50467,
 REG_MPAM1_EL1=50472,
 REG_MPAM0_EL1=50473,
 REG_VBAR_EL1=50688,
 REG_RMR_EL1=50690,
 REG_DISR_EL1=50697,
 REG_ICC_EOIR0_EL1=50753,
 REG_ICC_BPR0_EL1=50755,
 REG_ICC_AP0R0_EL1=50756,
 REG_ICC_AP0R1_EL1=50757,
 REG_ICC_AP0R2_EL1=50758,
 REG_ICC_AP0R3_EL1=50759,
 REG_ICC_AP1R0_EL1=50760,
 REG_ICC_AP1R1_EL1=50761,
 REG_ICC_AP1R2_EL1=50762,
 REG_ICC_AP1R3_EL1=50763,
 REG_ICC_DIR_EL1=50777,
 REG_ICC_SGI1R_EL1=50781,
 REG_ICC_ASGI1R_EL1=50782,
 REG_ICC_SGI0R_EL1=50783,
 REG_ICC_EOIR1_EL1=50785,
 REG_ICC_BPR1_EL1=50787,
 REG_ICC_CTLR_EL1=50788,
 REG_ICC_SRE_EL1=50789,
 REG_ICC_IGRPEN0_EL1=50790,
 REG_ICC_IGRPEN1_EL1=50791,
 REG_ICC_SEIEN_EL1=50792,
 REG_CONTEXTIDR_EL1=50817,
 REG_TPIDR_EL1=50820,
 REG_SCXTNUM_EL1=50823,
 REG_CNTKCTL_EL1=50952,
 REG_CSSELR_EL1=53248,
 REG_NZCV=55824,
 REG_DAIFSET=55825,
 REG_DIT=55829,
 REG_SSBS=55830,
 REG_TCO=55831,
 REG_FPCR=55840,
 REG_FPSR=55841,
 REG_DSPSR_EL0=55848,
 REG_DLR_EL0=55849,
 REG_PMCR_EL0=56544,
 REG_PMCNTENSET_EL0=56545,
 REG_PMCNTENCLR_EL0=56546,
 REG_PMOVSCLR_EL0=56547,
 REG_PMSWINC_EL0=56548,
 REG_PMSELR_EL0=56549,
 REG_PMCCNTR_EL0=56552,
 REG_PMXEVTYPER_EL0=56553,
 REG_PMXEVCNTR_EL0=56554,
 REG_DAIFCLR=56557,
 REG_PMUSERENR_EL0=56560,
 REG_PMOVSSET_EL0=56563,
 REG_TPIDR_EL0=56962,
 REG_TPIDRRO_EL0=56963,
 REG_SCXTNUM_EL0=56967,
 REG_AMCR_EL0=56976,
 REG_AMUSERENR_EL0=56979,
 REG_AMCNTENCLR0_EL0=56980,
 REG_AMCNTENSET0_EL0=56981,
 REG_AMCNTENCLR1_EL0=56984,
 REG_AMCNTENSET1_EL0=56985,
 REG_AMEVCNTR00_EL0=56992,
 REG_AMEVCNTR01_EL0=56993,
 REG_AMEVCNTR02_EL0=56994,
 REG_AMEVCNTR03_EL0=56995,
 REG_AMEVCNTR10_EL0=57056,
 REG_AMEVCNTR11_EL0=57057,
 REG_AMEVCNTR12_EL0=57058,
 REG_AMEVCNTR13_EL0=57059,
 REG_AMEVCNTR14_EL0=57060,
 REG_AMEVCNTR15_EL0=57061,
 REG_AMEVCNTR16_EL0=57062,
 REG_AMEVCNTR17_EL0=57063,
 REG_AMEVCNTR18_EL0=57064,
 REG_AMEVCNTR19_EL0=57065,
 REG_AMEVCNTR110_EL0=57066,
 REG_AMEVCNTR111_EL0=57067,
 REG_AMEVCNTR112_EL0=57068,
 REG_AMEVCNTR113_EL0=57069,
 REG_AMEVCNTR114_EL0=57070,
 REG_AMEVCNTR115_EL0=57071,
 REG_AMEVTYPER10_EL0=57072,
 REG_AMEVTYPER11_EL0=57073,
 REG_AMEVTYPER12_EL0=57074,
 REG_AMEVTYPER13_EL0=57075,
 REG_AMEVTYPER14_EL0=57076,
 REG_AMEVTYPER15_EL0=57077,
 REG_AMEVTYPER16_EL0=57078,
 REG_AMEVTYPER17_EL0=57079,
 REG_AMEVTYPER18_EL0=57080,
 REG_AMEVTYPER19_EL0=57081,
 REG_AMEVTYPER110_EL0=57082,
 REG_AMEVTYPER111_EL0=57083,
 REG_AMEVTYPER112_EL0=57084,
 REG_AMEVTYPER113_EL0=57085,
 REG_AMEVTYPER114_EL0=57086,
 REG_AMEVTYPER115_EL0=57087,
 REG_CNTFRQ_EL0=57088,
 REG_CNTP_TVAL_EL0=57104,
 REG_CNTP_CTL_EL0=57105,
 REG_CNTP_CVAL_EL0=57106,
 REG_CNTV_TVAL_EL0=57112,
 REG_CNTV_CTL_EL0=57113,
 REG_CNTV_CVAL_EL0=57114,
 REG_PMEVCNTR0_EL0=57152,
 REG_PMEVCNTR1_EL0=57153,
 REG_PMEVCNTR2_EL0=57154,
 REG_PMEVCNTR3_EL0=57155,
 REG_PMEVCNTR4_EL0=57156,
 REG_PMEVCNTR5_EL0=57157,
 REG_PMEVCNTR6_EL0=57158,
 REG_PMEVCNTR7_EL0=57159,
 REG_PMEVCNTR8_EL0=57160,
 REG_PMEVCNTR9_EL0=57161,
 REG_PMEVCNTR10_EL0=57162,
 REG_PMEVCNTR11_EL0=57163,
 REG_PMEVCNTR12_EL0=57164,
 REG_PMEVCNTR13_EL0=57165,
 REG_PMEVCNTR14_EL0=57166,
 REG_PMEVCNTR15_EL0=57167,
 REG_PMEVCNTR16_EL0=57168,
 REG_PMEVCNTR17_EL0=57169,
 REG_PMEVCNTR18_EL0=57170,
 REG_PMEVCNTR19_EL0=57171,
 REG_PMEVCNTR20_EL0=57172,
 REG_PMEVCNTR21_EL0=57173,
 REG_PMEVCNTR22_EL0=57174,
 REG_PMEVCNTR23_EL0=57175,
 REG_PMEVCNTR24_EL0=57176,
 REG_PMEVCNTR25_EL0=57177,
 REG_PMEVCNTR26_EL0=57178,
 REG_PMEVCNTR27_EL0=57179,
 REG_PMEVCNTR28_EL0=57180,
 REG_PMEVCNTR29_EL0=57181,
 REG_PMEVCNTR30_EL0=57182,
 REG_PMEVTYPER0_EL0=57184,
 REG_PMEVTYPER1_EL0=57185,
 REG_PMEVTYPER2_EL0=57186,
 REG_PMEVTYPER3_EL0=57187,
 REG_PMEVTYPER4_EL0=57188,
 REG_PMEVTYPER5_EL0=57189,
 REG_PMEVTYPER6_EL0=57190,
 REG_PMEVTYPER7_EL0=57191,
 REG_PMEVTYPER8_EL0=57192,
 REG_PMEVTYPER9_EL0=57193,
 REG_PMEVTYPER10_EL0=57194,
 REG_PMEVTYPER11_EL0=57195,
 REG_PMEVTYPER12_EL0=57196,
 REG_PMEVTYPER13_EL0=57197,
 REG_PMEVTYPER14_EL0=57198,
 REG_PMEVTYPER15_EL0=57199,
 REG_PMEVTYPER16_EL0=57200,
 REG_PMEVTYPER17_EL0=57201,
 REG_PMEVTYPER18_EL0=57202,
 REG_PMEVTYPER19_EL0=57203,
 REG_PMEVTYPER20_EL0=57204,
 REG_PMEVTYPER21_EL0=57205,
 REG_PMEVTYPER22_EL0=57206,
 REG_PMEVTYPER23_EL0=57207,
 REG_PMEVTYPER24_EL0=57208,
 REG_PMEVTYPER25_EL0=57209,
 REG_PMEVTYPER26_EL0=57210,
 REG_PMEVTYPER27_EL0=57211,
 REG_PMEVTYPER28_EL0=57212,
 REG_PMEVTYPER29_EL0=57213,
 REG_PMEVTYPER30_EL0=57214,
 REG_PMCCFILTR_EL0=57215,
 REG_VPIDR_EL2=57344,
 REG_VMPIDR_EL2=57349,
 REG_SCTLR_EL2=57472,
 REG_ACTLR_EL2=57473,
 REG_HCR_EL2=57480,
 REG_MDCR_EL2=57481,
 REG_CPTR_EL2=57482,
 REG_HSTR_EL2=57483,
 REG_HACR_EL2=57487,
 REG_TRFCR_EL2=57489,
 REG_SDER32_EL2=57497,
 REG_TTBR0_EL2=57600,
 REG_TTBR1_EL2=57601,
 REG_TCR_EL2=57602,
 REG_VTTBR_EL2=57608,
 REG_VTCR_EL2=57610,
 REG_VNCR_EL2=57616,
 REG_VSTTBR_EL2=57648,
 REG_VSTCR_EL2=57650,
 REG_DACR32_EL2=57728,
 REG_SPSR_EL2=57856,
 REG_ELR_EL2=57857,
 REG_SP_EL1=57864,
 REG_SPSR_IRQ=57880,
 REG_SPSR_ABT=57881,
 REG_SPSR_UND=57882,
 REG_SPSR_FIQ=57883,
 REG_IFSR32_EL2=57985,
 REG_AFSR0_EL2=57992,
 REG_AFSR1_EL2=57993,
 REG_ESR_EL2=58000,
 REG_VSESR_EL2=58003,
 REG_FPEXC32_EL2=58008,
 REG_TFSR_EL2=58032,
 REG_FAR_EL2=58112,
 REG_HPFAR_EL2=58116,
 REG_PMSCR_EL2=58568,
 REG_MAIR_EL2=58640,
 REG_AMAIR_EL2=58648,
 REG_MPAMHCR_EL2=58656,
 REG_MPAMVPMV_EL2=58657,
 REG_MPAM2_EL2=58664,
 REG_MPAMVPM0_EL2=58672,
 REG_MPAMVPM1_EL2=58673,
 REG_MPAMVPM2_EL2=58674,
 REG_MPAMVPM3_EL2=58675,
 REG_MPAMVPM4_EL2=58676,
 REG_MPAMVPM5_EL2=58677,
 REG_MPAMVPM6_EL2=58678,
 REG_MPAMVPM7_EL2=58679,
 REG_VBAR_EL2=58880,
 REG_RMR_EL2=58882,
 REG_VDISR_EL2=58889,
 REG_ICH_AP0R0_EL2=58944,
 REG_ICH_AP0R1_EL2=58945,
 REG_ICH_AP0R2_EL2=58946,
 REG_ICH_AP0R3_EL2=58947,
 REG_ICH_AP1R0_EL2=58952,
 REG_ICH_AP1R1_EL2=58953,
 REG_ICH_AP1R2_EL2=58954,
 REG_ICH_AP1R3_EL2=58955,
 REG_ICH_VSEIR_EL2=58956,
 REG_ICC_SRE_EL2=58957,
 REG_ICH_HCR_EL2=58968,
 REG_ICH_MISR_EL2=58970,
 REG_ICH_VMCR_EL2=58975,
 REG_ICH_LR0_EL2=58976,
 REG_ICH_LR1_EL2=58977,
 REG_ICH_LR2_EL2=58978,
 REG_ICH_LR3_EL2=58979,
 REG_ICH_LR4_EL2=58980,
 REG_ICH_LR5_EL2=58981,
 REG_ICH_LR6_EL2=58982,
 REG_ICH_LR7_EL2=58983,
 REG_ICH_LR8_EL2=58984,
 REG_ICH_LR9_EL2=58985,
 REG_ICH_LR10_EL2=58986,
 REG_ICH_LR11_EL2=58987,
 REG_ICH_LR12_EL2=58988,
 REG_ICH_LR13_EL2=58989,
 REG_ICH_LR14_EL2=58990,
 REG_ICH_LR15_EL2=58991,
 REG_CONTEXTIDR_EL2=59009,
 REG_TPIDR_EL2=59010,
 REG_SCXTNUM_EL2=59015,
 REG_CNTVOFF_EL2=59139,
 REG_CNTHCTL_EL2=59144,
 REG_CNTHP_TVAL_EL2=59152,
 REG_CNTHP_CTL_EL2=59153,
 REG_CNTHP_CVAL_EL2=59154,
 REG_CNTHV_TVAL_EL2=59160,
 REG_CNTHV_CTL_EL2=59161,
 REG_CNTHV_CVAL_EL2=59162,
 REG_CNTHVS_TVAL_EL2=59168,
 REG_CNTHVS_CTL_EL2=59169,
 REG_CNTHVS_CVAL_EL2=59170,
 REG_CNTHPS_TVAL_EL2=59176,
 REG_CNTHPS_CTL_EL2=59177,
 REG_CNTHPS_CVAL_EL2=59178,
 REG_SCTLR_EL12=59520,
 REG_CPACR_EL12=59522,
 REG_TRFCR_EL12=59537,
 REG_TTBR0_EL12=59648,
 REG_TTBR1_EL12=59649,
 REG_TCR_EL12=59650,
 REG_SPSR_EL12=59904,
 REG_ELR_EL12=59905,
 REG_AFSR0_EL12=60040,
 REG_AFSR1_EL12=60041,
 REG_ESR_EL12=60048,
 REG_TFSR_EL12=60080,
 REG_FAR_EL12=60160,
 REG_PMSCR_EL12=60616,
 REG_MAIR_EL12=60688,
 REG_AMAIR_EL12=60696,
 REG_MPAM1_EL12=60712,
 REG_VBAR_EL12=60928,
 REG_CONTEXTIDR_EL12=61057,
 REG_SCXTNUM_EL12=61063,
 REG_CNTKCTL_EL12=61192,
 REG_CNTP_TVAL_EL02=61200,
 REG_CNTP_CTL_EL02=61201,
 REG_CNTP_CVAL_EL02=61202,
 REG_CNTV_TVAL_EL02=61208,
 REG_CNTV_CTL_EL02=61209,
 REG_CNTV_CVAL_EL02=61210,
 REG_SCTLR_EL3=61568,
 REG_ACTLR_EL3=61569,
 REG_SCR_EL3=61576,
 REG_SDER32_EL3=61577,
 REG_CPTR_EL3=61578,
 REG_MDCR_EL3=61593,
 REG_TTBR0_EL3=61696,
 REG_TCR_EL3=61698,
 REG_SPSR_EL3=61952,
 REG_ELR_EL3=61953,
 REG_SP_EL2=61960,
 REG_AFSR0_EL3=62088,
 REG_AFSR1_EL3=62089,
 REG_ESR_EL3=62096,
 REG_TFSR_EL3=62128,
 REG_FAR_EL3=62208,
 REG_MAIR_EL3=62736,
 REG_AMAIR_EL3=62744,
 REG_MPAM3_EL3=62760,
 REG_VBAR_EL3=62976,
 REG_RMR_EL3=62978,
 REG_ICC_CTLR_EL3=63076,
 REG_ICC_SRE_EL3=63077,
 REG_ICC_IGRPEN1_EL3=63079,
 REG_TPIDR_EL3=63106,
 REG_SCXTNUM_EL3=63111,
 REG_CNTPS_TVAL_EL1=65296,
 REG_CNTPS_CTL_EL1=65297,
 REG_CNTPS_CVAL_EL1=65298,

 REG_PSTATE_SPSEL=65299,

 SYSREG_UNKNOWN=65300,
 SYSREG_END=65301,
};




const char *get_system_register_name(enum SystemReg);
const char *get_system_register_name_decomposed(int op0, int op1, int CRn, int CRm, int op2);
# 13 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 2
# 22 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
typedef union {
 unsigned int ui;
 float fn;
} ImmFloatUnion;


enum ArrangementSpec {
 ARRSPEC_NONE=0,

 ARRSPEC_FULL=1,


 ARRSPEC_2DOUBLES=2,
 ARRSPEC_4SINGLES=3,
 ARRSPEC_8HALVES=4,
 ARRSPEC_16BYTES=5,


 ARRSPEC_1DOUBLE=6,
 ARRSPEC_2SINGLES=7,
 ARRSPEC_4HALVES=8,
 ARRSPEC_8BYTES=9,


 ARRSPEC_1SINGLE=10,
 ARRSPEC_2HALVES=11,
 ARRSPEC_4BYTES=12,


 ARRSPEC_1HALF=13,


 ARRSPEC_1BYTE=14,
};
# 109 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
typedef struct context_ {
 uint32_t insword;
 uint64_t address;
 uint64_t features0;
 uint64_t features1;


 uint8_t pstate_btype;
 uint8_t pstate_el;
 uint8_t pstate_uao;
 
# 119 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 119 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     BTypeCompatible;
 uint8_t BTypeNext;
 
# 121 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 121 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     halted;
 uint64_t FPCR;
 
# 123 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 123 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     EDSCR_HDE;


 uint64_t A;
 uint64_t ADD;
 uint64_t AccType_NORMAL;
 uint64_t AccType_STREAM;
 uint64_t AccType_UNPRIV;
 uint64_t AccType_VEC;
 uint64_t AccType_VECSTREAM;
 uint64_t B;
 uint64_t C;
 uint64_t CRm;
 uint64_t CRn;
 uint64_t dst, D;
 uint64_t E;
 uint64_t H;
 uint64_t HCR_EL2_E2H, HCR_EL2_NV, HCR_EL2_NV1, HCR_EL2_TGE;
 uint64_t k;
 uint64_t L;
 uint64_t LL;
 uint64_t M;
 uint64_t N;
 uint64_t O;
 uint64_t Op0, Op3;
 uint64_t P;
 uint64_t Pd, Pdm, Pdn, Pg, Pm, Pn, Pt;
 uint64_t Q, Qa, Qd, Qm, Qn, Qt, Qt2;
 uint64_t reason, retry;
 uint64_t R, Ra, Rd, Rdn, Rm, Rmhi, Rn, Rs, Rt, Rt2;
 uint64_t s1, s2, sel1, sel2, S, Sa, Sd, Sm, Sn, St, St2;
 uint64_t S10;
 uint64_t SCTLR_EL1_UMA;
 uint64_t T;
 uint64_t U;
 uint64_t US;
 uint64_t V, Va, Vd, Vdn, Vm, Vn, Vt, Vt2;
 uint64_t W, Wa, Wd, Wdn, Wm, Wn, Ws, Wt, Wt2;
 uint64_t Xa, Xd, Xdn, Xm, Xn, Xs, Xt, Xt2;
 uint64_t Z, Za, Zd, Zda, Zdn, Zm, Zn, Zt;
 uint64_t a;
 uint64_t abs;
 uint64_t ac;
 uint64_t acc;
 uint64_t acctype;
 uint64_t accumulate;
 uint64_t amount;
 uint64_t and_test;
 uint64_t asimdimm;
 uint64_t b;
 uint64_t b40;
 uint64_t b5;
 uint64_t bit_pos;
 uint64_t bit_val;
 uint64_t branch_type;
 uint64_t c;
 uint64_t cmode;
 uint64_t cmp, cmph, cmpl, cmp_eq, cmp_with_zero;
 uint64_t comment;
 uint64_t comparison;
 uint64_t cond;
 uint64_t condition;
 uint64_t container_size;
 uint64_t containers;
 uint64_t countop;
 uint64_t crc32c;
 uint64_t csize;
 uint64_t d, da, data, datasize, double_table;
 uint64_t dtype, dtypeh, dtypel;
 uint64_t d_esize;
 uint64_t decrypt;
 uint64_t destsize;
 uint64_t dm;
 uint64_t dn;
 uint64_t domain;
 uint64_t dst_index;
 uint64_t dst_unsigned;
 uint64_t dstsize;
 uint64_t e;
 uint64_t elements;
 uint64_t elements_per_container;
 uint64_t else_inc;
 uint64_t else_inv;
 uint64_t elsize;
 uint64_t eq;
 uint64_t esize;
 uint64_t exact;
 uint64_t extend;
 uint64_t extend_type;
 uint64_t f, ff;
 uint64_t field;
 uint64_t flags;
 uint64_t fltsize;
 uint64_t fpop;
 uint64_t fracbits;
 uint64_t ftype;
 uint64_t g;
 uint64_t h;
 uint64_t has_result;
 uint64_t hi;
 uint64_t hw;
 uint64_t i, i1, i2, i2h, i2l,i3h, i3l;
 uint64_t idxdsize;
 uint64_t imm;
 uint64_t imm1;
 uint64_t imm12;
 uint64_t imm13;
 uint64_t imm14;
 uint64_t imm16;
 uint64_t imm19;
 uint64_t imm2;
 uint64_t imm26;
 uint64_t imm3;
 uint64_t imm4;
 uint64_t imm5;
 uint64_t imm5b;
 uint64_t imm6;
 uint64_t imm64;
 uint64_t imm7;
 uint64_t imm8;
 uint64_t imm8h;
 uint64_t imm8l;
 uint64_t imm9;
 uint64_t imm9h;
 uint64_t imm9l;
 uint64_t immb;
 uint64_t immh;
 uint64_t immhi;
 uint64_t immlo;
 uint64_t immr;
 uint64_t imms;
 uint64_t index;
 uint64_t init_scale;
 uint64_t intsize;
 uint64_t int_U;
 uint64_t invert;
 uint64_t inzero;
 uint64_t isBefore;
 uint64_t is_tbl;
 uint64_t iszero;
 uint64_t ldacctype;
 uint64_t len;
 uint64_t level;
 uint64_t lsb;
 uint64_t lt;
 uint64_t m;
 uint64_t mask;
 uint64_t mbytes;
 uint64_t memop;
 uint64_t merging;
 uint64_t min;
 uint64_t min_EL;
 uint64_t minimum;
 uint64_t msb;
 uint64_t msize;
 uint64_t msz;
 uint64_t mulx_op;
 uint64_t n;
 uint64_t ne;
 uint64_t need_secure;
 uint64_t neg;
 uint64_t neg_i;
 uint64_t neg_r;
 uint64_t negated;
 uint64_t nreg;
 uint64_t nzcv;
 uint64_t nXS;
 uint64_t o0, o1, o2, o3;
 uint64_t offs_size;
 uint64_t offs_unsigned;
 uint64_t offset;
 uint64_t op1_neg;
 uint64_t op1_unsigned;
 uint64_t op, op0, op1, op2, op3, op4, op21, op31, op54;
 uint64_t op2_unsigned;
 uint64_t op3_neg;
 uint64_t opa_neg;
 uint64_t opc;
 uint64_t opc2;
 uint64_t opcode, opcode2;
 uint64_t operand;
 uint64_t operation_;
 uint64_t opt, option;
 uint64_t osize;
 uint64_t pac;
 uint64_t page;
 uint64_t pair;
 uint64_t pairs;
 uint64_t part;
 uint64_t part1;
 uint64_t pat;
 uint64_t pattern;
 uint64_t poly;
 uint64_t pos;
 uint64_t position;
 uint64_t postindex;
 uint64_t pref_hint;
 uint64_t prfop;
 uint64_t ptype;
 uint64_t rd;
 uint64_t read;
 uint64_t regs;
 uint64_t regsize;
 uint64_t replicate;
 uint64_t rmode;
 uint64_t rot;
 uint64_t round;
 uint64_t rounding;
 uint64_t rpt;
 uint64_t rsize;
 uint64_t rn_unknown, rt_unknown;
 uint64_t rw;
 uint64_t s;
 uint64_t s_esize;
 uint64_t saturating;
 uint64_t scale;
 uint64_t sel;
 uint64_t sel_a;
 uint64_t sel_b;
 uint64_t selem;
 uint64_t setflags;
 uint64_t sf;
 uint64_t sh;
 uint64_t shift;
 uint64_t shift_amount;
 uint64_t shift_type;
 uint64_t signal_all_nans;
 uint64_t signed_;
 uint64_t simm7;
 uint64_t size;
 uint64_t source_is_sp;
 uint64_t src_index;
 uint64_t src_unsigned;
 uint64_t srcsize;
 uint64_t ssize, ssz;
 uint64_t stacctype;
 uint64_t stream;
 uint64_t sub_i;
 uint64_t sub_op;
 uint64_t sub_r;
 uint64_t swsize;
 uint64_t sys_crm;
 uint64_t sys_crn;
 uint64_t sys_op0;
 uint64_t sys_op1;
 uint64_t sys_op2;
 uint64_t sz;
 uint64_t t, t2, tb;
 uint64_t tag_checked;
 uint64_t tag_offset;
 uint64_t target_level;
 uint64_t tmask;
 uint64_t tsize;
 uint64_t tsz;
 uint64_t tszh;
 uint64_t tszl;
 uint64_t types;
 uint64_t uimm4;
 uint64_t uimm6;
 uint64_t unpriv_at_el1;
 uint64_t unpriv_at_el2;
 uint64_t uns;
 uint64_t unsigned_;
 uint64_t use_key_a;
 uint64_t user_access_override;
 uint64_t wback;
 uint64_t wb_unknown;
 uint64_t wmask;
 uint64_t writeback;
 uint64_t xs;
 uint64_t Zk, zero_data;

} context;





enum OperandClass {
 NONE = 0,
 IMM32,
 IMM64,
 FIMM32,
 STR_IMM,
 REG,
 MULTI_REG,
 SYS_REG,
 MEM_REG,
 MEM_PRE_IDX,
 MEM_POST_IDX,
 MEM_OFFSET,
 MEM_EXTENDED,
 LABEL,
 CONDITION,
 NAME,
 IMPLEMENTATION_SPECIFIC
};

enum Condition {
 COND_EQ, COND_NE, COND_CS, COND_CC,
 COND_MI, COND_PL, COND_VS, COND_VC,
 COND_HI, COND_LS, COND_GE, COND_LT,
 COND_GT, COND_LE, COND_AL, COND_NV,
 END_CONDITION
};

enum ShiftType {
 ShiftType_NONE, ShiftType_LSL, ShiftType_LSR, ShiftType_ASR,
 ShiftType_ROR, ShiftType_UXTW, ShiftType_SXTW, ShiftType_SXTX,
 ShiftType_UXTX, ShiftType_SXTB, ShiftType_SXTH, ShiftType_UXTH,
 ShiftType_UXTB, ShiftType_MSL, ShiftType_END,
};

enum Group {
 GROUP_UNALLOCATED,
 GROUP_DATA_PROCESSING_IMM,
 GROUP_BRANCH_EXCEPTION_SYSTEM,
 GROUP_LOAD_STORE,
 GROUP_DATA_PROCESSING_REG,
 GROUP_DATA_PROCESSING_SIMD,
 GROUP_DATA_PROCESSING_SIMD2,
 END_GROUP
};


 typedef enum SystemReg SystemReg;
 typedef enum OperandClass OperandClass;
 typedef enum Register Register;
 typedef enum Condition Condition;
 typedef enum ShiftType ShiftType;
 typedef enum Operation Operation;
 typedef enum Group Group;
 typedef enum ArrangementSpec ArrangementSpec;





struct InstructionOperand {
 OperandClass operandClass;
 ArrangementSpec arrSpec;
 Register reg[5];


 Condition cond;


 uint8_t implspec[5];


 SystemReg sysreg;

 
# 475 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 475 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     laneUsed;
 uint32_t lane;
 uint64_t immediate;
 ShiftType shiftType;
 
# 479 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 479 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     shiftValueUsed;
 uint32_t shiftValue;
 ShiftType extend;
 
# 482 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 482 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     signedImm;
 char pred_qual;
 
# 484 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 484 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     mul_vl;


 char name[16];
};


 typedef struct InstructionOperand InstructionOperand;




struct Instruction {
 uint32_t insword;
 enum ENCODING encoding;

 enum Operation operation;
 InstructionOperand operands[5];

 
# 503 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h" 3 4
_Bool 
# 503 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode.h"
     setflags;
};


typedef struct Instruction Instruction;






int aarch64_decompose(uint32_t instructionValue, Instruction *instr, uint64_t address);
size_t get_register_size(enum Register);
# 7 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 2
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.h" 1

       
int ABS_advsimd(context *ctx, Instruction *instr);
int ADC(context *ctx, Instruction *instr);
int ADCS(context *ctx, Instruction *instr);
int ADDG(context *ctx, Instruction *instr);
int ADDHN_advsimd(context *ctx, Instruction *instr);
int ADDP_advsimd_pair(context *ctx, Instruction *instr);
int ADDP_advsimd_vec(context *ctx, Instruction *instr);
int ADDS_addsub_ext(context *ctx, Instruction *instr);
int ADDS_addsub_imm(context *ctx, Instruction *instr);
int ADDS_addsub_shift(context *ctx, Instruction *instr);
int ADDV_advsimd(context *ctx, Instruction *instr);
int ADD_addsub_ext(context *ctx, Instruction *instr);
int ADD_addsub_imm(context *ctx, Instruction *instr);
int ADD_addsub_shift(context *ctx, Instruction *instr);
int ADD_advsimd(context *ctx, Instruction *instr);
int ADR(context *ctx, Instruction *instr);
int ADRP(context *ctx, Instruction *instr);
int AESD_advsimd(context *ctx, Instruction *instr);
int AESE_advsimd(context *ctx, Instruction *instr);
int AESIMC_advsimd(context *ctx, Instruction *instr);
int AESMC_advsimd(context *ctx, Instruction *instr);
int ANDS_log_imm(context *ctx, Instruction *instr);
int ANDS_log_shift(context *ctx, Instruction *instr);
int AND_advsimd(context *ctx, Instruction *instr);
int AND_log_imm(context *ctx, Instruction *instr);
int AND_log_shift(context *ctx, Instruction *instr);
int ASRV(context *ctx, Instruction *instr);
int ASR_ASRV(context *ctx, Instruction *instr);
int ASR_SBFM(context *ctx, Instruction *instr);
int AT_SYS(context *ctx, Instruction *instr);
int AUTDA(context *ctx, Instruction *instr);
int AUTDB(context *ctx, Instruction *instr);
int AUTIA(context *ctx, Instruction *instr);
int AUTIB(context *ctx, Instruction *instr);
int AXFLAG(context *ctx, Instruction *instr);
int BCAX_advsimd(context *ctx, Instruction *instr);
int BFCVTN_advsimd(context *ctx, Instruction *instr);
int BFCVT_float(context *ctx, Instruction *instr);
int BFC_BFM(context *ctx, Instruction *instr);
int BFDOT_advsimd_elt(context *ctx, Instruction *instr);
int BFDOT_advsimd_vec(context *ctx, Instruction *instr);
int BFI_BFM(context *ctx, Instruction *instr);
int BFM(context *ctx, Instruction *instr);
int BFMLAL_advsimd_elt(context *ctx, Instruction *instr);
int BFMLAL_advsimd_vec(context *ctx, Instruction *instr);
int BFMMLA_advsimd(context *ctx, Instruction *instr);
int BFXIL_BFM(context *ctx, Instruction *instr);
int BICS(context *ctx, Instruction *instr);
int BIC_advsimd_imm(context *ctx, Instruction *instr);
int BIC_advsimd_reg(context *ctx, Instruction *instr);
int BIC_and_z_zi(context *ctx, Instruction *instr);
int BIC_log_shift(context *ctx, Instruction *instr);
int BIF_advsimd(context *ctx, Instruction *instr);
int BIT_advsimd(context *ctx, Instruction *instr);
int BL(context *ctx, Instruction *instr);
int BLR(context *ctx, Instruction *instr);
int BLRA(context *ctx, Instruction *instr);
int BR(context *ctx, Instruction *instr);
int BRA(context *ctx, Instruction *instr);
int BRK(context *ctx, Instruction *instr);
int BSL_advsimd(context *ctx, Instruction *instr);
int BTI(context *ctx, Instruction *instr);
int B_cond(context *ctx, Instruction *instr);
int B_uncond(context *ctx, Instruction *instr);
int CAS(context *ctx, Instruction *instr);
int CASB(context *ctx, Instruction *instr);
int CASH(context *ctx, Instruction *instr);
int CASP(context *ctx, Instruction *instr);
int CBNZ(context *ctx, Instruction *instr);
int CBZ(context *ctx, Instruction *instr);
int CCMN_imm(context *ctx, Instruction *instr);
int CCMN_reg(context *ctx, Instruction *instr);
int CCMP_imm(context *ctx, Instruction *instr);
int CCMP_reg(context *ctx, Instruction *instr);
int CFINV(context *ctx, Instruction *instr);
int CFP_SYS(context *ctx, Instruction *instr);
int CINC_CSINC(context *ctx, Instruction *instr);
int CINV_CSINV(context *ctx, Instruction *instr);
int CLREX(context *ctx, Instruction *instr);
int CLS_advsimd(context *ctx, Instruction *instr);
int CLS_int(context *ctx, Instruction *instr);
int CLZ_advsimd(context *ctx, Instruction *instr);
int CLZ_int(context *ctx, Instruction *instr);
int CMEQ_advsimd_reg(context *ctx, Instruction *instr);
int CMEQ_advsimd_zero(context *ctx, Instruction *instr);
int CMGE_advsimd_reg(context *ctx, Instruction *instr);
int CMGE_advsimd_zero(context *ctx, Instruction *instr);
int CMGT_advsimd_reg(context *ctx, Instruction *instr);
int CMGT_advsimd_zero(context *ctx, Instruction *instr);
int CMHI_advsimd(context *ctx, Instruction *instr);
int CMHS_advsimd(context *ctx, Instruction *instr);
int CMLE_advsimd(context *ctx, Instruction *instr);
int CMLT_advsimd(context *ctx, Instruction *instr);
int CMN_ADDS_addsub_ext(context *ctx, Instruction *instr);
int CMN_ADDS_addsub_imm(context *ctx, Instruction *instr);
int CMN_ADDS_addsub_shift(context *ctx, Instruction *instr);
int CMPLE_cmpeq_p_p_zz(context *ctx, Instruction *instr);
int CMPLO_cmpeq_p_p_zz(context *ctx, Instruction *instr);
int CMPLS_cmpeq_p_p_zz(context *ctx, Instruction *instr);
int CMPLT_cmpeq_p_p_zz(context *ctx, Instruction *instr);
int CMPP_SUBPS(context *ctx, Instruction *instr);
int CMP_SUBS_addsub_ext(context *ctx, Instruction *instr);
int CMP_SUBS_addsub_imm(context *ctx, Instruction *instr);
int CMP_SUBS_addsub_shift(context *ctx, Instruction *instr);
int CMTST_advsimd(context *ctx, Instruction *instr);
int CNEG_CSNEG(context *ctx, Instruction *instr);
int CNT_advsimd(context *ctx, Instruction *instr);
int CPP_SYS(context *ctx, Instruction *instr);
int CRC32(context *ctx, Instruction *instr);
int CRC32C(context *ctx, Instruction *instr);
int CSDB(context *ctx, Instruction *instr);
int CSEL(context *ctx, Instruction *instr);
int CSETM_CSINV(context *ctx, Instruction *instr);
int CSET_CSINC(context *ctx, Instruction *instr);
int CSINC(context *ctx, Instruction *instr);
int CSINV(context *ctx, Instruction *instr);
int CSNEG(context *ctx, Instruction *instr);
int DCPS1(context *ctx, Instruction *instr);
int DCPS2(context *ctx, Instruction *instr);
int DCPS3(context *ctx, Instruction *instr);
int DC_SYS(context *ctx, Instruction *instr);
int DGH(context *ctx, Instruction *instr);
int DMB(context *ctx, Instruction *instr);
int DRPS(context *ctx, Instruction *instr);
int DSB(context *ctx, Instruction *instr);
int DUP_advsimd_elt(context *ctx, Instruction *instr);
int DUP_advsimd_gen(context *ctx, Instruction *instr);
int DVP_SYS(context *ctx, Instruction *instr);
int EON(context *ctx, Instruction *instr);
int EON_eor_z_zi(context *ctx, Instruction *instr);
int EOR3_advsimd(context *ctx, Instruction *instr);
int EOR_advsimd(context *ctx, Instruction *instr);
int EOR_log_imm(context *ctx, Instruction *instr);
int EOR_log_shift(context *ctx, Instruction *instr);
int ERET(context *ctx, Instruction *instr);
int ERETA(context *ctx, Instruction *instr);
int ESB(context *ctx, Instruction *instr);
int EXTR(context *ctx, Instruction *instr);
int EXT_advsimd(context *ctx, Instruction *instr);
int FABD_advsimd(context *ctx, Instruction *instr);
int FABS_advsimd(context *ctx, Instruction *instr);
int FABS_float(context *ctx, Instruction *instr);
int FACGE_advsimd(context *ctx, Instruction *instr);
int FACGT_advsimd(context *ctx, Instruction *instr);
int FACLE_facge_p_p_zz(context *ctx, Instruction *instr);
int FACLT_facge_p_p_zz(context *ctx, Instruction *instr);
int FADDP_advsimd_pair(context *ctx, Instruction *instr);
int FADDP_advsimd_vec(context *ctx, Instruction *instr);
int FADD_advsimd(context *ctx, Instruction *instr);
int FADD_float(context *ctx, Instruction *instr);
int FCADD_advsimd_vec(context *ctx, Instruction *instr);
int FCCMPE_float(context *ctx, Instruction *instr);
int FCCMP_float(context *ctx, Instruction *instr);
int FCMEQ_advsimd_reg(context *ctx, Instruction *instr);
int FCMEQ_advsimd_zero(context *ctx, Instruction *instr);
int FCMGE_advsimd_reg(context *ctx, Instruction *instr);
int FCMGE_advsimd_zero(context *ctx, Instruction *instr);
int FCMGT_advsimd_reg(context *ctx, Instruction *instr);
int FCMGT_advsimd_zero(context *ctx, Instruction *instr);
int FCMLA_advsimd_elt(context *ctx, Instruction *instr);
int FCMLA_advsimd_vec(context *ctx, Instruction *instr);
int FCMLE_advsimd(context *ctx, Instruction *instr);
int FCMLE_fcmeq_p_p_zz(context *ctx, Instruction *instr);
int FCMLT_advsimd(context *ctx, Instruction *instr);
int FCMLT_fcmeq_p_p_zz(context *ctx, Instruction *instr);
int FCMPE_float(context *ctx, Instruction *instr);
int FCMP_float(context *ctx, Instruction *instr);
int FCSEL_float(context *ctx, Instruction *instr);
int FCVTAS_advsimd(context *ctx, Instruction *instr);
int FCVTAS_float(context *ctx, Instruction *instr);
int FCVTAU_advsimd(context *ctx, Instruction *instr);
int FCVTAU_float(context *ctx, Instruction *instr);
int FCVTL_advsimd(context *ctx, Instruction *instr);
int FCVTMS_advsimd(context *ctx, Instruction *instr);
int FCVTMS_float(context *ctx, Instruction *instr);
int FCVTMU_advsimd(context *ctx, Instruction *instr);
int FCVTMU_float(context *ctx, Instruction *instr);
int FCVTNS_advsimd(context *ctx, Instruction *instr);
int FCVTNS_float(context *ctx, Instruction *instr);
int FCVTNU_advsimd(context *ctx, Instruction *instr);
int FCVTNU_float(context *ctx, Instruction *instr);
int FCVTN_advsimd(context *ctx, Instruction *instr);
int FCVTPS_advsimd(context *ctx, Instruction *instr);
int FCVTPS_float(context *ctx, Instruction *instr);
int FCVTPU_advsimd(context *ctx, Instruction *instr);
int FCVTPU_float(context *ctx, Instruction *instr);
int FCVTXN_advsimd(context *ctx, Instruction *instr);
int FCVTZS_advsimd_fix(context *ctx, Instruction *instr);
int FCVTZS_advsimd_int(context *ctx, Instruction *instr);
int FCVTZS_float_fix(context *ctx, Instruction *instr);
int FCVTZS_float_int(context *ctx, Instruction *instr);
int FCVTZU_advsimd_fix(context *ctx, Instruction *instr);
int FCVTZU_advsimd_int(context *ctx, Instruction *instr);
int FCVTZU_float_fix(context *ctx, Instruction *instr);
int FCVTZU_float_int(context *ctx, Instruction *instr);
int FCVT_float(context *ctx, Instruction *instr);
int FDIV_advsimd(context *ctx, Instruction *instr);
int FDIV_float(context *ctx, Instruction *instr);
int FJCVTZS(context *ctx, Instruction *instr);
int FMADD_float(context *ctx, Instruction *instr);
int FMAXNMP_advsimd_pair(context *ctx, Instruction *instr);
int FMAXNMP_advsimd_vec(context *ctx, Instruction *instr);
int FMAXNMV_advsimd(context *ctx, Instruction *instr);
int FMAXNM_advsimd(context *ctx, Instruction *instr);
int FMAXNM_float(context *ctx, Instruction *instr);
int FMAXP_advsimd_pair(context *ctx, Instruction *instr);
int FMAXP_advsimd_vec(context *ctx, Instruction *instr);
int FMAXV_advsimd(context *ctx, Instruction *instr);
int FMAX_advsimd(context *ctx, Instruction *instr);
int FMAX_float(context *ctx, Instruction *instr);
int FMINNMP_advsimd_pair(context *ctx, Instruction *instr);
int FMINNMP_advsimd_vec(context *ctx, Instruction *instr);
int FMINNMV_advsimd(context *ctx, Instruction *instr);
int FMINNM_advsimd(context *ctx, Instruction *instr);
int FMINNM_float(context *ctx, Instruction *instr);
int FMINP_advsimd_pair(context *ctx, Instruction *instr);
int FMINP_advsimd_vec(context *ctx, Instruction *instr);
int FMINV_advsimd(context *ctx, Instruction *instr);
int FMIN_advsimd(context *ctx, Instruction *instr);
int FMIN_float(context *ctx, Instruction *instr);
int FMLAL_advsimd_elt(context *ctx, Instruction *instr);
int FMLAL_advsimd_vec(context *ctx, Instruction *instr);
int FMLA_advsimd_elt(context *ctx, Instruction *instr);
int FMLA_advsimd_vec(context *ctx, Instruction *instr);
int FMLSL_advsimd_elt(context *ctx, Instruction *instr);
int FMLSL_advsimd_vec(context *ctx, Instruction *instr);
int FMLS_advsimd_elt(context *ctx, Instruction *instr);
int FMLS_advsimd_vec(context *ctx, Instruction *instr);
int FMOV_advsimd(context *ctx, Instruction *instr);
int FMOV_cpy_z_p_i(context *ctx, Instruction *instr);
int FMOV_dup_z_i(context *ctx, Instruction *instr);
int FMOV_fcpy_z_p_i(context *ctx, Instruction *instr);
int FMOV_fdup_z_i(context *ctx, Instruction *instr);
int FMOV_float(context *ctx, Instruction *instr);
int FMOV_float_gen(context *ctx, Instruction *instr);
int FMOV_float_imm(context *ctx, Instruction *instr);
int FMSUB_float(context *ctx, Instruction *instr);
int FMULX_advsimd_elt(context *ctx, Instruction *instr);
int FMULX_advsimd_vec(context *ctx, Instruction *instr);
int FMUL_advsimd_elt(context *ctx, Instruction *instr);
int FMUL_advsimd_vec(context *ctx, Instruction *instr);
int FMUL_float(context *ctx, Instruction *instr);
int FNEG_advsimd(context *ctx, Instruction *instr);
int FNEG_float(context *ctx, Instruction *instr);
int FNMADD_float(context *ctx, Instruction *instr);
int FNMSUB_float(context *ctx, Instruction *instr);
int FNMUL_float(context *ctx, Instruction *instr);
int FRECPE_advsimd(context *ctx, Instruction *instr);
int FRECPS_advsimd(context *ctx, Instruction *instr);
int FRECPX_advsimd(context *ctx, Instruction *instr);
int FRINT32X_advsimd(context *ctx, Instruction *instr);
int FRINT32X_float(context *ctx, Instruction *instr);
int FRINT32Z_advsimd(context *ctx, Instruction *instr);
int FRINT32Z_float(context *ctx, Instruction *instr);
int FRINT64X_advsimd(context *ctx, Instruction *instr);
int FRINT64X_float(context *ctx, Instruction *instr);
int FRINT64Z_advsimd(context *ctx, Instruction *instr);
int FRINT64Z_float(context *ctx, Instruction *instr);
int FRINTA_advsimd(context *ctx, Instruction *instr);
int FRINTA_float(context *ctx, Instruction *instr);
int FRINTI_advsimd(context *ctx, Instruction *instr);
int FRINTI_float(context *ctx, Instruction *instr);
int FRINTM_advsimd(context *ctx, Instruction *instr);
int FRINTM_float(context *ctx, Instruction *instr);
int FRINTN_advsimd(context *ctx, Instruction *instr);
int FRINTN_float(context *ctx, Instruction *instr);
int FRINTP_advsimd(context *ctx, Instruction *instr);
int FRINTP_float(context *ctx, Instruction *instr);
int FRINTX_advsimd(context *ctx, Instruction *instr);
int FRINTX_float(context *ctx, Instruction *instr);
int FRINTZ_advsimd(context *ctx, Instruction *instr);
int FRINTZ_float(context *ctx, Instruction *instr);
int FRSQRTE_advsimd(context *ctx, Instruction *instr);
int FRSQRTS_advsimd(context *ctx, Instruction *instr);
int FSQRT_advsimd(context *ctx, Instruction *instr);
int FSQRT_float(context *ctx, Instruction *instr);
int FSUB_advsimd(context *ctx, Instruction *instr);
int FSUB_float(context *ctx, Instruction *instr);
int GMI(context *ctx, Instruction *instr);
int HINT(context *ctx, Instruction *instr);
int HLT(context *ctx, Instruction *instr);
int HVC(context *ctx, Instruction *instr);
int IC_SYS(context *ctx, Instruction *instr);
int INS_advsimd_elt(context *ctx, Instruction *instr);
int INS_advsimd_gen(context *ctx, Instruction *instr);
int IRG(context *ctx, Instruction *instr);
int ISB(context *ctx, Instruction *instr);
int LD1R_advsimd(context *ctx, Instruction *instr);
int LD1_advsimd_mult(context *ctx, Instruction *instr);
int LD1_advsimd_sngl(context *ctx, Instruction *instr);
int LD2R_advsimd(context *ctx, Instruction *instr);
int LD2_advsimd_mult(context *ctx, Instruction *instr);
int LD2_advsimd_sngl(context *ctx, Instruction *instr);
int LD3R_advsimd(context *ctx, Instruction *instr);
int LD3_advsimd_mult(context *ctx, Instruction *instr);
int LD3_advsimd_sngl(context *ctx, Instruction *instr);
int LD4R_advsimd(context *ctx, Instruction *instr);
int LD4_advsimd_mult(context *ctx, Instruction *instr);
int LD4_advsimd_sngl(context *ctx, Instruction *instr);
int LD64B(context *ctx, Instruction *instr);
int LDADD(context *ctx, Instruction *instr);
int LDADDB(context *ctx, Instruction *instr);
int LDADDH(context *ctx, Instruction *instr);
int LDAPR(context *ctx, Instruction *instr);
int LDAPRB(context *ctx, Instruction *instr);
int LDAPRH(context *ctx, Instruction *instr);
int LDAPURB(context *ctx, Instruction *instr);
int LDAPURH(context *ctx, Instruction *instr);
int LDAPURSB(context *ctx, Instruction *instr);
int LDAPURSH(context *ctx, Instruction *instr);
int LDAPURSW(context *ctx, Instruction *instr);
int LDAPUR_gen(context *ctx, Instruction *instr);
int LDAR(context *ctx, Instruction *instr);
int LDARB(context *ctx, Instruction *instr);
int LDARH(context *ctx, Instruction *instr);
int LDAXP(context *ctx, Instruction *instr);
int LDAXR(context *ctx, Instruction *instr);
int LDAXRB(context *ctx, Instruction *instr);
int LDAXRH(context *ctx, Instruction *instr);
int LDCLR(context *ctx, Instruction *instr);
int LDCLRB(context *ctx, Instruction *instr);
int LDCLRH(context *ctx, Instruction *instr);
int LDEOR(context *ctx, Instruction *instr);
int LDEORB(context *ctx, Instruction *instr);
int LDEORH(context *ctx, Instruction *instr);
int LDG(context *ctx, Instruction *instr);
int LDGM(context *ctx, Instruction *instr);
int LDLAR(context *ctx, Instruction *instr);
int LDLARB(context *ctx, Instruction *instr);
int LDLARH(context *ctx, Instruction *instr);
int LDNP_fpsimd(context *ctx, Instruction *instr);
int LDNP_gen(context *ctx, Instruction *instr);
int LDPSW(context *ctx, Instruction *instr);
int LDP_fpsimd(context *ctx, Instruction *instr);
int LDP_gen(context *ctx, Instruction *instr);
int LDRA(context *ctx, Instruction *instr);
int LDRB_imm(context *ctx, Instruction *instr);
int LDRB_reg(context *ctx, Instruction *instr);
int LDRH_imm(context *ctx, Instruction *instr);
int LDRH_reg(context *ctx, Instruction *instr);
int LDRSB_imm(context *ctx, Instruction *instr);
int LDRSB_reg(context *ctx, Instruction *instr);
int LDRSH_imm(context *ctx, Instruction *instr);
int LDRSH_reg(context *ctx, Instruction *instr);
int LDRSW_imm(context *ctx, Instruction *instr);
int LDRSW_lit(context *ctx, Instruction *instr);
int LDRSW_reg(context *ctx, Instruction *instr);
int LDR_imm_fpsimd(context *ctx, Instruction *instr);
int LDR_imm_gen(context *ctx, Instruction *instr);
int LDR_lit_fpsimd(context *ctx, Instruction *instr);
int LDR_lit_gen(context *ctx, Instruction *instr);
int LDR_reg_fpsimd(context *ctx, Instruction *instr);
int LDR_reg_gen(context *ctx, Instruction *instr);
int LDSET(context *ctx, Instruction *instr);
int LDSETB(context *ctx, Instruction *instr);
int LDSETH(context *ctx, Instruction *instr);
int LDSMAX(context *ctx, Instruction *instr);
int LDSMAXB(context *ctx, Instruction *instr);
int LDSMAXH(context *ctx, Instruction *instr);
int LDSMIN(context *ctx, Instruction *instr);
int LDSMINB(context *ctx, Instruction *instr);
int LDSMINH(context *ctx, Instruction *instr);
int LDTR(context *ctx, Instruction *instr);
int LDTRB(context *ctx, Instruction *instr);
int LDTRH(context *ctx, Instruction *instr);
int LDTRSB(context *ctx, Instruction *instr);
int LDTRSH(context *ctx, Instruction *instr);
int LDTRSW(context *ctx, Instruction *instr);
int LDUMAX(context *ctx, Instruction *instr);
int LDUMAXB(context *ctx, Instruction *instr);
int LDUMAXH(context *ctx, Instruction *instr);
int LDUMIN(context *ctx, Instruction *instr);
int LDUMINB(context *ctx, Instruction *instr);
int LDUMINH(context *ctx, Instruction *instr);
int LDURB(context *ctx, Instruction *instr);
int LDURH(context *ctx, Instruction *instr);
int LDURSB(context *ctx, Instruction *instr);
int LDURSH(context *ctx, Instruction *instr);
int LDURSW(context *ctx, Instruction *instr);
int LDUR_fpsimd(context *ctx, Instruction *instr);
int LDUR_gen(context *ctx, Instruction *instr);
int LDXP(context *ctx, Instruction *instr);
int LDXR(context *ctx, Instruction *instr);
int LDXRB(context *ctx, Instruction *instr);
int LDXRH(context *ctx, Instruction *instr);
int LSLV(context *ctx, Instruction *instr);
int LSL_LSLV(context *ctx, Instruction *instr);
int LSL_UBFM(context *ctx, Instruction *instr);
int LSRV(context *ctx, Instruction *instr);
int LSR_LSRV(context *ctx, Instruction *instr);
int LSR_UBFM(context *ctx, Instruction *instr);
int MADD(context *ctx, Instruction *instr);
int MLA_advsimd_elt(context *ctx, Instruction *instr);
int MLA_advsimd_vec(context *ctx, Instruction *instr);
int MLS_advsimd_elt(context *ctx, Instruction *instr);
int MLS_advsimd_vec(context *ctx, Instruction *instr);
int MNEG_MSUB(context *ctx, Instruction *instr);
int MOVI_advsimd(context *ctx, Instruction *instr);
int MOVK(context *ctx, Instruction *instr);
int MOVN(context *ctx, Instruction *instr);
int MOVS_and_p_p_pp(context *ctx, Instruction *instr);
int MOVS_orr_p_p_pp(context *ctx, Instruction *instr);
int MOVZ(context *ctx, Instruction *instr);
int MOV_ADD_addsub_imm(context *ctx, Instruction *instr);
int MOV_DUP_advsimd_elt(context *ctx, Instruction *instr);
int MOV_INS_advsimd_elt(context *ctx, Instruction *instr);
int MOV_INS_advsimd_gen(context *ctx, Instruction *instr);
int MOV_MOVN(context *ctx, Instruction *instr);
int MOV_MOVZ(context *ctx, Instruction *instr);
int MOV_ORR_advsimd_reg(context *ctx, Instruction *instr);
int MOV_ORR_log_imm(context *ctx, Instruction *instr);
int MOV_ORR_log_shift(context *ctx, Instruction *instr);
int MOV_UMOV_advsimd(context *ctx, Instruction *instr);
int MOV_and_p_p_pp(context *ctx, Instruction *instr);
int MOV_cpy_z_o_i(context *ctx, Instruction *instr);
int MOV_cpy_z_p_i(context *ctx, Instruction *instr);
int MOV_cpy_z_p_r(context *ctx, Instruction *instr);
int MOV_cpy_z_p_v(context *ctx, Instruction *instr);
int MOV_dup_z_i(context *ctx, Instruction *instr);
int MOV_dup_z_r(context *ctx, Instruction *instr);
int MOV_dup_z_zi(context *ctx, Instruction *instr);
int MOV_dupm_z_i(context *ctx, Instruction *instr);
int MOV_orr_p_p_pp(context *ctx, Instruction *instr);
int MOV_orr_z_zz(context *ctx, Instruction *instr);
int MOV_sel_p_p_pp(context *ctx, Instruction *instr);
int MOV_sel_z_p_zz(context *ctx, Instruction *instr);
int MRS(context *ctx, Instruction *instr);
int MSR_imm(context *ctx, Instruction *instr);
int MSR_reg(context *ctx, Instruction *instr);
int MSUB(context *ctx, Instruction *instr);
int MUL_MADD(context *ctx, Instruction *instr);
int MUL_advsimd_elt(context *ctx, Instruction *instr);
int MUL_advsimd_vec(context *ctx, Instruction *instr);
int MVNI_advsimd(context *ctx, Instruction *instr);
int MVN_NOT_advsimd(context *ctx, Instruction *instr);
int MVN_ORN_log_shift(context *ctx, Instruction *instr);
int NEGS_SUBS_addsub_shift(context *ctx, Instruction *instr);
int NEG_SUB_addsub_shift(context *ctx, Instruction *instr);
int NEG_advsimd(context *ctx, Instruction *instr);
int NGCS_SBCS(context *ctx, Instruction *instr);
int NGC_SBC(context *ctx, Instruction *instr);
int NOP(context *ctx, Instruction *instr);
int NOTS_eor_p_p_pp(context *ctx, Instruction *instr);
int NOT_advsimd(context *ctx, Instruction *instr);
int NOT_eor_p_p_pp(context *ctx, Instruction *instr);
int ORN_advsimd(context *ctx, Instruction *instr);
int ORN_log_shift(context *ctx, Instruction *instr);
int ORN_orr_z_zi(context *ctx, Instruction *instr);
int ORR_advsimd_imm(context *ctx, Instruction *instr);
int ORR_advsimd_reg(context *ctx, Instruction *instr);
int ORR_log_imm(context *ctx, Instruction *instr);
int ORR_log_shift(context *ctx, Instruction *instr);
int PACDA(context *ctx, Instruction *instr);
int PACDB(context *ctx, Instruction *instr);
int PACGA(context *ctx, Instruction *instr);
int PACIA(context *ctx, Instruction *instr);
int PACIB(context *ctx, Instruction *instr);
int PMULL_advsimd(context *ctx, Instruction *instr);
int PMUL_advsimd(context *ctx, Instruction *instr);
int PRFM_imm(context *ctx, Instruction *instr);
int PRFM_lit(context *ctx, Instruction *instr);
int PRFM_reg(context *ctx, Instruction *instr);
int PRFUM(context *ctx, Instruction *instr);
int PSB(context *ctx, Instruction *instr);
int PSSBB_DSB(context *ctx, Instruction *instr);
int RADDHN_advsimd(context *ctx, Instruction *instr);
int RAX1_advsimd(context *ctx, Instruction *instr);
int RBIT_advsimd(context *ctx, Instruction *instr);
int RBIT_int(context *ctx, Instruction *instr);
int RET(context *ctx, Instruction *instr);
int RETA(context *ctx, Instruction *instr);
int REV(context *ctx, Instruction *instr);
int REV16_advsimd(context *ctx, Instruction *instr);
int REV16_int(context *ctx, Instruction *instr);
int REV32_advsimd(context *ctx, Instruction *instr);
int REV32_int(context *ctx, Instruction *instr);
int REV64_REV(context *ctx, Instruction *instr);
int REV64_advsimd(context *ctx, Instruction *instr);
int RMIF(context *ctx, Instruction *instr);
int RORV(context *ctx, Instruction *instr);
int ROR_EXTR(context *ctx, Instruction *instr);
int ROR_RORV(context *ctx, Instruction *instr);
int RSHRN_advsimd(context *ctx, Instruction *instr);
int RSUBHN_advsimd(context *ctx, Instruction *instr);
int SABAL_advsimd(context *ctx, Instruction *instr);
int SABA_advsimd(context *ctx, Instruction *instr);
int SABDL_advsimd(context *ctx, Instruction *instr);
int SABD_advsimd(context *ctx, Instruction *instr);
int SADALP_advsimd(context *ctx, Instruction *instr);
int SADDLP_advsimd(context *ctx, Instruction *instr);
int SADDLV_advsimd(context *ctx, Instruction *instr);
int SADDL_advsimd(context *ctx, Instruction *instr);
int SADDW_advsimd(context *ctx, Instruction *instr);
int SB(context *ctx, Instruction *instr);
int SBC(context *ctx, Instruction *instr);
int SBCS(context *ctx, Instruction *instr);
int SBFIZ_SBFM(context *ctx, Instruction *instr);
int SBFM(context *ctx, Instruction *instr);
int SBFX_SBFM(context *ctx, Instruction *instr);
int SCVTF_advsimd_fix(context *ctx, Instruction *instr);
int SCVTF_advsimd_int(context *ctx, Instruction *instr);
int SCVTF_float_fix(context *ctx, Instruction *instr);
int SCVTF_float_int(context *ctx, Instruction *instr);
int SDIV(context *ctx, Instruction *instr);
int SDOT_advsimd_elt(context *ctx, Instruction *instr);
int SDOT_advsimd_vec(context *ctx, Instruction *instr);
int SETF(context *ctx, Instruction *instr);
int SEV(context *ctx, Instruction *instr);
int SEVL(context *ctx, Instruction *instr);
int SHA1C_advsimd(context *ctx, Instruction *instr);
int SHA1H_advsimd(context *ctx, Instruction *instr);
int SHA1M_advsimd(context *ctx, Instruction *instr);
int SHA1P_advsimd(context *ctx, Instruction *instr);
int SHA1SU0_advsimd(context *ctx, Instruction *instr);
int SHA1SU1_advsimd(context *ctx, Instruction *instr);
int SHA256H2_advsimd(context *ctx, Instruction *instr);
int SHA256H_advsimd(context *ctx, Instruction *instr);
int SHA256SU0_advsimd(context *ctx, Instruction *instr);
int SHA256SU1_advsimd(context *ctx, Instruction *instr);
int SHA512H2_advsimd(context *ctx, Instruction *instr);
int SHA512H_advsimd(context *ctx, Instruction *instr);
int SHA512SU0_advsimd(context *ctx, Instruction *instr);
int SHA512SU1_advsimd(context *ctx, Instruction *instr);
int SHADD_advsimd(context *ctx, Instruction *instr);
int SHLL_advsimd(context *ctx, Instruction *instr);
int SHL_advsimd(context *ctx, Instruction *instr);
int SHRN_advsimd(context *ctx, Instruction *instr);
int SHSUB_advsimd(context *ctx, Instruction *instr);
int SLI_advsimd(context *ctx, Instruction *instr);
int SM3PARTW1_advsimd(context *ctx, Instruction *instr);
int SM3PARTW2_advsimd(context *ctx, Instruction *instr);
int SM3SS1_advsimd(context *ctx, Instruction *instr);
int SM3TT1A_advsimd(context *ctx, Instruction *instr);
int SM3TT1B_advsimd(context *ctx, Instruction *instr);
int SM3TT2A_advsimd(context *ctx, Instruction *instr);
int SM3TT2B_advsimd(context *ctx, Instruction *instr);
int SM4EKEY_advsimd(context *ctx, Instruction *instr);
int SM4E_advsimd(context *ctx, Instruction *instr);
int SMADDL(context *ctx, Instruction *instr);
int SMAXP_advsimd(context *ctx, Instruction *instr);
int SMAXV_advsimd(context *ctx, Instruction *instr);
int SMAX_advsimd(context *ctx, Instruction *instr);
int SMC(context *ctx, Instruction *instr);
int SMINP_advsimd(context *ctx, Instruction *instr);
int SMINV_advsimd(context *ctx, Instruction *instr);
int SMIN_advsimd(context *ctx, Instruction *instr);
int SMLAL_advsimd_elt(context *ctx, Instruction *instr);
int SMLAL_advsimd_vec(context *ctx, Instruction *instr);
int SMLSL_advsimd_elt(context *ctx, Instruction *instr);
int SMLSL_advsimd_vec(context *ctx, Instruction *instr);
int SMMLA_advsimd_vec(context *ctx, Instruction *instr);
int SMNEGL_SMSUBL(context *ctx, Instruction *instr);
int SMOV_advsimd(context *ctx, Instruction *instr);
int SMSUBL(context *ctx, Instruction *instr);
int SMULH(context *ctx, Instruction *instr);
int SMULL_SMADDL(context *ctx, Instruction *instr);
int SMULL_advsimd_elt(context *ctx, Instruction *instr);
int SMULL_advsimd_vec(context *ctx, Instruction *instr);
int SQABS_advsimd(context *ctx, Instruction *instr);
int SQADD_advsimd(context *ctx, Instruction *instr);
int SQDMLAL_advsimd_elt(context *ctx, Instruction *instr);
int SQDMLAL_advsimd_vec(context *ctx, Instruction *instr);
int SQDMLSL_advsimd_elt(context *ctx, Instruction *instr);
int SQDMLSL_advsimd_vec(context *ctx, Instruction *instr);
int SQDMULH_advsimd_elt(context *ctx, Instruction *instr);
int SQDMULH_advsimd_vec(context *ctx, Instruction *instr);
int SQDMULL_advsimd_elt(context *ctx, Instruction *instr);
int SQDMULL_advsimd_vec(context *ctx, Instruction *instr);
int SQNEG_advsimd(context *ctx, Instruction *instr);
int SQRDMLAH_advsimd_elt(context *ctx, Instruction *instr);
int SQRDMLAH_advsimd_vec(context *ctx, Instruction *instr);
int SQRDMLSH_advsimd_elt(context *ctx, Instruction *instr);
int SQRDMLSH_advsimd_vec(context *ctx, Instruction *instr);
int SQRDMULH_advsimd_elt(context *ctx, Instruction *instr);
int SQRDMULH_advsimd_vec(context *ctx, Instruction *instr);
int SQRSHL_advsimd(context *ctx, Instruction *instr);
int SQRSHRN_advsimd(context *ctx, Instruction *instr);
int SQRSHRUN_advsimd(context *ctx, Instruction *instr);
int SQSHLU_advsimd(context *ctx, Instruction *instr);
int SQSHL_advsimd_imm(context *ctx, Instruction *instr);
int SQSHL_advsimd_reg(context *ctx, Instruction *instr);
int SQSHRN_advsimd(context *ctx, Instruction *instr);
int SQSHRUN_advsimd(context *ctx, Instruction *instr);
int SQSUB_advsimd(context *ctx, Instruction *instr);
int SQXTN_advsimd(context *ctx, Instruction *instr);
int SQXTUN_advsimd(context *ctx, Instruction *instr);
int SRHADD_advsimd(context *ctx, Instruction *instr);
int SRI_advsimd(context *ctx, Instruction *instr);
int SRSHL_advsimd(context *ctx, Instruction *instr);
int SRSHR_advsimd(context *ctx, Instruction *instr);
int SRSRA_advsimd(context *ctx, Instruction *instr);
int SSBB_DSB(context *ctx, Instruction *instr);
int SSHLL_advsimd(context *ctx, Instruction *instr);
int SSHL_advsimd(context *ctx, Instruction *instr);
int SSHR_advsimd(context *ctx, Instruction *instr);
int SSRA_advsimd(context *ctx, Instruction *instr);
int SSUBL_advsimd(context *ctx, Instruction *instr);
int SSUBW_advsimd(context *ctx, Instruction *instr);
int ST1_advsimd_mult(context *ctx, Instruction *instr);
int ST1_advsimd_sngl(context *ctx, Instruction *instr);
int ST2G(context *ctx, Instruction *instr);
int ST2_advsimd_mult(context *ctx, Instruction *instr);
int ST2_advsimd_sngl(context *ctx, Instruction *instr);
int ST3_advsimd_mult(context *ctx, Instruction *instr);
int ST3_advsimd_sngl(context *ctx, Instruction *instr);
int ST4_advsimd_mult(context *ctx, Instruction *instr);
int ST4_advsimd_sngl(context *ctx, Instruction *instr);
int ST64B(context *ctx, Instruction *instr);
int ST64BV(context *ctx, Instruction *instr);
int ST64BV0(context *ctx, Instruction *instr);
int STADDB_LDADDB(context *ctx, Instruction *instr);
int STADDH_LDADDH(context *ctx, Instruction *instr);
int STADD_LDADD(context *ctx, Instruction *instr);
int STCLRB_LDCLRB(context *ctx, Instruction *instr);
int STCLRH_LDCLRH(context *ctx, Instruction *instr);
int STCLR_LDCLR(context *ctx, Instruction *instr);
int STEORB_LDEORB(context *ctx, Instruction *instr);
int STEORH_LDEORH(context *ctx, Instruction *instr);
int STEOR_LDEOR(context *ctx, Instruction *instr);
int STG(context *ctx, Instruction *instr);
int STGM(context *ctx, Instruction *instr);
int STGP(context *ctx, Instruction *instr);
int STLLR(context *ctx, Instruction *instr);
int STLLRB(context *ctx, Instruction *instr);
int STLLRH(context *ctx, Instruction *instr);
int STLR(context *ctx, Instruction *instr);
int STLRB(context *ctx, Instruction *instr);
int STLRH(context *ctx, Instruction *instr);
int STLURB(context *ctx, Instruction *instr);
int STLURH(context *ctx, Instruction *instr);
int STLUR_gen(context *ctx, Instruction *instr);
int STLXP(context *ctx, Instruction *instr);
int STLXR(context *ctx, Instruction *instr);
int STLXRB(context *ctx, Instruction *instr);
int STLXRH(context *ctx, Instruction *instr);
int STNP_fpsimd(context *ctx, Instruction *instr);
int STNP_gen(context *ctx, Instruction *instr);
int STP_fpsimd(context *ctx, Instruction *instr);
int STP_gen(context *ctx, Instruction *instr);
int STRB_imm(context *ctx, Instruction *instr);
int STRB_reg(context *ctx, Instruction *instr);
int STRH_imm(context *ctx, Instruction *instr);
int STRH_reg(context *ctx, Instruction *instr);
int STR_imm_fpsimd(context *ctx, Instruction *instr);
int STR_imm_gen(context *ctx, Instruction *instr);
int STR_reg_fpsimd(context *ctx, Instruction *instr);
int STR_reg_gen(context *ctx, Instruction *instr);
int STSETB_LDSETB(context *ctx, Instruction *instr);
int STSETH_LDSETH(context *ctx, Instruction *instr);
int STSET_LDSET(context *ctx, Instruction *instr);
int STSMAXB_LDSMAXB(context *ctx, Instruction *instr);
int STSMAXH_LDSMAXH(context *ctx, Instruction *instr);
int STSMAX_LDSMAX(context *ctx, Instruction *instr);
int STSMINB_LDSMINB(context *ctx, Instruction *instr);
int STSMINH_LDSMINH(context *ctx, Instruction *instr);
int STSMIN_LDSMIN(context *ctx, Instruction *instr);
int STTR(context *ctx, Instruction *instr);
int STTRB(context *ctx, Instruction *instr);
int STTRH(context *ctx, Instruction *instr);
int STUMAXB_LDUMAXB(context *ctx, Instruction *instr);
int STUMAXH_LDUMAXH(context *ctx, Instruction *instr);
int STUMAX_LDUMAX(context *ctx, Instruction *instr);
int STUMINB_LDUMINB(context *ctx, Instruction *instr);
int STUMINH_LDUMINH(context *ctx, Instruction *instr);
int STUMIN_LDUMIN(context *ctx, Instruction *instr);
int STURB(context *ctx, Instruction *instr);
int STURH(context *ctx, Instruction *instr);
int STUR_fpsimd(context *ctx, Instruction *instr);
int STUR_gen(context *ctx, Instruction *instr);
int STXP(context *ctx, Instruction *instr);
int STXR(context *ctx, Instruction *instr);
int STXRB(context *ctx, Instruction *instr);
int STXRH(context *ctx, Instruction *instr);
int STZ2G(context *ctx, Instruction *instr);
int STZG(context *ctx, Instruction *instr);
int STZGM(context *ctx, Instruction *instr);
int SUBG(context *ctx, Instruction *instr);
int SUBHN_advsimd(context *ctx, Instruction *instr);
int SUBP(context *ctx, Instruction *instr);
int SUBPS(context *ctx, Instruction *instr);
int SUBS_addsub_ext(context *ctx, Instruction *instr);
int SUBS_addsub_imm(context *ctx, Instruction *instr);
int SUBS_addsub_shift(context *ctx, Instruction *instr);
int SUB_addsub_ext(context *ctx, Instruction *instr);
int SUB_addsub_imm(context *ctx, Instruction *instr);
int SUB_addsub_shift(context *ctx, Instruction *instr);
int SUB_advsimd(context *ctx, Instruction *instr);
int SUDOT_advsimd_elt(context *ctx, Instruction *instr);
int SUQADD_advsimd(context *ctx, Instruction *instr);
int SVC(context *ctx, Instruction *instr);
int SWP(context *ctx, Instruction *instr);
int SWPB(context *ctx, Instruction *instr);
int SWPH(context *ctx, Instruction *instr);
int SXTB_SBFM(context *ctx, Instruction *instr);
int SXTH_SBFM(context *ctx, Instruction *instr);
int SXTL_SSHLL_advsimd(context *ctx, Instruction *instr);
int SXTW_SBFM(context *ctx, Instruction *instr);
int SYS(context *ctx, Instruction *instr);
int SYSL(context *ctx, Instruction *instr);
int TBL_advsimd(context *ctx, Instruction *instr);
int TBNZ(context *ctx, Instruction *instr);
int TBX_advsimd(context *ctx, Instruction *instr);
int TBZ(context *ctx, Instruction *instr);
int TCANCEL(context *ctx, Instruction *instr);
int TCOMMIT(context *ctx, Instruction *instr);
int TLBI_SYS(context *ctx, Instruction *instr);
int TRN1_advsimd(context *ctx, Instruction *instr);
int TRN2_advsimd(context *ctx, Instruction *instr);
int TSB(context *ctx, Instruction *instr);
int TSTART(context *ctx, Instruction *instr);
int TST_ANDS_log_imm(context *ctx, Instruction *instr);
int TST_ANDS_log_shift(context *ctx, Instruction *instr);
int TTEST(context *ctx, Instruction *instr);
int UABAL_advsimd(context *ctx, Instruction *instr);
int UABA_advsimd(context *ctx, Instruction *instr);
int UABDL_advsimd(context *ctx, Instruction *instr);
int UABD_advsimd(context *ctx, Instruction *instr);
int UADALP_advsimd(context *ctx, Instruction *instr);
int UADDLP_advsimd(context *ctx, Instruction *instr);
int UADDLV_advsimd(context *ctx, Instruction *instr);
int UADDL_advsimd(context *ctx, Instruction *instr);
int UADDW_advsimd(context *ctx, Instruction *instr);
int UBFIZ_UBFM(context *ctx, Instruction *instr);
int UBFM(context *ctx, Instruction *instr);
int UBFX_UBFM(context *ctx, Instruction *instr);
int UCVTF_advsimd_fix(context *ctx, Instruction *instr);
int UCVTF_advsimd_int(context *ctx, Instruction *instr);
int UCVTF_float_fix(context *ctx, Instruction *instr);
int UCVTF_float_int(context *ctx, Instruction *instr);
int UDF_perm_undef(context *ctx, Instruction *instr);
int UDIV(context *ctx, Instruction *instr);
int UDOT_advsimd_elt(context *ctx, Instruction *instr);
int UDOT_advsimd_vec(context *ctx, Instruction *instr);
int UHADD_advsimd(context *ctx, Instruction *instr);
int UHSUB_advsimd(context *ctx, Instruction *instr);
int UMADDL(context *ctx, Instruction *instr);
int UMAXP_advsimd(context *ctx, Instruction *instr);
int UMAXV_advsimd(context *ctx, Instruction *instr);
int UMAX_advsimd(context *ctx, Instruction *instr);
int UMINP_advsimd(context *ctx, Instruction *instr);
int UMINV_advsimd(context *ctx, Instruction *instr);
int UMIN_advsimd(context *ctx, Instruction *instr);
int UMLAL_advsimd_elt(context *ctx, Instruction *instr);
int UMLAL_advsimd_vec(context *ctx, Instruction *instr);
int UMLSL_advsimd_elt(context *ctx, Instruction *instr);
int UMLSL_advsimd_vec(context *ctx, Instruction *instr);
int UMMLA_advsimd_vec(context *ctx, Instruction *instr);
int UMNEGL_UMSUBL(context *ctx, Instruction *instr);
int UMOV_advsimd(context *ctx, Instruction *instr);
int UMSUBL(context *ctx, Instruction *instr);
int UMULH(context *ctx, Instruction *instr);
int UMULL_UMADDL(context *ctx, Instruction *instr);
int UMULL_advsimd_elt(context *ctx, Instruction *instr);
int UMULL_advsimd_vec(context *ctx, Instruction *instr);
int UQADD_advsimd(context *ctx, Instruction *instr);
int UQRSHL_advsimd(context *ctx, Instruction *instr);
int UQRSHRN_advsimd(context *ctx, Instruction *instr);
int UQSHL_advsimd_imm(context *ctx, Instruction *instr);
int UQSHL_advsimd_reg(context *ctx, Instruction *instr);
int UQSHRN_advsimd(context *ctx, Instruction *instr);
int UQSUB_advsimd(context *ctx, Instruction *instr);
int UQXTN_advsimd(context *ctx, Instruction *instr);
int URECPE_advsimd(context *ctx, Instruction *instr);
int URHADD_advsimd(context *ctx, Instruction *instr);
int URSHL_advsimd(context *ctx, Instruction *instr);
int URSHR_advsimd(context *ctx, Instruction *instr);
int URSQRTE_advsimd(context *ctx, Instruction *instr);
int URSRA_advsimd(context *ctx, Instruction *instr);
int USDOT_advsimd_elt(context *ctx, Instruction *instr);
int USDOT_advsimd_vec(context *ctx, Instruction *instr);
int USHLL_advsimd(context *ctx, Instruction *instr);
int USHL_advsimd(context *ctx, Instruction *instr);
int USHR_advsimd(context *ctx, Instruction *instr);
int USMMLA_advsimd_vec(context *ctx, Instruction *instr);
int USQADD_advsimd(context *ctx, Instruction *instr);
int USRA_advsimd(context *ctx, Instruction *instr);
int USUBL_advsimd(context *ctx, Instruction *instr);
int USUBW_advsimd(context *ctx, Instruction *instr);
int UXTB_UBFM(context *ctx, Instruction *instr);
int UXTH_UBFM(context *ctx, Instruction *instr);
int UXTL_USHLL_advsimd(context *ctx, Instruction *instr);
int UZP1_advsimd(context *ctx, Instruction *instr);
int UZP2_advsimd(context *ctx, Instruction *instr);
int WFE(context *ctx, Instruction *instr);
int WFET(context *ctx, Instruction *instr);
int WFI(context *ctx, Instruction *instr);
int WFIT(context *ctx, Instruction *instr);
int XAFLAG(context *ctx, Instruction *instr);
int XAR_advsimd(context *ctx, Instruction *instr);
int XPAC(context *ctx, Instruction *instr);
int XTN_advsimd(context *ctx, Instruction *instr);
int YIELD(context *ctx, Instruction *instr);
int ZIP1_advsimd(context *ctx, Instruction *instr);
int ZIP2_advsimd(context *ctx, Instruction *instr);
int abs_z_p_z(context *ctx, Instruction *instr);
int adclb_z_zzz(context *ctx, Instruction *instr);
int adclt_z_zzz(context *ctx, Instruction *instr);
int add_z_p_zz(context *ctx, Instruction *instr);
int add_z_zi(context *ctx, Instruction *instr);
int add_z_zz(context *ctx, Instruction *instr);
int addhnb_z_zz(context *ctx, Instruction *instr);
int addhnt_z_zz(context *ctx, Instruction *instr);
int addp_z_p_zz(context *ctx, Instruction *instr);
int addpl_r_ri(context *ctx, Instruction *instr);
int addvl_r_ri(context *ctx, Instruction *instr);
int adr_z_az(context *ctx, Instruction *instr);
int aesd_z_zz(context *ctx, Instruction *instr);
int aese_z_zz(context *ctx, Instruction *instr);
int aesimc_z_z(context *ctx, Instruction *instr);
int aesmc_z_z(context *ctx, Instruction *instr);
int and_p_p_pp(context *ctx, Instruction *instr);
int and_z_p_zz(context *ctx, Instruction *instr);
int and_z_zi(context *ctx, Instruction *instr);
int and_z_zz(context *ctx, Instruction *instr);
int andv_r_p_z(context *ctx, Instruction *instr);
int asr_z_p_zi(context *ctx, Instruction *instr);
int asr_z_p_zw(context *ctx, Instruction *instr);
int asr_z_p_zz(context *ctx, Instruction *instr);
int asr_z_zi(context *ctx, Instruction *instr);
int asr_z_zw(context *ctx, Instruction *instr);
int asrd_z_p_zi(context *ctx, Instruction *instr);
int asrr_z_p_zz(context *ctx, Instruction *instr);
int bcax_z_zzz(context *ctx, Instruction *instr);
int bdep_z_zz(context *ctx, Instruction *instr);
int bext_z_zz(context *ctx, Instruction *instr);
int bfcvt_z_p_z(context *ctx, Instruction *instr);
int bfcvtnt_z_p_z(context *ctx, Instruction *instr);
int bfdot_z_zzz(context *ctx, Instruction *instr);
int bfdot_z_zzzi(context *ctx, Instruction *instr);
int bfmlalb_z_zzz(context *ctx, Instruction *instr);
int bfmlalb_z_zzzi(context *ctx, Instruction *instr);
int bfmlalt_z_zzz(context *ctx, Instruction *instr);
int bfmlalt_z_zzzi(context *ctx, Instruction *instr);
int bfmmla_z_zzz(context *ctx, Instruction *instr);
int bgrp_z_zz(context *ctx, Instruction *instr);
int bic_p_p_pp(context *ctx, Instruction *instr);
int bic_z_p_zz(context *ctx, Instruction *instr);
int bic_z_zz(context *ctx, Instruction *instr);
int brka_p_p_p(context *ctx, Instruction *instr);
int brkb_p_p_p(context *ctx, Instruction *instr);
int brkn_p_p_pp(context *ctx, Instruction *instr);
int brkpa_p_p_pp(context *ctx, Instruction *instr);
int brkpb_p_p_pp(context *ctx, Instruction *instr);
int bsl1n_z_zzz(context *ctx, Instruction *instr);
int bsl2n_z_zzz(context *ctx, Instruction *instr);
int bsl_z_zzz(context *ctx, Instruction *instr);
int cadd_z_zz(context *ctx, Instruction *instr);
int cdot_z_zzz(context *ctx, Instruction *instr);
int cdot_z_zzzi(context *ctx, Instruction *instr);
int clasta_r_p_z(context *ctx, Instruction *instr);
int clasta_v_p_z(context *ctx, Instruction *instr);
int clasta_z_p_zz(context *ctx, Instruction *instr);
int clastb_r_p_z(context *ctx, Instruction *instr);
int clastb_v_p_z(context *ctx, Instruction *instr);
int clastb_z_p_zz(context *ctx, Instruction *instr);
int cls_z_p_z(context *ctx, Instruction *instr);
int clz_z_p_z(context *ctx, Instruction *instr);
int cmla_z_zzz(context *ctx, Instruction *instr);
int cmla_z_zzzi(context *ctx, Instruction *instr);
int cmpeq_p_p_zi(context *ctx, Instruction *instr);
int cmpeq_p_p_zw(context *ctx, Instruction *instr);
int cmpeq_p_p_zz(context *ctx, Instruction *instr);
int cnot_z_p_z(context *ctx, Instruction *instr);
int cnt_z_p_z(context *ctx, Instruction *instr);
int cntb_r_s(context *ctx, Instruction *instr);
int cntp_r_p_p(context *ctx, Instruction *instr);
int compact_z_p_z(context *ctx, Instruction *instr);
int cpy_z_o_i(context *ctx, Instruction *instr);
int cpy_z_p_i(context *ctx, Instruction *instr);
int cpy_z_p_r(context *ctx, Instruction *instr);
int cpy_z_p_v(context *ctx, Instruction *instr);
int ctermeq_rr(context *ctx, Instruction *instr);
int decb_r_rs(context *ctx, Instruction *instr);
int decd_z_zs(context *ctx, Instruction *instr);
int decp_r_p_r(context *ctx, Instruction *instr);
int decp_z_p_z(context *ctx, Instruction *instr);
int dup_z_i(context *ctx, Instruction *instr);
int dup_z_r(context *ctx, Instruction *instr);
int dup_z_zi(context *ctx, Instruction *instr);
int dupm_z_i(context *ctx, Instruction *instr);
int eor3_z_zzz(context *ctx, Instruction *instr);
int eor_p_p_pp(context *ctx, Instruction *instr);
int eor_z_p_zz(context *ctx, Instruction *instr);
int eor_z_zi(context *ctx, Instruction *instr);
int eor_z_zz(context *ctx, Instruction *instr);
int eorbt_z_zz(context *ctx, Instruction *instr);
int eortb_z_zz(context *ctx, Instruction *instr);
int eorv_r_p_z(context *ctx, Instruction *instr);
int ext_z_zi(context *ctx, Instruction *instr);
int fabd_z_p_zz(context *ctx, Instruction *instr);
int fabs_z_p_z(context *ctx, Instruction *instr);
int facge_p_p_zz(context *ctx, Instruction *instr);
int fadd_z_p_zs(context *ctx, Instruction *instr);
int fadd_z_p_zz(context *ctx, Instruction *instr);
int fadd_z_zz(context *ctx, Instruction *instr);
int fadda_v_p_z(context *ctx, Instruction *instr);
int faddp_z_p_zz(context *ctx, Instruction *instr);
int faddv_v_p_z(context *ctx, Instruction *instr);
int fcadd_z_p_zz(context *ctx, Instruction *instr);
int fcmeq_p_p_z0(context *ctx, Instruction *instr);
int fcmeq_p_p_zz(context *ctx, Instruction *instr);
int fcmla_z_p_zzz(context *ctx, Instruction *instr);
int fcmla_z_zzzi(context *ctx, Instruction *instr);
int fcpy_z_p_i(context *ctx, Instruction *instr);
int fcvt_z_p_z(context *ctx, Instruction *instr);
int fcvtlt_z_p_z(context *ctx, Instruction *instr);
int fcvtnt_z_p_z(context *ctx, Instruction *instr);
int fcvtx_z_p_z(context *ctx, Instruction *instr);
int fcvtxnt_z_p_z(context *ctx, Instruction *instr);
int fcvtzs_z_p_z(context *ctx, Instruction *instr);
int fcvtzu_z_p_z(context *ctx, Instruction *instr);
int fdiv_z_p_zz(context *ctx, Instruction *instr);
int fdivr_z_p_zz(context *ctx, Instruction *instr);
int fdup_z_i(context *ctx, Instruction *instr);
int fexpa_z_z(context *ctx, Instruction *instr);
int flogb_z_p_z(context *ctx, Instruction *instr);
int fmad_z_p_zzz(context *ctx, Instruction *instr);
int fmax_z_p_zs(context *ctx, Instruction *instr);
int fmax_z_p_zz(context *ctx, Instruction *instr);
int fmaxnm_z_p_zs(context *ctx, Instruction *instr);
int fmaxnm_z_p_zz(context *ctx, Instruction *instr);
int fmaxnmp_z_p_zz(context *ctx, Instruction *instr);
int fmaxnmv_v_p_z(context *ctx, Instruction *instr);
int fmaxp_z_p_zz(context *ctx, Instruction *instr);
int fmaxv_v_p_z(context *ctx, Instruction *instr);
int fmin_z_p_zs(context *ctx, Instruction *instr);
int fmin_z_p_zz(context *ctx, Instruction *instr);
int fminnm_z_p_zs(context *ctx, Instruction *instr);
int fminnm_z_p_zz(context *ctx, Instruction *instr);
int fminnmp_z_p_zz(context *ctx, Instruction *instr);
int fminnmv_v_p_z(context *ctx, Instruction *instr);
int fminp_z_p_zz(context *ctx, Instruction *instr);
int fminv_v_p_z(context *ctx, Instruction *instr);
int fmla_z_p_zzz(context *ctx, Instruction *instr);
int fmla_z_zzzi(context *ctx, Instruction *instr);
int fmlalb_z_zzz(context *ctx, Instruction *instr);
int fmlalb_z_zzzi(context *ctx, Instruction *instr);
int fmlalt_z_zzz(context *ctx, Instruction *instr);
int fmlalt_z_zzzi(context *ctx, Instruction *instr);
int fmls_z_p_zzz(context *ctx, Instruction *instr);
int fmls_z_zzzi(context *ctx, Instruction *instr);
int fmlslb_z_zzz(context *ctx, Instruction *instr);
int fmlslb_z_zzzi(context *ctx, Instruction *instr);
int fmlslt_z_zzz(context *ctx, Instruction *instr);
int fmlslt_z_zzzi(context *ctx, Instruction *instr);
int fmmla_z_zzz(context *ctx, Instruction *instr);
int fmsb_z_p_zzz(context *ctx, Instruction *instr);
int fmul_z_p_zs(context *ctx, Instruction *instr);
int fmul_z_p_zz(context *ctx, Instruction *instr);
int fmul_z_zz(context *ctx, Instruction *instr);
int fmul_z_zzi(context *ctx, Instruction *instr);
int fmulx_z_p_zz(context *ctx, Instruction *instr);
int fneg_z_p_z(context *ctx, Instruction *instr);
int fnmad_z_p_zzz(context *ctx, Instruction *instr);
int fnmla_z_p_zzz(context *ctx, Instruction *instr);
int fnmls_z_p_zzz(context *ctx, Instruction *instr);
int fnmsb_z_p_zzz(context *ctx, Instruction *instr);
int frecpe_z_z(context *ctx, Instruction *instr);
int frecps_z_zz(context *ctx, Instruction *instr);
int frecpx_z_p_z(context *ctx, Instruction *instr);
int frinta_z_p_z(context *ctx, Instruction *instr);
int frsqrte_z_z(context *ctx, Instruction *instr);
int frsqrts_z_zz(context *ctx, Instruction *instr);
int fscale_z_p_zz(context *ctx, Instruction *instr);
int fsqrt_z_p_z(context *ctx, Instruction *instr);
int fsub_z_p_zs(context *ctx, Instruction *instr);
int fsub_z_p_zz(context *ctx, Instruction *instr);
int fsub_z_zz(context *ctx, Instruction *instr);
int fsubr_z_p_zs(context *ctx, Instruction *instr);
int fsubr_z_p_zz(context *ctx, Instruction *instr);
int ftmad_z_zzi(context *ctx, Instruction *instr);
int ftsmul_z_zz(context *ctx, Instruction *instr);
int ftssel_z_zz(context *ctx, Instruction *instr);
int histcnt_z_p_zz(context *ctx, Instruction *instr);
int histseg_z_zz(context *ctx, Instruction *instr);
int incb_r_rs(context *ctx, Instruction *instr);
int incd_z_zs(context *ctx, Instruction *instr);
int incp_r_p_r(context *ctx, Instruction *instr);
int incp_z_p_z(context *ctx, Instruction *instr);
int index_z_ii(context *ctx, Instruction *instr);
int index_z_ir(context *ctx, Instruction *instr);
int index_z_ri(context *ctx, Instruction *instr);
int index_z_rr(context *ctx, Instruction *instr);
int insr_z_r(context *ctx, Instruction *instr);
int insr_z_v(context *ctx, Instruction *instr);
int lasta_r_p_z(context *ctx, Instruction *instr);
int lasta_v_p_z(context *ctx, Instruction *instr);
int lastb_r_p_z(context *ctx, Instruction *instr);
int lastb_v_p_z(context *ctx, Instruction *instr);
int ld1b_z_p_ai(context *ctx, Instruction *instr);
int ld1b_z_p_bi(context *ctx, Instruction *instr);
int ld1b_z_p_br(context *ctx, Instruction *instr);
int ld1b_z_p_bz(context *ctx, Instruction *instr);
int ld1d_z_p_ai(context *ctx, Instruction *instr);
int ld1d_z_p_bi(context *ctx, Instruction *instr);
int ld1d_z_p_br(context *ctx, Instruction *instr);
int ld1d_z_p_bz(context *ctx, Instruction *instr);
int ld1h_z_p_ai(context *ctx, Instruction *instr);
int ld1h_z_p_bi(context *ctx, Instruction *instr);
int ld1h_z_p_br(context *ctx, Instruction *instr);
int ld1h_z_p_bz(context *ctx, Instruction *instr);
int ld1rb_z_p_bi(context *ctx, Instruction *instr);
int ld1rd_z_p_bi(context *ctx, Instruction *instr);
int ld1rh_z_p_bi(context *ctx, Instruction *instr);
int ld1rob_z_p_bi(context *ctx, Instruction *instr);
int ld1rob_z_p_br(context *ctx, Instruction *instr);
int ld1rod_z_p_bi(context *ctx, Instruction *instr);
int ld1rod_z_p_br(context *ctx, Instruction *instr);
int ld1roh_z_p_bi(context *ctx, Instruction *instr);
int ld1roh_z_p_br(context *ctx, Instruction *instr);
int ld1row_z_p_bi(context *ctx, Instruction *instr);
int ld1row_z_p_br(context *ctx, Instruction *instr);
int ld1rqb_z_p_bi(context *ctx, Instruction *instr);
int ld1rqb_z_p_br(context *ctx, Instruction *instr);
int ld1rqd_z_p_bi(context *ctx, Instruction *instr);
int ld1rqd_z_p_br(context *ctx, Instruction *instr);
int ld1rqh_z_p_bi(context *ctx, Instruction *instr);
int ld1rqh_z_p_br(context *ctx, Instruction *instr);
int ld1rqw_z_p_bi(context *ctx, Instruction *instr);
int ld1rqw_z_p_br(context *ctx, Instruction *instr);
int ld1rsb_z_p_bi(context *ctx, Instruction *instr);
int ld1rsh_z_p_bi(context *ctx, Instruction *instr);
int ld1rsw_z_p_bi(context *ctx, Instruction *instr);
int ld1rw_z_p_bi(context *ctx, Instruction *instr);
int ld1sb_z_p_ai(context *ctx, Instruction *instr);
int ld1sb_z_p_bi(context *ctx, Instruction *instr);
int ld1sb_z_p_br(context *ctx, Instruction *instr);
int ld1sb_z_p_bz(context *ctx, Instruction *instr);
int ld1sh_z_p_ai(context *ctx, Instruction *instr);
int ld1sh_z_p_bi(context *ctx, Instruction *instr);
int ld1sh_z_p_br(context *ctx, Instruction *instr);
int ld1sh_z_p_bz(context *ctx, Instruction *instr);
int ld1sw_z_p_ai(context *ctx, Instruction *instr);
int ld1sw_z_p_bi(context *ctx, Instruction *instr);
int ld1sw_z_p_br(context *ctx, Instruction *instr);
int ld1sw_z_p_bz(context *ctx, Instruction *instr);
int ld1w_z_p_ai(context *ctx, Instruction *instr);
int ld1w_z_p_bi(context *ctx, Instruction *instr);
int ld1w_z_p_br(context *ctx, Instruction *instr);
int ld1w_z_p_bz(context *ctx, Instruction *instr);
int ld2b_z_p_bi(context *ctx, Instruction *instr);
int ld2b_z_p_br(context *ctx, Instruction *instr);
int ld2d_z_p_bi(context *ctx, Instruction *instr);
int ld2d_z_p_br(context *ctx, Instruction *instr);
int ld2h_z_p_bi(context *ctx, Instruction *instr);
int ld2h_z_p_br(context *ctx, Instruction *instr);
int ld2w_z_p_bi(context *ctx, Instruction *instr);
int ld2w_z_p_br(context *ctx, Instruction *instr);
int ld3b_z_p_bi(context *ctx, Instruction *instr);
int ld3b_z_p_br(context *ctx, Instruction *instr);
int ld3d_z_p_bi(context *ctx, Instruction *instr);
int ld3d_z_p_br(context *ctx, Instruction *instr);
int ld3h_z_p_bi(context *ctx, Instruction *instr);
int ld3h_z_p_br(context *ctx, Instruction *instr);
int ld3w_z_p_bi(context *ctx, Instruction *instr);
int ld3w_z_p_br(context *ctx, Instruction *instr);
int ld4b_z_p_bi(context *ctx, Instruction *instr);
int ld4b_z_p_br(context *ctx, Instruction *instr);
int ld4d_z_p_bi(context *ctx, Instruction *instr);
int ld4d_z_p_br(context *ctx, Instruction *instr);
int ld4h_z_p_bi(context *ctx, Instruction *instr);
int ld4h_z_p_br(context *ctx, Instruction *instr);
int ld4w_z_p_bi(context *ctx, Instruction *instr);
int ld4w_z_p_br(context *ctx, Instruction *instr);
int ldff1b_z_p_ai(context *ctx, Instruction *instr);
int ldff1b_z_p_br(context *ctx, Instruction *instr);
int ldff1b_z_p_bz(context *ctx, Instruction *instr);
int ldff1d_z_p_ai(context *ctx, Instruction *instr);
int ldff1d_z_p_br(context *ctx, Instruction *instr);
int ldff1d_z_p_bz(context *ctx, Instruction *instr);
int ldff1h_z_p_ai(context *ctx, Instruction *instr);
int ldff1h_z_p_br(context *ctx, Instruction *instr);
int ldff1h_z_p_bz(context *ctx, Instruction *instr);
int ldff1sb_z_p_ai(context *ctx, Instruction *instr);
int ldff1sb_z_p_br(context *ctx, Instruction *instr);
int ldff1sb_z_p_bz(context *ctx, Instruction *instr);
int ldff1sh_z_p_ai(context *ctx, Instruction *instr);
int ldff1sh_z_p_br(context *ctx, Instruction *instr);
int ldff1sh_z_p_bz(context *ctx, Instruction *instr);
int ldff1sw_z_p_ai(context *ctx, Instruction *instr);
int ldff1sw_z_p_br(context *ctx, Instruction *instr);
int ldff1sw_z_p_bz(context *ctx, Instruction *instr);
int ldff1w_z_p_ai(context *ctx, Instruction *instr);
int ldff1w_z_p_br(context *ctx, Instruction *instr);
int ldff1w_z_p_bz(context *ctx, Instruction *instr);
int ldnf1b_z_p_bi(context *ctx, Instruction *instr);
int ldnf1d_z_p_bi(context *ctx, Instruction *instr);
int ldnf1h_z_p_bi(context *ctx, Instruction *instr);
int ldnf1sb_z_p_bi(context *ctx, Instruction *instr);
int ldnf1sh_z_p_bi(context *ctx, Instruction *instr);
int ldnf1sw_z_p_bi(context *ctx, Instruction *instr);
int ldnf1w_z_p_bi(context *ctx, Instruction *instr);
int ldnt1b_z_p_ar(context *ctx, Instruction *instr);
int ldnt1b_z_p_bi(context *ctx, Instruction *instr);
int ldnt1b_z_p_br(context *ctx, Instruction *instr);
int ldnt1d_z_p_ar(context *ctx, Instruction *instr);
int ldnt1d_z_p_bi(context *ctx, Instruction *instr);
int ldnt1d_z_p_br(context *ctx, Instruction *instr);
int ldnt1h_z_p_ar(context *ctx, Instruction *instr);
int ldnt1h_z_p_bi(context *ctx, Instruction *instr);
int ldnt1h_z_p_br(context *ctx, Instruction *instr);
int ldnt1sb_z_p_ar(context *ctx, Instruction *instr);
int ldnt1sh_z_p_ar(context *ctx, Instruction *instr);
int ldnt1sw_z_p_ar(context *ctx, Instruction *instr);
int ldnt1w_z_p_ar(context *ctx, Instruction *instr);
int ldnt1w_z_p_bi(context *ctx, Instruction *instr);
int ldnt1w_z_p_br(context *ctx, Instruction *instr);
int ldr_p_bi(context *ctx, Instruction *instr);
int ldr_z_bi(context *ctx, Instruction *instr);
int lsl_z_p_zi(context *ctx, Instruction *instr);
int lsl_z_p_zw(context *ctx, Instruction *instr);
int lsl_z_p_zz(context *ctx, Instruction *instr);
int lsl_z_zi(context *ctx, Instruction *instr);
int lsl_z_zw(context *ctx, Instruction *instr);
int lslr_z_p_zz(context *ctx, Instruction *instr);
int lsr_z_p_zi(context *ctx, Instruction *instr);
int lsr_z_p_zw(context *ctx, Instruction *instr);
int lsr_z_p_zz(context *ctx, Instruction *instr);
int lsr_z_zi(context *ctx, Instruction *instr);
int lsr_z_zw(context *ctx, Instruction *instr);
int lsrr_z_p_zz(context *ctx, Instruction *instr);
int mad_z_p_zzz(context *ctx, Instruction *instr);
int match_p_p_zz(context *ctx, Instruction *instr);
int mla_z_p_zzz(context *ctx, Instruction *instr);
int mla_z_zzzi(context *ctx, Instruction *instr);
int mls_z_p_zzz(context *ctx, Instruction *instr);
int mls_z_zzzi(context *ctx, Instruction *instr);
int movprfx_z_p_z(context *ctx, Instruction *instr);
int movprfx_z_z(context *ctx, Instruction *instr);
int msb_z_p_zzz(context *ctx, Instruction *instr);
int mul_z_p_zz(context *ctx, Instruction *instr);
int mul_z_zi(context *ctx, Instruction *instr);
int mul_z_zz(context *ctx, Instruction *instr);
int mul_z_zzi(context *ctx, Instruction *instr);
int nand_p_p_pp(context *ctx, Instruction *instr);
int nbsl_z_zzz(context *ctx, Instruction *instr);
int neg_z_p_z(context *ctx, Instruction *instr);
int nmatch_p_p_zz(context *ctx, Instruction *instr);
int nor_p_p_pp(context *ctx, Instruction *instr);
int not_z_p_z(context *ctx, Instruction *instr);
int orn_p_p_pp(context *ctx, Instruction *instr);
int orr_p_p_pp(context *ctx, Instruction *instr);
int orr_z_p_zz(context *ctx, Instruction *instr);
int orr_z_zi(context *ctx, Instruction *instr);
int orr_z_zz(context *ctx, Instruction *instr);
int orv_r_p_z(context *ctx, Instruction *instr);
int pfalse_p(context *ctx, Instruction *instr);
int pfirst_p_p_p(context *ctx, Instruction *instr);
int pmul_z_zz(context *ctx, Instruction *instr);
int pmullb_z_zz(context *ctx, Instruction *instr);
int pmullt_z_zz(context *ctx, Instruction *instr);
int pnext_p_p_p(context *ctx, Instruction *instr);
int prfb_i_p_ai(context *ctx, Instruction *instr);
int prfb_i_p_bi(context *ctx, Instruction *instr);
int prfb_i_p_br(context *ctx, Instruction *instr);
int prfb_i_p_bz(context *ctx, Instruction *instr);
int prfd_i_p_ai(context *ctx, Instruction *instr);
int prfd_i_p_bi(context *ctx, Instruction *instr);
int prfd_i_p_br(context *ctx, Instruction *instr);
int prfd_i_p_bz(context *ctx, Instruction *instr);
int prfh_i_p_ai(context *ctx, Instruction *instr);
int prfh_i_p_bi(context *ctx, Instruction *instr);
int prfh_i_p_br(context *ctx, Instruction *instr);
int prfh_i_p_bz(context *ctx, Instruction *instr);
int prfw_i_p_ai(context *ctx, Instruction *instr);
int prfw_i_p_bi(context *ctx, Instruction *instr);
int prfw_i_p_br(context *ctx, Instruction *instr);
int prfw_i_p_bz(context *ctx, Instruction *instr);
int ptest_p_p(context *ctx, Instruction *instr);
int ptrue_p_s(context *ctx, Instruction *instr);
int punpkhi_p_p(context *ctx, Instruction *instr);
int raddhnb_z_zz(context *ctx, Instruction *instr);
int raddhnt_z_zz(context *ctx, Instruction *instr);
int rax1_z_zz(context *ctx, Instruction *instr);
int rbit_z_p_z(context *ctx, Instruction *instr);
int rdffr_p_f(context *ctx, Instruction *instr);
int rdffr_p_p_f(context *ctx, Instruction *instr);
int rdvl_r_i(context *ctx, Instruction *instr);
int rev_p_p(context *ctx, Instruction *instr);
int rev_z_z(context *ctx, Instruction *instr);
int revb_z_z(context *ctx, Instruction *instr);
int rshrnb_z_zi(context *ctx, Instruction *instr);
int rshrnt_z_zi(context *ctx, Instruction *instr);
int rsubhnb_z_zz(context *ctx, Instruction *instr);
int rsubhnt_z_zz(context *ctx, Instruction *instr);
int saba_z_zzz(context *ctx, Instruction *instr);
int sabalb_z_zzz(context *ctx, Instruction *instr);
int sabalt_z_zzz(context *ctx, Instruction *instr);
int sabd_z_p_zz(context *ctx, Instruction *instr);
int sabdlb_z_zz(context *ctx, Instruction *instr);
int sabdlt_z_zz(context *ctx, Instruction *instr);
int sadalp_z_p_z(context *ctx, Instruction *instr);
int saddlb_z_zz(context *ctx, Instruction *instr);
int saddlbt_z_zz(context *ctx, Instruction *instr);
int saddlt_z_zz(context *ctx, Instruction *instr);
int saddv_r_p_z(context *ctx, Instruction *instr);
int saddwb_z_zz(context *ctx, Instruction *instr);
int saddwt_z_zz(context *ctx, Instruction *instr);
int sbclb_z_zzz(context *ctx, Instruction *instr);
int sbclt_z_zzz(context *ctx, Instruction *instr);
int scvtf_z_p_z(context *ctx, Instruction *instr);
int sdiv_z_p_zz(context *ctx, Instruction *instr);
int sdivr_z_p_zz(context *ctx, Instruction *instr);
int sdot_z_zzz(context *ctx, Instruction *instr);
int sdot_z_zzzi(context *ctx, Instruction *instr);
int sel_p_p_pp(context *ctx, Instruction *instr);
int sel_z_p_zz(context *ctx, Instruction *instr);
int setffr_f(context *ctx, Instruction *instr);
int shadd_z_p_zz(context *ctx, Instruction *instr);
int shared_pseudocode(context *ctx, Instruction *instr);
int shrnb_z_zi(context *ctx, Instruction *instr);
int shrnt_z_zi(context *ctx, Instruction *instr);
int shsub_z_p_zz(context *ctx, Instruction *instr);
int shsubr_z_p_zz(context *ctx, Instruction *instr);
int sli_z_zzi(context *ctx, Instruction *instr);
int sm4e_z_zz(context *ctx, Instruction *instr);
int sm4ekey_z_zz(context *ctx, Instruction *instr);
int smax_z_p_zz(context *ctx, Instruction *instr);
int smax_z_zi(context *ctx, Instruction *instr);
int smaxp_z_p_zz(context *ctx, Instruction *instr);
int smaxv_r_p_z(context *ctx, Instruction *instr);
int smin_z_p_zz(context *ctx, Instruction *instr);
int smin_z_zi(context *ctx, Instruction *instr);
int sminp_z_p_zz(context *ctx, Instruction *instr);
int sminv_r_p_z(context *ctx, Instruction *instr);
int smlalb_z_zzz(context *ctx, Instruction *instr);
int smlalb_z_zzzi(context *ctx, Instruction *instr);
int smlalt_z_zzz(context *ctx, Instruction *instr);
int smlalt_z_zzzi(context *ctx, Instruction *instr);
int smlslb_z_zzz(context *ctx, Instruction *instr);
int smlslb_z_zzzi(context *ctx, Instruction *instr);
int smlslt_z_zzz(context *ctx, Instruction *instr);
int smlslt_z_zzzi(context *ctx, Instruction *instr);
int smmla_z_zzz(context *ctx, Instruction *instr);
int smulh_z_p_zz(context *ctx, Instruction *instr);
int smulh_z_zz(context *ctx, Instruction *instr);
int smullb_z_zz(context *ctx, Instruction *instr);
int smullb_z_zzi(context *ctx, Instruction *instr);
int smullt_z_zz(context *ctx, Instruction *instr);
int smullt_z_zzi(context *ctx, Instruction *instr);
int splice_z_p_zz(context *ctx, Instruction *instr);
int sqabs_z_p_z(context *ctx, Instruction *instr);
int sqadd_z_p_zz(context *ctx, Instruction *instr);
int sqadd_z_zi(context *ctx, Instruction *instr);
int sqadd_z_zz(context *ctx, Instruction *instr);
int sqcadd_z_zz(context *ctx, Instruction *instr);
int sqdecb_r_rs(context *ctx, Instruction *instr);
int sqdecd_r_rs(context *ctx, Instruction *instr);
int sqdecd_z_zs(context *ctx, Instruction *instr);
int sqdech_r_rs(context *ctx, Instruction *instr);
int sqdech_z_zs(context *ctx, Instruction *instr);
int sqdecp_r_p_r(context *ctx, Instruction *instr);
int sqdecp_z_p_z(context *ctx, Instruction *instr);
int sqdecw_r_rs(context *ctx, Instruction *instr);
int sqdecw_z_zs(context *ctx, Instruction *instr);
int sqdmlalb_z_zzz(context *ctx, Instruction *instr);
int sqdmlalb_z_zzzi(context *ctx, Instruction *instr);
int sqdmlalbt_z_zzz(context *ctx, Instruction *instr);
int sqdmlalt_z_zzz(context *ctx, Instruction *instr);
int sqdmlalt_z_zzzi(context *ctx, Instruction *instr);
int sqdmlslb_z_zzz(context *ctx, Instruction *instr);
int sqdmlslb_z_zzzi(context *ctx, Instruction *instr);
int sqdmlslbt_z_zzz(context *ctx, Instruction *instr);
int sqdmlslt_z_zzz(context *ctx, Instruction *instr);
int sqdmlslt_z_zzzi(context *ctx, Instruction *instr);
int sqdmulh_z_zz(context *ctx, Instruction *instr);
int sqdmulh_z_zzi(context *ctx, Instruction *instr);
int sqdmullb_z_zz(context *ctx, Instruction *instr);
int sqdmullb_z_zzi(context *ctx, Instruction *instr);
int sqdmullt_z_zz(context *ctx, Instruction *instr);
int sqdmullt_z_zzi(context *ctx, Instruction *instr);
int sqincb_r_rs(context *ctx, Instruction *instr);
int sqincd_r_rs(context *ctx, Instruction *instr);
int sqincd_z_zs(context *ctx, Instruction *instr);
int sqinch_r_rs(context *ctx, Instruction *instr);
int sqinch_z_zs(context *ctx, Instruction *instr);
int sqincp_r_p_r(context *ctx, Instruction *instr);
int sqincp_z_p_z(context *ctx, Instruction *instr);
int sqincw_r_rs(context *ctx, Instruction *instr);
int sqincw_z_zs(context *ctx, Instruction *instr);
int sqneg_z_p_z(context *ctx, Instruction *instr);
int sqrdcmlah_z_zzz(context *ctx, Instruction *instr);
int sqrdcmlah_z_zzzi(context *ctx, Instruction *instr);
int sqrdmlah_z_zzz(context *ctx, Instruction *instr);
int sqrdmlah_z_zzzi(context *ctx, Instruction *instr);
int sqrdmlsh_z_zzz(context *ctx, Instruction *instr);
int sqrdmlsh_z_zzzi(context *ctx, Instruction *instr);
int sqrdmulh_z_zz(context *ctx, Instruction *instr);
int sqrdmulh_z_zzi(context *ctx, Instruction *instr);
int sqrshl_z_p_zz(context *ctx, Instruction *instr);
int sqrshlr_z_p_zz(context *ctx, Instruction *instr);
int sqrshrnb_z_zi(context *ctx, Instruction *instr);
int sqrshrnt_z_zi(context *ctx, Instruction *instr);
int sqrshrunb_z_zi(context *ctx, Instruction *instr);
int sqrshrunt_z_zi(context *ctx, Instruction *instr);
int sqshl_z_p_zi(context *ctx, Instruction *instr);
int sqshl_z_p_zz(context *ctx, Instruction *instr);
int sqshlr_z_p_zz(context *ctx, Instruction *instr);
int sqshlu_z_p_zi(context *ctx, Instruction *instr);
int sqshrnb_z_zi(context *ctx, Instruction *instr);
int sqshrnt_z_zi(context *ctx, Instruction *instr);
int sqshrunb_z_zi(context *ctx, Instruction *instr);
int sqshrunt_z_zi(context *ctx, Instruction *instr);
int sqsub_z_p_zz(context *ctx, Instruction *instr);
int sqsub_z_zi(context *ctx, Instruction *instr);
int sqsub_z_zz(context *ctx, Instruction *instr);
int sqsubr_z_p_zz(context *ctx, Instruction *instr);
int sqxtnb_z_zz(context *ctx, Instruction *instr);
int sqxtnt_z_zz(context *ctx, Instruction *instr);
int sqxtunb_z_zz(context *ctx, Instruction *instr);
int sqxtunt_z_zz(context *ctx, Instruction *instr);
int srhadd_z_p_zz(context *ctx, Instruction *instr);
int sri_z_zzi(context *ctx, Instruction *instr);
int srshl_z_p_zz(context *ctx, Instruction *instr);
int srshlr_z_p_zz(context *ctx, Instruction *instr);
int srshr_z_p_zi(context *ctx, Instruction *instr);
int srsra_z_zi(context *ctx, Instruction *instr);
int sshllb_z_zi(context *ctx, Instruction *instr);
int sshllt_z_zi(context *ctx, Instruction *instr);
int ssra_z_zi(context *ctx, Instruction *instr);
int ssublb_z_zz(context *ctx, Instruction *instr);
int ssublbt_z_zz(context *ctx, Instruction *instr);
int ssublt_z_zz(context *ctx, Instruction *instr);
int ssubltb_z_zz(context *ctx, Instruction *instr);
int ssubwb_z_zz(context *ctx, Instruction *instr);
int ssubwt_z_zz(context *ctx, Instruction *instr);
int st1b_z_p_ai(context *ctx, Instruction *instr);
int st1b_z_p_bi(context *ctx, Instruction *instr);
int st1b_z_p_br(context *ctx, Instruction *instr);
int st1b_z_p_bz(context *ctx, Instruction *instr);
int st1d_z_p_ai(context *ctx, Instruction *instr);
int st1d_z_p_bi(context *ctx, Instruction *instr);
int st1d_z_p_br(context *ctx, Instruction *instr);
int st1d_z_p_bz(context *ctx, Instruction *instr);
int st1h_z_p_ai(context *ctx, Instruction *instr);
int st1h_z_p_bi(context *ctx, Instruction *instr);
int st1h_z_p_br(context *ctx, Instruction *instr);
int st1h_z_p_bz(context *ctx, Instruction *instr);
int st1w_z_p_ai(context *ctx, Instruction *instr);
int st1w_z_p_bi(context *ctx, Instruction *instr);
int st1w_z_p_br(context *ctx, Instruction *instr);
int st1w_z_p_bz(context *ctx, Instruction *instr);
int st2b_z_p_bi(context *ctx, Instruction *instr);
int st2b_z_p_br(context *ctx, Instruction *instr);
int st2d_z_p_bi(context *ctx, Instruction *instr);
int st2d_z_p_br(context *ctx, Instruction *instr);
int st2h_z_p_bi(context *ctx, Instruction *instr);
int st2h_z_p_br(context *ctx, Instruction *instr);
int st2w_z_p_bi(context *ctx, Instruction *instr);
int st2w_z_p_br(context *ctx, Instruction *instr);
int st3b_z_p_bi(context *ctx, Instruction *instr);
int st3b_z_p_br(context *ctx, Instruction *instr);
int st3d_z_p_bi(context *ctx, Instruction *instr);
int st3d_z_p_br(context *ctx, Instruction *instr);
int st3h_z_p_bi(context *ctx, Instruction *instr);
int st3h_z_p_br(context *ctx, Instruction *instr);
int st3w_z_p_bi(context *ctx, Instruction *instr);
int st3w_z_p_br(context *ctx, Instruction *instr);
int st4b_z_p_bi(context *ctx, Instruction *instr);
int st4b_z_p_br(context *ctx, Instruction *instr);
int st4d_z_p_bi(context *ctx, Instruction *instr);
int st4d_z_p_br(context *ctx, Instruction *instr);
int st4h_z_p_bi(context *ctx, Instruction *instr);
int st4h_z_p_br(context *ctx, Instruction *instr);
int st4w_z_p_bi(context *ctx, Instruction *instr);
int st4w_z_p_br(context *ctx, Instruction *instr);
int stnt1b_z_p_ar(context *ctx, Instruction *instr);
int stnt1b_z_p_bi(context *ctx, Instruction *instr);
int stnt1b_z_p_br(context *ctx, Instruction *instr);
int stnt1d_z_p_ar(context *ctx, Instruction *instr);
int stnt1d_z_p_bi(context *ctx, Instruction *instr);
int stnt1d_z_p_br(context *ctx, Instruction *instr);
int stnt1h_z_p_ar(context *ctx, Instruction *instr);
int stnt1h_z_p_bi(context *ctx, Instruction *instr);
int stnt1h_z_p_br(context *ctx, Instruction *instr);
int stnt1w_z_p_ar(context *ctx, Instruction *instr);
int stnt1w_z_p_bi(context *ctx, Instruction *instr);
int stnt1w_z_p_br(context *ctx, Instruction *instr);
int str_p_bi(context *ctx, Instruction *instr);
int str_z_bi(context *ctx, Instruction *instr);
int sub_z_p_zz(context *ctx, Instruction *instr);
int sub_z_zi(context *ctx, Instruction *instr);
int sub_z_zz(context *ctx, Instruction *instr);
int subhnb_z_zz(context *ctx, Instruction *instr);
int subhnt_z_zz(context *ctx, Instruction *instr);
int subr_z_p_zz(context *ctx, Instruction *instr);
int subr_z_zi(context *ctx, Instruction *instr);
int sudot_z_zzzi(context *ctx, Instruction *instr);
int sunpkhi_z_z(context *ctx, Instruction *instr);
int suqadd_z_p_zz(context *ctx, Instruction *instr);
int sxtb_z_p_z(context *ctx, Instruction *instr);
int tbl_z_zz(context *ctx, Instruction *instr);
int tbx_z_zz(context *ctx, Instruction *instr);
int trn1_p_pp(context *ctx, Instruction *instr);
int trn1_z_zz(context *ctx, Instruction *instr);
int uaba_z_zzz(context *ctx, Instruction *instr);
int uabalb_z_zzz(context *ctx, Instruction *instr);
int uabalt_z_zzz(context *ctx, Instruction *instr);
int uabd_z_p_zz(context *ctx, Instruction *instr);
int uabdlb_z_zz(context *ctx, Instruction *instr);
int uabdlt_z_zz(context *ctx, Instruction *instr);
int uadalp_z_p_z(context *ctx, Instruction *instr);
int uaddlb_z_zz(context *ctx, Instruction *instr);
int uaddlt_z_zz(context *ctx, Instruction *instr);
int uaddv_r_p_z(context *ctx, Instruction *instr);
int uaddwb_z_zz(context *ctx, Instruction *instr);
int uaddwt_z_zz(context *ctx, Instruction *instr);
int ucvtf_z_p_z(context *ctx, Instruction *instr);
int udiv_z_p_zz(context *ctx, Instruction *instr);
int udivr_z_p_zz(context *ctx, Instruction *instr);
int udot_z_zzz(context *ctx, Instruction *instr);
int udot_z_zzzi(context *ctx, Instruction *instr);
int uhadd_z_p_zz(context *ctx, Instruction *instr);
int uhsub_z_p_zz(context *ctx, Instruction *instr);
int uhsubr_z_p_zz(context *ctx, Instruction *instr);
int umax_z_p_zz(context *ctx, Instruction *instr);
int umax_z_zi(context *ctx, Instruction *instr);
int umaxp_z_p_zz(context *ctx, Instruction *instr);
int umaxv_r_p_z(context *ctx, Instruction *instr);
int umin_z_p_zz(context *ctx, Instruction *instr);
int umin_z_zi(context *ctx, Instruction *instr);
int uminp_z_p_zz(context *ctx, Instruction *instr);
int uminv_r_p_z(context *ctx, Instruction *instr);
int umlalb_z_zzz(context *ctx, Instruction *instr);
int umlalb_z_zzzi(context *ctx, Instruction *instr);
int umlalt_z_zzz(context *ctx, Instruction *instr);
int umlalt_z_zzzi(context *ctx, Instruction *instr);
int umlslb_z_zzz(context *ctx, Instruction *instr);
int umlslb_z_zzzi(context *ctx, Instruction *instr);
int umlslt_z_zzz(context *ctx, Instruction *instr);
int umlslt_z_zzzi(context *ctx, Instruction *instr);
int ummla_z_zzz(context *ctx, Instruction *instr);
int umulh_z_p_zz(context *ctx, Instruction *instr);
int umulh_z_zz(context *ctx, Instruction *instr);
int umullb_z_zz(context *ctx, Instruction *instr);
int umullb_z_zzi(context *ctx, Instruction *instr);
int umullt_z_zz(context *ctx, Instruction *instr);
int umullt_z_zzi(context *ctx, Instruction *instr);
int uqadd_z_p_zz(context *ctx, Instruction *instr);
int uqadd_z_zi(context *ctx, Instruction *instr);
int uqadd_z_zz(context *ctx, Instruction *instr);
int uqdecb_r_rs(context *ctx, Instruction *instr);
int uqdecd_r_rs(context *ctx, Instruction *instr);
int uqdecd_z_zs(context *ctx, Instruction *instr);
int uqdech_r_rs(context *ctx, Instruction *instr);
int uqdech_z_zs(context *ctx, Instruction *instr);
int uqdecp_r_p_r(context *ctx, Instruction *instr);
int uqdecp_z_p_z(context *ctx, Instruction *instr);
int uqdecw_r_rs(context *ctx, Instruction *instr);
int uqdecw_z_zs(context *ctx, Instruction *instr);
int uqincb_r_rs(context *ctx, Instruction *instr);
int uqincd_r_rs(context *ctx, Instruction *instr);
int uqincd_z_zs(context *ctx, Instruction *instr);
int uqinch_r_rs(context *ctx, Instruction *instr);
int uqinch_z_zs(context *ctx, Instruction *instr);
int uqincp_r_p_r(context *ctx, Instruction *instr);
int uqincp_z_p_z(context *ctx, Instruction *instr);
int uqincw_r_rs(context *ctx, Instruction *instr);
int uqincw_z_zs(context *ctx, Instruction *instr);
int uqrshl_z_p_zz(context *ctx, Instruction *instr);
int uqrshlr_z_p_zz(context *ctx, Instruction *instr);
int uqrshrnb_z_zi(context *ctx, Instruction *instr);
int uqrshrnt_z_zi(context *ctx, Instruction *instr);
int uqshl_z_p_zi(context *ctx, Instruction *instr);
int uqshl_z_p_zz(context *ctx, Instruction *instr);
int uqshlr_z_p_zz(context *ctx, Instruction *instr);
int uqshrnb_z_zi(context *ctx, Instruction *instr);
int uqshrnt_z_zi(context *ctx, Instruction *instr);
int uqsub_z_p_zz(context *ctx, Instruction *instr);
int uqsub_z_zi(context *ctx, Instruction *instr);
int uqsub_z_zz(context *ctx, Instruction *instr);
int uqsubr_z_p_zz(context *ctx, Instruction *instr);
int uqxtnb_z_zz(context *ctx, Instruction *instr);
int uqxtnt_z_zz(context *ctx, Instruction *instr);
int urecpe_z_p_z(context *ctx, Instruction *instr);
int urhadd_z_p_zz(context *ctx, Instruction *instr);
int urshl_z_p_zz(context *ctx, Instruction *instr);
int urshlr_z_p_zz(context *ctx, Instruction *instr);
int urshr_z_p_zi(context *ctx, Instruction *instr);
int ursqrte_z_p_z(context *ctx, Instruction *instr);
int ursra_z_zi(context *ctx, Instruction *instr);
int usdot_z_zzz(context *ctx, Instruction *instr);
int usdot_z_zzzi(context *ctx, Instruction *instr);
int ushllb_z_zi(context *ctx, Instruction *instr);
int ushllt_z_zi(context *ctx, Instruction *instr);
int usmmla_z_zzz(context *ctx, Instruction *instr);
int usqadd_z_p_zz(context *ctx, Instruction *instr);
int usra_z_zi(context *ctx, Instruction *instr);
int usublb_z_zz(context *ctx, Instruction *instr);
int usublt_z_zz(context *ctx, Instruction *instr);
int usubwb_z_zz(context *ctx, Instruction *instr);
int usubwt_z_zz(context *ctx, Instruction *instr);
int uunpkhi_z_z(context *ctx, Instruction *instr);
int uxtb_z_p_z(context *ctx, Instruction *instr);
int uzp1_p_pp(context *ctx, Instruction *instr);
int uzp1_z_zz(context *ctx, Instruction *instr);
int whilege_p_p_rr(context *ctx, Instruction *instr);
int whilegt_p_p_rr(context *ctx, Instruction *instr);
int whilehi_p_p_rr(context *ctx, Instruction *instr);
int whilehs_p_p_rr(context *ctx, Instruction *instr);
int whilele_p_p_rr(context *ctx, Instruction *instr);
int whilelo_p_p_rr(context *ctx, Instruction *instr);
int whilels_p_p_rr(context *ctx, Instruction *instr);
int whilelt_p_p_rr(context *ctx, Instruction *instr);
int whilerw_p_rr(context *ctx, Instruction *instr);
int whilewr_p_rr(context *ctx, Instruction *instr);
int wrffr_f_p(context *ctx, Instruction *instr);
int xar_z_zzi(context *ctx, Instruction *instr);
int zip1_p_pp(context *ctx, Instruction *instr);
int zip1_z_zz(context *ctx, Instruction *instr);
# 8 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 2
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 1
# 49 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
enum SystemOp {
 Sys_ERROR=-1,
 Sys_AT=0,
 Sys_DC=1,
 Sys_IC=2,
 Sys_TLBI=3,
 Sys_SYS=4,
};

enum ReduceOp {
 ReduceOp_ERROR=0,
 ReduceOp_ADD,
 ReduceOp_FADD,
 ReduceOp_FMIN,
 ReduceOp_FMAX,
 ReduceOp_FMINNUM,
 ReduceOp_FMAXNUM,
};

enum LogicalOp {
 LogicalOp_ERROR=0,
 LogicalOp_AND,
 LogicalOp_EOR,
 LogicalOp_ORR
};

enum BranchType {
 BranchType_ERROR=0,
 BranchType_DIRCALL,
 BranchType_INDCALL,
 BranchType_ERET,
 BranchType_DBGEXIT,
 BranchType_RET,
 BranchType_DIR,
 BranchType_INDIR,
 BranchType_EXCEPTION,
 BranchType_RESET,
 BranchType_UNKNOWN
};

enum VBitOp {
 VBitOp_ERROR=0,
 VBitOp_VBIF,
 VBitOp_VBIT,
 VBitOp_VBSL,
 VBitOp_VEOR
};

enum SystemHintOp {
 SystemHintOp_ERROR=0,
 SystemHintOp_NOP,
 SystemHintOp_YIELD,
 SystemHintOp_WFE,
 SystemHintOp_WFI,
 SystemHintOp_SEV,
 SystemHintOp_SEVL,
 SystemHintOp_DGH,
 SystemHintOp_ESB,
 SystemHintOp_PSB,
 SystemHintOp_TSB,
 SystemHintOp_BTI,
 SystemHintOp_CSDB,
 SystemHintOp_WFET,
 SystemHintOp_WFIT,
};

enum ImmediateOp {
 ImmediateOp_ERROR=0,
 ImmediateOp_MOVI,
 ImmediateOp_MVNI,
 ImmediateOp_ORR,
 ImmediateOp_BIC
};

enum AccType {
 AccType_ERROR=0,
 AccType_ATOMICRW,
 AccType_ATOMIC,
 AccType_LIMITEDORDERED,
 AccType_ORDEREDATOMICRW,
 AccType_ORDEREDATOMIC,
 AccType_ORDERED
};

enum CompareOp {
 CompareOp_ERROR=0,
 CompareOp_EQ,
 CompareOp_GE,
 CompareOp_GT,
 CompareOp_LE,
 CompareOp_LT
};

enum Constraint {
 Constraint_ERROR=0,
 Constraint_DISABLED,
 Constraint_FALSE,
 Constraint_FAULT,
 Constraint_FORCE,
 Constraint_LIMITED_ATOMICITY,
 Constraint_NONE,
 Constraint_NOP,
 Constraint_TRUE,
 Constraint_UNDEF,
 Constraint_UNKNOWN,
 Constraint_WBSUPPRESS,
};

enum CountOp {
 CountOp_ERROR=0,
 CountOp_CLS,
 CountOp_CLZ
};

enum MBReqDomain {
 MBReqDomain_ERROR=0,
 MBReqDomain_Nonshareable,
 MBReqDomain_InnerShareable,
 MBReqDomain_OuterShareable,
 MBReqDomain_FullSystem
};

enum MBReqTypes {
 MBReqTypes_ERROR=0,
 MBReqTypes_Reads,
 MBReqTypes_Writes,
 MBReqTypes_All
};

enum FPUnaryOp {
 FPUnaryOp_ERROR=0,
 FPUnaryOp_ABS,
 FPUnaryOp_MOV,
 FPUnaryOp_NEG,
 FPUnaryOp_SQRT
};

enum FPConvOp {
 FPConvOp_ERROR=0,
 FPConvOp_CVT_FtoI,
 FPConvOp_CVT_ItoF,
 FPConvOp_MOV_FtoI,
 FPConvOp_MOV_ItoF,
 FPConvOp_CVT_FtoI_JS
};

enum FPMaxMinOp {
 FPMaxMinOp_ERROR=0,
 FPMaxMinOp_MAX,
 FPMaxMinOp_MIN,
 FPMaxMinOp_MAXNUM,
 FPMaxMinOp_MINNUM
};

enum FPRounding {
 FPRounding_ERROR=0,
 FPRounding_TIEEVEN,
 FPRounding_POSINF,
 FPRounding_NEGINF,
 FPRounding_ZERO,
 FPRounding_TIEAWAY,
 FPRounding_ODD
};

enum MemAtomicOp {
 MemAtomicOp_ERROR=0,
 MemAtomicOp_ADD,
 MemAtomicOp_BIC,
 MemAtomicOp_EOR,
 MemAtomicOp_ORR,
 MemAtomicOp_SMAX,
 MemAtomicOp_SMIN,
 MemAtomicOp_UMAX,
 MemAtomicOp_UMIN,
 MemAtomicOp_SWP
};

enum MemOp {
 MemOp_ERROR=0,
 MemOp_LOAD,
 MemOp_STORE,
 MemOp_PREFETCH
};

enum MoveWideOp {
 MoveWideOp_ERROR=0,
 MoveWideOp_N,
 MoveWideOp_Z,
 MoveWideOp_K
};

enum PSTATEField {
 PSTATEField_ERROR=0,
 PSTATEField_DAIFSet,
 PSTATEField_DAIFClr,
 PSTATEField_PAN,
 PSTATEField_UAO,
 PSTATEField_DIT,
 PSTATEField_SSBS,
 PSTATEField_TCO,
 PSTATEField_SP
};

enum SVECmp {
 Cmp_ERROR=-1,
 Cmp_EQ,
 Cmp_NE,
 Cmp_GE,
 Cmp_GT,
 Cmp_LT,
 Cmp_LE,
 Cmp_UN
};

enum PrefetchHint {
 Prefetch_ERROR=-1,
 Prefetch_READ,
 Prefetch_WRITE,
 Prefetch_EXEC
};

enum Unpredictable {
 Unpredictable_ERROR=-1,
 Unpredictable_VMSR,
 Unpredictable_WBOVERLAPLD,
 Unpredictable_WBOVERLAPST,
 Unpredictable_LDPOVERLAP,
 Unpredictable_BASEOVERLAP,
 Unpredictable_DATAOVERLAP,
 Unpredictable_DEVPAGE2,
 Unpredictable_DEVICETAGSTORE,
 Unpredictable_INSTRDEVICE,
 Unpredictable_RESCPACR,
 Unpredictable_RESMAIR,
 Unpredictable_RESTEXCB,
 Unpredictable_RESDACR,
 Unpredictable_RESPRRR,
 Unpredictable_RESVTCRS,
 Unpredictable_RESTnSZ,
 Unpredictable_OORTnSZ,
 Unpredictable_LARGEIPA,
 Unpredictable_ESRCONDPASS,
 Unpredictable_ILZEROIT,
 Unpredictable_ILZEROT,
 Unpredictable_BPVECTORCATCHPRI,
 Unpredictable_VCMATCHHALF,
 Unpredictable_VCMATCHDAPA,
 Unpredictable_WPMASKANDBAS,
 Unpredictable_WPBASCONTIGUOUS,
 Unpredictable_RESWPMASK,
 Unpredictable_WPMASKEDBITS,
 Unpredictable_RESBPWPCTRL,
 Unpredictable_BPNOTIMPL,
 Unpredictable_RESBPTYPE,
 Unpredictable_BPNOTCTXCMP,
 Unpredictable_BPMATCHHALF,
 Unpredictable_BPMISMATCHHALF,
 Unpredictable_RESTARTALIGNPC,
 Unpredictable_RESTARTZEROUPPERPC,
 Unpredictable_ZEROUPPER,
 Unpredictable_ERETZEROUPPERPC,
 Unpredictable_A32FORCEALIGNPC,
 Unpredictable_SMD,
 Unpredictable_NONFAULT,
 Unpredictable_SVEZEROUPPER,
 Unpredictable_SVELDNFDATA,
 Unpredictable_SVELDNFZERO,
 Unpredictable_CHECKSPNONEACTIVE,
 Unpredictable_AFUPDATE,
 Unpredictable_IESBinDebug,
 Unpredictable_BADPMSFCR,
 Unpredictable_ZEROBTYPE,
 Unpredictable_CLEARERRITEZERO,
 Unpredictable_ALUEXCEPTIONRETURN,
 Unpredictable_DBGxVR_RESS,
 Unpredictable_WFxTDEBUG,
 Unpredictable_LS64UNSUPPORTED,
};

typedef struct DecodeBitMasks_ReturnType_ {
 uint64_t wmask;
 uint64_t tmask;
} DecodeBitMasks_ReturnType;

int HighestSetBit(uint64_t x);
int LowestSetBit(uint64_t x);


# 336 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 336 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    BFXPreferred(uint32_t sf, uint32_t uns, uint32_t imms, uint32_t immr);
int BitCount(uint32_t x);
DecodeBitMasks_ReturnType DecodeBitMasks(uint8_t immN, uint8_t imms, uint8_t immr);

enum Constraint ConstrainUnpredictable(enum Unpredictable);

# 341 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 341 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    MoveWidePreferred(uint32_t sf, uint32_t immN, uint32_t imms, uint32_t immr);

# 342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    SVEMoveMaskPreferred(uint32_t imm13);
enum ShiftType DecodeRegExtend(uint8_t op);
enum ShiftType DecodeShift(uint8_t op);
enum SystemOp SysOp(uint32_t op1, uint32_t CRn, uint32_t CRm, uint32_t op2);
uint32_t UInt(uint32_t);
uint32_t BitSlice(uint64_t, int hi, int lo);

# 348 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 348 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    IsZero(uint64_t foo);

# 349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    IsOnes(uint64_t foo, int width);
uint64_t Replicate(uint64_t val, uint8_t times, uint64_t width);
uint64_t AdvSIMDExpandImm(uint8_t op, uint8_t cmode, uint64_t imm8);


# 353 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 353 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    BTypeCompatible_BTI(uint8_t hintcode, uint8_t pstate_btype);

# 354 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 354 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    BTypeCompatible_PACIXSP(void);

enum FPRounding FPDecodeRounding(uint8_t RMode);
enum FPRounding FPRoundingMode(uint64_t fpcr);


# 359 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 359 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    HaltingAllowed(void);
void SystemAccessTrap(uint32_t a, uint32_t b);
void CheckSystemAccess(uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t, uint8_t);

uint64_t VFPExpandImm(uint8_t imm8, unsigned width);






# 369 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 369 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    EL2Enabled(void);

# 370 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
_Bool 
# 370 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
    ELUsingAArch32(uint8_t);

uint64_t FPOne(
# 372 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
              _Bool 
# 372 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
                   sign, int width);
uint64_t FPTwo(
# 373 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
              _Bool 
# 373 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
                   sign, int width);
uint64_t FPPointFive(
# 374 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h" 3 4
                    _Bool 
# 374 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/pcode.h"
                         sign, int width);

uint64_t SignExtend(uint64_t x, int width);
# 9 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 2
# 1 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode_fields32.h" 1

       
void decode_fields32(enum ENCODING enc, context *ctx, Instruction *dec);
# 10 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 2


int ABS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E20B800) {
  decode_fields32(ENC_ABS_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_ABS_ASISDMISC_R); instr->operation = enc_to_oper(ENC_ABS_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0xE20B800) {
  decode_fields32(ENC_ABS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_ABS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_ABS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int ADC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1A000000) {
  decode_fields32(ENC_ADC_32_ADDSUB_CARRY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  if(ctx->sf==0) {instr->encoding = (ENC_ADC_32_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_ADC_32_ADDSUB_CARRY); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADC_64_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_ADC_64_ADDSUB_CARRY); rc = 0; };
 }
 return rc;
}


int ADCS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x3A000000) {
  decode_fields32(ENC_ADCS_32_ADDSUB_CARRY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  if(ctx->sf==0) {instr->encoding = (ENC_ADCS_32_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_ADCS_32_ADDSUB_CARRY); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADCS_64_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_ADCS_64_ADDSUB_CARRY); rc = 0; };
 }
 return rc;
}


int ADDG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC00000)==0x91800000) {
  decode_fields32(ENC_ADDG_64_ADDSUB_IMMTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Xd);
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->tag_offset = ctx->uimm4;
  ctx->offset = (((uint64_t)(ctx->uimm6))<<(4));
  ctx->ADD = 
# 105 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
            1
# 105 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                ;
  {instr->encoding = (ENC_ADDG_64_ADDSUB_IMMTAGS); instr->operation = enc_to_oper(ENC_ADDG_64_ADDSUB_IMMTAGS); rc = 0; };
 }
 return rc;
}


int ADDHN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE204000) {
  decode_fields32(ENC_ADDHN_ASIMDDIFF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->round = (ctx->U==1);
  {instr->encoding = (ENC_ADDHN_ASIMDDIFF_N); instr->operation = enc_to_oper(ENC_ADDHN_ASIMDDIFF_N); rc = 0; };
 }
 return rc;
}


int ADDP_advsimd_pair(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E31B800) {
  decode_fields32(ENC_ADDP_ASISDPAIR_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = ReduceOp_ADD;
  {instr->encoding = (ENC_ADDP_ASISDPAIR_ONLY); instr->operation = enc_to_oper(ENC_ADDP_ASISDPAIR_ONLY); rc = 0; };
 }
 return rc;
}


int ADDP_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE20BC00) {
  decode_fields32(ENC_ADDP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_ADDP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_ADDP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int ADDS_addsub_ext(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00000)==0x2B200000) {
  decode_fields32(ENC_ADDS_32S_ADDSUB_EXT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (unsigned int)(ctx->imm3);
  if(ctx->shift>4) {
   { return -4; };
  }

  if(ctx->Rd==0x1f) return CMN_ADDS_addsub_ext(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ADDS_32S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_ADDS_32S_ADDSUB_EXT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADDS_64S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_ADDS_64S_ADDSUB_EXT); rc = 0; };
 }
 return rc;
}


int ADDS_addsub_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x31000000) {
  decode_fields32(ENC_ADDS_32S_ADDSUB_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  if(!ctx->sh) {
   ctx->imm = (uint64_t)(ctx->imm12);
  }
  else if(ctx->sh) {
   ctx->imm = (uint64_t)(((ctx->imm12<<12)|0));
  }

  if(ctx->Rd==0x1f) return CMN_ADDS_addsub_imm(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ADDS_32S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_ADDS_32S_ADDSUB_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADDS_64S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_ADDS_64S_ADDSUB_IMM); rc = 0; };
 }
 return rc;
}


int ADDS_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x2B000000) {
  decode_fields32(ENC_ADDS_32_ADDSUB_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  if(ctx->shift==3) {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);

  if(ctx->Rd==0x1f) return CMN_ADDS_addsub_shift(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ADDS_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_ADDS_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADDS_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_ADDS_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int ADDV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE31B800) {
  decode_fields32(ENC_ADDV_ASIMDALL_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==4) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = ReduceOp_ADD;
  {instr->encoding = (ENC_ADDV_ASIMDALL_ONLY); instr->operation = enc_to_oper(ENC_ADDV_ASIMDALL_ONLY); rc = 0; };
 }
 return rc;
}


int ADD_addsub_ext(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00000)==0xB200000) {
  decode_fields32(ENC_ADD_32_ADDSUB_EXT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (unsigned int)(ctx->imm3);
  if(ctx->shift>4) {
   { return -4; };
  }
  if(ctx->sf==0) {instr->encoding = (ENC_ADD_32_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_ADD_32_ADDSUB_EXT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADD_64_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_ADD_64_ADDSUB_EXT); rc = 0; };
 }
 return rc;
}


int ADD_addsub_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x11000000) {
  decode_fields32(ENC_ADD_32_ADDSUB_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  if(!ctx->sh) {
   ctx->imm = (uint64_t)(ctx->imm12);
  }
  else if(ctx->sh) {
   ctx->imm = (uint64_t)(((ctx->imm12<<12)|0));
  }

  if(ctx->sh==0 && ctx->imm12==0 && (ctx->Rd==0x1f || ctx->Rn==0x1f)) return MOV_ADD_addsub_imm(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ADD_32_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_ADD_32_ADDSUB_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADD_64_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_ADD_64_ADDSUB_IMM); rc = 0; };
 }
 return rc;
}


int ADD_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0xB000000) {
  decode_fields32(ENC_ADD_32_ADDSUB_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = ctx->setflags;
  if(ctx->shift==3) {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  if(ctx->sf==0) {instr->encoding = (ENC_ADD_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_ADD_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ADD_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_ADD_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int ADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E208400) {
  decode_fields32(ENC_ADD_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->sub_op = (ctx->U==1);
  {instr->encoding = (ENC_ADD_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_ADD_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE208400) {
  decode_fields32(ENC_ADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->U==1);
  {instr->encoding = (ENC_ADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_ADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int ADR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x9F000000)==0x10000000) {
  decode_fields32(ENC_ADR_ONLY_PCRELADDR, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->page = (ctx->op==1);
  if(ctx->page) {
   ctx->imm = SignExtend(((ctx->immhi<<14)|(ctx->immlo<<12)|0),33);
  }
  else {
   ctx->imm = SignExtend(((ctx->immhi<<2)|ctx->immlo),21);
  }
  {instr->encoding = (ENC_ADR_ONLY_PCRELADDR); instr->operation = enc_to_oper(ENC_ADR_ONLY_PCRELADDR); rc = 0; };
 }
 return rc;
}


int ADRP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x9F000000)==0x90000000) {
  decode_fields32(ENC_ADRP_ONLY_PCRELADDR, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->page = (ctx->op==1);
  if(ctx->page) {
   ctx->imm = SignExtend(((ctx->immhi<<14)|(ctx->immlo<<12)|0),33);
  }
  else {
   ctx->imm = SignExtend(((ctx->immhi<<2)|ctx->immlo),21);
  }
  {instr->encoding = (ENC_ADRP_ONLY_PCRELADDR); instr->operation = enc_to_oper(ENC_ADRP_ONLY_PCRELADDR); rc = 0; };
 }
 return rc;
}


int AESD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x4E285800) {
  decode_fields32(ENC_AESD_B_CRYPTOAES, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<0))) {
   { return -4; };
  }
  ctx->decrypt = (ctx->D==1);
  {instr->encoding = (ENC_AESD_B_CRYPTOAES); instr->operation = enc_to_oper(ENC_AESD_B_CRYPTOAES); rc = 0; };
 }
 return rc;
}


int AESE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x4E284800) {
  decode_fields32(ENC_AESE_B_CRYPTOAES, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<0))) {
   { return -4; };
  }
  ctx->decrypt = (ctx->D==1);
  {instr->encoding = (ENC_AESE_B_CRYPTOAES); instr->operation = enc_to_oper(ENC_AESE_B_CRYPTOAES); rc = 0; };
 }
 return rc;
}


int AESIMC_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x4E287800) {
  decode_fields32(ENC_AESIMC_B_CRYPTOAES, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<0))) {
   { return -4; };
  }
  ctx->decrypt = (ctx->D==1);
  {instr->encoding = (ENC_AESIMC_B_CRYPTOAES); instr->operation = enc_to_oper(ENC_AESIMC_B_CRYPTOAES); rc = 0; };
 }
 return rc;
}


int AESMC_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x4E286800) {
  decode_fields32(ENC_AESMC_B_CRYPTOAES, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<0))) {
   { return -4; };
  }
  ctx->decrypt = (ctx->D==1);
  {instr->encoding = (ENC_AESMC_B_CRYPTOAES); instr->operation = enc_to_oper(ENC_AESMC_B_CRYPTOAES); rc = 0; };
 }
 return rc;
}


int ANDS_log_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x72000000) {
  decode_fields32(ENC_ANDS_32S_LOG_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 549 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 549 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 553 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 553 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && ctx->N!=0) {
   { return -4; };
  }
  if((ctx->N==0 && (ctx->imms==0x3D || ctx->imms==0x3B || ctx->imms==0x37 || ctx->imms==0x2F || ctx->imms==0x1F)) || (ctx->N==1 && ctx->imms==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks(ctx->N,ctx->imms,ctx->immr);
  ctx->imm = dbmrt.wmask;

  if(ctx->Rd==0x1f) return TST_ANDS_log_imm(ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_ANDS_32S_LOG_IMM); instr->operation = enc_to_oper(ENC_ANDS_32S_LOG_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ANDS_64S_LOG_IMM); instr->operation = enc_to_oper(ENC_ANDS_64S_LOG_IMM); rc = 0; };
 }
 return rc;
}


int ANDS_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x6A000000) {
  decode_fields32(ENC_ANDS_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 587 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 587 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 591 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 591 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 595 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 595 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 599 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 599 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);

  if(ctx->Rd==0x1f) return TST_ANDS_log_shift(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ANDS_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_ANDS_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ANDS_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_ANDS_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int AND_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE201C00) {
  decode_fields32(ENC_AND_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->invert = ((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  ctx->op = ((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) ? LogicalOp_ORR : LogicalOp_AND;
  {instr->encoding = (ENC_AND_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_AND_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int AND_log_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x12000000) {
  decode_fields32(ENC_AND_32_LOG_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 649 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 649 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 653 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 653 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 657 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 657 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 661 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 661 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && ctx->N!=0) {
   { return -4; };
  }
  if((ctx->N==0 && (ctx->imms==0x3D || ctx->imms==0x3B || ctx->imms==0x37 || ctx->imms==0x2F || ctx->imms==0x1F)) || (ctx->N==1 && ctx->imms==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks(ctx->N,ctx->imms,ctx->immr);
  ctx->imm = dbmrt.wmask;
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_AND_32_LOG_IMM); instr->operation = enc_to_oper(ENC_AND_32_LOG_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_AND_64_LOG_IMM); instr->operation = enc_to_oper(ENC_AND_64_LOG_IMM); rc = 0; };
 }
 return rc;
}


int AND_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0xA000000) {
  decode_fields32(ENC_AND_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 693 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 693 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 697 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 697 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 701 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 701 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);
  if(ctx->sf==0) {instr->encoding = (ENC_AND_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_AND_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_AND_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_AND_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int ASRV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02800) {
  decode_fields32(ENC_ASRV_32_DP_2SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->shift_type = DecodeShift(ctx->op2);

  if(ASR_ASRV(ctx, instr)==0) return 0;
  if(ctx->sf==0) {instr->encoding = (ENC_ASRV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_ASRV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ASRV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_ASRV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int ASR_ASRV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02800) {
  decode_fields32(ENC_ASR_ASRV_32_DP_2SRC, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ASR_ASRV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_ASR_ASRV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ASR_ASRV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_ASR_ASRV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int ASR_SBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F807C00)==0x13007C00) {
  decode_fields32(ENC_ASR_SBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0 && ctx->imms==0x1f) {instr->encoding = (ENC_ASR_SBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_ASR_SBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1 && ctx->imms==0x3f) {instr->encoding = (ENC_ASR_SBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_ASR_SBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int AT_SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF8FE00)==0xD5087800) {
  decode_fields32(ENC_AT_SYS_CR_SYSTEMINSTRS, ctx, instr);
  {instr->encoding = (ENC_AT_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_AT_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int AUTDA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC11800) {
  decode_fields32(ENC_AUTDA_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 785 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 785 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 793 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 793 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_AUTDA_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTDA_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_AUTDZA_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTDZA_64Z_DP_1SRC); rc = 0; };
 }
 return rc;
}


int AUTDB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC11C00) {
  decode_fields32(ENC_AUTDB_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 815 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 815 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 823 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 823 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_AUTDB_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTDB_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_AUTDZB_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTDZB_64Z_DP_1SRC); rc = 0; };
 }
 return rc;
}


int AUTIA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC11000) {
  decode_fields32(ENC_AUTIA_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 853 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 853 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_AUTIA_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTIA_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_AUTIZA_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTIZA_64Z_DP_1SRC); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFFDDF)==0xD503219F) {
  decode_fields32(ENC_AUTIA1716_HI_HINTS, ctx, instr);
  if(ctx->CRm==1 && ctx->op2==4) {instr->encoding = (ENC_AUTIA1716_HI_HINTS); instr->operation = enc_to_oper(ENC_AUTIA1716_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==5) {instr->encoding = (ENC_AUTIASP_HI_HINTS); instr->operation = enc_to_oper(ENC_AUTIASP_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==4) {instr->encoding = (ENC_AUTIAZ_HI_HINTS); instr->operation = enc_to_oper(ENC_AUTIAZ_HI_HINTS); rc = 0; };
 }
 return rc;
}


int AUTIB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC11400) {
  decode_fields32(ENC_AUTIB_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 883 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 883 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 891 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 891 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_AUTIB_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTIB_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_AUTIZB_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_AUTIZB_64Z_DP_1SRC); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFFDDF)==0xD50321DF) {
  decode_fields32(ENC_AUTIB1716_HI_HINTS, ctx, instr);
  if(ctx->CRm==1 && ctx->op2==6) {instr->encoding = (ENC_AUTIB1716_HI_HINTS); instr->operation = enc_to_oper(ENC_AUTIB1716_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==7) {instr->encoding = (ENC_AUTIBSP_HI_HINTS); instr->operation = enc_to_oper(ENC_AUTIBSP_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==6) {instr->encoding = (ENC_AUTIBZ_HI_HINTS); instr->operation = enc_to_oper(ENC_AUTIBZ_HI_HINTS); rc = 0; };
 }
 return rc;
}


int AXFLAG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD500405F) {
  decode_fields32(ENC_AXFLAG_M_PSTATE, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<16))) {
   { return -4; };
  }
  {instr->encoding = (ENC_AXFLAG_M_PSTATE); instr->operation = enc_to_oper(ENC_AXFLAG_M_PSTATE); rc = 0; };
 }
 return rc;
}


int BCAX_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0xCE200000) {
  decode_fields32(ENC_BCAX_VVV16_CRYPTO4, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<30))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  {instr->encoding = (ENC_BCAX_VVV16_CRYPTO4); instr->operation = enc_to_oper(ENC_BCAX_VVV16_CRYPTO4); rc = 0; };
 }
 return rc;
}


int BFCVTN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xEA16800) {
  decode_fields32(ENC_BFCVTN_ASIMDMISC_4S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((0x10) ? ((0x40) / (0x10)) : 0);
  {instr->encoding = (ENC_BFCVTN_ASIMDMISC_4S); instr->operation = enc_to_oper(ENC_BFCVTN_ASIMDMISC_4S); rc = 0; };
 }
 return rc;
}


int BFCVT_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x1E634000) {
  decode_fields32(ENC_BFCVT_BS_FLOATDP1, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->d = (unsigned int)(ctx->Rd);
  {instr->encoding = (ENC_BFCVT_BS_FLOATDP1); instr->operation = enc_to_oper(ENC_BFCVT_BS_FLOATDP1); rc = 0; };
 }
 return rc;
}


int BFC_BFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F8003E0)==0x330003E0) {
  decode_fields32(ENC_BFC_BFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_BFC_BFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_BFC_BFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_BFC_BFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_BFC_BFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int BFDOT_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFC0F400)==0xF40F000) {
  decode_fields32(ENC_BFDOT_ASIMDELEM_E, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->M<<4)|ctx->Rm));
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->i = (unsigned int)(((ctx->H<<1)|ctx->L));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((0x20) ? ((ctx->datasize) / (0x20)) : 0);
  {instr->encoding = (ENC_BFDOT_ASIMDELEM_E); instr->operation = enc_to_oper(ENC_BFDOT_ASIMDELEM_E); rc = 0; };
 }
 return rc;
}


int BFDOT_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E40FC00) {
  decode_fields32(ENC_BFDOT_ASIMDSAME2_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((0x20) ? ((ctx->datasize) / (0x20)) : 0);
  {instr->encoding = (ENC_BFDOT_ASIMDSAME2_D); instr->operation = enc_to_oper(ENC_BFDOT_ASIMDSAME2_D); rc = 0; };
 }
 return rc;
}


int BFI_BFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x33000000 && ((ctx->insword) & 0x3E0)!=0x3E0) {
  decode_fields32(ENC_BFI_BFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_BFI_BFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_BFI_BFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_BFI_BFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_BFI_BFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int BFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x33000000) {
  decode_fields32(ENC_BFM_32M_BITFIELD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->inzero = 
# 1070 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 1070 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
   ctx->extend = 
# 1071 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 1071 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  }
  else if(ctx->opc==1) {
   ctx->inzero = 
# 1074 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 1074 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
   ctx->extend = 
# 1075 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 1075 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==2) {
   ctx->inzero = 
# 1078 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 1078 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
   ctx->extend = 
# 1079 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 1079 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==3) {
   { return -4; };
  }
  if(ctx->sf==1 && ctx->N!=1) {
   { return -4; };
  }
  if(ctx->sf==0 && (ctx->N!=0 || (((ctx->immr)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))!=0 || (((ctx->imms)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))!=0)) {
   { return -4; };
  }
  ctx->R = (unsigned int)(ctx->immr);
  ctx->S = (unsigned int)(ctx->imms);
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks(ctx->N,ctx->imms,ctx->immr);
  ctx->wmask = dbmrt.wmask;
  ctx->tmask = dbmrt.tmask;

  if(ctx->Rn==0x1f && (unsigned int)(ctx->imms)<(unsigned int)(ctx->immr)) return BFC_BFM(ctx, instr);
  if(ctx->Rn!=0x1f && (unsigned int)(ctx->imms)<(unsigned int)(ctx->immr)) return BFI_BFM(ctx, instr);
  if(((unsigned int)(ctx->imms)) >= ((unsigned int)(ctx->immr))) return BFXIL_BFM(ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_BFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_BFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_BFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_BFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int BFMLAL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFC0F400)==0xFC0F000) {
  decode_fields32(ENC_BFMLAL_ASIMDELEM_F, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->elements = ((0x20) ? ((0x80) / (0x20)) : 0);
  ctx->sel = (unsigned int)(ctx->Q);
  {instr->encoding = (ENC_BFMLAL_ASIMDELEM_F); instr->operation = enc_to_oper(ENC_BFMLAL_ASIMDELEM_F); rc = 0; };
 }
 return rc;
}


int BFMLAL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2EC0FC00) {
  decode_fields32(ENC_BFMLAL_ASIMDSAME2_F_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->elements = ((0x20) ? ((0x80) / (0x20)) : 0);
  ctx->sel = (unsigned int)(ctx->Q);
  {instr->encoding = (ENC_BFMLAL_ASIMDSAME2_F_); instr->operation = enc_to_oper(ENC_BFMLAL_ASIMDSAME2_F_); rc = 0; };
 }
 return rc;
}


int BFMMLA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x6E40EC00) {
  decode_fields32(ENC_BFMMLA_ASIMDSAME2_E, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  {instr->encoding = (ENC_BFMMLA_ASIMDSAME2_E); instr->operation = enc_to_oper(ENC_BFMMLA_ASIMDSAME2_E); rc = 0; };
 }
 return rc;
}


int BFXIL_BFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x33000000) {
  decode_fields32(ENC_BFXIL_BFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_BFXIL_BFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_BFXIL_BFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_BFXIL_BFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_BFXIL_BFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int BICS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x6A200000) {
  decode_fields32(ENC_BICS_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 1195 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 1195 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 1199 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 1199 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 1203 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 1203 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 1207 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 1207 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);
  if(ctx->sf==0) {instr->encoding = (ENC_BICS_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_BICS_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_BICS_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_BICS_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int BIC_advsimd_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFF81C00)==0x2F001400) {
  decode_fields32(ENC_BIC_ASIMDIMM_L_HL, ctx, instr);
  ctx->rd = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  if(!(((ctx->cmode<<1)|ctx->op)&0x13)) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==1) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==2) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==3) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x10) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x11) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x12) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x13) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x18) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x19) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1e)==0x1c) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1e) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1f) {
   if(ctx->Q==0) {
    { return -4; };
   }
   ctx->operation_ = ImmediateOp_MOVI;
  }
  ctx->imm64 = AdvSIMDExpandImm(ctx->op,ctx->cmode,((ctx->a<<7)|(ctx->b<<6)|(ctx->c<<5)|(ctx->d<<4)|(ctx->e<<3)|(ctx->f<<2)|(ctx->g<<1)|ctx->h));
  ctx->imm = Replicate(ctx->imm64, ((0x40) ? ((ctx->datasize) / (0x40)) : 0), 64);
  if((ctx->cmode&13)==9) {instr->encoding = (ENC_BIC_ASIMDIMM_L_HL); instr->operation = enc_to_oper(ENC_BIC_ASIMDIMM_L_HL); rc = 0; };
  if((ctx->cmode&9)==1) {instr->encoding = (ENC_BIC_ASIMDIMM_L_SL); instr->operation = enc_to_oper(ENC_BIC_ASIMDIMM_L_SL); rc = 0; };
 }
 return rc;
}


int BIC_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE601C00) {
  decode_fields32(ENC_BIC_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->invert = ((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  ctx->op = ((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) ? LogicalOp_ORR : LogicalOp_AND;
  {instr->encoding = (ENC_BIC_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_BIC_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int BIC_and_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5800000) {
  decode_fields32(ENC_BIC_AND_Z_ZI_, ctx, instr);
  {instr->encoding = (ENC_BIC_AND_Z_ZI_); instr->operation = enc_to_oper(ENC_BIC_AND_Z_ZI_); rc = 0; };
 }
 return rc;
}


int BIC_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0xA200000) {
  decode_fields32(ENC_BIC_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 1329 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 1329 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 1333 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 1333 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 1337 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 1337 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 1341 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 1341 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);
  if(ctx->sf==0) {instr->encoding = (ENC_BIC_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_BIC_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_BIC_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_BIC_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int BIF_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2EE01C00) {
  decode_fields32(ENC_BIF_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!ctx->opc2) {
   ctx->op = VBitOp_VEOR;
  }
  else if(ctx->opc2==1) {
   ctx->op = VBitOp_VBSL;
  }
  else if(ctx->opc2==2) {
   ctx->op = VBitOp_VBIT;
  }
  else if(ctx->opc2==3) {
   ctx->op = VBitOp_VBIF;
  }
  {instr->encoding = (ENC_BIF_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_BIF_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int BIT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2EA01C00) {
  decode_fields32(ENC_BIT_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!ctx->opc2) {
   ctx->op = VBitOp_VEOR;
  }
  else if(ctx->opc2==1) {
   ctx->op = VBitOp_VBSL;
  }
  else if(ctx->opc2==2) {
   ctx->op = VBitOp_VBIT;
  }
  else if(ctx->opc2==3) {
   ctx->op = VBitOp_VBIF;
  }
  {instr->encoding = (ENC_BIT_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_BIT_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int BL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFC000000)==0x94000000) {
  decode_fields32(ENC_BL_ONLY_BRANCH_IMM, ctx, instr);
  ctx->branch_type = (ctx->op==1) ? BranchType_DIRCALL : BranchType_DIR;
  ctx->offset = SignExtend((ctx->imm26<<2),28);
  {instr->encoding = (ENC_BL_ONLY_BRANCH_IMM); instr->operation = enc_to_oper(ENC_BL_ONLY_BRANCH_IMM); rc = 0; };
 }
 return rc;
}


int BLR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC1F)==0xD63F0000) {
  decode_fields32(ENC_BLR_64_BRANCH_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  ctx->source_is_sp = ((ctx->Z==1) && (ctx->m==0x1f));
  if(!ctx->pac && ctx->m!=0) {
   { return -4; };
  }
  else if(ctx->pac && !(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(!ctx->op) {
   ctx->branch_type = BranchType_INDIR;
  }
  else if(ctx->op==1) {
   ctx->branch_type = BranchType_INDCALL;
  }
  else if(ctx->op==2) {
   ctx->branch_type = BranchType_RET;
  }
  else {
   { return -4; };
  }
  if(ctx->pac) {
   if(ctx->Z==0 && ctx->m!=0x1f) {
    { return -4; };
   }
   if(ctx->branch_type==BranchType_RET) {
    if(ctx->n!=0x1f) {
     { return -4; };
    }
    ctx->n = 0x1e;
    ctx->source_is_sp = 
# 1472 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 1472 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  {instr->encoding = (ENC_BLR_64_BRANCH_REG); instr->operation = enc_to_oper(ENC_BLR_64_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int BLRA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFEFFF800)==0xD63F0800) {
  decode_fields32(ENC_BLRAAZ_64_BRANCH_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  ctx->source_is_sp = ((ctx->Z==1) && (ctx->m==0x1f));
  if(!ctx->pac && ctx->m!=0) {
   { return -4; };
  }
  else if(ctx->pac && !(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(!ctx->op) {
   ctx->branch_type = BranchType_INDIR;
  }
  else if(ctx->op==1) {
   ctx->branch_type = BranchType_INDCALL;
  }
  else if(ctx->op==2) {
   ctx->branch_type = BranchType_RET;
  }
  else {
   { return -4; };
  }
  if(ctx->pac) {
   if(ctx->Z==0 && ctx->m!=0x1f) {
    { return -4; };
   }
   if(ctx->branch_type==BranchType_RET) {
    if(ctx->n!=0x1f) {
     { return -4; };
    }
    ctx->n = 0x1e;
    ctx->source_is_sp = 
# 1520 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 1520 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  if(ctx->Z==0 && ctx->M==0 && ctx->Rm==0x1f) {instr->encoding = (ENC_BLRAAZ_64_BRANCH_REG); instr->operation = enc_to_oper(ENC_BLRAAZ_64_BRANCH_REG); rc = 0; };
  if(ctx->Z==1 && ctx->M==0) {instr->encoding = (ENC_BLRAA_64P_BRANCH_REG); instr->operation = enc_to_oper(ENC_BLRAA_64P_BRANCH_REG); rc = 0; };
  if(ctx->Z==0 && ctx->M==1 && ctx->Rm==0x1f) {instr->encoding = (ENC_BLRABZ_64_BRANCH_REG); instr->operation = enc_to_oper(ENC_BLRABZ_64_BRANCH_REG); rc = 0; };
  if(ctx->Z==1 && ctx->M==1) {instr->encoding = (ENC_BLRAB_64P_BRANCH_REG); instr->operation = enc_to_oper(ENC_BLRAB_64P_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int BR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC1F)==0xD61F0000) {
  decode_fields32(ENC_BR_64_BRANCH_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  ctx->source_is_sp = ((ctx->Z==1) && (ctx->m==0x1f));
  if(!ctx->pac && ctx->m!=0) {
   { return -4; };
  }
  else if(ctx->pac && !(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(!ctx->op) {
   ctx->branch_type = BranchType_INDIR;
  }
  else if(ctx->op==1) {
   ctx->branch_type = BranchType_INDCALL;
  }
  else if(ctx->op==2) {
   ctx->branch_type = BranchType_RET;
  }
  else {
   { return -4; };
  }
  if(ctx->pac) {
   if(ctx->Z==0 && ctx->m!=0x1f) {
    { return -4; };
   }
   if(ctx->branch_type==BranchType_RET) {
    if(ctx->n!=0x1f) {
     { return -4; };
    }
    ctx->n = 0x1e;
    ctx->source_is_sp = 
# 1571 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 1571 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  {instr->encoding = (ENC_BR_64_BRANCH_REG); instr->operation = enc_to_oper(ENC_BR_64_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int BRA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFEFFF800)==0xD61F0800) {
  decode_fields32(ENC_BRAAZ_64_BRANCH_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  ctx->source_is_sp = ((ctx->Z==1) && (ctx->m==0x1f));
  if(!ctx->pac && ctx->m!=0) {
   { return -4; };
  }
  else if(ctx->pac && !(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(!ctx->op) {
   ctx->branch_type = BranchType_INDIR;
  }
  else if(ctx->op==1) {
   ctx->branch_type = BranchType_INDCALL;
  }
  else if(ctx->op==2) {
   ctx->branch_type = BranchType_RET;
  }
  else {
   { return -4; };
  }
  if(ctx->pac) {
   if(ctx->Z==0 && ctx->m!=0x1f) {
    { return -4; };
   }
   if(ctx->branch_type==BranchType_RET) {
    if(ctx->n!=0x1f) {
     { return -4; };
    }
    ctx->n = 0x1e;
    ctx->source_is_sp = 
# 1619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 1619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  if(ctx->Z==0 && ctx->M==0 && ctx->Rm==0x1f) {instr->encoding = (ENC_BRAAZ_64_BRANCH_REG); instr->operation = enc_to_oper(ENC_BRAAZ_64_BRANCH_REG); rc = 0; };
  if(ctx->Z==1 && ctx->M==0) {instr->encoding = (ENC_BRAA_64P_BRANCH_REG); instr->operation = enc_to_oper(ENC_BRAA_64P_BRANCH_REG); rc = 0; };
  if(ctx->Z==0 && ctx->M==1 && ctx->Rm==0x1f) {instr->encoding = (ENC_BRABZ_64_BRANCH_REG); instr->operation = enc_to_oper(ENC_BRABZ_64_BRANCH_REG); rc = 0; };
  if(ctx->Z==1 && ctx->M==1) {instr->encoding = (ENC_BRAB_64P_BRANCH_REG); instr->operation = enc_to_oper(ENC_BRAB_64P_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int BRK(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4200000) {
  decode_fields32(ENC_BRK_EX_EXCEPTION, ctx, instr);
  ctx->comment = ctx->imm16;
  if((ctx->features1 & ((uint64_t)1<<3))) {
   ctx->BTypeCompatible = (
# 1640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
  1
# 1640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
  );
  }
  {instr->encoding = (ENC_BRK_EX_EXCEPTION); instr->operation = enc_to_oper(ENC_BRK_EX_EXCEPTION); rc = 0; };
 }
 return rc;
}


int BSL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E601C00) {
  decode_fields32(ENC_BSL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!ctx->opc2) {
   ctx->op = VBitOp_VEOR;
  }
  else if(ctx->opc2==1) {
   ctx->op = VBitOp_VBSL;
  }
  else if(ctx->opc2==2) {
   ctx->op = VBitOp_VBIT;
  }
  else if(ctx->opc2==3) {
   ctx->op = VBitOp_VBIF;
  }
  {instr->encoding = (ENC_BSL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_BSL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int BTI(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFF3F)==0xD503241F) {
  decode_fields32(ENC_BTI_HB_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_BTI_HB_HINTS); instr->operation = enc_to_oper(ENC_BTI_HB_HINTS); rc = 0; };
 }
 return rc;
}


int B_cond(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF000010)==0x54000000) {
  decode_fields32(ENC_B_ONLY_CONDBRANCH, ctx, instr);
  ctx->offset = SignExtend((ctx->imm19<<2),21);
  ctx->condition = ctx->cond;
  {instr->encoding = (ENC_B_ONLY_CONDBRANCH); instr->operation = enc_to_oper(ENC_B_ONLY_CONDBRANCH); rc = 0; };
 }
 return rc;
}


int B_uncond(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFC000000)==0x14000000) {
  decode_fields32(ENC_B_ONLY_BRANCH_IMM, ctx, instr);
  ctx->branch_type = (ctx->op==1) ? BranchType_DIRCALL : BranchType_DIR;
  ctx->offset = SignExtend((ctx->imm26<<2),28);
  {instr->encoding = (ENC_B_ONLY_BRANCH_IMM); instr->operation = enc_to_oper(ENC_B_ONLY_BRANCH_IMM); rc = 0; };
 }
 return rc;
}


int CAS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA07C00)==0x88A07C00) {
  decode_fields32(ENC_CAS_C32_COMSWAP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->L==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->o0==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->size==2 && ctx->L==0 && ctx->o0==0) {instr->encoding = (ENC_CAS_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CAS_C32_COMSWAP); rc = 0; };
  if(ctx->size==2 && ctx->L==1 && ctx->o0==0) {instr->encoding = (ENC_CASA_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASA_C32_COMSWAP); rc = 0; };
  if(ctx->size==2 && ctx->L==1 && ctx->o0==1) {instr->encoding = (ENC_CASAL_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASAL_C32_COMSWAP); rc = 0; };
  if(ctx->size==2 && ctx->L==0 && ctx->o0==1) {instr->encoding = (ENC_CASL_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASL_C32_COMSWAP); rc = 0; };
  if(ctx->size==3 && ctx->L==0 && ctx->o0==0) {instr->encoding = (ENC_CAS_C64_COMSWAP); instr->operation = enc_to_oper(ENC_CAS_C64_COMSWAP); rc = 0; };
  if(ctx->size==3 && ctx->L==1 && ctx->o0==0) {instr->encoding = (ENC_CASA_C64_COMSWAP); instr->operation = enc_to_oper(ENC_CASA_C64_COMSWAP); rc = 0; };
  if(ctx->size==3 && ctx->L==1 && ctx->o0==1) {instr->encoding = (ENC_CASAL_C64_COMSWAP); instr->operation = enc_to_oper(ENC_CASAL_C64_COMSWAP); rc = 0; };
  if(ctx->size==3 && ctx->L==0 && ctx->o0==1) {instr->encoding = (ENC_CASL_C64_COMSWAP); instr->operation = enc_to_oper(ENC_CASL_C64_COMSWAP); rc = 0; };
 }
 return rc;
}


int CASB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA07C00)==0x8A07C00) {
  decode_fields32(ENC_CASAB_C32_COMSWAP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->L==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->o0==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->L==1 && ctx->o0==0) {instr->encoding = (ENC_CASAB_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASAB_C32_COMSWAP); rc = 0; };
  if(ctx->L==1 && ctx->o0==1) {instr->encoding = (ENC_CASALB_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASALB_C32_COMSWAP); rc = 0; };
  if(ctx->L==0 && ctx->o0==0) {instr->encoding = (ENC_CASB_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASB_C32_COMSWAP); rc = 0; };
  if(ctx->L==0 && ctx->o0==1) {instr->encoding = (ENC_CASLB_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASLB_C32_COMSWAP); rc = 0; };
 }
 return rc;
}


int CASH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA07C00)==0x48A07C00) {
  decode_fields32(ENC_CASAH_C32_COMSWAP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->L==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->o0==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->L==1 && ctx->o0==0) {instr->encoding = (ENC_CASAH_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASAH_C32_COMSWAP); rc = 0; };
  if(ctx->L==1 && ctx->o0==1) {instr->encoding = (ENC_CASALH_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASALH_C32_COMSWAP); rc = 0; };
  if(ctx->L==0 && ctx->o0==0) {instr->encoding = (ENC_CASH_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASH_C32_COMSWAP); rc = 0; };
  if(ctx->L==0 && ctx->o0==1) {instr->encoding = (ENC_CASLH_C32_COMSWAP); instr->operation = enc_to_oper(ENC_CASLH_C32_COMSWAP); rc = 0; };
 }
 return rc;
}


int CASP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA07C00)==0x8207C00) {
  decode_fields32(ENC_CASP_CP32_COMSWAPPR, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  if((((ctx->Rs)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->Rt)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->regsize = ctx->datasize;
  ctx->ldacctype = (ctx->L==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->o0==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->sz==0 && ctx->L==0 && ctx->o0==0) {instr->encoding = (ENC_CASP_CP32_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASP_CP32_COMSWAPPR); rc = 0; };
  if(ctx->sz==0 && ctx->L==1 && ctx->o0==0) {instr->encoding = (ENC_CASPA_CP32_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASPA_CP32_COMSWAPPR); rc = 0; };
  if(ctx->sz==0 && ctx->L==1 && ctx->o0==1) {instr->encoding = (ENC_CASPAL_CP32_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASPAL_CP32_COMSWAPPR); rc = 0; };
  if(ctx->sz==0 && ctx->L==0 && ctx->o0==1) {instr->encoding = (ENC_CASPL_CP32_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASPL_CP32_COMSWAPPR); rc = 0; };
  if(ctx->sz==1 && ctx->L==0 && ctx->o0==0) {instr->encoding = (ENC_CASP_CP64_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASP_CP64_COMSWAPPR); rc = 0; };
  if(ctx->sz==1 && ctx->L==1 && ctx->o0==0) {instr->encoding = (ENC_CASPA_CP64_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASPA_CP64_COMSWAPPR); rc = 0; };
  if(ctx->sz==1 && ctx->L==1 && ctx->o0==1) {instr->encoding = (ENC_CASPAL_CP64_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASPAL_CP64_COMSWAPPR); rc = 0; };
  if(ctx->sz==1 && ctx->L==0 && ctx->o0==1) {instr->encoding = (ENC_CASPL_CP64_COMSWAPPR); instr->operation = enc_to_oper(ENC_CASPL_CP64_COMSWAPPR); rc = 0; };
 }
 return rc;
}


int CBNZ(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F000000)==0x35000000) {
  decode_fields32(ENC_CBNZ_32_COMPBRANCH, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->iszero = (ctx->op==0);
  ctx->offset = SignExtend((ctx->imm19<<2),21);
  if(ctx->sf==0) {instr->encoding = (ENC_CBNZ_32_COMPBRANCH); instr->operation = enc_to_oper(ENC_CBNZ_32_COMPBRANCH); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CBNZ_64_COMPBRANCH); instr->operation = enc_to_oper(ENC_CBNZ_64_COMPBRANCH); rc = 0; };
 }
 return rc;
}


int CBZ(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F000000)==0x34000000) {
  decode_fields32(ENC_CBZ_32_COMPBRANCH, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->iszero = (ctx->op==0);
  ctx->offset = SignExtend((ctx->imm19<<2),21);
  if(ctx->sf==0) {instr->encoding = (ENC_CBZ_32_COMPBRANCH); instr->operation = enc_to_oper(ENC_CBZ_32_COMPBRANCH); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CBZ_64_COMPBRANCH); instr->operation = enc_to_oper(ENC_CBZ_64_COMPBRANCH); rc = 0; };
 }
 return rc;
}


int CCMN_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C10)==0x3A400800) {
  decode_fields32(ENC_CCMN_32_CONDCMP_IMM, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->condition = ctx->cond;
  ctx->flags = ctx->nzcv;
  ctx->imm = (uint64_t)(ctx->imm5);
  if(ctx->sf==0) {instr->encoding = (ENC_CCMN_32_CONDCMP_IMM); instr->operation = enc_to_oper(ENC_CCMN_32_CONDCMP_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CCMN_64_CONDCMP_IMM); instr->operation = enc_to_oper(ENC_CCMN_64_CONDCMP_IMM); rc = 0; };
 }
 return rc;
}


int CCMN_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C10)==0x3A400000) {
  decode_fields32(ENC_CCMN_32_CONDCMP_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->condition = ctx->cond;
  ctx->flags = ctx->nzcv;
  if(ctx->sf==0) {instr->encoding = (ENC_CCMN_32_CONDCMP_REG); instr->operation = enc_to_oper(ENC_CCMN_32_CONDCMP_REG); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CCMN_64_CONDCMP_REG); instr->operation = enc_to_oper(ENC_CCMN_64_CONDCMP_REG); rc = 0; };
 }
 return rc;
}


int CCMP_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C10)==0x7A400800) {
  decode_fields32(ENC_CCMP_32_CONDCMP_IMM, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->condition = ctx->cond;
  ctx->flags = ctx->nzcv;
  ctx->imm = (uint64_t)(ctx->imm5);
  if(ctx->sf==0) {instr->encoding = (ENC_CCMP_32_CONDCMP_IMM); instr->operation = enc_to_oper(ENC_CCMP_32_CONDCMP_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CCMP_64_CONDCMP_IMM); instr->operation = enc_to_oper(ENC_CCMP_64_CONDCMP_IMM); rc = 0; };
 }
 return rc;
}


int CCMP_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C10)==0x7A400000) {
  decode_fields32(ENC_CCMP_32_CONDCMP_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->condition = ctx->cond;
  ctx->flags = ctx->nzcv;
  if(ctx->sf==0) {instr->encoding = (ENC_CCMP_32_CONDCMP_REG); instr->operation = enc_to_oper(ENC_CCMP_32_CONDCMP_REG); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CCMP_64_CONDCMP_REG); instr->operation = enc_to_oper(ENC_CCMP_64_CONDCMP_REG); rc = 0; };
 }
 return rc;
}


int CFINV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD500401F) {
  decode_fields32(ENC_CFINV_M_PSTATE, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<17))) {
   { return -4; };
  }
  {instr->encoding = (ENC_CFINV_M_PSTATE); instr->operation = enc_to_oper(ENC_CFINV_M_PSTATE); rc = 0; };
 }
 return rc;
}


int CFP_SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0xD50B7380) {
  decode_fields32(ENC_CFP_SYS_CR_SYSTEMINSTRS, ctx, instr);
  {instr->encoding = (ENC_CFP_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_CFP_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int CINC_CSINC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C00)==0x1A800400 && ((ctx->insword) & 0x1FE3E0)!=0x1FE3E0) {
  decode_fields32(ENC_CINC_CSINC_32_CONDSEL, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CINC_CSINC_32_CONDSEL); instr->operation = enc_to_oper(ENC_CINC_CSINC_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CINC_CSINC_64_CONDSEL); instr->operation = enc_to_oper(ENC_CINC_CSINC_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CINV_CSINV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C00)==0x5A800000 && ((ctx->insword) & 0x1FE3E0)!=0x1FE3E0) {
  decode_fields32(ENC_CINV_CSINV_32_CONDSEL, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CINV_CSINV_32_CONDSEL); instr->operation = enc_to_oper(ENC_CINV_CSINV_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CINV_CSINV_64_CONDSEL); instr->operation = enc_to_oper(ENC_CINV_CSINV_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CLREX(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD503305F) {
  decode_fields32(ENC_CLREX_BN_BARRIERS, ctx, instr);
  {instr->encoding = (ENC_CLREX_BN_BARRIERS); instr->operation = enc_to_oper(ENC_CLREX_BN_BARRIERS); rc = 0; };
 }
 return rc;
}


int CLS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE204800) {
  decode_fields32(ENC_CLS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->countop = (ctx->U==1) ? CountOp_CLZ : CountOp_CLS;
  {instr->encoding = (ENC_CLS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_CLS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int CLS_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFFFC00)==0x5AC01400) {
  decode_fields32(ENC_CLS_32_DP_1SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->opcode = (ctx->op==0) ? CountOp_CLZ : CountOp_CLS;
  if(ctx->sf==0) {instr->encoding = (ENC_CLS_32_DP_1SRC); instr->operation = enc_to_oper(ENC_CLS_32_DP_1SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CLS_64_DP_1SRC); instr->operation = enc_to_oper(ENC_CLS_64_DP_1SRC); rc = 0; };
 }
 return rc;
}


int CLZ_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E204800) {
  decode_fields32(ENC_CLZ_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->countop = (ctx->U==1) ? CountOp_CLZ : CountOp_CLS;
  {instr->encoding = (ENC_CLZ_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_CLZ_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int CLZ_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFFFC00)==0x5AC01000) {
  decode_fields32(ENC_CLZ_32_DP_1SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->opcode = (ctx->op==0) ? CountOp_CLZ : CountOp_CLS;
  if(ctx->sf==0) {instr->encoding = (ENC_CLZ_32_DP_1SRC); instr->operation = enc_to_oper(ENC_CLZ_32_DP_1SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CLZ_64_DP_1SRC); instr->operation = enc_to_oper(ENC_CLZ_64_DP_1SRC); rc = 0; };
 }
 return rc;
}


int CMEQ_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E208C00) {
  decode_fields32(ENC_CMEQ_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->and_test = (ctx->U==0);
  {instr->encoding = (ENC_CMEQ_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMEQ_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E208C00) {
  decode_fields32(ENC_CMEQ_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->and_test = (ctx->U==0);
  {instr->encoding = (ENC_CMEQ_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMEQ_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int CMEQ_advsimd_zero(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E209800) {
  decode_fields32(ENC_CMEQ_ASISDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMEQ_ASISDMISC_Z); instr->operation = enc_to_oper(ENC_CMEQ_ASISDMISC_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0xE209800) {
  decode_fields32(ENC_CMEQ_ASIMDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMEQ_ASIMDMISC_Z); instr->operation = enc_to_oper(ENC_CMEQ_ASIMDMISC_Z); rc = 0; };
 }
 return rc;
}


int CMGE_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E203C00) {
  decode_fields32(ENC_CMGE_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMGE_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMGE_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE203C00) {
  decode_fields32(ENC_CMGE_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMGE_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMGE_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int CMGE_advsimd_zero(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x7E208800) {
  decode_fields32(ENC_CMGE_ASISDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMGE_ASISDMISC_Z); instr->operation = enc_to_oper(ENC_CMGE_ASISDMISC_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0x2E208800) {
  decode_fields32(ENC_CMGE_ASIMDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMGE_ASIMDMISC_Z); instr->operation = enc_to_oper(ENC_CMGE_ASIMDMISC_Z); rc = 0; };
 }
 return rc;
}


int CMGT_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E203400) {
  decode_fields32(ENC_CMGT_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMGT_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMGT_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE203400) {
  decode_fields32(ENC_CMGT_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMGT_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMGT_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int CMGT_advsimd_zero(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E208800) {
  decode_fields32(ENC_CMGT_ASISDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMGT_ASISDMISC_Z); instr->operation = enc_to_oper(ENC_CMGT_ASISDMISC_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0xE208800) {
  decode_fields32(ENC_CMGT_ASIMDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMGT_ASIMDMISC_Z); instr->operation = enc_to_oper(ENC_CMGT_ASIMDMISC_Z); rc = 0; };
 }
 return rc;
}


int CMHI_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E203400) {
  decode_fields32(ENC_CMHI_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMHI_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMHI_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E203400) {
  decode_fields32(ENC_CMHI_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMHI_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMHI_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int CMHS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E203C00) {
  decode_fields32(ENC_CMHS_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMHS_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMHS_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E203C00) {
  decode_fields32(ENC_CMHS_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->cmp_eq = (ctx->eq==1);
  {instr->encoding = (ENC_CMHS_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMHS_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int CMLE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x7E209800) {
  decode_fields32(ENC_CMLE_ASISDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMLE_ASISDMISC_Z); instr->operation = enc_to_oper(ENC_CMLE_ASISDMISC_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0x2E209800) {
  decode_fields32(ENC_CMLE_ASIMDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_CMLE_ASIMDMISC_Z); instr->operation = enc_to_oper(ENC_CMLE_ASIMDMISC_Z); rc = 0; };
 }
 return rc;
}


int CMLT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E20A800) {
  decode_fields32(ENC_CMLT_ASISDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->comparison = CompareOp_LT;
  {instr->encoding = (ENC_CMLT_ASISDMISC_Z); instr->operation = enc_to_oper(ENC_CMLT_ASISDMISC_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0xE20A800) {
  decode_fields32(ENC_CMLT_ASIMDMISC_Z, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->comparison = CompareOp_LT;
  {instr->encoding = (ENC_CMLT_ASIMDMISC_Z); instr->operation = enc_to_oper(ENC_CMLT_ASIMDMISC_Z); rc = 0; };
 }
 return rc;
}


int CMN_ADDS_addsub_ext(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0001F)==0x2B20001F) {
  decode_fields32(ENC_CMN_ADDS_32S_ADDSUB_EXT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CMN_ADDS_32S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_CMN_ADDS_32S_ADDSUB_EXT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CMN_ADDS_64S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_CMN_ADDS_64S_ADDSUB_EXT); rc = 0; };
 }
 return rc;
}


int CMN_ADDS_addsub_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F80001F)==0x3100001F) {
  decode_fields32(ENC_CMN_ADDS_32S_ADDSUB_IMM, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CMN_ADDS_32S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_CMN_ADDS_32S_ADDSUB_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CMN_ADDS_64S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_CMN_ADDS_64S_ADDSUB_IMM); rc = 0; };
 }
 return rc;
}


int CMN_ADDS_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F20001F)==0x2B00001F) {
  decode_fields32(ENC_CMN_ADDS_32_ADDSUB_SHIFT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CMN_ADDS_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_CMN_ADDS_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CMN_ADDS_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_CMN_ADDS_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int CMPLE_cmpeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x24008000) {
  decode_fields32(ENC_CMPLE_CMPGE_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_CMPLE_CMPGE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPLE_CMPGE_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int CMPLO_cmpeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x24000010) {
  decode_fields32(ENC_CMPLO_CMPHI_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_CMPLO_CMPHI_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPLO_CMPHI_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int CMPLS_cmpeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x24000000) {
  decode_fields32(ENC_CMPLS_CMPHS_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_CMPLS_CMPHS_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPLS_CMPHS_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int CMPLT_cmpeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x24008010) {
  decode_fields32(ENC_CMPLT_CMPGT_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_CMPLT_CMPGT_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPLT_CMPGT_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int CMPP_SUBPS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC1F)==0xBAC0001F) {
  decode_fields32(ENC_CMPP_SUBPS_64S_DP_2SRC, ctx, instr);
  {instr->encoding = (ENC_CMPP_SUBPS_64S_DP_2SRC); instr->operation = enc_to_oper(ENC_CMPP_SUBPS_64S_DP_2SRC); rc = 0; };
 }
 return rc;
}


int CMP_SUBS_addsub_ext(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0001F)==0x6B20001F) {
  decode_fields32(ENC_CMP_SUBS_32S_ADDSUB_EXT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CMP_SUBS_32S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_CMP_SUBS_32S_ADDSUB_EXT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CMP_SUBS_64S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_CMP_SUBS_64S_ADDSUB_EXT); rc = 0; };
 }
 return rc;
}


int CMP_SUBS_addsub_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F80001F)==0x7100001F) {
  decode_fields32(ENC_CMP_SUBS_32S_ADDSUB_IMM, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CMP_SUBS_32S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_CMP_SUBS_32S_ADDSUB_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CMP_SUBS_64S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_CMP_SUBS_64S_ADDSUB_IMM); rc = 0; };
 }
 return rc;
}


int CMP_SUBS_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F20001F)==0x6B00001F) {
  decode_fields32(ENC_CMP_SUBS_32_ADDSUB_SHIFT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CMP_SUBS_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_CMP_SUBS_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CMP_SUBS_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_CMP_SUBS_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int CMTST_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E208C00) {
  decode_fields32(ENC_CMTST_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->and_test = (ctx->U==0);
  {instr->encoding = (ENC_CMTST_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMTST_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE208C00) {
  decode_fields32(ENC_CMTST_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->and_test = (ctx->U==0);
  {instr->encoding = (ENC_CMTST_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_CMTST_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int CNEG_CSNEG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C00)==0x5A800400 && ((ctx->insword) & 0xE000)!=0xE000) {
  decode_fields32(ENC_CNEG_CSNEG_32_CONDSEL, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CNEG_CSNEG_32_CONDSEL); instr->operation = enc_to_oper(ENC_CNEG_CSNEG_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CNEG_CSNEG_64_CONDSEL); instr->operation = enc_to_oper(ENC_CNEG_CSNEG_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CNT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE205800) {
  decode_fields32(ENC_CNT_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=0) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((8) ? ((ctx->datasize) / (8)) : 0);
  {instr->encoding = (ENC_CNT_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_CNT_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int CPP_SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0xD50B73E0) {
  decode_fields32(ENC_CPP_SYS_CR_SYSTEMINSTRS, ctx, instr);
  {instr->encoding = (ENC_CPP_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_CPP_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int CRC32(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0F000)==0x1AC04000) {
  decode_fields32(ENC_CRC32B_32C_DP_2SRC, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<5))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sf==1 && ctx->sz!=3) {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->sz==3) {
   { return -4; };
  }
  ctx->size = (8) << ((unsigned int)(ctx->sz));
  ctx->crc32c = (ctx->C==1);
  if(ctx->sf==0 && ctx->sz==0) {instr->encoding = (ENC_CRC32B_32C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32B_32C_DP_2SRC); rc = 0; };
  if(ctx->sf==0 && ctx->sz==1) {instr->encoding = (ENC_CRC32H_32C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32H_32C_DP_2SRC); rc = 0; };
  if(ctx->sf==0 && ctx->sz==2) {instr->encoding = (ENC_CRC32W_32C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32W_32C_DP_2SRC); rc = 0; };
  if(ctx->sf==1 && ctx->sz==3) {instr->encoding = (ENC_CRC32X_64C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32X_64C_DP_2SRC); rc = 0; };
 }
 return rc;
}


int CRC32C(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0F000)==0x1AC05000) {
  decode_fields32(ENC_CRC32CB_32C_DP_2SRC, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<5))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sf==1 && ctx->sz!=3) {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->sz==3) {
   { return -4; };
  }
  ctx->size = (8) << ((unsigned int)(ctx->sz));
  ctx->crc32c = (ctx->C==1);
  if(ctx->sf==0 && ctx->sz==0) {instr->encoding = (ENC_CRC32CB_32C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32CB_32C_DP_2SRC); rc = 0; };
  if(ctx->sf==0 && ctx->sz==1) {instr->encoding = (ENC_CRC32CH_32C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32CH_32C_DP_2SRC); rc = 0; };
  if(ctx->sf==0 && ctx->sz==2) {instr->encoding = (ENC_CRC32CW_32C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32CW_32C_DP_2SRC); rc = 0; };
  if(ctx->sf==1 && ctx->sz==3) {instr->encoding = (ENC_CRC32CX_64C_DP_2SRC); instr->operation = enc_to_oper(ENC_CRC32CX_64C_DP_2SRC); rc = 0; };
 }
 return rc;
}


int CSDB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503229F) {
  decode_fields32(ENC_CSDB_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_CSDB_HI_HINTS); instr->operation = enc_to_oper(ENC_CSDB_HI_HINTS); rc = 0; };
 }
 return rc;
}


int CSEL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C00)==0x1A800000) {
  decode_fields32(ENC_CSEL_32_CONDSEL, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->condition = ctx->cond;
  ctx->else_inv = (ctx->op==1);
  ctx->else_inc = (ctx->o2==1);
  if(ctx->sf==0) {instr->encoding = (ENC_CSEL_32_CONDSEL); instr->operation = enc_to_oper(ENC_CSEL_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CSEL_64_CONDSEL); instr->operation = enc_to_oper(ENC_CSEL_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CSETM_CSINV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFF0FE0)==0x5A9F03E0 && ((ctx->insword) & 0xE000)!=0xE000) {
  decode_fields32(ENC_CSETM_CSINV_32_CONDSEL, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CSETM_CSINV_32_CONDSEL); instr->operation = enc_to_oper(ENC_CSETM_CSINV_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CSETM_CSINV_64_CONDSEL); instr->operation = enc_to_oper(ENC_CSETM_CSINV_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CSET_CSINC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFF0FE0)==0x1A9F07E0 && ((ctx->insword) & 0xE000)!=0xE000) {
  decode_fields32(ENC_CSET_CSINC_32_CONDSEL, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CSET_CSINC_32_CONDSEL); instr->operation = enc_to_oper(ENC_CSET_CSINC_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CSET_CSINC_64_CONDSEL); instr->operation = enc_to_oper(ENC_CSET_CSINC_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CSINC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C00)==0x1A800400) {
  decode_fields32(ENC_CSINC_32_CONDSEL, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->condition = ctx->cond;
  ctx->else_inv = (ctx->op==1);
  ctx->else_inc = (ctx->o2==1);

  if(ctx->Rm!=0x1f && (ctx->cond&14)!=14 && ctx->Rn!=0x1f && ctx->Rn==ctx->Rm) return CINC_CSINC(ctx, instr);
  if(ctx->Rm==0x1f && (ctx->cond&14)!=14 && ctx->Rn==0x1f) return CSET_CSINC(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CSINC_32_CONDSEL); instr->operation = enc_to_oper(ENC_CSINC_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CSINC_64_CONDSEL); instr->operation = enc_to_oper(ENC_CSINC_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CSINV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C00)==0x5A800000) {
  decode_fields32(ENC_CSINV_32_CONDSEL, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->condition = ctx->cond;
  ctx->else_inv = (ctx->op==1);
  ctx->else_inc = (ctx->o2==1);

  if(ctx->Rm!=0x1f && (ctx->cond&14)!=14 && ctx->Rn!=0x1f && ctx->Rn==ctx->Rm) return CINV_CSINV(ctx, instr);
  if(ctx->Rm==0x1f && (ctx->cond&14)!=14 && ctx->Rn==0x1f) return CSETM_CSINV(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CSINV_32_CONDSEL); instr->operation = enc_to_oper(ENC_CSINV_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CSINV_64_CONDSEL); instr->operation = enc_to_oper(ENC_CSINV_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int CSNEG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00C00)==0x5A800400) {
  decode_fields32(ENC_CSNEG_32_CONDSEL, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->condition = ctx->cond;
  ctx->else_inv = (ctx->op==1);
  ctx->else_inc = (ctx->o2==1);

  if((ctx->cond&14)!=14 && ctx->Rn==ctx->Rm) return CNEG_CSNEG(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_CSNEG_32_CONDSEL); instr->operation = enc_to_oper(ENC_CSNEG_32_CONDSEL); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_CSNEG_64_CONDSEL); instr->operation = enc_to_oper(ENC_CSNEG_64_CONDSEL); rc = 0; };
 }
 return rc;
}


int DCPS1(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4A00001) {
  decode_fields32(ENC_DCPS1_DC_EXCEPTION, ctx, instr);
  ctx->target_level = ctx->LL;
  if(ctx->LL==0) {
   { return -4; };
  }

  {instr->encoding = (ENC_DCPS1_DC_EXCEPTION); instr->operation = enc_to_oper(ENC_DCPS1_DC_EXCEPTION); rc = 0; };
 }
 return rc;
}


int DCPS2(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4A00002) {
  decode_fields32(ENC_DCPS2_DC_EXCEPTION, ctx, instr);
  ctx->target_level = ctx->LL;
  if(ctx->LL==0) {
   { return -4; };
  }

  {instr->encoding = (ENC_DCPS2_DC_EXCEPTION); instr->operation = enc_to_oper(ENC_DCPS2_DC_EXCEPTION); rc = 0; };
 }
 return rc;
}


int DCPS3(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4A00003) {
  decode_fields32(ENC_DCPS3_DC_EXCEPTION, ctx, instr);
  ctx->target_level = ctx->LL;
  if(ctx->LL==0) {
   { return -4; };
  }

  {instr->encoding = (ENC_DCPS3_DC_EXCEPTION); instr->operation = enc_to_oper(ENC_DCPS3_DC_EXCEPTION); rc = 0; };
 }
 return rc;
}


int DC_SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF8F000)==0xD5087000) {
  decode_fields32(ENC_DC_SYS_CR_SYSTEMINSTRS, ctx, instr);
  {instr->encoding = (ENC_DC_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_DC_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int DGH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD50320DF) {
  decode_fields32(ENC_DGH_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_DGH_HI_HINTS); instr->operation = enc_to_oper(ENC_DGH_HI_HINTS); rc = 0; };
 }
 return rc;
}


int DMB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD50330BF) {
  decode_fields32(ENC_DMB_BO_BARRIERS, ctx, instr);
  if(!(((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))) {
   ctx->domain = MBReqDomain_OuterShareable;
  }
  else if((((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))==1) {
   ctx->domain = MBReqDomain_Nonshareable;
  }
  else if((((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))==2) {
   ctx->domain = MBReqDomain_InnerShareable;
  }
  else if((((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))==3) {
   ctx->domain = MBReqDomain_FullSystem;
  }
  if(!(((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))) {
   ctx->types = MBReqTypes_All;
   ctx->domain = MBReqDomain_FullSystem;
  }
  else if((((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))==1) {
   ctx->types = MBReqTypes_Reads;
  }
  else if((((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))==2) {
   ctx->types = MBReqTypes_Writes;
  }
  else if((((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))==3) {
   ctx->types = MBReqTypes_All;
  }
  {instr->encoding = (ENC_DMB_BO_BARRIERS); instr->operation = enc_to_oper(ENC_DMB_BO_BARRIERS); rc = 0; };
 }
 return rc;
}


int DRPS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD6BF03E0) {
  decode_fields32(ENC_DRPS_64E_BRANCH_REG, ctx, instr);

  {instr->encoding = (ENC_DRPS_64E_BRANCH_REG); instr->operation = enc_to_oper(ENC_DRPS_64E_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int DSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD503309F) {
  decode_fields32(ENC_DSB_BO_BARRIERS, ctx, instr);
  ctx->nXS = 
# 3448 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
            0
# 3448 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  if(!(((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))) {
   ctx->domain = MBReqDomain_OuterShareable;
  }
  else if((((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))==1) {
   ctx->domain = MBReqDomain_Nonshareable;
  }
  else if((((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))==2) {
   ctx->domain = MBReqDomain_InnerShareable;
  }
  else if((((ctx->CRm)>>(2)) & (((uint64_t)1<<((3)-(2)+1))-1))==3) {
   ctx->domain = MBReqDomain_FullSystem;
  }
  if(!(((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))) {
   ctx->types = MBReqTypes_All;
   ctx->domain = MBReqDomain_FullSystem;
  }
  else if((((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))==1) {
   ctx->types = MBReqTypes_Reads;
  }
  else if((((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))==2) {
   ctx->types = MBReqTypes_Writes;
  }
  else if((((ctx->CRm)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1))==3) {
   ctx->types = MBReqTypes_All;
  }

  if(ctx->CRm==4) return PSSBB_DSB(ctx, instr);
  if(ctx->CRm==0) return SSBB_DSB(ctx, instr);
  {instr->encoding = (ENC_DSB_BO_BARRIERS); instr->operation = enc_to_oper(ENC_DSB_BO_BARRIERS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFF3FF)==0xD503323F) {
  decode_fields32(ENC_DSB_BON_BARRIERS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<15))) {
   { return -4; };
  }
  ctx->types = MBReqTypes_All;
  ctx->nXS = 
# 3487 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
            1
# 3487 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                ;
  if(!ctx->imm2) {
   ctx->domain = MBReqDomain_OuterShareable;
  }
  else if(ctx->imm2==1) {
   ctx->domain = MBReqDomain_Nonshareable;
  }
  else if(ctx->imm2==2) {
   ctx->domain = MBReqDomain_InnerShareable;
  }
  else if(ctx->imm2==3) {
   ctx->domain = MBReqDomain_FullSystem;
  }



  {instr->encoding = (ENC_DSB_BON_BARRIERS); instr->operation = enc_to_oper(ENC_DSB_BON_BARRIERS); rc = 0; };
 }
 return rc;
}


int DUP_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E000400) {
  decode_fields32(ENC_DUP_ASISDONE_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->size = LowestSetBit(ctx->imm5);
  if(ctx->size>3) {
   { return -4; };
  }
  ctx->index = (unsigned int)((((ctx->imm5)>>(ctx->size+1)) & (((uint64_t)1<<((4)-(ctx->size+1)+1))-1)));
  ctx->idxdsize = ((((ctx->imm5)>>(4)) & (((uint64_t)1<<((4)-(4)+1))-1))==1) ? 0x80 : 0x40;
  ctx->esize = (8) << (ctx->size);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;

  if(MOV_DUP_advsimd_elt(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_DUP_ASISDONE_ONLY); instr->operation = enc_to_oper(ENC_DUP_ASISDONE_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0xE000400) {
  decode_fields32(ENC_DUP_ASIMDINS_DV_V, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->size = LowestSetBit(ctx->imm5);
  if(ctx->size>3) {
   { return -4; };
  }
  ctx->index = (unsigned int)((((ctx->imm5)>>(ctx->size+1)) & (((uint64_t)1<<((4)-(ctx->size+1)+1))-1)));
  ctx->idxdsize = ((((ctx->imm5)>>(4)) & (((uint64_t)1<<((4)-(4)+1))-1))==1) ? 0x80 : 0x40;
  if(ctx->size==3 && ctx->Q==0) {
   { return -4; };
  }
  ctx->esize = (8) << (ctx->size);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);

  if(MOV_DUP_advsimd_elt(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_DUP_ASIMDINS_DV_V); instr->operation = enc_to_oper(ENC_DUP_ASIMDINS_DV_V); rc = 0; };
 }
 return rc;
}


int DUP_advsimd_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE000C00) {
  decode_fields32(ENC_DUP_ASIMDINS_DR_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->size = LowestSetBit(ctx->imm5);
  if(ctx->size>3) {
   { return -4; };
  }
  if(ctx->size==3 && ctx->Q==0) {
   { return -4; };
  }
  ctx->esize = (8) << (ctx->size);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_DUP_ASIMDINS_DR_R); instr->operation = enc_to_oper(ENC_DUP_ASIMDINS_DR_R); rc = 0; };
 }
 return rc;
}


int DVP_SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0xD50B73A0) {
  decode_fields32(ENC_DVP_SYS_CR_SYSTEMINSTRS, ctx, instr);
  {instr->encoding = (ENC_DVP_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_DVP_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int EON(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x4A200000) {
  decode_fields32(ENC_EON_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 3608 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3608 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 3612 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3612 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 3616 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3616 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 3620 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 3620 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);
  if(ctx->sf==0) {instr->encoding = (ENC_EON_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_EON_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_EON_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_EON_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int EON_eor_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5400000) {
  decode_fields32(ENC_EON_EOR_Z_ZI_, ctx, instr);
  {instr->encoding = (ENC_EON_EOR_Z_ZI_); instr->operation = enc_to_oper(ENC_EON_EOR_Z_ZI_); rc = 0; };
 }
 return rc;
}


int EOR3_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0xCE000000) {
  decode_fields32(ENC_EOR3_VVV16_CRYPTO4, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<30))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  {instr->encoding = (ENC_EOR3_VVV16_CRYPTO4); instr->operation = enc_to_oper(ENC_EOR3_VVV16_CRYPTO4); rc = 0; };
 }
 return rc;
}


int EOR_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E201C00) {
  decode_fields32(ENC_EOR_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!ctx->opc2) {
   ctx->op = VBitOp_VEOR;
  }
  else if(ctx->opc2==1) {
   ctx->op = VBitOp_VBSL;
  }
  else if(ctx->opc2==2) {
   ctx->op = VBitOp_VBIT;
  }
  else if(ctx->opc2==3) {
   ctx->op = VBitOp_VBIF;
  }
  {instr->encoding = (ENC_EOR_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_EOR_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int EOR_log_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x52000000) {
  decode_fields32(ENC_EOR_32_LOG_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 3711 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3711 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 3715 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3715 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 3719 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3719 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 3723 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 3723 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && ctx->N!=0) {
   { return -4; };
  }
  if((ctx->N==0 && (ctx->imms==0x3D || ctx->imms==0x3B || ctx->imms==0x37 || ctx->imms==0x2F || ctx->imms==0x1F)) || (ctx->N==1 && ctx->imms==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks(ctx->N,ctx->imms,ctx->immr);
  ctx->imm = dbmrt.wmask;
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_EOR_32_LOG_IMM); instr->operation = enc_to_oper(ENC_EOR_32_LOG_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_EOR_64_LOG_IMM); instr->operation = enc_to_oper(ENC_EOR_64_LOG_IMM); rc = 0; };
 }
 return rc;
}


int EOR_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x4A000000) {
  decode_fields32(ENC_EOR_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 3751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 3755 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3755 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 3759 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 3759 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 3763 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 3763 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);
  if(ctx->sf==0) {instr->encoding = (ENC_EOR_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_EOR_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_EOR_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_EOR_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int ERET(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD69F03E0) {
  decode_fields32(ENC_ERET_64E_BRANCH_REG, ctx, instr);

  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  if(!ctx->pac && ctx->op4!=0) {
   { return -4; };
  }
  else if(ctx->pac && (!(ctx->features1 & ((uint64_t)1<<23)) || ctx->op4!=0x1f)) {
   { return -4; };
  }
  if(ctx->Rn!=0x1f) {
   { return -4; };
  }
  {instr->encoding = (ENC_ERET_64E_BRANCH_REG); instr->operation = enc_to_oper(ENC_ERET_64E_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int ERETA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFBFF)==0xD69F0BFF) {
  decode_fields32(ENC_ERETAA_64E_BRANCH_REG, ctx, instr);

  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  if(!ctx->pac && ctx->op4!=0) {
   { return -4; };
  }
  else if(ctx->pac && (!(ctx->features1 & ((uint64_t)1<<23)) || ctx->op4!=0x1f)) {
   { return -4; };
  }
  if(ctx->Rn!=0x1f) {
   { return -4; };
  }
  if(ctx->M==0) {instr->encoding = (ENC_ERETAA_64E_BRANCH_REG); instr->operation = enc_to_oper(ENC_ERETAA_64E_BRANCH_REG); rc = 0; };
  if(ctx->M==1) {instr->encoding = (ENC_ERETAB_64E_BRANCH_REG); instr->operation = enc_to_oper(ENC_ERETAB_64E_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int ESB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503221F) {
  decode_fields32(ENC_ESB_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_ESB_HI_HINTS); instr->operation = enc_to_oper(ENC_ESB_HI_HINTS); rc = 0; };
 }
 return rc;
}


int EXTR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FA00000)==0x13800000) {
  decode_fields32(ENC_EXTR_32_EXTRACT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(ctx->N!=ctx->sf) {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->imms)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->lsb = (unsigned int)(ctx->imms);

  if(ctx->Rn==ctx->Rm) return ROR_EXTR(ctx, instr);
  if(ctx->sf==0 && ctx->N==0 && !(ctx->imms&0x20)) {instr->encoding = (ENC_EXTR_32_EXTRACT); instr->operation = enc_to_oper(ENC_EXTR_32_EXTRACT); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_EXTR_64_EXTRACT); instr->operation = enc_to_oper(ENC_EXTR_64_EXTRACT); rc = 0; };
 }
 return rc;
}


int EXT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08400)==0x2E000000) {
  decode_fields32(ENC_EXT_ASIMDEXT_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->Q==0 && (((ctx->imm4)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->position = ((unsigned int)(ctx->imm4)) << (3);
  {instr->encoding = (ENC_EXT_ASIMDEXT_ONLY); instr->operation = enc_to_oper(ENC_EXT_ASIMDEXT_ONLY); rc = 0; };
 }
 return rc;
}


int FABD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x7EC01400) {
  decode_fields32(ENC_FABD_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->abs = 
# 4004 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
            1
# 4004 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                ;
  {instr->encoding = (ENC_FABD_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FABD_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x7EA0D400) {
  decode_fields32(ENC_FABD_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->abs = 
# 4017 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
            1
# 4017 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                ;
  {instr->encoding = (ENC_FABD_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FABD_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0x2EC01400) {
  decode_fields32(ENC_FABD_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->abs = (ctx->U==1);
  {instr->encoding = (ENC_FABD_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FABD_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2EA0D400) {
  decode_fields32(ENC_FABD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->abs = (ctx->U==1);
  {instr->encoding = (ENC_FABD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FABD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FABS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xEF8F800) {
  decode_fields32(ENC_FABS_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_FABS_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FABS_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA0F800) {
  decode_fields32(ENC_FABS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_FABS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FABS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FABS_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E20C000) {
  decode_fields32(ENC_FABS_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->opc) {
   ctx->fpop = FPUnaryOp_MOV;
  }
  else if(ctx->opc==1) {
   ctx->fpop = FPUnaryOp_ABS;
  }
  else if(ctx->opc==2) {
   ctx->fpop = FPUnaryOp_NEG;
  }
  else if(ctx->opc==3) {
   ctx->fpop = FPUnaryOp_SQRT;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FABS_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FABS_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FABS_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FABS_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FABS_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FABS_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FACGE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x7E402C00) {
  decode_fields32(ENC_FACGE_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4157 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4157 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4161 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4161 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4165 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4165 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4169 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4169 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4173 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4173 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGE_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FACGE_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x7E20EC00) {
  decode_fields32(ENC_FACGE_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4192 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4192 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4196 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4196 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4200 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4200 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4204 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4204 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4208 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4208 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGE_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FACGE_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0x2E402C00) {
  decode_fields32(ENC_FACGE_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4230 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4230 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4234 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4234 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4238 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4238 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4242 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4242 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4246 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4246 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGE_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FACGE_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2E20EC00) {
  decode_fields32(ENC_FACGE_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4268 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4268 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4272 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4272 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4276 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4276 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4280 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4280 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4284 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4284 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGE_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FACGE_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FACGT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x7EC02C00) {
  decode_fields32(ENC_FACGT_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4313 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4313 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4317 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4317 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4321 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4321 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4325 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4325 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4329 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4329 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGT_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FACGT_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x7EA0EC00) {
  decode_fields32(ENC_FACGT_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4348 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4348 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4352 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4352 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4360 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4360 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4364 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4364 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGT_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FACGT_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0x2EC02C00) {
  decode_fields32(ENC_FACGT_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4386 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4386 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4390 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4390 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4394 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4394 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4398 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4398 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4402 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4402 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGT_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FACGT_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2EA0EC00) {
  decode_fields32(ENC_FACGT_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4424 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4424 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4428 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4428 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4432 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4432 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4436 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4436 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4440 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4440 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FACGT_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FACGT_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FACLE_facge_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x6500C010) {
  decode_fields32(ENC_FACLE_FACGE_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_FACLE_FACGE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FACLE_FACGE_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int FACLT_facge_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x6500E010) {
  decode_fields32(ENC_FACLT_FACGT_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_FACLT_FACGT_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FACLT_FACGT_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int FADDP_advsimd_pair(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x5E30D800) {
  decode_fields32(ENC_FADDP_ASISDPAIR_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = ReduceOp_FADD;
  {instr->encoding = (ENC_FADDP_ASISDPAIR_ONLY_H); instr->operation = enc_to_oper(ENC_FADDP_ASISDPAIR_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7E30D800) {
  decode_fields32(ENC_FADDP_ASISDPAIR_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = ReduceOp_FADD;
  {instr->encoding = (ENC_FADDP_ASISDPAIR_ONLY_SD); instr->operation = enc_to_oper(ENC_FADDP_ASISDPAIR_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FADDP_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E401400) {
  decode_fields32(ENC_FADDP_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  {instr->encoding = (ENC_FADDP_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FADDP_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2E20D400) {
  decode_fields32(ENC_FADDP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  {instr->encoding = (ENC_FADDP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FADDP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE401400) {
  decode_fields32(ENC_FADD_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  {instr->encoding = (ENC_FADD_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FADD_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xE20D400) {
  decode_fields32(ENC_FADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  {instr->encoding = (ENC_FADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FADD_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E202800) {
  decode_fields32(ENC_FADD_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->sub_op = (ctx->op==1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FADD_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FADD_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FADD_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FADD_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FADD_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FADD_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FCADD_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20EC00)==0x2E00E400) {
  decode_fields32(ENC_FCADD_ASIMDSAME2_C, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<9))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0) {
   { return -4; };
  }
  if(ctx->Q==0 && ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  if(!(ctx->features1 & ((uint64_t)1<<11)) && ctx->esize==0x10) {
   { return -4; };
  }
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FCADD_ASIMDSAME2_C); instr->operation = enc_to_oper(ENC_FCADD_ASIMDSAME2_C); rc = 0; };
 }
 return rc;
}


int FCCMPE_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF200C10)==0x1E200410) {
  decode_fields32(ENC_FCCMPE_H_FLOATCCMP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->datasize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->datasize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->datasize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->signal_all_nans = (ctx->op==1);
  ctx->condition = ctx->cond;
  ctx->flags = ctx->nzcv;
  if(ctx->ftype==3) {instr->encoding = (ENC_FCCMPE_H_FLOATCCMP); instr->operation = enc_to_oper(ENC_FCCMPE_H_FLOATCCMP); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FCCMPE_S_FLOATCCMP); instr->operation = enc_to_oper(ENC_FCCMPE_S_FLOATCCMP); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FCCMPE_D_FLOATCCMP); instr->operation = enc_to_oper(ENC_FCCMPE_D_FLOATCCMP); rc = 0; };
 }
 return rc;
}


int FCCMP_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF200C10)==0x1E200400) {
  decode_fields32(ENC_FCCMP_H_FLOATCCMP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->datasize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->datasize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->datasize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->signal_all_nans = (ctx->op==1);
  ctx->condition = ctx->cond;
  ctx->flags = ctx->nzcv;
  if(ctx->ftype==3) {instr->encoding = (ENC_FCCMP_H_FLOATCCMP); instr->operation = enc_to_oper(ENC_FCCMP_H_FLOATCCMP); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FCCMP_S_FLOATCCMP); instr->operation = enc_to_oper(ENC_FCCMP_S_FLOATCCMP); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FCCMP_D_FLOATCCMP); instr->operation = enc_to_oper(ENC_FCCMP_D_FLOATCCMP); rc = 0; };
 }
 return rc;
}


int FCMEQ_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E402400) {
  decode_fields32(ENC_FCMEQ_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4755 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4755 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4759 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4759 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4763 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4763 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4767 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4767 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMEQ_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FCMEQ_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x5E20E400) {
  decode_fields32(ENC_FCMEQ_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4786 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4786 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4790 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4790 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4794 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4794 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4798 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4798 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4802 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4802 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMEQ_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FCMEQ_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0xE402400) {
  decode_fields32(ENC_FCMEQ_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4824 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4824 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4828 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4828 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4832 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4832 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4840 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4840 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMEQ_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FCMEQ_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xE20E400) {
  decode_fields32(ENC_FCMEQ_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 4862 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4862 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4866 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4866 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 4870 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4870 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4874 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 4874 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 4878 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 4878 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMEQ_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FCMEQ_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FCMEQ_advsimd_zero(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5EF8D800) {
  decode_fields32(ENC_FCMEQ_ASISDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMEQ_ASISDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMEQ_ASISDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5EA0D800) {
  decode_fields32(ENC_FCMEQ_ASISDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMEQ_ASISDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMEQ_ASISDMISC_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xEF8D800) {
  decode_fields32(ENC_FCMEQ_ASIMDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMEQ_ASIMDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMEQ_ASIMDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA0D800) {
  decode_fields32(ENC_FCMEQ_ASIMDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMEQ_ASIMDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMEQ_ASIMDMISC_FZ); rc = 0; };
 }
 return rc;
}


int FCMGE_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x7E402400) {
  decode_fields32(ENC_FCMGE_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5015 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5015 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5023 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5023 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5027 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5027 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5031 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5031 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGE_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FCMGE_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x7E20E400) {
  decode_fields32(ENC_FCMGE_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5050 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5050 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5054 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5054 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5058 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5058 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5062 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5062 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5066 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5066 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGE_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FCMGE_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0x2E402400) {
  decode_fields32(ENC_FCMGE_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5088 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5088 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5096 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5096 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5104 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5104 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGE_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FCMGE_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2E20E400) {
  decode_fields32(ENC_FCMGE_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5126 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5126 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5130 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5130 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5138 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5138 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5142 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5142 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGE_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FCMGE_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FCMGE_advsimd_zero(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7EF8C800) {
  decode_fields32(ENC_FCMGE_ASISDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGE_ASISDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMGE_ASISDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7EA0C800) {
  decode_fields32(ENC_FCMGE_ASISDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGE_ASISDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMGE_ASISDMISC_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF8C800) {
  decode_fields32(ENC_FCMGE_ASIMDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGE_ASIMDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMGE_ASIMDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA0C800) {
  decode_fields32(ENC_FCMGE_ASIMDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGE_ASIMDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMGE_ASIMDMISC_FZ); rc = 0; };
 }
 return rc;
}


int FCMGT_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x7EC02400) {
  decode_fields32(ENC_FCMGT_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5279 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5279 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5283 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5283 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5291 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5291 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5295 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5295 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGT_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FCMGT_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x7EA0E400) {
  decode_fields32(ENC_FCMGT_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5314 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5314 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5318 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5318 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5322 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5322 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5326 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5326 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5330 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5330 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGT_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FCMGT_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0x2EC02400) {
  decode_fields32(ENC_FCMGT_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5352 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5352 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5360 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5360 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5364 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5364 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5368 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5368 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGT_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FCMGT_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2EA0E400) {
  decode_fields32(ENC_FCMGT_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->E<<2)|(ctx->U<<1)|ctx->ac)) {
   ctx->cmp = CompareOp_EQ;
   ctx->abs = 
# 5390 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5390 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==2) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5394 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5394 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==3) {
   ctx->cmp = CompareOp_GE;
   ctx->abs = 
# 5398 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5398 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==6) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5402 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 5402 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  }
  else if(((ctx->E<<2)|(ctx->U<<1)|ctx->ac)==7) {
   ctx->cmp = CompareOp_GT;
   ctx->abs = 
# 5406 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 5406 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FCMGT_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FCMGT_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FCMGT_advsimd_zero(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5EF8C800) {
  decode_fields32(ENC_FCMGT_ASISDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGT_ASISDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMGT_ASISDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5EA0C800) {
  decode_fields32(ENC_FCMGT_ASISDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGT_ASISDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMGT_ASISDMISC_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xEF8C800) {
  decode_fields32(ENC_FCMGT_ASIMDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGT_ASIMDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMGT_ASIMDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA0C800) {
  decode_fields32(ENC_FCMGT_ASIMDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMGT_ASIMDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMGT_ASIMDMISC_FZ); rc = 0; };
 }
 return rc;
}


int FCMLA_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF009400)==0x2F001000) {
  decode_fields32(ENC_FCMLA_ASIMDELEM_C_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<9))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->M<<4)|ctx->Rm));
  if(ctx->size==0 || ctx->size==3) {
   { return -4; };
  }
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  if(ctx->size==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  if(!(ctx->features1 & ((uint64_t)1<<11)) && ctx->esize==0x10) {
   { return -4; };
  }
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(ctx->size==2 && (ctx->L==1 || ctx->Q==0)) {
   { return -4; };
  }
  if(ctx->size==1 && ctx->H==1 && ctx->Q==0) {
   { return -4; };
  }
  if(ctx->size==1) {instr->encoding = (ENC_FCMLA_ASIMDELEM_C_H); instr->operation = enc_to_oper(ENC_FCMLA_ASIMDELEM_C_H); rc = 0; };
  if(ctx->size==2) {instr->encoding = (ENC_FCMLA_ASIMDELEM_C_S); instr->operation = enc_to_oper(ENC_FCMLA_ASIMDELEM_C_S); rc = 0; };
 }
 return rc;
}


int FCMLA_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20E400)==0x2E00C400) {
  decode_fields32(ENC_FCMLA_ASIMDSAME2_C, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<9))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0) {
   { return -4; };
  }
  if(ctx->Q==0 && ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  if(!(ctx->features1 & ((uint64_t)1<<11)) && ctx->esize==0x10) {
   { return -4; };
  }
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FCMLA_ASIMDSAME2_C); instr->operation = enc_to_oper(ENC_FCMLA_ASIMDSAME2_C); rc = 0; };
 }
 return rc;
}


int FCMLE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7EF8D800) {
  decode_fields32(ENC_FCMLE_ASISDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMLE_ASISDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMLE_ASISDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7EA0D800) {
  decode_fields32(ENC_FCMLE_ASISDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMLE_ASISDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMLE_ASISDMISC_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF8D800) {
  decode_fields32(ENC_FCMLE_ASIMDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMLE_ASIMDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMLE_ASIMDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA0D800) {
  decode_fields32(ENC_FCMLE_ASIMDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  if(!((ctx->op<<1)|ctx->U)) {
   ctx->comparison = CompareOp_GT;
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->comparison = CompareOp_GE;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->comparison = CompareOp_EQ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->comparison = CompareOp_LE;
  }
  {instr->encoding = (ENC_FCMLE_ASIMDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMLE_ASIMDMISC_FZ); rc = 0; };
 }
 return rc;
}


int FCMLE_fcmeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x65004000) {
  decode_fields32(ENC_FCMLE_FCMGE_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_FCMLE_FCMGE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FCMLE_FCMGE_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int FCMLT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5EF8E800) {
  decode_fields32(ENC_FCMLT_ASISDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->comparison = CompareOp_LT;
  {instr->encoding = (ENC_FCMLT_ASISDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMLT_ASISDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5EA0E800) {
  decode_fields32(ENC_FCMLT_ASISDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->comparison = CompareOp_LT;
  {instr->encoding = (ENC_FCMLT_ASISDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMLT_ASISDMISC_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xEF8E800) {
  decode_fields32(ENC_FCMLT_ASIMDMISCFP16_FZ, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->comparison = CompareOp_LT;
  {instr->encoding = (ENC_FCMLT_ASIMDMISCFP16_FZ); instr->operation = enc_to_oper(ENC_FCMLT_ASIMDMISCFP16_FZ); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA0E800) {
  decode_fields32(ENC_FCMLT_ASIMDMISC_FZ, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->comparison = CompareOp_LT;
  {instr->encoding = (ENC_FCMLT_ASIMDMISC_FZ); instr->operation = enc_to_oper(ENC_FCMLT_ASIMDMISC_FZ); rc = 0; };
 }
 return rc;
}


int FCMLT_fcmeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x65004010) {
  decode_fields32(ENC_FCMLT_FCMGT_P_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_FCMLT_FCMGT_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FCMLT_FCMGT_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int FCMPE_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC17)==0x1E202010) {
  decode_fields32(ENC_FCMPE_H_FLOATCMP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->datasize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->datasize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->datasize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->signal_all_nans = ((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  ctx->cmp_with_zero = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if(ctx->ftype==3 && ctx->opc==2) {instr->encoding = (ENC_FCMPE_H_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMPE_H_FLOATCMP); rc = 0; };
  if(ctx->ftype==3 && 
# 5824 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                                                                1 
# 5824 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                                                                     && ctx->opc==3) {instr->encoding = (ENC_FCMPE_HZ_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMPE_HZ_FLOATCMP); rc = 0; };
  if(ctx->ftype==0 && ctx->opc==2) {instr->encoding = (ENC_FCMPE_S_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMPE_S_FLOATCMP); rc = 0; };
  if(ctx->ftype==0 && 
# 5826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                                                                1 
# 5826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                                                                     && ctx->opc==3) {instr->encoding = (ENC_FCMPE_SZ_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMPE_SZ_FLOATCMP); rc = 0; };
  if(ctx->ftype==1 && ctx->opc==2) {instr->encoding = (ENC_FCMPE_D_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMPE_D_FLOATCMP); rc = 0; };
  if(ctx->ftype==1 && 
# 5828 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                                                                1 
# 5828 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                                                                     && ctx->opc==3) {instr->encoding = (ENC_FCMPE_DZ_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMPE_DZ_FLOATCMP); rc = 0; };
 }
 return rc;
}


int FCMP_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC17)==0x1E202000) {
  decode_fields32(ENC_FCMP_H_FLOATCMP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->datasize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->datasize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->datasize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->signal_all_nans = ((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  ctx->cmp_with_zero = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if(ctx->ftype==3 && ctx->opc==0) {instr->encoding = (ENC_FCMP_H_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMP_H_FLOATCMP); rc = 0; };
  if(ctx->ftype==3 && 
# 5863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                                                                1 
# 5863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                                                                     && ctx->opc==1) {instr->encoding = (ENC_FCMP_HZ_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMP_HZ_FLOATCMP); rc = 0; };
  if(ctx->ftype==0 && ctx->opc==0) {instr->encoding = (ENC_FCMP_S_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMP_S_FLOATCMP); rc = 0; };
  if(ctx->ftype==0 && 
# 5865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                                                                1 
# 5865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                                                                     && ctx->opc==1) {instr->encoding = (ENC_FCMP_SZ_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMP_SZ_FLOATCMP); rc = 0; };
  if(ctx->ftype==1 && ctx->opc==0) {instr->encoding = (ENC_FCMP_D_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMP_D_FLOATCMP); rc = 0; };
  if(ctx->ftype==1 && 
# 5867 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                                                                1 
# 5867 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                                                                     && ctx->opc==1) {instr->encoding = (ENC_FCMP_DZ_FLOATCMP); instr->operation = enc_to_oper(ENC_FCMP_DZ_FLOATCMP); rc = 0; };
 }
 return rc;
}


int FCSEL_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF200C00)==0x1E200C00) {
  decode_fields32(ENC_FCSEL_H_FLOATSEL, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->datasize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->datasize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->datasize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->condition = ctx->cond;
  if(ctx->ftype==3) {instr->encoding = (ENC_FCSEL_H_FLOATSEL); instr->operation = enc_to_oper(ENC_FCSEL_H_FLOATSEL); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FCSEL_S_FLOATSEL); instr->operation = enc_to_oper(ENC_FCSEL_S_FLOATSEL); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FCSEL_D_FLOATSEL); instr->operation = enc_to_oper(ENC_FCSEL_D_FLOATSEL); rc = 0; };
 }
 return rc;
}


int FCVTAS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5E79C800) {
  decode_fields32(ENC_FCVTAS_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAS_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTAS_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5E21C800) {
  decode_fields32(ENC_FCVTAS_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAS_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTAS_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xE79C800) {
  decode_fields32(ENC_FCVTAS_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAS_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTAS_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xE21C800) {
  decode_fields32(ENC_FCVTAS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTAS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTAS_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E240000) {
  decode_fields32(ENC_FCVTAS_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTAS_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAS_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTAS_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAS_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTAS_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAS_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTAS_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAS_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTAS_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAS_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTAS_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAS_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTAU_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7E79C800) {
  decode_fields32(ENC_FCVTAU_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAU_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTAU_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7E21C800) {
  decode_fields32(ENC_FCVTAU_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAU_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTAU_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2E79C800) {
  decode_fields32(ENC_FCVTAU_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAU_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTAU_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E21C800) {
  decode_fields32(ENC_FCVTAU_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPRounding_TIEAWAY;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTAU_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTAU_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTAU_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E250000) {
  decode_fields32(ENC_FCVTAU_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTAU_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAU_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTAU_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAU_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTAU_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAU_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTAU_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAU_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTAU_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAU_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTAU_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTAU_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0xE217800) {
  decode_fields32(ENC_FCVTL_ASIMDMISC_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x10) << ((unsigned int)(ctx->sz));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FCVTL_ASIMDMISC_L); instr->operation = enc_to_oper(ENC_FCVTL_ASIMDMISC_L); rc = 0; };
 }
 return rc;
}


int FCVTMS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5E79B800) {
  decode_fields32(ENC_FCVTMS_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMS_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTMS_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5E21B800) {
  decode_fields32(ENC_FCVTMS_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMS_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTMS_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xE79B800) {
  decode_fields32(ENC_FCVTMS_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMS_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTMS_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xE21B800) {
  decode_fields32(ENC_FCVTMS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTMS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTMS_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E300000) {
  decode_fields32(ENC_FCVTMS_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTMS_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMS_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTMS_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMS_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTMS_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMS_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTMS_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMS_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTMS_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMS_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTMS_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMS_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTMU_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7E79B800) {
  decode_fields32(ENC_FCVTMU_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMU_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTMU_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7E21B800) {
  decode_fields32(ENC_FCVTMU_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMU_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTMU_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2E79B800) {
  decode_fields32(ENC_FCVTMU_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMU_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTMU_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E21B800) {
  decode_fields32(ENC_FCVTMU_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTMU_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTMU_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTMU_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E310000) {
  decode_fields32(ENC_FCVTMU_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTMU_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMU_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTMU_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMU_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTMU_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMU_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTMU_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMU_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTMU_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMU_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTMU_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTMU_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTNS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5E79A800) {
  decode_fields32(ENC_FCVTNS_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNS_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTNS_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5E21A800) {
  decode_fields32(ENC_FCVTNS_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNS_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTNS_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xE79A800) {
  decode_fields32(ENC_FCVTNS_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNS_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTNS_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xE21A800) {
  decode_fields32(ENC_FCVTNS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTNS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTNS_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E200000) {
  decode_fields32(ENC_FCVTNS_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTNS_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNS_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTNS_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNS_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTNS_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNS_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTNS_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNS_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTNS_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNS_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTNS_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNS_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTNU_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7E79A800) {
  decode_fields32(ENC_FCVTNU_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNU_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTNU_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7E21A800) {
  decode_fields32(ENC_FCVTNU_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNU_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTNU_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2E79A800) {
  decode_fields32(ENC_FCVTNU_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNU_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTNU_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E21A800) {
  decode_fields32(ENC_FCVTNU_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTNU_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTNU_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTNU_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E210000) {
  decode_fields32(ENC_FCVTNU_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTNU_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNU_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTNU_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNU_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTNU_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNU_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTNU_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNU_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTNU_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNU_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTNU_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTNU_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0xE216800) {
  decode_fields32(ENC_FCVTN_ASIMDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x10) << ((unsigned int)(ctx->sz));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FCVTN_ASIMDMISC_N); instr->operation = enc_to_oper(ENC_FCVTN_ASIMDMISC_N); rc = 0; };
 }
 return rc;
}


int FCVTPS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5EF9A800) {
  decode_fields32(ENC_FCVTPS_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPS_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTPS_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5EA1A800) {
  decode_fields32(ENC_FCVTPS_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPS_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTPS_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xEF9A800) {
  decode_fields32(ENC_FCVTPS_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPS_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTPS_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA1A800) {
  decode_fields32(ENC_FCVTPS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTPS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTPS_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E280000) {
  decode_fields32(ENC_FCVTPS_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTPS_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPS_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTPS_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPS_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTPS_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPS_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTPS_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPS_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTPS_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPS_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTPS_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPS_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTPU_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7EF9A800) {
  decode_fields32(ENC_FCVTPU_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPU_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTPU_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7EA1A800) {
  decode_fields32(ENC_FCVTPU_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPU_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTPU_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF9A800) {
  decode_fields32(ENC_FCVTPU_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPU_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTPU_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA1A800) {
  decode_fields32(ENC_FCVTPU_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTPU_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTPU_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTPU_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E290000) {
  decode_fields32(ENC_FCVTPU_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTPU_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPU_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTPU_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPU_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTPU_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPU_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTPU_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPU_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTPU_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPU_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTPU_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTPU_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTXN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x7E216800) {
  decode_fields32(ENC_FCVTXN_ASISDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->sz==0) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  {instr->encoding = (ENC_FCVTXN_ASISDMISC_N); instr->operation = enc_to_oper(ENC_FCVTXN_ASISDMISC_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E216800) {
  decode_fields32(ENC_FCVTXN_ASIMDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->sz==0) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = 0x40;
  ctx->elements = 2;
  ctx->part = (unsigned int)(ctx->Q);
  {instr->encoding = (ENC_FCVTXN_ASIMDMISC_N); instr->operation = enc_to_oper(ENC_FCVTXN_ASIMDMISC_N); rc = 0; };
 }
 return rc;
}


int FCVTZS_advsimd_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F00FC00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_FCVTZS_ASISDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_ASISDSHF_C); instr->operation = enc_to_oper(ENC_FCVTZS_ASISDSHF_C); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF00FC00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_FCVTZS_ASIMDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_ASIMDSHF_C); instr->operation = enc_to_oper(ENC_FCVTZS_ASIMDSHF_C); rc = 0; };
 }
 return rc;
}


int FCVTZS_advsimd_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5EF9B800) {
  decode_fields32(ENC_FCVTZS_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZS_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTZS_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5EA1B800) {
  decode_fields32(ENC_FCVTZS_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZS_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTZS_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xEF9B800) {
  decode_fields32(ENC_FCVTZS_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZS_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTZS_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA1B800) {
  decode_fields32(ENC_FCVTZS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTZS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTZS_float_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3F0000)==0x1E180000) {
  decode_fields32(ENC_FCVTZS_32H_FLOAT2FIX, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(ctx->sf==0 && (((ctx->scale)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==0) {
   { return -4; };
  }
  ctx->fracbits = 0x40-(unsigned int)(ctx->scale);
  if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==3) {
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZS_32H_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZS_32H_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZS_64H_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZS_64H_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZS_32S_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZS_32S_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZS_64S_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZS_64S_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZS_32D_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZS_32D_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZS_64D_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZS_64D_FLOAT2FIX); rc = 0; };
 }
 return rc;
}


int FCVTZS_float_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E380000) {
  decode_fields32(ENC_FCVTZS_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZS_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZS_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZS_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZS_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZS_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZS_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZS_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZS_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZS_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZS_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZS_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZS_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVTZU_advsimd_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F00FC00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_FCVTZU_ASISDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_ASISDSHF_C); instr->operation = enc_to_oper(ENC_FCVTZU_ASISDSHF_C); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F00FC00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_FCVTZU_ASIMDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_ASIMDSHF_C); instr->operation = enc_to_oper(ENC_FCVTZU_ASIMDSHF_C); rc = 0; };
 }
 return rc;
}


int FCVTZU_advsimd_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7EF9B800) {
  decode_fields32(ENC_FCVTZU_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZU_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTZU_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7EA1B800) {
  decode_fields32(ENC_FCVTZU_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZU_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FCVTZU_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF9B800) {
  decode_fields32(ENC_FCVTZU_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZU_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FCVTZU_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA1B800) {
  decode_fields32(ENC_FCVTZU_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_FCVTZU_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FCVTZU_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FCVTZU_float_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3F0000)==0x1E190000) {
  decode_fields32(ENC_FCVTZU_32H_FLOAT2FIX, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(ctx->sf==0 && (((ctx->scale)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==0) {
   { return -4; };
  }
  ctx->fracbits = 0x40-(unsigned int)(ctx->scale);
  if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==3) {
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZU_32H_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZU_32H_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZU_64H_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZU_64H_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZU_32S_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZU_32S_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZU_64S_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZU_64S_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZU_32D_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZU_32D_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZU_64D_FLOAT2FIX); instr->operation = enc_to_oper(ENC_FCVTZU_64D_FLOAT2FIX); rc = 0; };
 }
 return rc;
}


int FCVTZU_float_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E390000) {
  decode_fields32(ENC_FCVTZU_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZU_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZU_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_FCVTZU_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZU_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZU_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZU_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_FCVTZU_64S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZU_64S_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZU_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZU_32D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_FCVTZU_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FCVTZU_64D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FCVT_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3E7C00)==0x1E224000) {
  decode_fields32(ENC_FCVT_SH_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->ftype==ctx->opc) {
   { return -4; };
  }
  if(!ctx->ftype) {
   ctx->srcsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->srcsize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   ctx->srcsize = 0x10;
  }
  if(!ctx->opc) {
   ctx->dstsize = 0x20;
  }
  else if(ctx->opc==1) {
   ctx->dstsize = 0x40;
  }
  else if(ctx->opc==2) {
   { return -4; };
  }
  else if(ctx->opc==3) {
   ctx->dstsize = 0x10;
  }
  if(ctx->ftype==3 && ctx->opc==0) {instr->encoding = (ENC_FCVT_SH_FLOATDP1); instr->operation = enc_to_oper(ENC_FCVT_SH_FLOATDP1); rc = 0; };
  if(ctx->ftype==3 && ctx->opc==1) {instr->encoding = (ENC_FCVT_DH_FLOATDP1); instr->operation = enc_to_oper(ENC_FCVT_DH_FLOATDP1); rc = 0; };
  if(ctx->ftype==0 && ctx->opc==3) {instr->encoding = (ENC_FCVT_HS_FLOATDP1); instr->operation = enc_to_oper(ENC_FCVT_HS_FLOATDP1); rc = 0; };
  if(ctx->ftype==0 && ctx->opc==1) {instr->encoding = (ENC_FCVT_DS_FLOATDP1); instr->operation = enc_to_oper(ENC_FCVT_DS_FLOATDP1); rc = 0; };
  if(ctx->ftype==1 && ctx->opc==3) {instr->encoding = (ENC_FCVT_HD_FLOATDP1); instr->operation = enc_to_oper(ENC_FCVT_HD_FLOATDP1); rc = 0; };
  if(ctx->ftype==1 && ctx->opc==0) {instr->encoding = (ENC_FCVT_SD_FLOATDP1); instr->operation = enc_to_oper(ENC_FCVT_SD_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FDIV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E403C00) {
  decode_fields32(ENC_FDIV_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FDIV_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FDIV_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2E20FC00) {
  decode_fields32(ENC_FDIV_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FDIV_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FDIV_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FDIV_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E201800) {
  decode_fields32(ENC_FDIV_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FDIV_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FDIV_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FDIV_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FDIV_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FDIV_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FDIV_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FJCVTZS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x1E7E0000) {
  decode_fields32(ENC_FJCVTZS_32D_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  {instr->encoding = (ENC_FJCVTZS_32D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FJCVTZS_32D_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FMADD_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF208000)==0x1F000000) {
  decode_fields32(ENC_FMADD_H_FLOATDP3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->opa_neg = (ctx->o1==1);
  ctx->op1_neg = (ctx->o0!=ctx->o1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FMADD_H_FLOATDP3); instr->operation = enc_to_oper(ENC_FMADD_H_FLOATDP3); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMADD_S_FLOATDP3); instr->operation = enc_to_oper(ENC_FMADD_S_FLOATDP3); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMADD_D_FLOATDP3); instr->operation = enc_to_oper(ENC_FMADD_D_FLOATDP3); rc = 0; };
 }
 return rc;
}


int FMAXNMP_advsimd_pair(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x5E30C800) {
  decode_fields32(ENC_FMAXNMP_ASISDPAIR_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMAXNMP_ASISDPAIR_ONLY_H); instr->operation = enc_to_oper(ENC_FMAXNMP_ASISDPAIR_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7E30C800) {
  decode_fields32(ENC_FMAXNMP_ASISDPAIR_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMAXNMP_ASISDPAIR_ONLY_SD); instr->operation = enc_to_oper(ENC_FMAXNMP_ASISDPAIR_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMAXNMP_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E400400) {
  decode_fields32(ENC_FMAXNMP_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->a==1);
  {instr->encoding = (ENC_FMAXNMP_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMAXNMP_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2E20C400) {
  decode_fields32(ENC_FMAXNMP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMAXNMP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMAXNMP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMAXNMV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xE30C800) {
  decode_fields32(ENC_FMAXNMV_ASIMDALL_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMAXNMV_ASIMDALL_ONLY_H); instr->operation = enc_to_oper(ENC_FMAXNMV_ASIMDALL_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E30C800) {
  decode_fields32(ENC_FMAXNMV_ASIMDALL_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)!=1) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMAXNMV_ASIMDALL_ONLY_SD); instr->operation = enc_to_oper(ENC_FMAXNMV_ASIMDALL_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMAXNM_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE400400) {
  decode_fields32(ENC_FMAXNM_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->a==1);
  {instr->encoding = (ENC_FMAXNM_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMAXNM_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xE20C400) {
  decode_fields32(ENC_FMAXNM_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMAXNM_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMAXNM_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMAXNM_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E206800) {
  decode_fields32(ENC_FMAXNM_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->op) {
   ctx->operation_ = FPMaxMinOp_MAX;
  }
  else if(ctx->op==1) {
   ctx->operation_ = FPMaxMinOp_MIN;
  }
  else if(ctx->op==2) {
   ctx->operation_ = FPMaxMinOp_MAXNUM;
  }
  else if(ctx->op==3) {
   ctx->operation_ = FPMaxMinOp_MINNUM;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FMAXNM_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FMAXNM_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMAXNM_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FMAXNM_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMAXNM_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FMAXNM_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FMAXP_advsimd_pair(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x5E30F800) {
  decode_fields32(ENC_FMAXP_ASISDPAIR_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMAXP_ASISDPAIR_ONLY_H); instr->operation = enc_to_oper(ENC_FMAXP_ASISDPAIR_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7E30F800) {
  decode_fields32(ENC_FMAXP_ASISDPAIR_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMAXP_ASISDPAIR_ONLY_SD); instr->operation = enc_to_oper(ENC_FMAXP_ASISDPAIR_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMAXP_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E403400) {
  decode_fields32(ENC_FMAXP_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMAXP_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMAXP_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2E20F400) {
  decode_fields32(ENC_FMAXP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMAXP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMAXP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMAXV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xE30F800) {
  decode_fields32(ENC_FMAXV_ASIMDALL_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMAXV_ASIMDALL_ONLY_H); instr->operation = enc_to_oper(ENC_FMAXV_ASIMDALL_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E30F800) {
  decode_fields32(ENC_FMAXV_ASIMDALL_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)!=1) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMAXV_ASIMDALL_ONLY_SD); instr->operation = enc_to_oper(ENC_FMAXV_ASIMDALL_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMAX_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE403400) {
  decode_fields32(ENC_FMAX_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMAX_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMAX_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xE20F400) {
  decode_fields32(ENC_FMAX_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMAX_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMAX_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMAX_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E204800) {
  decode_fields32(ENC_FMAX_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->op) {
   ctx->operation_ = FPMaxMinOp_MAX;
  }
  else if(ctx->op==1) {
   ctx->operation_ = FPMaxMinOp_MIN;
  }
  else if(ctx->op==2) {
   ctx->operation_ = FPMaxMinOp_MAXNUM;
  }
  else if(ctx->op==3) {
   ctx->operation_ = FPMaxMinOp_MINNUM;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FMAX_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FMAX_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMAX_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FMAX_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMAX_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FMAX_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FMINNMP_advsimd_pair(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x5EB0C800) {
  decode_fields32(ENC_FMINNMP_ASISDPAIR_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMINNMP_ASISDPAIR_ONLY_H); instr->operation = enc_to_oper(ENC_FMINNMP_ASISDPAIR_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7EB0C800) {
  decode_fields32(ENC_FMINNMP_ASISDPAIR_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMINNMP_ASISDPAIR_ONLY_SD); instr->operation = enc_to_oper(ENC_FMINNMP_ASISDPAIR_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMINNMP_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2EC00400) {
  decode_fields32(ENC_FMINNMP_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->a==1);
  {instr->encoding = (ENC_FMINNMP_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMINNMP_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2EA0C400) {
  decode_fields32(ENC_FMINNMP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMINNMP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMINNMP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMINNMV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xEB0C800) {
  decode_fields32(ENC_FMINNMV_ASIMDALL_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMINNMV_ASIMDALL_ONLY_H); instr->operation = enc_to_oper(ENC_FMINNMV_ASIMDALL_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EB0C800) {
  decode_fields32(ENC_FMINNMV_ASIMDALL_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)!=1) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMINNUM : ReduceOp_FMAXNUM;
  {instr->encoding = (ENC_FMINNMV_ASIMDALL_ONLY_SD); instr->operation = enc_to_oper(ENC_FMINNMV_ASIMDALL_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMINNM_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEC00400) {
  decode_fields32(ENC_FMINNM_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->a==1);
  {instr->encoding = (ENC_FMINNM_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMINNM_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xEA0C400) {
  decode_fields32(ENC_FMINNM_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMINNM_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMINNM_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMINNM_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E207800) {
  decode_fields32(ENC_FMINNM_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->op) {
   ctx->operation_ = FPMaxMinOp_MAX;
  }
  else if(ctx->op==1) {
   ctx->operation_ = FPMaxMinOp_MIN;
  }
  else if(ctx->op==2) {
   ctx->operation_ = FPMaxMinOp_MAXNUM;
  }
  else if(ctx->op==3) {
   ctx->operation_ = FPMaxMinOp_MINNUM;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FMINNM_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FMINNM_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMINNM_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FMINNM_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMINNM_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FMINNM_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FMINP_advsimd_pair(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x5EB0F800) {
  decode_fields32(ENC_FMINP_ASISDPAIR_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMINP_ASISDPAIR_ONLY_H); instr->operation = enc_to_oper(ENC_FMINP_ASISDPAIR_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7EB0F800) {
  decode_fields32(ENC_FMINP_ASISDPAIR_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->esize) * (2);
  ctx->elements = 2;
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMINP_ASISDPAIR_ONLY_SD); instr->operation = enc_to_oper(ENC_FMINP_ASISDPAIR_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMINP_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2EC03400) {
  decode_fields32(ENC_FMINP_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMINP_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMINP_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2EA0F400) {
  decode_fields32(ENC_FMINP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMINP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMINP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMINV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xEB0F800) {
  decode_fields32(ENC_FMINV_ASIMDALL_ONLY_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMINV_ASIMDALL_ONLY_H); instr->operation = enc_to_oper(ENC_FMINV_ASIMDALL_ONLY_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EB0F800) {
  decode_fields32(ENC_FMINV_ASIMDALL_ONLY_SD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)!=1) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->op = (ctx->o1==1) ? ReduceOp_FMIN : ReduceOp_FMAX;
  {instr->encoding = (ENC_FMINV_ASIMDALL_ONLY_SD); instr->operation = enc_to_oper(ENC_FMINV_ASIMDALL_ONLY_SD); rc = 0; };
 }
 return rc;
}


int FMIN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEC03400) {
  decode_fields32(ENC_FMIN_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMIN_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMIN_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xEA0F400) {
  decode_fields32(ENC_FMIN_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->pair = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_FMIN_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMIN_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMIN_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E205800) {
  decode_fields32(ENC_FMIN_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->op) {
   ctx->operation_ = FPMaxMinOp_MAX;
  }
  else if(ctx->op==1) {
   ctx->operation_ = FPMaxMinOp_MIN;
  }
  else if(ctx->op==2) {
   ctx->operation_ = FPMaxMinOp_MAXNUM;
  }
  else if(ctx->op==3) {
   ctx->operation_ = FPMaxMinOp_MINNUM;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FMIN_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FMIN_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMIN_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FMIN_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMIN_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FMIN_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FMLAL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFC0F400)==0xF800000) {
  decode_fields32(ENC_FMLAL_ASIMDELEM_LH, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 0;
  {instr->encoding = (ENC_FMLAL_ASIMDELEM_LH); instr->operation = enc_to_oper(ENC_FMLAL_ASIMDELEM_LH); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC0F400)==0x2F808000) {
  decode_fields32(ENC_FMLAL2_ASIMDELEM_LH, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 1;
  {instr->encoding = (ENC_FMLAL2_ASIMDELEM_LH); instr->operation = enc_to_oper(ENC_FMLAL2_ASIMDELEM_LH); rc = 0; };
 }
 return rc;
}


int FMLAL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE20EC00) {
  decode_fields32(ENC_FMLAL_ASIMDSAME_F, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 0;
  {instr->encoding = (ENC_FMLAL_ASIMDSAME_F); instr->operation = enc_to_oper(ENC_FMLAL_ASIMDSAME_F); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0x2E20CC00) {
  decode_fields32(ENC_FMLAL2_ASIMDSAME_F, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 1;
  {instr->encoding = (ENC_FMLAL2_ASIMDSAME_F); instr->operation = enc_to_oper(ENC_FMLAL2_ASIMDSAME_F); rc = 0; };
 }
 return rc;
}


int FMLA_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0F400)==0x5F001000) {
  decode_fields32(ENC_FMLA_ASISDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLA_ASISDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMLA_ASISDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFF80F400)==0x5F801000) {
  decode_fields32(ENC_FMLA_ASISDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLA_ASISDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMLA_ASISDELEM_R_SD); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC0F400)==0xF001000) {
  decode_fields32(ENC_FMLA_ASIMDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLA_ASIMDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMLA_ASIMDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80F400)==0xF801000) {
  decode_fields32(ENC_FMLA_ASIMDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLA_ASIMDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMLA_ASIMDELEM_R_SD); rc = 0; };
 }
 return rc;
}


int FMLA_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE400C00) {
  decode_fields32(ENC_FMLA_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->a==1);
  {instr->encoding = (ENC_FMLA_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMLA_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xE20CC00) {
  decode_fields32(ENC_FMLA_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->op==1);
  {instr->encoding = (ENC_FMLA_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMLA_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMLSL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFC0F400)==0xF804000) {
  decode_fields32(ENC_FMLSL_ASIMDELEM_LH, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 0;
  {instr->encoding = (ENC_FMLSL_ASIMDELEM_LH); instr->operation = enc_to_oper(ENC_FMLSL_ASIMDELEM_LH); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC0F400)==0x2F80C000) {
  decode_fields32(ENC_FMLSL2_ASIMDELEM_LH, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 1;
  {instr->encoding = (ENC_FMLSL2_ASIMDELEM_LH); instr->operation = enc_to_oper(ENC_FMLSL2_ASIMDELEM_LH); rc = 0; };
 }
 return rc;
}


int FMLSL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEA0EC00) {
  decode_fields32(ENC_FMLSL_ASIMDSAME_F, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 0;
  {instr->encoding = (ENC_FMLSL_ASIMDSAME_F); instr->operation = enc_to_oper(ENC_FMLSL_ASIMDSAME_F); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0x2EA0CC00) {
  decode_fields32(ENC_FMLSL2_ASIMDSAME_F, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<12))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->S==1);
  ctx->part = 1;
  {instr->encoding = (ENC_FMLSL2_ASIMDSAME_F); instr->operation = enc_to_oper(ENC_FMLSL2_ASIMDSAME_F); rc = 0; };
 }
 return rc;
}


int FMLS_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0F400)==0x5F005000) {
  decode_fields32(ENC_FMLS_ASISDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLS_ASISDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMLS_ASISDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFF80F400)==0x5F805000) {
  decode_fields32(ENC_FMLS_ASISDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLS_ASISDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMLS_ASISDELEM_R_SD); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC0F400)==0xF005000) {
  decode_fields32(ENC_FMLS_ASIMDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLS_ASIMDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMLS_ASIMDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80F400)==0xF805000) {
  decode_fields32(ENC_FMLS_ASIMDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_FMLS_ASIMDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMLS_ASIMDELEM_R_SD); rc = 0; };
 }
 return rc;
}


int FMLS_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEC00C00) {
  decode_fields32(ENC_FMLS_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->a==1);
  {instr->encoding = (ENC_FMLS_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMLS_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xEA0CC00) {
  decode_fields32(ENC_FMLS_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->op==1);
  {instr->encoding = (ENC_FMLS_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMLS_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMOV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFF8FC00)==0xF00FC00) {
  decode_fields32(ENC_FMOV_ASIMDIMM_H_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->rd = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->imm8 = ((ctx->a<<7)|(ctx->b<<6)|(ctx->c<<5)|(ctx->d<<4)|(ctx->e<<3)|(ctx->f<<2)|(ctx->g<<1)|ctx->h);
  ctx->imm16 = (((((ctx->imm8)>>(7)) & (((uint64_t)1<<((7)-(7)+1))-1))<<15)|((((((ctx->imm8)>>(6)) & (((uint64_t)1<<((6)-(6)+1))-1))) ^ (((uint64_t)1<<(1))-1))<<14)|(Replicate((((ctx->imm8)>>(6)) & (((uint64_t)1<<((6)-(6)+1))-1)), 2, 1)<<12)|((((ctx->imm8)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))<<6)|0);
  ctx->imm = Replicate(ctx->imm16, ((0x10) ? ((ctx->datasize) / (0x10)) : 0), 16);
  {instr->encoding = (ENC_FMOV_ASIMDIMM_H_H); instr->operation = enc_to_oper(ENC_FMOV_ASIMDIMM_H_H); rc = 0; };
 }


 if(((ctx->insword) & 0x9FF8FC00)==0xF00F400) {
  decode_fields32(ENC_FMOV_ASIMDIMM_S_S, ctx, instr);
  ctx->rd = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  if(!(((ctx->cmode<<1)|ctx->op)&0x13)) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==1) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==2) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==3) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x10) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x11) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x12) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x13) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x18) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x19) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1e)==0x1c) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1e) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1f) {
   if(ctx->Q==0) {
    { return -4; };
   }
   ctx->operation_ = ImmediateOp_MOVI;
  }
  ctx->imm64 = AdvSIMDExpandImm(ctx->op,ctx->cmode,((ctx->a<<7)|(ctx->b<<6)|(ctx->c<<5)|(ctx->d<<4)|(ctx->e<<3)|(ctx->f<<2)|(ctx->g<<1)|ctx->h));
  ctx->imm = Replicate(ctx->imm64, ((0x40) ? ((ctx->datasize) / (0x40)) : 0), 64);
  if(ctx->op==0) {instr->encoding = (ENC_FMOV_ASIMDIMM_S_S); instr->operation = enc_to_oper(ENC_FMOV_ASIMDIMM_S_S); rc = 0; };
  if(ctx->Q==1 && ctx->op==1) {instr->encoding = (ENC_FMOV_ASIMDIMM_D2_D); instr->operation = enc_to_oper(ENC_FMOV_ASIMDIMM_D2_D); rc = 0; };
 }
 return rc;
}


int FMOV_cpy_z_p_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30FFE0)==0x5104000) {
  decode_fields32(ENC_FMOV_CPY_Z_P_I_, ctx, instr);
  {instr->encoding = (ENC_FMOV_CPY_Z_P_I_); instr->operation = enc_to_oper(ENC_FMOV_CPY_Z_P_I_); rc = 0; };
 }
 return rc;
}


int FMOV_dup_z_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFFE0)==0x2538C000) {
  decode_fields32(ENC_FMOV_DUP_Z_I_, ctx, instr);
  {instr->encoding = (ENC_FMOV_DUP_Z_I_); instr->operation = enc_to_oper(ENC_FMOV_DUP_Z_I_); rc = 0; };
 }
 return rc;
}


int FMOV_fcpy_z_p_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30E000)==0x510C000) {
  decode_fields32(ENC_FMOV_FCPY_Z_P_I_, ctx, instr);
  {instr->encoding = (ENC_FMOV_FCPY_Z_P_I_); instr->operation = enc_to_oper(ENC_FMOV_FCPY_Z_P_I_); rc = 0; };
 }
 return rc;
}


int FMOV_fdup_z_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x2539C000) {
  decode_fields32(ENC_FMOV_FDUP_Z_I_, ctx, instr);
  {instr->encoding = (ENC_FMOV_FDUP_Z_I_); instr->operation = enc_to_oper(ENC_FMOV_FDUP_Z_I_); rc = 0; };
 }
 return rc;
}


int FMOV_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E204000) {
  decode_fields32(ENC_FMOV_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->opc) {
   ctx->fpop = FPUnaryOp_MOV;
  }
  else if(ctx->opc==1) {
   ctx->fpop = FPUnaryOp_ABS;
  }
  else if(ctx->opc==2) {
   ctx->fpop = FPUnaryOp_NEG;
  }
  else if(ctx->opc==3) {
   ctx->fpop = FPUnaryOp_SQRT;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FMOV_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FMOV_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMOV_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FMOV_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMOV_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FMOV_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FMOV_float_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F36FC00)==0x1E260000) {
  decode_fields32(ENC_FMOV_32H_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3 && ctx->rmode==0 && ctx->opcode==6) {instr->encoding = (ENC_FMOV_32H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_32H_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3 && ctx->rmode==0 && ctx->opcode==6) {instr->encoding = (ENC_FMOV_64H_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_64H_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==3 && ctx->rmode==0 && ctx->opcode==7) {instr->encoding = (ENC_FMOV_H32_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_H32_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0 && ctx->rmode==0 && ctx->opcode==7) {instr->encoding = (ENC_FMOV_S32_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_S32_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0 && ctx->rmode==0 && ctx->opcode==6) {instr->encoding = (ENC_FMOV_32S_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_32S_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3 && ctx->rmode==0 && ctx->opcode==7) {instr->encoding = (ENC_FMOV_H64_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_H64_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1 && ctx->rmode==0 && ctx->opcode==7) {instr->encoding = (ENC_FMOV_D64_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_D64_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==2 && ctx->rmode==1 && ctx->opcode==7) {instr->encoding = (ENC_FMOV_V64I_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_V64I_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1 && ctx->rmode==0 && ctx->opcode==6) {instr->encoding = (ENC_FMOV_64D_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_64D_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==2 && ctx->rmode==1 && ctx->opcode==6) {instr->encoding = (ENC_FMOV_64VX_FLOAT2INT); instr->operation = enc_to_oper(ENC_FMOV_64VX_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int FMOV_float_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF201FE0)==0x1E201000) {
  decode_fields32(ENC_FMOV_H_FLOATIMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  if(!ctx->ftype) {
   ctx->datasize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->datasize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->datasize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->imm = VFPExpandImm(ctx->imm8,8);
  if(ctx->ftype==3) {instr->encoding = (ENC_FMOV_H_FLOATIMM); instr->operation = enc_to_oper(ENC_FMOV_H_FLOATIMM); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMOV_S_FLOATIMM); instr->operation = enc_to_oper(ENC_FMOV_S_FLOATIMM); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMOV_D_FLOATIMM); instr->operation = enc_to_oper(ENC_FMOV_D_FLOATIMM); rc = 0; };
 }
 return rc;
}


int FMSUB_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF208000)==0x1F008000) {
  decode_fields32(ENC_FMSUB_H_FLOATDP3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->opa_neg = (ctx->o1==1);
  ctx->op1_neg = (ctx->o0!=ctx->o1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FMSUB_H_FLOATDP3); instr->operation = enc_to_oper(ENC_FMSUB_H_FLOATDP3); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMSUB_S_FLOATDP3); instr->operation = enc_to_oper(ENC_FMSUB_S_FLOATDP3); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMSUB_D_FLOATDP3); instr->operation = enc_to_oper(ENC_FMSUB_D_FLOATDP3); rc = 0; };
 }
 return rc;
}


int FMULX_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0F400)==0x7F009000) {
  decode_fields32(ENC_FMULX_ASISDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMULX_ASISDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMULX_ASISDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFF80F400)==0x7F809000) {
  decode_fields32(ENC_FMULX_ASISDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMULX_ASISDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMULX_ASISDELEM_R_SD); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC0F400)==0x2F009000) {
  decode_fields32(ENC_FMULX_ASIMDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMULX_ASIMDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMULX_ASIMDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80F400)==0x2F809000) {
  decode_fields32(ENC_FMULX_ASIMDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMULX_ASIMDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMULX_ASIMDELEM_R_SD); rc = 0; };
 }
 return rc;
}


int FMULX_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E401C00) {
  decode_fields32(ENC_FMULX_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FMULX_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMULX_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x5E20DC00) {
  decode_fields32(ENC_FMULX_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FMULX_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMULX_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0xE401C00) {
  decode_fields32(ENC_FMULX_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FMULX_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMULX_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xE20DC00) {
  decode_fields32(ENC_FMULX_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FMULX_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMULX_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMUL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0F400)==0x5F009000) {
  decode_fields32(ENC_FMUL_ASISDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMUL_ASISDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMUL_ASISDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFF80F400)==0x5F809000) {
  decode_fields32(ENC_FMUL_ASISDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMUL_ASISDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMUL_ASISDELEM_R_SD); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC0F400)==0xF009000) {
  decode_fields32(ENC_FMUL_ASIMDELEM_RH_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMUL_ASIMDELEM_RH_H); instr->operation = enc_to_oper(ENC_FMUL_ASIMDELEM_RH_H); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80F400)==0xF809000) {
  decode_fields32(ENC_FMUL_ASIMDELEM_R_SD, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  ctx->Rmhi = ctx->M;
  if(!(((ctx->sz<<1)|ctx->L)&2)) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  }
  else if(((ctx->sz<<1)|ctx->L)==2) {
   ctx->index = (unsigned int)(ctx->H);
  }
  else if(((ctx->sz<<1)|ctx->L)==3) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->mulx_op = (ctx->U==1);
  {instr->encoding = (ENC_FMUL_ASIMDELEM_R_SD); instr->operation = enc_to_oper(ENC_FMUL_ASIMDELEM_R_SD); rc = 0; };
 }
 return rc;
}


int FMUL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0x2E401C00) {
  decode_fields32(ENC_FMUL_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FMUL_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FMUL_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0x2E20DC00) {
  decode_fields32(ENC_FMUL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FMUL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FMUL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FMUL_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E200800) {
  decode_fields32(ENC_FMUL_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->negated = (ctx->op==1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FMUL_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FMUL_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FMUL_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FMUL_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FMUL_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FMUL_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FNEG_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF8F800) {
  decode_fields32(ENC_FNEG_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_FNEG_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FNEG_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA0F800) {
  decode_fields32(ENC_FNEG_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_FNEG_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FNEG_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FNEG_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E214000) {
  decode_fields32(ENC_FNEG_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->opc) {
   ctx->fpop = FPUnaryOp_MOV;
  }
  else if(ctx->opc==1) {
   ctx->fpop = FPUnaryOp_ABS;
  }
  else if(ctx->opc==2) {
   ctx->fpop = FPUnaryOp_NEG;
  }
  else if(ctx->opc==3) {
   ctx->fpop = FPUnaryOp_SQRT;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FNEG_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FNEG_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FNEG_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FNEG_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FNEG_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FNEG_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FNMADD_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF208000)==0x1F200000) {
  decode_fields32(ENC_FNMADD_H_FLOATDP3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->opa_neg = (ctx->o1==1);
  ctx->op1_neg = (ctx->o0!=ctx->o1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FNMADD_H_FLOATDP3); instr->operation = enc_to_oper(ENC_FNMADD_H_FLOATDP3); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FNMADD_S_FLOATDP3); instr->operation = enc_to_oper(ENC_FNMADD_S_FLOATDP3); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FNMADD_D_FLOATDP3); instr->operation = enc_to_oper(ENC_FNMADD_D_FLOATDP3); rc = 0; };
 }
 return rc;
}


int FNMSUB_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF208000)==0x1F208000) {
  decode_fields32(ENC_FNMSUB_H_FLOATDP3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->opa_neg = (ctx->o1==1);
  ctx->op1_neg = (ctx->o0!=ctx->o1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FNMSUB_H_FLOATDP3); instr->operation = enc_to_oper(ENC_FNMSUB_H_FLOATDP3); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FNMSUB_S_FLOATDP3); instr->operation = enc_to_oper(ENC_FNMSUB_S_FLOATDP3); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FNMSUB_D_FLOATDP3); instr->operation = enc_to_oper(ENC_FNMSUB_D_FLOATDP3); rc = 0; };
 }
 return rc;
}


int FNMUL_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E208800) {
  decode_fields32(ENC_FNMUL_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->negated = (ctx->op==1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FNMUL_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FNMUL_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FNMUL_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FNMUL_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FNMUL_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FNMUL_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int FRECPE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5EF9D800) {
  decode_fields32(ENC_FRECPE_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRECPE_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRECPE_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5EA1D800) {
  decode_fields32(ENC_FRECPE_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRECPE_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FRECPE_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xEF9D800) {
  decode_fields32(ENC_FRECPE_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRECPE_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRECPE_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA1D800) {
  decode_fields32(ENC_FRECPE_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRECPE_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRECPE_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRECPS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E403C00) {
  decode_fields32(ENC_FRECPS_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRECPS_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FRECPS_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x5E20FC00) {
  decode_fields32(ENC_FRECPS_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRECPS_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FRECPS_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0xE403C00) {
  decode_fields32(ENC_FRECPS_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRECPS_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FRECPS_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xE20FC00) {
  decode_fields32(ENC_FRECPS_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRECPS_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FRECPS_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FRECPX_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5EF9F800) {
  decode_fields32(ENC_FRECPX_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRECPX_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRECPX_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5EA1F800) {
  decode_fields32(ENC_FRECPX_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRECPX_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FRECPX_ASISDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINT32X_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0x2E21E800) {
  decode_fields32(ENC_FRINT32X_ASIMDMISC_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->intsize = (ctx->op==0) ? 0x20 : 0x40;
  ctx->rounding = (ctx->U==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_FRINT32X_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINT32X_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINT32X_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x1E28C000) {
  decode_fields32(ENC_FRINT32X_S_FLOATDP1, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if((ctx->ftype&2)==2) {
   { return -4; };
  }
  ctx->intsize = ((((ctx->op)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) ? 0x20 : 0x40;
  ctx->rounding = ((((ctx->op)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINT32X_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT32X_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINT32X_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT32X_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINT32Z_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0xE21E800) {
  decode_fields32(ENC_FRINT32Z_ASIMDMISC_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->intsize = (ctx->op==0) ? 0x20 : 0x40;
  ctx->rounding = (ctx->U==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_FRINT32Z_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINT32Z_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINT32Z_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x1E284000) {
  decode_fields32(ENC_FRINT32Z_S_FLOATDP1, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if((ctx->ftype&2)==2) {
   { return -4; };
  }
  ctx->intsize = ((((ctx->op)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) ? 0x20 : 0x40;
  ctx->rounding = ((((ctx->op)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINT32Z_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT32Z_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINT32Z_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT32Z_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINT64X_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0x2E21F800) {
  decode_fields32(ENC_FRINT64X_ASIMDMISC_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->intsize = (ctx->op==0) ? 0x20 : 0x40;
  ctx->rounding = (ctx->U==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_FRINT64X_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINT64X_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINT64X_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x1E29C000) {
  decode_fields32(ENC_FRINT64X_S_FLOATDP1, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if((ctx->ftype&2)==2) {
   { return -4; };
  }
  ctx->intsize = ((((ctx->op)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) ? 0x20 : 0x40;
  ctx->rounding = ((((ctx->op)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINT64X_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT64X_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINT64X_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT64X_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINT64Z_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0xE21F800) {
  decode_fields32(ENC_FRINT64Z_ASIMDMISC_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->intsize = (ctx->op==0) ? 0x20 : 0x40;
  ctx->rounding = (ctx->U==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_FRINT64Z_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINT64Z_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINT64Z_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFBFFC00)==0x1E294000) {
  decode_fields32(ENC_FRINT64Z_S_FLOATDP1, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<18))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if((ctx->ftype&2)==2) {
   { return -4; };
  }
  ctx->intsize = ((((ctx->op)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) ? 0x20 : 0x40;
  ctx->rounding = ((((ctx->op)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) ? FPRounding_ZERO : FPRoundingMode(ctx->FPCR);
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINT64Z_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT64Z_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINT64Z_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINT64Z_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINTA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2E798800) {
  decode_fields32(ENC_FRINTA_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10485 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10485 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10497 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10497 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTA_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRINTA_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E218800) {
  decode_fields32(ENC_FRINTA_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10516 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10516 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10528 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10528 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTA_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINTA_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINTA_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E264000) {
  decode_fields32(ENC_FRINTA_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->exact = 
# 10565 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10565 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(ctx->rmode&4)) {
   ctx->rounding = FPDecodeRounding((((ctx->rmode)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1)));
  }
  else if(ctx->rmode==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(ctx->rmode==5) {
   { return -4; };
  }
  else if(ctx->rmode==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10577 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10577 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(ctx->rmode==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FRINTA_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTA_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINTA_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTA_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINTA_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTA_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINTI_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF99800) {
  decode_fields32(ENC_FRINTI_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10617 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10617 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTI_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRINTI_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA19800) {
  decode_fields32(ENC_FRINTI_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10636 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10636 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10648 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10648 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTI_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINTI_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINTI_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E27C000) {
  decode_fields32(ENC_FRINTI_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->exact = 
# 10685 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10685 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(ctx->rmode&4)) {
   ctx->rounding = FPDecodeRounding((((ctx->rmode)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1)));
  }
  else if(ctx->rmode==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(ctx->rmode==5) {
   { return -4; };
  }
  else if(ctx->rmode==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10697 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10697 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(ctx->rmode==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FRINTI_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTI_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINTI_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTI_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINTI_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTI_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINTM_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xE799800) {
  decode_fields32(ENC_FRINTM_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10725 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10725 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTM_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRINTM_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xE219800) {
  decode_fields32(ENC_FRINTM_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10756 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10756 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTM_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINTM_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINTM_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E254000) {
  decode_fields32(ENC_FRINTM_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->exact = 
# 10805 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10805 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(ctx->rmode&4)) {
   ctx->rounding = FPDecodeRounding((((ctx->rmode)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1)));
  }
  else if(ctx->rmode==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(ctx->rmode==5) {
   { return -4; };
  }
  else if(ctx->rmode==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10817 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10817 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(ctx->rmode==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FRINTM_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTM_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINTM_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTM_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINTM_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTM_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINTN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xE798800) {
  decode_fields32(ENC_FRINTN_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10857 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10857 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTN_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRINTN_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xE218800) {
  decode_fields32(ENC_FRINTN_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTN_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINTN_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINTN_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E244000) {
  decode_fields32(ENC_FRINTN_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->exact = 
# 10925 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10925 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(ctx->rmode&4)) {
   ctx->rounding = FPDecodeRounding((((ctx->rmode)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1)));
  }
  else if(ctx->rmode==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(ctx->rmode==5) {
   { return -4; };
  }
  else if(ctx->rmode==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10937 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10937 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(ctx->rmode==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FRINTN_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTN_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINTN_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTN_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINTN_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTN_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINTP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xEF98800) {
  decode_fields32(ENC_FRINTP_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10965 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10965 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 10977 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 10977 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTP_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRINTP_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA18800) {
  decode_fields32(ENC_FRINTP_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 10996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 10996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11008 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11008 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTP_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINTP_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINTP_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E24C000) {
  decode_fields32(ENC_FRINTP_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->exact = 
# 11045 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11045 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(ctx->rmode&4)) {
   ctx->rounding = FPDecodeRounding((((ctx->rmode)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1)));
  }
  else if(ctx->rmode==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(ctx->rmode==5) {
   { return -4; };
  }
  else if(ctx->rmode==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11057 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11057 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(ctx->rmode==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FRINTP_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTP_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINTP_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTP_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINTP_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTP_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINTX_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2E799800) {
  decode_fields32(ENC_FRINTX_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 11085 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11085 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11097 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11097 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTX_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRINTX_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E219800) {
  decode_fields32(ENC_FRINTX_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 11116 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11116 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11128 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11128 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTX_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINTX_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINTX_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E274000) {
  decode_fields32(ENC_FRINTX_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->exact = 
# 11165 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11165 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(ctx->rmode&4)) {
   ctx->rounding = FPDecodeRounding((((ctx->rmode)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1)));
  }
  else if(ctx->rmode==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(ctx->rmode==5) {
   { return -4; };
  }
  else if(ctx->rmode==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11177 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11177 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(ctx->rmode==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FRINTX_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTX_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINTX_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTX_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINTX_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTX_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRINTZ_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0xEF99800) {
  decode_fields32(ENC_FRINTZ_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 11205 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11205 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11217 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11217 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTZ_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRINTZ_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xEA19800) {
  decode_fields32(ENC_FRINTZ_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->exact = 
# 11236 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11236 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)&4)) {
   ctx->rounding = FPDecodeRounding(((ctx->o1<<1)|ctx->o2));
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==5) {
   { return -4; };
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11248 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11248 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(((ctx->U<<2)|(ctx->o1<<1)|ctx->o2)==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  {instr->encoding = (ENC_FRINTZ_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRINTZ_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRINTZ_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E25C000) {
  decode_fields32(ENC_FRINTZ_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->exact = 
# 11285 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11285 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  if(!(ctx->rmode&4)) {
   ctx->rounding = FPDecodeRounding((((ctx->rmode)>>(0)) & (((uint64_t)1<<((1)-(0)+1))-1)));
  }
  else if(ctx->rmode==4) {
   ctx->rounding = FPRounding_TIEAWAY;
  }
  else if(ctx->rmode==5) {
   { return -4; };
  }
  else if(ctx->rmode==6) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->exact = 
# 11297 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 11297 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  }
  else if(ctx->rmode==7) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FRINTZ_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTZ_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FRINTZ_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTZ_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FRINTZ_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FRINTZ_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FRSQRTE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7EF9D800) {
  decode_fields32(ENC_FRSQRTE_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRSQRTE_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRSQRTE_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7EA1D800) {
  decode_fields32(ENC_FRSQRTE_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRSQRTE_ASISDMISC_R); instr->operation = enc_to_oper(ENC_FRSQRTE_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF9D800) {
  decode_fields32(ENC_FRSQRTE_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRSQRTE_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FRSQRTE_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA1D800) {
  decode_fields32(ENC_FRSQRTE_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRSQRTE_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FRSQRTE_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FRSQRTS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5EC03C00) {
  decode_fields32(ENC_FRSQRTS_ASISDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRSQRTS_ASISDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FRSQRTS_ASISDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC00)==0x5EA0FC00) {
  decode_fields32(ENC_FRSQRTS_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  {instr->encoding = (ENC_FRSQRTS_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_FRSQRTS_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0FC00)==0xEC03C00) {
  decode_fields32(ENC_FRSQRTS_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRSQRTS_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FRSQRTS_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xEA0FC00) {
  decode_fields32(ENC_FRSQRTS_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FRSQRTS_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FRSQRTS_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FSQRT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2EF9F800) {
  decode_fields32(ENC_FSQRT_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FSQRT_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_FSQRT_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA1F800) {
  decode_fields32(ENC_FSQRT_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_FSQRT_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_FSQRT_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int FSQRT_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x1E21C000) {
  decode_fields32(ENC_FSQRT_H_FLOATDP1, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!ctx->opc) {
   ctx->fpop = FPUnaryOp_MOV;
  }
  else if(ctx->opc==1) {
   ctx->fpop = FPUnaryOp_ABS;
  }
  else if(ctx->opc==2) {
   ctx->fpop = FPUnaryOp_NEG;
  }
  else if(ctx->opc==3) {
   ctx->fpop = FPUnaryOp_SQRT;
  }
  if(ctx->ftype==3) {instr->encoding = (ENC_FSQRT_H_FLOATDP1); instr->operation = enc_to_oper(ENC_FSQRT_H_FLOATDP1); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FSQRT_S_FLOATDP1); instr->operation = enc_to_oper(ENC_FSQRT_S_FLOATDP1); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FSQRT_D_FLOATDP1); instr->operation = enc_to_oper(ENC_FSQRT_D_FLOATDP1); rc = 0; };
 }
 return rc;
}


int FSUB_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEC01400) {
  decode_fields32(ENC_FSUB_ASIMDSAMEFP16_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->abs = (ctx->U==1);
  {instr->encoding = (ENC_FSUB_ASIMDSAMEFP16_ONLY); instr->operation = enc_to_oper(ENC_FSUB_ASIMDSAMEFP16_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBFA0FC00)==0xEA0D400) {
  decode_fields32(ENC_FSUB_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->abs = (ctx->U==1);
  {instr->encoding = (ENC_FSUB_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_FSUB_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int FSUB_float(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x1E203800) {
  decode_fields32(ENC_FSUB_H_FLOATDP2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!ctx->ftype) {
   ctx->esize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->esize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->esize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  ctx->sub_op = (ctx->op==1);
  if(ctx->ftype==3) {instr->encoding = (ENC_FSUB_H_FLOATDP2); instr->operation = enc_to_oper(ENC_FSUB_H_FLOATDP2); rc = 0; };
  if(ctx->ftype==0) {instr->encoding = (ENC_FSUB_S_FLOATDP2); instr->operation = enc_to_oper(ENC_FSUB_S_FLOATDP2); rc = 0; };
  if(ctx->ftype==1) {instr->encoding = (ENC_FSUB_D_FLOATDP2); instr->operation = enc_to_oper(ENC_FSUB_D_FLOATDP2); rc = 0; };
 }
 return rc;
}


int GMI(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9AC01400) {
  decode_fields32(ENC_GMI_64G_DP_2SRC, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Xd);
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->m = (unsigned int)(ctx->Xm);
  {instr->encoding = (ENC_GMI_64G_DP_2SRC); instr->operation = enc_to_oper(ENC_GMI_64G_DP_2SRC); rc = 0; };
 }
 return rc;
}


int HINT(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF01F)==0xD503201F) {
  decode_fields32(ENC_HINT_HM_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_HINT_HM_HINTS); instr->operation = enc_to_oper(ENC_HINT_HM_HINTS); rc = 0; };
 }
 return rc;
}


int HLT(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4400000) {
  decode_fields32(ENC_HLT_EX_EXCEPTION, ctx, instr);
  if(ctx->EDSCR_HDE==0 || !HaltingAllowed()) {
   { return -4; };
  }
  if((ctx->features1 & ((uint64_t)1<<3))) {
   ctx->BTypeCompatible = (
# 11731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
  1
# 11731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
  );
  }
  {instr->encoding = (ENC_HLT_EX_EXCEPTION); instr->operation = enc_to_oper(ENC_HLT_EX_EXCEPTION); rc = 0; };
 }
 return rc;
}


int HVC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4000002) {
  decode_fields32(ENC_HVC_EX_EXCEPTION, ctx, instr);
  {instr->encoding = (ENC_HVC_EX_EXCEPTION); instr->operation = enc_to_oper(ENC_HVC_EX_EXCEPTION); rc = 0; };
 }
 return rc;
}


int IC_SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF8F000)==0xD5087000) {
  decode_fields32(ENC_IC_SYS_CR_SYSTEMINSTRS, ctx, instr);
  {instr->encoding = (ENC_IC_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_IC_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int INS_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08400)==0x6E000400) {
  decode_fields32(ENC_INS_ASIMDINS_IV_V, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->size = LowestSetBit(ctx->imm5);
  if(ctx->size>3) {
   { return -4; };
  }
  ctx->dst_index = (unsigned int)((((ctx->imm5)>>(ctx->size+1)) & (((uint64_t)1<<((4)-(ctx->size+1)+1))-1)));
  ctx->src_index = (unsigned int)((((ctx->imm4)>>(ctx->size)) & (((uint64_t)1<<((3)-(ctx->size)+1))-1)));
  ctx->idxdsize = ((((ctx->imm4)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) ? 0x80 : 0x40;
  ctx->esize = (8) << (ctx->size);

  if(MOV_INS_advsimd_elt(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_INS_ASIMDINS_IV_V); instr->operation = enc_to_oper(ENC_INS_ASIMDINS_IV_V); rc = 0; };
 }
 return rc;
}


int INS_advsimd_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4E001C00) {
  decode_fields32(ENC_INS_ASIMDINS_IR_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->size = LowestSetBit(ctx->imm5);
  if(ctx->size>3) {
   { return -4; };
  }
  ctx->index = (unsigned int)((((ctx->imm5)>>(ctx->size+1)) & (((uint64_t)1<<((4)-(ctx->size+1)+1))-1)));
  ctx->esize = (8) << (ctx->size);
  ctx->datasize = 0x80;

  if(MOV_INS_advsimd_gen(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_INS_ASIMDINS_IR_R); instr->operation = enc_to_oper(ENC_INS_ASIMDINS_IR_R); rc = 0; };
 }
 return rc;
}


int IRG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9AC01000) {
  decode_fields32(ENC_IRG_64I_DP_2SRC, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Xd);
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->m = (unsigned int)(ctx->Xm);
  {instr->encoding = (ENC_IRG_64I_DP_2SRC); instr->operation = enc_to_oper(ENC_IRG_64I_DP_2SRC); rc = 0; };
 }
 return rc;
}


int ISB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD50330DF) {
  decode_fields32(ENC_ISB_BI_BARRIERS, ctx, instr);
  {instr->encoding = (ENC_ISB_BI_BARRIERS); instr->operation = enc_to_oper(ENC_ISB_BI_BARRIERS); rc = 0; };
 }
 return rc;
}


int LD1R_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xD40C000) {
  decode_fields32(ENC_LD1R_ASISDLSO_R1, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 11856 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11856 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_LD1R_ASISDLSO_R1); instr->operation = enc_to_oper(ENC_LD1R_ASISDLSO_R1); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xDC0C000) {
  decode_fields32(ENC_LD1R_ASISDLSOP_R1_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 11867 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 11867 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_LD1R_ASISDLSOP_R1_I); instr->operation = enc_to_oper(ENC_LD1R_ASISDLSOP_R1_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_LD1R_ASISDLSOP_RX1_R); instr->operation = enc_to_oper(ENC_LD1R_ASISDLSOP_RX1_R); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 11876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 11876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 11882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 11882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD1_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xC402000) {
  decode_fields32(ENC_LD1_ASISDLSE_R1_1V, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 11925 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 11925 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==7) {instr->encoding = (ENC_LD1_ASISDLSE_R1_1V); instr->operation = enc_to_oper(ENC_LD1_ASISDLSE_R1_1V); rc = 0; };
  if(ctx->opcode==10) {instr->encoding = (ENC_LD1_ASISDLSE_R2_2V); instr->operation = enc_to_oper(ENC_LD1_ASISDLSE_R2_2V); rc = 0; };
  if(ctx->opcode==6) {instr->encoding = (ENC_LD1_ASISDLSE_R3_3V); instr->operation = enc_to_oper(ENC_LD1_ASISDLSE_R3_3V); rc = 0; };
  if(ctx->opcode==2) {instr->encoding = (ENC_LD1_ASISDLSE_R4_4V); instr->operation = enc_to_oper(ENC_LD1_ASISDLSE_R4_4V); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xCC02000) {
  decode_fields32(ENC_LD1_ASISDLSEP_I1_I1, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 11939 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 11939 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==7) {instr->encoding = (ENC_LD1_ASISDLSEP_I1_I1); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_I1_I1); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==7) {instr->encoding = (ENC_LD1_ASISDLSEP_R1_R1); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_R1_R1); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==10) {instr->encoding = (ENC_LD1_ASISDLSEP_I2_I2); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_I2_I2); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==10) {instr->encoding = (ENC_LD1_ASISDLSEP_R2_R2); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_R2_R2); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==6) {instr->encoding = (ENC_LD1_ASISDLSEP_I3_I3); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_I3_I3); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==6) {instr->encoding = (ENC_LD1_ASISDLSEP_R3_R3); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_R3_R3); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==2) {instr->encoding = (ENC_LD1_ASISDLSEP_I4_I4); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_I4_I4); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==2) {instr->encoding = (ENC_LD1_ASISDLSEP_R4_R4); instr->operation = enc_to_oper(ENC_LD1_ASISDLSEP_R4_R4); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int LD1_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD400000) {
  decode_fields32(ENC_LD1_ASISDLSO_B1_1B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12003 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12003 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==0) {instr->encoding = (ENC_LD1_ASISDLSO_B1_1B); instr->operation = enc_to_oper(ENC_LD1_ASISDLSO_B1_1B); rc = 0; };
  if(ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_LD1_ASISDLSO_H1_1H); instr->operation = enc_to_oper(ENC_LD1_ASISDLSO_H1_1H); rc = 0; };
  if(ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_LD1_ASISDLSO_S1_1S); instr->operation = enc_to_oper(ENC_LD1_ASISDLSO_S1_1S); rc = 0; };
  if(ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD1_ASISDLSO_D1_1D); instr->operation = enc_to_oper(ENC_LD1_ASISDLSO_D1_1D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xDC00000) {
  decode_fields32(ENC_LD1_ASISDLSOP_B1_I1B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12017 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12017 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==0) {instr->encoding = (ENC_LD1_ASISDLSOP_B1_I1B); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_B1_I1B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==0) {instr->encoding = (ENC_LD1_ASISDLSOP_BX1_R1B); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_BX1_R1B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_LD1_ASISDLSOP_H1_I1H); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_H1_I1H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_LD1_ASISDLSOP_HX1_R1H); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_HX1_R1H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_LD1_ASISDLSOP_S1_I1S); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_S1_I1S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_LD1_ASISDLSOP_SX1_R1S); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_SX1_R1S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD1_ASISDLSOP_D1_I1D); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_D1_I1D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD1_ASISDLSOP_DX1_R1D); instr->operation = enc_to_oper(ENC_LD1_ASISDLSOP_DX1_R1D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 12032 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 12032 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 12038 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 12038 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD2R_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xD60C000) {
  decode_fields32(ENC_LD2R_ASISDLSO_R2, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12081 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12081 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_LD2R_ASISDLSO_R2); instr->operation = enc_to_oper(ENC_LD2R_ASISDLSO_R2); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xDE0C000) {
  decode_fields32(ENC_LD2R_ASISDLSOP_R2_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_LD2R_ASISDLSOP_R2_I); instr->operation = enc_to_oper(ENC_LD2R_ASISDLSOP_R2_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_LD2R_ASISDLSOP_RX2_R); instr->operation = enc_to_oper(ENC_LD2R_ASISDLSOP_RX2_R); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 12101 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 12101 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 12107 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 12107 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD2_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xC408000) {
  decode_fields32(ENC_LD2_ASISDLSE_R2, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12150 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12150 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_LD2_ASISDLSE_R2); instr->operation = enc_to_oper(ENC_LD2_ASISDLSE_R2); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xCC08000) {
  decode_fields32(ENC_LD2_ASISDLSEP_I2_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12161 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12161 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_LD2_ASISDLSEP_I2_I); instr->operation = enc_to_oper(ENC_LD2_ASISDLSEP_I2_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_LD2_ASISDLSEP_R2_R); instr->operation = enc_to_oper(ENC_LD2_ASISDLSEP_R2_R); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int LD2_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD600000) {
  decode_fields32(ENC_LD2_ASISDLSO_B2_2B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12219 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12219 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==0) {instr->encoding = (ENC_LD2_ASISDLSO_B2_2B); instr->operation = enc_to_oper(ENC_LD2_ASISDLSO_B2_2B); rc = 0; };
  if(ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_LD2_ASISDLSO_H2_2H); instr->operation = enc_to_oper(ENC_LD2_ASISDLSO_H2_2H); rc = 0; };
  if(ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_LD2_ASISDLSO_S2_2S); instr->operation = enc_to_oper(ENC_LD2_ASISDLSO_S2_2S); rc = 0; };
  if(ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD2_ASISDLSO_D2_2D); instr->operation = enc_to_oper(ENC_LD2_ASISDLSO_D2_2D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xDE00000) {
  decode_fields32(ENC_LD2_ASISDLSOP_B2_I2B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12233 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12233 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==0) {instr->encoding = (ENC_LD2_ASISDLSOP_B2_I2B); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_B2_I2B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==0) {instr->encoding = (ENC_LD2_ASISDLSOP_BX2_R2B); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_BX2_R2B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_LD2_ASISDLSOP_H2_I2H); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_H2_I2H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_LD2_ASISDLSOP_HX2_R2H); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_HX2_R2H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_LD2_ASISDLSOP_S2_I2S); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_S2_I2S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_LD2_ASISDLSOP_SX2_R2S); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_SX2_R2S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD2_ASISDLSOP_D2_I2D); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_D2_I2D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD2_ASISDLSOP_DX2_R2D); instr->operation = enc_to_oper(ENC_LD2_ASISDLSOP_DX2_R2D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 12248 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 12248 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 12254 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 12254 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD3R_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xD40E000) {
  decode_fields32(ENC_LD3R_ASISDLSO_R3, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12297 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12297 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_LD3R_ASISDLSO_R3); instr->operation = enc_to_oper(ENC_LD3R_ASISDLSO_R3); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xDC0E000) {
  decode_fields32(ENC_LD3R_ASISDLSOP_R3_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12308 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12308 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_LD3R_ASISDLSOP_R3_I); instr->operation = enc_to_oper(ENC_LD3R_ASISDLSOP_R3_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_LD3R_ASISDLSOP_RX3_R); instr->operation = enc_to_oper(ENC_LD3R_ASISDLSOP_RX3_R); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 12317 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 12317 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 12323 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 12323 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD3_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xC404000) {
  decode_fields32(ENC_LD3_ASISDLSE_R3, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12366 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12366 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_LD3_ASISDLSE_R3); instr->operation = enc_to_oper(ENC_LD3_ASISDLSE_R3); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xCC04000) {
  decode_fields32(ENC_LD3_ASISDLSEP_I3_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12377 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12377 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_LD3_ASISDLSEP_I3_I); instr->operation = enc_to_oper(ENC_LD3_ASISDLSEP_I3_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_LD3_ASISDLSEP_R3_R); instr->operation = enc_to_oper(ENC_LD3_ASISDLSEP_R3_R); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int LD3_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD402000) {
  decode_fields32(ENC_LD3_ASISDLSO_B3_3B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12435 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12435 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==1) {instr->encoding = (ENC_LD3_ASISDLSO_B3_3B); instr->operation = enc_to_oper(ENC_LD3_ASISDLSO_B3_3B); rc = 0; };
  if(ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_LD3_ASISDLSO_H3_3H); instr->operation = enc_to_oper(ENC_LD3_ASISDLSO_H3_3H); rc = 0; };
  if(ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_LD3_ASISDLSO_S3_3S); instr->operation = enc_to_oper(ENC_LD3_ASISDLSO_S3_3S); rc = 0; };
  if(ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD3_ASISDLSO_D3_3D); instr->operation = enc_to_oper(ENC_LD3_ASISDLSO_D3_3D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xDC02000) {
  decode_fields32(ENC_LD3_ASISDLSOP_B3_I3B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12449 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12449 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==1) {instr->encoding = (ENC_LD3_ASISDLSOP_B3_I3B); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_B3_I3B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==1) {instr->encoding = (ENC_LD3_ASISDLSOP_BX3_R3B); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_BX3_R3B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_LD3_ASISDLSOP_H3_I3H); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_H3_I3H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_LD3_ASISDLSOP_HX3_R3H); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_HX3_R3H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_LD3_ASISDLSOP_S3_I3S); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_S3_I3S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_LD3_ASISDLSOP_SX3_R3S); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_SX3_R3S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD3_ASISDLSOP_D3_I3D); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_D3_I3D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD3_ASISDLSOP_DX3_R3D); instr->operation = enc_to_oper(ENC_LD3_ASISDLSOP_DX3_R3D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 12464 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 12464 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 12470 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 12470 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD4R_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xD60E000) {
  decode_fields32(ENC_LD4R_ASISDLSO_R4, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_LD4R_ASISDLSO_R4); instr->operation = enc_to_oper(ENC_LD4R_ASISDLSO_R4); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xDE0E000) {
  decode_fields32(ENC_LD4R_ASISDLSOP_R4_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12524 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12524 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_LD4R_ASISDLSOP_R4_I); instr->operation = enc_to_oper(ENC_LD4R_ASISDLSOP_R4_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_LD4R_ASISDLSOP_RX4_R); instr->operation = enc_to_oper(ENC_LD4R_ASISDLSOP_RX4_R); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 12533 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 12533 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 12539 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 12539 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD4_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xC400000) {
  decode_fields32(ENC_LD4_ASISDLSE_R4, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12582 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12582 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_LD4_ASISDLSE_R4); instr->operation = enc_to_oper(ENC_LD4_ASISDLSE_R4); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xCC00000) {
  decode_fields32(ENC_LD4_ASISDLSEP_I4_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12593 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12593 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_LD4_ASISDLSEP_I4_I); instr->operation = enc_to_oper(ENC_LD4_ASISDLSEP_I4_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_LD4_ASISDLSEP_R4_R); instr->operation = enc_to_oper(ENC_LD4_ASISDLSEP_R4_R); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int LD4_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD602000) {
  decode_fields32(ENC_LD4_ASISDLSO_B4_4B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 12651 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12651 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==1) {instr->encoding = (ENC_LD4_ASISDLSO_B4_4B); instr->operation = enc_to_oper(ENC_LD4_ASISDLSO_B4_4B); rc = 0; };
  if(ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_LD4_ASISDLSO_H4_4H); instr->operation = enc_to_oper(ENC_LD4_ASISDLSO_H4_4H); rc = 0; };
  if(ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_LD4_ASISDLSO_S4_4S); instr->operation = enc_to_oper(ENC_LD4_ASISDLSO_S4_4S); rc = 0; };
  if(ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD4_ASISDLSO_D4_4D); instr->operation = enc_to_oper(ENC_LD4_ASISDLSO_D4_4D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xDE02000) {
  decode_fields32(ENC_LD4_ASISDLSOP_B4_I4B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 12665 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 12665 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==1) {instr->encoding = (ENC_LD4_ASISDLSOP_B4_I4B); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_B4_I4B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==1) {instr->encoding = (ENC_LD4_ASISDLSOP_BX4_R4B); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_BX4_R4B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_LD4_ASISDLSOP_H4_I4H); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_H4_I4H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_LD4_ASISDLSOP_HX4_R4H); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_HX4_R4H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_LD4_ASISDLSOP_S4_I4S); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_S4_I4S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_LD4_ASISDLSOP_SX4_R4S); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_SX4_R4S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD4_ASISDLSOP_D4_I4D); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_D4_I4D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_LD4_ASISDLSOP_DX4_R4D); instr->operation = enc_to_oper(ENC_LD4_ASISDLSOP_DX4_R4D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 12680 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 12680 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 12686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 12686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int LD64B(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xF83FD000) {
  decode_fields32(ENC_LD64B_64L_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<13))) {
   { return -4; };
  }
  if((((ctx->Rt)>>(3)) & (((uint64_t)1<<((4)-(3)+1))-1))==3 || (((ctx->Rt)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_LD64B_64L_MEMOP); instr->operation = enc_to_oper(ENC_LD64B_64L_MEMOP); rc = 0; };
 }
 return rc;
}


int LDADD(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8200000) {
  decode_fields32(ENC_LDADD_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STADD_LDADD(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDADD_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADD_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDADDA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDADDAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDADDL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDADD_64_MEMOP); instr->operation = enc_to_oper(ENC_LDADD_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDADDA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDADDA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDADDAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDADDAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDADDL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDADDL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDADDB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38200000) {
  decode_fields32(ENC_LDADDAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STADDB_LDADDB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDADDAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDADDALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDADDB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDADDLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDADDH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78200000) {
  decode_fields32(ENC_LDADDAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STADDH_LDADDH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDADDAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDADDALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDADDH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDADDLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDADDLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDAPR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xB8A0C000) {
  decode_fields32(ENC_LDAPR_32L_MEMOP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = AccType_ORDERED;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->size==2) {instr->encoding = (ENC_LDAPR_32L_MEMOP); instr->operation = enc_to_oper(ENC_LDAPR_32L_MEMOP); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDAPR_64L_MEMOP); instr->operation = enc_to_oper(ENC_LDAPR_64L_MEMOP); rc = 0; };
 }
 return rc;
}


int LDAPRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x38A0C000) {
  decode_fields32(ENC_LDAPRB_32L_MEMOP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = AccType_ORDERED;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_LDAPRB_32L_MEMOP); instr->operation = enc_to_oper(ENC_LDAPRB_32L_MEMOP); rc = 0; };
 }
 return rc;
}


int LDAPRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x78A0C000) {
  decode_fields32(ENC_LDAPRH_32L_MEMOP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = AccType_ORDERED;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_LDAPRH_32L_MEMOP); instr->operation = enc_to_oper(ENC_LDAPRH_32L_MEMOP); rc = 0; };
 }
 return rc;
}


int LDAPURB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x19400000) {
  decode_fields32(ENC_LDAPURB_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 12975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 12975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 12976 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 12976 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDAPURB_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPURB_32_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 12992 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 12992 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 13009 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 13009 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 13014 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13014 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 13015 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13015 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDAPURH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x59400000) {
  decode_fields32(ENC_LDAPURH_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 13037 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 13037 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 13038 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13038 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDAPURH_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPURH_32_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 13054 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 13054 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 13071 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 13071 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 13076 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13076 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 13077 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13077 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDAPURSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x19800000) {
  decode_fields32(ENC_LDAPURSB_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 13099 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 13099 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 13100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDAPURSB_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPURSB_32_LDAPSTL_UNSCALED); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDAPURSB_64_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPURSB_64_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 13117 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 13117 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 13134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 13134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 13139 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13139 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 13140 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13140 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDAPURSH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x59800000) {
  decode_fields32(ENC_LDAPURSH_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 13162 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 13162 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 13163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDAPURSH_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPURSH_32_LDAPSTL_UNSCALED); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDAPURSH_64_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPURSH_64_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 13180 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 13180 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 13197 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 13197 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 13202 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13202 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 13203 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13203 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDAPURSW(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x99800000) {
  decode_fields32(ENC_LDAPURSW_64_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 13225 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 13225 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 13226 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13226 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDAPURSW_64_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPURSW_64_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 13242 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 13242 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 13259 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 13259 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 13264 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13264 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 13265 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13265 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDAPUR_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0x99400000) {
  decode_fields32(ENC_LDAPUR_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 13287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 13287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 13288 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13288 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_LDAPUR_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPUR_32_LDAPSTL_UNSCALED); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDAPUR_64_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_LDAPUR_64_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 13305 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 13305 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 13322 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 13322 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 13327 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13327 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 13328 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 13328 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDAR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88C08000) {
  decode_fields32(ENC_LDAR_LR32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->size==2) {instr->encoding = (ENC_LDAR_LR32_LDSTORD); instr->operation = enc_to_oper(ENC_LDAR_LR32_LDSTORD); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDAR_LR64_LDSTORD); instr->operation = enc_to_oper(ENC_LDAR_LR64_LDSTORD); rc = 0; };
 }
 return rc;
}


int LDARB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8C08000) {
  decode_fields32(ENC_LDARB_LR32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_LDARB_LR32_LDSTORD); instr->operation = enc_to_oper(ENC_LDARB_LR32_LDSTORD); rc = 0; };
 }
 return rc;
}


int LDARH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48C08000) {
  decode_fields32(ENC_LDARH_LR32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_LDARH_LR32_LDSTORD); instr->operation = enc_to_oper(ENC_LDARH_LR32_LDSTORD); rc = 0; };
 }
 return rc;
}


int LDAXP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88608000) {
  decode_fields32(ENC_LDAXP_LP32_LDSTEXCLP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 13425 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 13425 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 13431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 13432 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13432 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->sz==0) {instr->encoding = (ENC_LDAXP_LP32_LDSTEXCLP); instr->operation = enc_to_oper(ENC_LDAXP_LP32_LDSTEXCLP); rc = 0; };
  if(ctx->sz==1) {instr->encoding = (ENC_LDAXP_LP64_LDSTEXCLP); instr->operation = enc_to_oper(ENC_LDAXP_LP64_LDSTEXCLP); rc = 0; };
 }
 return rc;
}


int LDAXR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88408000) {
  decode_fields32(ENC_LDAXR_LR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 13469 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 13469 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 13475 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13475 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 13476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->size==2) {instr->encoding = (ENC_LDAXR_LR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDAXR_LR32_LDSTEXCLR); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDAXR_LR64_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDAXR_LR64_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int LDAXRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8408000) {
  decode_fields32(ENC_LDAXRB_LR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 13513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 13513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 13519 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13519 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 13520 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13520 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_LDAXRB_LR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDAXRB_LR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int LDAXRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48408000) {
  decode_fields32(ENC_LDAXRH_LR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 13556 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 13556 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 13562 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13562 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 13563 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 13563 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_LDAXRH_LR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDAXRH_LR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int LDCLR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8201000) {
  decode_fields32(ENC_LDCLR_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STCLR_LDCLR(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDCLR_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLR_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDCLRA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDCLRAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDCLRL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDCLR_64_MEMOP); instr->operation = enc_to_oper(ENC_LDCLR_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDCLRA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDCLRAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDCLRL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDCLRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38201000) {
  decode_fields32(ENC_LDCLRAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STCLRB_LDCLRB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDCLRAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDCLRALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDCLRB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDCLRLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDCLRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78201000) {
  decode_fields32(ENC_LDCLRAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STCLRH_LDCLRH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDCLRAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDCLRALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDCLRH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDCLRLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDCLRLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDEOR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8202000) {
  decode_fields32(ENC_LDEOR_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STEOR_LDEOR(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDEOR_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEOR_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDEORA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDEORAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDEORL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDEOR_64_MEMOP); instr->operation = enc_to_oper(ENC_LDEOR_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDEORA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDEORA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDEORAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDEORAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDEORL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDEORL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDEORB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38202000) {
  decode_fields32(ENC_LDEORAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STEORB_LDEORB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDEORAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDEORALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDEORB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDEORLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDEORH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78202000) {
  decode_fields32(ENC_LDEORAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STEORH_LDEORH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDEORAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDEORALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDEORH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDEORLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDEORLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xD9600000) {
  decode_fields32(ENC_LDG_64LOFFSET_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  {instr->encoding = (ENC_LDG_64LOFFSET_LDSTTAGS); instr->operation = enc_to_oper(ENC_LDG_64LOFFSET_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int LDGM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xD9E00000) {
  decode_fields32(ENC_LDGM_64BULK_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<20))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->n = (unsigned int)(ctx->Xn);
  {instr->encoding = (ENC_LDGM_64BULK_LDSTTAGS); instr->operation = enc_to_oper(ENC_LDGM_64BULK_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int LDLAR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88C00000) {
  decode_fields32(ENC_LDLAR_LR32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->size==2) {instr->encoding = (ENC_LDLAR_LR32_LDSTORD); instr->operation = enc_to_oper(ENC_LDLAR_LR32_LDSTORD); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDLAR_LR64_LDSTORD); instr->operation = enc_to_oper(ENC_LDLAR_LR64_LDSTORD); rc = 0; };
 }
 return rc;
}


int LDLARB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8C00000) {
  decode_fields32(ENC_LDLARB_LR32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_LDLARB_LR32_LDSTORD); instr->operation = enc_to_oper(ENC_LDLARB_LR32_LDSTORD); rc = 0; };
 }
 return rc;
}


int LDLARH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48C00000) {
  decode_fields32(ENC_LDLARH_LR32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_LDLARH_LR32_LDSTORD); instr->operation = enc_to_oper(ENC_LDLARH_LR32_LDSTORD); rc = 0; };
 }
 return rc;
}


int LDNP_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3FC00000)==0x2C400000) {
  decode_fields32(ENC_LDNP_S_LDSTNAPAIR_OFFS, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDNP_S_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_LDNP_S_LDSTNAPAIR_OFFS); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_LDNP_D_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_LDNP_D_LDSTNAPAIR_OFFS); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDNP_Q_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_LDNP_Q_LDSTNAPAIR_OFFS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_VECSTREAM;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if(ctx->opc==3) {
  { return -4; };
 }
 ctx->scale = 2+(unsigned int)(ctx->opc);
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 14044 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14044 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int LDNP_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FC00000)==0x28400000) {
  decode_fields32(ENC_LDNP_32_LDSTNAPAIR_OFFS, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDNP_32_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_LDNP_32_LDSTNAPAIR_OFFS); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDNP_64_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_LDNP_64_LDSTNAPAIR_OFFS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_STREAM;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
  { return -4; };
 }
 ctx->scale = 2+(unsigned int)((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 14077 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14077 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int LDPSW(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC00000)==0x68C00000) {
  decode_fields32(ENC_LDPSW_64_LDSTPAIR_POST, ctx, instr);
  {instr->encoding = (ENC_LDPSW_64_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_LDPSW_64_LDSTPAIR_POST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x69C00000) {
  decode_fields32(ENC_LDPSW_64_LDSTPAIR_PRE, ctx, instr);
  {instr->encoding = (ENC_LDPSW_64_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_LDPSW_64_LDSTPAIR_PRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x69400000) {
  decode_fields32(ENC_LDPSW_64_LDSTPAIR_OFF, ctx, instr);
  {instr->encoding = (ENC_LDPSW_64_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_LDPSW_64_LDSTPAIR_OFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_NORMAL;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if(((ctx->L<<1)|(((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)))==1 || ctx->opc==3) {
  { return -4; };
 }
 ctx->signed_ = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=0);
 ctx->scale = 2+(unsigned int)((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 14122 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14122 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->wb_unknown = 
# 14123 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14123 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && (ctx->t==ctx->n || ctx->t2==ctx->n) && ctx->n!=0x1f) {
  ctx->c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);


 }
 if(ctx->memop==MemOp_STORE && ctx->wback && (ctx->t==ctx->n || ctx->t2==ctx->n) && ctx->n!=0x1f) {
  ctx->c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);


 }
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int LDP_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3FC00000)==0x2CC00000) {
  decode_fields32(ENC_LDP_S_LDSTPAIR_POST, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDP_S_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_LDP_S_LDSTPAIR_POST); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_LDP_D_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_LDP_D_LDSTPAIR_POST); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDP_Q_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_LDP_Q_LDSTPAIR_POST); rc = 0; };
 }


 if(((ctx->insword) & 0x3FC00000)==0x2DC00000) {
  decode_fields32(ENC_LDP_S_LDSTPAIR_PRE, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDP_S_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_LDP_S_LDSTPAIR_PRE); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_LDP_D_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_LDP_D_LDSTPAIR_PRE); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDP_Q_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_LDP_Q_LDSTPAIR_PRE); rc = 0; };
 }


 if(((ctx->insword) & 0x3FC00000)==0x2D400000) {
  decode_fields32(ENC_LDP_S_LDSTPAIR_OFF, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDP_S_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_LDP_S_LDSTPAIR_OFF); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_LDP_D_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_LDP_D_LDSTPAIR_OFF); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDP_Q_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_LDP_Q_LDSTPAIR_OFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if(ctx->opc==3) {
  { return -4; };
 }
 ctx->scale = 2+(unsigned int)(ctx->opc);
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 14183 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14183 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int LDP_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FC00000)==0x28C00000) {
  decode_fields32(ENC_LDP_32_LDSTPAIR_POST, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDP_32_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_LDP_32_LDSTPAIR_POST); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDP_64_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_LDP_64_LDSTPAIR_POST); rc = 0; };
 }


 if(((ctx->insword) & 0x7FC00000)==0x29C00000) {
  decode_fields32(ENC_LDP_32_LDSTPAIR_PRE, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDP_32_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_LDP_32_LDSTPAIR_PRE); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDP_64_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_LDP_64_LDSTPAIR_PRE); rc = 0; };
 }


 if(((ctx->insword) & 0x7FC00000)==0x29400000) {
  decode_fields32(ENC_LDP_32_LDSTPAIR_OFF, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_LDP_32_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_LDP_32_LDSTPAIR_OFF); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDP_64_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_LDP_64_LDSTPAIR_OFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_NORMAL;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if(((ctx->L<<1)|(((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)))==1 || ctx->opc==3) {
  { return -4; };
 }
 ctx->signed_ = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=0);
 ctx->scale = 2+(unsigned int)((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 14231 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14231 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->wb_unknown = 
# 14232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && (ctx->t==ctx->n || ctx->t2==ctx->n) && ctx->n!=0x1f) {
  ctx->c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);


 }
 if(ctx->memop==MemOp_STORE && ctx->wback && (ctx->t==ctx->n || ctx->t2==ctx->n) && ctx->n!=0x1f) {
  ctx->c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);


 }
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int LDRA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF200400)==0xF8200400) {
  decode_fields32(ENC_LDRAA_64_LDST_PAC, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<23)) || ctx->size!=3) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->wback = (ctx->W==1);
  ctx->use_key_a = (ctx->M==0);
  ctx->S10 = ((ctx->S<<9)|ctx->imm9);
  ctx->scale = 3;
  ctx->offset = ((SignExtend(ctx->S10,10))<<(ctx->scale));
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->M==0 && ctx->W==0) {instr->encoding = (ENC_LDRAA_64_LDST_PAC); instr->operation = enc_to_oper(ENC_LDRAA_64_LDST_PAC); rc = 0; };
  if(ctx->M==0 && ctx->W==1) {instr->encoding = (ENC_LDRAA_64W_LDST_PAC); instr->operation = enc_to_oper(ENC_LDRAA_64W_LDST_PAC); rc = 0; };
  if(ctx->M==1 && ctx->W==0) {instr->encoding = (ENC_LDRAB_64_LDST_PAC); instr->operation = enc_to_oper(ENC_LDRAB_64_LDST_PAC); rc = 0; };
  if(ctx->M==1 && ctx->W==1) {instr->encoding = (ENC_LDRAB_64W_LDST_PAC); instr->operation = enc_to_oper(ENC_LDRAB_64W_LDST_PAC); rc = 0; };
 }
 return rc;
}


int LDRB_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38400400) {
  decode_fields32(ENC_LDRB_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 14286 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14286 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 14287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDRB_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDRB_32_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0x38400C00) {
  decode_fields32(ENC_LDRB_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 14296 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14296 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14297 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14297 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDRB_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDRB_32_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x39400000) {
  decode_fields32(ENC_LDRB_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 14306 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14306 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14307 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14307 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  {instr->encoding = (ENC_LDRB_32_LDST_POS); instr->operation = enc_to_oper(ENC_LDRB_32_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14323 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14323 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14337 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14337 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 14342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14343 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14343 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRB_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38600800) {
  decode_fields32(ENC_LDRB_32B_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 14365 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14365 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14366 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14366 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->option!=3) {instr->encoding = (ENC_LDRB_32B_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRB_32B_LDST_REGOFF); rc = 0; };
  if(ctx->option==3) {instr->encoding = (ENC_LDRB_32BL_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRB_32BL_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14388 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14388 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14405 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14405 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 14410 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14410 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14411 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14411 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRH_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78400400) {
  decode_fields32(ENC_LDRH_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 14433 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14433 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14434 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 14434 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDRH_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDRH_32_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0x78400C00) {
  decode_fields32(ENC_LDRH_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 14443 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14443 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14444 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14444 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDRH_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDRH_32_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x79400000) {
  decode_fields32(ENC_LDRH_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 14453 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14453 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14454 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14454 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  {instr->encoding = (ENC_LDRH_32_LDST_POS); instr->operation = enc_to_oper(ENC_LDRH_32_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14470 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14470 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14484 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14484 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 14489 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14489 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14490 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14490 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRH_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78600800) {
  decode_fields32(ENC_LDRH_32_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 14512 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14512 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  {instr->encoding = (ENC_LDRH_32_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRH_32_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14534 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14534 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14551 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14551 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 14556 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14556 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRSB_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x38800400) {
  decode_fields32(ENC_LDRSB_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 14579 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14579 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14580 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 14580 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDRSB_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDRSB_32_LDST_IMMPOST); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDRSB_64_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDRSB_64_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA00C00)==0x38800C00) {
  decode_fields32(ENC_LDRSB_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 14590 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14590 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14591 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14591 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDRSB_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDRSB_32_LDST_IMMPRE); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDRSB_64_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDRSB_64_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFF800000)==0x39800000) {
  decode_fields32(ENC_LDRSB_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 14601 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14601 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14602 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14602 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  if(ctx->opc==3) {instr->encoding = (ENC_LDRSB_32_LDST_POS); instr->operation = enc_to_oper(ENC_LDRSB_32_LDST_POS); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDRSB_64_LDST_POS); instr->operation = enc_to_oper(ENC_LDRSB_64_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14633 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14633 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 14638 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14638 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14639 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14639 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRSB_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x38A00800) {
  decode_fields32(ENC_LDRSB_32B_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 14661 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14661 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14662 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14662 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->opc==3 && ctx->option!=3) {instr->encoding = (ENC_LDRSB_32B_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRSB_32B_LDST_REGOFF); rc = 0; };
  if(ctx->opc==3 && ctx->option==3) {instr->encoding = (ENC_LDRSB_32BL_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRSB_32BL_LDST_REGOFF); rc = 0; };
  if(ctx->opc==2 && ctx->option!=3) {instr->encoding = (ENC_LDRSB_64B_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRSB_64B_LDST_REGOFF); rc = 0; };
  if(ctx->opc==2 && ctx->option==3) {instr->encoding = (ENC_LDRSB_64BL_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRSB_64BL_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14703 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14703 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 14708 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14708 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14709 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14709 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRSH_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x78800400) {
  decode_fields32(ENC_LDRSH_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 14731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14732 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 14732 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDRSH_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDRSH_32_LDST_IMMPOST); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDRSH_64_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDRSH_64_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA00C00)==0x78800C00) {
  decode_fields32(ENC_LDRSH_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 14742 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14742 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14743 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14743 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDRSH_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDRSH_32_LDST_IMMPRE); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDRSH_64_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDRSH_64_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFF800000)==0x79800000) {
  decode_fields32(ENC_LDRSH_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 14753 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14753 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14754 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14754 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  if(ctx->opc==3) {instr->encoding = (ENC_LDRSH_32_LDST_POS); instr->operation = enc_to_oper(ENC_LDRSH_32_LDST_POS); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDRSH_64_LDST_POS); instr->operation = enc_to_oper(ENC_LDRSH_64_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14771 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14771 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14785 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14785 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 14790 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14790 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14791 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14791 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRSH_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x78A00800) {
  decode_fields32(ENC_LDRSH_32_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 14813 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14813 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14814 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14814 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->opc==3) {instr->encoding = (ENC_LDRSH_32_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRSH_32_LDST_REGOFF); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDRSH_64_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRSH_64_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14853 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14853 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 14858 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14858 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14859 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14859 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRSW_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xB8800400) {
  decode_fields32(ENC_LDRSW_64_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 14881 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14881 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 14882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDRSW_64_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDRSW_64_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xB8800C00) {
  decode_fields32(ENC_LDRSW_64_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 14891 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 14891 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 14892 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14892 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDRSW_64_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDRSW_64_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0xB9800000) {
  decode_fields32(ENC_LDRSW_64_LDST_POS, ctx, instr);
  ctx->wback = 
# 14901 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14901 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14902 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14902 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  {instr->encoding = (ENC_LDRSW_64_LDST_POS); instr->operation = enc_to_oper(ENC_LDRSW_64_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 14918 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14918 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 14932 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14932 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 14937 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14937 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 14938 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14938 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDRSW_lit(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF000000)==0x98000000) {
  decode_fields32(ENC_LDRSW_64_LOADLIT, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->memop = MemOp_LOAD;
  ctx->signed_ = 
# 14962 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 14962 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  if(!ctx->opc) {
   ctx->size = 4;
  }
  else if(ctx->opc==1) {
   ctx->size = 8;
  }
  else if(ctx->opc==2) {
   ctx->size = 4;
   ctx->signed_ = 
# 14971 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 14971 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==3) {
   ctx->memop = MemOp_PREFETCH;
  }
  ctx->offset = SignExtend((ctx->imm19<<2),21);
  ctx->tag_checked = 
# 14977 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                    0
# 14977 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  {instr->encoding = (ENC_LDRSW_64_LOADLIT); instr->operation = enc_to_oper(ENC_LDRSW_64_LOADLIT); rc = 0; };
 }
 return rc;
}


int LDRSW_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xB8A00800) {
  decode_fields32(ENC_LDRSW_64_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 14991 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 14991 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 14992 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 14992 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  {instr->encoding = (ENC_LDRSW_64_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDRSW_64_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 15013 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 15013 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 15030 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 15030 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 15035 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15035 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 15036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDR_imm_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3F600C00)==0x3C400400) {
  decode_fields32(ENC_LDR_B_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 15058 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 15058 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 15059 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 15059 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==0 && ctx->opc==1) {instr->encoding = (ENC_LDR_B_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDR_B_LDST_IMMPOST); rc = 0; };
  if(ctx->size==1 && ctx->opc==1) {instr->encoding = (ENC_LDR_H_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDR_H_LDST_IMMPOST); rc = 0; };
  if(ctx->size==2 && ctx->opc==1) {instr->encoding = (ENC_LDR_S_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDR_S_LDST_IMMPOST); rc = 0; };
  if(ctx->size==3 && ctx->opc==1) {instr->encoding = (ENC_LDR_D_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDR_D_LDST_IMMPOST); rc = 0; };
  if(ctx->size==0 && ctx->opc==3) {instr->encoding = (ENC_LDR_Q_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDR_Q_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0x3F600C00)==0x3C400C00) {
  decode_fields32(ENC_LDR_B_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 15075 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 15075 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 15076 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15076 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==0 && ctx->opc==1) {instr->encoding = (ENC_LDR_B_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDR_B_LDST_IMMPRE); rc = 0; };
  if(ctx->size==1 && ctx->opc==1) {instr->encoding = (ENC_LDR_H_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDR_H_LDST_IMMPRE); rc = 0; };
  if(ctx->size==2 && ctx->opc==1) {instr->encoding = (ENC_LDR_S_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDR_S_LDST_IMMPRE); rc = 0; };
  if(ctx->size==3 && ctx->opc==1) {instr->encoding = (ENC_LDR_D_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDR_D_LDST_IMMPRE); rc = 0; };
  if(ctx->size==0 && ctx->opc==3) {instr->encoding = (ENC_LDR_Q_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDR_Q_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0x3F400000)==0x3D400000) {
  decode_fields32(ENC_LDR_B_LDST_POS, ctx, instr);
  ctx->wback = 
# 15092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 15092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 15093 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15093 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  if(ctx->size==0 && ctx->opc==1) {instr->encoding = (ENC_LDR_B_LDST_POS); instr->operation = enc_to_oper(ENC_LDR_B_LDST_POS); rc = 0; };
  if(ctx->size==1 && ctx->opc==1) {instr->encoding = (ENC_LDR_H_LDST_POS); instr->operation = enc_to_oper(ENC_LDR_H_LDST_POS); rc = 0; };
  if(ctx->size==2 && ctx->opc==1) {instr->encoding = (ENC_LDR_S_LDST_POS); instr->operation = enc_to_oper(ENC_LDR_S_LDST_POS); rc = 0; };
  if(ctx->size==3 && ctx->opc==1) {instr->encoding = (ENC_LDR_D_LDST_POS); instr->operation = enc_to_oper(ENC_LDR_D_LDST_POS); rc = 0; };
  if(ctx->size==0 && ctx->opc==3) {instr->encoding = (ENC_LDR_Q_LDST_POS); instr->operation = enc_to_oper(ENC_LDR_Q_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 return rc;
}


int LDR_imm_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8400400) {
  decode_fields32(ENC_LDR_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 15123 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 15123 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 15124 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 15124 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_LDR_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDR_32_LDST_IMMPOST); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDR_64_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_LDR_64_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE00C00)==0xB8400C00) {
  decode_fields32(ENC_LDR_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 15134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 15134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 15135 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15135 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_LDR_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDR_32_LDST_IMMPRE); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDR_64_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_LDR_64_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC00000)==0xB9400000) {
  decode_fields32(ENC_LDR_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 15145 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 15145 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 15146 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15146 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  if(ctx->size==2) {instr->encoding = (ENC_LDR_32_LDST_POS); instr->operation = enc_to_oper(ENC_LDR_32_LDST_POS); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDR_64_LDST_POS); instr->operation = enc_to_oper(ENC_LDR_64_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 15163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 15163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 15177 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 15177 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 15182 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15182 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 15183 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15183 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDR_lit_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3F000000)==0x1C000000) {
  decode_fields32(ENC_LDR_S_LOADLIT, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  if(!ctx->opc) {
   ctx->size = 4;
  }
  else if(ctx->opc==1) {
   ctx->size = 8;
  }
  else if(ctx->opc==2) {
   ctx->size = 0x10;
  }
  else if(ctx->opc==3) {
   { return -4; };
  }
  ctx->offset = SignExtend((ctx->imm19<<2),21);
  ctx->tag_checked = 
# 15219 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                    0
# 15219 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  if(ctx->opc==0) {instr->encoding = (ENC_LDR_S_LOADLIT); instr->operation = enc_to_oper(ENC_LDR_S_LOADLIT); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_LDR_D_LOADLIT); instr->operation = enc_to_oper(ENC_LDR_D_LOADLIT); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDR_Q_LOADLIT); instr->operation = enc_to_oper(ENC_LDR_Q_LOADLIT); rc = 0; };
 }
 return rc;
}


int LDR_lit_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF000000)==0x18000000) {
  decode_fields32(ENC_LDR_32_LOADLIT, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->memop = MemOp_LOAD;
  ctx->signed_ = 
# 15237 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 15237 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  if(!ctx->opc) {
   ctx->size = 4;
  }
  else if(ctx->opc==1) {
   ctx->size = 8;
  }
  else if(ctx->opc==2) {
   ctx->size = 4;
   ctx->signed_ = 
# 15246 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 15246 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==3) {
   ctx->memop = MemOp_PREFETCH;
  }
  ctx->offset = SignExtend((ctx->imm19<<2),21);
  ctx->tag_checked = 
# 15252 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                    0
# 15252 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  if(ctx->opc==0) {instr->encoding = (ENC_LDR_32_LOADLIT); instr->operation = enc_to_oper(ENC_LDR_32_LOADLIT); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_LDR_64_LOADLIT); instr->operation = enc_to_oper(ENC_LDR_64_LOADLIT); rc = 0; };
 }
 return rc;
}


int LDR_reg_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3F600C00)==0x3C600800) {
  decode_fields32(ENC_LDR_B_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 15267 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 15267 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 15268 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15268 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->size==0 && ctx->opc==1 && ctx->option!=3) {instr->encoding = (ENC_LDR_B_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_B_LDST_REGOFF); rc = 0; };
  if(ctx->size==0 && ctx->opc==1 && ctx->option==3) {instr->encoding = (ENC_LDR_BL_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_BL_LDST_REGOFF); rc = 0; };
  if(ctx->size==1 && ctx->opc==1) {instr->encoding = (ENC_LDR_H_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_H_LDST_REGOFF); rc = 0; };
  if(ctx->size==2 && ctx->opc==1) {instr->encoding = (ENC_LDR_S_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_S_LDST_REGOFF); rc = 0; };
  if(ctx->size==3 && ctx->opc==1) {instr->encoding = (ENC_LDR_D_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_D_LDST_REGOFF); rc = 0; };
  if(ctx->size==0 && ctx->opc==3) {instr->encoding = (ENC_LDR_Q_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_Q_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 return rc;
}


int LDR_reg_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8600800) {
  decode_fields32(ENC_LDR_32_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 15304 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 15304 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 15305 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15305 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->size==2) {instr->encoding = (ENC_LDR_32_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_32_LDST_REGOFF); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDR_64_LDST_REGOFF); instr->operation = enc_to_oper(ENC_LDR_64_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 15327 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 15327 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 15344 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 15344 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 15349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 15350 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15350 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDSET(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8203000) {
  decode_fields32(ENC_LDSET_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSET_LDSET(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSET_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSET_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSETA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSETAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSETL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSET_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSET_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSETA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSETA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSETAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSETAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSETL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSETL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSETB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38203000) {
  decode_fields32(ENC_LDSETAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSETB_LDSETB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSETAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSETALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSETB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSETLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSETH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78203000) {
  decode_fields32(ENC_LDSETAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSETH_LDSETH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSETAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSETALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSETH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSETLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSETLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSMAX(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8204000) {
  decode_fields32(ENC_LDSMAX_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSMAX_LDSMAX(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMAX_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAX_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMAXA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMAXAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMAXL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMAX_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAX_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMAXA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMAXAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMAXL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSMAXB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38204000) {
  decode_fields32(ENC_LDSMAXAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSMAXB_LDSMAXB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMAXAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMAXALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMAXB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMAXLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSMAXH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78204000) {
  decode_fields32(ENC_LDSMAXAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSMAXH_LDSMAXH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMAXAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMAXALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMAXH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMAXLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMAXLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSMIN(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8205000) {
  decode_fields32(ENC_LDSMIN_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSMIN_LDSMIN(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMIN_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMIN_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMINA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMINAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMINL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMIN_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMIN_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMINA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMINAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMINL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSMINB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38205000) {
  decode_fields32(ENC_LDSMINAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSMINB_LDSMINB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMINAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMINALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMINB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMINLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDSMINH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78205000) {
  decode_fields32(ENC_LDSMINAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STSMINH_LDSMINH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDSMINAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDSMINALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDSMINH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDSMINLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDSMINLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDTR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8400800) {
  decode_fields32(ENC_LDTR_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 15861 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 15861 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 15862 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15862 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_LDTR_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTR_32_LDST_UNPRIV); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDTR_64_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTR_64_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 15887 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 15887 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 15901 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 15901 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 15906 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15906 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 15907 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15907 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDTRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38400800) {
  decode_fields32(ENC_LDTRB_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 15929 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 15929 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 15930 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15930 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDTRB_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTRB_32_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 15954 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 15954 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 15968 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 15968 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 15973 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15973 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 15974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDTRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78400800) {
  decode_fields32(ENC_LDTRH_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 15996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 15996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 15997 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 15997 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDTRH_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTRH_32_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16021 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16021 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16035 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16035 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16040 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16040 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16041 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16041 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDTRSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x38800800) {
  decode_fields32(ENC_LDTRSB_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 16063 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16063 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16064 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16064 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDTRSB_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTRSB_32_LDST_UNPRIV); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDTRSB_64_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTRSB_64_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16089 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16089 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16103 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16103 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16108 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16108 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16109 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16109 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDTRSH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x78800800) {
  decode_fields32(ENC_LDTRSH_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 16131 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16131 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16132 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16132 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDTRSH_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTRSH_32_LDST_UNPRIV); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDTRSH_64_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTRSH_64_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16157 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16157 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16171 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16171 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16176 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16176 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16177 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16177 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDTRSW(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xB8800800) {
  decode_fields32(ENC_LDTRSW_64_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 16199 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16199 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16200 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16200 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDTRSW_64_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_LDTRSW_64_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16224 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16224 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16238 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16238 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16244 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16244 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDUMAX(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8206000) {
  decode_fields32(ENC_LDUMAX_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STUMAX_LDUMAX(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMAX_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAX_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMAXA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMAXAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMAXL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMAX_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAX_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMAXA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMAXAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMAXL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDUMAXB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38206000) {
  decode_fields32(ENC_LDUMAXAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STUMAXB_LDUMAXB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMAXAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMAXALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMAXB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMAXLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDUMAXH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78206000) {
  decode_fields32(ENC_LDUMAXAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STUMAXH_LDUMAXH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMAXAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMAXALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMAXH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMAXLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMAXLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDUMIN(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8207000) {
  decode_fields32(ENC_LDUMIN_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STUMIN_LDUMIN(ctx, instr);
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMIN_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMIN_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMINA_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMINAL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMINL_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMIN_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMIN_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMINA_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMINAL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMINL_64_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int LDUMINB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38207000) {
  decode_fields32(ENC_LDUMINAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STUMINB_LDUMINB(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMINAB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMINALB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMINB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMINLB_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDUMINH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78207000) {
  decode_fields32(ENC_LDUMINAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  if(!ctx->opc) {
   ctx->op = MemAtomicOp_ADD;
  }
  else if(ctx->opc==1) {
   ctx->op = MemAtomicOp_BIC;
  }
  else if(ctx->opc==2) {
   ctx->op = MemAtomicOp_EOR;
  }
  else if(ctx->opc==3) {
   ctx->op = MemAtomicOp_ORR;
  }
  else if(ctx->opc==4) {
   ctx->op = MemAtomicOp_SMAX;
  }
  else if(ctx->opc==5) {
   ctx->op = MemAtomicOp_SMIN;
  }
  else if(ctx->opc==6) {
   ctx->op = MemAtomicOp_UMAX;
  }
  else if(ctx->opc==7) {
   ctx->op = MemAtomicOp_UMIN;
  }
  ctx->tag_checked = ctx->n!=0x1f;

  if(ctx->A==0 && ctx->Rt==0x1f) return STUMINH_LDUMINH(ctx, instr);
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_LDUMINAH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_LDUMINALH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_LDUMINH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_LDUMINLH_32_MEMOP); instr->operation = enc_to_oper(ENC_LDUMINLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int LDURB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38400000) {
  decode_fields32(ENC_LDURB_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 16592 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16592 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16593 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16593 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDURB_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDURB_32_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16609 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16609 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16626 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16626 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16631 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16631 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16632 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16632 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDURH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78400000) {
  decode_fields32(ENC_LDURH_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 16654 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16654 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16655 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16655 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDURH_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDURH_32_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16671 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16671 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16693 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16693 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16694 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16694 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDURSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x38800000) {
  decode_fields32(ENC_LDURSB_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 16716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16717 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16717 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDURSB_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDURSB_32_LDST_UNSCALED); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDURSB_64_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDURSB_64_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16734 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16734 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16756 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16756 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16757 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16757 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDURSH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA00C00)==0x78800000) {
  decode_fields32(ENC_LDURSH_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 16779 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16779 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16780 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16780 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->opc==3) {instr->encoding = (ENC_LDURSH_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDURSH_32_LDST_UNSCALED); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_LDURSH_64_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDURSH_64_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16814 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16814 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16820 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16820 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDURSW(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xB8800000) {
  decode_fields32(ENC_LDURSW_64_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 16842 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16842 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16843 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16843 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_LDURSW_64_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDURSW_64_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16859 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16859 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16881 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16881 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDUR_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3F600C00)==0x3C400000) {
  decode_fields32(ENC_LDUR_B_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 16904 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16904 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16905 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16905 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==0 && ctx->opc==1) {instr->encoding = (ENC_LDUR_B_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDUR_B_LDST_UNSCALED); rc = 0; };
  if(ctx->size==1 && ctx->opc==1) {instr->encoding = (ENC_LDUR_H_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDUR_H_LDST_UNSCALED); rc = 0; };
  if(ctx->size==2 && ctx->opc==1) {instr->encoding = (ENC_LDUR_S_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDUR_S_LDST_UNSCALED); rc = 0; };
  if(ctx->size==3 && ctx->opc==1) {instr->encoding = (ENC_LDUR_D_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDUR_D_LDST_UNSCALED); rc = 0; };
  if(ctx->size==0 && ctx->opc==3) {instr->encoding = (ENC_LDUR_Q_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDUR_Q_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 return rc;
}


int LDUR_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8400000) {
  decode_fields32(ENC_LDUR_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 16935 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 16935 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 16936 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16936 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_LDUR_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDUR_32_LDST_UNSCALED); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDUR_64_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_LDUR_64_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 16953 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 16953 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 16970 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 16970 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 16975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 16976 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 16976 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int LDXP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88600000) {
  decode_fields32(ENC_LDXP_LP32_LDSTEXCLP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 17003 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 17003 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 17009 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17009 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 17010 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17010 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->sz==0) {instr->encoding = (ENC_LDXP_LP32_LDSTEXCLP); instr->operation = enc_to_oper(ENC_LDXP_LP32_LDSTEXCLP); rc = 0; };
  if(ctx->sz==1) {instr->encoding = (ENC_LDXP_LP64_LDSTEXCLP); instr->operation = enc_to_oper(ENC_LDXP_LP64_LDSTEXCLP); rc = 0; };
 }
 return rc;
}


int LDXR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88400000) {
  decode_fields32(ENC_LDXR_LR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 17047 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 17047 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 17053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 17054 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17054 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->size==2) {instr->encoding = (ENC_LDXR_LR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDXR_LR32_LDSTEXCLR); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_LDXR_LR64_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDXR_LR64_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int LDXRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8400000) {
  decode_fields32(ENC_LDXRB_LR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 17091 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 17091 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 17097 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17097 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 17098 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17098 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_LDXRB_LR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDXRB_LR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int LDXRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48400000) {
  decode_fields32(ENC_LDXRH_LR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 17134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 17134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 17140 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17140 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 17141 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 17141 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_LDXRH_LR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_LDXRH_LR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int LSLV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02000) {
  decode_fields32(ENC_LSLV_32_DP_2SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->shift_type = DecodeShift(ctx->op2);

  if(LSL_LSLV(ctx, instr)==0) return 0;
  if(ctx->sf==0) {instr->encoding = (ENC_LSLV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_LSLV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_LSLV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_LSLV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int LSL_LSLV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02000) {
  decode_fields32(ENC_LSL_LSLV_32_DP_2SRC, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_LSL_LSLV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_LSL_LSLV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_LSL_LSLV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_LSL_LSLV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int LSL_UBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x53000000) {
  decode_fields32(ENC_LSL_UBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0 && ctx->imms!=0x1f) {instr->encoding = (ENC_LSL_UBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_LSL_UBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1 && ctx->imms!=0x3f) {instr->encoding = (ENC_LSL_UBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_LSL_UBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int LSRV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02400) {
  decode_fields32(ENC_LSRV_32_DP_2SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->shift_type = DecodeShift(ctx->op2);

  if(LSR_LSRV(ctx, instr)==0) return 0;
  if(ctx->sf==0) {instr->encoding = (ENC_LSRV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_LSRV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_LSRV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_LSRV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int LSR_LSRV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02400) {
  decode_fields32(ENC_LSR_LSRV_32_DP_2SRC, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_LSR_LSRV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_LSR_LSRV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_LSR_LSRV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_LSR_LSRV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int LSR_UBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F807C00)==0x53007C00) {
  decode_fields32(ENC_LSR_UBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0 && ctx->imms==0x1f) {instr->encoding = (ENC_LSR_UBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_LSR_UBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1 && ctx->imms==0x3f) {instr->encoding = (ENC_LSR_UBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_LSR_UBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int MADD(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE08000)==0x1B000000) {
  decode_fields32(ENC_MADD_32A_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->datasize = ctx->destsize;
  ctx->sub_op = (ctx->o0==1);

  if(ctx->Ra==0x1f) return MUL_MADD(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_MADD_32A_DP_3SRC); instr->operation = enc_to_oper(ENC_MADD_32A_DP_3SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MADD_64A_DP_3SRC); instr->operation = enc_to_oper(ENC_MADD_64A_DP_3SRC); rc = 0; };
 }
 return rc;
}


int MLA_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0x2F000000) {
  decode_fields32(ENC_MLA_ASIMDELEM_R, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_MLA_ASIMDELEM_R); instr->operation = enc_to_oper(ENC_MLA_ASIMDELEM_R); rc = 0; };
 }
 return rc;
}


int MLA_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE209400) {
  decode_fields32(ENC_MLA_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->U==1);
  {instr->encoding = (ENC_MLA_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_MLA_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int MLS_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0x2F004000) {
  decode_fields32(ENC_MLS_ASIMDELEM_R, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_MLS_ASIMDELEM_R); instr->operation = enc_to_oper(ENC_MLS_ASIMDELEM_R); rc = 0; };
 }
 return rc;
}


int MLS_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E209400) {
  decode_fields32(ENC_MLS_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->U==1);
  {instr->encoding = (ENC_MLS_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_MLS_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int MNEG_MSUB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1B00FC00) {
  decode_fields32(ENC_MNEG_MSUB_32A_DP_3SRC, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_MNEG_MSUB_32A_DP_3SRC); instr->operation = enc_to_oper(ENC_MNEG_MSUB_32A_DP_3SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MNEG_MSUB_64A_DP_3SRC); instr->operation = enc_to_oper(ENC_MNEG_MSUB_64A_DP_3SRC); rc = 0; };
 }
 return rc;
}


int MOVI_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x9FF80C00)==0xF000400) {
  decode_fields32(ENC_MOVI_ASIMDIMM_N_B, ctx, instr);
  ctx->rd = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  if(!(((ctx->cmode<<1)|ctx->op)&0x13)) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==1) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==2) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==3) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x10) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x11) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x12) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x13) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x18) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x19) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1e)==0x1c) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1e) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1f) {
   if(ctx->Q==0) {
    { return -4; };
   }
   ctx->operation_ = ImmediateOp_MOVI;
  }
  ctx->imm64 = AdvSIMDExpandImm(ctx->op,ctx->cmode,((ctx->a<<7)|(ctx->b<<6)|(ctx->c<<5)|(ctx->d<<4)|(ctx->e<<3)|(ctx->f<<2)|(ctx->g<<1)|ctx->h));
  ctx->imm = Replicate(ctx->imm64, ((0x40) ? ((ctx->datasize) / (0x40)) : 0), 64);
  if(ctx->op==0 && ctx->cmode==14) {instr->encoding = (ENC_MOVI_ASIMDIMM_N_B); instr->operation = enc_to_oper(ENC_MOVI_ASIMDIMM_N_B); rc = 0; };
  if(ctx->op==0 && (ctx->cmode&13)==8) {instr->encoding = (ENC_MOVI_ASIMDIMM_L_HL); instr->operation = enc_to_oper(ENC_MOVI_ASIMDIMM_L_HL); rc = 0; };
  if(ctx->op==0 && !(ctx->cmode&9)) {instr->encoding = (ENC_MOVI_ASIMDIMM_L_SL); instr->operation = enc_to_oper(ENC_MOVI_ASIMDIMM_L_SL); rc = 0; };
  if(ctx->op==0 && (ctx->cmode&14)==12) {instr->encoding = (ENC_MOVI_ASIMDIMM_M_SM); instr->operation = enc_to_oper(ENC_MOVI_ASIMDIMM_M_SM); rc = 0; };
  if(ctx->Q==0 && ctx->op==1 && ctx->cmode==14) {instr->encoding = (ENC_MOVI_ASIMDIMM_D_DS); instr->operation = enc_to_oper(ENC_MOVI_ASIMDIMM_D_DS); rc = 0; };
  if(ctx->Q==1 && ctx->op==1 && ctx->cmode==14) {instr->encoding = (ENC_MOVI_ASIMDIMM_D2_D); instr->operation = enc_to_oper(ENC_MOVI_ASIMDIMM_D2_D); rc = 0; };
 }
 return rc;
}


int MOVK(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x72800000) {
  decode_fields32(ENC_MOVK_32_MOVEWIDE, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->imm = ctx->imm16;
  if(!ctx->opc) {
   ctx->opcode = MoveWideOp_N;
  }
  else if(ctx->opc==2) {
   ctx->opcode = MoveWideOp_Z;
  }
  else if(ctx->opc==3) {
   ctx->opcode = MoveWideOp_K;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->hw)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  ctx->pos = (unsigned int)((ctx->hw<<4));
  if(ctx->sf==0 && !(ctx->hw&2)) {instr->encoding = (ENC_MOVK_32_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOVK_32_MOVEWIDE); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOVK_64_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOVK_64_MOVEWIDE); rc = 0; };
 }
 return rc;
}


int MOVN(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x12800000) {
  decode_fields32(ENC_MOVN_32_MOVEWIDE, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->imm = ctx->imm16;
  if(!ctx->opc) {
   ctx->opcode = MoveWideOp_N;
  }
  else if(ctx->opc==2) {
   ctx->opcode = MoveWideOp_Z;
  }
  else if(ctx->opc==3) {
   ctx->opcode = MoveWideOp_K;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->hw)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  ctx->pos = (unsigned int)((ctx->hw<<4));

  
# 17534 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
 _Bool 
# 17534 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
      encoding32 = ctx->sf==0 && !(ctx->hw&2);
  
# 17535 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
 _Bool 
# 17535 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
      encoding64 = ctx->sf==1;
  if((!(IsZero(ctx->imm16) && ctx->hw!=0) && (encoding64)) || (!(IsZero(ctx->imm16) && ctx->hw!=0) && !IsOnes(ctx->imm16,16) && (encoding32))) return MOV_MOVN(ctx, instr);
  if(ctx->sf==0 && !(ctx->hw&2)) {instr->encoding = (ENC_MOVN_32_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOVN_32_MOVEWIDE); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOVN_64_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOVN_64_MOVEWIDE); rc = 0; };
 }
 return rc;
}


int MOVS_and_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25404000) {
  decode_fields32(ENC_MOVS_ANDS_P_P_PP_Z, ctx, instr);
  {instr->encoding = (ENC_MOVS_ANDS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_MOVS_ANDS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int MOVS_orr_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25C04000) {
  decode_fields32(ENC_MOVS_ORRS_P_P_PP_Z, ctx, instr);
  {instr->encoding = (ENC_MOVS_ORRS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_MOVS_ORRS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int MOVZ(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x52800000) {
  decode_fields32(ENC_MOVZ_32_MOVEWIDE, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->imm = ctx->imm16;
  if(!ctx->opc) {
   ctx->opcode = MoveWideOp_N;
  }
  else if(ctx->opc==2) {
   ctx->opcode = MoveWideOp_Z;
  }
  else if(ctx->opc==3) {
   ctx->opcode = MoveWideOp_K;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->hw)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  ctx->pos = (unsigned int)((ctx->hw<<4));

  if(!(IsZero(ctx->imm16) && ctx->hw!=0)) return MOV_MOVZ(ctx, instr);
  if(ctx->sf==0 && !(ctx->hw&2)) {instr->encoding = (ENC_MOVZ_32_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOVZ_32_MOVEWIDE); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOVZ_64_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOVZ_64_MOVEWIDE); rc = 0; };
 }
 return rc;
}


int MOV_ADD_addsub_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFFFC00)==0x11000000) {
  decode_fields32(ENC_MOV_ADD_32_ADDSUB_IMM, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_MOV_ADD_32_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_MOV_ADD_32_ADDSUB_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOV_ADD_64_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_MOV_ADD_64_ADDSUB_IMM); rc = 0; };
 }
 return rc;
}


int MOV_DUP_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E000400) {
  decode_fields32(ENC_MOV_DUP_ASISDONE_ONLY, ctx, instr);
  {instr->encoding = (ENC_MOV_DUP_ASISDONE_ONLY); instr->operation = enc_to_oper(ENC_MOV_DUP_ASISDONE_ONLY); rc = 0; };
 }
 return rc;
}


int MOV_INS_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08400)==0x6E000400) {
  decode_fields32(ENC_MOV_INS_ASIMDINS_IV_V, ctx, instr);
  {instr->encoding = (ENC_MOV_INS_ASIMDINS_IV_V); instr->operation = enc_to_oper(ENC_MOV_INS_ASIMDINS_IV_V); rc = 0; };
 }
 return rc;
}


int MOV_INS_advsimd_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4E001C00) {
  decode_fields32(ENC_MOV_INS_ASIMDINS_IR_R, ctx, instr);
  {instr->encoding = (ENC_MOV_INS_ASIMDINS_IR_R); instr->operation = enc_to_oper(ENC_MOV_INS_ASIMDINS_IR_R); rc = 0; };
 }
 return rc;
}


int MOV_MOVN(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x12800000) {
  decode_fields32(ENC_MOV_MOVN_32_MOVEWIDE, ctx, instr);
  if(ctx->sf==0 && !(ctx->hw&2)) {instr->encoding = (ENC_MOV_MOVN_32_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOV_MOVN_32_MOVEWIDE); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOV_MOVN_64_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOV_MOVN_64_MOVEWIDE); rc = 0; };
 }
 return rc;
}


int MOV_MOVZ(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x52800000) {
  decode_fields32(ENC_MOV_MOVZ_32_MOVEWIDE, ctx, instr);
  if(ctx->sf==0 && !(ctx->hw&2)) {instr->encoding = (ENC_MOV_MOVZ_32_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOV_MOVZ_32_MOVEWIDE); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOV_MOVZ_64_MOVEWIDE); instr->operation = enc_to_oper(ENC_MOV_MOVZ_64_MOVEWIDE); rc = 0; };
 }
 return rc;
}


int MOV_ORR_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEA01C00) {
  decode_fields32(ENC_MOV_ORR_ASIMDSAME_ONLY, ctx, instr);
  {instr->encoding = (ENC_MOV_ORR_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_MOV_ORR_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int MOV_ORR_log_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F8003E0)==0x320003E0) {
  decode_fields32(ENC_MOV_ORR_32_LOG_IMM, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_MOV_ORR_32_LOG_IMM); instr->operation = enc_to_oper(ENC_MOV_ORR_32_LOG_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOV_ORR_64_LOG_IMM); instr->operation = enc_to_oper(ENC_MOV_ORR_64_LOG_IMM); rc = 0; };
 }
 return rc;
}


int MOV_ORR_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FFE0)==0x2A0003E0) {
  decode_fields32(ENC_MOV_ORR_32_LOG_SHIFT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_MOV_ORR_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_MOV_ORR_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MOV_ORR_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_MOV_ORR_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int MOV_UMOV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE3FC00)==0xE003C00) {
  decode_fields32(ENC_MOV_UMOV_ASIMDINS_W_W, ctx, instr);
  if(ctx->Q==0 && (ctx->imm5&7)==4) {instr->encoding = (ENC_MOV_UMOV_ASIMDINS_W_W); instr->operation = enc_to_oper(ENC_MOV_UMOV_ASIMDINS_W_W); rc = 0; };
  if(ctx->Q==1 && (ctx->imm5&15)==8) {instr->encoding = (ENC_MOV_UMOV_ASIMDINS_X_X); instr->operation = enc_to_oper(ENC_MOV_UMOV_ASIMDINS_X_X); rc = 0; };
 }
 return rc;
}


int MOV_and_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25004000) {
  decode_fields32(ENC_MOV_AND_P_P_PP_Z, ctx, instr);
  {instr->encoding = (ENC_MOV_AND_P_P_PP_Z); instr->operation = enc_to_oper(ENC_MOV_AND_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int MOV_cpy_z_o_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30C000)==0x5100000) {
  decode_fields32(ENC_MOV_CPY_Z_O_I_, ctx, instr);
  {instr->encoding = (ENC_MOV_CPY_Z_O_I_); instr->operation = enc_to_oper(ENC_MOV_CPY_Z_O_I_); rc = 0; };
 }
 return rc;
}


int MOV_cpy_z_p_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30C000)==0x5104000) {
  decode_fields32(ENC_MOV_CPY_Z_P_I_, ctx, instr);
  {instr->encoding = (ENC_MOV_CPY_Z_P_I_); instr->operation = enc_to_oper(ENC_MOV_CPY_Z_P_I_); rc = 0; };
 }
 return rc;
}


int MOV_cpy_z_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x528A000) {
  decode_fields32(ENC_MOV_CPY_Z_P_R_, ctx, instr);
  {instr->encoding = (ENC_MOV_CPY_Z_P_R_); instr->operation = enc_to_oper(ENC_MOV_CPY_Z_P_R_); rc = 0; };
 }
 return rc;
}


int MOV_cpy_z_p_v(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5208000) {
  decode_fields32(ENC_MOV_CPY_Z_P_V_, ctx, instr);
  {instr->encoding = (ENC_MOV_CPY_Z_P_V_); instr->operation = enc_to_oper(ENC_MOV_CPY_Z_P_V_); rc = 0; };
 }
 return rc;
}


int MOV_dup_z_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2538C000) {
  decode_fields32(ENC_MOV_DUP_Z_I_, ctx, instr);
  {instr->encoding = (ENC_MOV_DUP_Z_I_); instr->operation = enc_to_oper(ENC_MOV_DUP_Z_I_); rc = 0; };
 }
 return rc;
}


int MOV_dup_z_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5203800) {
  decode_fields32(ENC_MOV_DUP_Z_R_, ctx, instr);
  {instr->encoding = (ENC_MOV_DUP_Z_R_); instr->operation = enc_to_oper(ENC_MOV_DUP_Z_R_); rc = 0; };
 }
 return rc;
}


int MOV_dup_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5202000) {
  decode_fields32(ENC_MOV_DUP_Z_ZI_, ctx, instr);
  if(BitCount(((ctx->imm2<<5)|ctx->tsz))==1) {instr->encoding = (ENC_MOV_DUP_Z_ZI_); instr->operation = enc_to_oper(ENC_MOV_DUP_Z_ZI_); rc = 0; };
  if(BitCount(((ctx->imm2<<5)|ctx->tsz))>1) {instr->encoding = (ENC_MOV_DUP_Z_ZI_2); instr->operation = enc_to_oper(ENC_MOV_DUP_Z_ZI_2); rc = 0; };
 }
 return rc;
}


int MOV_dupm_z_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5C00000) {
  decode_fields32(ENC_MOV_DUPM_Z_I_, ctx, instr);
  {instr->encoding = (ENC_MOV_DUPM_Z_I_); instr->operation = enc_to_oper(ENC_MOV_DUPM_Z_I_); rc = 0; };
 }
 return rc;
}


int MOV_orr_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25804000) {
  decode_fields32(ENC_MOV_ORR_P_P_PP_Z, ctx, instr);
  {instr->encoding = (ENC_MOV_ORR_P_P_PP_Z); instr->operation = enc_to_oper(ENC_MOV_ORR_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int MOV_orr_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4603000) {
  decode_fields32(ENC_MOV_ORR_Z_ZZ_, ctx, instr);
  {instr->encoding = (ENC_MOV_ORR_Z_ZZ_); instr->operation = enc_to_oper(ENC_MOV_ORR_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int MOV_sel_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25004210) {
  decode_fields32(ENC_MOV_SEL_P_P_PP_, ctx, instr);
  {instr->encoding = (ENC_MOV_SEL_P_P_PP_); instr->operation = enc_to_oper(ENC_MOV_SEL_P_P_PP_); rc = 0; };
 }
 return rc;
}


int MOV_sel_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20C000)==0x520C000) {
  decode_fields32(ENC_MOV_SEL_Z_P_ZZ_, ctx, instr);
  {instr->encoding = (ENC_MOV_SEL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_MOV_SEL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int MRS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF00000)==0xD5300000) {
  decode_fields32(ENC_MRS_RS_SYSTEMMOVE, ctx, instr);
  CheckSystemAccess(((1<<1)|ctx->o0),ctx->op1,ctx->CRn,ctx->CRm,ctx->op2,ctx->Rt,ctx->L);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->sys_op0 = 2+(unsigned int)(ctx->o0);
  ctx->sys_op1 = (unsigned int)(ctx->op1);
  ctx->sys_op2 = (unsigned int)(ctx->op2);
  ctx->sys_crn = (unsigned int)(ctx->CRn);
  ctx->sys_crm = (unsigned int)(ctx->CRm);
  ctx->read = (ctx->L==1);
  {instr->encoding = (ENC_MRS_RS_SYSTEMMOVE); instr->operation = enc_to_oper(ENC_MRS_RS_SYSTEMMOVE); rc = 0; };
 }
 return rc;
}


int MSR_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF8F01F)==0xD500401F) {
  decode_fields32(ENC_MSR_SI_PSTATE, ctx, instr);
  if(ctx->op1==0 && ctx->op2==0) {
   { return -6; } ;
  }
  if(ctx->op1==0 && ctx->op2==1) {
   { return -6; } ;
  }
  if(ctx->op1==0 && ctx->op2==2) {
   { return -6; } ;
  }
  CheckSystemAccess(0,ctx->op1,4,ctx->CRm,ctx->op2,0x1f,0);
  ctx->need_secure = 
# 17949 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                    0
# 17949 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  if(!(ctx->op1&6)) {
   ctx->min_EL = 1;
  }
  else if(ctx->op1==2) {
   ctx->min_EL = 1;
  }
  else if(ctx->op1==3) {
   ctx->min_EL = 0;
  }
  else if(ctx->op1==4) {
   ctx->min_EL = 2;
  }
  else if(ctx->op1==5) {
   if(!(ctx->features1 & ((uint64_t)1<<48))) {
    { return -4; };
   }
   ctx->min_EL = 2;
  }
  else if(ctx->op1==6) {
   ctx->min_EL = 3;
  }
  else if(ctx->op1==7) {
   ctx->min_EL = 1;
   ctx->need_secure = 
# 17973 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     1
# 17973 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  }

  ctx->operand = ctx->CRm;
  if(((ctx->op1<<3)|ctx->op2)==3) {
   if(!(ctx->features1 & ((uint64_t)1<<47))) {
    { return -4; };
   }
   ctx->field = PSTATEField_UAO;
  }
  else if(((ctx->op1<<3)|ctx->op2)==4) {
   if(!(ctx->features1 & ((uint64_t)1<<24))) {
    { return -4; };
   }
   ctx->field = PSTATEField_PAN;
  }
  else if(((ctx->op1<<3)|ctx->op2)==5) {
   ctx->field = PSTATEField_SP;
  }
  else if(((ctx->op1<<3)|ctx->op2)==0x1a) {
   if(!(ctx->features1 & ((uint64_t)1<<7))) {
    { return -4; };
   }
   ctx->field = PSTATEField_DIT;
  }
  else if(((ctx->op1<<3)|ctx->op2)==0x1c) {
   if(!(ctx->features1 & ((uint64_t)1<<21))) {
    { return -4; };
   }
   ctx->field = PSTATEField_TCO;
  }
  else if(((ctx->op1<<3)|ctx->op2)==0x1e) {
   ctx->field = PSTATEField_DAIFSet;
  }
  else if(((ctx->op1<<3)|ctx->op2)==0x1f) {
   ctx->field = PSTATEField_DAIFClr;
  }
  else if(((ctx->op1<<3)|ctx->op2)==0x19) {
   if(!(ctx->features1 & ((uint64_t)1<<34))) {
    { return -4; };
   }
   ctx->field = PSTATEField_SSBS;
  }
  else {
   { return -4; };
  }

  {instr->encoding = (ENC_MSR_SI_PSTATE); instr->operation = enc_to_oper(ENC_MSR_SI_PSTATE); rc = 0; };
 }
 return rc;
}


int MSR_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF00000)==0xD5100000) {
  decode_fields32(ENC_MSR_SR_SYSTEMMOVE, ctx, instr);
  CheckSystemAccess(((1<<1)|ctx->o0),ctx->op1,ctx->CRn,ctx->CRm,ctx->op2,ctx->Rt,ctx->L);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->sys_op0 = 2+(unsigned int)(ctx->o0);
  ctx->sys_op1 = (unsigned int)(ctx->op1);
  ctx->sys_op2 = (unsigned int)(ctx->op2);
  ctx->sys_crn = (unsigned int)(ctx->CRn);
  ctx->sys_crm = (unsigned int)(ctx->CRm);
  ctx->read = (ctx->L==1);
  {instr->encoding = (ENC_MSR_SR_SYSTEMMOVE); instr->operation = enc_to_oper(ENC_MSR_SR_SYSTEMMOVE); rc = 0; };
 }
 return rc;
}


int MSUB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE08000)==0x1B008000) {
  decode_fields32(ENC_MSUB_32A_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->datasize = ctx->destsize;
  ctx->sub_op = (ctx->o0==1);

  if(ctx->Ra==0x1f) return MNEG_MSUB(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_MSUB_32A_DP_3SRC); instr->operation = enc_to_oper(ENC_MSUB_32A_DP_3SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MSUB_64A_DP_3SRC); instr->operation = enc_to_oper(ENC_MSUB_64A_DP_3SRC); rc = 0; };
 }
 return rc;
}


int MUL_MADD(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1B007C00) {
  decode_fields32(ENC_MUL_MADD_32A_DP_3SRC, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_MUL_MADD_32A_DP_3SRC); instr->operation = enc_to_oper(ENC_MUL_MADD_32A_DP_3SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MUL_MADD_64A_DP_3SRC); instr->operation = enc_to_oper(ENC_MUL_MADD_64A_DP_3SRC); rc = 0; };
 }
 return rc;
}


int MUL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0xF008000) {
  decode_fields32(ENC_MUL_ASIMDELEM_R, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_MUL_ASIMDELEM_R); instr->operation = enc_to_oper(ENC_MUL_ASIMDELEM_R); rc = 0; };
 }
 return rc;
}


int MUL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE209C00) {
  decode_fields32(ENC_MUL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->U==1 && ctx->size!=0) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->poly = (ctx->U==1);
  {instr->encoding = (ENC_MUL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_MUL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int MVNI_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFF80C00)==0x2F000400) {
  decode_fields32(ENC_MVNI_ASIMDIMM_L_HL, ctx, instr);
  ctx->rd = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  if(!(((ctx->cmode<<1)|ctx->op)&0x13)) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==1) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==2) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==3) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x10) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x11) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x12) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x13) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x18) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x19) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1e)==0x1c) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1e) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1f) {
   if(ctx->Q==0) {
    { return -4; };
   }
   ctx->operation_ = ImmediateOp_MOVI;
  }
  ctx->imm64 = AdvSIMDExpandImm(ctx->op,ctx->cmode,((ctx->a<<7)|(ctx->b<<6)|(ctx->c<<5)|(ctx->d<<4)|(ctx->e<<3)|(ctx->f<<2)|(ctx->g<<1)|ctx->h));
  ctx->imm = Replicate(ctx->imm64, ((0x40) ? ((ctx->datasize) / (0x40)) : 0), 64);
  if((ctx->cmode&13)==8) {instr->encoding = (ENC_MVNI_ASIMDIMM_L_HL); instr->operation = enc_to_oper(ENC_MVNI_ASIMDIMM_L_HL); rc = 0; };
  if(!(ctx->cmode&9)) {instr->encoding = (ENC_MVNI_ASIMDIMM_L_SL); instr->operation = enc_to_oper(ENC_MVNI_ASIMDIMM_L_SL); rc = 0; };
  if((ctx->cmode&14)==12) {instr->encoding = (ENC_MVNI_ASIMDIMM_M_SM); instr->operation = enc_to_oper(ENC_MVNI_ASIMDIMM_M_SM); rc = 0; };
 }
 return rc;
}


int MVN_NOT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2E205800) {
  decode_fields32(ENC_MVN_NOT_ASIMDMISC_R, ctx, instr);
  {instr->encoding = (ENC_MVN_NOT_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_MVN_NOT_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int MVN_ORN_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F2003E0)==0x2A2003E0) {
  decode_fields32(ENC_MVN_ORN_32_LOG_SHIFT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_MVN_ORN_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_MVN_ORN_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_MVN_ORN_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_MVN_ORN_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int NEGS_SUBS_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F2003E0)==0x6B0003E0 && ((ctx->insword) & 0x1F)!=0x1F) {
  decode_fields32(ENC_NEGS_SUBS_32_ADDSUB_SHIFT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_NEGS_SUBS_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_NEGS_SUBS_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_NEGS_SUBS_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_NEGS_SUBS_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int NEG_SUB_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F2003E0)==0x4B0003E0) {
  decode_fields32(ENC_NEG_SUB_32_ADDSUB_SHIFT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_NEG_SUB_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_NEG_SUB_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_NEG_SUB_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_NEG_SUB_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int NEG_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x7E20B800) {
  decode_fields32(ENC_NEG_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_NEG_ASISDMISC_R); instr->operation = enc_to_oper(ENC_NEG_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0x2E20B800) {
  decode_fields32(ENC_NEG_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_NEG_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_NEG_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int NGCS_SBCS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FFE0)==0x7A0003E0) {
  decode_fields32(ENC_NGCS_SBCS_32_ADDSUB_CARRY, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_NGCS_SBCS_32_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_NGCS_SBCS_32_ADDSUB_CARRY); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_NGCS_SBCS_64_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_NGCS_SBCS_64_ADDSUB_CARRY); rc = 0; };
 }
 return rc;
}


int NGC_SBC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FFE0)==0x5A0003E0) {
  decode_fields32(ENC_NGC_SBC_32_ADDSUB_CARRY, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_NGC_SBC_32_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_NGC_SBC_32_ADDSUB_CARRY); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_NGC_SBC_64_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_NGC_SBC_64_ADDSUB_CARRY); rc = 0; };
 }
 return rc;
}


int NOP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503201F) {
  decode_fields32(ENC_NOP_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_NOP_HI_HINTS); instr->operation = enc_to_oper(ENC_NOP_HI_HINTS); rc = 0; };
 }
 return rc;
}


int NOTS_eor_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25404200) {
  decode_fields32(ENC_NOTS_EORS_P_P_PP_Z, ctx, instr);
  {instr->encoding = (ENC_NOTS_EORS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_NOTS_EORS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int NOT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2E205800) {
  decode_fields32(ENC_NOT_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((8) ? ((ctx->datasize) / (8)) : 0);

  if(MVN_NOT_advsimd(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_NOT_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_NOT_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int NOT_eor_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25004200) {
  decode_fields32(ENC_NOT_EOR_P_P_PP_Z, ctx, instr);
  {instr->encoding = (ENC_NOT_EOR_P_P_PP_Z); instr->operation = enc_to_oper(ENC_NOT_EOR_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int ORN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEE01C00) {
  decode_fields32(ENC_ORN_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->invert = ((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  ctx->op = ((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) ? LogicalOp_ORR : LogicalOp_AND;
  {instr->encoding = (ENC_ORN_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_ORN_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int ORN_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x2A200000) {
  decode_fields32(ENC_ORN_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 18513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18513 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 18517 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18517 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 18521 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18521 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 18525 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 18525 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);

  if(ctx->Rn==0x1f) return MVN_ORN_log_shift(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ORN_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_ORN_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ORN_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_ORN_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int ORN_orr_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5000000) {
  decode_fields32(ENC_ORN_ORR_Z_ZI_, ctx, instr);
  {instr->encoding = (ENC_ORN_ORR_Z_ZI_); instr->operation = enc_to_oper(ENC_ORN_ORR_Z_ZI_); rc = 0; };
 }
 return rc;
}


int ORR_advsimd_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFF81C00)==0xF001400) {
  decode_fields32(ENC_ORR_ASIMDIMM_L_HL, ctx, instr);
  ctx->rd = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  if(!(((ctx->cmode<<1)|ctx->op)&0x13)) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==1) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==2) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x13)==3) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x10) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x11) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x12) {
   ctx->operation_ = ImmediateOp_ORR;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1b)==0x13) {
   ctx->operation_ = ImmediateOp_BIC;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x18) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1d)==0x19) {
   ctx->operation_ = ImmediateOp_MVNI;
  }
  else if((((ctx->cmode<<1)|ctx->op)&0x1e)==0x1c) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1e) {
   ctx->operation_ = ImmediateOp_MOVI;
  }
  else if(((ctx->cmode<<1)|ctx->op)==0x1f) {
   if(ctx->Q==0) {
    { return -4; };
   }
   ctx->operation_ = ImmediateOp_MOVI;
  }
  ctx->imm64 = AdvSIMDExpandImm(ctx->op,ctx->cmode,((ctx->a<<7)|(ctx->b<<6)|(ctx->c<<5)|(ctx->d<<4)|(ctx->e<<3)|(ctx->f<<2)|(ctx->g<<1)|ctx->h));
  ctx->imm = Replicate(ctx->imm64, ((0x40) ? ((ctx->datasize) / (0x40)) : 0), 64);
  if((ctx->cmode&13)==9) {instr->encoding = (ENC_ORR_ASIMDIMM_L_HL); instr->operation = enc_to_oper(ENC_ORR_ASIMDIMM_L_HL); rc = 0; };
  if((ctx->cmode&9)==1) {instr->encoding = (ENC_ORR_ASIMDIMM_L_SL); instr->operation = enc_to_oper(ENC_ORR_ASIMDIMM_L_SL); rc = 0; };
 }
 return rc;
}


int ORR_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xEA01C00) {
  decode_fields32(ENC_ORR_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->invert = ((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  ctx->op = ((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) ? LogicalOp_ORR : LogicalOp_AND;

  if(ctx->Rm==ctx->Rn) return MOV_ORR_advsimd_reg(ctx, instr);
  {instr->encoding = (ENC_ORR_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_ORR_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int ORR_log_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x32000000) {
  decode_fields32(ENC_ORR_32_LOG_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 18650 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18650 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 18654 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18654 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 18658 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18658 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 18662 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 18662 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && ctx->N!=0) {
   { return -4; };
  }
  if((ctx->N==0 && (ctx->imms==0x3D || ctx->imms==0x3B || ctx->imms==0x37 || ctx->imms==0x2F || ctx->imms==0x1F)) || (ctx->N==1 && ctx->imms==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks(ctx->N,ctx->imms,ctx->immr);
  ctx->imm = dbmrt.wmask;

  if(ctx->Rn==0x1f && !MoveWidePreferred(ctx->sf,ctx->N,ctx->imms,ctx->immr)) return MOV_ORR_log_imm(ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_ORR_32_LOG_IMM); instr->operation = enc_to_oper(ENC_ORR_32_LOG_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ORR_64_LOG_IMM); instr->operation = enc_to_oper(ENC_ORR_64_LOG_IMM); rc = 0; };
 }
 return rc;
}


int ORR_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x2A000000) {
  decode_fields32(ENC_ORR_32_LOG_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 18692 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18692 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==1) {
   ctx->op = LogicalOp_ORR;
   ctx->setflags = 
# 18696 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18696 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==2) {
   ctx->op = LogicalOp_EOR;
   ctx->setflags = 
# 18700 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 18700 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  }
  else if(ctx->opc==3) {
   ctx->op = LogicalOp_AND;
   ctx->setflags = 
# 18704 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 18704 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);
  ctx->invert = (ctx->N==1);

  if(ctx->shift==0 && ctx->imm6==0 && ctx->Rn==0x1f) return MOV_ORR_log_shift(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ORR_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_ORR_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ORR_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_ORR_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int PACDA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC10800) {
  decode_fields32(ENC_PACDA_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 18728 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 18728 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 18736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 18736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_PACDA_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_PACDA_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_PACDZA_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_PACDZA_64Z_DP_1SRC); rc = 0; };
 }
 return rc;
}


int PACDB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC10C00) {
  decode_fields32(ENC_PACDB_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 18758 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 18758 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 18766 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 18766 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_PACDB_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_PACDB_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_PACDZB_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_PACDZB_64Z_DP_1SRC); rc = 0; };
 }
 return rc;
}


int PACGA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9AC03000) {
  decode_fields32(ENC_PACGA_64P_DP_2SRC, ctx, instr);
  ctx->source_is_sp = 
# 18788 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 18788 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->m==0x1f) {
   ctx->source_is_sp = 
# 18796 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 18796 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  {instr->encoding = (ENC_PACGA_64P_DP_2SRC); instr->operation = enc_to_oper(ENC_PACGA_64P_DP_2SRC); rc = 0; };
 }
 return rc;
}


int PACIA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC10000) {
  decode_fields32(ENC_PACIA_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 18811 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 18811 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 18819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 18819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_PACIA_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_PACIA_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_PACIZA_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_PACIZA_64Z_DP_1SRC); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFFDDF)==0xD503211F) {
  decode_fields32(ENC_PACIA1716_HI_HINTS, ctx, instr);
  ctx->source_is_sp = 
# 18834 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 18834 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  if(((ctx->CRm<<3)|ctx->op2)==0x18) {
   ctx->d = 0x1e;
   ctx->n = 0x1f;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x19) {
   ctx->d = 0x1e;
   ctx->source_is_sp = 
# 18841 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 18841 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   if((ctx->features1 & ((uint64_t)1<<3))) {
    ctx->BTypeCompatible = (BTypeCompatible_PACIXSP());
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==8) {
   ctx->d = 0x11;
   ctx->n = 0x10;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==10) {
   { return -6; } ;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==12) {
   { return -6; } ;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==14) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x7e)==0x1a) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x7e)==0x1c) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x7e)==0x1e) {
   { return -6; } ;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else {
   { return -6; } ;
  }
  if(ctx->CRm==1 && ctx->op2==0) {instr->encoding = (ENC_PACIA1716_HI_HINTS); instr->operation = enc_to_oper(ENC_PACIA1716_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==1) {instr->encoding = (ENC_PACIASP_HI_HINTS); instr->operation = enc_to_oper(ENC_PACIASP_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==0) {instr->encoding = (ENC_PACIAZ_HI_HINTS); instr->operation = enc_to_oper(ENC_PACIAZ_HI_HINTS); rc = 0; };
 }
 return rc;
}


int PACIB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFDC00)==0xDAC10400) {
  decode_fields32(ENC_PACIB_64P_DP_1SRC, ctx, instr);
  ctx->source_is_sp = 
# 18889 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 18889 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->Z==0) {
   if(ctx->n==0x1f) {
    ctx->source_is_sp = 
# 18897 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 18897 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  else {
   if(ctx->n!=0x1f) {
    { return -4; };
   }
  }
  if(ctx->Z==0) {instr->encoding = (ENC_PACIB_64P_DP_1SRC); instr->operation = enc_to_oper(ENC_PACIB_64P_DP_1SRC); rc = 0; };
  if(ctx->Z==1 && ctx->Rn==0x1f) {instr->encoding = (ENC_PACIZB_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_PACIZB_64Z_DP_1SRC); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFFDDF)==0xD503215F) {
  decode_fields32(ENC_PACIB1716_HI_HINTS, ctx, instr);
  ctx->source_is_sp = 
# 18912 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 18912 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  if(((ctx->CRm<<3)|ctx->op2)==0x1a) {
   ctx->d = 0x1e;
   ctx->n = 0x1f;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x1b) {
   ctx->d = 0x1e;
   ctx->source_is_sp = 
# 18919 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 18919 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   if((ctx->features1 & ((uint64_t)1<<3))) {
    ctx->BTypeCompatible = (BTypeCompatible_PACIXSP());
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==10) {
   ctx->d = 0x11;
   ctx->n = 0x10;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==8) {
   { return -6; } ;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==12) {
   { return -6; } ;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==14) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x7e)==0x18) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x7e)==0x1c) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x7e)==0x1e) {
   { return -6; } ;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else {
   { return -6; } ;
  }
  if(ctx->CRm==1 && ctx->op2==2) {instr->encoding = (ENC_PACIB1716_HI_HINTS); instr->operation = enc_to_oper(ENC_PACIB1716_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==3) {instr->encoding = (ENC_PACIBSP_HI_HINTS); instr->operation = enc_to_oper(ENC_PACIBSP_HI_HINTS); rc = 0; };
  if(ctx->CRm==3 && ctx->op2==2) {instr->encoding = (ENC_PACIBZ_HI_HINTS); instr->operation = enc_to_oper(ENC_PACIBZ_HI_HINTS); rc = 0; };
 }
 return rc;
}


int PMULL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE20E000) {
  decode_fields32(ENC_PMULL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==1 || ctx->size==2) {
   { return -4; };
  }
  if(ctx->size==3 && !(ctx->features1 & ((uint64_t)1<<4))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_PMULL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_PMULL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int PMUL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E209C00) {
  decode_fields32(ENC_PMUL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->U==1 && ctx->size!=0) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->poly = (ctx->U==1);
  {instr->encoding = (ENC_PMUL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_PMUL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int PRFM_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC00000)==0xF9800000) {
  decode_fields32(ENC_PRFM_P_LDST_POS, ctx, instr);
  ctx->wback = 
# 19019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 19019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 19020 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19020 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  {instr->encoding = (ENC_PRFM_P_LDST_POS); instr->operation = enc_to_oper(ENC_PRFM_P_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 19036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 19036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 19053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 19053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 19058 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19058 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 19059 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19059 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int PRFM_lit(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF000000)==0xD8000000) {
  decode_fields32(ENC_PRFM_P_LOADLIT, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->memop = MemOp_LOAD;
  ctx->signed_ = 
# 19083 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 19083 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  if(!ctx->opc) {
   ctx->size = 4;
  }
  else if(ctx->opc==1) {
   ctx->size = 8;
  }
  else if(ctx->opc==2) {
   ctx->size = 4;
   ctx->signed_ = 
# 19092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 19092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==3) {
   ctx->memop = MemOp_PREFETCH;
  }
  ctx->offset = SignExtend((ctx->imm19<<2),21);
  ctx->tag_checked = 
# 19098 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                    0
# 19098 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  {instr->encoding = (ENC_PRFM_P_LOADLIT); instr->operation = enc_to_oper(ENC_PRFM_P_LOADLIT); rc = 0; };
 }
 return rc;
}


int PRFM_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xF8A00800) {
  decode_fields32(ENC_PRFM_P_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 19112 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 19112 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 19113 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19113 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  {instr->encoding = (ENC_PRFM_P_LDST_REGOFF); instr->operation = enc_to_oper(ENC_PRFM_P_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 19134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 19134 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 19151 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 19151 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 19156 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19156 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 19157 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19157 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int PRFUM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xF8800000) {
  decode_fields32(ENC_PRFUM_P_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 19179 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 19179 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 19180 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19180 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_PRFUM_P_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_PRFUM_P_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 19196 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 19196 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 19213 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 19213 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 19218 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19218 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 19219 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 19219 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int PSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503223F) {
  decode_fields32(ENC_PSB_HC_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_PSB_HC_HINTS); instr->operation = enc_to_oper(ENC_PSB_HC_HINTS); rc = 0; };
 }
 return rc;
}


int PSSBB_DSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503349F) {
  decode_fields32(ENC_PSSBB_DSB_BO_BARRIERS, ctx, instr);
  {instr->encoding = (ENC_PSSBB_DSB_BO_BARRIERS); instr->operation = enc_to_oper(ENC_PSSBB_DSB_BO_BARRIERS); rc = 0; };
 }
 return rc;
}


int RADDHN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E204000) {
  decode_fields32(ENC_RADDHN_ASIMDDIFF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->round = (ctx->U==1);
  {instr->encoding = (ENC_RADDHN_ASIMDDIFF_N); instr->operation = enc_to_oper(ENC_RADDHN_ASIMDDIFF_N); rc = 0; };
 }
 return rc;
}


int RAX1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xCE608C00) {
  decode_fields32(ENC_RAX1_VVV2_CRYPTOSHA512_3, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<30))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_RAX1_VVV2_CRYPTOSHA512_3); instr->operation = enc_to_oper(ENC_RAX1_VVV2_CRYPTOSHA512_3); rc = 0; };
 }
 return rc;
}


int RBIT_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFFC00)==0x2E605800) {
  decode_fields32(ENC_RBIT_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 8;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((8) ? ((ctx->datasize) / (8)) : 0);
  {instr->encoding = (ENC_RBIT_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_RBIT_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int RBIT_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFFFC00)==0x5AC00000) {
  decode_fields32(ENC_RBIT_32_DP_1SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(ctx->sf==0) {instr->encoding = (ENC_RBIT_32_DP_1SRC); instr->operation = enc_to_oper(ENC_RBIT_32_DP_1SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_RBIT_64_DP_1SRC); instr->operation = enc_to_oper(ENC_RBIT_64_DP_1SRC); rc = 0; };
 }
 return rc;
}


int RET(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC1F)==0xD65F0000) {
  decode_fields32(ENC_RET_64R_BRANCH_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  ctx->source_is_sp = ((ctx->Z==1) && (ctx->m==0x1f));
  if(!ctx->pac && ctx->m!=0) {
   { return -4; };
  }
  else if(ctx->pac && !(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(!ctx->op) {
   ctx->branch_type = BranchType_INDIR;
  }
  else if(ctx->op==1) {
   ctx->branch_type = BranchType_INDCALL;
  }
  else if(ctx->op==2) {
   ctx->branch_type = BranchType_RET;
  }
  else {
   { return -4; };
  }
  if(ctx->pac) {
   if(ctx->Z==0 && ctx->m!=0x1f) {
    { return -4; };
   }
   if(ctx->branch_type==BranchType_RET) {
    if(ctx->n!=0x1f) {
     { return -4; };
    }
    ctx->n = 0x1e;
    ctx->source_is_sp = 
# 19476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 19476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  {instr->encoding = (ENC_RET_64R_BRANCH_REG); instr->operation = enc_to_oper(ENC_RET_64R_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int RETA(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFBFF)==0xD65F0BFF) {
  decode_fields32(ENC_RETAA_64E_BRANCH_REG, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->pac = (ctx->A==1);
  ctx->use_key_a = (ctx->M==0);
  ctx->source_is_sp = ((ctx->Z==1) && (ctx->m==0x1f));
  if(!ctx->pac && ctx->m!=0) {
   { return -4; };
  }
  else if(ctx->pac && !(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(!ctx->op) {
   ctx->branch_type = BranchType_INDIR;
  }
  else if(ctx->op==1) {
   ctx->branch_type = BranchType_INDCALL;
  }
  else if(ctx->op==2) {
   ctx->branch_type = BranchType_RET;
  }
  else {
   { return -4; };
  }
  if(ctx->pac) {
   if(ctx->Z==0 && ctx->m!=0x1f) {
    { return -4; };
   }
   if(ctx->branch_type==BranchType_RET) {
    if(ctx->n!=0x1f) {
     { return -4; };
    }
    ctx->n = 0x1e;
    ctx->source_is_sp = 
# 19524 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                       1
# 19524 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   }
  }
  if(ctx->M==0) {instr->encoding = (ENC_RETAA_64E_BRANCH_REG); instr->operation = enc_to_oper(ENC_RETAA_64E_BRANCH_REG); rc = 0; };
  if(ctx->M==1) {instr->encoding = (ENC_RETAB_64E_BRANCH_REG); instr->operation = enc_to_oper(ENC_RETAB_64E_BRANCH_REG); rc = 0; };
 }
 return rc;
}


int REV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFFF800)==0x5AC00800) {
  decode_fields32(ENC_REV_32_DP_1SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   { return -5; };
  }
  else if(ctx->opc==1) {
   ctx->container_size = 0x10;
  }
  else if(ctx->opc==2) {
   ctx->container_size = 0x20;
  }
  else if(ctx->opc==3) {
   if(ctx->sf==0) {
    { return -4; };
   }
   ctx->container_size = 0x40;
  }
  if(ctx->sf==0 && ctx->opc==2) {instr->encoding = (ENC_REV_32_DP_1SRC); instr->operation = enc_to_oper(ENC_REV_32_DP_1SRC); rc = 0; };
  if(ctx->sf==1 && ctx->opc==3) {instr->encoding = (ENC_REV_64_DP_1SRC); instr->operation = enc_to_oper(ENC_REV_64_DP_1SRC); rc = 0; };
 }
 return rc;
}


int REV16_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE201800) {
  decode_fields32(ENC_REV16_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->op = ((ctx->o0<<1)|ctx->U);
  if(((unsigned int)(ctx->op)+(unsigned int)(ctx->size)) >= (3)) {
   { return -4; };
  }
  if(ctx->op==2) {
   ctx->container_size = 0x10;
  }
  else if(ctx->op==1) {
   ctx->container_size = 0x20;
  }
  else if(!ctx->op) {
   ctx->container_size = 0x40;
  }
  ctx->containers = ((ctx->container_size) ? ((ctx->datasize) / (ctx->container_size)) : 0);
  ctx->elements_per_container = ((ctx->esize) ? ((ctx->container_size) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_REV16_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_REV16_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int REV16_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FFFFC00)==0x5AC00400) {
  decode_fields32(ENC_REV16_32_DP_1SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   { return -5; };
  }
  else if(ctx->opc==1) {
   ctx->container_size = 0x10;
  }
  else if(ctx->opc==2) {
   ctx->container_size = 0x20;
  }
  else if(ctx->opc==3) {
   if(ctx->sf==0) {
    { return -4; };
   }
   ctx->container_size = 0x40;
  }
  if(ctx->sf==0) {instr->encoding = (ENC_REV16_32_DP_1SRC); instr->operation = enc_to_oper(ENC_REV16_32_DP_1SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_REV16_64_DP_1SRC); instr->operation = enc_to_oper(ENC_REV16_64_DP_1SRC); rc = 0; };
 }
 return rc;
}


int REV32_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E200800) {
  decode_fields32(ENC_REV32_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->op = ((ctx->o0<<1)|ctx->U);
  if(((unsigned int)(ctx->op)+(unsigned int)(ctx->size)) >= (3)) {
   { return -4; };
  }
  if(ctx->op==2) {
   ctx->container_size = 0x10;
  }
  else if(ctx->op==1) {
   ctx->container_size = 0x20;
  }
  else if(!ctx->op) {
   ctx->container_size = 0x40;
  }
  ctx->containers = ((ctx->container_size) ? ((ctx->datasize) / (ctx->container_size)) : 0);
  ctx->elements_per_container = ((ctx->esize) ? ((ctx->container_size) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_REV32_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_REV32_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int REV32_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xDAC00800) {
  decode_fields32(ENC_REV32_64_DP_1SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   { return -5; };
  }
  else if(ctx->opc==1) {
   ctx->container_size = 0x10;
  }
  else if(ctx->opc==2) {
   ctx->container_size = 0x20;
  }
  else if(ctx->opc==3) {
   if(ctx->sf==0) {
    { return -4; };
   }
   ctx->container_size = 0x40;
  }
  {instr->encoding = (ENC_REV32_64_DP_1SRC); instr->operation = enc_to_oper(ENC_REV32_64_DP_1SRC); rc = 0; };
 }
 return rc;
}


int REV64_REV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xDAC00C00) {
  decode_fields32(ENC_REV64_REV_64_DP_1SRC, ctx, instr);
  {instr->encoding = (ENC_REV64_REV_64_DP_1SRC); instr->operation = enc_to_oper(ENC_REV64_REV_64_DP_1SRC); rc = 0; };
 }
 return rc;
}


int REV64_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE200800) {
  decode_fields32(ENC_REV64_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->op = ((ctx->o0<<1)|ctx->U);
  if(((unsigned int)(ctx->op)+(unsigned int)(ctx->size)) >= (3)) {
   { return -4; };
  }
  if(ctx->op==2) {
   ctx->container_size = 0x10;
  }
  else if(ctx->op==1) {
   ctx->container_size = 0x20;
  }
  else if(!ctx->op) {
   ctx->container_size = 0x40;
  }
  ctx->containers = ((ctx->container_size) ? ((ctx->datasize) / (ctx->container_size)) : 0);
  ctx->elements_per_container = ((ctx->esize) ? ((ctx->container_size) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_REV64_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_REV64_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int RMIF(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE07C10)==0xBA000400) {
  decode_fields32(ENC_RMIF_ONLY_RMIF, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<17)) || ctx->sf!=1) {
   { return -4; };
  }
  ctx->lsb = (unsigned int)(ctx->imm6);
  ctx->n = (unsigned int)(ctx->Rn);
  {instr->encoding = (ENC_RMIF_ONLY_RMIF); instr->operation = enc_to_oper(ENC_RMIF_ONLY_RMIF); rc = 0; };
 }
 return rc;
}


int RORV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02C00) {
  decode_fields32(ENC_RORV_32_DP_2SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->shift_type = DecodeShift(ctx->op2);

  if(ROR_RORV(ctx, instr)==0) return 0;
  if(ctx->sf==0) {instr->encoding = (ENC_RORV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_RORV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_RORV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_RORV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int ROR_EXTR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FA00000)==0x13800000) {
  decode_fields32(ENC_ROR_EXTR_32_EXTRACT, ctx, instr);
  if(ctx->sf==0 && ctx->N==0 && !(ctx->imms&0x20)) {instr->encoding = (ENC_ROR_EXTR_32_EXTRACT); instr->operation = enc_to_oper(ENC_ROR_EXTR_32_EXTRACT); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_ROR_EXTR_64_EXTRACT); instr->operation = enc_to_oper(ENC_ROR_EXTR_64_EXTRACT); rc = 0; };
 }
 return rc;
}


int ROR_RORV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC02C00) {
  decode_fields32(ENC_ROR_RORV_32_DP_2SRC, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_ROR_RORV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_ROR_RORV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_ROR_RORV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_ROR_RORV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int RSHRN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF80FC00)==0xF008C00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_RSHRN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_RSHRN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_RSHRN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int RSUBHN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E206000) {
  decode_fields32(ENC_RSUBHN_ASIMDDIFF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->round = (ctx->U==1);
  {instr->encoding = (ENC_RSUBHN_ASIMDDIFF_N); instr->operation = enc_to_oper(ENC_RSUBHN_ASIMDDIFF_N); rc = 0; };
 }
 return rc;
}


int SABAL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE205000) {
  decode_fields32(ENC_SABAL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->accumulate = (ctx->op==0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SABAL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SABAL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SABA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE207C00) {
  decode_fields32(ENC_SABA_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->accumulate = (ctx->ac==1);
  {instr->encoding = (ENC_SABA_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SABA_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SABDL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE207000) {
  decode_fields32(ENC_SABDL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->accumulate = (ctx->op==0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SABDL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SABDL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SABD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE207400) {
  decode_fields32(ENC_SABD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->accumulate = (ctx->ac==1);
  {instr->encoding = (ENC_SABD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SABD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SADALP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE206800) {
  decode_fields32(ENC_SADALP_ASIMDMISC_P, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((2 * ctx->esize)!=0) ? ((ctx->datasize) / (((2) * (ctx->esize)))) : 0;
  ctx->acc = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SADALP_ASIMDMISC_P); instr->operation = enc_to_oper(ENC_SADALP_ASIMDMISC_P); rc = 0; };
 }
 return rc;
}


int SADDLP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE202800) {
  decode_fields32(ENC_SADDLP_ASIMDMISC_P, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((2 * ctx->esize)!=0) ? ((ctx->datasize) / (((2) * (ctx->esize)))) : 0;
  ctx->acc = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SADDLP_ASIMDMISC_P); instr->operation = enc_to_oper(ENC_SADDLP_ASIMDMISC_P); rc = 0; };
 }
 return rc;
}


int SADDLV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE303800) {
  decode_fields32(ENC_SADDLV_ASIMDALL_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==4) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SADDLV_ASIMDALL_ONLY); instr->operation = enc_to_oper(ENC_SADDLV_ASIMDALL_ONLY); rc = 0; };
 }
 return rc;
}


int SADDL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE200000) {
  decode_fields32(ENC_SADDL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SADDL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SADDL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SADDW_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE201000) {
  decode_fields32(ENC_SADDW_ASIMDDIFF_W, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SADDW_ASIMDDIFF_W); instr->operation = enc_to_oper(ENC_SADDW_ASIMDDIFF_W); rc = 0; };
 }
 return rc;
}


int SB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD50330FF) {
  decode_fields32(ENC_SB_ONLY_BARRIERS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<27))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SB_ONLY_BARRIERS); instr->operation = enc_to_oper(ENC_SB_ONLY_BARRIERS); rc = 0; };
 }
 return rc;
}


int SBC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x5A000000) {
  decode_fields32(ENC_SBC_32_ADDSUB_CARRY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  instr->setflags = (ctx->S==1);
  ctx->setflags = (ctx->S==1);

  if(ctx->Rn==0x1f) return NGC_SBC(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_SBC_32_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_SBC_32_ADDSUB_CARRY); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SBC_64_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_SBC_64_ADDSUB_CARRY); rc = 0; };
 }
 return rc;
}


int SBCS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x7A000000) {
  decode_fields32(ENC_SBCS_32_ADDSUB_CARRY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  instr->setflags = (ctx->S==1);
  ctx->setflags = (ctx->S==1);

  if(ctx->Rn==0x1f) return NGCS_SBCS(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_SBCS_32_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_SBCS_32_ADDSUB_CARRY); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SBCS_64_ADDSUB_CARRY); instr->operation = enc_to_oper(ENC_SBCS_64_ADDSUB_CARRY); rc = 0; };
 }
 return rc;
}


int SBFIZ_SBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x13000000) {
  decode_fields32(ENC_SBFIZ_SBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_SBFIZ_SBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_SBFIZ_SBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_SBFIZ_SBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_SBFIZ_SBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int SBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x13000000) {
  decode_fields32(ENC_SBFM_32M_BITFIELD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->inzero = 
# 20163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 20163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
   ctx->extend = 
# 20164 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 20164 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  }
  else if(ctx->opc==1) {
   ctx->inzero = 
# 20167 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 20167 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
   ctx->extend = 
# 20168 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 20168 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==2) {
   ctx->inzero = 
# 20171 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 20171 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
   ctx->extend = 
# 20172 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 20172 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==3) {
   { return -4; };
  }
  if(ctx->sf==1 && ctx->N!=1) {
   { return -4; };
  }
  if(ctx->sf==0 && (ctx->N!=0 || (((ctx->immr)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))!=0 || (((ctx->imms)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))!=0)) {
   { return -4; };
  }
  ctx->R = (unsigned int)(ctx->immr);
  ctx->S = (unsigned int)(ctx->imms);
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks(ctx->N,ctx->imms,ctx->immr);
  ctx->wmask = dbmrt.wmask;
  ctx->tmask = dbmrt.tmask;

  
# 20189 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
 _Bool 
# 20189 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
      encoding32 = ctx->sf==0 && ctx->N==0;
  
# 20190 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
 _Bool 
# 20190 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
      encoding64 = ctx->sf==1 && ctx->N==1;
  if((ctx->imms==0x1f && (encoding32)) || (ctx->imms==0x3f && (encoding64))) return ASR_SBFM(ctx, instr);
  if((unsigned int)(ctx->imms)<(unsigned int)(ctx->immr)) return SBFIZ_SBFM(ctx, instr);
  if(BFXPreferred(ctx->sf,(((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)),ctx->imms,ctx->immr)) return SBFX_SBFM(ctx, instr);
  if(ctx->immr==0 && ctx->imms==7) return SXTB_SBFM(ctx, instr);
  if(ctx->immr==0 && ctx->imms==15) return SXTH_SBFM(ctx, instr);
  if(ctx->immr==0 && ctx->imms==0x1f) return SXTW_SBFM(ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_SBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_SBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_SBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_SBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int SBFX_SBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x13000000) {
  decode_fields32(ENC_SBFX_SBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_SBFX_SBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_SBFX_SBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_SBFX_SBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_SBFX_SBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int SCVTF_advsimd_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F00E400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SCVTF_ASISDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_ASISDSHF_C); instr->operation = enc_to_oper(ENC_SCVTF_ASISDSHF_C); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF00E400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SCVTF_ASIMDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_ASIMDSHF_C); instr->operation = enc_to_oper(ENC_SCVTF_ASIMDSHF_C); rc = 0; };
 }
 return rc;
}


int SCVTF_advsimd_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5E79D800) {
  decode_fields32(ENC_SCVTF_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SCVTF_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_SCVTF_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x5E21D800) {
  decode_fields32(ENC_SCVTF_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SCVTF_ASISDMISC_R); instr->operation = enc_to_oper(ENC_SCVTF_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0xE79D800) {
  decode_fields32(ENC_SCVTF_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SCVTF_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_SCVTF_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0xE21D800) {
  decode_fields32(ENC_SCVTF_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SCVTF_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_SCVTF_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int SCVTF_float_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3F0000)==0x1E020000) {
  decode_fields32(ENC_SCVTF_H32_FLOAT2FIX, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(ctx->sf==0 && (((ctx->scale)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==0) {
   { return -4; };
  }
  ctx->fracbits = 0x40-(unsigned int)(ctx->scale);
  if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==3) {
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_SCVTF_H32_FLOAT2FIX); instr->operation = enc_to_oper(ENC_SCVTF_H32_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_SCVTF_S32_FLOAT2FIX); instr->operation = enc_to_oper(ENC_SCVTF_S32_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_SCVTF_D32_FLOAT2FIX); instr->operation = enc_to_oper(ENC_SCVTF_D32_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_SCVTF_H64_FLOAT2FIX); instr->operation = enc_to_oper(ENC_SCVTF_H64_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_SCVTF_S64_FLOAT2FIX); instr->operation = enc_to_oper(ENC_SCVTF_S64_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_SCVTF_D64_FLOAT2FIX); instr->operation = enc_to_oper(ENC_SCVTF_D64_FLOAT2FIX); rc = 0; };
 }
 return rc;
}


int SCVTF_float_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E220000) {
  decode_fields32(ENC_SCVTF_H32_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_SCVTF_H32_FLOAT2INT); instr->operation = enc_to_oper(ENC_SCVTF_H32_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_SCVTF_S32_FLOAT2INT); instr->operation = enc_to_oper(ENC_SCVTF_S32_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_SCVTF_D32_FLOAT2INT); instr->operation = enc_to_oper(ENC_SCVTF_D32_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_SCVTF_H64_FLOAT2INT); instr->operation = enc_to_oper(ENC_SCVTF_H64_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_SCVTF_S64_FLOAT2INT); instr->operation = enc_to_oper(ENC_SCVTF_S64_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_SCVTF_D64_FLOAT2INT); instr->operation = enc_to_oper(ENC_SCVTF_D64_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int SDIV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC00C00) {
  decode_fields32(ENC_SDIV_32_DP_2SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->unsigned_ = (ctx->o1==0);
  if(ctx->sf==0) {instr->encoding = (ENC_SDIV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_SDIV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SDIV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_SDIV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int SDOT_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0xF00E000) {
  decode_fields32(ENC_SDOT_ASIMDELEM_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<8))) {
   { return -4; };
  }
  if(ctx->size!=2) {
   { return -4; };
  }
  ctx->signed_ = (ctx->U==0);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->M<<4)|ctx->Rm));
  ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_SDOT_ASIMDELEM_D); instr->operation = enc_to_oper(ENC_SDOT_ASIMDELEM_D); rc = 0; };
 }
 return rc;
}


int SDOT_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE009400) {
  decode_fields32(ENC_SDOT_ASIMDSAME2_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<8))) {
   { return -4; };
  }
  if(ctx->size!=2) {
   { return -4; };
  }
  ctx->signed_ = (ctx->U==0);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_SDOT_ASIMDSAME2_D); instr->operation = enc_to_oper(ENC_SDOT_ASIMDSAME2_D); rc = 0; };
 }
 return rc;
}


int SETF(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFBC1F)==0x3A00080D) {
  decode_fields32(ENC_SETF8_ONLY_SETF, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<17)) || ctx->sf!=0) {
   { return -4; };
  }
  ctx->msb = (ctx->sz==1) ? 15 : 7;
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->sz==0) {instr->encoding = (ENC_SETF8_ONLY_SETF); instr->operation = enc_to_oper(ENC_SETF8_ONLY_SETF); rc = 0; };
  if(ctx->sz==1) {instr->encoding = (ENC_SETF16_ONLY_SETF); instr->operation = enc_to_oper(ENC_SETF16_ONLY_SETF); rc = 0; };
 }
 return rc;
}


int SEV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503209F) {
  decode_fields32(ENC_SEV_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_SEV_HI_HINTS); instr->operation = enc_to_oper(ENC_SEV_HI_HINTS); rc = 0; };
 }
 return rc;
}


int SEVL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD50320BF) {
  decode_fields32(ENC_SEVL_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_SEVL_HI_HINTS); instr->operation = enc_to_oper(ENC_SEVL_HI_HINTS); rc = 0; };
 }
 return rc;
}


int SHA1C_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E000000) {
  decode_fields32(ENC_SHA1C_QSV_CRYPTOSHA3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA1C_QSV_CRYPTOSHA3); instr->operation = enc_to_oper(ENC_SHA1C_QSV_CRYPTOSHA3); rc = 0; };
 }
 return rc;
}


int SHA1H_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5E280800) {
  decode_fields32(ENC_SHA1H_SS_CRYPTOSHA2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA1H_SS_CRYPTOSHA2); instr->operation = enc_to_oper(ENC_SHA1H_SS_CRYPTOSHA2); rc = 0; };
 }
 return rc;
}


int SHA1M_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E002000) {
  decode_fields32(ENC_SHA1M_QSV_CRYPTOSHA3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA1M_QSV_CRYPTOSHA3); instr->operation = enc_to_oper(ENC_SHA1M_QSV_CRYPTOSHA3); rc = 0; };
 }
 return rc;
}


int SHA1P_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E001000) {
  decode_fields32(ENC_SHA1P_QSV_CRYPTOSHA3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA1P_QSV_CRYPTOSHA3); instr->operation = enc_to_oper(ENC_SHA1P_QSV_CRYPTOSHA3); rc = 0; };
 }
 return rc;
}


int SHA1SU0_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E003000) {
  decode_fields32(ENC_SHA1SU0_VVV_CRYPTOSHA3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA1SU0_VVV_CRYPTOSHA3); instr->operation = enc_to_oper(ENC_SHA1SU0_VVV_CRYPTOSHA3); rc = 0; };
 }
 return rc;
}


int SHA1SU1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5E281800) {
  decode_fields32(ENC_SHA1SU1_VV_CRYPTOSHA2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA1SU1_VV_CRYPTOSHA2); instr->operation = enc_to_oper(ENC_SHA1SU1_VV_CRYPTOSHA2); rc = 0; };
 }
 return rc;
}


int SHA256H2_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E005000) {
  decode_fields32(ENC_SHA256H2_QQV_CRYPTOSHA3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<29))) {
   { return -4; };
  }
  ctx->part1 = (ctx->P==0);
  {instr->encoding = (ENC_SHA256H2_QQV_CRYPTOSHA3); instr->operation = enc_to_oper(ENC_SHA256H2_QQV_CRYPTOSHA3); rc = 0; };
 }
 return rc;
}


int SHA256H_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E004000) {
  decode_fields32(ENC_SHA256H_QQV_CRYPTOSHA3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<29))) {
   { return -4; };
  }
  ctx->part1 = (ctx->P==0);
  {instr->encoding = (ENC_SHA256H_QQV_CRYPTOSHA3); instr->operation = enc_to_oper(ENC_SHA256H_QQV_CRYPTOSHA3); rc = 0; };
 }
 return rc;
}


int SHA256SU0_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x5E282800) {
  decode_fields32(ENC_SHA256SU0_VV_CRYPTOSHA2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<29))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA256SU0_VV_CRYPTOSHA2); instr->operation = enc_to_oper(ENC_SHA256SU0_VV_CRYPTOSHA2); rc = 0; };
 }
 return rc;
}


int SHA256SU1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x5E006000) {
  decode_fields32(ENC_SHA256SU1_VVV_CRYPTOSHA3, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(!(ctx->features1 & ((uint64_t)1<<29))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SHA256SU1_VVV_CRYPTOSHA3); instr->operation = enc_to_oper(ENC_SHA256SU1_VVV_CRYPTOSHA3); rc = 0; };
 }
 return rc;
}


int SHA512H2_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xCE608400) {
  decode_fields32(ENC_SHA512H2_QQV_CRYPTOSHA512_3, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<31))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_SHA512H2_QQV_CRYPTOSHA512_3); instr->operation = enc_to_oper(ENC_SHA512H2_QQV_CRYPTOSHA512_3); rc = 0; };
 }
 return rc;
}


int SHA512H_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xCE608000) {
  decode_fields32(ENC_SHA512H_QQV_CRYPTOSHA512_3, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<31))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_SHA512H_QQV_CRYPTOSHA512_3); instr->operation = enc_to_oper(ENC_SHA512H_QQV_CRYPTOSHA512_3); rc = 0; };
 }
 return rc;
}


int SHA512SU0_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xCEC08000) {
  decode_fields32(ENC_SHA512SU0_VV2_CRYPTOSHA512_2, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<31))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  {instr->encoding = (ENC_SHA512SU0_VV2_CRYPTOSHA512_2); instr->operation = enc_to_oper(ENC_SHA512SU0_VV2_CRYPTOSHA512_2); rc = 0; };
 }
 return rc;
}


int SHA512SU1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xCE608800) {
  decode_fields32(ENC_SHA512SU1_VVV2_CRYPTOSHA512_3, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<31))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_SHA512SU1_VVV2_CRYPTOSHA512_3); instr->operation = enc_to_oper(ENC_SHA512SU1_VVV2_CRYPTOSHA512_3); rc = 0; };
 }
 return rc;
}


int SHADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE200400) {
  decode_fields32(ENC_SHADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SHADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SHADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SHLL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E213800) {
  decode_fields32(ENC_SHLL_ASIMDMISC_S, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ctx->esize;
  ctx->unsigned_ = 
# 21087 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 21087 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SHLL_ASIMDMISC_S); instr->operation = enc_to_oper(ENC_SHLL_ASIMDMISC_S); rc = 0; };
 }
 return rc;
}


int SHL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F005400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SHL_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  {instr->encoding = (ENC_SHL_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SHL_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF005400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SHL_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  {instr->encoding = (ENC_SHL_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SHL_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SHRN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF80FC00)==0xF008400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SHRN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SHRN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_SHRN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int SHSUB_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE202400) {
  decode_fields32(ENC_SHSUB_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SHSUB_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SHSUB_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SLI_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F005400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SLI_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  {instr->encoding = (ENC_SLI_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SLI_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F005400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SLI_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  {instr->encoding = (ENC_SLI_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SLI_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SM3PARTW1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xCE60C000) {
  decode_fields32(ENC_SM3PARTW1_VVV4_CRYPTOSHA512_3, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<32))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_SM3PARTW1_VVV4_CRYPTOSHA512_3); instr->operation = enc_to_oper(ENC_SM3PARTW1_VVV4_CRYPTOSHA512_3); rc = 0; };
 }
 return rc;
}


int SM3PARTW2_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xCE60C400) {
  decode_fields32(ENC_SM3PARTW2_VVV4_CRYPTOSHA512_3, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<32))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_SM3PARTW2_VVV4_CRYPTOSHA512_3); instr->operation = enc_to_oper(ENC_SM3PARTW2_VVV4_CRYPTOSHA512_3); rc = 0; };
 }
 return rc;
}


int SM3SS1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0xCE400000) {
  decode_fields32(ENC_SM3SS1_VVV4_CRYPTO4, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<32))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  {instr->encoding = (ENC_SM3SS1_VVV4_CRYPTO4); instr->operation = enc_to_oper(ENC_SM3SS1_VVV4_CRYPTO4); rc = 0; };
 }
 return rc;
}


int SM3TT1A_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0CC00)==0xCE408000) {
  decode_fields32(ENC_SM3TT1A_VVV4_CRYPTO3_IMM2, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<32))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->i = (unsigned int)(ctx->imm2);
  {instr->encoding = (ENC_SM3TT1A_VVV4_CRYPTO3_IMM2); instr->operation = enc_to_oper(ENC_SM3TT1A_VVV4_CRYPTO3_IMM2); rc = 0; };
 }
 return rc;
}


int SM3TT1B_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0CC00)==0xCE408400) {
  decode_fields32(ENC_SM3TT1B_VVV4_CRYPTO3_IMM2, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<32))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->i = (unsigned int)(ctx->imm2);
  {instr->encoding = (ENC_SM3TT1B_VVV4_CRYPTO3_IMM2); instr->operation = enc_to_oper(ENC_SM3TT1B_VVV4_CRYPTO3_IMM2); rc = 0; };
 }
 return rc;
}


int SM3TT2A_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0CC00)==0xCE408800) {
  decode_fields32(ENC_SM3TT2A_VVV4_CRYPTO3_IMM2, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<32))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->i = (unsigned int)(ctx->imm2);
  {instr->encoding = (ENC_SM3TT2A_VVV4_CRYPTO3_IMM2); instr->operation = enc_to_oper(ENC_SM3TT2A_VVV4_CRYPTO3_IMM2); rc = 0; };
 }
 return rc;
}


int SM3TT2B_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0CC00)==0xCE408C00) {
  decode_fields32(ENC_SM3TT2B_VVV_CRYPTO3_IMM2, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<32))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->i = (unsigned int)(ctx->imm2);
  {instr->encoding = (ENC_SM3TT2B_VVV_CRYPTO3_IMM2); instr->operation = enc_to_oper(ENC_SM3TT2B_VVV_CRYPTO3_IMM2); rc = 0; };
 }
 return rc;
}


int SM4EKEY_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xCE60C800) {
  decode_fields32(ENC_SM4EKEY_VVV4_CRYPTOSHA512_3, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<33))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_SM4EKEY_VVV4_CRYPTOSHA512_3); instr->operation = enc_to_oper(ENC_SM4EKEY_VVV4_CRYPTOSHA512_3); rc = 0; };
 }
 return rc;
}


int SM4E_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xCEC08400) {
  decode_fields32(ENC_SM4E_VV4_CRYPTOSHA512_2, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<33))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  {instr->encoding = (ENC_SM4E_VV4_CRYPTOSHA512_2); instr->operation = enc_to_oper(ENC_SM4E_VV4_CRYPTOSHA512_2); rc = 0; };
 }
 return rc;
}


int SMADDL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x9B200000) {
  decode_fields32(ENC_SMADDL_64WA_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = 0x40;
  ctx->datasize = 0x20;
  ctx->sub_op = (ctx->o0==1);
  ctx->unsigned_ = (ctx->U==1);

  if(ctx->Ra==0x1f) return SMULL_SMADDL(ctx, instr);
  {instr->encoding = (ENC_SMADDL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_SMADDL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int SMAXP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE20A400) {
  decode_fields32(ENC_SMAXP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_SMAXP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SMAXP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SMAXV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE30A800) {
  decode_fields32(ENC_SMAXV_ASIMDALL_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==4) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->min = (ctx->op==1);
  {instr->encoding = (ENC_SMAXV_ASIMDALL_ONLY); instr->operation = enc_to_oper(ENC_SMAXV_ASIMDALL_ONLY); rc = 0; };
 }
 return rc;
}


int SMAX_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE206400) {
  decode_fields32(ENC_SMAX_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_SMAX_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SMAX_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SMC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4000003) {
  decode_fields32(ENC_SMC_EX_EXCEPTION, ctx, instr);
  {instr->encoding = (ENC_SMC_EX_EXCEPTION); instr->operation = enc_to_oper(ENC_SMC_EX_EXCEPTION); rc = 0; };
 }
 return rc;
}


int SMINP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE20AC00) {
  decode_fields32(ENC_SMINP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_SMINP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SMINP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SMINV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE31A800) {
  decode_fields32(ENC_SMINV_ASIMDALL_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==4) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->min = (ctx->op==1);
  {instr->encoding = (ENC_SMINV_ASIMDALL_ONLY); instr->operation = enc_to_oper(ENC_SMINV_ASIMDALL_ONLY); rc = 0; };
 }
 return rc;
}


int SMIN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE206C00) {
  decode_fields32(ENC_SMIN_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_SMIN_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SMIN_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SMLAL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0xF002000) {
  decode_fields32(ENC_SMLAL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_SMLAL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_SMLAL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int SMLAL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE208000) {
  decode_fields32(ENC_SMLAL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SMLAL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SMLAL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SMLSL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0xF006000) {
  decode_fields32(ENC_SMLSL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_SMLSL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_SMLSL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int SMLSL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE20A000) {
  decode_fields32(ENC_SMLSL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SMLSL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SMLSL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SMMLA_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4E80A400) {
  decode_fields32(ENC_SMMLA_ASIMDSAME2_G, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  if(!((ctx->B<<1)|ctx->U)) {
   ctx->op1_unsigned = 
# 21712 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 21712 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->op2_unsigned = 
# 21713 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 21713 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->B<<1)|ctx->U)==1) {
   ctx->op1_unsigned = 
# 21716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 21716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->op2_unsigned = 
# 21717 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 21717 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->B<<1)|ctx->U)==2) {
   ctx->op1_unsigned = 
# 21720 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 21720 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->op2_unsigned = 
# 21721 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 21721 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->B<<1)|ctx->U)==3) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  {instr->encoding = (ENC_SMMLA_ASIMDSAME2_G); instr->operation = enc_to_oper(ENC_SMMLA_ASIMDSAME2_G); rc = 0; };
 }
 return rc;
}


int SMNEGL_SMSUBL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9B20FC00) {
  decode_fields32(ENC_SMNEGL_SMSUBL_64WA_DP_3SRC, ctx, instr);
  {instr->encoding = (ENC_SMNEGL_SMSUBL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_SMNEGL_SMSUBL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int SMOV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE002C00) {
  decode_fields32(ENC_SMOV_ASIMDINS_W_W, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->Q<<5)|ctx->imm5)&1) {
   ctx->size = 0;
  }
  else if((((ctx->Q<<5)|ctx->imm5)&3)==2) {
   ctx->size = 1;
  }
  else if((((ctx->Q<<5)|ctx->imm5)&0x27)==0x24) {
   ctx->size = 2;
  }
  else {
   { return -4; };
  }
  ctx->idxdsize = ((((ctx->imm5)>>(4)) & (((uint64_t)1<<((4)-(4)+1))-1))==1) ? 0x80 : 0x40;
  ctx->index = (unsigned int)((((ctx->imm5)>>(ctx->size+1)) & (((uint64_t)1<<((4)-(ctx->size+1)+1))-1)));
  ctx->esize = (8) << (ctx->size);
  ctx->datasize = (ctx->Q==1) ? 0x40 : 0x20;
  if(ctx->Q==0) {instr->encoding = (ENC_SMOV_ASIMDINS_W_W); instr->operation = enc_to_oper(ENC_SMOV_ASIMDINS_W_W); rc = 0; };
  if(ctx->Q==1) {instr->encoding = (ENC_SMOV_ASIMDINS_X_X); instr->operation = enc_to_oper(ENC_SMOV_ASIMDINS_X_X); rc = 0; };
 }
 return rc;
}


int SMSUBL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x9B208000) {
  decode_fields32(ENC_SMSUBL_64WA_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = 0x40;
  ctx->datasize = 0x20;
  ctx->sub_op = (ctx->o0==1);
  ctx->unsigned_ = (ctx->U==1);

  if(ctx->Ra==0x1f) return SMNEGL_SMSUBL(ctx, instr);
  {instr->encoding = (ENC_SMSUBL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_SMSUBL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int SMULH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x9B400000) {
  decode_fields32(ENC_SMULH_64_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = 0x40;
  ctx->datasize = ctx->destsize;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SMULH_64_DP_3SRC); instr->operation = enc_to_oper(ENC_SMULH_64_DP_3SRC); rc = 0; };
 }
 return rc;
}


int SMULL_SMADDL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9B207C00) {
  decode_fields32(ENC_SMULL_SMADDL_64WA_DP_3SRC, ctx, instr);
  {instr->encoding = (ENC_SMULL_SMADDL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_SMULL_SMADDL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int SMULL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0xF00A000) {
  decode_fields32(ENC_SMULL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SMULL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_SMULL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int SMULL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE20C000) {
  decode_fields32(ENC_SMULL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SMULL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SMULL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SQABS_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E207800) {
  decode_fields32(ENC_SQABS_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_SQABS_ASISDMISC_R); instr->operation = enc_to_oper(ENC_SQABS_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0xE207800) {
  decode_fields32(ENC_SQABS_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_SQABS_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_SQABS_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int SQADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E200C00) {
  decode_fields32(ENC_SQADD_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQADD_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQADD_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE200C00) {
  decode_fields32(ENC_SQADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SQDMLAL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF00F400)==0x5F003000) {
  decode_fields32(ENC_SQDMLAL_ASISDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_SQDMLAL_ASISDELEM_L); instr->operation = enc_to_oper(ENC_SQDMLAL_ASISDELEM_L); rc = 0; };
 }


 if(((ctx->insword) & 0xBF00F400)==0xF003000) {
  decode_fields32(ENC_SQDMLAL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_SQDMLAL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_SQDMLAL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int SQDMLAL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E209000) {
  decode_fields32(ENC_SQDMLAL_ASISDDIFF_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0 || ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->sub_op = (ctx->o1==1);
  {instr->encoding = (ENC_SQDMLAL_ASISDDIFF_ONLY); instr->operation = enc_to_oper(ENC_SQDMLAL_ASISDDIFF_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE209000) {
  decode_fields32(ENC_SQDMLAL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0 || ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  {instr->encoding = (ENC_SQDMLAL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SQDMLAL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SQDMLSL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF00F400)==0x5F007000) {
  decode_fields32(ENC_SQDMLSL_ASISDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_SQDMLSL_ASISDELEM_L); instr->operation = enc_to_oper(ENC_SQDMLSL_ASISDELEM_L); rc = 0; };
 }


 if(((ctx->insword) & 0xBF00F400)==0xF007000) {
  decode_fields32(ENC_SQDMLSL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_SQDMLSL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_SQDMLSL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int SQDMLSL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E20B000) {
  decode_fields32(ENC_SQDMLSL_ASISDDIFF_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0 || ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->sub_op = (ctx->o1==1);
  {instr->encoding = (ENC_SQDMLSL_ASISDDIFF_ONLY); instr->operation = enc_to_oper(ENC_SQDMLSL_ASISDDIFF_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE20B000) {
  decode_fields32(ENC_SQDMLSL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0 || ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  {instr->encoding = (ENC_SQDMLSL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SQDMLSL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SQDMULH_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF00F400)==0x5F00C000) {
  decode_fields32(ENC_SQDMULH_ASISDELEM_R, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQDMULH_ASISDELEM_R); instr->operation = enc_to_oper(ENC_SQDMULH_ASISDELEM_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF00F400)==0xF00C000) {
  decode_fields32(ENC_SQDMULH_ASIMDELEM_R, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQDMULH_ASIMDELEM_R); instr->operation = enc_to_oper(ENC_SQDMULH_ASIMDELEM_R); rc = 0; };
 }
 return rc;
}


int SQDMULH_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E20B400) {
  decode_fields32(ENC_SQDMULH_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = (ctx->U==1);
  {instr->encoding = (ENC_SQDMULH_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQDMULH_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE20B400) {
  decode_fields32(ENC_SQDMULH_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = (ctx->U==1);
  {instr->encoding = (ENC_SQDMULH_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQDMULH_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SQDMULL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF00F400)==0x5F00B000) {
  decode_fields32(ENC_SQDMULL_ASISDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  {instr->encoding = (ENC_SQDMULL_ASISDELEM_L); instr->operation = enc_to_oper(ENC_SQDMULL_ASISDELEM_L); rc = 0; };
 }


 if(((ctx->insword) & 0xBF00F400)==0xF00B000) {
  decode_fields32(ENC_SQDMULL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_SQDMULL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_SQDMULL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int SQDMULL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E20D000) {
  decode_fields32(ENC_SQDMULL_ASISDDIFF_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0 || ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  {instr->encoding = (ENC_SQDMULL_ASISDDIFF_ONLY); instr->operation = enc_to_oper(ENC_SQDMULL_ASISDDIFF_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE20D000) {
  decode_fields32(ENC_SQDMULL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==0 || ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_SQDMULL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SQDMULL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SQNEG_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x7E207800) {
  decode_fields32(ENC_SQNEG_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_SQNEG_ASISDMISC_R); instr->operation = enc_to_oper(ENC_SQNEG_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0x2E207800) {
  decode_fields32(ENC_SQNEG_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->neg = (ctx->U==1);
  {instr->encoding = (ENC_SQNEG_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_SQNEG_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int SQRDMLAH_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF00F400)==0x7F00D000) {
  decode_fields32(ENC_SQRDMLAH_ASISDELEM_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = 
# 22417 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22417 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLAH_ASISDELEM_R); instr->operation = enc_to_oper(ENC_SQRDMLAH_ASISDELEM_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF00F400)==0x2F00D000) {
  decode_fields32(ENC_SQRDMLAH_ASIMDELEM_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = 
# 22446 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22446 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLAH_ASIMDELEM_R); instr->operation = enc_to_oper(ENC_SQRDMLAH_ASIMDELEM_R); rc = 0; };
 }
 return rc;
}


int SQRDMLAH_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E008400) {
  decode_fields32(ENC_SQRDMLAH_ASISDSAME2_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = 
# 22473 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22473 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLAH_ASISDSAME2_ONLY); instr->operation = enc_to_oper(ENC_SQRDMLAH_ASISDSAME2_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E008400) {
  decode_fields32(ENC_SQRDMLAH_ASIMDSAME2_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = 
# 22493 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22493 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLAH_ASIMDSAME2_ONLY); instr->operation = enc_to_oper(ENC_SQRDMLAH_ASIMDSAME2_ONLY); rc = 0; };
 }
 return rc;
}


int SQRDMLSH_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF00F400)==0x7F00F000) {
  decode_fields32(ENC_SQRDMLSH_ASISDELEM_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = 
# 22529 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22529 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLSH_ASISDELEM_R); instr->operation = enc_to_oper(ENC_SQRDMLSH_ASISDELEM_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF00F400)==0x2F00F000) {
  decode_fields32(ENC_SQRDMLSH_ASIMDELEM_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = 
# 22558 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22558 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLSH_ASIMDELEM_R); instr->operation = enc_to_oper(ENC_SQRDMLSH_ASIMDELEM_R); rc = 0; };
 }
 return rc;
}


int SQRDMLSH_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E008C00) {
  decode_fields32(ENC_SQRDMLSH_ASISDSAME2_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = 
# 22585 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22585 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLSH_ASISDSAME2_ONLY); instr->operation = enc_to_oper(ENC_SQRDMLSH_ASISDSAME2_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E008C00) {
  decode_fields32(ENC_SQRDMLSH_ASIMDSAME2_ONLY, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<25))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = 
# 22605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 22605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->sub_op = (ctx->S==1);
  {instr->encoding = (ENC_SQRDMLSH_ASIMDSAME2_ONLY); instr->operation = enc_to_oper(ENC_SQRDMLSH_ASIMDSAME2_ONLY); rc = 0; };
 }
 return rc;
}


int SQRDMULH_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF00F400)==0x5F00D000) {
  decode_fields32(ENC_SQRDMULH_ASISDELEM_R, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQRDMULH_ASISDELEM_R); instr->operation = enc_to_oper(ENC_SQRDMULH_ASISDELEM_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF00F400)==0xF00D000) {
  decode_fields32(ENC_SQRDMULH_ASIMDELEM_R, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQRDMULH_ASIMDELEM_R); instr->operation = enc_to_oper(ENC_SQRDMULH_ASIMDELEM_R); rc = 0; };
 }
 return rc;
}


int SQRDMULH_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E20B400) {
  decode_fields32(ENC_SQRDMULH_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->rounding = (ctx->U==1);
  {instr->encoding = (ENC_SQRDMULH_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQRDMULH_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E20B400) {
  decode_fields32(ENC_SQRDMULH_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3 || ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->rounding = (ctx->U==1);
  {instr->encoding = (ENC_SQRDMULH_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQRDMULH_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SQRSHL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E205C00) {
  decode_fields32(ENC_SQRSHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_SQRSHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQRSHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE205C00) {
  decode_fields32(ENC_SQRSHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_SQRSHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQRSHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SQRSHRN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F009C00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQRSHRN_ASISDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQRSHRN_ASISDSHF_N); instr->operation = enc_to_oper(ENC_SQRSHRN_ASISDSHF_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF009C00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQRSHRN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQRSHRN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_SQRSHRN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int SQRSHRUN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F008C00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQRSHRUN_ASISDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQRSHRUN_ASISDSHF_N); instr->operation = enc_to_oper(ENC_SQRSHRUN_ASISDSHF_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F008C00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQRSHRUN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQRSHRUN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_SQRSHRUN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int SQSHLU_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F006400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHLU_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  if(!((ctx->op<<1)|ctx->U)) {
   { return -4; };
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->src_unsigned = 
# 22868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22869 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22869 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->src_unsigned = 
# 22872 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22872 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22873 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22873 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->src_unsigned = 
# 22876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->dst_unsigned = 
# 22877 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22877 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  {instr->encoding = (ENC_SQSHLU_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SQSHLU_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F006400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHLU_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  if(!((ctx->op<<1)|ctx->U)) {
   { return -4; };
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->src_unsigned = 
# 22901 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22901 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22902 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22902 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->src_unsigned = 
# 22905 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22905 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22906 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22906 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->src_unsigned = 
# 22909 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22909 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->dst_unsigned = 
# 22910 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22910 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  {instr->encoding = (ENC_SQSHLU_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SQSHLU_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SQSHL_advsimd_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F007400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHL_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  if(!((ctx->op<<1)|ctx->U)) {
   { return -4; };
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->src_unsigned = 
# 22938 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22938 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22939 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22939 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->src_unsigned = 
# 22942 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22942 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22943 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22943 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->src_unsigned = 
# 22946 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22946 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->dst_unsigned = 
# 22947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  {instr->encoding = (ENC_SQSHL_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SQSHL_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF007400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHL_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  if(!((ctx->op<<1)|ctx->U)) {
   { return -4; };
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->src_unsigned = 
# 22971 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22971 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22972 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22972 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->src_unsigned = 
# 22975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 22976 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 22976 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->src_unsigned = 
# 22979 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22979 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->dst_unsigned = 
# 22980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 22980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  {instr->encoding = (ENC_SQSHL_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SQSHL_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SQSHL_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E204C00) {
  decode_fields32(ENC_SQSHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_SQSHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQSHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE204C00) {
  decode_fields32(ENC_SQSHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_SQSHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQSHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SQSHRN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F009400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHRN_ASISDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQSHRN_ASISDSHF_N); instr->operation = enc_to_oper(ENC_SQSHRN_ASISDSHF_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF009400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHRN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQSHRN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_SQSHRN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int SQSHRUN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F008400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHRUN_ASISDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQSHRUN_ASISDSHF_N); instr->operation = enc_to_oper(ENC_SQSHRUN_ASISDSHF_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F008400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SQSHRUN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  {instr->encoding = (ENC_SQSHRUN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_SQSHRUN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int SQSUB_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E202C00) {
  decode_fields32(ENC_SQSUB_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQSUB_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQSUB_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE202C00) {
  decode_fields32(ENC_SQSUB_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQSUB_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SQSUB_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SQXTN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E214800) {
  decode_fields32(ENC_SQXTN_ASISDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->part = 0;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQXTN_ASISDMISC_N); instr->operation = enc_to_oper(ENC_SQXTN_ASISDMISC_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0xE214800) {
  decode_fields32(ENC_SQXTN_ASIMDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SQXTN_ASIMDMISC_N); instr->operation = enc_to_oper(ENC_SQXTN_ASIMDMISC_N); rc = 0; };
 }
 return rc;
}


int SQXTUN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x7E212800) {
  decode_fields32(ENC_SQXTUN_ASISDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->part = 0;
  ctx->elements = 1;
  {instr->encoding = (ENC_SQXTUN_ASISDMISC_N); instr->operation = enc_to_oper(ENC_SQXTUN_ASISDMISC_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0x2E212800) {
  decode_fields32(ENC_SQXTUN_ASIMDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_SQXTUN_ASIMDMISC_N); instr->operation = enc_to_oper(ENC_SQXTUN_ASIMDMISC_N); rc = 0; };
 }
 return rc;
}


int SRHADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE201400) {
  decode_fields32(ENC_SRHADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SRHADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SRHADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SRI_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F004400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SRI_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  {instr->encoding = (ENC_SRI_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SRI_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F004400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SRI_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  {instr->encoding = (ENC_SRI_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SRI_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SRSHL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E205400) {
  decode_fields32(ENC_SRSHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_SRSHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SRSHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE205400) {
  decode_fields32(ENC_SRSHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_SRSHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SRSHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SRSHR_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F002400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SRSHR_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SRSHR_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SRSHR_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF002400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SRSHR_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SRSHR_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SRSHR_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SRSRA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F003400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SRSRA_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SRSRA_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SRSRA_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF003400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SRSRA_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SRSRA_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SRSRA_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SSBB_DSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503309F) {
  decode_fields32(ENC_SSBB_DSB_BO_BARRIERS, ctx, instr);
  {instr->encoding = (ENC_SSBB_DSB_BO_BARRIERS); instr->operation = enc_to_oper(ENC_SSBB_DSB_BO_BARRIERS); rc = 0; };
 }
 return rc;
}


int SSHLL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF80FC00)==0xF00A400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SSHLL_ASIMDSHF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  ctx->unsigned_ = (ctx->U==1);

  if(ctx->immb==0 && BitCount(ctx->immh)==1) return SXTL_SSHLL_advsimd(ctx, instr);
  {instr->encoding = (ENC_SSHLL_ASIMDSHF_L); instr->operation = enc_to_oper(ENC_SSHLL_ASIMDSHF_L); rc = 0; };
 }
 return rc;
}


int SSHL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5E204400) {
  decode_fields32(ENC_SSHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_SSHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SSHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0xE204400) {
  decode_fields32(ENC_SSHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_SSHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SSHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SSHR_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F000400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SSHR_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SSHR_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SSHR_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF000400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SSHR_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SSHR_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SSHR_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SSRA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x5F001400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SSRA_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SSRA_ASISDSHF_R); instr->operation = enc_to_oper(ENC_SSRA_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0xF001400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SSRA_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_SSRA_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_SSRA_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int SSUBL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE202000) {
  decode_fields32(ENC_SSUBL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SSUBL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_SSUBL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int SSUBW_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE203000) {
  decode_fields32(ENC_SSUBW_ASIMDDIFF_W, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SSUBW_ASIMDDIFF_W); instr->operation = enc_to_oper(ENC_SSUBW_ASIMDDIFF_W); rc = 0; };
 }
 return rc;
}


int ST1_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xC002000) {
  decode_fields32(ENC_ST1_ASISDLSE_R1_1V, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 23674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 23674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==7) {instr->encoding = (ENC_ST1_ASISDLSE_R1_1V); instr->operation = enc_to_oper(ENC_ST1_ASISDLSE_R1_1V); rc = 0; };
  if(ctx->opcode==10) {instr->encoding = (ENC_ST1_ASISDLSE_R2_2V); instr->operation = enc_to_oper(ENC_ST1_ASISDLSE_R2_2V); rc = 0; };
  if(ctx->opcode==6) {instr->encoding = (ENC_ST1_ASISDLSE_R3_3V); instr->operation = enc_to_oper(ENC_ST1_ASISDLSE_R3_3V); rc = 0; };
  if(ctx->opcode==2) {instr->encoding = (ENC_ST1_ASISDLSE_R4_4V); instr->operation = enc_to_oper(ENC_ST1_ASISDLSE_R4_4V); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xC802000) {
  decode_fields32(ENC_ST1_ASISDLSEP_I1_I1, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 23688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 23688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==7) {instr->encoding = (ENC_ST1_ASISDLSEP_I1_I1); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_I1_I1); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==7) {instr->encoding = (ENC_ST1_ASISDLSEP_R1_R1); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_R1_R1); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==10) {instr->encoding = (ENC_ST1_ASISDLSEP_I2_I2); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_I2_I2); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==10) {instr->encoding = (ENC_ST1_ASISDLSEP_R2_R2); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_R2_R2); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==6) {instr->encoding = (ENC_ST1_ASISDLSEP_I3_I3); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_I3_I3); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==6) {instr->encoding = (ENC_ST1_ASISDLSEP_R3_R3); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_R3_R3); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==2) {instr->encoding = (ENC_ST1_ASISDLSEP_I4_I4); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_I4_I4); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==2) {instr->encoding = (ENC_ST1_ASISDLSEP_R4_R4); instr->operation = enc_to_oper(ENC_ST1_ASISDLSEP_R4_R4); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int ST1_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD000000) {
  decode_fields32(ENC_ST1_ASISDLSO_B1_1B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 23752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 23752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==0) {instr->encoding = (ENC_ST1_ASISDLSO_B1_1B); instr->operation = enc_to_oper(ENC_ST1_ASISDLSO_B1_1B); rc = 0; };
  if(ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_ST1_ASISDLSO_H1_1H); instr->operation = enc_to_oper(ENC_ST1_ASISDLSO_H1_1H); rc = 0; };
  if(ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_ST1_ASISDLSO_S1_1S); instr->operation = enc_to_oper(ENC_ST1_ASISDLSO_S1_1S); rc = 0; };
  if(ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST1_ASISDLSO_D1_1D); instr->operation = enc_to_oper(ENC_ST1_ASISDLSO_D1_1D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xD800000) {
  decode_fields32(ENC_ST1_ASISDLSOP_B1_I1B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 23766 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 23766 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==0) {instr->encoding = (ENC_ST1_ASISDLSOP_B1_I1B); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_B1_I1B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==0) {instr->encoding = (ENC_ST1_ASISDLSOP_BX1_R1B); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_BX1_R1B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_ST1_ASISDLSOP_H1_I1H); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_H1_I1H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_ST1_ASISDLSOP_HX1_R1H); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_HX1_R1H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_ST1_ASISDLSOP_S1_I1S); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_S1_I1S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_ST1_ASISDLSOP_SX1_R1S); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_SX1_R1S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST1_ASISDLSOP_D1_I1D); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_D1_I1D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST1_ASISDLSOP_DX1_R1D); instr->operation = enc_to_oper(ENC_ST1_ASISDLSOP_DX1_R1D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 23781 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 23781 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 23787 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 23787 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int ST2G(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xD9A00400) {
  decode_fields32(ENC_ST2G_64SPOST_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 23833 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 23833 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 23834 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 23834 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->zero_data = 
# 23835 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 23835 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_ST2G_64SPOST_LDSTTAGS); instr->operation = enc_to_oper(ENC_ST2G_64SPOST_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9A00C00) {
  decode_fields32(ENC_ST2G_64SPRE_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 23848 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 23848 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 23849 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 23849 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 23850 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 23850 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_ST2G_64SPRE_LDSTTAGS); instr->operation = enc_to_oper(ENC_ST2G_64SPRE_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9A00800) {
  decode_fields32(ENC_ST2G_64SOFFSET_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 23863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 23863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->postindex = 
# 23864 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 23864 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 23865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 23865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_ST2G_64SOFFSET_LDSTTAGS); instr->operation = enc_to_oper(ENC_ST2G_64SOFFSET_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int ST2_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xC008000) {
  decode_fields32(ENC_ST2_ASISDLSE_R2, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 23882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 23882 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_ST2_ASISDLSE_R2); instr->operation = enc_to_oper(ENC_ST2_ASISDLSE_R2); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xC808000) {
  decode_fields32(ENC_ST2_ASISDLSEP_I2_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 23893 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 23893 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_ST2_ASISDLSEP_I2_I); instr->operation = enc_to_oper(ENC_ST2_ASISDLSEP_I2_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_ST2_ASISDLSEP_R2_R); instr->operation = enc_to_oper(ENC_ST2_ASISDLSEP_R2_R); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int ST2_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD200000) {
  decode_fields32(ENC_ST2_ASISDLSO_B2_2B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 23951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 23951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==0) {instr->encoding = (ENC_ST2_ASISDLSO_B2_2B); instr->operation = enc_to_oper(ENC_ST2_ASISDLSO_B2_2B); rc = 0; };
  if(ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_ST2_ASISDLSO_H2_2H); instr->operation = enc_to_oper(ENC_ST2_ASISDLSO_H2_2H); rc = 0; };
  if(ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_ST2_ASISDLSO_S2_2S); instr->operation = enc_to_oper(ENC_ST2_ASISDLSO_S2_2S); rc = 0; };
  if(ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST2_ASISDLSO_D2_2D); instr->operation = enc_to_oper(ENC_ST2_ASISDLSO_D2_2D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xDA00000) {
  decode_fields32(ENC_ST2_ASISDLSOP_B2_I2B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 23965 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 23965 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==0) {instr->encoding = (ENC_ST2_ASISDLSOP_B2_I2B); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_B2_I2B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==0) {instr->encoding = (ENC_ST2_ASISDLSOP_BX2_R2B); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_BX2_R2B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_ST2_ASISDLSOP_H2_I2H); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_H2_I2H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==2 && !(ctx->size&1)) {instr->encoding = (ENC_ST2_ASISDLSOP_HX2_R2H); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_HX2_R2H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_ST2_ASISDLSOP_S2_I2S); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_S2_I2S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->size==0) {instr->encoding = (ENC_ST2_ASISDLSOP_SX2_R2S); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_SX2_R2S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST2_ASISDLSOP_D2_I2D); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_D2_I2D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==4 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST2_ASISDLSOP_DX2_R2D); instr->operation = enc_to_oper(ENC_ST2_ASISDLSOP_DX2_R2D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 23980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 23980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 23986 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 23986 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int ST3_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xC004000) {
  decode_fields32(ENC_ST3_ASISDLSE_R3, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 24029 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 24029 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_ST3_ASISDLSE_R3); instr->operation = enc_to_oper(ENC_ST3_ASISDLSE_R3); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xC804000) {
  decode_fields32(ENC_ST3_ASISDLSEP_I3_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 24040 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 24040 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_ST3_ASISDLSEP_I3_I); instr->operation = enc_to_oper(ENC_ST3_ASISDLSEP_I3_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_ST3_ASISDLSEP_R3_R); instr->operation = enc_to_oper(ENC_ST3_ASISDLSEP_R3_R); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int ST3_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD002000) {
  decode_fields32(ENC_ST3_ASISDLSO_B3_3B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 24098 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 24098 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==1) {instr->encoding = (ENC_ST3_ASISDLSO_B3_3B); instr->operation = enc_to_oper(ENC_ST3_ASISDLSO_B3_3B); rc = 0; };
  if(ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_ST3_ASISDLSO_H3_3H); instr->operation = enc_to_oper(ENC_ST3_ASISDLSO_H3_3H); rc = 0; };
  if(ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_ST3_ASISDLSO_S3_3S); instr->operation = enc_to_oper(ENC_ST3_ASISDLSO_S3_3S); rc = 0; };
  if(ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST3_ASISDLSO_D3_3D); instr->operation = enc_to_oper(ENC_ST3_ASISDLSO_D3_3D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xD802000) {
  decode_fields32(ENC_ST3_ASISDLSOP_B3_I3B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 24112 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 24112 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==1) {instr->encoding = (ENC_ST3_ASISDLSOP_B3_I3B); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_B3_I3B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==1) {instr->encoding = (ENC_ST3_ASISDLSOP_BX3_R3B); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_BX3_R3B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_ST3_ASISDLSOP_H3_I3H); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_H3_I3H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_ST3_ASISDLSOP_HX3_R3H); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_HX3_R3H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_ST3_ASISDLSOP_S3_I3S); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_S3_I3S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_ST3_ASISDLSOP_SX3_R3S); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_SX3_R3S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST3_ASISDLSOP_D3_I3D); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_D3_I3D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST3_ASISDLSOP_DX3_R3D); instr->operation = enc_to_oper(ENC_ST3_ASISDLSOP_DX3_R3D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 24127 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 24127 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 24133 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24133 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int ST4_advsimd_mult(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFFF000)==0xC000000) {
  decode_fields32(ENC_ST4_ASISDLSE_R4, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 24176 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 24176 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  {instr->encoding = (ENC_ST4_ASISDLSE_R4); instr->operation = enc_to_oper(ENC_ST4_ASISDLSE_R4); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE0F000)==0xC800000) {
  decode_fields32(ENC_ST4_ASISDLSEP_I4_I, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 24187 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 24187 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f) {instr->encoding = (ENC_ST4_ASISDLSEP_I4_I); instr->operation = enc_to_oper(ENC_ST4_ASISDLSEP_I4_I); rc = 0; };
  if(ctx->Rm!=0x1f) {instr->encoding = (ENC_ST4_ASISDLSEP_R4_R); instr->operation = enc_to_oper(ENC_ST4_ASISDLSEP_R4_R); rc = 0; };
 }

 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << ((unsigned int)(ctx->size));
 ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
 if(!ctx->opcode) {
  ctx->rpt = 1;
  ctx->selem = 4;
 }
 else if(ctx->opcode==2) {
  ctx->rpt = 4;
  ctx->selem = 1;
 }
 else if(ctx->opcode==4) {
  ctx->rpt = 1;
  ctx->selem = 3;
 }
 else if(ctx->opcode==6) {
  ctx->rpt = 3;
  ctx->selem = 1;
 }
 else if(ctx->opcode==7) {
  ctx->rpt = 1;
  ctx->selem = 1;
 }
 else if(ctx->opcode==8) {
  ctx->rpt = 1;
  ctx->selem = 2;
 }
 else if(ctx->opcode==10) {
  ctx->rpt = 2;
  ctx->selem = 1;
 }
 else {
  { return -4; };
 }
 if(((ctx->size<<1)|ctx->Q)==6 && ctx->selem!=1) {
  { return -4; };
 }
 return rc;
}


int ST4_advsimd_sngl(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFFF2000)==0xD202000) {
  decode_fields32(ENC_ST4_ASISDLSO_B4_4B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = 0;
  ctx->wback = 
# 24245 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 24245 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->opcode==1) {instr->encoding = (ENC_ST4_ASISDLSO_B4_4B); instr->operation = enc_to_oper(ENC_ST4_ASISDLSO_B4_4B); rc = 0; };
  if(ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_ST4_ASISDLSO_H4_4H); instr->operation = enc_to_oper(ENC_ST4_ASISDLSO_H4_4H); rc = 0; };
  if(ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_ST4_ASISDLSO_S4_4S); instr->operation = enc_to_oper(ENC_ST4_ASISDLSO_S4_4S); rc = 0; };
  if(ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST4_ASISDLSO_D4_4D); instr->operation = enc_to_oper(ENC_ST4_ASISDLSO_D4_4D); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE02000)==0xDA02000) {
  decode_fields32(ENC_ST4_ASISDLSOP_B4_I4B, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->wback = 
# 24259 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 24259 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
  if(ctx->Rm==0x1f && ctx->opcode==1) {instr->encoding = (ENC_ST4_ASISDLSOP_B4_I4B); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_B4_I4B); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==1) {instr->encoding = (ENC_ST4_ASISDLSOP_BX4_R4B); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_BX4_R4B); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_ST4_ASISDLSOP_H4_I4H); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_H4_I4H); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==3 && !(ctx->size&1)) {instr->encoding = (ENC_ST4_ASISDLSOP_HX4_R4H); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_HX4_R4H); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_ST4_ASISDLSOP_S4_I4S); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_S4_I4S); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->size==0) {instr->encoding = (ENC_ST4_ASISDLSOP_SX4_R4S); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_SX4_R4S); rc = 0; };
  if(ctx->Rm==0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST4_ASISDLSOP_D4_I4D); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_D4_I4D); rc = 0; };
  if(ctx->Rm!=0x1f && ctx->opcode==5 && ctx->S==0 && ctx->size==1) {instr->encoding = (ENC_ST4_ASISDLSOP_DX4_R4D); instr->operation = enc_to_oper(ENC_ST4_ASISDLSOP_DX4_R4D); rc = 0; };
 }

 ctx->init_scale = (unsigned int)((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
 ctx->scale = ctx->init_scale;
 ctx->selem = (unsigned int)((((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))<<1)|ctx->R))+1;
 ctx->replicate = 
# 24274 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 24274 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 if(ctx->scale==3) {
  if(ctx->L==0 || ctx->S==1) {
   { return -4; };
  }
  ctx->scale = (unsigned int)(ctx->size);
  ctx->replicate = 
# 24280 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24280 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
 }
 else if(ctx->scale==0) {
  ctx->index = (unsigned int)(((ctx->Q<<3)|(ctx->S<<2)|ctx->size));
 }
 else if(ctx->scale==1) {
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->index = (unsigned int)(((ctx->Q<<2)|(ctx->S<<1)|(((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))));
 }
 else if(ctx->scale==2) {
  if((((ctx->size)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1) {
   { return -4; };
  }
  if((((ctx->size)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==0) {
   ctx->index = (unsigned int)(((ctx->Q<<1)|ctx->S));
  }
  else {
   if(ctx->S==1) {
    { return -4; };
   }
   ctx->index = (unsigned int)(ctx->Q);
   ctx->scale = 3;
  }
 }
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
 ctx->esize = (8) << (ctx->scale);
 return rc;
}


int ST64B(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xF83F9000) {
  decode_fields32(ENC_ST64B_64L_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<13))) {
   { return -4; };
  }
  if((((ctx->Rt)>>(3)) & (((uint64_t)1<<((4)-(3)+1))-1))==3 || (((ctx->Rt)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_ST64B_64L_MEMOP); instr->operation = enc_to_oper(ENC_ST64B_64L_MEMOP); rc = 0; };
 }
 return rc;
}


int ST64BV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xF820B000) {
  decode_fields32(ENC_ST64BV_64_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<13))) {
   { return -4; };
  }
  if((((ctx->Rt)>>(3)) & (((uint64_t)1<<((4)-(3)+1))-1))==3 || (((ctx->Rt)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_ST64BV_64_MEMOP); instr->operation = enc_to_oper(ENC_ST64BV_64_MEMOP); rc = 0; };
 }
 return rc;
}


int ST64BV0(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xF820A000) {
  decode_fields32(ENC_ST64BV0_64_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<13))) {
   { return -4; };
  }
  if((((ctx->Rt)>>(3)) & (((uint64_t)1<<((4)-(3)+1))-1))==3 || (((ctx->Rt)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_ST64BV0_64_MEMOP); instr->operation = enc_to_oper(ENC_ST64BV0_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STADDB_LDADDB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820001F) {
  decode_fields32(ENC_STADDB_LDADDB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STADDB_LDADDB_32_MEMOP); instr->operation = enc_to_oper(ENC_STADDB_LDADDB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STADDLB_LDADDLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STADDLB_LDADDLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STADDH_LDADDH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820001F) {
  decode_fields32(ENC_STADDH_LDADDH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STADDH_LDADDH_32_MEMOP); instr->operation = enc_to_oper(ENC_STADDH_LDADDH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STADDLH_LDADDLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STADDLH_LDADDLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STADD_LDADD(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820001F) {
  decode_fields32(ENC_STADD_LDADD_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STADD_LDADD_32_MEMOP); instr->operation = enc_to_oper(ENC_STADD_LDADD_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STADDL_LDADDL_32_MEMOP); instr->operation = enc_to_oper(ENC_STADDL_LDADDL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STADD_LDADD_64_MEMOP); instr->operation = enc_to_oper(ENC_STADD_LDADD_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STADDL_LDADDL_64_MEMOP); instr->operation = enc_to_oper(ENC_STADDL_LDADDL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STCLRB_LDCLRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820101F) {
  decode_fields32(ENC_STCLRB_LDCLRB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STCLRB_LDCLRB_32_MEMOP); instr->operation = enc_to_oper(ENC_STCLRB_LDCLRB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STCLRLB_LDCLRLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STCLRLB_LDCLRLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STCLRH_LDCLRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820101F) {
  decode_fields32(ENC_STCLRH_LDCLRH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STCLRH_LDCLRH_32_MEMOP); instr->operation = enc_to_oper(ENC_STCLRH_LDCLRH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STCLRLH_LDCLRLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STCLRLH_LDCLRLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STCLR_LDCLR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820101F) {
  decode_fields32(ENC_STCLR_LDCLR_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STCLR_LDCLR_32_MEMOP); instr->operation = enc_to_oper(ENC_STCLR_LDCLR_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STCLRL_LDCLRL_32_MEMOP); instr->operation = enc_to_oper(ENC_STCLRL_LDCLRL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STCLR_LDCLR_64_MEMOP); instr->operation = enc_to_oper(ENC_STCLR_LDCLR_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STCLRL_LDCLRL_64_MEMOP); instr->operation = enc_to_oper(ENC_STCLRL_LDCLRL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STEORB_LDEORB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820201F) {
  decode_fields32(ENC_STEORB_LDEORB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STEORB_LDEORB_32_MEMOP); instr->operation = enc_to_oper(ENC_STEORB_LDEORB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STEORLB_LDEORLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STEORLB_LDEORLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STEORH_LDEORH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820201F) {
  decode_fields32(ENC_STEORH_LDEORH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STEORH_LDEORH_32_MEMOP); instr->operation = enc_to_oper(ENC_STEORH_LDEORH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STEORLH_LDEORLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STEORLH_LDEORLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STEOR_LDEOR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820201F) {
  decode_fields32(ENC_STEOR_LDEOR_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STEOR_LDEOR_32_MEMOP); instr->operation = enc_to_oper(ENC_STEOR_LDEOR_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STEORL_LDEORL_32_MEMOP); instr->operation = enc_to_oper(ENC_STEORL_LDEORL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STEOR_LDEOR_64_MEMOP); instr->operation = enc_to_oper(ENC_STEOR_LDEOR_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STEORL_LDEORL_64_MEMOP); instr->operation = enc_to_oper(ENC_STEORL_LDEORL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xD9200400) {
  decode_fields32(ENC_STG_64SPOST_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 24526 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24526 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 24527 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24527 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->zero_data = 
# 24528 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24528 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_STG_64SPOST_LDSTTAGS); instr->operation = enc_to_oper(ENC_STG_64SPOST_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9200C00) {
  decode_fields32(ENC_STG_64SPRE_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 24541 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24541 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 24542 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24542 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 24543 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24543 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_STG_64SPRE_LDSTTAGS); instr->operation = enc_to_oper(ENC_STG_64SPRE_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9200800) {
  decode_fields32(ENC_STG_64SOFFSET_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 24556 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24556 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->postindex = 
# 24557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 24558 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24558 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_STG_64SOFFSET_LDSTTAGS); instr->operation = enc_to_oper(ENC_STG_64SOFFSET_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int STGM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xD9A00000) {
  decode_fields32(ENC_STGM_64BULK_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<20))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->n = (unsigned int)(ctx->Xn);
  {instr->encoding = (ENC_STGM_64BULK_LDSTTAGS); instr->operation = enc_to_oper(ENC_STGM_64BULK_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int STGP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC00000)==0x68800000) {
  decode_fields32(ENC_STGP_64_LDSTPAIR_POST, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->t2 = (unsigned int)(ctx->Xt2);
  ctx->offset = ((SignExtend(ctx->simm7,7))<<(4));
  ctx->writeback = 
# 24597 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24597 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 24598 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24598 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_STGP_64_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_STGP_64_LDSTPAIR_POST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x69800000) {
  decode_fields32(ENC_STGP_64_LDSTPAIR_PRE, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->t2 = (unsigned int)(ctx->Xt2);
  ctx->offset = ((SignExtend(ctx->simm7,7))<<(4));
  ctx->writeback = 
# 24612 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 24612 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 24613 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24613 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_STGP_64_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_STGP_64_LDSTPAIR_PRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x69000000) {
  decode_fields32(ENC_STGP_64_LDSTPAIR_OFF, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->t2 = (unsigned int)(ctx->Xt2);
  ctx->offset = ((SignExtend(ctx->simm7,7))<<(4));
  ctx->writeback = 
# 24627 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24627 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->postindex = 
# 24628 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24628 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_STGP_64_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_STGP_64_LDSTPAIR_OFF); rc = 0; };
 }
 return rc;
}


int STLLR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88800000) {
  decode_fields32(ENC_STLLR_SL32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->size==2) {instr->encoding = (ENC_STLLR_SL32_LDSTORD); instr->operation = enc_to_oper(ENC_STLLR_SL32_LDSTORD); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STLLR_SL64_LDSTORD); instr->operation = enc_to_oper(ENC_STLLR_SL64_LDSTORD); rc = 0; };
 }
 return rc;
}


int STLLRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8800000) {
  decode_fields32(ENC_STLLRB_SL32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_STLLRB_SL32_LDSTORD); instr->operation = enc_to_oper(ENC_STLLRB_SL32_LDSTORD); rc = 0; };
 }
 return rc;
}


int STLLRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48800000) {
  decode_fields32(ENC_STLLRH_SL32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_STLLRH_SL32_LDSTORD); instr->operation = enc_to_oper(ENC_STLLRH_SL32_LDSTORD); rc = 0; };
 }
 return rc;
}


int STLR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88808000) {
  decode_fields32(ENC_STLR_SL32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->size==2) {instr->encoding = (ENC_STLR_SL32_LDSTORD); instr->operation = enc_to_oper(ENC_STLR_SL32_LDSTORD); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STLR_SL64_LDSTORD); instr->operation = enc_to_oper(ENC_STLR_SL64_LDSTORD); rc = 0; };
 }
 return rc;
}


int STLRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8808000) {
  decode_fields32(ENC_STLRB_SL32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_STLRB_SL32_LDSTORD); instr->operation = enc_to_oper(ENC_STLRB_SL32_LDSTORD); rc = 0; };
 }
 return rc;
}


int STLRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48808000) {
  decode_fields32(ENC_STLRH_SL32_LDSTORD, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==0) ? AccType_LIMITEDORDERED : AccType_ORDERED;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  {instr->encoding = (ENC_STLRH_SL32_LDSTORD); instr->operation = enc_to_oper(ENC_STLRH_SL32_LDSTORD); rc = 0; };
 }
 return rc;
}


int STLURB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x19000000) {
  decode_fields32(ENC_STLURB_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 24782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 24782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 24783 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24783 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STLURB_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_STLURB_32_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 24799 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 24799 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 24816 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 24816 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 24821 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24821 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 24822 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24822 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STLURH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x59000000) {
  decode_fields32(ENC_STLURH_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 24844 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 24844 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 24845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STLURH_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_STLURH_32_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 24861 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 24861 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 24878 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 24878 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 24883 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24883 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 24884 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24884 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STLUR_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0x99000000) {
  decode_fields32(ENC_STLUR_32_LDAPSTL_UNSCALED, ctx, instr);
  ctx->wback = 
# 24906 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 24906 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 24907 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24907 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_STLUR_32_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_STLUR_32_LDAPSTL_UNSCALED); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STLUR_64_LDAPSTL_UNSCALED); instr->operation = enc_to_oper(ENC_STLUR_64_LDAPSTL_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = AccType_ORDERED;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 24924 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 24924 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 24941 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 24941 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 24946 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24946 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 24947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 24947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STLXP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88208000) {
  decode_fields32(ENC_STLXP_SP32_LDSTEXCLP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 24974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 24974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 24980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 24980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 24981 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 24981 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->sz==0) {instr->encoding = (ENC_STLXP_SP32_LDSTEXCLP); instr->operation = enc_to_oper(ENC_STLXP_SP32_LDSTEXCLP); rc = 0; };
  if(ctx->sz==1) {instr->encoding = (ENC_STLXP_SP64_LDSTEXCLP); instr->operation = enc_to_oper(ENC_STLXP_SP64_LDSTEXCLP); rc = 0; };
 }
 return rc;
}


int STLXR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88008000) {
  decode_fields32(ENC_STLXR_SR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 25018 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 25018 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 25024 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 25024 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 25025 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 25025 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->size==2) {instr->encoding = (ENC_STLXR_SR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STLXR_SR32_LDSTEXCLR); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STLXR_SR64_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STLXR_SR64_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int STLXRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8008000) {
  decode_fields32(ENC_STLXRB_SR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 25062 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 25062 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 25068 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 25068 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 25069 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 25069 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_STLXRB_SR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STLXRB_SR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int STLXRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48008000) {
  decode_fields32(ENC_STLXRH_SR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 25105 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 25105 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 25111 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 25111 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 25112 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 25112 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_STLXRH_SR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STLXRH_SR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int STNP_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3FC00000)==0x2C000000) {
  decode_fields32(ENC_STNP_S_LDSTNAPAIR_OFFS, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STNP_S_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_STNP_S_LDSTNAPAIR_OFFS); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_STNP_D_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_STNP_D_LDSTNAPAIR_OFFS); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STNP_Q_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_STNP_Q_LDSTNAPAIR_OFFS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_VECSTREAM;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if(ctx->opc==3) {
  { return -4; };
 }
 ctx->scale = 2+(unsigned int)(ctx->opc);
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 25160 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25160 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int STNP_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FC00000)==0x28000000) {
  decode_fields32(ENC_STNP_32_LDSTNAPAIR_OFFS, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STNP_32_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_STNP_32_LDSTNAPAIR_OFFS); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STNP_64_LDSTNAPAIR_OFFS); instr->operation = enc_to_oper(ENC_STNP_64_LDSTNAPAIR_OFFS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_STREAM;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
  { return -4; };
 }
 ctx->scale = 2+(unsigned int)((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 25193 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25193 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int STP_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3FC00000)==0x2C800000) {
  decode_fields32(ENC_STP_S_LDSTPAIR_POST, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STP_S_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_STP_S_LDSTPAIR_POST); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_STP_D_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_STP_D_LDSTPAIR_POST); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STP_Q_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_STP_Q_LDSTPAIR_POST); rc = 0; };
 }


 if(((ctx->insword) & 0x3FC00000)==0x2D800000) {
  decode_fields32(ENC_STP_S_LDSTPAIR_PRE, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STP_S_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_STP_S_LDSTPAIR_PRE); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_STP_D_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_STP_D_LDSTPAIR_PRE); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STP_Q_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_STP_Q_LDSTPAIR_PRE); rc = 0; };
 }


 if(((ctx->insword) & 0x3FC00000)==0x2D000000) {
  decode_fields32(ENC_STP_S_LDSTPAIR_OFF, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STP_S_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_STP_S_LDSTPAIR_OFF); rc = 0; };
  if(ctx->opc==1) {instr->encoding = (ENC_STP_D_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_STP_D_LDSTPAIR_OFF); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STP_Q_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_STP_Q_LDSTPAIR_OFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if(ctx->opc==3) {
  { return -4; };
 }
 ctx->scale = 2+(unsigned int)(ctx->opc);
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 25243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int STP_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FC00000)==0x28800000) {
  decode_fields32(ENC_STP_32_LDSTPAIR_POST, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STP_32_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_STP_32_LDSTPAIR_POST); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STP_64_LDSTPAIR_POST); instr->operation = enc_to_oper(ENC_STP_64_LDSTPAIR_POST); rc = 0; };
 }


 if(((ctx->insword) & 0x7FC00000)==0x29800000) {
  decode_fields32(ENC_STP_32_LDSTPAIR_PRE, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STP_32_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_STP_32_LDSTPAIR_PRE); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STP_64_LDSTPAIR_PRE); instr->operation = enc_to_oper(ENC_STP_64_LDSTPAIR_PRE); rc = 0; };
 }


 if(((ctx->insword) & 0x7FC00000)==0x29000000) {
  decode_fields32(ENC_STP_32_LDSTPAIR_OFF, ctx, instr);
  if(ctx->opc==0) {instr->encoding = (ENC_STP_32_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_STP_32_LDSTPAIR_OFF); rc = 0; };
  if(ctx->opc==2) {instr->encoding = (ENC_STP_64_LDSTPAIR_OFF); instr->operation = enc_to_oper(ENC_STP_64_LDSTPAIR_OFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->t2 = (unsigned int)(ctx->Rt2);
 ctx->acctype = ctx->AccType_NORMAL;
 ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
 if(((ctx->L<<1)|(((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)))==1 || ctx->opc==3) {
  { return -4; };
 }
 ctx->signed_ = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=0);
 ctx->scale = 2+(unsigned int)((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
 ctx->datasize = (8) << (ctx->scale);
 ctx->offset = ((SignExtend(ctx->imm7,7))<<(ctx->scale));
 ctx->tag_checked = ctx->wback || ctx->n!=0x1f;
 ctx->rt_unknown = 
# 25291 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25291 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->wb_unknown = 
# 25292 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25292 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && (ctx->t==ctx->n || ctx->t2==ctx->n) && ctx->n!=0x1f) {
  ctx->c = ConstrainUnpredictable(Unpredictable_WBOVERLAPLD);


 }
 if(ctx->memop==MemOp_STORE && ctx->wback && (ctx->t==ctx->n || ctx->t2==ctx->n) && ctx->n!=0x1f) {
  ctx->c = ConstrainUnpredictable(Unpredictable_WBOVERLAPST);


 }
 if(ctx->memop==MemOp_LOAD && ctx->t==ctx->t2) {
  ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


 }
 return rc;
}


int STRB_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38000400) {
  decode_fields32(ENC_STRB_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 25319 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25319 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25320 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 25320 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STRB_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STRB_32_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0x38000C00) {
  decode_fields32(ENC_STRB_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 25329 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25329 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25330 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25330 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STRB_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STRB_32_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x39000000) {
  decode_fields32(ENC_STRB_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 25339 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25339 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25340 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25340 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  {instr->encoding = (ENC_STRB_32_LDST_POS); instr->operation = enc_to_oper(ENC_STRB_32_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 25356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 25356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 25370 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 25370 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 25375 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25375 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 25376 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25376 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STRB_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38200800) {
  decode_fields32(ENC_STRB_32B_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 25398 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25398 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25399 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25399 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->option!=3) {instr->encoding = (ENC_STRB_32B_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STRB_32B_LDST_REGOFF); rc = 0; };
  if(ctx->option==3) {instr->encoding = (ENC_STRB_32BL_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STRB_32BL_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 25421 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 25421 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 25438 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 25438 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 25443 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25443 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 25444 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25444 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STRH_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78000400) {
  decode_fields32(ENC_STRH_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 25466 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25466 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25467 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 25467 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STRH_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STRH_32_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0x78000C00) {
  decode_fields32(ENC_STRH_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 25476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25477 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25477 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STRH_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STRH_32_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC00000)==0x79000000) {
  decode_fields32(ENC_STRH_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 25486 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25486 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25487 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25487 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  {instr->encoding = (ENC_STRH_32_LDST_POS); instr->operation = enc_to_oper(ENC_STRH_32_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 25503 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 25503 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 25517 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 25517 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 25522 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25522 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 25523 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25523 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STRH_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78200800) {
  decode_fields32(ENC_STRH_32_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 25545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25546 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25546 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  {instr->encoding = (ENC_STRH_32_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STRH_32_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 25567 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 25567 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 25584 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 25584 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 25589 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25589 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 25590 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25590 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STR_imm_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3F600C00)==0x3C000400) {
  decode_fields32(ENC_STR_B_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 25612 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25612 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25613 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 25613 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==0 && ctx->opc==0) {instr->encoding = (ENC_STR_B_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STR_B_LDST_IMMPOST); rc = 0; };
  if(ctx->size==1 && ctx->opc==0) {instr->encoding = (ENC_STR_H_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STR_H_LDST_IMMPOST); rc = 0; };
  if(ctx->size==2 && ctx->opc==0) {instr->encoding = (ENC_STR_S_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STR_S_LDST_IMMPOST); rc = 0; };
  if(ctx->size==3 && ctx->opc==0) {instr->encoding = (ENC_STR_D_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STR_D_LDST_IMMPOST); rc = 0; };
  if(ctx->size==0 && ctx->opc==2) {instr->encoding = (ENC_STR_Q_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STR_Q_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0x3F600C00)==0x3C000C00) {
  decode_fields32(ENC_STR_B_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 25629 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25629 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25630 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25630 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==0 && ctx->opc==0) {instr->encoding = (ENC_STR_B_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STR_B_LDST_IMMPRE); rc = 0; };
  if(ctx->size==1 && ctx->opc==0) {instr->encoding = (ENC_STR_H_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STR_H_LDST_IMMPRE); rc = 0; };
  if(ctx->size==2 && ctx->opc==0) {instr->encoding = (ENC_STR_S_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STR_S_LDST_IMMPRE); rc = 0; };
  if(ctx->size==3 && ctx->opc==0) {instr->encoding = (ENC_STR_D_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STR_D_LDST_IMMPRE); rc = 0; };
  if(ctx->size==0 && ctx->opc==2) {instr->encoding = (ENC_STR_Q_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STR_Q_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0x3F400000)==0x3D000000) {
  decode_fields32(ENC_STR_B_LDST_POS, ctx, instr);
  ctx->wback = 
# 25646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25647 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25647 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  if(ctx->size==0 && ctx->opc==0) {instr->encoding = (ENC_STR_B_LDST_POS); instr->operation = enc_to_oper(ENC_STR_B_LDST_POS); rc = 0; };
  if(ctx->size==1 && ctx->opc==0) {instr->encoding = (ENC_STR_H_LDST_POS); instr->operation = enc_to_oper(ENC_STR_H_LDST_POS); rc = 0; };
  if(ctx->size==2 && ctx->opc==0) {instr->encoding = (ENC_STR_S_LDST_POS); instr->operation = enc_to_oper(ENC_STR_S_LDST_POS); rc = 0; };
  if(ctx->size==3 && ctx->opc==0) {instr->encoding = (ENC_STR_D_LDST_POS); instr->operation = enc_to_oper(ENC_STR_D_LDST_POS); rc = 0; };
  if(ctx->size==0 && ctx->opc==2) {instr->encoding = (ENC_STR_Q_LDST_POS); instr->operation = enc_to_oper(ENC_STR_Q_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 return rc;
}


int STR_imm_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8000400) {
  decode_fields32(ENC_STR_32_LDST_IMMPOST, ctx, instr);
  ctx->wback = 
# 25677 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25677 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25678 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 25678 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_STR_32_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STR_32_LDST_IMMPOST); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STR_64_LDST_IMMPOST); instr->operation = enc_to_oper(ENC_STR_64_LDST_IMMPOST); rc = 0; };
 }


 if(((ctx->insword) & 0xBFE00C00)==0xB8000C00) {
  decode_fields32(ENC_STR_32_LDST_IMMPRE, ctx, instr);
  ctx->wback = 
# 25688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 25688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->postindex = 
# 25689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_STR_32_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STR_32_LDST_IMMPRE); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STR_64_LDST_IMMPRE); instr->operation = enc_to_oper(ENC_STR_64_LDST_IMMPRE); rc = 0; };
 }


 if(((ctx->insword) & 0xBFC00000)==0xB9000000) {
  decode_fields32(ENC_STR_32_LDST_POS, ctx, instr);
  ctx->wback = 
# 25699 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25699 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25700 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25700 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = (((uint64_t)(ctx->imm12))<<(ctx->scale));
  if(ctx->size==2) {instr->encoding = (ENC_STR_32_LDST_POS); instr->operation = enc_to_oper(ENC_STR_32_LDST_POS); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STR_64_LDST_POS); instr->operation = enc_to_oper(ENC_STR_64_LDST_POS); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 25717 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 25717 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 25731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 25731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 25736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 25737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STR_reg_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3F600C00)==0x3C200800) {
  decode_fields32(ENC_STR_B_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 25759 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25759 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25760 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25760 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->size==0 && ctx->opc==0 && ctx->option!=3) {instr->encoding = (ENC_STR_B_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_B_LDST_REGOFF); rc = 0; };
  if(ctx->size==0 && ctx->opc==0 && ctx->option==3) {instr->encoding = (ENC_STR_BL_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_BL_LDST_REGOFF); rc = 0; };
  if(ctx->size==1 && ctx->opc==0) {instr->encoding = (ENC_STR_H_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_H_LDST_REGOFF); rc = 0; };
  if(ctx->size==2 && ctx->opc==0) {instr->encoding = (ENC_STR_S_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_S_LDST_REGOFF); rc = 0; };
  if(ctx->size==3 && ctx->opc==0) {instr->encoding = (ENC_STR_D_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_D_LDST_REGOFF); rc = 0; };
  if(ctx->size==0 && ctx->opc==2) {instr->encoding = (ENC_STR_Q_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_Q_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 return rc;
}


int STR_reg_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8200800) {
  decode_fields32(ENC_STR_32_LDST_REGOFF, ctx, instr);
  ctx->wback = 
# 25796 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25796 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  if((((ctx->option)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
   { return -4; };
  }
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (ctx->S==1) ? ctx->scale : 0;
  if(ctx->size==2) {instr->encoding = (ENC_STR_32_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_32_LDST_REGOFF); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STR_64_LDST_REGOFF); instr->operation = enc_to_oper(ENC_STR_64_LDST_REGOFF); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->m = (unsigned int)(ctx->Rm);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 25819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 25819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 25836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 25836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH;
 ctx->wb_unknown = 
# 25841 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25841 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 25842 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25842 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STSETB_LDSETB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820301F) {
  decode_fields32(ENC_STSETB_LDSETB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STSETB_LDSETB_32_MEMOP); instr->operation = enc_to_oper(ENC_STSETB_LDSETB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STSETLB_LDSETLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STSETLB_LDSETLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STSETH_LDSETH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820301F) {
  decode_fields32(ENC_STSETH_LDSETH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STSETH_LDSETH_32_MEMOP); instr->operation = enc_to_oper(ENC_STSETH_LDSETH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STSETLH_LDSETLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STSETLH_LDSETLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STSET_LDSET(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820301F) {
  decode_fields32(ENC_STSET_LDSET_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STSET_LDSET_32_MEMOP); instr->operation = enc_to_oper(ENC_STSET_LDSET_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STSETL_LDSETL_32_MEMOP); instr->operation = enc_to_oper(ENC_STSETL_LDSETL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STSET_LDSET_64_MEMOP); instr->operation = enc_to_oper(ENC_STSET_LDSET_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STSETL_LDSETL_64_MEMOP); instr->operation = enc_to_oper(ENC_STSETL_LDSETL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STSMAXB_LDSMAXB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820401F) {
  decode_fields32(ENC_STSMAXB_LDSMAXB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STSMAXB_LDSMAXB_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMAXB_LDSMAXB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STSMAXLB_LDSMAXLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMAXLB_LDSMAXLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STSMAXH_LDSMAXH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820401F) {
  decode_fields32(ENC_STSMAXH_LDSMAXH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STSMAXH_LDSMAXH_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMAXH_LDSMAXH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STSMAXLH_LDSMAXLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMAXLH_LDSMAXLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STSMAX_LDSMAX(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820401F) {
  decode_fields32(ENC_STSMAX_LDSMAX_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STSMAX_LDSMAX_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMAX_LDSMAX_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STSMAXL_LDSMAXL_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMAXL_LDSMAXL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STSMAX_LDSMAX_64_MEMOP); instr->operation = enc_to_oper(ENC_STSMAX_LDSMAX_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STSMAXL_LDSMAXL_64_MEMOP); instr->operation = enc_to_oper(ENC_STSMAXL_LDSMAXL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STSMINB_LDSMINB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820501F) {
  decode_fields32(ENC_STSMINB_LDSMINB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STSMINB_LDSMINB_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMINB_LDSMINB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STSMINLB_LDSMINLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMINLB_LDSMINLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STSMINH_LDSMINH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820501F) {
  decode_fields32(ENC_STSMINH_LDSMINH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STSMINH_LDSMINH_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMINH_LDSMINH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STSMINLH_LDSMINLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMINLH_LDSMINLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STSMIN_LDSMIN(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820501F) {
  decode_fields32(ENC_STSMIN_LDSMIN_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STSMIN_LDSMIN_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMIN_LDSMIN_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STSMINL_LDSMINL_32_MEMOP); instr->operation = enc_to_oper(ENC_STSMINL_LDSMINL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STSMIN_LDSMIN_64_MEMOP); instr->operation = enc_to_oper(ENC_STSMIN_LDSMIN_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STSMINL_LDSMINL_64_MEMOP); instr->operation = enc_to_oper(ENC_STSMINL_LDSMINL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STTR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8000800) {
  decode_fields32(ENC_STTR_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 25996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 25996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 25997 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 25997 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_STTR_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_STTR_32_LDST_UNPRIV); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STTR_64_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_STTR_64_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 26022 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 26022 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 26036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 26036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 26041 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26041 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 26042 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26042 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STTRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38000800) {
  decode_fields32(ENC_STTRB_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 26064 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 26064 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 26065 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26065 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STTRB_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_STTRB_32_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 26089 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 26089 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 26103 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 26103 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 26108 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26108 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 26109 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26109 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STTRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78000800) {
  decode_fields32(ENC_STTRH_32_LDST_UNPRIV, ctx, instr);
  ctx->wback = 
# 26131 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 26131 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 26132 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26132 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STTRH_32_LDST_UNPRIV); instr->operation = enc_to_oper(ENC_STTRH_32_LDST_UNPRIV); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->unpriv_at_el1 = ctx->pstate_el==1 && !(EL2Enabled() && (ctx->features1 & ((uint64_t)1<<22)) && (((ctx->HCR_EL2_NV)<<(1))|(ctx->HCR_EL2_NV1))==3);
 ctx->unpriv_at_el2 = ctx->pstate_el==2 && (ctx->features1 & ((uint64_t)1<<48)) && (((ctx->HCR_EL2_E2H)<<(1))|(ctx->HCR_EL2_TGE))==3;
 ctx->user_access_override = (ctx->features1 & ((uint64_t)1<<47)) && ctx->pstate_uao==1;
 if(!ctx->user_access_override && (ctx->unpriv_at_el1 || ctx->unpriv_at_el2)) {
  ctx->acctype = ctx->AccType_UNPRIV;
 }
 else {
  ctx->acctype = ctx->AccType_NORMAL;
 }
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 26156 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 26156 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   { return -4; };
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 26170 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 26170 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 26175 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26175 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 26176 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26176 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STUMAXB_LDUMAXB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820601F) {
  decode_fields32(ENC_STUMAXB_LDUMAXB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STUMAXB_LDUMAXB_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMAXB_LDUMAXB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STUMAXLB_LDUMAXLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMAXLB_LDUMAXLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STUMAXH_LDUMAXH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820601F) {
  decode_fields32(ENC_STUMAXH_LDUMAXH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STUMAXH_LDUMAXH_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMAXH_LDUMAXH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STUMAXLH_LDUMAXLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMAXLH_LDUMAXLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STUMAX_LDUMAX(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820601F) {
  decode_fields32(ENC_STUMAX_LDUMAX_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STUMAX_LDUMAX_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMAX_LDUMAX_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STUMAXL_LDUMAXL_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMAXL_LDUMAXL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STUMAX_LDUMAX_64_MEMOP); instr->operation = enc_to_oper(ENC_STUMAX_LDUMAX_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STUMAXL_LDUMAXL_64_MEMOP); instr->operation = enc_to_oper(ENC_STUMAXL_LDUMAXL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STUMINB_LDUMINB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x3820701F) {
  decode_fields32(ENC_STUMINB_LDUMINB_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STUMINB_LDUMINB_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMINB_LDUMINB_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STUMINLB_LDUMINLB_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMINLB_LDUMINLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STUMINH_LDUMINH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x7820701F) {
  decode_fields32(ENC_STUMINH_LDUMINH_32_MEMOP, ctx, instr);
  if(ctx->R==0) {instr->encoding = (ENC_STUMINH_LDUMINH_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMINH_LDUMINH_32_MEMOP); rc = 0; };
  if(ctx->R==1) {instr->encoding = (ENC_STUMINLH_LDUMINLH_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMINLH_LDUMINLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int STUMIN_LDUMIN(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFA0FC1F)==0xB820701F) {
  decode_fields32(ENC_STUMIN_LDUMIN_32_MEMOP, ctx, instr);
  if(ctx->size==2 && ctx->R==0) {instr->encoding = (ENC_STUMIN_LDUMIN_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMIN_LDUMIN_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->R==1) {instr->encoding = (ENC_STUMINL_LDUMINL_32_MEMOP); instr->operation = enc_to_oper(ENC_STUMINL_LDUMINL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==0) {instr->encoding = (ENC_STUMIN_LDUMIN_64_MEMOP); instr->operation = enc_to_oper(ENC_STUMIN_LDUMIN_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->R==1) {instr->encoding = (ENC_STUMINL_LDUMINL_64_MEMOP); instr->operation = enc_to_oper(ENC_STUMINL_LDUMINL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int STURB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x38000000) {
  decode_fields32(ENC_STURB_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 26286 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 26286 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 26287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STURB_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STURB_32_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 26303 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 26303 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 26320 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 26320 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 26325 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26325 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 26326 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26326 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STURH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0x78000000) {
  decode_fields32(ENC_STURH_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 26348 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 26348 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 26349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  {instr->encoding = (ENC_STURH_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STURH_32_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 26365 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 26365 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 26382 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 26382 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 26387 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26387 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 26388 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26388 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STUR_fpsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x3F600C00)==0x3C000000) {
  decode_fields32(ENC_STUR_B_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 26410 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 26410 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 26411 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26411 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)((((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))<<2)|ctx->size));
  if(ctx->scale>4) {
   { return -4; };
  }
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==0 && ctx->opc==0) {instr->encoding = (ENC_STUR_B_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STUR_B_LDST_UNSCALED); rc = 0; };
  if(ctx->size==1 && ctx->opc==0) {instr->encoding = (ENC_STUR_H_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STUR_H_LDST_UNSCALED); rc = 0; };
  if(ctx->size==2 && ctx->opc==0) {instr->encoding = (ENC_STUR_S_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STUR_S_LDST_UNSCALED); rc = 0; };
  if(ctx->size==3 && ctx->opc==0) {instr->encoding = (ENC_STUR_D_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STUR_D_LDST_UNSCALED); rc = 0; };
  if(ctx->size==0 && ctx->opc==2) {instr->encoding = (ENC_STUR_Q_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STUR_Q_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_VEC;
 ctx->memop = ((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) ? MemOp_LOAD : MemOp_STORE;
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 return rc;
}


int STUR_gen(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE00C00)==0xB8000000) {
  decode_fields32(ENC_STUR_32_LDST_UNSCALED, ctx, instr);
  ctx->wback = 
# 26441 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 26441 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->postindex = 
# 26442 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26442 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->scale = (unsigned int)(ctx->size);
  ctx->offset = SignExtend(ctx->imm9,9);
  if(ctx->size==2) {instr->encoding = (ENC_STUR_32_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STUR_32_LDST_UNSCALED); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STUR_64_LDST_UNSCALED); instr->operation = enc_to_oper(ENC_STUR_64_LDST_UNSCALED); rc = 0; };
 }

 ctx->n = (unsigned int)(ctx->Rn);
 ctx->t = (unsigned int)(ctx->Rt);
 ctx->acctype = ctx->AccType_NORMAL;
 if((((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==0) {
  if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
   ctx->memop = MemOp_LOAD;
  };
  if(ctx->size==3) {
   ctx->regsize = 0x40;
  };
  ctx->signed_ = 
# 26459 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 26459 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
 }
 else {
  if(ctx->size==3) {
   ctx->memop = MemOp_PREFETCH;
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
  }
  else {
   ctx->memop = MemOp_LOAD;
   if(ctx->size==2 && (((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    { return -4; };
   }
   if((((ctx->opc)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->regsize = 0x20;
   };
   ctx->signed_ = 
# 26476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 26476 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
 }
 ctx->datasize = (8) << (ctx->scale);
 ctx->tag_checked = ctx->memop!=MemOp_PREFETCH && (ctx->wback || ctx->n!=0x1f);
 ctx->wb_unknown = 
# 26481 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26481 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 ctx->rt_unknown = 
# 26482 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26482 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
 if(ctx->memop==MemOp_LOAD && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 if(ctx->memop==MemOp_STORE && ctx->wback && ctx->n==ctx->t && ctx->n!=0x1f) {



 }
 return rc;
}


int STXP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88200000) {
  decode_fields32(ENC_STXP_SP32_LDSTEXCLP, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 26509 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             1
# 26509 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 26515 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26515 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 26516 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26516 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->sz==0) {instr->encoding = (ENC_STXP_SP32_LDSTEXCLP); instr->operation = enc_to_oper(ENC_STXP_SP32_LDSTEXCLP); rc = 0; };
  if(ctx->sz==1) {instr->encoding = (ENC_STXP_SP64_LDSTEXCLP); instr->operation = enc_to_oper(ENC_STXP_SP64_LDSTEXCLP); rc = 0; };
 }
 return rc;
}


int STXR(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE08000)==0x88000000) {
  decode_fields32(ENC_STXR_SR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 26553 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 26553 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 26559 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26559 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 26560 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26560 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  if(ctx->size==2) {instr->encoding = (ENC_STXR_SR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STXR_SR32_LDSTEXCLR); rc = 0; };
  if(ctx->size==3) {instr->encoding = (ENC_STXR_SR64_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STXR_SR64_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int STXRB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x8000000) {
  decode_fields32(ENC_STXRB_SR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 26597 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 26597 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 26603 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26603 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 26604 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26604 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_STXRB_SR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STXRB_SR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int STXRH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x48000000) {
  decode_fields32(ENC_STXRH_SR32_LDSTEXCLR, ctx, instr);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->t2 = (unsigned int)(ctx->Rt2);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->acctype = (ctx->o0==1) ? AccType_ORDEREDATOMIC : AccType_ATOMIC;
  ctx->pair = 
# 26640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
             0
# 26640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->memop = (ctx->L==1) ? MemOp_LOAD : MemOp_STORE;
  ctx->elsize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->elsize==0x40) ? 0x40 : 0x20;
  ctx->datasize = (ctx->pair) ? (ctx->elsize) * (2) : ctx->elsize;
  ctx->tag_checked = ctx->n!=0x1f;
  ctx->rt_unknown = 
# 26646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->rn_unknown = 
# 26647 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26647 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  if(ctx->memop==MemOp_LOAD && ctx->pair && ctx->t==ctx->t2) {
   ctx->c = ConstrainUnpredictable(Unpredictable_LDPOVERLAP);


  }
  if(ctx->memop==MemOp_STORE) {
   if(ctx->s==ctx->t || (ctx->pair && ctx->s==ctx->t2)) {
    ctx->c = ConstrainUnpredictable(Unpredictable_DATAOVERLAP);


   }
   if(ctx->s==ctx->n && ctx->n!=0x1f) {
    ctx->c = ConstrainUnpredictable(Unpredictable_BASEOVERLAP);


   }
  }
  {instr->encoding = (ENC_STXRH_SR32_LDSTEXCLR); instr->operation = enc_to_oper(ENC_STXRH_SR32_LDSTEXCLR); rc = 0; };
 }
 return rc;
}


int STZ2G(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xD9E00400) {
  decode_fields32(ENC_STZ2G_64SPOST_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 26684 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26684 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 26685 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26685 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->zero_data = 
# 26686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_STZ2G_64SPOST_LDSTTAGS); instr->operation = enc_to_oper(ENC_STZ2G_64SPOST_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9E00C00) {
  decode_fields32(ENC_STZ2G_64SPRE_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 26699 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26699 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 26700 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26700 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 26701 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26701 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_STZ2G_64SPRE_LDSTTAGS); instr->operation = enc_to_oper(ENC_STZ2G_64SPRE_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9E00800) {
  decode_fields32(ENC_STZ2G_64SOFFSET_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 26714 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26714 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->postindex = 
# 26715 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26715 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 26716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_STZ2G_64SOFFSET_LDSTTAGS); instr->operation = enc_to_oper(ENC_STZ2G_64SOFFSET_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int STZG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00C00)==0xD9600400) {
  decode_fields32(ENC_STZG_64SPOST_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 26736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 26737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->zero_data = 
# 26738 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26738 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_STZG_64SPOST_LDSTTAGS); instr->operation = enc_to_oper(ENC_STZG_64SPOST_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9600C00) {
  decode_fields32(ENC_STZG_64SPRE_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 26751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->postindex = 
# 26752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 26753 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26753 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_STZG_64SPRE_LDSTTAGS); instr->operation = enc_to_oper(ENC_STZG_64SPRE_LDSTTAGS); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE00C00)==0xD9600800) {
  decode_fields32(ENC_STZG_64SOFFSET_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->offset = ((SignExtend(ctx->imm9,9))<<(4));
  ctx->writeback = 
# 26766 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26766 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->postindex = 
# 26767 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 26767 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->zero_data = 
# 26768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 26768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_STZG_64SOFFSET_LDSTTAGS); instr->operation = enc_to_oper(ENC_STZG_64SOFFSET_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int STZGM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0xD9200000) {
  decode_fields32(ENC_STZGM_64BULK_LDSTTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<20))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Xt);
  ctx->n = (unsigned int)(ctx->Xn);
  {instr->encoding = (ENC_STZGM_64BULK_LDSTTAGS); instr->operation = enc_to_oper(ENC_STZGM_64BULK_LDSTTAGS); rc = 0; };
 }
 return rc;
}


int SUBG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC00000)==0xD1800000) {
  decode_fields32(ENC_SUBG_64_ADDSUB_IMMTAGS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Xd);
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->tag_offset = ctx->uimm4;
  ctx->offset = (((uint64_t)(ctx->uimm6))<<(4));
  ctx->ADD = 
# 26807 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
            0
# 26807 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                 ;
  {instr->encoding = (ENC_SUBG_64_ADDSUB_IMMTAGS); instr->operation = enc_to_oper(ENC_SUBG_64_ADDSUB_IMMTAGS); rc = 0; };
 }
 return rc;
}


int SUBHN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE206000) {
  decode_fields32(ENC_SUBHN_ASIMDDIFF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->round = (ctx->U==1);
  {instr->encoding = (ENC_SUBHN_ASIMDDIFF_N); instr->operation = enc_to_oper(ENC_SUBHN_ASIMDDIFF_N); rc = 0; };
 }
 return rc;
}


int SUBP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9AC00000) {
  decode_fields32(ENC_SUBP_64S_DP_2SRC, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Xd);
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->m = (unsigned int)(ctx->Xm);
  instr->setflags = 
# 26852 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 26852 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 26853 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 26853 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_SUBP_64S_DP_2SRC); instr->operation = enc_to_oper(ENC_SUBP_64S_DP_2SRC); rc = 0; };
 }
 return rc;
}


int SUBPS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0xBAC00000) {
  decode_fields32(ENC_SUBPS_64S_DP_2SRC, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<21))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Xd);
  ctx->n = (unsigned int)(ctx->Xn);
  ctx->m = (unsigned int)(ctx->Xm);
  instr->setflags = 
# 26873 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 26873 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 26874 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 26874 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;

  if(ctx->S==1 && ctx->Xd==0x1f) return CMPP_SUBPS(ctx, instr);
  {instr->encoding = (ENC_SUBPS_64S_DP_2SRC); instr->operation = enc_to_oper(ENC_SUBPS_64S_DP_2SRC); rc = 0; };
 }
 return rc;
}


int SUBS_addsub_ext(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00000)==0x6B200000) {
  decode_fields32(ENC_SUBS_32S_ADDSUB_EXT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  instr->setflags = (ctx->S==1);
  ctx->setflags = (ctx->S==1);
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (unsigned int)(ctx->imm3);
  if(ctx->shift>4) {
   { return -4; };
  }

  if(ctx->Rd==0x1f) return CMP_SUBS_addsub_ext(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_SUBS_32S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_SUBS_32S_ADDSUB_EXT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SUBS_64S_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_SUBS_64S_ADDSUB_EXT); rc = 0; };
 }
 return rc;
}


int SUBS_addsub_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x71000000) {
  decode_fields32(ENC_SUBS_32S_ADDSUB_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  instr->setflags = (ctx->S==1);
  ctx->setflags = (ctx->S==1);
  if(!ctx->sh) {
   ctx->imm = (uint64_t)(ctx->imm12);
  }
  else if(ctx->sh) {
   ctx->imm = (uint64_t)(((ctx->imm12<<12)|0));
  }

  if(ctx->Rd==0x1f) return CMP_SUBS_addsub_imm(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_SUBS_32S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_SUBS_32S_ADDSUB_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SUBS_64S_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_SUBS_64S_ADDSUB_IMM); rc = 0; };
 }
 return rc;
}


int SUBS_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x6B000000) {
  decode_fields32(ENC_SUBS_32_ADDSUB_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  ctx->setflags = (ctx->S==1);
  instr->setflags = (ctx->S==1);
  if(ctx->shift==3) {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);

  if(ctx->Rd==0x1f) return CMP_SUBS_addsub_shift(ctx, instr);
  if(ctx->Rn==0x1f && ctx->Rd!=0x1f) return NEGS_SUBS_addsub_shift(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_SUBS_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_SUBS_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SUBS_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_SUBS_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int SUB_addsub_ext(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE00000)==0x4B200000) {
  decode_fields32(ENC_SUB_32_ADDSUB_EXT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  instr->setflags = (ctx->S==1);
  ctx->setflags = (ctx->S==1);
  ctx->extend_type = DecodeRegExtend(ctx->option);
  ctx->shift = (unsigned int)(ctx->imm3);
  if(ctx->shift>4) {
   { return -4; };
  }
  if(ctx->sf==0) {instr->encoding = (ENC_SUB_32_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_SUB_32_ADDSUB_EXT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SUB_64_ADDSUB_EXT); instr->operation = enc_to_oper(ENC_SUB_64_ADDSUB_EXT); rc = 0; };
 }
 return rc;
}


int SUB_addsub_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x51000000) {
  decode_fields32(ENC_SUB_32_ADDSUB_IMM, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  instr->setflags = (ctx->S==1);
  ctx->setflags = (ctx->S==1);
  if(!ctx->sh) {
   ctx->imm = (uint64_t)(ctx->imm12);
  }
  else if(ctx->sh) {
   ctx->imm = (uint64_t)(((ctx->imm12<<12)|0));
  }
  if(ctx->sf==0) {instr->encoding = (ENC_SUB_32_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_SUB_32_ADDSUB_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SUB_64_ADDSUB_IMM); instr->operation = enc_to_oper(ENC_SUB_64_ADDSUB_IMM); rc = 0; };
 }
 return rc;
}


int SUB_addsub_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F200000)==0x4B000000) {
  decode_fields32(ENC_SUB_32_ADDSUB_SHIFT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->sub_op = (ctx->op==1);
  instr->setflags = (ctx->S==1);
  ctx->setflags = (ctx->S==1);
  if(ctx->shift==3) {
   { return -4; };
  }
  if(ctx->sf==0 && (((ctx->imm6)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==1) {
   { return -4; };
  }
  ctx->shift_type = DecodeShift(ctx->shift);
  ctx->shift_amount = (unsigned int)(ctx->imm6);

  if(ctx->Rn==0x1f) return NEG_SUB_addsub_shift(ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_SUB_32_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_SUB_32_ADDSUB_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_SUB_64_ADDSUB_SHIFT); instr->operation = enc_to_oper(ENC_SUB_64_ADDSUB_SHIFT); rc = 0; };
 }
 return rc;
}


int SUB_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E208400) {
  decode_fields32(ENC_SUB_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->sub_op = (ctx->U==1);
  {instr->encoding = (ENC_SUB_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_SUB_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E208400) {
  decode_fields32(ENC_SUB_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->U==1);
  {instr->encoding = (ENC_SUB_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_SUB_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int SUDOT_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFC0F400)==0xF00F000) {
  decode_fields32(ENC_SUDOT_ASIMDELEM_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->op1_unsigned = (ctx->US==1);
  ctx->op2_unsigned = (ctx->US==0);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->M<<4)|ctx->Rm));
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->i = (unsigned int)(((ctx->H<<1)|ctx->L));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((0x20) ? ((ctx->datasize) / (0x20)) : 0);
  {instr->encoding = (ENC_SUDOT_ASIMDELEM_D); instr->operation = enc_to_oper(ENC_SUDOT_ASIMDELEM_D); rc = 0; };
 }
 return rc;
}


int SUQADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5E203800) {
  decode_fields32(ENC_SUQADD_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SUQADD_ASISDMISC_R); instr->operation = enc_to_oper(ENC_SUQADD_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0xE203800) {
  decode_fields32(ENC_SUQADD_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_SUQADD_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_SUQADD_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int SVC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4000001) {
  decode_fields32(ENC_SVC_EX_EXCEPTION, ctx, instr);
  {instr->encoding = (ENC_SVC_EX_EXCEPTION); instr->operation = enc_to_oper(ENC_SVC_EX_EXCEPTION); rc = 0; };
 }
 return rc;
}


int SWP(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xB8208000) {
  decode_fields32(ENC_SWP_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->size==2 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_SWP_32_MEMOP); instr->operation = enc_to_oper(ENC_SWP_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_SWPA_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPA_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_SWPAL_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPAL_32_MEMOP); rc = 0; };
  if(ctx->size==2 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_SWPL_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPL_32_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_SWP_64_MEMOP); instr->operation = enc_to_oper(ENC_SWP_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_SWPA_64_MEMOP); instr->operation = enc_to_oper(ENC_SWPA_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_SWPAL_64_MEMOP); instr->operation = enc_to_oper(ENC_SWPAL_64_MEMOP); rc = 0; };
  if(ctx->size==3 && ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_SWPL_64_MEMOP); instr->operation = enc_to_oper(ENC_SWPL_64_MEMOP); rc = 0; };
 }
 return rc;
}


int SWPB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x38208000) {
  decode_fields32(ENC_SWPAB_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_SWPAB_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPAB_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_SWPALB_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPALB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_SWPB_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPB_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_SWPLB_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPLB_32_MEMOP); rc = 0; };
 }
 return rc;
}


int SWPH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x78208000) {
  decode_fields32(ENC_SWPAH_32_MEMOP, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<1))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->s = (unsigned int)(ctx->Rs);
  ctx->datasize = (8) << ((unsigned int)(ctx->size));
  ctx->regsize = (ctx->datasize==0x40) ? 0x40 : 0x20;
  ctx->ldacctype = (ctx->A==1 && ctx->Rt!=0x1f) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->stacctype = (ctx->R==1) ? AccType_ORDEREDATOMICRW : AccType_ATOMICRW;
  ctx->tag_checked = ctx->n!=0x1f;
  if(ctx->A==1 && ctx->R==0) {instr->encoding = (ENC_SWPAH_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPAH_32_MEMOP); rc = 0; };
  if(ctx->A==1 && ctx->R==1) {instr->encoding = (ENC_SWPALH_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPALH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==0) {instr->encoding = (ENC_SWPH_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPH_32_MEMOP); rc = 0; };
  if(ctx->A==0 && ctx->R==1) {instr->encoding = (ENC_SWPLH_32_MEMOP); instr->operation = enc_to_oper(ENC_SWPLH_32_MEMOP); rc = 0; };
 }
 return rc;
}


int SXTB_SBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FBFFC00)==0x13001C00) {
  decode_fields32(ENC_SXTB_SBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_SXTB_SBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_SXTB_SBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_SXTB_SBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_SXTB_SBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int SXTH_SBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FBFFC00)==0x13003C00) {
  decode_fields32(ENC_SXTH_SBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_SXTH_SBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_SXTH_SBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_SXTH_SBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_SXTH_SBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int SXTL_SSHLL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF87FC00)==0xF00A400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_SXTL_SSHLL_ASIMDSHF_L, ctx, instr);
  {instr->encoding = (ENC_SXTL_SSHLL_ASIMDSHF_L); instr->operation = enc_to_oper(ENC_SXTL_SSHLL_ASIMDSHF_L); rc = 0; };
 }
 return rc;
}


int SXTW_SBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x93407C00) {
  decode_fields32(ENC_SXTW_SBFM_64M_BITFIELD, ctx, instr);
  {instr->encoding = (ENC_SXTW_SBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_SXTW_SBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF80000)==0xD5080000) {
  decode_fields32(ENC_SYS_CR_SYSTEMINSTRS, ctx, instr);
  CheckSystemAccess(1,ctx->op1,ctx->CRn,ctx->CRm,ctx->op2,ctx->Rt,ctx->L);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->sys_op0 = 1;
  ctx->sys_op1 = (unsigned int)(ctx->op1);
  ctx->sys_op2 = (unsigned int)(ctx->op2);
  ctx->sys_crn = (unsigned int)(ctx->CRn);
  ctx->sys_crm = (unsigned int)(ctx->CRm);
  ctx->has_result = (ctx->L==1);

  if(ctx->CRn==7 && (ctx->CRm&14)==8 && SysOp(ctx->op1,7,ctx->CRm,ctx->op2)==Sys_AT) return AT_SYS(ctx, instr);
  if(ctx->op1==3 && ctx->CRn==7 && ctx->CRm==3 && ctx->op2==4) return CFP_SYS(ctx, instr);
  if(ctx->op1==3 && ctx->CRn==7 && ctx->CRm==3 && ctx->op2==7) return CPP_SYS(ctx, instr);
  if(ctx->CRn==7 && SysOp(ctx->op1,7,ctx->CRm,ctx->op2)==Sys_DC) return DC_SYS(ctx, instr);
  if(ctx->op1==3 && ctx->CRn==7 && ctx->CRm==3 && ctx->op2==5) return DVP_SYS(ctx, instr);
  if(ctx->CRn==7 && SysOp(ctx->op1,7,ctx->CRm,ctx->op2)==Sys_IC) return IC_SYS(ctx, instr);
  if(ctx->CRn==8 && SysOp(ctx->op1,8,ctx->CRm,ctx->op2)==Sys_TLBI) return TLBI_SYS(ctx, instr);
  {instr->encoding = (ENC_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int SYSL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF80000)==0xD5280000) {
  decode_fields32(ENC_SYSL_RC_SYSTEMINSTRS, ctx, instr);
  CheckSystemAccess(1,ctx->op1,ctx->CRn,ctx->CRm,ctx->op2,ctx->Rt,ctx->L);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->sys_op0 = 1;
  ctx->sys_op1 = (unsigned int)(ctx->op1);
  ctx->sys_op2 = (unsigned int)(ctx->op2);
  ctx->sys_crn = (unsigned int)(ctx->CRn);
  ctx->sys_crm = (unsigned int)(ctx->CRm);
  ctx->has_result = (ctx->L==1);
  {instr->encoding = (ENC_SYSL_RC_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_SYSL_RC_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int TBL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE09C00)==0xE000000) {
  decode_fields32(ENC_TBL_ASIMDTBL_L2_2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((8) ? ((ctx->datasize) / (8)) : 0);
  ctx->regs = (unsigned int)(ctx->len)+1;
  ctx->is_tbl = (ctx->op==0);
  if(ctx->len==1) {instr->encoding = (ENC_TBL_ASIMDTBL_L2_2); instr->operation = enc_to_oper(ENC_TBL_ASIMDTBL_L2_2); rc = 0; };
  if(ctx->len==2) {instr->encoding = (ENC_TBL_ASIMDTBL_L3_3); instr->operation = enc_to_oper(ENC_TBL_ASIMDTBL_L3_3); rc = 0; };
  if(ctx->len==3) {instr->encoding = (ENC_TBL_ASIMDTBL_L4_4); instr->operation = enc_to_oper(ENC_TBL_ASIMDTBL_L4_4); rc = 0; };
  if(ctx->len==0) {instr->encoding = (ENC_TBL_ASIMDTBL_L1_1); instr->operation = enc_to_oper(ENC_TBL_ASIMDTBL_L1_1); rc = 0; };
 }
 return rc;
}


int TBNZ(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F000000)==0x37000000) {
  decode_fields32(ENC_TBNZ_ONLY_TESTBRANCH, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->datasize = (ctx->b5==1) ? 0x40 : 0x20;
  ctx->bit_pos = (unsigned int)(((ctx->b5<<5)|ctx->b40));
  ctx->bit_val = ctx->op;
  ctx->offset = SignExtend((ctx->imm14<<2),16);
  {instr->encoding = (ENC_TBNZ_ONLY_TESTBRANCH); instr->operation = enc_to_oper(ENC_TBNZ_ONLY_TESTBRANCH); rc = 0; };
 }
 return rc;
}


int TBX_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE09C00)==0xE001000) {
  decode_fields32(ENC_TBX_ASIMDTBL_L2_2, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((8) ? ((ctx->datasize) / (8)) : 0);
  ctx->regs = (unsigned int)(ctx->len)+1;
  ctx->is_tbl = (ctx->op==0);
  if(ctx->len==1) {instr->encoding = (ENC_TBX_ASIMDTBL_L2_2); instr->operation = enc_to_oper(ENC_TBX_ASIMDTBL_L2_2); rc = 0; };
  if(ctx->len==2) {instr->encoding = (ENC_TBX_ASIMDTBL_L3_3); instr->operation = enc_to_oper(ENC_TBX_ASIMDTBL_L3_3); rc = 0; };
  if(ctx->len==3) {instr->encoding = (ENC_TBX_ASIMDTBL_L4_4); instr->operation = enc_to_oper(ENC_TBX_ASIMDTBL_L4_4); rc = 0; };
  if(ctx->len==0) {instr->encoding = (ENC_TBX_ASIMDTBL_L1_1); instr->operation = enc_to_oper(ENC_TBX_ASIMDTBL_L1_1); rc = 0; };
 }
 return rc;
}


int TBZ(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F000000)==0x36000000) {
  decode_fields32(ENC_TBZ_ONLY_TESTBRANCH, ctx, instr);
  ctx->t = (unsigned int)(ctx->Rt);
  ctx->datasize = (ctx->b5==1) ? 0x40 : 0x20;
  ctx->bit_pos = (unsigned int)(((ctx->b5<<5)|ctx->b40));
  ctx->bit_val = ctx->op;
  ctx->offset = SignExtend((ctx->imm14<<2),16);
  {instr->encoding = (ENC_TBZ_ONLY_TESTBRANCH); instr->operation = enc_to_oper(ENC_TBZ_ONLY_TESTBRANCH); rc = 0; };
 }
 return rc;
}


int TCANCEL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0001F)==0xD4600000) {
  decode_fields32(ENC_TCANCEL_EX_EXCEPTION, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  ctx->retry = ((((ctx->imm16)>>(15)) & (((uint64_t)1<<((15)-(15)+1))-1))==1);
  ctx->reason = (((ctx->imm16)>>(0)) & (((uint64_t)1<<((14)-(0)+1))-1));
  {instr->encoding = (ENC_TCANCEL_EX_EXCEPTION); instr->operation = enc_to_oper(ENC_TCANCEL_EX_EXCEPTION); rc = 0; };
 }
 return rc;
}


int TCOMMIT(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503307F) {
  decode_fields32(ENC_TCOMMIT_ONLY_BARRIERS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  {instr->encoding = (ENC_TCOMMIT_ONLY_BARRIERS); instr->operation = enc_to_oper(ENC_TCOMMIT_ONLY_BARRIERS); rc = 0; };
 }
 return rc;
}


int TLBI_SYS(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF8F000)==0xD5088000) {
  decode_fields32(ENC_TLBI_SYS_CR_SYSTEMINSTRS, ctx, instr);
  {instr->encoding = (ENC_TLBI_SYS_CR_SYSTEMINSTRS); instr->operation = enc_to_oper(ENC_TLBI_SYS_CR_SYSTEMINSTRS); rc = 0; };
 }
 return rc;
}


int TRN1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE002800) {
  decode_fields32(ENC_TRN1_ASIMDPERM_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->part = (unsigned int)(ctx->op);
  ctx->pairs = ((2) ? ((ctx->elements) / (2)) : 0);
  {instr->encoding = (ENC_TRN1_ASIMDPERM_ONLY); instr->operation = enc_to_oper(ENC_TRN1_ASIMDPERM_ONLY); rc = 0; };
 }
 return rc;
}


int TRN2_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE006800) {
  decode_fields32(ENC_TRN2_ASIMDPERM_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->part = (unsigned int)(ctx->op);
  ctx->pairs = ((2) ? ((ctx->elements) / (2)) : 0);
  {instr->encoding = (ENC_TRN2_ASIMDPERM_ONLY); instr->operation = enc_to_oper(ENC_TRN2_ASIMDPERM_ONLY); rc = 0; };
 }
 return rc;
}


int TSB(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503225F) {
  decode_fields32(ENC_TSB_HC_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_TSB_HC_HINTS); instr->operation = enc_to_oper(ENC_TSB_HC_HINTS); rc = 0; };
 }
 return rc;
}


int TSTART(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0xD5233060) {
  decode_fields32(ENC_TSTART_BR_SYSTEMRESULT, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  {instr->encoding = (ENC_TSTART_BR_SYSTEMRESULT); instr->operation = enc_to_oper(ENC_TSTART_BR_SYSTEMRESULT); rc = 0; };
 }
 return rc;
}


int TST_ANDS_log_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F80001F)==0x7200001F) {
  decode_fields32(ENC_TST_ANDS_32S_LOG_IMM, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_TST_ANDS_32S_LOG_IMM); instr->operation = enc_to_oper(ENC_TST_ANDS_32S_LOG_IMM); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_TST_ANDS_64S_LOG_IMM); instr->operation = enc_to_oper(ENC_TST_ANDS_64S_LOG_IMM); rc = 0; };
 }
 return rc;
}


int TST_ANDS_log_shift(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F20001F)==0x6A00001F) {
  decode_fields32(ENC_TST_ANDS_32_LOG_SHIFT, ctx, instr);
  if(ctx->sf==0) {instr->encoding = (ENC_TST_ANDS_32_LOG_SHIFT); instr->operation = enc_to_oper(ENC_TST_ANDS_32_LOG_SHIFT); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_TST_ANDS_64_LOG_SHIFT); instr->operation = enc_to_oper(ENC_TST_ANDS_64_LOG_SHIFT); rc = 0; };
 }
 return rc;
}


int TTEST(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0xD5233160) {
  decode_fields32(ENC_TTEST_BR_SYSTEMRESULT, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<28))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Rt);
  {instr->encoding = (ENC_TTEST_BR_SYSTEMRESULT); instr->operation = enc_to_oper(ENC_TTEST_BR_SYSTEMRESULT); rc = 0; };
 }
 return rc;
}


int UABAL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E205000) {
  decode_fields32(ENC_UABAL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->accumulate = (ctx->op==0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UABAL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_UABAL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int UABA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E207C00) {
  decode_fields32(ENC_UABA_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->accumulate = (ctx->ac==1);
  {instr->encoding = (ENC_UABA_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UABA_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UABDL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E207000) {
  decode_fields32(ENC_UABDL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->accumulate = (ctx->op==0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UABDL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_UABDL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int UABD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E207400) {
  decode_fields32(ENC_UABD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->accumulate = (ctx->ac==1);
  {instr->encoding = (ENC_UABD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UABD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UADALP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E206800) {
  decode_fields32(ENC_UADALP_ASIMDMISC_P, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((2 * ctx->esize)!=0) ? ((ctx->datasize) / (((2) * (ctx->esize)))) : 0;
  ctx->acc = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UADALP_ASIMDMISC_P); instr->operation = enc_to_oper(ENC_UADALP_ASIMDMISC_P); rc = 0; };
 }
 return rc;
}


int UADDLP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E202800) {
  decode_fields32(ENC_UADDLP_ASIMDMISC_P, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((2 * ctx->esize)!=0) ? ((ctx->datasize) / (((2) * (ctx->esize)))) : 0;
  ctx->acc = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UADDLP_ASIMDMISC_P); instr->operation = enc_to_oper(ENC_UADDLP_ASIMDMISC_P); rc = 0; };
 }
 return rc;
}


int UADDLV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E303800) {
  decode_fields32(ENC_UADDLV_ASIMDALL_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==4) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UADDLV_ASIMDALL_ONLY); instr->operation = enc_to_oper(ENC_UADDLV_ASIMDALL_ONLY); rc = 0; };
 }
 return rc;
}


int UADDL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E200000) {
  decode_fields32(ENC_UADDL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UADDL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_UADDL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int UADDW_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E201000) {
  decode_fields32(ENC_UADDW_ASIMDDIFF_W, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UADDW_ASIMDDIFF_W); instr->operation = enc_to_oper(ENC_UADDW_ASIMDDIFF_W); rc = 0; };
 }
 return rc;
}


int UBFIZ_UBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x53000000) {
  decode_fields32(ENC_UBFIZ_UBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_UBFIZ_UBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_UBFIZ_UBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_UBFIZ_UBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_UBFIZ_UBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int UBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x53000000) {
  decode_fields32(ENC_UBFM_32M_BITFIELD, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->opc) {
   ctx->inzero = 
# 27947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 27947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
   ctx->extend = 
# 27948 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 27948 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  }
  else if(ctx->opc==1) {
   ctx->inzero = 
# 27951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 27951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
   ctx->extend = 
# 27952 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 27952 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==2) {
   ctx->inzero = 
# 27955 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 27955 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
   ctx->extend = 
# 27956 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 27956 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  }
  else if(ctx->opc==3) {
   { return -4; };
  }
  if(ctx->sf==1 && ctx->N!=1) {
   { return -4; };
  }
  if(ctx->sf==0 && (ctx->N!=0 || (((ctx->immr)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))!=0 || (((ctx->imms)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))!=0)) {
   { return -4; };
  }
  ctx->R = (unsigned int)(ctx->immr);
  ctx->S = (unsigned int)(ctx->imms);
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks(ctx->N,ctx->imms,ctx->immr);
  ctx->wmask = dbmrt.wmask;
  ctx->tmask = dbmrt.tmask;

  
# 27973 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
 _Bool 
# 27973 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
      encoding32 = ctx->sf==0 && ctx->N==0;
  
# 27974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
 _Bool 
# 27974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
      encoding64 = ctx->sf==1 && ctx->N==1;
  if((ctx->imms!=0x1f && ctx->imms+1==ctx->immr && (encoding32)) || (ctx->imms!=0x3f && ctx->imms+1==ctx->immr && (encoding64))) return LSL_UBFM(ctx, instr);
  if((ctx->imms==0x1f && (encoding32)) || (ctx->imms==0x3f && (encoding64))) return LSR_UBFM(ctx, instr);
  if((unsigned int)(ctx->imms)<(unsigned int)(ctx->immr)) return UBFIZ_UBFM(ctx, instr);
  if(BFXPreferred(ctx->sf,(((ctx->opc)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)),ctx->imms,ctx->immr)) return UBFX_UBFM(ctx, instr);
  if(ctx->immr==0 && ctx->imms==7) return UXTB_UBFM(ctx, instr);
  if(ctx->immr==0 && ctx->imms==15) return UXTH_UBFM(ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_UBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_UBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_UBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_UBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int UBFX_UBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F800000)==0x53000000) {
  decode_fields32(ENC_UBFX_UBFM_32M_BITFIELD, ctx, instr);
  if(ctx->sf==0 && ctx->N==0) {instr->encoding = (ENC_UBFX_UBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_UBFX_UBFM_32M_BITFIELD); rc = 0; };
  if(ctx->sf==1 && ctx->N==1) {instr->encoding = (ENC_UBFX_UBFM_64M_BITFIELD); instr->operation = enc_to_oper(ENC_UBFX_UBFM_64M_BITFIELD); rc = 0; };
 }
 return rc;
}


int UCVTF_advsimd_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F00E400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UCVTF_ASISDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_ASISDSHF_C); instr->operation = enc_to_oper(ENC_UCVTF_ASISDSHF_C); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F00E400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UCVTF_ASIMDSHF_C, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if(!(ctx->immh&14) || ((ctx->immh&14)==2 && !(ctx->features1 & ((uint64_t)1<<11)))) {
   { return -4; };
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = ((ctx->immh&8)==8) ? 0x40 : (((ctx->immh&12)==4) ? 0x20 : 0x10);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->fracbits = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_ASIMDSHF_C); instr->operation = enc_to_oper(ENC_UCVTF_ASIMDSHF_C); rc = 0; };
 }
 return rc;
}


int UCVTF_advsimd_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x7E79D800) {
  decode_fields32(ENC_UCVTF_ASISDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UCVTF_ASISDMISCFP16_R); instr->operation = enc_to_oper(ENC_UCVTF_ASISDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xFFBFFC00)==0x7E21D800) {
  decode_fields32(ENC_UCVTF_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UCVTF_ASISDMISC_R); instr->operation = enc_to_oper(ENC_UCVTF_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFFFFC00)==0x2E79D800) {
  decode_fields32(ENC_UCVTF_ASIMDMISCFP16_R, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<11))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = 0x10;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UCVTF_ASIMDMISCFP16_R); instr->operation = enc_to_oper(ENC_UCVTF_ASIMDMISCFP16_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBFBFFC00)==0x2E21D800) {
  decode_fields32(ENC_UCVTF_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->sz<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UCVTF_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_UCVTF_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int UCVTF_float_fix(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3F0000)==0x1E030000) {
  decode_fields32(ENC_UCVTF_H32_FLOAT2FIX, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   { return -4; };
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(ctx->sf==0 && (((ctx->scale)>>(5)) & (((uint64_t)1<<((5)-(5)+1))-1))==0) {
   { return -4; };
  }
  ctx->fracbits = 0x40-(unsigned int)(ctx->scale);
  if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==3) {
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_UCVTF_H32_FLOAT2FIX); instr->operation = enc_to_oper(ENC_UCVTF_H32_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_UCVTF_S32_FLOAT2FIX); instr->operation = enc_to_oper(ENC_UCVTF_S32_FLOAT2FIX); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_UCVTF_D32_FLOAT2FIX); instr->operation = enc_to_oper(ENC_UCVTF_D32_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_UCVTF_H64_FLOAT2FIX); instr->operation = enc_to_oper(ENC_UCVTF_H64_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_UCVTF_S64_FLOAT2FIX); instr->operation = enc_to_oper(ENC_UCVTF_S64_FLOAT2FIX); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_UCVTF_D64_FLOAT2FIX); instr->operation = enc_to_oper(ENC_UCVTF_D64_FLOAT2FIX); rc = 0; };
 }
 return rc;
}


int UCVTF_float_int(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7F3FFC00)==0x1E230000) {
  decode_fields32(ENC_UCVTF_H32_FLOAT2INT, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->intsize = (ctx->sf==1) ? 0x40 : 0x20;
  if(!ctx->ftype) {
   ctx->fltsize = 0x20;
  }
  else if(ctx->ftype==1) {
   ctx->fltsize = 0x40;
  }
  else if(ctx->ftype==2) {
   if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)!=13) {
    { return -4; };
   }
   ctx->fltsize = 0x80;
  }
  else if(ctx->ftype==3) {
   if((ctx->features1 & ((uint64_t)1<<11))) {
    ctx->fltsize = 0x10;
   }
   else {
    { return -4; };
   }
  }
  if(!((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)&12)) {
   ctx->rounding = FPDecodeRounding(ctx->rmode);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==4) {
   ctx->rounding = FPRoundingMode(ctx->FPCR);
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_ItoF;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==8) {
   ctx->rounding = FPRounding_TIEAWAY;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==12) {
   if(ctx->fltsize!=0x10 && ctx->fltsize!=ctx->intsize) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 0;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==13) {
   if(ctx->intsize!=0x40 || ctx->fltsize!=0x80) {
    { return -4; };
   }
   if((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1) {
    ctx->op = FPConvOp_MOV_ItoF;
   };
   ctx->part = 1;
   ctx->fltsize = 0x40;
  }
  else if((((((ctx->opcode)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1))<<2)|ctx->rmode)==15) {
   if(!(ctx->features1 & ((uint64_t)1<<10))) {
    { return -4; };
   }
   ctx->rounding = FPRounding_ZERO;
   ctx->unsigned_ = ((((ctx->opcode)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
   ctx->op = FPConvOp_CVT_FtoI_JS;
  }
  else {
   { return -4; };
  }
  if(ctx->sf==0 && ctx->ftype==3) {instr->encoding = (ENC_UCVTF_H32_FLOAT2INT); instr->operation = enc_to_oper(ENC_UCVTF_H32_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==0) {instr->encoding = (ENC_UCVTF_S32_FLOAT2INT); instr->operation = enc_to_oper(ENC_UCVTF_S32_FLOAT2INT); rc = 0; };
  if(ctx->sf==0 && ctx->ftype==1) {instr->encoding = (ENC_UCVTF_D32_FLOAT2INT); instr->operation = enc_to_oper(ENC_UCVTF_D32_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==3) {instr->encoding = (ENC_UCVTF_H64_FLOAT2INT); instr->operation = enc_to_oper(ENC_UCVTF_H64_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==0) {instr->encoding = (ENC_UCVTF_S64_FLOAT2INT); instr->operation = enc_to_oper(ENC_UCVTF_S64_FLOAT2INT); rc = 0; };
  if(ctx->sf==1 && ctx->ftype==1) {instr->encoding = (ENC_UCVTF_D64_FLOAT2INT); instr->operation = enc_to_oper(ENC_UCVTF_D64_FLOAT2INT); rc = 0; };
 }
 return rc;
}


int UDF_perm_undef(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFF0000)==0x0) {
  decode_fields32(ENC_UDF_ONLY_PERM_UNDEF, ctx, instr);
  {instr->encoding = (ENC_UDF_ONLY_PERM_UNDEF); instr->operation = enc_to_oper(ENC_UDF_ONLY_PERM_UNDEF); rc = 0; };
 }
 return rc;
}


int UDIV(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0x7FE0FC00)==0x1AC00800) {
  decode_fields32(ENC_UDIV_32_DP_2SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->datasize = (ctx->sf==1) ? 0x40 : 0x20;
  ctx->unsigned_ = (ctx->o1==0);
  if(ctx->sf==0) {instr->encoding = (ENC_UDIV_32_DP_2SRC); instr->operation = enc_to_oper(ENC_UDIV_32_DP_2SRC); rc = 0; };
  if(ctx->sf==1) {instr->encoding = (ENC_UDIV_64_DP_2SRC); instr->operation = enc_to_oper(ENC_UDIV_64_DP_2SRC); rc = 0; };
 }
 return rc;
}


int UDOT_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0x2F00E000) {
  decode_fields32(ENC_UDOT_ASIMDELEM_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<8))) {
   { return -4; };
  }
  if(ctx->size!=2) {
   { return -4; };
  }
  ctx->signed_ = (ctx->U==0);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->M<<4)|ctx->Rm));
  ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_UDOT_ASIMDELEM_D); instr->operation = enc_to_oper(ENC_UDOT_ASIMDELEM_D); rc = 0; };
 }
 return rc;
}


int UDOT_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E009400) {
  decode_fields32(ENC_UDOT_ASIMDSAME2_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<8))) {
   { return -4; };
  }
  if(ctx->size!=2) {
   { return -4; };
  }
  ctx->signed_ = (ctx->U==0);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_UDOT_ASIMDSAME2_D); instr->operation = enc_to_oper(ENC_UDOT_ASIMDSAME2_D); rc = 0; };
 }
 return rc;
}


int UHADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E200400) {
  decode_fields32(ENC_UHADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UHADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UHADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UHSUB_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E202400) {
  decode_fields32(ENC_UHSUB_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UHSUB_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UHSUB_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UMADDL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x9BA00000) {
  decode_fields32(ENC_UMADDL_64WA_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = 0x40;
  ctx->datasize = 0x20;
  ctx->sub_op = (ctx->o0==1);
  ctx->unsigned_ = (ctx->U==1);

  if(ctx->Ra==0x1f) return UMULL_UMADDL(ctx, instr);
  {instr->encoding = (ENC_UMADDL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_UMADDL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int UMAXP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E20A400) {
  decode_fields32(ENC_UMAXP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_UMAXP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UMAXP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UMAXV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E30A800) {
  decode_fields32(ENC_UMAXV_ASIMDALL_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==4) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->min = (ctx->op==1);
  {instr->encoding = (ENC_UMAXV_ASIMDALL_ONLY); instr->operation = enc_to_oper(ENC_UMAXV_ASIMDALL_ONLY); rc = 0; };
 }
 return rc;
}


int UMAX_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E206400) {
  decode_fields32(ENC_UMAX_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_UMAX_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UMAX_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UMINP_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E20AC00) {
  decode_fields32(ENC_UMINP_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_UMINP_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UMINP_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UMINV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0x2E31A800) {
  decode_fields32(ENC_UMINV_ASIMDALL_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==4) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->min = (ctx->op==1);
  {instr->encoding = (ENC_UMINV_ASIMDALL_ONLY); instr->operation = enc_to_oper(ENC_UMINV_ASIMDALL_ONLY); rc = 0; };
 }
 return rc;
}


int UMIN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E206C00) {
  decode_fields32(ENC_UMIN_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->minimum = (ctx->o1==1);
  {instr->encoding = (ENC_UMIN_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UMIN_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UMLAL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0x2F002000) {
  decode_fields32(ENC_UMLAL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_UMLAL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_UMLAL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int UMLAL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E208000) {
  decode_fields32(ENC_UMLAL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UMLAL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_UMLAL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int UMLSL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0x2F006000) {
  decode_fields32(ENC_UMLSL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->sub_op = (ctx->o2==1);
  {instr->encoding = (ENC_UMLSL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_UMLSL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int UMLSL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E20A000) {
  decode_fields32(ENC_UMLSL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UMLSL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_UMLSL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int UMMLA_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x6E80A400) {
  decode_fields32(ENC_UMMLA_ASIMDSAME2_G, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  if(!((ctx->B<<1)|ctx->U)) {
   ctx->op1_unsigned = 
# 28685 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 28685 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->op2_unsigned = 
# 28686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 28686 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->B<<1)|ctx->U)==1) {
   ctx->op1_unsigned = 
# 28689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 28689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->op2_unsigned = 
# 28690 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 28690 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->B<<1)|ctx->U)==2) {
   ctx->op1_unsigned = 
# 28693 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 28693 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->op2_unsigned = 
# 28694 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 28694 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->B<<1)|ctx->U)==3) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  {instr->encoding = (ENC_UMMLA_ASIMDSAME2_G); instr->operation = enc_to_oper(ENC_UMMLA_ASIMDSAME2_G); rc = 0; };
 }
 return rc;
}


int UMNEGL_UMSUBL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9BA0FC00) {
  decode_fields32(ENC_UMNEGL_UMSUBL_64WA_DP_3SRC, ctx, instr);
  {instr->encoding = (ENC_UMNEGL_UMSUBL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_UMNEGL_UMSUBL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int UMOV_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE003C00) {
  decode_fields32(ENC_UMOV_ASIMDINS_W_W, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->Q<<5)|ctx->imm5)&0x21)==1) {
   ctx->size = 0;
  }
  else if((((ctx->Q<<5)|ctx->imm5)&0x23)==2) {
   ctx->size = 1;
  }
  else if((((ctx->Q<<5)|ctx->imm5)&0x27)==4) {
   ctx->size = 2;
  }
  else if((((ctx->Q<<5)|ctx->imm5)&0x2f)==0x28) {
   ctx->size = 3;
  }
  else {
   { return -4; };
  }
  ctx->idxdsize = ((((ctx->imm5)>>(4)) & (((uint64_t)1<<((4)-(4)+1))-1))==1) ? 0x80 : 0x40;
  ctx->index = (unsigned int)((((ctx->imm5)>>(ctx->size+1)) & (((uint64_t)1<<((4)-(ctx->size+1)+1))-1)));
  ctx->esize = (8) << (ctx->size);
  ctx->datasize = (ctx->Q==1) ? 0x40 : 0x20;

  if(((ctx->imm5&15)==8) || ((ctx->imm5&7)==4)) return MOV_UMOV_advsimd(ctx, instr);
  if(ctx->Q==0) {instr->encoding = (ENC_UMOV_ASIMDINS_W_W); instr->operation = enc_to_oper(ENC_UMOV_ASIMDINS_W_W); rc = 0; };
  if(ctx->Q==1 && (ctx->imm5&15)==8) {instr->encoding = (ENC_UMOV_ASIMDINS_X_X); instr->operation = enc_to_oper(ENC_UMOV_ASIMDINS_X_X); rc = 0; };
 }
 return rc;
}


int UMSUBL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x9BA08000) {
  decode_fields32(ENC_UMSUBL_64WA_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = 0x40;
  ctx->datasize = 0x20;
  ctx->sub_op = (ctx->o0==1);
  ctx->unsigned_ = (ctx->U==1);

  if(ctx->Ra==0x1f) return UMNEGL_UMSUBL(ctx, instr);
  {instr->encoding = (ENC_UMSUBL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_UMSUBL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int UMULH(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE08000)==0x9BC00000) {
  decode_fields32(ENC_UMULH_64_DP_3SRC, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->a = (unsigned int)(ctx->Ra);
  ctx->destsize = 0x40;
  ctx->datasize = ctx->destsize;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UMULH_64_DP_3SRC); instr->operation = enc_to_oper(ENC_UMULH_64_DP_3SRC); rc = 0; };
 }
 return rc;
}


int UMULL_UMADDL(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x9BA07C00) {
  decode_fields32(ENC_UMULL_UMADDL_64WA_DP_3SRC, ctx, instr);
  {instr->encoding = (ENC_UMULL_UMADDL_64WA_DP_3SRC); instr->operation = enc_to_oper(ENC_UMULL_UMADDL_64WA_DP_3SRC); rc = 0; };
 }
 return rc;
}


int UMULL_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF00F400)==0x2F00A000) {
  decode_fields32(ENC_UMULL_ASIMDELEM_L, ctx, instr);
  ctx->idxdsize = (ctx->H==1) ? 0x80 : 0x40;
  if(ctx->size==1) {
   ctx->index = (unsigned int)(((ctx->H<<2)|(ctx->L<<1)|ctx->M));
   ctx->Rmhi = 0;
  }
  else if(ctx->size==2) {
   ctx->index = (unsigned int)(((ctx->H<<1)|ctx->L));
   ctx->Rmhi = ctx->M;
  }
  else {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->Rmhi<<4)|ctx->Rm));
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UMULL_ASIMDELEM_L); instr->operation = enc_to_oper(ENC_UMULL_ASIMDELEM_L); rc = 0; };
 }
 return rc;
}


int UMULL_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E20C000) {
  decode_fields32(ENC_UMULL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UMULL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_UMULL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int UQADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E200C00) {
  decode_fields32(ENC_UQADD_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQADD_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQADD_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E200C00) {
  decode_fields32(ENC_UQADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UQRSHL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E205C00) {
  decode_fields32(ENC_UQRSHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_UQRSHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQRSHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E205C00) {
  decode_fields32(ENC_UQRSHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_UQRSHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQRSHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UQRSHRN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F009C00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UQRSHRN_ASISDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQRSHRN_ASISDSHF_N); instr->operation = enc_to_oper(ENC_UQRSHRN_ASISDSHF_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F009C00 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UQRSHRN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQRSHRN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_UQRSHRN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int UQSHL_advsimd_imm(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F007400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UQSHL_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  if(!((ctx->op<<1)|ctx->U)) {
   { return -4; };
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->src_unsigned = 
# 29019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 29020 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29020 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->src_unsigned = 
# 29023 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29023 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 29024 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29024 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->src_unsigned = 
# 29027 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29027 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->dst_unsigned = 
# 29028 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29028 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  {instr->encoding = (ENC_UQSHL_ASISDSHF_R); instr->operation = enc_to_oper(ENC_UQSHL_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F007400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UQSHL_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  if(!((ctx->op<<1)|ctx->U)) {
   { return -4; };
  }
  else if(((ctx->op<<1)|ctx->U)==1) {
   ctx->src_unsigned = 
# 29052 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29052 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 29053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->op<<1)|ctx->U)==2) {
   ctx->src_unsigned = 
# 29056 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29056 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->dst_unsigned = 
# 29057 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29057 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->op<<1)|ctx->U)==3) {
   ctx->src_unsigned = 
# 29060 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29060 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->dst_unsigned = 
# 29061 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29061 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  {instr->encoding = (ENC_UQSHL_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_UQSHL_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int UQSHL_advsimd_reg(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E204C00) {
  decode_fields32(ENC_UQSHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_UQSHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQSHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E204C00) {
  decode_fields32(ENC_UQSHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_UQSHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQSHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UQSHRN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F009400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UQSHRN_ASISDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -4; };
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->part = 0;
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQSHRN_ASISDSHF_N); instr->operation = enc_to_oper(ENC_UQSHRN_ASISDSHF_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F009400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UQSHRN_ASIMDSHF_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->round = (ctx->op==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQSHRN_ASIMDSHF_N); instr->operation = enc_to_oper(ENC_UQSHRN_ASIMDSHF_N); rc = 0; };
 }
 return rc;
}


int UQSUB_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E202C00) {
  decode_fields32(ENC_UQSUB_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQSUB_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQSUB_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E202C00) {
  decode_fields32(ENC_UQSUB_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQSUB_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_UQSUB_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int UQXTN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x7E214800) {
  decode_fields32(ENC_UQXTN_ASISDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->part = 0;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQXTN_ASISDMISC_N); instr->operation = enc_to_oper(ENC_UQXTN_ASISDMISC_N); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0x2E214800) {
  decode_fields32(ENC_UQXTN_ASIMDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_UQXTN_ASIMDMISC_N); instr->operation = enc_to_oper(ENC_UQXTN_ASIMDMISC_N); rc = 0; };
 }
 return rc;
}


int URECPE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0xEA1C800) {
  decode_fields32(ENC_URECPE_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_URECPE_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_URECPE_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int URHADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E201400) {
  decode_fields32(ENC_URHADD_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_URHADD_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_URHADD_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int URSHL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E205400) {
  decode_fields32(ENC_URSHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_URSHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_URSHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E205400) {
  decode_fields32(ENC_URSHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_URSHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_URSHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int URSHR_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F002400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_URSHR_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_URSHR_ASISDSHF_R); instr->operation = enc_to_oper(ENC_URSHR_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F002400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_URSHR_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_URSHR_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_URSHR_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int URSQRTE_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFBFFC00)==0x2EA1C800) {
  decode_fields32(ENC_URSQRTE_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->sz==1) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_URSQRTE_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_URSQRTE_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int URSRA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F003400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_URSRA_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_URSRA_ASISDSHF_R); instr->operation = enc_to_oper(ENC_URSRA_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F003400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_URSRA_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_URSRA_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_URSRA_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int USDOT_advsimd_elt(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFC0F400)==0xF80F000) {
  decode_fields32(ENC_USDOT_ASIMDELEM_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->op1_unsigned = (ctx->US==1);
  ctx->op2_unsigned = (ctx->US==0);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(((ctx->M<<4)|ctx->Rm));
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->i = (unsigned int)(((ctx->H<<1)|ctx->L));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((0x20) ? ((ctx->datasize) / (0x20)) : 0);
  {instr->encoding = (ENC_USDOT_ASIMDELEM_D); instr->operation = enc_to_oper(ENC_USDOT_ASIMDELEM_D); rc = 0; };
 }
 return rc;
}


int USDOT_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBFE0FC00)==0xE809C00) {
  decode_fields32(ENC_USDOT_ASIMDSAME2_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((0x20) ? ((ctx->datasize) / (0x20)) : 0);
  {instr->encoding = (ENC_USDOT_ASIMDSAME2_D); instr->operation = enc_to_oper(ENC_USDOT_ASIMDSAME2_D); rc = 0; };
 }
 return rc;
}


int USHLL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF80FC00)==0x2F00A400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_USHLL_ASIMDSHF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==1) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = (unsigned int)(((ctx->immh<<3)|ctx->immb))-ctx->esize;
  ctx->unsigned_ = (ctx->U==1);

  if(ctx->immb==0 && BitCount(ctx->immh)==1) return UXTL_USHLL_advsimd(ctx, instr);
  {instr->encoding = (ENC_USHLL_ASIMDSHF_L); instr->operation = enc_to_oper(ENC_USHLL_ASIMDSHF_L); rc = 0; };
 }
 return rc;
}


int USHL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x7E204400) {
  decode_fields32(ENC_USHL_ASISDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  if(ctx->S==0 && ctx->size!=3) {
   { return -4; };
  }
  {instr->encoding = (ENC_USHL_ASISDSAME_ONLY); instr->operation = enc_to_oper(ENC_USHL_ASISDSAME_ONLY); rc = 0; };
 }


 if(((ctx->insword) & 0xBF20FC00)==0x2E204400) {
  decode_fields32(ENC_USHL_ASIMDSAME_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  ctx->rounding = (ctx->R==1);
  ctx->saturating = (ctx->S==1);
  {instr->encoding = (ENC_USHL_ASIMDSAME_ONLY); instr->operation = enc_to_oper(ENC_USHL_ASIMDSAME_ONLY); rc = 0; };
 }
 return rc;
}


int USHR_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F000400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_USHR_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_USHR_ASISDSHF_R); instr->operation = enc_to_oper(ENC_USHR_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F000400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_USHR_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_USHR_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_USHR_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int USMMLA_advsimd_vec(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4E80AC00) {
  decode_fields32(ENC_USMMLA_ASIMDSAME2_G, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  if(!((ctx->B<<1)|ctx->U)) {
   ctx->op1_unsigned = 
# 29610 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29610 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
   ctx->op2_unsigned = 
# 29611 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29611 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->B<<1)|ctx->U)==1) {
   ctx->op1_unsigned = 
# 29614 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29614 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->op2_unsigned = 
# 29615 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29615 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  }
  else if(((ctx->B<<1)|ctx->U)==2) {
   ctx->op1_unsigned = 
# 29618 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 29618 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
   ctx->op2_unsigned = 
# 29619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      0
# 29619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                           ;
  }
  else if(((ctx->B<<1)|ctx->U)==3) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Rd);
  {instr->encoding = (ENC_USMMLA_ASIMDSAME2_G); instr->operation = enc_to_oper(ENC_USMMLA_ASIMDSAME2_G); rc = 0; };
 }
 return rc;
}


int USQADD_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x7E203800) {
  decode_fields32(ENC_USQADD_ASISDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_USQADD_ASISDMISC_R); instr->operation = enc_to_oper(ENC_USQADD_ASISDMISC_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF3FFC00)==0x2E203800) {
  decode_fields32(ENC_USQADD_ASIMDMISC_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_USQADD_ASIMDMISC_R); instr->operation = enc_to_oper(ENC_USQADD_ASIMDMISC_R); rc = 0; };
 }
 return rc;
}


int USRA_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80FC00)==0x7F001400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_USRA_ASISDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))!=1) {
   { return -4; };
  }
  ctx->esize = (8) << (3);
  ctx->datasize = ctx->esize;
  ctx->elements = 1;
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_USRA_ASISDSHF_R); instr->operation = enc_to_oper(ENC_USRA_ASISDSHF_R); rc = 0; };
 }


 if(((ctx->insword) & 0xBF80FC00)==0x2F001400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_USRA_ASIMDSHF_R, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->immh==0) {
   { return -6; } ;
  }
  if((((((ctx->immh)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))<<1)|ctx->Q)==2) {
   { return -4; };
  }
  ctx->esize = (8) << (HighestSetBit(ctx->immh));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->shift = ((ctx->esize) * (2))-(unsigned int)(((ctx->immh<<3)|ctx->immb));
  ctx->unsigned_ = (ctx->U==1);
  ctx->round = (ctx->o1==1);
  ctx->accumulate = (ctx->o0==1);
  {instr->encoding = (ENC_USRA_ASIMDSHF_R); instr->operation = enc_to_oper(ENC_USRA_ASIMDSHF_R); rc = 0; };
 }
 return rc;
}


int USUBL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E202000) {
  decode_fields32(ENC_USUBL_ASIMDDIFF_L, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_USUBL_ASIMDDIFF_L); instr->operation = enc_to_oper(ENC_USUBL_ASIMDDIFF_L); rc = 0; };
 }
 return rc;
}


int USUBW_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0x2E203000) {
  decode_fields32(ENC_USUBW_ASIMDDIFF_W, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->sub_op = (ctx->o1==1);
  ctx->unsigned_ = (ctx->U==1);
  {instr->encoding = (ENC_USUBW_ASIMDDIFF_W); instr->operation = enc_to_oper(ENC_USUBW_ASIMDDIFF_W); rc = 0; };
 }
 return rc;
}


int UXTB_UBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x53001C00) {
  decode_fields32(ENC_UXTB_UBFM_32M_BITFIELD, ctx, instr);
  {instr->encoding = (ENC_UXTB_UBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_UXTB_UBFM_32M_BITFIELD); rc = 0; };
 }
 return rc;
}


int UXTH_UBFM(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x53003C00) {
  decode_fields32(ENC_UXTH_UBFM_32M_BITFIELD, ctx, instr);
  {instr->encoding = (ENC_UXTH_UBFM_32M_BITFIELD); instr->operation = enc_to_oper(ENC_UXTH_UBFM_32M_BITFIELD); rc = 0; };
 }
 return rc;
}


int UXTL_USHLL_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF87FC00)==0x2F00A400 && ((ctx->insword) & 0x780000)!=0x0) {
  decode_fields32(ENC_UXTL_USHLL_ASIMDSHF_L, ctx, instr);
  {instr->encoding = (ENC_UXTL_USHLL_ASIMDSHF_L); instr->operation = enc_to_oper(ENC_UXTL_USHLL_ASIMDSHF_L); rc = 0; };
 }
 return rc;
}


int UZP1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE001800) {
  decode_fields32(ENC_UZP1_ASIMDPERM_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->part = (unsigned int)(ctx->op);
  {instr->encoding = (ENC_UZP1_ASIMDPERM_ONLY); instr->operation = enc_to_oper(ENC_UZP1_ASIMDPERM_ONLY); rc = 0; };
 }
 return rc;
}


int UZP2_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE005800) {
  decode_fields32(ENC_UZP2_ASIMDPERM_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->part = (unsigned int)(ctx->op);
  {instr->encoding = (ENC_UZP2_ASIMDPERM_ONLY); instr->operation = enc_to_oper(ENC_UZP2_ASIMDPERM_ONLY); rc = 0; };
 }
 return rc;
}


int WFE(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503205F) {
  decode_fields32(ENC_WFE_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_WFE_HI_HINTS); instr->operation = enc_to_oper(ENC_WFE_HI_HINTS); rc = 0; };
 }
 return rc;
}


int WFET(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0xD5031000) {
  decode_fields32(ENC_WFET_ONLY_SYSTEMINSTRSWITHREG, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<14))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  if(!ctx->op2) {
   ctx->op = SystemHintOp_WFET;
  }
  else if(ctx->op2==1) {
   ctx->op = SystemHintOp_WFIT;
  }
  {instr->encoding = (ENC_WFET_ONLY_SYSTEMINSTRSWITHREG); instr->operation = enc_to_oper(ENC_WFET_ONLY_SYSTEMINSTRSWITHREG); rc = 0; };
 }
 return rc;
}


int WFI(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503207F) {
  decode_fields32(ENC_WFI_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_WFI_HI_HINTS); instr->operation = enc_to_oper(ENC_WFI_HI_HINTS); rc = 0; };
 }
 return rc;
}


int WFIT(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0xD5031020) {
  decode_fields32(ENC_WFIT_ONLY_SYSTEMINSTRSWITHREG, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<14))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  if(!ctx->op2) {
   ctx->op = SystemHintOp_WFET;
  }
  else if(ctx->op2==1) {
   ctx->op = SystemHintOp_WFIT;
  }
  {instr->encoding = (ENC_WFIT_ONLY_SYSTEMINSTRSWITHREG); instr->operation = enc_to_oper(ENC_WFIT_ONLY_SYSTEMINSTRSWITHREG); rc = 0; };
 }
 return rc;
}


int XAFLAG(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF0FF)==0xD500403F) {
  decode_fields32(ENC_XAFLAG_M_PSTATE, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<16))) {
   { return -4; };
  }
  {instr->encoding = (ENC_XAFLAG_M_PSTATE); instr->operation = enc_to_oper(ENC_XAFLAG_M_PSTATE); rc = 0; };
 }
 return rc;
}


int XAR_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE00000)==0xCE800000) {
  decode_fields32(ENC_XAR_VVV2_CRYPTO3_IMM6, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<30))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_XAR_VVV2_CRYPTO3_IMM6); instr->operation = enc_to_oper(ENC_XAR_VVV2_CRYPTO3_IMM6); rc = 0; };
 }
 return rc;
}


int XPAC(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFBE0)==0xDAC143E0) {
  decode_fields32(ENC_XPACD_64Z_DP_1SRC, ctx, instr);
  ctx->data = (ctx->D==1);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(!(ctx->features1 & ((uint64_t)1<<23))) {
   { return -4; };
  }
  if(ctx->n!=0x1f) {
   { return -4; };
  }
  if(ctx->D==1) {instr->encoding = (ENC_XPACD_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_XPACD_64Z_DP_1SRC); rc = 0; };
  if(ctx->D==0) {instr->encoding = (ENC_XPACI_64Z_DP_1SRC); instr->operation = enc_to_oper(ENC_XPACI_64Z_DP_1SRC); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFFFFF)==0xD50320FF) {
  decode_fields32(ENC_XPACLRI_HI_HINTS, ctx, instr);
  {instr->encoding = (ENC_XPACLRI_HI_HINTS); instr->operation = enc_to_oper(ENC_XPACLRI_HI_HINTS); rc = 0; };
 }
 return rc;
}


int XTN_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF3FFC00)==0xE212800) {
  decode_fields32(ENC_XTN_ASIMDMISC_N, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = 0x40;
  ctx->part = (unsigned int)(ctx->Q);
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  {instr->encoding = (ENC_XTN_ASIMDMISC_N); instr->operation = enc_to_oper(ENC_XTN_ASIMDMISC_N); rc = 0; };
 }
 return rc;
}


int YIELD(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0xD503203F) {
  decode_fields32(ENC_YIELD_HI_HINTS, ctx, instr);
  if(!((ctx->CRm<<3)|ctx->op2)) {
   ctx->op = SystemHintOp_NOP;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==1) {
   ctx->op = SystemHintOp_YIELD;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==2) {
   ctx->op = SystemHintOp_WFE;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==3) {
   ctx->op = SystemHintOp_WFI;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==4) {
   ctx->op = SystemHintOp_SEV;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==5) {
   ctx->op = SystemHintOp_SEVL;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==6) {
   if(!(ctx->features1 & ((uint64_t)1<<6))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_DGH;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==7) {
   { return -6; } ;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==8) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else {
    { return -5; };
   }
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x10) {
   if(!(ctx->features1 & ((uint64_t)1<<26))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_ESB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x11) {
   if(!(ctx->features1 & ((uint64_t)1<<45))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_PSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x12) {
   if(!(ctx->features1 & ((uint64_t)1<<44))) {
    { return -5; };
   }
   ctx->op = SystemHintOp_TSB;
  }
  else if(((ctx->CRm<<3)|ctx->op2)==0x14) {
   ctx->op = SystemHintOp_CSDB;
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x78)==0x18) {
   if(!ctx->op2) {
    { return -6; } ;
   }
   else if(ctx->op2==1) {
    { return -6; } ;
   }
   else if(ctx->op2==2) {
    { return -6; } ;
   }
   else if(ctx->op2==3) {
    { return -6; } ;
   }
   else if(ctx->op2==4) {
    { return -6; } ;
   }
   else if(ctx->op2==5) {
    { return -6; } ;
   }
   else if(ctx->op2==6) {
    { return -6; } ;
   }
   else if(ctx->op2==7) {
    { return -6; } ;
   }
  }
  else if((((ctx->CRm<<3)|ctx->op2)&0x79)==0x20) {
   ctx->op = SystemHintOp_BTI;
   ctx->BTypeCompatible = (BTypeCompatible_BTI((((ctx->op2)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)), ctx->pstate_btype));
  }
  else {
   { return -5; };
  }
  {instr->encoding = (ENC_YIELD_HI_HINTS); instr->operation = enc_to_oper(ENC_YIELD_HI_HINTS); rc = 0; };
 }
 return rc;
}


int ZIP1_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE003800) {
  decode_fields32(ENC_ZIP1_ASIMDPERM_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->part = (unsigned int)(ctx->op);
  ctx->pairs = ((2) ? ((ctx->elements) / (2)) : 0);
  {instr->encoding = (ENC_ZIP1_ASIMDPERM_ONLY); instr->operation = enc_to_oper(ENC_ZIP1_ASIMDPERM_ONLY); rc = 0; };
 }
 return rc;
}


int ZIP2_advsimd(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xBF20FC00)==0xE007800) {
  decode_fields32(ENC_ZIP2_ASIMDPERM_ONLY, ctx, instr);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  if(((ctx->size<<1)|ctx->Q)==6) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->datasize = (ctx->Q==1) ? 0x80 : 0x40;
  ctx->elements = ((ctx->esize) ? ((ctx->datasize) / (ctx->esize)) : 0);
  ctx->part = (unsigned int)(ctx->op);
  ctx->pairs = ((2) ? ((ctx->elements) / (2)) : 0);
  {instr->encoding = (ENC_ZIP2_ASIMDPERM_ONLY); instr->operation = enc_to_oper(ENC_ZIP2_ASIMDPERM_ONLY); rc = 0; };
 }
 return rc;
}


int abs_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x416A000) {
  decode_fields32(ENC_ABS_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_ABS_Z_P_Z_); instr->operation = enc_to_oper(ENC_ABS_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int adclb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4500D000) {
  decode_fields32(ENC_ADCLB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_ADCLB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_ADCLB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int adclt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4500D400) {
  decode_fields32(ENC_ADCLT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_ADCLT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_ADCLT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int add_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4000000) {
  decode_fields32(ENC_ADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_ADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_ADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int add_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2520C000) {
  decode_fields32(ENC_ADD_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (unsigned int)(ctx->imm8);
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }
  {instr->encoding = (ENC_ADD_Z_ZI_); instr->operation = enc_to_oper(ENC_ADD_Z_ZI_); rc = 0; };
 }
 return rc;
}


int add_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4200000) {
  decode_fields32(ENC_ADD_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_ADD_Z_ZZ_); instr->operation = enc_to_oper(ENC_ADD_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int addhnb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45206000) {
  decode_fields32(ENC_ADDHNB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_ADDHNB_Z_ZZ_); instr->operation = enc_to_oper(ENC_ADDHNB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int addhnt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45206400) {
  decode_fields32(ENC_ADDHNT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_ADDHNT_Z_ZZ_); instr->operation = enc_to_oper(ENC_ADDHNT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int addp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4411A000) {
  decode_fields32(ENC_ADDP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_ADDP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_ADDP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int addpl_r_ri(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F800)==0x4605000) {
  decode_fields32(ENC_ADDPL_R_RI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->imm = SignExtend((ctx->imm6),(6));
  {instr->encoding = (ENC_ADDPL_R_RI_); instr->operation = enc_to_oper(ENC_ADDPL_R_RI_); rc = 0; };
 }
 return rc;
}


int addvl_r_ri(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F800)==0x4205000) {
  decode_fields32(ENC_ADDVL_R_RI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->imm = SignExtend((ctx->imm6),(6));
  {instr->encoding = (ENC_ADDVL_R_RI_); instr->operation = enc_to_oper(ENC_ADDVL_R_RI_); rc = 0; };
 }
 return rc;
}


int adr_z_az(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0F000)==0x4A0A000) {
  decode_fields32(ENC_ADR_Z_AZ_SD_SAME_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->osize = ctx->esize;
  ctx->unsigned_ = 
# 30605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 30605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->mbytes = (1) << ((unsigned int)(ctx->msz));
  {instr->encoding = (ENC_ADR_Z_AZ_SD_SAME_SCALED); instr->operation = enc_to_oper(ENC_ADR_Z_AZ_SD_SAME_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F000)==0x420A000) {
  decode_fields32(ENC_ADR_Z_AZ_D_S32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->osize = 0x20;
  ctx->unsigned_ = 
# 30621 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 30621 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->mbytes = (1) << ((unsigned int)(ctx->msz));
  {instr->encoding = (ENC_ADR_Z_AZ_D_S32_SCALED); instr->operation = enc_to_oper(ENC_ADR_Z_AZ_D_S32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F000)==0x460A000) {
  decode_fields32(ENC_ADR_Z_AZ_D_U32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->osize = 0x20;
  ctx->unsigned_ = 
# 30637 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 30637 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->mbytes = (1) << ((unsigned int)(ctx->msz));
  {instr->encoding = (ENC_ADR_Z_AZ_D_U32_SCALED); instr->operation = enc_to_oper(ENC_ADR_Z_AZ_D_U32_SCALED); rc = 0; };
 }
 return rc;
}


int aesd_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x4522E400) {
  decode_fields32(ENC_AESD_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<37))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_AESD_Z_ZZ_); instr->operation = enc_to_oper(ENC_AESD_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int aese_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x4522E000) {
  decode_fields32(ENC_AESE_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<37))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_AESE_Z_ZZ_); instr->operation = enc_to_oper(ENC_AESE_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int aesimc_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0x4520E400) {
  decode_fields32(ENC_AESIMC_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<37))) {
   { return -4; };
  }
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_AESIMC_Z_Z_); instr->operation = enc_to_oper(ENC_AESIMC_Z_Z_); rc = 0; };
 }
 return rc;
}


int aesmc_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFE0)==0x4520E000) {
  decode_fields32(ENC_AESMC_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<37))) {
   { return -4; };
  }
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_AESMC_Z_Z_); instr->operation = enc_to_oper(ENC_AESMC_Z_Z_); rc = 0; };
 }
 return rc;
}


int and_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25004000) {
  decode_fields32(ENC_AND_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 30730 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 30730 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 30731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 30731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;

  if(ctx->S==1 && ctx->Pn==ctx->Pm) return MOVS_and_p_p_pp(ctx, instr);
  if(ctx->S==0 && ctx->Pn==ctx->Pm) return MOV_and_p_p_pp(ctx, instr);
  {instr->encoding = (ENC_AND_P_P_PP_Z); instr->operation = enc_to_oper(ENC_AND_P_P_PP_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x25404000) {
  decode_fields32(ENC_ANDS_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 30749 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 30749 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 30750 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 30750 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;

  if(ctx->S==1 && ctx->Pn==ctx->Pm) return MOVS_and_p_p_pp(ctx, instr);
  if(ctx->S==0 && ctx->Pn==ctx->Pm) return MOV_and_p_p_pp(ctx, instr);
  {instr->encoding = (ENC_ANDS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_ANDS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int and_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41A0000) {
  decode_fields32(ENC_AND_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_AND_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_AND_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int and_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5800000) {
  decode_fields32(ENC_AND_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->dn = (unsigned int)(ctx->Zdn);
  if(((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==0 && ((((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3D || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3B || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x37 || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x2F || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x1F)) || ((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==1 && (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1)),(((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1)),(((ctx->imm13)>>(6)) & (((uint64_t)1<<((11)-(6)+1))-1)));
  ctx->imm = dbmrt.wmask;
  {instr->encoding = (ENC_AND_Z_ZI_); instr->operation = enc_to_oper(ENC_AND_Z_ZI_); rc = 0; };
 }
 return rc;
}


int and_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4203000) {
  decode_fields32(ENC_AND_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_AND_Z_ZZ_); instr->operation = enc_to_oper(ENC_AND_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int andv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41A2000) {
  decode_fields32(ENC_ANDV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_ANDV_R_P_Z_); instr->operation = enc_to_oper(ENC_ANDV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int asr_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4008000) {
  decode_fields32(ENC_ASR_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_ASR_Z_P_ZI_); instr->operation = enc_to_oper(ENC_ASR_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int asr_z_p_zw(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4188000) {
  decode_fields32(ENC_ASR_Z_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_ASR_Z_P_ZW_); instr->operation = enc_to_oper(ENC_ASR_Z_P_ZW_); rc = 0; };
 }
 return rc;
}


int asr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4108000) {
  decode_fields32(ENC_ASR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_ASR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_ASR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int asr_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4209000) {
  decode_fields32(ENC_ASR_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_ASR_Z_ZI_); instr->operation = enc_to_oper(ENC_ASR_Z_ZI_); rc = 0; };
 }
 return rc;
}


int asr_z_zw(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4208000) {
  decode_fields32(ENC_ASR_Z_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_ASR_Z_ZW_); instr->operation = enc_to_oper(ENC_ASR_Z_ZW_); rc = 0; };
 }
 return rc;
}


int asrd_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4048000) {
  decode_fields32(ENC_ASRD_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_ASRD_Z_P_ZI_); instr->operation = enc_to_oper(ENC_ASRD_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int asrr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4148000) {
  decode_fields32(ENC_ASRR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_ASRR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_ASRR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int bcax_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4603800) {
  decode_fields32(ENC_BCAX_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->k = (unsigned int)(ctx->Zk);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_BCAX_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BCAX_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int bdep_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500B400) {
  decode_fields32(ENC_BDEP_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<38))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_BDEP_Z_ZZ_); instr->operation = enc_to_oper(ENC_BDEP_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int bext_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500B000) {
  decode_fields32(ENC_BEXT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<38))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_BEXT_Z_ZZ_); instr->operation = enc_to_oper(ENC_BEXT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int bfcvt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x658AA000) {
  decode_fields32(ENC_BFCVT_Z_P_Z_S2BF, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_BFCVT_Z_P_Z_S2BF); instr->operation = enc_to_oper(ENC_BFCVT_Z_P_Z_S2BF); rc = 0; };
 }
 return rc;
}


int bfcvtnt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x648AA000) {
  decode_fields32(ENC_BFCVTNT_Z_P_Z_S2BF, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_BFCVTNT_Z_P_Z_S2BF); instr->operation = enc_to_oper(ENC_BFCVTNT_Z_P_Z_S2BF); rc = 0; };
 }
 return rc;
}


int bfdot_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64608000) {
  decode_fields32(ENC_BFDOT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_BFDOT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BFDOT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int bfdot_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64604000) {
  decode_fields32(ENC_BFDOT_Z_ZZZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->index = (unsigned int)(ctx->i2);
  {instr->encoding = (ENC_BFDOT_Z_ZZZI_); instr->operation = enc_to_oper(ENC_BFDOT_Z_ZZZI_); rc = 0; };
 }
 return rc;
}


int bfmlalb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64E08000) {
  decode_fields32(ENC_BFMLALB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_BFMLALB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BFMLALB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int bfmlalb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x64E04000) {
  decode_fields32(ENC_BFMLALB_Z_ZZZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  {instr->encoding = (ENC_BFMLALB_Z_ZZZI_); instr->operation = enc_to_oper(ENC_BFMLALB_Z_ZZZI_); rc = 0; };
 }
 return rc;
}


int bfmlalt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64E08400) {
  decode_fields32(ENC_BFMLALT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_BFMLALT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BFMLALT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int bfmlalt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x64E04400) {
  decode_fields32(ENC_BFMLALT_Z_ZZZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  {instr->encoding = (ENC_BFMLALT_Z_ZZZI_); instr->operation = enc_to_oper(ENC_BFMLALT_Z_ZZZI_); rc = 0; };
 }
 return rc;
}


int bfmmla_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x6460E400) {
  decode_fields32(ENC_BFMMLA_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<2))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_BFMMLA_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BFMMLA_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int bgrp_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500B800) {
  decode_fields32(ENC_BGRP_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<38))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_BGRP_Z_ZZ_); instr->operation = enc_to_oper(ENC_BGRP_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int bic_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25004010) {
  decode_fields32(ENC_BIC_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 31298 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 31298 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 31299 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31299 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_BIC_P_P_PP_Z); instr->operation = enc_to_oper(ENC_BIC_P_P_PP_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x25404010) {
  decode_fields32(ENC_BICS_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 31314 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 31314 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 31315 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31315 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_BICS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_BICS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int bic_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41B0000) {
  decode_fields32(ENC_BIC_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_BIC_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_BIC_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int bic_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4E03000) {
  decode_fields32(ENC_BIC_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_BIC_Z_ZZ_); instr->operation = enc_to_oper(ENC_BIC_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int brka_p_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFC200)==0x25104000) {
  decode_fields32(ENC_BRKA_P_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->merging = (ctx->M==1);
  instr->setflags = 
# 31376 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 31376 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 31377 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31377 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_BRKA_P_P_P_); instr->operation = enc_to_oper(ENC_BRKA_P_P_P_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFC210)==0x25504000) {
  decode_fields32(ENC_BRKAS_P_P_P_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->merging = 
# 31391 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 31391 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  instr->setflags = 
# 31392 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 31392 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 31393 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31393 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_BRKAS_P_P_P_Z); instr->operation = enc_to_oper(ENC_BRKAS_P_P_P_Z); rc = 0; };
 }
 return rc;
}


int brkb_p_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFC200)==0x25904000) {
  decode_fields32(ENC_BRKB_P_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->merging = (ctx->M==1);
  instr->setflags = 
# 31415 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 31415 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 31416 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31416 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_BRKB_P_P_P_); instr->operation = enc_to_oper(ENC_BRKB_P_P_P_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFC210)==0x25D04000) {
  decode_fields32(ENC_BRKBS_P_P_P_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->merging = 
# 31430 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 31430 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  instr->setflags = 
# 31431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 31431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 31432 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31432 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_BRKBS_P_P_P_Z); instr->operation = enc_to_oper(ENC_BRKBS_P_P_P_Z); rc = 0; };
 }
 return rc;
}


int brkn_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFC210)==0x25184000) {
  decode_fields32(ENC_BRKN_P_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->dm = (unsigned int)(ctx->Pdm);
  instr->setflags = 
# 31452 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 31452 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 31453 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31453 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_BRKN_P_P_PP_); instr->operation = enc_to_oper(ENC_BRKN_P_P_PP_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFC210)==0x25584000) {
  decode_fields32(ENC_BRKNS_P_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->dm = (unsigned int)(ctx->Pdm);
  instr->setflags = 
# 31466 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 31466 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 31467 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31467 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_BRKNS_P_P_PP_); instr->operation = enc_to_oper(ENC_BRKNS_P_P_PP_); rc = 0; };
 }
 return rc;
}


int brkpa_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x2500C000) {
  decode_fields32(ENC_BRKPA_P_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 31489 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 31489 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 31490 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31490 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_BRKPA_P_P_PP_); instr->operation = enc_to_oper(ENC_BRKPA_P_P_PP_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x2540C000) {
  decode_fields32(ENC_BRKPAS_P_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 31505 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 31505 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 31506 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31506 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_BRKPAS_P_P_PP_); instr->operation = enc_to_oper(ENC_BRKPAS_P_P_PP_); rc = 0; };
 }
 return rc;
}


int brkpb_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x2500C010) {
  decode_fields32(ENC_BRKPB_P_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 31528 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 31528 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 31529 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31529 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_BRKPB_P_P_PP_); instr->operation = enc_to_oper(ENC_BRKPB_P_P_PP_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x2540C010) {
  decode_fields32(ENC_BRKPBS_P_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 31544 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 31544 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 31545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_BRKPBS_P_P_PP_); instr->operation = enc_to_oper(ENC_BRKPBS_P_P_PP_); rc = 0; };
 }
 return rc;
}


int bsl1n_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4603C00) {
  decode_fields32(ENC_BSL1N_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->k = (unsigned int)(ctx->Zk);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_BSL1N_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BSL1N_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int bsl2n_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4A03C00) {
  decode_fields32(ENC_BSL2N_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->k = (unsigned int)(ctx->Zk);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_BSL2N_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BSL2N_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int bsl_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4203C00) {
  decode_fields32(ENC_BSL_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->k = (unsigned int)(ctx->Zk);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_BSL_Z_ZZZ_); instr->operation = enc_to_oper(ENC_BSL_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int cadd_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FF800)==0x4500D800) {
  decode_fields32(ENC_CADD_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->sub_i = (ctx->rot==0);
  ctx->sub_r = (ctx->rot==1);
  {instr->encoding = (ENC_CADD_Z_ZZ_); instr->operation = enc_to_oper(ENC_CADD_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int cdot_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20F000)==0x44001000) {
  decode_fields32(ENC_CDOT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  {instr->encoding = (ENC_CDOT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_CDOT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int cdot_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F000)==0x44A04000) {
  decode_fields32(ENC_CDOT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  {instr->encoding = (ENC_CDOT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_CDOT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F000)==0x44E04000) {
  decode_fields32(ENC_CDOT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  {instr->encoding = (ENC_CDOT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_CDOT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int clasta_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x530A000) {
  decode_fields32(ENC_CLASTA_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->csize = (ctx->esize<0x40) ? 0x20 : 0x40;
  ctx->isBefore = 
# 31712 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31712 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CLASTA_R_P_Z_); instr->operation = enc_to_oper(ENC_CLASTA_R_P_Z_); rc = 0; };
 }
 return rc;
}


int clasta_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x52A8000) {
  decode_fields32(ENC_CLASTA_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Vdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->isBefore = 
# 31733 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31733 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CLASTA_V_P_Z_); instr->operation = enc_to_oper(ENC_CLASTA_V_P_Z_); rc = 0; };
 }
 return rc;
}


int clasta_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5288000) {
  decode_fields32(ENC_CLASTA_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->isBefore = 
# 31754 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 31754 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CLASTA_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_CLASTA_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int clastb_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x531A000) {
  decode_fields32(ENC_CLASTB_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->csize = (ctx->esize<0x40) ? 0x20 : 0x40;
  ctx->isBefore = 
# 31776 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31776 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_CLASTB_R_P_Z_); instr->operation = enc_to_oper(ENC_CLASTB_R_P_Z_); rc = 0; };
 }
 return rc;
}


int clastb_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x52B8000) {
  decode_fields32(ENC_CLASTB_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Vdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->isBefore = 
# 31797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_CLASTB_V_P_Z_); instr->operation = enc_to_oper(ENC_CLASTB_V_P_Z_); rc = 0; };
 }
 return rc;
}


int clastb_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5298000) {
  decode_fields32(ENC_CLASTB_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->isBefore = 
# 31818 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 31818 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_CLASTB_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_CLASTB_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int cls_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x418A000) {
  decode_fields32(ENC_CLS_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_CLS_Z_P_Z_); instr->operation = enc_to_oper(ENC_CLS_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int clz_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x419A000) {
  decode_fields32(ENC_CLZ_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_CLZ_Z_P_Z_); instr->operation = enc_to_oper(ENC_CLZ_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int cmla_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20F000)==0x44002000) {
  decode_fields32(ENC_CMLA_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  {instr->encoding = (ENC_CMLA_Z_ZZZ_); instr->operation = enc_to_oper(ENC_CMLA_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int cmla_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F000)==0x44A06000) {
  decode_fields32(ENC_CMLA_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  {instr->encoding = (ENC_CMLA_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_CMLA_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F000)==0x44E06000) {
  decode_fields32(ENC_CMLA_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  {instr->encoding = (ENC_CMLA_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_CMLA_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int cmpeq_p_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x25008000) {
  decode_fields32(ENC_CMPEQ_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_EQ;
  ctx->imm = SignExtend((ctx->imm5),(5));
  ctx->unsigned_ = 
# 31948 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 31948 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPEQ_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPEQ_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x25000010) {
  decode_fields32(ENC_CMPGT_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  ctx->imm = SignExtend((ctx->imm5),(5));
  ctx->unsigned_ = 
# 31964 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 31964 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPGT_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPGT_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x25000000) {
  decode_fields32(ENC_CMPGE_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  ctx->imm = SignExtend((ctx->imm5),(5));
  ctx->unsigned_ = 
# 31980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 31980 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPGE_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPGE_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF202010)==0x24200010) {
  decode_fields32(ENC_CMPHI_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  ctx->imm = (unsigned int)(ctx->imm7);
  ctx->unsigned_ = 
# 31996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 31996 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPHI_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPHI_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF202010)==0x24200000) {
  decode_fields32(ENC_CMPHS_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  ctx->imm = (unsigned int)(ctx->imm7);
  ctx->unsigned_ = 
# 32012 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32012 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPHS_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPHS_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x25002000) {
  decode_fields32(ENC_CMPLT_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LT;
  ctx->imm = SignExtend((ctx->imm5),(5));
  ctx->unsigned_ = 
# 32028 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32028 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPLT_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPLT_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x25002010) {
  decode_fields32(ENC_CMPLE_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LE;
  ctx->imm = SignExtend((ctx->imm5),(5));
  ctx->unsigned_ = 
# 32044 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32044 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPLE_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPLE_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF202010)==0x24202000) {
  decode_fields32(ENC_CMPLO_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LT;
  ctx->imm = (unsigned int)(ctx->imm7);
  ctx->unsigned_ = 
# 32060 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32060 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPLO_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPLO_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF202010)==0x24202010) {
  decode_fields32(ENC_CMPLS_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LE;
  ctx->imm = (unsigned int)(ctx->imm7);
  ctx->unsigned_ = 
# 32076 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32076 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPLS_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPLS_P_P_ZI_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x25008010) {
  decode_fields32(ENC_CMPNE_P_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_NE;
  ctx->imm = SignExtend((ctx->imm5),(5));
  ctx->unsigned_ = 
# 32092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32092 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPNE_P_P_ZI_); instr->operation = enc_to_oper(ENC_CMPNE_P_P_ZI_); rc = 0; };
 }
 return rc;
}


int cmpeq_p_p_zw(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x24002000) {
  decode_fields32(ENC_CMPEQ_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_EQ;
  ctx->unsigned_ = 
# 32118 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32118 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPEQ_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPEQ_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24004010) {
  decode_fields32(ENC_CMPGT_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  ctx->unsigned_ = 
# 32137 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32137 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPGT_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPGT_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24004000) {
  decode_fields32(ENC_CMPGE_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  ctx->unsigned_ = 
# 32156 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32156 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPGE_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPGE_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x2400C010) {
  decode_fields32(ENC_CMPHI_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  ctx->unsigned_ = 
# 32175 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32175 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPHI_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPHI_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x2400C000) {
  decode_fields32(ENC_CMPHS_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  ctx->unsigned_ = 
# 32194 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32194 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPHS_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPHS_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24006000) {
  decode_fields32(ENC_CMPLT_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LT;
  ctx->unsigned_ = 
# 32213 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32213 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPLT_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPLT_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24006010) {
  decode_fields32(ENC_CMPLE_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LE;
  ctx->unsigned_ = 
# 32232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPLE_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPLE_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x2400E000) {
  decode_fields32(ENC_CMPLO_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LT;
  ctx->unsigned_ = 
# 32251 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32251 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPLO_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPLO_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x2400E010) {
  decode_fields32(ENC_CMPLS_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LE;
  ctx->unsigned_ = 
# 32270 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32270 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPLS_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPLS_P_P_ZW_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24002010) {
  decode_fields32(ENC_CMPNE_P_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_NE;
  ctx->unsigned_ = 
# 32289 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32289 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPNE_P_P_ZW_); instr->operation = enc_to_oper(ENC_CMPNE_P_P_ZW_); rc = 0; };
 }
 return rc;
}


int cmpeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x2400A000) {
  decode_fields32(ENC_CMPEQ_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_EQ;
  ctx->unsigned_ = 
# 32312 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32312 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPEQ_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPEQ_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24008010) {
  decode_fields32(ENC_CMPGT_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  ctx->unsigned_ = 
# 32328 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32328 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPGT_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPGT_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24008000) {
  decode_fields32(ENC_CMPGE_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  ctx->unsigned_ = 
# 32344 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32344 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPGE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPGE_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24000010) {
  decode_fields32(ENC_CMPHI_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  ctx->unsigned_ = 
# 32360 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32360 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPHI_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPHI_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x24000000) {
  decode_fields32(ENC_CMPHS_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  ctx->unsigned_ = 
# 32376 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 32376 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_CMPHS_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPHS_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x2400A010) {
  decode_fields32(ENC_CMPNE_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_NE;
  ctx->unsigned_ = 
# 32392 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 32392 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_CMPNE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_CMPNE_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int cnot_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41BA000) {
  decode_fields32(ENC_CNOT_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_CNOT_Z_P_Z_); instr->operation = enc_to_oper(ENC_CNOT_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int cnt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41AA000) {
  decode_fields32(ENC_CNT_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_CNT_Z_P_Z_); instr->operation = enc_to_oper(ENC_CNT_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int cntb_r_s(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x420E000) {
  decode_fields32(ENC_CNTB_R_S_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_CNTB_R_S_); instr->operation = enc_to_oper(ENC_CNTB_R_S_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0E000) {
  decode_fields32(ENC_CNTD_R_S_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_CNTD_R_S_); instr->operation = enc_to_oper(ENC_CNTD_R_S_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x460E000) {
  decode_fields32(ENC_CNTH_R_S_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_CNTH_R_S_); instr->operation = enc_to_oper(ENC_CNTH_R_S_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0E000) {
  decode_fields32(ENC_CNTW_R_S_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_CNTW_R_S_); instr->operation = enc_to_oper(ENC_CNTW_R_S_); rc = 0; };
 }
 return rc;
}


int cntp_r_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC200)==0x25208000) {
  decode_fields32(ENC_CNTP_R_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Rd);
  {instr->encoding = (ENC_CNTP_R_P_P_); instr->operation = enc_to_oper(ENC_CNTP_R_P_P_); rc = 0; };
 }
 return rc;
}


int compact_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5218000) {
  decode_fields32(ENC_COMPACT_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_COMPACT_Z_P_Z_); instr->operation = enc_to_oper(ENC_COMPACT_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int cpy_z_o_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30C000)==0x5100000) {
  decode_fields32(ENC_CPY_Z_O_I_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->merging = 
# 32557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 32557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->imm = SignExtend((ctx->imm8),(8));
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }

  if(MOV_cpy_z_o_i(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_CPY_Z_O_I_); instr->operation = enc_to_oper(ENC_CPY_Z_O_I_); rc = 0; };
 }
 return rc;
}


int cpy_z_p_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30C000)==0x5104000) {
  decode_fields32(ENC_CPY_Z_P_I_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->merging = 
# 32586 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 32586 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->imm = SignExtend((ctx->imm8),(8));
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }

  if(MOV_cpy_z_p_i(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_CPY_Z_P_I_); instr->operation = enc_to_oper(ENC_CPY_Z_P_I_); rc = 0; };
 }
 return rc;
}


int cpy_z_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x528A000) {
  decode_fields32(ENC_CPY_Z_P_R_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->d = (unsigned int)(ctx->Zd);

  if(MOV_cpy_z_p_r(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_CPY_Z_P_R_); instr->operation = enc_to_oper(ENC_CPY_Z_P_R_); rc = 0; };
 }
 return rc;
}


int cpy_z_p_v(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5208000) {
  decode_fields32(ENC_CPY_Z_P_V_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Vn);
  ctx->d = (unsigned int)(ctx->Zd);

  if(MOV_cpy_z_p_v(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_CPY_Z_P_V_); instr->operation = enc_to_oper(ENC_CPY_Z_P_V_); rc = 0; };
 }
 return rc;
}


int ctermeq_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC1F)==0x25A02000) {
  decode_fields32(ENC_CTERMEQ_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->op = Cmp_EQ;
  {instr->encoding = (ENC_CTERMEQ_RR_); instr->operation = enc_to_oper(ENC_CTERMEQ_RR_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0FC1F)==0x25A02010) {
  decode_fields32(ENC_CTERMNE_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->op = Cmp_NE;
  {instr->encoding = (ENC_CTERMNE_RR_); instr->operation = enc_to_oper(ENC_CTERMNE_RR_); rc = 0; };
 }
 return rc;
}


int decb_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x430E400) {
  decode_fields32(ENC_DECB_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_DECB_R_RS_); instr->operation = enc_to_oper(ENC_DECB_R_RS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0E400) {
  decode_fields32(ENC_DECD_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_DECD_R_RS_); instr->operation = enc_to_oper(ENC_DECD_R_RS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470E400) {
  decode_fields32(ENC_DECH_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_DECH_R_RS_); instr->operation = enc_to_oper(ENC_DECH_R_RS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0E400) {
  decode_fields32(ENC_DECW_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_DECW_R_RS_); instr->operation = enc_to_oper(ENC_DECW_R_RS_); rc = 0; };
 }
 return rc;
}


int decd_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0C400) {
  decode_fields32(ENC_DECD_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_DECD_Z_ZS_); instr->operation = enc_to_oper(ENC_DECD_Z_ZS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470C400) {
  decode_fields32(ENC_DECH_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_DECH_Z_ZS_); instr->operation = enc_to_oper(ENC_DECH_Z_ZS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0C400) {
  decode_fields32(ENC_DECW_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_DECW_Z_ZS_); instr->operation = enc_to_oper(ENC_DECW_Z_ZS_); rc = 0; };
 }
 return rc;
}


int decp_r_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252D8800) {
  decode_fields32(ENC_DECP_R_P_R_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  {instr->encoding = (ENC_DECP_R_P_R_); instr->operation = enc_to_oper(ENC_DECP_R_P_R_); rc = 0; };
 }
 return rc;
}


int decp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252D8000) {
  decode_fields32(ENC_DECP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_DECP_Z_P_Z_); instr->operation = enc_to_oper(ENC_DECP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int dup_z_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2538C000) {
  decode_fields32(ENC_DUP_Z_I_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->imm = SignExtend((ctx->imm8),(8));
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }

  if(MOV_dup_z_i(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_DUP_Z_I_); instr->operation = enc_to_oper(ENC_DUP_Z_I_); rc = 0; };
 }
 return rc;
}


int dup_z_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5203800) {
  decode_fields32(ENC_DUP_Z_R_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->d = (unsigned int)(ctx->Zd);

  if(MOV_dup_z_r(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_DUP_Z_R_); instr->operation = enc_to_oper(ENC_DUP_Z_R_); rc = 0; };
 }
 return rc;
}


int dup_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5202000) {
  decode_fields32(ENC_DUP_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->imm = ((ctx->imm2<<5)|ctx->tsz);
  if(!ctx->tsz) {
   { return -4; };
  }
  else if(ctx->tsz==0x10) {
   ctx->esize = 0x80;
   ctx->index = (unsigned int)((((ctx->imm)>>(5)) & (((uint64_t)1<<((6)-(5)+1))-1)));
  }
  else if((ctx->tsz&15)==8) {
   ctx->esize = 0x40;
   ctx->index = (unsigned int)((((ctx->imm)>>(4)) & (((uint64_t)1<<((6)-(4)+1))-1)));
  }
  else if((ctx->tsz&7)==4) {
   ctx->esize = 0x20;
   ctx->index = (unsigned int)((((ctx->imm)>>(3)) & (((uint64_t)1<<((6)-(3)+1))-1)));
  }
  else if((ctx->tsz&3)==2) {
   ctx->esize = 0x10;
   ctx->index = (unsigned int)((((ctx->imm)>>(2)) & (((uint64_t)1<<((6)-(2)+1))-1)));
  }
  else if(ctx->tsz&1) {
   ctx->esize = 8;
   ctx->index = (unsigned int)((((ctx->imm)>>(1)) & (((uint64_t)1<<((6)-(1)+1))-1)));
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);

  if((BitCount(((ctx->imm2<<5)|ctx->tsz))==1) || (BitCount(((ctx->imm2<<5)|ctx->tsz))>1)) return MOV_dup_z_zi(ctx, instr);
  {instr->encoding = (ENC_DUP_Z_ZI_); instr->operation = enc_to_oper(ENC_DUP_Z_ZI_); rc = 0; };
 }
 return rc;
}


int dupm_z_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5C00000) {
  decode_fields32(ENC_DUPM_Z_I_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->d = (unsigned int)(ctx->Zd);
  if(((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==0 && ((((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3D || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3B || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x37 || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x2F || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x1F)) || ((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==1 && (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1)),(((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1)),(((ctx->imm13)>>(6)) & (((uint64_t)1<<((11)-(6)+1))-1)));
  ctx->imm = dbmrt.wmask;

  if(SVEMoveMaskPreferred(ctx->imm13)) return MOV_dupm_z_i(ctx, instr);
  {instr->encoding = (ENC_DUPM_Z_I_); instr->operation = enc_to_oper(ENC_DUPM_Z_I_); rc = 0; };
 }
 return rc;
}


int eor3_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4203800) {
  decode_fields32(ENC_EOR3_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->k = (unsigned int)(ctx->Zk);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_EOR3_Z_ZZZ_); instr->operation = enc_to_oper(ENC_EOR3_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int eor_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25004200) {
  decode_fields32(ENC_EOR_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 32971 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 32971 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 32972 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 32972 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;

  if(ctx->Pm==ctx->Pg) return NOTS_eor_p_p_pp(ctx, instr);
  if(ctx->Pm==ctx->Pg) return NOT_eor_p_p_pp(ctx, instr);
  {instr->encoding = (ENC_EOR_P_P_PP_Z); instr->operation = enc_to_oper(ENC_EOR_P_P_PP_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x25404200) {
  decode_fields32(ENC_EORS_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 32990 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 32990 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 32991 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 32991 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;

  if(ctx->Pm==ctx->Pg) return NOTS_eor_p_p_pp(ctx, instr);
  if(ctx->Pm==ctx->Pg) return NOT_eor_p_p_pp(ctx, instr);
  {instr->encoding = (ENC_EORS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_EORS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int eor_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4190000) {
  decode_fields32(ENC_EOR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_EOR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_EOR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int eor_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5400000) {
  decode_fields32(ENC_EOR_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->dn = (unsigned int)(ctx->Zdn);
  if(((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==0 && ((((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3D || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3B || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x37 || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x2F || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x1F)) || ((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==1 && (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1)),(((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1)),(((ctx->imm13)>>(6)) & (((uint64_t)1<<((11)-(6)+1))-1)));
  ctx->imm = dbmrt.wmask;
  {instr->encoding = (ENC_EOR_Z_ZI_); instr->operation = enc_to_oper(ENC_EOR_Z_ZI_); rc = 0; };
 }
 return rc;
}


int eor_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4A03000) {
  decode_fields32(ENC_EOR_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_EOR_Z_ZZ_); instr->operation = enc_to_oper(ENC_EOR_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int eorbt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45009000) {
  decode_fields32(ENC_EORBT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 0;
  ctx->sel2 = 1;
  {instr->encoding = (ENC_EORBT_Z_ZZ_); instr->operation = enc_to_oper(ENC_EORBT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int eortb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45009400) {
  decode_fields32(ENC_EORTB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 1;
  ctx->sel2 = 0;
  {instr->encoding = (ENC_EORTB_Z_ZZ_); instr->operation = enc_to_oper(ENC_EORTB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int eorv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4192000) {
  decode_fields32(ENC_EORV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_EORV_R_P_Z_); instr->operation = enc_to_oper(ENC_EORV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int ext_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x5600000) {
  decode_fields32(ENC_EXT_Z_ZI_CON, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dst = (unsigned int)(ctx->Zd);
  ctx->s1 = (unsigned int)(ctx->Zn);
  ctx->s2 = ((ctx->s1+1)) % 32;
  ctx->position = (unsigned int)(((ctx->imm8h<<3)|ctx->imm8l));
  {instr->encoding = (ENC_EXT_Z_ZI_CON); instr->operation = enc_to_oper(ENC_EXT_Z_ZI_CON); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0x5200000) {
  decode_fields32(ENC_EXT_Z_ZI_DES, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dst = (unsigned int)(ctx->Zdn);
  ctx->s1 = ctx->dst;
  ctx->s2 = (unsigned int)(ctx->Zm);
  ctx->position = (unsigned int)(((ctx->imm8h<<3)|ctx->imm8l));
  {instr->encoding = (ENC_EXT_Z_ZI_DES); instr->operation = enc_to_oper(ENC_EXT_Z_ZI_DES); rc = 0; };
 }
 return rc;
}


int fabd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65088000) {
  decode_fields32(ENC_FABD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FABD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FABD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fabs_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41CA000) {
  decode_fields32(ENC_FABS_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FABS_Z_P_Z_); instr->operation = enc_to_oper(ENC_FABS_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int facge_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x6500E010) {
  decode_fields32(ENC_FACGT_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  {instr->encoding = (ENC_FACGT_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FACGT_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x6500C010) {
  decode_fields32(ENC_FACGE_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  {instr->encoding = (ENC_FACGE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FACGE_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fadd_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x65188000) {
  decode_fields32(ENC_FADD_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? FPPointFive(0,ctx->esize) : FPOne(0,ctx->esize);
  {instr->encoding = (ENC_FADD_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FADD_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65008000) {
  decode_fields32(ENC_FADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fadd_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x65000000) {
  decode_fields32(ENC_FADD_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FADD_Z_ZZ_); instr->operation = enc_to_oper(ENC_FADD_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int fadda_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65182000) {
  decode_fields32(ENC_FADDA_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Vdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FADDA_V_P_Z_); instr->operation = enc_to_oper(ENC_FADDA_V_P_Z_); rc = 0; };
 }
 return rc;
}


int faddp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x64108000) {
  decode_fields32(ENC_FADDP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_FADDP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FADDP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int faddv_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65002000) {
  decode_fields32(ENC_FADDV_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_FADDV_V_P_Z_); instr->operation = enc_to_oper(ENC_FADDV_V_P_Z_); rc = 0; };
 }
 return rc;
}


int fcadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3EE000)==0x64008000) {
  decode_fields32(ENC_FCADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->sub_i = (ctx->rot==0);
  ctx->sub_r = (ctx->rot==1);
  {instr->encoding = (ENC_FCADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FCADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fcmeq_p_p_z0(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE010)==0x65122000) {
  decode_fields32(ENC_FCMEQ_P_P_Z0_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_EQ;
  {instr->encoding = (ENC_FCMEQ_P_P_Z0_); instr->operation = enc_to_oper(ENC_FCMEQ_P_P_Z0_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE010)==0x65102010) {
  decode_fields32(ENC_FCMGT_P_P_Z0_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  {instr->encoding = (ENC_FCMGT_P_P_Z0_); instr->operation = enc_to_oper(ENC_FCMGT_P_P_Z0_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE010)==0x65102000) {
  decode_fields32(ENC_FCMGE_P_P_Z0_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  {instr->encoding = (ENC_FCMGE_P_P_Z0_); instr->operation = enc_to_oper(ENC_FCMGE_P_P_Z0_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE010)==0x65112000) {
  decode_fields32(ENC_FCMLT_P_P_Z0_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LT;
  {instr->encoding = (ENC_FCMLT_P_P_Z0_); instr->operation = enc_to_oper(ENC_FCMLT_P_P_Z0_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE010)==0x65112010) {
  decode_fields32(ENC_FCMLE_P_P_Z0_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_LE;
  {instr->encoding = (ENC_FCMLE_P_P_Z0_); instr->operation = enc_to_oper(ENC_FCMLE_P_P_Z0_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE010)==0x65132000) {
  decode_fields32(ENC_FCMNE_P_P_Z0_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_NE;
  {instr->encoding = (ENC_FCMNE_P_P_Z0_); instr->operation = enc_to_oper(ENC_FCMNE_P_P_Z0_); rc = 0; };
 }
 return rc;
}


int fcmeq_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x65006000) {
  decode_fields32(ENC_FCMEQ_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_EQ;
  {instr->encoding = (ENC_FCMEQ_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FCMEQ_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x65004010) {
  decode_fields32(ENC_FCMGT_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GT;
  {instr->encoding = (ENC_FCMGT_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FCMGT_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x65004000) {
  decode_fields32(ENC_FCMGE_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_GE;
  {instr->encoding = (ENC_FCMGE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FCMGE_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x65006010) {
  decode_fields32(ENC_FCMNE_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_NE;
  {instr->encoding = (ENC_FCMNE_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FCMNE_P_P_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20E010)==0x6500C000) {
  decode_fields32(ENC_FCMUO_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->op = Cmp_UN;
  {instr->encoding = (ENC_FCMUO_P_P_ZZ_); instr->operation = enc_to_oper(ENC_FCMUO_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fcmla_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF208000)==0x64000000) {
  decode_fields32(ENC_FCMLA_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->neg_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  ctx->neg_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  {instr->encoding = (ENC_FCMLA_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FCMLA_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fcmla_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F000)==0x64A01000) {
  decode_fields32(ENC_FCMLA_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->neg_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  ctx->neg_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  {instr->encoding = (ENC_FCMLA_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_FCMLA_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F000)==0x64E01000) {
  decode_fields32(ENC_FCMLA_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->neg_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  ctx->neg_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  {instr->encoding = (ENC_FCMLA_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_FCMLA_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int fcpy_z_p_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30E000)==0x510C000) {
  decode_fields32(ENC_FCPY_Z_P_I_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->imm = VFPExpandImm(ctx->imm8,8);

  if(FMOV_fcpy_z_p_i(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_FCPY_Z_P_I_); instr->operation = enc_to_oper(ENC_FCPY_Z_P_I_); rc = 0; };
 }
 return rc;
}


int fcvt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x6589A000) {
  decode_fields32(ENC_FCVT_Z_P_Z_H2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x20;
  {instr->encoding = (ENC_FCVT_Z_P_Z_H2S); instr->operation = enc_to_oper(ENC_FCVT_Z_P_Z_H2S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65C9A000) {
  decode_fields32(ENC_FCVT_Z_P_Z_H2D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x40;
  {instr->encoding = (ENC_FCVT_Z_P_Z_H2D); instr->operation = enc_to_oper(ENC_FCVT_Z_P_Z_H2D); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x6588A000) {
  decode_fields32(ENC_FCVT_Z_P_Z_S2H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x10;
  {instr->encoding = (ENC_FCVT_Z_P_Z_S2H); instr->operation = enc_to_oper(ENC_FCVT_Z_P_Z_S2H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65CBA000) {
  decode_fields32(ENC_FCVT_Z_P_Z_S2D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x40;
  {instr->encoding = (ENC_FCVT_Z_P_Z_S2D); instr->operation = enc_to_oper(ENC_FCVT_Z_P_Z_S2D); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65C8A000) {
  decode_fields32(ENC_FCVT_Z_P_Z_D2H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x10;
  {instr->encoding = (ENC_FCVT_Z_P_Z_D2H); instr->operation = enc_to_oper(ENC_FCVT_Z_P_Z_D2H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65CAA000) {
  decode_fields32(ENC_FCVT_Z_P_Z_D2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x20;
  {instr->encoding = (ENC_FCVT_Z_P_Z_D2S); instr->operation = enc_to_oper(ENC_FCVT_Z_P_Z_D2S); rc = 0; };
 }
 return rc;
}


int fcvtlt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x6489A000) {
  decode_fields32(ENC_FCVTLT_Z_P_Z_H2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FCVTLT_Z_P_Z_H2S); instr->operation = enc_to_oper(ENC_FCVTLT_Z_P_Z_H2S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x64CBA000) {
  decode_fields32(ENC_FCVTLT_Z_P_Z_S2D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FCVTLT_Z_P_Z_S2D); instr->operation = enc_to_oper(ENC_FCVTLT_Z_P_Z_S2D); rc = 0; };
 }
 return rc;
}


int fcvtnt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x6488A000) {
  decode_fields32(ENC_FCVTNT_Z_P_Z_S2H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FCVTNT_Z_P_Z_S2H); instr->operation = enc_to_oper(ENC_FCVTNT_Z_P_Z_S2H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x64CAA000) {
  decode_fields32(ENC_FCVTNT_Z_P_Z_D2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FCVTNT_Z_P_Z_D2S); instr->operation = enc_to_oper(ENC_FCVTNT_Z_P_Z_D2S); rc = 0; };
 }
 return rc;
}


int fcvtx_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x650AA000) {
  decode_fields32(ENC_FCVTX_Z_P_Z_D2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x20;
  {instr->encoding = (ENC_FCVTX_Z_P_Z_D2S); instr->operation = enc_to_oper(ENC_FCVTX_Z_P_Z_D2S); rc = 0; };
 }
 return rc;
}


int fcvtxnt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x640AA000) {
  decode_fields32(ENC_FCVTXNT_Z_P_Z_D2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FCVTXNT_Z_P_Z_D2S); instr->operation = enc_to_oper(ENC_FCVTXNT_Z_P_Z_D2S); rc = 0; };
 }
 return rc;
}


int fcvtzs_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x655AA000) {
  decode_fields32(ENC_FCVTZS_Z_P_Z_FP162H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 33934 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 33934 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_Z_P_Z_FP162H); instr->operation = enc_to_oper(ENC_FCVTZS_Z_P_Z_FP162H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x655CA000) {
  decode_fields32(ENC_FCVTZS_Z_P_Z_FP162W, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 33951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 33951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_Z_P_Z_FP162W); instr->operation = enc_to_oper(ENC_FCVTZS_Z_P_Z_FP162W); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x655EA000) {
  decode_fields32(ENC_FCVTZS_Z_P_Z_FP162X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 33968 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 33968 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_Z_P_Z_FP162X); instr->operation = enc_to_oper(ENC_FCVTZS_Z_P_Z_FP162X); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x659CA000) {
  decode_fields32(ENC_FCVTZS_Z_P_Z_S2W, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 33985 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 33985 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_Z_P_Z_S2W); instr->operation = enc_to_oper(ENC_FCVTZS_Z_P_Z_S2W); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65DCA000) {
  decode_fields32(ENC_FCVTZS_Z_P_Z_S2X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 34002 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 34002 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_Z_P_Z_S2X); instr->operation = enc_to_oper(ENC_FCVTZS_Z_P_Z_S2X); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D8A000) {
  decode_fields32(ENC_FCVTZS_Z_P_Z_D2W, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 34019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 34019 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_Z_P_Z_D2W); instr->operation = enc_to_oper(ENC_FCVTZS_Z_P_Z_D2W); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65DEA000) {
  decode_fields32(ENC_FCVTZS_Z_P_Z_D2X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 34036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 34036 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZS_Z_P_Z_D2X); instr->operation = enc_to_oper(ENC_FCVTZS_Z_P_Z_D2X); rc = 0; };
 }
 return rc;
}


int fcvtzu_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x655BA000) {
  decode_fields32(ENC_FCVTZU_Z_P_Z_FP162H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 34060 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 34060 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_Z_P_Z_FP162H); instr->operation = enc_to_oper(ENC_FCVTZU_Z_P_Z_FP162H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x655DA000) {
  decode_fields32(ENC_FCVTZU_Z_P_Z_FP162W, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 34077 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 34077 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_Z_P_Z_FP162W); instr->operation = enc_to_oper(ENC_FCVTZU_Z_P_Z_FP162W); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x655FA000) {
  decode_fields32(ENC_FCVTZU_Z_P_Z_FP162X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 34094 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 34094 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_Z_P_Z_FP162X); instr->operation = enc_to_oper(ENC_FCVTZU_Z_P_Z_FP162X); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x659DA000) {
  decode_fields32(ENC_FCVTZU_Z_P_Z_S2W, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 34111 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 34111 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_Z_P_Z_S2W); instr->operation = enc_to_oper(ENC_FCVTZU_Z_P_Z_S2W); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65DDA000) {
  decode_fields32(ENC_FCVTZU_Z_P_Z_S2X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 34128 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 34128 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_Z_P_Z_S2X); instr->operation = enc_to_oper(ENC_FCVTZU_Z_P_Z_S2X); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D9A000) {
  decode_fields32(ENC_FCVTZU_Z_P_Z_D2W, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 34145 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 34145 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_Z_P_Z_D2W); instr->operation = enc_to_oper(ENC_FCVTZU_Z_P_Z_D2W); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65DFA000) {
  decode_fields32(ENC_FCVTZU_Z_P_Z_D2X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 34162 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 34162 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FCVTZU_Z_P_Z_D2X); instr->operation = enc_to_oper(ENC_FCVTZU_Z_P_Z_D2X); rc = 0; };
 }
 return rc;
}


int fdiv_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x650D8000) {
  decode_fields32(ENC_FDIV_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FDIV_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FDIV_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fdivr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x650C8000) {
  decode_fields32(ENC_FDIVR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FDIVR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FDIVR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fdup_z_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x2539C000) {
  decode_fields32(ENC_FDUP_Z_I_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->imm = VFPExpandImm(ctx->imm8,8);

  if(FMOV_fdup_z_i(ctx, instr)==0) return 0;
  {instr->encoding = (ENC_FDUP_Z_I_); instr->operation = enc_to_oper(ENC_FDUP_Z_I_); rc = 0; };
 }
 return rc;
}


int fexpa_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x420B800) {
  decode_fields32(ENC_FEXPA_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FEXPA_Z_Z_); instr->operation = enc_to_oper(ENC_FEXPA_Z_Z_); rc = 0; };
 }
 return rc;
}


int flogb_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF9E000)==0x6518A000) {
  decode_fields32(ENC_FLOGB_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FLOGB_Z_P_Z_); instr->operation = enc_to_oper(ENC_FLOGB_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int fmad_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x65208000) {
  decode_fields32(ENC_FMAD_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->a = (unsigned int)(ctx->Za);
  ctx->op1_neg = 
# 34303 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34303 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->op3_neg = 
# 34304 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34304 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMAD_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FMAD_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmax_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x651E8000) {
  decode_fields32(ENC_FMAX_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? 0 : FPOne(0,ctx->esize);
  {instr->encoding = (ENC_FMAX_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FMAX_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fmax_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65068000) {
  decode_fields32(ENC_FMAX_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FMAX_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMAX_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fmaxnm_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x651C8000) {
  decode_fields32(ENC_FMAXNM_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? 0 : FPOne(0,ctx->esize);
  {instr->encoding = (ENC_FMAXNM_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FMAXNM_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fmaxnm_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65048000) {
  decode_fields32(ENC_FMAXNM_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FMAXNM_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMAXNM_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fmaxnmp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x64148000) {
  decode_fields32(ENC_FMAXNMP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_FMAXNMP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMAXNMP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fmaxnmv_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65042000) {
  decode_fields32(ENC_FMAXNMV_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_FMAXNMV_V_P_Z_); instr->operation = enc_to_oper(ENC_FMAXNMV_V_P_Z_); rc = 0; };
 }
 return rc;
}


int fmaxp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x64168000) {
  decode_fields32(ENC_FMAXP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_FMAXP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMAXP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fmaxv_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65062000) {
  decode_fields32(ENC_FMAXV_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_FMAXV_V_P_Z_); instr->operation = enc_to_oper(ENC_FMAXV_V_P_Z_); rc = 0; };
 }
 return rc;
}


int fmin_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x651F8000) {
  decode_fields32(ENC_FMIN_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? 0 : FPOne(0,ctx->esize);
  {instr->encoding = (ENC_FMIN_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FMIN_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fmin_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65078000) {
  decode_fields32(ENC_FMIN_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FMIN_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMIN_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fminnm_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x651D8000) {
  decode_fields32(ENC_FMINNM_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? 0 : FPOne(0,ctx->esize);
  {instr->encoding = (ENC_FMINNM_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FMINNM_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fminnm_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65058000) {
  decode_fields32(ENC_FMINNM_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FMINNM_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMINNM_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fminnmp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x64158000) {
  decode_fields32(ENC_FMINNMP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_FMINNMP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMINNMP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fminnmv_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65052000) {
  decode_fields32(ENC_FMINNMV_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_FMINNMV_V_P_Z_); instr->operation = enc_to_oper(ENC_FMINNMV_V_P_Z_); rc = 0; };
 }
 return rc;
}


int fminp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x64178000) {
  decode_fields32(ENC_FMINP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_FMINP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMINP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fminv_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65072000) {
  decode_fields32(ENC_FMINV_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_FMINV_V_P_Z_); instr->operation = enc_to_oper(ENC_FMINV_V_P_Z_); rc = 0; };
 }
 return rc;
}


int fmla_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x65200000) {
  decode_fields32(ENC_FMLA_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34697 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34697 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->op3_neg = 
# 34698 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34698 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLA_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FMLA_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmla_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x64200000) {
  decode_fields32(ENC_FMLA_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34720 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34720 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->op3_neg = 
# 34721 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34721 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLA_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_FMLA_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x64A00000) {
  decode_fields32(ENC_FMLA_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34736 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->op3_neg = 
# 34737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLA_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_FMLA_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x64E00000) {
  decode_fields32(ENC_FMLA_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->op3_neg = 
# 34753 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34753 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLA_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_FMLA_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int fmlalb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64A08000) {
  decode_fields32(ENC_FMLALB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34774 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34774 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLALB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_FMLALB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmlalb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x64A04000) {
  decode_fields32(ENC_FMLALB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->op1_neg = 
# 34796 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34796 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLALB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_FMLALB_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int fmlalt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64A08400) {
  decode_fields32(ENC_FMLALT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34817 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34817 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLALT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_FMLALT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmlalt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x64A04400) {
  decode_fields32(ENC_FMLALT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->op1_neg = 
# 34839 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34839 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLALT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_FMLALT_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int fmls_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x65202000) {
  decode_fields32(ENC_FMLS_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34864 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 34864 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->op3_neg = 
# 34865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLS_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FMLS_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmls_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x64200400) {
  decode_fields32(ENC_FMLS_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34887 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 34887 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->op3_neg = 
# 34888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLS_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_FMLS_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x64A00400) {
  decode_fields32(ENC_FMLS_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34903 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 34903 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->op3_neg = 
# 34904 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34904 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLS_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_FMLS_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x64E00400) {
  decode_fields32(ENC_FMLS_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34919 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 34919 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->op3_neg = 
# 34920 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 34920 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMLS_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_FMLS_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int fmlslb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64A0A000) {
  decode_fields32(ENC_FMLSLB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34941 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 34941 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FMLSLB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_FMLSLB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmlslb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x64A06000) {
  decode_fields32(ENC_FMLSLB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->op1_neg = 
# 34963 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 34963 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FMLSLB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_FMLSLB_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int fmlslt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64A0A400) {
  decode_fields32(ENC_FMLSLT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 34984 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 34984 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FMLSLT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_FMLSLT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmlslt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x64A06400) {
  decode_fields32(ENC_FMLSLT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->op1_neg = 
# 35006 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35006 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FMLSLT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_FMLSLT_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int fmmla_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x64A0E400) {
  decode_fields32(ENC_FMMLA_Z_ZZZ_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<42))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_FMMLA_Z_ZZZ_S); instr->operation = enc_to_oper(ENC_FMMLA_Z_ZZZ_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x64E0E400) {
  decode_fields32(ENC_FMMLA_Z_ZZZ_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_FMMLA_Z_ZZZ_D); instr->operation = enc_to_oper(ENC_FMMLA_Z_ZZZ_D); rc = 0; };
 }
 return rc;
}


int fmsb_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x6520A000) {
  decode_fields32(ENC_FMSB_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->a = (unsigned int)(ctx->Za);
  ctx->op1_neg = 
# 35064 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35064 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->op3_neg = 
# 35065 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 35065 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_FMSB_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FMSB_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fmul_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x651A8000) {
  decode_fields32(ENC_FMUL_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? FPPointFive(0,ctx->esize) : FPTwo(0,ctx->esize);
  {instr->encoding = (ENC_FMUL_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FMUL_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fmul_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65028000) {
  decode_fields32(ENC_FMUL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FMUL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMUL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fmul_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x65000800) {
  decode_fields32(ENC_FMUL_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FMUL_Z_ZZ_); instr->operation = enc_to_oper(ENC_FMUL_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int fmul_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x64202000) {
  decode_fields32(ENC_FMUL_Z_ZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FMUL_Z_ZZI_H); instr->operation = enc_to_oper(ENC_FMUL_Z_ZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x64A02000) {
  decode_fields32(ENC_FMUL_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FMUL_Z_ZZI_S); instr->operation = enc_to_oper(ENC_FMUL_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x64E02000) {
  decode_fields32(ENC_FMUL_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FMUL_Z_ZZI_D); instr->operation = enc_to_oper(ENC_FMUL_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int fmulx_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x650A8000) {
  decode_fields32(ENC_FMULX_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FMULX_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FMULX_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fneg_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41DA000) {
  decode_fields32(ENC_FNEG_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FNEG_Z_P_Z_); instr->operation = enc_to_oper(ENC_FNEG_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int fnmad_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x6520C000) {
  decode_fields32(ENC_FNMAD_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->a = (unsigned int)(ctx->Za);
  ctx->op1_neg = 
# 35254 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35254 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->op3_neg = 
# 35255 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35255 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FNMAD_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FNMAD_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fnmla_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x65204000) {
  decode_fields32(ENC_FNMLA_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 35280 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35280 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  ctx->op3_neg = 
# 35281 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35281 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FNMLA_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FNMLA_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fnmls_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x65206000) {
  decode_fields32(ENC_FNMLS_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_neg = 
# 35306 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 35306 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->op3_neg = 
# 35307 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35307 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FNMLS_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FNMLS_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int fnmsb_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x6520E000) {
  decode_fields32(ENC_FNMSB_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->a = (unsigned int)(ctx->Za);
  ctx->op1_neg = 
# 35332 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                0
# 35332 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->op3_neg = 
# 35333 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                1
# 35333 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_FNMSB_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_FNMSB_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int frecpe_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x650E3000) {
  decode_fields32(ENC_FRECPE_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FRECPE_Z_Z_); instr->operation = enc_to_oper(ENC_FRECPE_Z_Z_); rc = 0; };
 }
 return rc;
}


int frecps_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x65001800) {
  decode_fields32(ENC_FRECPS_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FRECPS_Z_ZZ_); instr->operation = enc_to_oper(ENC_FRECPS_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int frecpx_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x650CA000) {
  decode_fields32(ENC_FRECPX_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FRECPX_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRECPX_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int frinta_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x6507A000) {
  decode_fields32(ENC_FRINTI_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->exact = 
# 35425 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 35425 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_FRINTI_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRINTI_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x6506A000) {
  decode_fields32(ENC_FRINTX_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->exact = 
# 35443 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              1
# 35443 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                  ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_FRINTX_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRINTX_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x6504A000) {
  decode_fields32(ENC_FRINTA_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->exact = 
# 35461 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 35461 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->rounding = FPRounding_TIEAWAY;
  {instr->encoding = (ENC_FRINTA_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRINTA_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x6500A000) {
  decode_fields32(ENC_FRINTN_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->exact = 
# 35479 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 35479 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->rounding = FPRounding_TIEEVEN;
  {instr->encoding = (ENC_FRINTN_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRINTN_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x6503A000) {
  decode_fields32(ENC_FRINTZ_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->exact = 
# 35497 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 35497 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->rounding = FPRounding_ZERO;
  {instr->encoding = (ENC_FRINTZ_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRINTZ_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x6502A000) {
  decode_fields32(ENC_FRINTM_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->exact = 
# 35515 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 35515 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->rounding = FPRounding_NEGINF;
  {instr->encoding = (ENC_FRINTM_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRINTM_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x6501A000) {
  decode_fields32(ENC_FRINTP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->exact = 
# 35533 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
              0
# 35533 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  ctx->rounding = FPRounding_POSINF;
  {instr->encoding = (ENC_FRINTP_Z_P_Z_); instr->operation = enc_to_oper(ENC_FRINTP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int frsqrte_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x650F3000) {
  decode_fields32(ENC_FRSQRTE_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FRSQRTE_Z_Z_); instr->operation = enc_to_oper(ENC_FRSQRTE_Z_Z_); rc = 0; };
 }
 return rc;
}


int frsqrts_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x65001C00) {
  decode_fields32(ENC_FRSQRTS_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FRSQRTS_Z_ZZ_); instr->operation = enc_to_oper(ENC_FRSQRTS_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int fscale_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65098000) {
  decode_fields32(ENC_FSCALE_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FSCALE_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FSCALE_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fsqrt_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x650DA000) {
  decode_fields32(ENC_FSQRT_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FSQRT_Z_P_Z_); instr->operation = enc_to_oper(ENC_FSQRT_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int fsub_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x65198000) {
  decode_fields32(ENC_FSUB_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? FPPointFive(0,ctx->esize) : FPOne(0,ctx->esize);
  {instr->encoding = (ENC_FSUB_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FSUB_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fsub_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65018000) {
  decode_fields32(ENC_FSUB_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FSUB_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FSUB_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int fsub_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x65000400) {
  decode_fields32(ENC_FSUB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FSUB_Z_ZZ_); instr->operation = enc_to_oper(ENC_FSUB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int fsubr_z_p_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE3C0)==0x651B8000) {
  decode_fields32(ENC_FSUBR_Z_P_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (ctx->i1==0) ? FPPointFive(0,ctx->esize) : FPOne(0,ctx->esize);
  {instr->encoding = (ENC_FSUBR_Z_P_ZS_); instr->operation = enc_to_oper(ENC_FSUBR_Z_P_ZS_); rc = 0; };
 }
 return rc;
}


int fsubr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x65038000) {
  decode_fields32(ENC_FSUBR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_FSUBR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_FSUBR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int ftmad_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF38FC00)==0x65108000) {
  decode_fields32(ENC_FTMAD_Z_ZZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->imm = (unsigned int)(ctx->imm3);
  {instr->encoding = (ENC_FTMAD_Z_ZZI_); instr->operation = enc_to_oper(ENC_FTMAD_Z_ZZI_); rc = 0; };
 }
 return rc;
}


int ftsmul_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x65000C00) {
  decode_fields32(ENC_FTSMUL_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FTSMUL_Z_ZZ_); instr->operation = enc_to_oper(ENC_FTSMUL_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int ftssel_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x420B000) {
  decode_fields32(ENC_FTSSEL_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_FTSSEL_Z_ZZ_); instr->operation = enc_to_oper(ENC_FTSSEL_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int histcnt_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x4520C000) {
  decode_fields32(ENC_HISTCNT_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_HISTCNT_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_HISTCNT_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int histseg_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4520A000) {
  decode_fields32(ENC_HISTSEG_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size!=0) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_HISTSEG_Z_ZZ_); instr->operation = enc_to_oper(ENC_HISTSEG_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int incb_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x430E000) {
  decode_fields32(ENC_INCB_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_INCB_R_RS_); instr->operation = enc_to_oper(ENC_INCB_R_RS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0E000) {
  decode_fields32(ENC_INCD_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_INCD_R_RS_); instr->operation = enc_to_oper(ENC_INCD_R_RS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470E000) {
  decode_fields32(ENC_INCH_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_INCH_R_RS_); instr->operation = enc_to_oper(ENC_INCH_R_RS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0E000) {
  decode_fields32(ENC_INCW_R_RS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_INCW_R_RS_); instr->operation = enc_to_oper(ENC_INCW_R_RS_); rc = 0; };
 }
 return rc;
}


int incd_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0C000) {
  decode_fields32(ENC_INCD_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_INCD_Z_ZS_); instr->operation = enc_to_oper(ENC_INCD_Z_ZS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470C000) {
  decode_fields32(ENC_INCH_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_INCH_Z_ZS_); instr->operation = enc_to_oper(ENC_INCH_Z_ZS_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0C000) {
  decode_fields32(ENC_INCW_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  {instr->encoding = (ENC_INCW_Z_ZS_); instr->operation = enc_to_oper(ENC_INCW_Z_ZS_); rc = 0; };
 }
 return rc;
}


int incp_r_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252C8800) {
  decode_fields32(ENC_INCP_R_P_R_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  {instr->encoding = (ENC_INCP_R_P_R_); instr->operation = enc_to_oper(ENC_INCP_R_P_R_); rc = 0; };
 }
 return rc;
}


int incp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252C8000) {
  decode_fields32(ENC_INCP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_INCP_Z_P_Z_); instr->operation = enc_to_oper(ENC_INCP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int index_z_ii(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4204000) {
  decode_fields32(ENC_INDEX_Z_II_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->imm1 = SignExtend((ctx->imm5),(5));
  ctx->imm2 = SignExtend((ctx->imm5b),(5));
  {instr->encoding = (ENC_INDEX_Z_II_); instr->operation = enc_to_oper(ENC_INDEX_Z_II_); rc = 0; };
 }
 return rc;
}


int index_z_ir(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4204800) {
  decode_fields32(ENC_INDEX_Z_IR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->imm = SignExtend((ctx->imm5),(5));
  {instr->encoding = (ENC_INDEX_Z_IR_); instr->operation = enc_to_oper(ENC_INDEX_Z_IR_); rc = 0; };
 }
 return rc;
}


int index_z_ri(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4204400) {
  decode_fields32(ENC_INDEX_Z_RI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->imm = SignExtend((ctx->imm5),(5));
  {instr->encoding = (ENC_INDEX_Z_RI_); instr->operation = enc_to_oper(ENC_INDEX_Z_RI_); rc = 0; };
 }
 return rc;
}


int index_z_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4204C00) {
  decode_fields32(ENC_INDEX_Z_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_INDEX_Z_RR_); instr->operation = enc_to_oper(ENC_INDEX_Z_RR_); rc = 0; };
 }
 return rc;
}


int insr_z_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5243800) {
  decode_fields32(ENC_INSR_Z_R_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Rm);
  {instr->encoding = (ENC_INSR_Z_R_); instr->operation = enc_to_oper(ENC_INSR_Z_R_); rc = 0; };
 }
 return rc;
}


int insr_z_v(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5343800) {
  decode_fields32(ENC_INSR_Z_V_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Vm);
  {instr->encoding = (ENC_INSR_Z_V_); instr->operation = enc_to_oper(ENC_INSR_Z_V_); rc = 0; };
 }
 return rc;
}


int lasta_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x520A000) {
  decode_fields32(ENC_LASTA_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (ctx->esize<0x40) ? 0x20 : 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->isBefore = 
# 36142 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 36142 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LASTA_R_P_Z_); instr->operation = enc_to_oper(ENC_LASTA_R_P_Z_); rc = 0; };
 }
 return rc;
}


int lasta_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5228000) {
  decode_fields32(ENC_LASTA_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  ctx->isBefore = 
# 36163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 36163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LASTA_V_P_Z_); instr->operation = enc_to_oper(ENC_LASTA_V_P_Z_); rc = 0; };
 }
 return rc;
}


int lastb_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x521A000) {
  decode_fields32(ENC_LASTB_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (ctx->esize<0x40) ? 0x20 : 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->isBefore = 
# 36185 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 36185 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_LASTB_R_P_Z_); instr->operation = enc_to_oper(ENC_LASTB_R_P_Z_); rc = 0; };
 }
 return rc;
}


int lastb_v_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5238000) {
  decode_fields32(ENC_LASTB_V_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  ctx->isBefore = 
# 36206 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 36206 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_LASTB_V_P_Z_); instr->operation = enc_to_oper(ENC_LASTB_V_P_Z_); rc = 0; };
 }
 return rc;
}


int ld1b_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8420C000) {
  decode_fields32(ENC_LD1B_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36228 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36228 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1B_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LD1B_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC420C000) {
  decode_fields32(ENC_LD1B_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36244 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36244 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1B_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LD1B_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ld1b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA400A000) {
  decode_fields32(ENC_LD1B_Z_P_BI_U8, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36267 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36267 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1B_Z_P_BI_U8); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BI_U8); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA420A000) {
  decode_fields32(ENC_LD1B_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36283 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36283 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1B_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BI_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA440A000) {
  decode_fields32(ENC_LD1B_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36299 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36299 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1B_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA460A000) {
  decode_fields32(ENC_LD1B_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36315 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36315 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1B_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4004000) {
  decode_fields32(ENC_LD1B_Z_P_BR_U8, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1B_Z_P_BR_U8); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BR_U8); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4204000) {
  decode_fields32(ENC_LD1B_Z_P_BR_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36361 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36361 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1B_Z_P_BR_U16); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BR_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4404000) {
  decode_fields32(ENC_LD1B_Z_P_BR_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36380 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36380 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1B_Z_P_BR_U32); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BR_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4604000) {
  decode_fields32(ENC_LD1B_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36399 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36399 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1B_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ld1b_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC4004000) {
  decode_fields32(ENC_LD1B_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36423 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36423 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1B_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84004000) {
  decode_fields32(ENC_LD1B_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36442 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36442 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1B_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC440C000) {
  decode_fields32(ENC_LD1B_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 36461 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36461 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 36462 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 36462 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1B_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LD1B_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ld1d_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xC5A0C000) {
  decode_fields32(ENC_LD1D_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 36485 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36485 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1D_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LD1D_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ld1d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5E0A000) {
  decode_fields32(ENC_LD1D_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 36508 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36508 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1D_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1D_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5E04000) {
  decode_fields32(ENC_LD1D_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 36535 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36535 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1D_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LD1D_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ld1d_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC5A04000) {
  decode_fields32(ENC_LD1D_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36559 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36559 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 3;
  {instr->encoding = (ENC_LD1D_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1D_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5804000) {
  decode_fields32(ENC_LD1D_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36578 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36578 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1D_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1D_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC5E0C000) {
  decode_fields32(ENC_LD1D_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 36597 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36597 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 36598 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 36598 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 3;
  {instr->encoding = (ENC_LD1D_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LD1D_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC5C0C000) {
  decode_fields32(ENC_LD1D_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 36616 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36616 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 36617 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 36617 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1D_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LD1D_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ld1h_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x84A0C000) {
  decode_fields32(ENC_LD1H_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1H_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LD1H_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4A0C000) {
  decode_fields32(ENC_LD1H_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36656 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36656 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1H_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LD1H_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ld1h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4A0A000) {
  decode_fields32(ENC_LD1H_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36679 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36679 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1H_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BI_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA4C0A000) {
  decode_fields32(ENC_LD1H_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36695 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36695 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1H_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA4E0A000) {
  decode_fields32(ENC_LD1H_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36711 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36711 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1H_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4A04000) {
  decode_fields32(ENC_LD1H_Z_P_BR_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36738 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36738 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1H_Z_P_BR_U16); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BR_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4C04000) {
  decode_fields32(ENC_LD1H_Z_P_BR_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36757 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36757 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1H_Z_P_BR_U32); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BR_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4E04000) {
  decode_fields32(ENC_LD1H_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 36776 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36776 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1H_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ld1h_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0x84A04000) {
  decode_fields32(ENC_LD1H_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36800 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36800 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LD1H_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4A04000) {
  decode_fields32(ENC_LD1H_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LD1H_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4804000) {
  decode_fields32(ENC_LD1H_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36838 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36838 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1H_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84804000) {
  decode_fields32(ENC_LD1H_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 36857 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36857 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1H_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4E0C000) {
  decode_fields32(ENC_LD1H_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 36876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36876 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 36877 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 36877 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 1;
  {instr->encoding = (ENC_LD1H_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4C0C000) {
  decode_fields32(ENC_LD1H_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 36895 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36895 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 36896 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 36896 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1H_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LD1H_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ld1rb_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x84408000) {
  decode_fields32(ENC_LD1RB_Z_P_BI_U8, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36919 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36919 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RB_Z_P_BI_U8); instr->operation = enc_to_oper(ENC_LD1RB_Z_P_BI_U8); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x8440A000) {
  decode_fields32(ENC_LD1RB_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36935 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36935 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RB_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LD1RB_Z_P_BI_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x8440C000) {
  decode_fields32(ENC_LD1RB_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36951 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RB_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1RB_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x8440E000) {
  decode_fields32(ENC_LD1RB_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 36967 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36967 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RB_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1RB_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1rd_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x85C0E000) {
  decode_fields32(ENC_LD1RD_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 36990 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 36990 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RD_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1RD_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1rh_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x84C0A000) {
  decode_fields32(ENC_LD1RH_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37013 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 37013 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RH_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LD1RH_Z_P_BI_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x84C0C000) {
  decode_fields32(ENC_LD1RH_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37029 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 37029 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RH_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1RH_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x84C0E000) {
  decode_fields32(ENC_LD1RH_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37045 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 37045 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RH_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1RH_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1rob_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4202000) {
  decode_fields32(ENC_LD1ROB_Z_P_BI_U8, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1ROB_Z_P_BI_U8); instr->operation = enc_to_oper(ENC_LD1ROB_Z_P_BI_U8); rc = 0; };
 }
 return rc;
}


int ld1rob_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4200000) {
  decode_fields32(ENC_LD1ROB_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  {instr->encoding = (ENC_LD1ROB_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1ROB_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1rod_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5A02000) {
  decode_fields32(ENC_LD1ROD_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1ROD_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1ROD_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1rod_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5A00000) {
  decode_fields32(ENC_LD1ROD_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  {instr->encoding = (ENC_LD1ROD_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1ROD_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1roh_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4A02000) {
  decode_fields32(ENC_LD1ROH_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1ROH_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LD1ROH_Z_P_BI_U16); rc = 0; };
 }
 return rc;
}


int ld1roh_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4A00000) {
  decode_fields32(ENC_LD1ROH_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  {instr->encoding = (ENC_LD1ROH_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1ROH_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1row_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5202000) {
  decode_fields32(ENC_LD1ROW_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1ROW_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1ROW_Z_P_BI_U32); rc = 0; };
 }
 return rc;
}


int ld1row_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5200000) {
  decode_fields32(ENC_LD1ROW_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  {instr->encoding = (ENC_LD1ROW_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1ROW_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1rqb_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4002000) {
  decode_fields32(ENC_LD1RQB_Z_P_BI_U8, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1RQB_Z_P_BI_U8); instr->operation = enc_to_oper(ENC_LD1RQB_Z_P_BI_U8); rc = 0; };
 }
 return rc;
}


int ld1rqb_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4000000) {
  decode_fields32(ENC_LD1RQB_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  {instr->encoding = (ENC_LD1RQB_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1RQB_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1rqd_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5802000) {
  decode_fields32(ENC_LD1RQD_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1RQD_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1RQD_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1rqd_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5800000) {
  decode_fields32(ENC_LD1RQD_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  {instr->encoding = (ENC_LD1RQD_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1RQD_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1rqh_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4802000) {
  decode_fields32(ENC_LD1RQH_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1RQH_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LD1RQH_Z_P_BI_U16); rc = 0; };
 }
 return rc;
}


int ld1rqh_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4800000) {
  decode_fields32(ENC_LD1RQH_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  {instr->encoding = (ENC_LD1RQH_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1RQH_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1rqw_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5002000) {
  decode_fields32(ENC_LD1RQW_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1RQW_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1RQW_Z_P_BI_U32); rc = 0; };
 }
 return rc;
}


int ld1rqw_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5000000) {
  decode_fields32(ENC_LD1RQW_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  {instr->encoding = (ENC_LD1RQW_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD1RQW_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld1rsb_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x85C0C000) {
  decode_fields32(ENC_LD1RSB_Z_P_BI_S16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37428 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37428 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RSB_Z_P_BI_S16); instr->operation = enc_to_oper(ENC_LD1RSB_Z_P_BI_S16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x85C0A000) {
  decode_fields32(ENC_LD1RSB_Z_P_BI_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37444 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37444 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RSB_Z_P_BI_S32); instr->operation = enc_to_oper(ENC_LD1RSB_Z_P_BI_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x85C08000) {
  decode_fields32(ENC_LD1RSB_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37460 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37460 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RSB_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LD1RSB_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ld1rsh_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x8540A000) {
  decode_fields32(ENC_LD1RSH_Z_P_BI_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37483 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37483 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RSH_Z_P_BI_S32); instr->operation = enc_to_oper(ENC_LD1RSH_Z_P_BI_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x85408000) {
  decode_fields32(ENC_LD1RSH_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37499 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37499 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RSH_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LD1RSH_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ld1rsw_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x84C08000) {
  decode_fields32(ENC_LD1RSW_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 37522 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37522 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RSW_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LD1RSW_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ld1rw_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x8540C000) {
  decode_fields32(ENC_LD1RW_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 37545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 37545 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RW_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1RW_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFC0E000)==0x8540E000) {
  decode_fields32(ENC_LD1RW_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 37561 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 37561 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm6);
  {instr->encoding = (ENC_LD1RW_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1RW_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1sb_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x84208000) {
  decode_fields32(ENC_LD1SB_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37584 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37584 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1SB_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4208000) {
  decode_fields32(ENC_LD1SB_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37600 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37600 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1SB_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ld1sb_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5C0A000) {
  decode_fields32(ENC_LD1SB_Z_P_BI_S16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37623 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37623 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1SB_Z_P_BI_S16); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BI_S16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA5A0A000) {
  decode_fields32(ENC_LD1SB_Z_P_BI_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37639 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37639 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1SB_Z_P_BI_S32); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BI_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA580A000) {
  decode_fields32(ENC_LD1SB_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37655 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37655 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1SB_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ld1sb_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5C04000) {
  decode_fields32(ENC_LD1SB_Z_P_BR_S16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37682 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37682 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LD1SB_Z_P_BR_S16); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BR_S16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5A04000) {
  decode_fields32(ENC_LD1SB_Z_P_BR_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37701 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37701 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LD1SB_Z_P_BR_S32); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BR_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5804000) {
  decode_fields32(ENC_LD1SB_Z_P_BR_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 37720 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37720 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LD1SB_Z_P_BR_S64); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BR_S64); rc = 0; };
 }
 return rc;
}


int ld1sb_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC4000000) {
  decode_fields32(ENC_LD1SB_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 37744 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37744 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SB_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84000000) {
  decode_fields32(ENC_LD1SB_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 37763 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37763 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SB_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4408000) {
  decode_fields32(ENC_LD1SB_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 37782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 37783 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 37783 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SB_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SB_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ld1sh_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x84A08000) {
  decode_fields32(ENC_LD1SH_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37806 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37806 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1SH_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4A08000) {
  decode_fields32(ENC_LD1SH_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37822 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37822 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1SH_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ld1sh_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA520A000) {
  decode_fields32(ENC_LD1SH_Z_P_BI_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1SH_Z_P_BI_S32); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BI_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA500A000) {
  decode_fields32(ENC_LD1SH_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37861 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37861 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1SH_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ld1sh_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5204000) {
  decode_fields32(ENC_LD1SH_Z_P_BR_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LD1SH_Z_P_BR_S32); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BR_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5004000) {
  decode_fields32(ENC_LD1SH_Z_P_BR_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 37907 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37907 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LD1SH_Z_P_BR_S64); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BR_S64); rc = 0; };
 }
 return rc;
}


int ld1sh_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0x84A00000) {
  decode_fields32(ENC_LD1SH_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 37931 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37931 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LD1SH_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4A00000) {
  decode_fields32(ENC_LD1SH_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 37950 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37950 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LD1SH_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4800000) {
  decode_fields32(ENC_LD1SH_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 37969 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37969 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SH_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84800000) {
  decode_fields32(ENC_LD1SH_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 37988 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 37988 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SH_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4E08000) {
  decode_fields32(ENC_LD1SH_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 38007 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38007 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 38008 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 38008 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 1;
  {instr->encoding = (ENC_LD1SH_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4C08000) {
  decode_fields32(ENC_LD1SH_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 38026 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38026 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 38027 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 38027 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SH_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SH_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ld1sw_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xC5208000) {
  decode_fields32(ENC_LD1SW_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38050 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38050 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1SW_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LD1SW_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ld1sw_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA480A000) {
  decode_fields32(ENC_LD1SW_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38073 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38073 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1SW_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LD1SW_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ld1sw_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4804000) {
  decode_fields32(ENC_LD1SW_Z_P_BR_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LD1SW_Z_P_BR_S64); instr->operation = enc_to_oper(ENC_LD1SW_Z_P_BR_S64); rc = 0; };
 }
 return rc;
}


int ld1sw_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC5200000) {
  decode_fields32(ENC_LD1SW_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 38124 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38124 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_LD1SW_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1SW_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5000000) {
  decode_fields32(ENC_LD1SW_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 38143 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38143 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SW_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SW_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC5608000) {
  decode_fields32(ENC_LD1SW_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 38162 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38162 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 38163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 38163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 2;
  {instr->encoding = (ENC_LD1SW_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LD1SW_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC5408000) {
  decode_fields32(ENC_LD1SW_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 38181 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 38181 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 38182 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 38182 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1SW_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LD1SW_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ld1w_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8520C000) {
  decode_fields32(ENC_LD1W_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38205 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38205 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1W_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LD1W_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC520C000) {
  decode_fields32(ENC_LD1W_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38221 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38221 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LD1W_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LD1W_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ld1w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA540A000) {
  decode_fields32(ENC_LD1W_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38244 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38244 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1W_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA560A000) {
  decode_fields32(ENC_LD1W_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38260 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38260 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LD1W_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ld1w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5404000) {
  decode_fields32(ENC_LD1W_Z_P_BR_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1W_Z_P_BR_U32); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BR_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5604000) {
  decode_fields32(ENC_LD1W_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 38306 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38306 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LD1W_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ld1w_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0x85204000) {
  decode_fields32(ENC_LD1W_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 38330 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38330 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_LD1W_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5204000) {
  decode_fields32(ENC_LD1W_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 38349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38349 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_LD1W_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5004000) {
  decode_fields32(ENC_LD1W_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 38368 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38368 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1W_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x85004000) {
  decode_fields32(ENC_LD1W_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 38387 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38387 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1W_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC560C000) {
  decode_fields32(ENC_LD1W_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 38406 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38406 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 38407 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 38407 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 2;
  {instr->encoding = (ENC_LD1W_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC540C000) {
  decode_fields32(ENC_LD1W_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 38425 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 38425 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 38426 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 38426 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LD1W_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LD1W_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ld2b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA420E000) {
  decode_fields32(ENC_LD2B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld2b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA420C000) {
  decode_fields32(ENC_LD2B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld2d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5A0E000) {
  decode_fields32(ENC_LD2D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld2d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5A0C000) {
  decode_fields32(ENC_LD2D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld2h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4A0E000) {
  decode_fields32(ENC_LD2H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld2h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4A0C000) {
  decode_fields32(ENC_LD2H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld2w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA520E000) {
  decode_fields32(ENC_LD2W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld2w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA520C000) {
  decode_fields32(ENC_LD2W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->nreg = 2;
  {instr->encoding = (ENC_LD2W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD2W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA440E000) {
  decode_fields32(ENC_LD3B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA440C000) {
  decode_fields32(ENC_LD3B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5C0E000) {
  decode_fields32(ENC_LD3D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5C0C000) {
  decode_fields32(ENC_LD3D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4C0E000) {
  decode_fields32(ENC_LD3H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4C0C000) {
  decode_fields32(ENC_LD3H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA540E000) {
  decode_fields32(ENC_LD3W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld3w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA540C000) {
  decode_fields32(ENC_LD3W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->nreg = 3;
  {instr->encoding = (ENC_LD3W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD3W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA460E000) {
  decode_fields32(ENC_LD4B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA460C000) {
  decode_fields32(ENC_LD4B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5E0E000) {
  decode_fields32(ENC_LD4D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5E0C000) {
  decode_fields32(ENC_LD4D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4E0E000) {
  decode_fields32(ENC_LD4H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4E0C000) {
  decode_fields32(ENC_LD4H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA560E000) {
  decode_fields32(ENC_LD4W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ld4w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA560C000) {
  decode_fields32(ENC_LD4W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->nreg = 4;
  {instr->encoding = (ENC_LD4W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LD4W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldff1b_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8420E000) {
  decode_fields32(ENC_LDFF1B_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39013 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39013 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1B_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC420E000) {
  decode_fields32(ENC_LDFF1B_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39029 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39029 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1B_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ldff1b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4006000) {
  decode_fields32(ENC_LDFF1B_Z_P_BR_U8, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39053 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1B_Z_P_BR_U8); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_BR_U8); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4206000) {
  decode_fields32(ENC_LDFF1B_Z_P_BR_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39069 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39069 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1B_Z_P_BR_U16); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_BR_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4406000) {
  decode_fields32(ENC_LDFF1B_Z_P_BR_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39085 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39085 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1B_Z_P_BR_U32); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_BR_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4606000) {
  decode_fields32(ENC_LDFF1B_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39101 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39101 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1B_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ldff1b_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC4006000) {
  decode_fields32(ENC_LDFF1B_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39125 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39125 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1B_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84006000) {
  decode_fields32(ENC_LDFF1B_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39144 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39144 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1B_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC440E000) {
  decode_fields32(ENC_LDFF1B_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39163 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 39164 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39164 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1B_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1B_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldff1d_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xC5A0E000) {
  decode_fields32(ENC_LDFF1D_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 39187 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39187 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1D_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LDFF1D_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ldff1d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5E06000) {
  decode_fields32(ENC_LDFF1D_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 39211 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39211 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1D_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LDFF1D_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ldff1d_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC5A06000) {
  decode_fields32(ENC_LDFF1D_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39235 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39235 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 3;
  {instr->encoding = (ENC_LDFF1D_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1D_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5806000) {
  decode_fields32(ENC_LDFF1D_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39254 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39254 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1D_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1D_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC5E0E000) {
  decode_fields32(ENC_LDFF1D_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39273 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39273 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 39274 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39274 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 3;
  {instr->encoding = (ENC_LDFF1D_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LDFF1D_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC5C0E000) {
  decode_fields32(ENC_LDFF1D_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39292 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39292 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 39293 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39293 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1D_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1D_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldff1h_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x84A0E000) {
  decode_fields32(ENC_LDFF1H_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39316 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39316 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1H_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4A0E000) {
  decode_fields32(ENC_LDFF1H_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39332 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39332 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1H_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ldff1h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4A06000) {
  decode_fields32(ENC_LDFF1H_Z_P_BR_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39356 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1H_Z_P_BR_U16); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BR_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4C06000) {
  decode_fields32(ENC_LDFF1H_Z_P_BR_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39372 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39372 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1H_Z_P_BR_U32); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BR_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA4E06000) {
  decode_fields32(ENC_LDFF1H_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39388 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39388 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1H_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ldff1h_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0x84A06000) {
  decode_fields32(ENC_LDFF1H_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39412 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39412 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LDFF1H_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4A06000) {
  decode_fields32(ENC_LDFF1H_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LDFF1H_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4806000) {
  decode_fields32(ENC_LDFF1H_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39450 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39450 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1H_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84806000) {
  decode_fields32(ENC_LDFF1H_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39469 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39469 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1H_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4E0E000) {
  decode_fields32(ENC_LDFF1H_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39488 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39488 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 39489 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39489 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 1;
  {instr->encoding = (ENC_LDFF1H_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4C0E000) {
  decode_fields32(ENC_LDFF1H_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39507 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 39507 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 39508 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39508 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1H_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1H_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldff1sb_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8420A000) {
  decode_fields32(ENC_LDFF1SB_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39531 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39531 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1SB_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC420A000) {
  decode_fields32(ENC_LDFF1SB_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39547 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39547 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1SB_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ldff1sb_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5C06000) {
  decode_fields32(ENC_LDFF1SB_Z_P_BR_S16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39571 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39571 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDFF1SB_Z_P_BR_S16); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_BR_S16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5A06000) {
  decode_fields32(ENC_LDFF1SB_Z_P_BR_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39587 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39587 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDFF1SB_Z_P_BR_S32); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_BR_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5806000) {
  decode_fields32(ENC_LDFF1SB_Z_P_BR_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 39603 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39603 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDFF1SB_Z_P_BR_S64); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_BR_S64); rc = 0; };
 }
 return rc;
}


int ldff1sb_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC4002000) {
  decode_fields32(ENC_LDFF1SB_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39627 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39627 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SB_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84002000) {
  decode_fields32(ENC_LDFF1SB_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SB_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC440A000) {
  decode_fields32(ENC_LDFF1SB_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39665 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39665 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 39666 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39666 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SB_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SB_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldff1sh_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x84A0A000) {
  decode_fields32(ENC_LDFF1SH_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39689 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1SH_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4A0A000) {
  decode_fields32(ENC_LDFF1SH_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39705 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39705 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1SH_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ldff1sh_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5206000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BR_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39729 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39729 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BR_S32); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BR_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5006000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BR_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 39745 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39745 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BR_S64); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BR_S64); rc = 0; };
 }
 return rc;
}


int ldff1sh_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0x84A02000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39769 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39769 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4A02000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39788 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39788 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC4802000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39807 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39807 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x84802000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4E0A000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39845 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 39846 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39846 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 1;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4C0A000) {
  decode_fields32(ENC_LDFF1SH_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39864 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39864 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 39865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39865 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SH_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SH_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldff1sw_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xC520A000) {
  decode_fields32(ENC_LDFF1SW_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 39888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39888 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1SW_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LDFF1SW_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ldff1sw_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA4806000) {
  decode_fields32(ENC_LDFF1SW_Z_P_BR_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 39912 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39912 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDFF1SW_Z_P_BR_S64); instr->operation = enc_to_oper(ENC_LDFF1SW_Z_P_BR_S64); rc = 0; };
 }
 return rc;
}


int ldff1sw_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0xC5202000) {
  decode_fields32(ENC_LDFF1SW_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39936 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39936 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_LDFF1SW_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1SW_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5002000) {
  decode_fields32(ENC_LDFF1SW_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 39955 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39955 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SW_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SW_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC560A000) {
  decode_fields32(ENC_LDFF1SW_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39974 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 39975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39975 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 2;
  {instr->encoding = (ENC_LDFF1SW_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LDFF1SW_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC540A000) {
  decode_fields32(ENC_LDFF1SW_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 39993 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 39993 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offs_unsigned = 
# 39994 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 39994 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1SW_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1SW_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldff1w_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8520E000) {
  decode_fields32(ENC_LDFF1W_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40017 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40017 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1W_Z_P_AI_S); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC520E000) {
  decode_fields32(ENC_LDFF1W_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40033 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40033 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_LDFF1W_Z_P_AI_D); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int ldff1w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA5406000) {
  decode_fields32(ENC_LDFF1W_Z_P_BR_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40057 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40057 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1W_Z_P_BR_U32); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BR_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xA5606000) {
  decode_fields32(ENC_LDFF1W_Z_P_BR_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40073 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40073 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDFF1W_Z_P_BR_U64); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BR_U64); rc = 0; };
 }
 return rc;
}


int ldff1w_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E000)==0x85206000) {
  decode_fields32(ENC_LDFF1W_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 40097 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40097 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_LDFF1W_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5206000) {
  decode_fields32(ENC_LDFF1W_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 40116 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40116 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_LDFF1W_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0xC5006000) {
  decode_fields32(ENC_LDFF1W_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 40135 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40135 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1W_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E000)==0x85006000) {
  decode_fields32(ENC_LDFF1W_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->unsigned_ = 
# 40154 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40154 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1W_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC560E000) {
  decode_fields32(ENC_LDFF1W_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 40173 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40173 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 40174 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 40174 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 2;
  {instr->encoding = (ENC_LDFF1W_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC540E000) {
  decode_fields32(ENC_LDFF1W_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->unsigned_ = 
# 40192 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40192 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offs_unsigned = 
# 40193 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 40193 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_LDFF1W_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDFF1W_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnf1b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA410A000) {
  decode_fields32(ENC_LDNF1B_Z_P_BI_U8, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40216 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40216 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1B_Z_P_BI_U8); instr->operation = enc_to_oper(ENC_LDNF1B_Z_P_BI_U8); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA430A000) {
  decode_fields32(ENC_LDNF1B_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1B_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LDNF1B_Z_P_BI_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA450A000) {
  decode_fields32(ENC_LDNF1B_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40248 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40248 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1B_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LDNF1B_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA470A000) {
  decode_fields32(ENC_LDNF1B_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40264 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40264 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1B_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LDNF1B_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ldnf1d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5F0A000) {
  decode_fields32(ENC_LDNF1D_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 40287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40287 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1D_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LDNF1D_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ldnf1h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA4B0A000) {
  decode_fields32(ENC_LDNF1H_Z_P_BI_U16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40310 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40310 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1H_Z_P_BI_U16); instr->operation = enc_to_oper(ENC_LDNF1H_Z_P_BI_U16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA4D0A000) {
  decode_fields32(ENC_LDNF1H_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40326 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40326 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1H_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LDNF1H_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA4F0A000) {
  decode_fields32(ENC_LDNF1H_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40342 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1H_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LDNF1H_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ldnf1sb_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA5D0A000) {
  decode_fields32(ENC_LDNF1SB_Z_P_BI_S16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40365 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40365 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1SB_Z_P_BI_S16); instr->operation = enc_to_oper(ENC_LDNF1SB_Z_P_BI_S16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA5B0A000) {
  decode_fields32(ENC_LDNF1SB_Z_P_BI_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40381 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40381 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1SB_Z_P_BI_S32); instr->operation = enc_to_oper(ENC_LDNF1SB_Z_P_BI_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA590A000) {
  decode_fields32(ENC_LDNF1SB_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40397 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40397 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1SB_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LDNF1SB_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ldnf1sh_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA530A000) {
  decode_fields32(ENC_LDNF1SH_Z_P_BI_S32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40420 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40420 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1SH_Z_P_BI_S32); instr->operation = enc_to_oper(ENC_LDNF1SH_Z_P_BI_S32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA510A000) {
  decode_fields32(ENC_LDNF1SH_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40436 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40436 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1SH_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LDNF1SH_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ldnf1sw_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA490A000) {
  decode_fields32(ENC_LDNF1SW_Z_P_BI_S64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40459 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40459 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1SW_Z_P_BI_S64); instr->operation = enc_to_oper(ENC_LDNF1SW_Z_P_BI_S64); rc = 0; };
 }
 return rc;
}


int ldnf1w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA550A000) {
  decode_fields32(ENC_LDNF1W_Z_P_BI_U32, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40482 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40482 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1W_Z_P_BI_U32); instr->operation = enc_to_oper(ENC_LDNF1W_Z_P_BI_U32); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0E000)==0xA570A000) {
  decode_fields32(ENC_LDNF1W_Z_P_BI_U64, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40498 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40498 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNF1W_Z_P_BI_U64); instr->operation = enc_to_oper(ENC_LDNF1W_Z_P_BI_U64); rc = 0; };
 }
 return rc;
}


int ldnt1b_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8400A000) {
  decode_fields32(ENC_LDNT1B_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40522 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40522 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDNT1B_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1B_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC400C000) {
  decode_fields32(ENC_LDNT1B_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40538 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40538 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDNT1B_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1B_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnt1b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA400E000) {
  decode_fields32(ENC_LDNT1B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNT1B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldnt1b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA400C000) {
  decode_fields32(ENC_LDNT1B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  {instr->encoding = (ENC_LDNT1B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldnt1d_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xC580C000) {
  decode_fields32(ENC_LDNT1D_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->unsigned_ = 
# 40606 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40606 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDNT1D_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1D_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnt1d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA580E000) {
  decode_fields32(ENC_LDNT1D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNT1D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldnt1d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA580C000) {
  decode_fields32(ENC_LDNT1D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  {instr->encoding = (ENC_LDNT1D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldnt1h_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8480A000) {
  decode_fields32(ENC_LDNT1H_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDNT1H_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1H_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC480C000) {
  decode_fields32(ENC_LDNT1H_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40690 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40690 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDNT1H_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1H_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnt1h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA480E000) {
  decode_fields32(ENC_LDNT1H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNT1H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldnt1h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA480C000) {
  decode_fields32(ENC_LDNT1H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  {instr->encoding = (ENC_LDNT1H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldnt1sb_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x84008000) {
  decode_fields32(ENC_LDNT1SB_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40758 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40758 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDNT1SB_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1SB_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4008000) {
  decode_fields32(ENC_LDNT1SB_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->unsigned_ = 
# 40774 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40774 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDNT1SB_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1SB_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnt1sh_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x84808000) {
  decode_fields32(ENC_LDNT1SH_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDNT1SH_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1SH_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC4808000) {
  decode_fields32(ENC_LDNT1SH_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->unsigned_ = 
# 40813 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40813 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDNT1SH_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1SH_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnt1sw_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xC5008000) {
  decode_fields32(ENC_LDNT1SW_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 40836 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_LDNT1SW_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1SW_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnt1w_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0x8500A000) {
  decode_fields32(ENC_LDNT1W_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40859 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40859 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDNT1W_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1W_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xC500C000) {
  decode_fields32(ENC_LDNT1W_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->unsigned_ = 
# 40875 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 40875 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_LDNT1W_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_LDNT1W_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int ldnt1w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xA500E000) {
  decode_fields32(ENC_LDNT1W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_LDNT1W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldnt1w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xA500C000) {
  decode_fields32(ENC_LDNT1W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  {instr->encoding = (ENC_LDNT1W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_LDNT1W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int ldr_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E010)==0x85800000) {
  decode_fields32(ENC_LDR_P_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Pt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->imm = SignExtend((((ctx->imm9h<<3)|ctx->imm9l)),(9));
  {instr->encoding = (ENC_LDR_P_BI_); instr->operation = enc_to_oper(ENC_LDR_P_BI_); rc = 0; };
 }
 return rc;
}


int ldr_z_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0x85804000) {
  decode_fields32(ENC_LDR_Z_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->imm = SignExtend((((ctx->imm9h<<3)|ctx->imm9l)),(9));
  {instr->encoding = (ENC_LDR_Z_BI_); instr->operation = enc_to_oper(ENC_LDR_Z_BI_); rc = 0; };
 }
 return rc;
}


int lsl_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4038000) {
  decode_fields32(ENC_LSL_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_LSL_Z_P_ZI_); instr->operation = enc_to_oper(ENC_LSL_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int lsl_z_p_zw(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41B8000) {
  decode_fields32(ENC_LSL_Z_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_LSL_Z_P_ZW_); instr->operation = enc_to_oper(ENC_LSL_Z_P_ZW_); rc = 0; };
 }
 return rc;
}


int lsl_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4138000) {
  decode_fields32(ENC_LSL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_LSL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_LSL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int lsl_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4209C00) {
  decode_fields32(ENC_LSL_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_LSL_Z_ZI_); instr->operation = enc_to_oper(ENC_LSL_Z_ZI_); rc = 0; };
 }
 return rc;
}


int lsl_z_zw(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4208C00) {
  decode_fields32(ENC_LSL_Z_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_LSL_Z_ZW_); instr->operation = enc_to_oper(ENC_LSL_Z_ZW_); rc = 0; };
 }
 return rc;
}


int lslr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4178000) {
  decode_fields32(ENC_LSLR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_LSLR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_LSLR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int lsr_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4018000) {
  decode_fields32(ENC_LSR_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_LSR_Z_P_ZI_); instr->operation = enc_to_oper(ENC_LSR_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int lsr_z_p_zw(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4198000) {
  decode_fields32(ENC_LSR_Z_P_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_LSR_Z_P_ZW_); instr->operation = enc_to_oper(ENC_LSR_Z_P_ZW_); rc = 0; };
 }
 return rc;
}


int lsr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4118000) {
  decode_fields32(ENC_LSR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_LSR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_LSR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int lsr_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4209400) {
  decode_fields32(ENC_LSR_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_LSR_Z_ZI_); instr->operation = enc_to_oper(ENC_LSR_Z_ZI_); rc = 0; };
 }
 return rc;
}


int lsr_z_zw(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4208400) {
  decode_fields32(ENC_LSR_Z_ZW_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_LSR_Z_ZW_); instr->operation = enc_to_oper(ENC_LSR_Z_ZW_); rc = 0; };
 }
 return rc;
}


int lsrr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4158000) {
  decode_fields32(ENC_LSRR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_LSRR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_LSRR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int mad_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x400C000) {
  decode_fields32(ENC_MAD_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->a = (unsigned int)(ctx->Za);
  ctx->sub_op = 
# 41292 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               0
# 41292 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_MAD_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_MAD_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int match_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x45208000) {
  decode_fields32(ENC_MATCH_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if((ctx->size&2)==2) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_MATCH_P_P_ZZ_); instr->operation = enc_to_oper(ENC_MATCH_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int mla_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x4004000) {
  decode_fields32(ENC_MLA_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sub_op = 
# 41338 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               0
# 41338 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                    ;
  {instr->encoding = (ENC_MLA_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_MLA_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int mla_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x44200800) {
  decode_fields32(ENC_MLA_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_MLA_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_MLA_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44A00800) {
  decode_fields32(ENC_MLA_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_MLA_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_MLA_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E00800) {
  decode_fields32(ENC_MLA_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_MLA_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_MLA_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int mls_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x4006000) {
  decode_fields32(ENC_MLS_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sub_op = 
# 41409 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 41409 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  {instr->encoding = (ENC_MLS_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_MLS_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int mls_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x44200C00) {
  decode_fields32(ENC_MLS_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_MLS_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_MLS_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44A00C00) {
  decode_fields32(ENC_MLS_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_MLS_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_MLS_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E00C00) {
  decode_fields32(ENC_MLS_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_MLS_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_MLS_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int movprfx_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3EE000)==0x4102000) {
  decode_fields32(ENC_MOVPRFX_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->merging = (ctx->M==1);
  {instr->encoding = (ENC_MOVPRFX_Z_P_Z_); instr->operation = enc_to_oper(ENC_MOVPRFX_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int movprfx_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x420BC00) {
  decode_fields32(ENC_MOVPRFX_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_MOVPRFX_Z_Z_); instr->operation = enc_to_oper(ENC_MOVPRFX_Z_Z_); rc = 0; };
 }
 return rc;
}


int msb_z_p_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E000)==0x400E000) {
  decode_fields32(ENC_MSB_Z_P_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->a = (unsigned int)(ctx->Za);
  ctx->sub_op = 
# 41519 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
               1
# 41519 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                   ;
  {instr->encoding = (ENC_MSB_Z_P_ZZZ_); instr->operation = enc_to_oper(ENC_MSB_Z_P_ZZZ_); rc = 0; };
 }
 return rc;
}


int mul_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4100000) {
  decode_fields32(ENC_MUL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_MUL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_MUL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int mul_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x2530C000) {
  decode_fields32(ENC_MUL_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = SignExtend((ctx->imm8),(8));
  {instr->encoding = (ENC_MUL_Z_ZI_); instr->operation = enc_to_oper(ENC_MUL_Z_ZI_); rc = 0; };
 }
 return rc;
}


int mul_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4206000) {
  decode_fields32(ENC_MUL_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_MUL_Z_ZZ_); instr->operation = enc_to_oper(ENC_MUL_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int mul_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4420F800) {
  decode_fields32(ENC_MUL_Z_ZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_MUL_Z_ZZI_H); instr->operation = enc_to_oper(ENC_MUL_Z_ZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44A0F800) {
  decode_fields32(ENC_MUL_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_MUL_Z_ZZI_S); instr->operation = enc_to_oper(ENC_MUL_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E0F800) {
  decode_fields32(ENC_MUL_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_MUL_Z_ZZI_D); instr->operation = enc_to_oper(ENC_MUL_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int nand_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25804210) {
  decode_fields32(ENC_NAND_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 41649 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 41649 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 41650 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 41650 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_NAND_P_P_PP_Z); instr->operation = enc_to_oper(ENC_NAND_P_P_PP_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x25C04210) {
  decode_fields32(ENC_NANDS_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 41665 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 41665 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 41666 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 41666 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_NANDS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_NANDS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int nbsl_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4E03C00) {
  decode_fields32(ENC_NBSL_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->k = (unsigned int)(ctx->Zk);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_NBSL_Z_ZZZ_); instr->operation = enc_to_oper(ENC_NBSL_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int neg_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x417A000) {
  decode_fields32(ENC_NEG_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_NEG_Z_P_Z_); instr->operation = enc_to_oper(ENC_NEG_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int nmatch_p_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20E010)==0x45208010) {
  decode_fields32(ENC_NMATCH_P_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if((ctx->size&2)==2) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_NMATCH_P_P_ZZ_); instr->operation = enc_to_oper(ENC_NMATCH_P_P_ZZ_); rc = 0; };
 }
 return rc;
}


int nor_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25804200) {
  decode_fields32(ENC_NOR_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->setflags = 
# 41751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 41751 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  instr->setflags = 
# 41752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 41752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  {instr->encoding = (ENC_NOR_P_P_PP_Z); instr->operation = enc_to_oper(ENC_NOR_P_P_PP_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x25C04200) {
  decode_fields32(ENC_NORS_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 41767 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 41767 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 41768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 41768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_NORS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_NORS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int not_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x41EA000) {
  decode_fields32(ENC_NOT_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_NOT_Z_P_Z_); instr->operation = enc_to_oper(ENC_NOT_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int orn_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25804010) {
  decode_fields32(ENC_ORN_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 41810 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 41810 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 41811 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 41811 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_ORN_P_P_PP_Z); instr->operation = enc_to_oper(ENC_ORN_P_P_PP_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x25C04010) {
  decode_fields32(ENC_ORNS_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 41826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 41826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 41827 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 41827 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_ORNS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_ORNS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int orr_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25804000) {
  decode_fields32(ENC_ORR_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 41849 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 41849 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 41850 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 41850 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;

  if(ctx->S==1 && ctx->Pn==ctx->Pm && ctx->Pm==ctx->Pg) return MOVS_orr_p_p_pp(ctx, instr);
  if(ctx->S==0 && ctx->Pn==ctx->Pm && ctx->Pm==ctx->Pg) return MOV_orr_p_p_pp(ctx, instr);
  {instr->encoding = (ENC_ORR_P_P_PP_Z); instr->operation = enc_to_oper(ENC_ORR_P_P_PP_Z); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0C210)==0x25C04000) {
  decode_fields32(ENC_ORRS_P_P_PP_Z, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 41868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 41868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 41869 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 41869 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;

  if(ctx->S==1 && ctx->Pn==ctx->Pm && ctx->Pm==ctx->Pg) return MOVS_orr_p_p_pp(ctx, instr);
  if(ctx->S==0 && ctx->Pn==ctx->Pm && ctx->Pm==ctx->Pg) return MOV_orr_p_p_pp(ctx, instr);
  {instr->encoding = (ENC_ORRS_P_P_PP_Z); instr->operation = enc_to_oper(ENC_ORRS_P_P_PP_Z); rc = 0; };
 }
 return rc;
}


int orr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4180000) {
  decode_fields32(ENC_ORR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_ORR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_ORR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int orr_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFC0000)==0x5000000) {
  decode_fields32(ENC_ORR_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->dn = (unsigned int)(ctx->Zdn);
  if(((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==0 && ((((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3D || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3B || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x37 || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x2F || (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x1F)) || ((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1))==1 && (((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1))==0x3F)) { return -4; };
  DecodeBitMasks_ReturnType dbmrt = DecodeBitMasks((((ctx->imm13)>>(12)) & (((uint64_t)1<<((12)-(12)+1))-1)),(((ctx->imm13)>>(0)) & (((uint64_t)1<<((5)-(0)+1))-1)),(((ctx->imm13)>>(6)) & (((uint64_t)1<<((11)-(6)+1))-1)));
  ctx->imm = dbmrt.wmask;
  {instr->encoding = (ENC_ORR_Z_ZI_); instr->operation = enc_to_oper(ENC_ORR_Z_ZI_); rc = 0; };
 }
 return rc;
}


int orr_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4603000) {
  decode_fields32(ENC_ORR_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);

  if(ctx->Zn==ctx->Zm) return MOV_orr_z_zz(ctx, instr);
  {instr->encoding = (ENC_ORR_Z_ZZ_); instr->operation = enc_to_oper(ENC_ORR_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int orv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4182000) {
  decode_fields32(ENC_ORV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_ORV_R_P_Z_); instr->operation = enc_to_oper(ENC_ORV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int pfalse_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFF0)==0x2518E400) {
  decode_fields32(ENC_PFALSE_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Pd);
  {instr->encoding = (ENC_PFALSE_P_); instr->operation = enc_to_oper(ENC_PFALSE_P_); rc = 0; };
 }
 return rc;
}


int pfirst_p_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFE10)==0x2558C000) {
  decode_fields32(ENC_PFIRST_P_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Pdn);
  {instr->encoding = (ENC_PFIRST_P_P_P_); instr->operation = enc_to_oper(ENC_PFIRST_P_P_P_); rc = 0; };
 }
 return rc;
}


int pmul_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4206400) {
  decode_fields32(ENC_PMUL_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_PMUL_Z_ZZ_); instr->operation = enc_to_oper(ENC_PMUL_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int pmullb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45006800) {
  decode_fields32(ENC_PMULLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0 && !(ctx->features1 & ((uint64_t)1<<39))) {
   { return -4; };
  }
  if(!ctx->size) {
   ctx->esize = 0x80;
  }
  else if(ctx->size==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->size==2) {
   { return -4; };
  }
  else if(ctx->size==3) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_PMULLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_PMULLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int pmullt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45006C00) {
  decode_fields32(ENC_PMULLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0 && !(ctx->features1 & ((uint64_t)1<<39))) {
   { return -4; };
  }
  if(!ctx->size) {
   ctx->esize = 0x80;
  }
  else if(ctx->size==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->size==2) {
   { return -4; };
  }
  else if(ctx->size==3) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_PMULLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_PMULLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int pnext_p_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE10)==0x2519C400) {
  decode_fields32(ENC_PNEXT_P_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Pdn);
  {instr->encoding = (ENC_PNEXT_P_P_P_); instr->operation = enc_to_oper(ENC_PNEXT_P_P_P_); rc = 0; };
 }
 return rc;
}


int prfb_i_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8400E000) {
  decode_fields32(ENC_PRFB_I_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 0;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFB_I_P_AI_S); instr->operation = enc_to_oper(ENC_PRFB_I_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC400E000) {
  decode_fields32(ENC_PRFB_I_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 0;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFB_I_P_AI_D); instr->operation = enc_to_oper(ENC_PRFB_I_P_AI_D); rc = 0; };
 }
 return rc;
}


int prfb_i_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E010)==0x85C00000) {
  decode_fields32(ENC_PRFB_I_P_BI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 0;
  ctx->offset = SignExtend((ctx->imm6),(6));
  {instr->encoding = (ENC_PRFB_I_P_BI_S); instr->operation = enc_to_oper(ENC_PRFB_I_P_BI_S); rc = 0; };
 }
 return rc;
}


int prfb_i_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8400C000) {
  decode_fields32(ENC_PRFB_I_P_BR_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 0;
  {instr->encoding = (ENC_PRFB_I_P_BR_S); instr->operation = enc_to_oper(ENC_PRFB_I_P_BR_S); rc = 0; };
 }
 return rc;
}


int prfb_i_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E010)==0x84200000) {
  decode_fields32(ENC_PRFB_I_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 0;
  {instr->encoding = (ENC_PRFB_I_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFB_I_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E010)==0xC4200000) {
  decode_fields32(ENC_PRFB_I_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 0;
  {instr->encoding = (ENC_PRFB_I_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFB_I_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC4608000) {
  decode_fields32(ENC_PRFB_I_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 42265 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 42265 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_PRFB_I_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_PRFB_I_P_BZ_D_64_SCALED); rc = 0; };
 }
 return rc;
}


int prfd_i_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8580E000) {
  decode_fields32(ENC_PRFD_I_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 3;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFD_I_P_AI_S); instr->operation = enc_to_oper(ENC_PRFD_I_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC580E000) {
  decode_fields32(ENC_PRFD_I_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 3;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFD_I_P_AI_D); instr->operation = enc_to_oper(ENC_PRFD_I_P_AI_D); rc = 0; };
 }
 return rc;
}


int prfd_i_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E010)==0x85C06000) {
  decode_fields32(ENC_PRFD_I_P_BI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 3;
  ctx->offset = SignExtend((ctx->imm6),(6));
  {instr->encoding = (ENC_PRFD_I_P_BI_S); instr->operation = enc_to_oper(ENC_PRFD_I_P_BI_S); rc = 0; };
 }
 return rc;
}


int prfd_i_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8580C000) {
  decode_fields32(ENC_PRFD_I_P_BR_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 3;
  {instr->encoding = (ENC_PRFD_I_P_BR_S); instr->operation = enc_to_oper(ENC_PRFD_I_P_BR_S); rc = 0; };
 }
 return rc;
}


int prfd_i_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E010)==0x84206000) {
  decode_fields32(ENC_PRFD_I_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 3;
  {instr->encoding = (ENC_PRFD_I_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFD_I_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E010)==0xC4206000) {
  decode_fields32(ENC_PRFD_I_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 3;
  {instr->encoding = (ENC_PRFD_I_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFD_I_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC460E000) {
  decode_fields32(ENC_PRFD_I_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 42435 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 42435 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 3;
  {instr->encoding = (ENC_PRFD_I_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_PRFD_I_P_BZ_D_64_SCALED); rc = 0; };
 }
 return rc;
}


int prfh_i_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8480E000) {
  decode_fields32(ENC_PRFH_I_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 1;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFH_I_P_AI_S); instr->operation = enc_to_oper(ENC_PRFH_I_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC480E000) {
  decode_fields32(ENC_PRFH_I_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 1;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFH_I_P_AI_D); instr->operation = enc_to_oper(ENC_PRFH_I_P_AI_D); rc = 0; };
 }
 return rc;
}


int prfh_i_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E010)==0x85C02000) {
  decode_fields32(ENC_PRFH_I_P_BI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 1;
  ctx->offset = SignExtend((ctx->imm6),(6));
  {instr->encoding = (ENC_PRFH_I_P_BI_S); instr->operation = enc_to_oper(ENC_PRFH_I_P_BI_S); rc = 0; };
 }
 return rc;
}


int prfh_i_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8480C000) {
  decode_fields32(ENC_PRFH_I_P_BR_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 1;
  {instr->encoding = (ENC_PRFH_I_P_BR_S); instr->operation = enc_to_oper(ENC_PRFH_I_P_BR_S); rc = 0; };
 }
 return rc;
}


int prfh_i_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E010)==0x84202000) {
  decode_fields32(ENC_PRFH_I_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 1;
  {instr->encoding = (ENC_PRFH_I_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFH_I_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E010)==0xC4202000) {
  decode_fields32(ENC_PRFH_I_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 1;
  {instr->encoding = (ENC_PRFH_I_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFH_I_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC460A000) {
  decode_fields32(ENC_PRFH_I_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 42605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 42605 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 1;
  {instr->encoding = (ENC_PRFH_I_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_PRFH_I_P_BZ_D_64_SCALED); rc = 0; };
 }
 return rc;
}


int prfw_i_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8500E000) {
  decode_fields32(ENC_PRFW_I_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 2;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFW_I_P_AI_S); instr->operation = enc_to_oper(ENC_PRFW_I_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC500E000) {
  decode_fields32(ENC_PRFW_I_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 2;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_PRFW_I_P_AI_D); instr->operation = enc_to_oper(ENC_PRFW_I_P_AI_D); rc = 0; };
 }
 return rc;
}


int prfw_i_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E010)==0x85C04000) {
  decode_fields32(ENC_PRFW_I_P_BI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 2;
  ctx->offset = SignExtend((ctx->imm6),(6));
  {instr->encoding = (ENC_PRFW_I_P_BI_S); instr->operation = enc_to_oper(ENC_PRFW_I_P_BI_S); rc = 0; };
 }
 return rc;
}


int prfw_i_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E010)==0x8500C000) {
  decode_fields32(ENC_PRFW_I_P_BR_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->scale = 2;
  {instr->encoding = (ENC_PRFW_I_P_BR_S); instr->operation = enc_to_oper(ENC_PRFW_I_P_BR_S); rc = 0; };
 }
 return rc;
}


int prfw_i_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0E010)==0x84204000) {
  decode_fields32(ENC_PRFW_I_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 2;
  {instr->encoding = (ENC_PRFW_I_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFW_I_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFA0E010)==0xC4204000) {
  decode_fields32(ENC_PRFW_I_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = (ctx->xs==0);
  ctx->scale = 2;
  {instr->encoding = (ENC_PRFW_I_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_PRFW_I_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E010)==0xC460C000) {
  decode_fields32(ENC_PRFW_I_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->level = (unsigned int)((((ctx->prfop)>>(1)) & (((uint64_t)1<<((2)-(1)+1))-1)));
  ctx->stream = ((((ctx->prfop)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))==1);
  if((((ctx->prfop)>>(3)) & (((uint64_t)1<<((3)-(3)+1))-1))==0) {
   ctx->pref_hint = Prefetch_READ;
  };
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 42775 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 42775 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 2;
  {instr->encoding = (ENC_PRFW_I_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_PRFW_I_P_BZ_D_64_SCALED); rc = 0; };
 }
 return rc;
}


int ptest_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFC21F)==0x2550C000) {
  decode_fields32(ENC_PTEST_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  {instr->encoding = (ENC_PTEST_P_P_); instr->operation = enc_to_oper(ENC_PTEST_P_P_); rc = 0; };
 }
 return rc;
}


int ptrue_p_s(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC10)==0x2518E000) {
  decode_fields32(ENC_PTRUE_P_S_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 42814 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 42814 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 42815 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 42815 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->pat = ctx->pattern;
  {instr->encoding = (ENC_PTRUE_P_S_); instr->operation = enc_to_oper(ENC_PTRUE_P_S_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FFC10)==0x2519E000) {
  decode_fields32(ENC_PTRUES_P_S_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 42828 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 42828 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 42829 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 42829 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  ctx->pat = ctx->pattern;
  {instr->encoding = (ENC_PTRUES_P_S_); instr->operation = enc_to_oper(ENC_PTRUES_P_S_); rc = 0; };
 }
 return rc;
}


int punpkhi_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFE10)==0x5314000) {
  decode_fields32(ENC_PUNPKHI_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->hi = 
# 42850 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
           1
# 42850 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
               ;
  {instr->encoding = (ENC_PUNPKHI_P_P_); instr->operation = enc_to_oper(ENC_PUNPKHI_P_P_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFFE10)==0x5304000) {
  decode_fields32(ENC_PUNPKLO_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->hi = 
# 42863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
           0
# 42863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                ;
  {instr->encoding = (ENC_PUNPKLO_P_P_); instr->operation = enc_to_oper(ENC_PUNPKLO_P_P_); rc = 0; };
 }
 return rc;
}


int raddhnb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45206800) {
  decode_fields32(ENC_RADDHNB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_RADDHNB_Z_ZZ_); instr->operation = enc_to_oper(ENC_RADDHNB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int raddhnt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45206C00) {
  decode_fields32(ENC_RADDHNT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_RADDHNT_Z_ZZ_); instr->operation = enc_to_oper(ENC_RADDHNT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int rax1_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4520F400) {
  decode_fields32(ENC_RAX1_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<40))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_RAX1_Z_ZZ_); instr->operation = enc_to_oper(ENC_RAX1_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int rbit_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5278000) {
  decode_fields32(ENC_RBIT_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_RBIT_Z_P_Z_); instr->operation = enc_to_oper(ENC_RBIT_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int rdffr_p_f(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFF0)==0x2519F000) {
  decode_fields32(ENC_RDFFR_P_F_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Pd);
  {instr->encoding = (ENC_RDFFR_P_F_); instr->operation = enc_to_oper(ENC_RDFFR_P_F_); rc = 0; };
 }
 return rc;
}


int rdffr_p_p_f(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFE10)==0x2518F000) {
  decode_fields32(ENC_RDFFR_P_P_F_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 42984 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   0
# 42984 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                        ;
  ctx->setflags = 
# 42985 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 0
# 42985 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_RDFFR_P_P_F_); instr->operation = enc_to_oper(ENC_RDFFR_P_P_F_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFFE10)==0x2558F000) {
  decode_fields32(ENC_RDFFRS_P_P_F_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->d = (unsigned int)(ctx->Pd);
  instr->setflags = 
# 42997 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                   1
# 42997 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->setflags = 
# 42998 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                 1
# 42998 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                     ;
  {instr->encoding = (ENC_RDFFRS_P_P_F_); instr->operation = enc_to_oper(ENC_RDFFRS_P_P_F_); rc = 0; };
 }
 return rc;
}


int rdvl_r_i(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFF800)==0x4BF5000) {
  decode_fields32(ENC_RDVL_R_I_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->d = (unsigned int)(ctx->Rd);
  ctx->imm = SignExtend((ctx->imm6),(6));
  {instr->encoding = (ENC_RDVL_R_I_); instr->operation = enc_to_oper(ENC_RDVL_R_I_); rc = 0; };
 }
 return rc;
}


int rev_p_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE10)==0x5344000) {
  decode_fields32(ENC_REV_P_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->d = (unsigned int)(ctx->Pd);
  {instr->encoding = (ENC_REV_P_P_); instr->operation = enc_to_oper(ENC_REV_P_P_); rc = 0; };
 }
 return rc;
}


int rev_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5383800) {
  decode_fields32(ENC_REV_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_REV_Z_Z_); instr->operation = enc_to_oper(ENC_REV_Z_Z_); rc = 0; };
 }
 return rc;
}


int revb_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x5248000) {
  decode_fields32(ENC_REVB_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->swsize = 8;
  {instr->encoding = (ENC_REVB_Z_Z_); instr->operation = enc_to_oper(ENC_REVB_Z_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x5258000) {
  decode_fields32(ENC_REVH_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if((ctx->size&2)!=2) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->swsize = 0x10;
  {instr->encoding = (ENC_REVH_Z_Z_); instr->operation = enc_to_oper(ENC_REVH_Z_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x5268000) {
  decode_fields32(ENC_REVW_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->swsize = 0x20;
  {instr->encoding = (ENC_REVW_Z_Z_); instr->operation = enc_to_oper(ENC_REVW_Z_Z_); rc = 0; };
 }
 return rc;
}


int rshrnb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45201800) {
  decode_fields32(ENC_RSHRNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_RSHRNB_Z_ZI_); instr->operation = enc_to_oper(ENC_RSHRNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int rshrnt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45201C00) {
  decode_fields32(ENC_RSHRNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_RSHRNT_Z_ZI_); instr->operation = enc_to_oper(ENC_RSHRNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int rsubhnb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45207800) {
  decode_fields32(ENC_RSUBHNB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_RSUBHNB_Z_ZZ_); instr->operation = enc_to_oper(ENC_RSUBHNB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int rsubhnt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45207C00) {
  decode_fields32(ENC_RSUBHNT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_RSUBHNT_Z_ZZ_); instr->operation = enc_to_oper(ENC_RSUBHNT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int saba_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500F800) {
  decode_fields32(ENC_SABA_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->unsigned_ = 
# 43243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SABA_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SABA_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sabalb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500C000) {
  decode_fields32(ENC_SABALB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SABALB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SABALB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sabalt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500C400) {
  decode_fields32(ENC_SABALT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SABALT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SABALT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sabd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40C0000) {
  decode_fields32(ENC_SABD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 43310 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43310 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SABD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SABD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sabdlb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45003000) {
  decode_fields32(ENC_SABDLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SABDLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SABDLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sabdlt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45003400) {
  decode_fields32(ENC_SABDLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SABDLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SABDLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sadalp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4404A000) {
  decode_fields32(ENC_SADALP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SADALP_Z_P_Z_); instr->operation = enc_to_oper(ENC_SADALP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int saddlb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45000000) {
  decode_fields32(ENC_SADDLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 0;
  ctx->sel2 = 0;
  ctx->unsigned_ = 
# 43405 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43405 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SADDLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SADDLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int saddlbt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45008000) {
  decode_fields32(ENC_SADDLBT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 0;
  ctx->sel2 = 1;
  ctx->unsigned_ = 
# 43431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43431 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SADDLBT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SADDLBT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int saddlt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45000400) {
  decode_fields32(ENC_SADDLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 1;
  ctx->sel2 = 1;
  ctx->unsigned_ = 
# 43457 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43457 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SADDLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SADDLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int saddv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4002000) {
  decode_fields32(ENC_SADDV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_SADDV_R_P_Z_); instr->operation = enc_to_oper(ENC_SADDV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int saddwb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45004000) {
  decode_fields32(ENC_SADDWB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SADDWB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SADDWB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int saddwt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45004400) {
  decode_fields32(ENC_SADDWT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SADDWT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SADDWT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sbclb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4580D000) {
  decode_fields32(ENC_SBCLB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SBCLB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SBCLB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sbclt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4580D400) {
  decode_fields32(ENC_SBCLT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (0x20) << ((unsigned int)(ctx->sz));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SBCLT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SBCLT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int scvtf_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x6552A000) {
  decode_fields32(ENC_SCVTF_Z_P_Z_H2FP16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 43589 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43589 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_Z_P_Z_H2FP16); instr->operation = enc_to_oper(ENC_SCVTF_Z_P_Z_H2FP16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x6554A000) {
  decode_fields32(ENC_SCVTF_Z_P_Z_W2FP16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 43606 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43606 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_Z_P_Z_W2FP16); instr->operation = enc_to_oper(ENC_SCVTF_Z_P_Z_W2FP16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x6594A000) {
  decode_fields32(ENC_SCVTF_Z_P_Z_W2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 43623 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43623 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_Z_P_Z_W2S); instr->operation = enc_to_oper(ENC_SCVTF_Z_P_Z_W2S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D0A000) {
  decode_fields32(ENC_SCVTF_Z_P_Z_W2D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 43640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43640 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_Z_P_Z_W2D); instr->operation = enc_to_oper(ENC_SCVTF_Z_P_Z_W2D); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x6556A000) {
  decode_fields32(ENC_SCVTF_Z_P_Z_X2FP16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 43657 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43657 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_Z_P_Z_X2FP16); instr->operation = enc_to_oper(ENC_SCVTF_Z_P_Z_X2FP16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D4A000) {
  decode_fields32(ENC_SCVTF_Z_P_Z_X2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 43674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_Z_P_Z_X2S); instr->operation = enc_to_oper(ENC_SCVTF_Z_P_Z_X2S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D6A000) {
  decode_fields32(ENC_SCVTF_Z_P_Z_X2D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 43691 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43691 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_SCVTF_Z_P_Z_X2D); instr->operation = enc_to_oper(ENC_SCVTF_Z_P_Z_X2D); rc = 0; };
 }
 return rc;
}


int sdiv_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4140000) {
  decode_fields32(ENC_SDIV_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 43716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43716 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SDIV_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SDIV_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sdivr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4160000) {
  decode_fields32(ENC_SDIVR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 43740 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 43740 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SDIVR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SDIVR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sdot_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44000000) {
  decode_fields32(ENC_SDOT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SDOT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SDOT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sdot_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x44A00000) {
  decode_fields32(ENC_SDOT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SDOT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SDOT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E00000) {
  decode_fields32(ENC_SDOT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SDOT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SDOT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int sel_p_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0C210)==0x25004210) {
  decode_fields32(ENC_SEL_P_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);

  if(ctx->Pd==ctx->Pm) return MOV_sel_p_p_pp(ctx, instr);
  {instr->encoding = (ENC_SEL_P_P_PP_); instr->operation = enc_to_oper(ENC_SEL_P_P_PP_); rc = 0; };
 }
 return rc;
}


int sel_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20C000)==0x520C000) {
  decode_fields32(ENC_SEL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);

  if(ctx->Zd==ctx->Zm) return MOV_sel_z_p_zz(ctx, instr);
  {instr->encoding = (ENC_SEL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SEL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int setffr_f(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFFFF)==0x252C9000) {
  decode_fields32(ENC_SETFFR_F_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  {instr->encoding = (ENC_SETFFR_F_); instr->operation = enc_to_oper(ENC_SETFFR_F_); rc = 0; };
 }
 return rc;
}


int shadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44108000) {
  decode_fields32(ENC_SHADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SHADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SHADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int shared_pseudocode(context *ctx, Instruction *instr)
{
 int rc = -2;
 return rc;
}


int shrnb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45201000) {
  decode_fields32(ENC_SHRNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SHRNB_Z_ZI_); instr->operation = enc_to_oper(ENC_SHRNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int shrnt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45201400) {
  decode_fields32(ENC_SHRNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SHRNT_Z_ZI_); instr->operation = enc_to_oper(ENC_SHRNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int shsub_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44128000) {
  decode_fields32(ENC_SHSUB_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SHSUB_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SHSUB_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int shsubr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44168000) {
  decode_fields32(ENC_SHSUBR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SHSUBR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SHSUBR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sli_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500F400) {
  decode_fields32(ENC_SLI_Z_ZZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_SLI_Z_ZZI_); instr->operation = enc_to_oper(ENC_SLI_Z_ZZI_); rc = 0; };
 }
 return rc;
}


int sm4e_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFC00)==0x4523E000) {
  decode_fields32(ENC_SM4E_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<41))) {
   { return -4; };
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SM4E_Z_ZZ_); instr->operation = enc_to_oper(ENC_SM4E_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sm4ekey_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x4520F000) {
  decode_fields32(ENC_SM4EKEY_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<41))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SM4EKEY_Z_ZZ_); instr->operation = enc_to_oper(ENC_SM4EKEY_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int smax_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4080000) {
  decode_fields32(ENC_SMAX_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 44084 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44084 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SMAX_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SMAX_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int smax_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x2528C000) {
  decode_fields32(ENC_SMAX_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 44103 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44103 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->imm = (unsigned int)(ctx->imm8);
  {instr->encoding = (ENC_SMAX_Z_ZI_); instr->operation = enc_to_oper(ENC_SMAX_Z_ZI_); rc = 0; };
 }
 return rc;
}


int smaxp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4414A000) {
  decode_fields32(ENC_SMAXP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SMAXP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SMAXP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int smaxv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4082000) {
  decode_fields32(ENC_SMAXV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  ctx->unsigned_ = 
# 44145 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44145 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SMAXV_R_P_Z_); instr->operation = enc_to_oper(ENC_SMAXV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int smin_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40A0000) {
  decode_fields32(ENC_SMIN_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 44166 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44166 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SMIN_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SMIN_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int smin_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x252AC000) {
  decode_fields32(ENC_SMIN_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 44185 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44185 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->imm = (unsigned int)(ctx->imm8);
  {instr->encoding = (ENC_SMIN_Z_ZI_); instr->operation = enc_to_oper(ENC_SMIN_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sminp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4416A000) {
  decode_fields32(ENC_SMINP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SMINP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SMINP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sminv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40A2000) {
  decode_fields32(ENC_SMINV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  ctx->unsigned_ = 
# 44227 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44227 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SMINV_R_P_Z_); instr->operation = enc_to_oper(ENC_SMINV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int smlalb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44004000) {
  decode_fields32(ENC_SMLALB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SMLALB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SMLALB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int smlalb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A08000) {
  decode_fields32(ENC_SMLALB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SMLALB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SMLALB_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E08000) {
  decode_fields32(ENC_SMLALB_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SMLALB_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SMLALB_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int smlalt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44004400) {
  decode_fields32(ENC_SMLALT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SMLALT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SMLALT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int smlalt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A08400) {
  decode_fields32(ENC_SMLALT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SMLALT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SMLALT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E08400) {
  decode_fields32(ENC_SMLALT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SMLALT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SMLALT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int smlslb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44005000) {
  decode_fields32(ENC_SMLSLB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SMLSLB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SMLSLB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int smlslb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0A000) {
  decode_fields32(ENC_SMLSLB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SMLSLB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SMLSLB_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0A000) {
  decode_fields32(ENC_SMLSLB_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SMLSLB_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SMLSLB_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int smlslt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44005400) {
  decode_fields32(ENC_SMLSLT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SMLSLT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SMLSLT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int smlslt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0A400) {
  decode_fields32(ENC_SMLSLT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SMLSLT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SMLSLT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0A400) {
  decode_fields32(ENC_SMLSLT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SMLSLT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SMLSLT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int smmla_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x45009800) {
  decode_fields32(ENC_SMMLA_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_unsigned = 
# 44487 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 44487 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->op2_unsigned = 
# 44488 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 44488 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  {instr->encoding = (ENC_SMMLA_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SMMLA_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int smulh_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4120000) {
  decode_fields32(ENC_SMULH_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 44509 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44509 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SMULH_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SMULH_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int smulh_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4206800) {
  decode_fields32(ENC_SMULH_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 44530 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44530 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SMULH_Z_ZZ_); instr->operation = enc_to_oper(ENC_SMULH_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int smullb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45007000) {
  decode_fields32(ENC_SMULLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SMULLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SMULLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int smullb_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0C000) {
  decode_fields32(ENC_SMULLB_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 0;
  {instr->encoding = (ENC_SMULLB_Z_ZZI_S); instr->operation = enc_to_oper(ENC_SMULLB_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0C000) {
  decode_fields32(ENC_SMULLB_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 0;
  {instr->encoding = (ENC_SMULLB_Z_ZZI_D); instr->operation = enc_to_oper(ENC_SMULLB_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int smullt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45007400) {
  decode_fields32(ENC_SMULLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SMULLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SMULLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int smullt_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0C400) {
  decode_fields32(ENC_SMULLT_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 1;
  {instr->encoding = (ENC_SMULLT_Z_ZZI_S); instr->operation = enc_to_oper(ENC_SMULLT_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0C400) {
  decode_fields32(ENC_SMULLT_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 1;
  {instr->encoding = (ENC_SMULLT_Z_ZZI_D); instr->operation = enc_to_oper(ENC_SMULLT_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int splice_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x52D8000) {
  decode_fields32(ENC_SPLICE_Z_P_ZZ_CON, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dst = (unsigned int)(ctx->Zd);
  ctx->s1 = (unsigned int)(ctx->Zn);
  ctx->s2 = ((ctx->s1+1)) % 32;
  {instr->encoding = (ENC_SPLICE_Z_P_ZZ_CON); instr->operation = enc_to_oper(ENC_SPLICE_Z_P_ZZ_CON); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x52C8000) {
  decode_fields32(ENC_SPLICE_Z_P_ZZ_DES, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dst = (unsigned int)(ctx->Zdn);
  ctx->s1 = ctx->dst;
  ctx->s2 = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SPLICE_Z_P_ZZ_DES); instr->operation = enc_to_oper(ENC_SPLICE_Z_P_ZZ_DES); rc = 0; };
 }
 return rc;
}


int sqabs_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4408A000) {
  decode_fields32(ENC_SQABS_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQABS_Z_P_Z_); instr->operation = enc_to_oper(ENC_SQABS_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int sqadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44188000) {
  decode_fields32(ENC_SQADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 44726 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44726 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SQADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sqadd_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2524C000) {
  decode_fields32(ENC_SQADD_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (unsigned int)(ctx->imm8);
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }
  ctx->unsigned_ = 
# 44752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44752 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQADD_Z_ZI_); instr->operation = enc_to_oper(ENC_SQADD_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqadd_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4201000) {
  decode_fields32(ENC_SQADD_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 44773 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44773 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQADD_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQADD_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqcadd_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FF800)==0x4501D800) {
  decode_fields32(ENC_SQCADD_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->sub_i = (ctx->rot==0);
  ctx->sub_r = (ctx->rot==1);
  {instr->encoding = (ENC_SQCADD_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQCADD_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqdecb_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x420F800) {
  decode_fields32(ENC_SQDECB_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44815 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44815 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQDECB_R_RS_SX); instr->operation = enc_to_oper(ENC_SQDECB_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x430F800) {
  decode_fields32(ENC_SQDECB_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44830 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44830 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQDECB_R_RS_X); instr->operation = enc_to_oper(ENC_SQDECB_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqdecd_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0F800) {
  decode_fields32(ENC_SQDECD_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44852 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44852 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQDECD_R_RS_SX); instr->operation = enc_to_oper(ENC_SQDECD_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0F800) {
  decode_fields32(ENC_SQDECD_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44867 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44867 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQDECD_R_RS_X); instr->operation = enc_to_oper(ENC_SQDECD_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqdecd_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0C800) {
  decode_fields32(ENC_SQDECD_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44889 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44889 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQDECD_Z_ZS_); instr->operation = enc_to_oper(ENC_SQDECD_Z_ZS_); rc = 0; };
 }
 return rc;
}


int sqdech_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460F800) {
  decode_fields32(ENC_SQDECH_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44910 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44910 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQDECH_R_RS_SX); instr->operation = enc_to_oper(ENC_SQDECH_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470F800) {
  decode_fields32(ENC_SQDECH_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44925 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44925 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQDECH_R_RS_X); instr->operation = enc_to_oper(ENC_SQDECH_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqdech_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460C800) {
  decode_fields32(ENC_SQDECH_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 44947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44947 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQDECH_Z_ZS_); instr->operation = enc_to_oper(ENC_SQDECH_Z_ZS_); rc = 0; };
 }
 return rc;
}


int sqdecp_r_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252A8800) {
  decode_fields32(ENC_SQDECP_R_P_R_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 44967 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44967 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQDECP_R_P_R_SX); instr->operation = enc_to_oper(ENC_SQDECP_R_P_R_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FFE00)==0x252A8C00) {
  decode_fields32(ENC_SQDECP_R_P_R_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 44981 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 44981 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQDECP_R_P_R_X); instr->operation = enc_to_oper(ENC_SQDECP_R_P_R_X); rc = 0; };
 }
 return rc;
}


int sqdecp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252A8000) {
  decode_fields32(ENC_SQDECP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 45005 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45005 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQDECP_Z_P_Z_); instr->operation = enc_to_oper(ENC_SQDECP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int sqdecw_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0F800) {
  decode_fields32(ENC_SQDECW_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45026 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45026 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQDECW_R_RS_SX); instr->operation = enc_to_oper(ENC_SQDECW_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0F800) {
  decode_fields32(ENC_SQDECW_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45041 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45041 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQDECW_R_RS_X); instr->operation = enc_to_oper(ENC_SQDECW_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqdecw_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0C800) {
  decode_fields32(ENC_SQDECW_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45063 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45063 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQDECW_Z_ZS_); instr->operation = enc_to_oper(ENC_SQDECW_Z_ZS_); rc = 0; };
 }
 return rc;
}


int sqdmlalb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44006000) {
  decode_fields32(ENC_SQDMLALB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel1 = 0;
  ctx->sel2 = 0;
  {instr->encoding = (ENC_SQDMLALB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQDMLALB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqdmlalb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A02000) {
  decode_fields32(ENC_SQDMLALB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SQDMLALB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SQDMLALB_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E02000) {
  decode_fields32(ENC_SQDMLALB_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SQDMLALB_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SQDMLALB_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int sqdmlalbt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44000800) {
  decode_fields32(ENC_SQDMLALBT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel1 = 0;
  ctx->sel2 = 1;
  {instr->encoding = (ENC_SQDMLALBT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQDMLALBT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqdmlalt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44006400) {
  decode_fields32(ENC_SQDMLALT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel1 = 1;
  ctx->sel2 = 1;
  {instr->encoding = (ENC_SQDMLALT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQDMLALT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqdmlalt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A02400) {
  decode_fields32(ENC_SQDMLALT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SQDMLALT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SQDMLALT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E02400) {
  decode_fields32(ENC_SQDMLALT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SQDMLALT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SQDMLALT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int sqdmlslb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44006800) {
  decode_fields32(ENC_SQDMLSLB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel1 = 0;
  ctx->sel2 = 0;
  {instr->encoding = (ENC_SQDMLSLB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQDMLSLB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqdmlslb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A03000) {
  decode_fields32(ENC_SQDMLSLB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SQDMLSLB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SQDMLSLB_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E03000) {
  decode_fields32(ENC_SQDMLSLB_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_SQDMLSLB_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SQDMLSLB_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int sqdmlslbt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44000C00) {
  decode_fields32(ENC_SQDMLSLBT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel1 = 0;
  ctx->sel2 = 1;
  {instr->encoding = (ENC_SQDMLSLBT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQDMLSLBT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqdmlslt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44006C00) {
  decode_fields32(ENC_SQDMLSLT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel1 = 1;
  ctx->sel2 = 1;
  {instr->encoding = (ENC_SQDMLSLT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQDMLSLT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqdmlslt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A03400) {
  decode_fields32(ENC_SQDMLSLT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SQDMLSLT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SQDMLSLT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E03400) {
  decode_fields32(ENC_SQDMLSLT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_SQDMLSLT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SQDMLSLT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int sqdmulh_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4207000) {
  decode_fields32(ENC_SQDMULH_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQDMULH_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQDMULH_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqdmulh_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4420F000) {
  decode_fields32(ENC_SQDMULH_Z_ZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQDMULH_Z_ZZI_H); instr->operation = enc_to_oper(ENC_SQDMULH_Z_ZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44A0F000) {
  decode_fields32(ENC_SQDMULH_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQDMULH_Z_ZZI_S); instr->operation = enc_to_oper(ENC_SQDMULH_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E0F000) {
  decode_fields32(ENC_SQDMULH_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQDMULH_Z_ZZI_D); instr->operation = enc_to_oper(ENC_SQDMULH_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int sqdmullb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45006000) {
  decode_fields32(ENC_SQDMULLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQDMULLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQDMULLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqdmullb_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0E000) {
  decode_fields32(ENC_SQDMULLB_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 0;
  {instr->encoding = (ENC_SQDMULLB_Z_ZZI_S); instr->operation = enc_to_oper(ENC_SQDMULLB_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0E000) {
  decode_fields32(ENC_SQDMULLB_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 0;
  {instr->encoding = (ENC_SQDMULLB_Z_ZZI_D); instr->operation = enc_to_oper(ENC_SQDMULLB_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int sqdmullt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45006400) {
  decode_fields32(ENC_SQDMULLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQDMULLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQDMULLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqdmullt_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0E400) {
  decode_fields32(ENC_SQDMULLT_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 1;
  {instr->encoding = (ENC_SQDMULLT_Z_ZZI_S); instr->operation = enc_to_oper(ENC_SQDMULLT_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0E400) {
  decode_fields32(ENC_SQDMULLT_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 1;
  {instr->encoding = (ENC_SQDMULLT_Z_ZZI_D); instr->operation = enc_to_oper(ENC_SQDMULLT_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int sqincb_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x420F000) {
  decode_fields32(ENC_SQINCB_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45571 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45571 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQINCB_R_RS_SX); instr->operation = enc_to_oper(ENC_SQINCB_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x430F000) {
  decode_fields32(ENC_SQINCB_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45586 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45586 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQINCB_R_RS_X); instr->operation = enc_to_oper(ENC_SQINCB_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqincd_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0F000) {
  decode_fields32(ENC_SQINCD_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45608 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45608 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQINCD_R_RS_SX); instr->operation = enc_to_oper(ENC_SQINCD_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0F000) {
  decode_fields32(ENC_SQINCD_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45623 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45623 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQINCD_R_RS_X); instr->operation = enc_to_oper(ENC_SQINCD_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqincd_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0C000) {
  decode_fields32(ENC_SQINCD_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45645 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45645 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQINCD_Z_ZS_); instr->operation = enc_to_oper(ENC_SQINCD_Z_ZS_); rc = 0; };
 }
 return rc;
}


int sqinch_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460F000) {
  decode_fields32(ENC_SQINCH_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45666 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45666 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQINCH_R_RS_SX); instr->operation = enc_to_oper(ENC_SQINCH_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470F000) {
  decode_fields32(ENC_SQINCH_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45681 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45681 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQINCH_R_RS_X); instr->operation = enc_to_oper(ENC_SQINCH_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqinch_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460C000) {
  decode_fields32(ENC_SQINCH_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45703 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45703 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQINCH_Z_ZS_); instr->operation = enc_to_oper(ENC_SQINCH_Z_ZS_); rc = 0; };
 }
 return rc;
}


int sqincp_r_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x25288800) {
  decode_fields32(ENC_SQINCP_R_P_R_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 45723 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45723 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQINCP_R_P_R_SX); instr->operation = enc_to_oper(ENC_SQINCP_R_P_R_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FFE00)==0x25288C00) {
  decode_fields32(ENC_SQINCP_R_P_R_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 45737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45737 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQINCP_R_P_R_X); instr->operation = enc_to_oper(ENC_SQINCP_R_P_R_X); rc = 0; };
 }
 return rc;
}


int sqincp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x25288000) {
  decode_fields32(ENC_SQINCP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 45761 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45761 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQINCP_Z_P_Z_); instr->operation = enc_to_oper(ENC_SQINCP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int sqincw_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0F000) {
  decode_fields32(ENC_SQINCW_R_RS_SX, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_SQINCW_R_RS_SX); instr->operation = enc_to_oper(ENC_SQINCW_R_RS_SX); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0F000) {
  decode_fields32(ENC_SQINCW_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45797 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_SQINCW_R_RS_X); instr->operation = enc_to_oper(ENC_SQINCW_R_RS_X); rc = 0; };
 }
 return rc;
}


int sqincw_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0C000) {
  decode_fields32(ENC_SQINCW_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 45819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 45819 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQINCW_Z_ZS_); instr->operation = enc_to_oper(ENC_SQINCW_Z_ZS_); rc = 0; };
 }
 return rc;
}


int sqneg_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4409A000) {
  decode_fields32(ENC_SQNEG_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQNEG_Z_P_Z_); instr->operation = enc_to_oper(ENC_SQNEG_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int sqrdcmlah_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20F000)==0x44003000) {
  decode_fields32(ENC_SQRDCMLAH_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  {instr->encoding = (ENC_SQRDCMLAH_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQRDCMLAH_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqrdcmlah_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F000)==0x44A07000) {
  decode_fields32(ENC_SQRDCMLAH_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  {instr->encoding = (ENC_SQRDCMLAH_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_SQRDCMLAH_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F000)==0x44E07000) {
  decode_fields32(ENC_SQRDCMLAH_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel_a = (unsigned int)((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1)));
  ctx->sel_b = (unsigned int)((((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))) ^ (((uint64_t)1<<(1))-1)));
  ctx->sub_r = ((((ctx->rot)>>(0)) & (((uint64_t)1<<((0)-(0)+1))-1))!=(((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1)));
  ctx->sub_i = ((((ctx->rot)>>(1)) & (((uint64_t)1<<((1)-(1)+1))-1))==1);
  {instr->encoding = (ENC_SQRDCMLAH_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SQRDCMLAH_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int sqrdmlah_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44007000) {
  decode_fields32(ENC_SQRDMLAH_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLAH_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQRDMLAH_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqrdmlah_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x44201000) {
  decode_fields32(ENC_SQRDMLAH_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLAH_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_SQRDMLAH_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44A01000) {
  decode_fields32(ENC_SQRDMLAH_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLAH_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SQRDMLAH_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E01000) {
  decode_fields32(ENC_SQRDMLAH_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLAH_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SQRDMLAH_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int sqrdmlsh_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44007400) {
  decode_fields32(ENC_SQRDMLSH_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLSH_Z_ZZZ_); instr->operation = enc_to_oper(ENC_SQRDMLSH_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int sqrdmlsh_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x44201400) {
  decode_fields32(ENC_SQRDMLSH_Z_ZZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLSH_Z_ZZZI_H); instr->operation = enc_to_oper(ENC_SQRDMLSH_Z_ZZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44A01400) {
  decode_fields32(ENC_SQRDMLSH_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLSH_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SQRDMLSH_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E01400) {
  decode_fields32(ENC_SQRDMLSH_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SQRDMLSH_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_SQRDMLSH_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int sqrdmulh_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4207400) {
  decode_fields32(ENC_SQRDMULH_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQRDMULH_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQRDMULH_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqrdmulh_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4420F400) {
  decode_fields32(ENC_SQRDMULH_Z_ZZI_H, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<2)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQRDMULH_Z_ZZI_H); instr->operation = enc_to_oper(ENC_SQRDMULH_Z_ZZI_H); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44A0F400) {
  decode_fields32(ENC_SQRDMULH_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQRDMULH_Z_ZZI_S); instr->operation = enc_to_oper(ENC_SQRDMULH_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E0F400) {
  decode_fields32(ENC_SQRDMULH_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQRDMULH_Z_ZZI_D); instr->operation = enc_to_oper(ENC_SQRDMULH_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int sqrshl_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x440A8000) {
  decode_fields32(ENC_SQRSHL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SQRSHL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SQRSHL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sqrshlr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x440E8000) {
  decode_fields32(ENC_SQRSHLR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SQRSHLR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SQRSHLR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sqrshrnb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45202800) {
  decode_fields32(ENC_SQRSHRNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQRSHRNB_Z_ZI_); instr->operation = enc_to_oper(ENC_SQRSHRNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqrshrnt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45202C00) {
  decode_fields32(ENC_SQRSHRNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQRSHRNT_Z_ZI_); instr->operation = enc_to_oper(ENC_SQRSHRNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqrshrunb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45200800) {
  decode_fields32(ENC_SQRSHRUNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQRSHRUNB_Z_ZI_); instr->operation = enc_to_oper(ENC_SQRSHRUNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqrshrunt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45200C00) {
  decode_fields32(ENC_SQRSHRUNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQRSHRUNT_Z_ZI_); instr->operation = enc_to_oper(ENC_SQRSHRUNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqshl_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4068000) {
  decode_fields32(ENC_SQSHL_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_SQSHL_Z_P_ZI_); instr->operation = enc_to_oper(ENC_SQSHL_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int sqshl_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44088000) {
  decode_fields32(ENC_SQSHL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SQSHL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SQSHL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sqshlr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x440C8000) {
  decode_fields32(ENC_SQSHLR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SQSHLR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SQSHLR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sqshlu_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40F8000) {
  decode_fields32(ENC_SQSHLU_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_SQSHLU_Z_P_ZI_); instr->operation = enc_to_oper(ENC_SQSHLU_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int sqshrnb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45202000) {
  decode_fields32(ENC_SQSHRNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQSHRNB_Z_ZI_); instr->operation = enc_to_oper(ENC_SQSHRNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqshrnt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45202400) {
  decode_fields32(ENC_SQSHRNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQSHRNT_Z_ZI_); instr->operation = enc_to_oper(ENC_SQSHRNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqshrunb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45200000) {
  decode_fields32(ENC_SQSHRUNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQSHRUNB_Z_ZI_); instr->operation = enc_to_oper(ENC_SQSHRUNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqshrunt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45200400) {
  decode_fields32(ENC_SQSHRUNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SQSHRUNT_Z_ZI_); instr->operation = enc_to_oper(ENC_SQSHRUNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqsub_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x441A8000) {
  decode_fields32(ENC_SQSUB_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 46540 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 46540 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQSUB_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SQSUB_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sqsub_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2526C000) {
  decode_fields32(ENC_SQSUB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (unsigned int)(ctx->imm8);
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }
  ctx->unsigned_ = 
# 46566 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 46566 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQSUB_Z_ZI_); instr->operation = enc_to_oper(ENC_SQSUB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sqsub_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4201800) {
  decode_fields32(ENC_SQSUB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 46587 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 46587 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQSUB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQSUB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqsubr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x441E8000) {
  decode_fields32(ENC_SQSUBR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 46608 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 46608 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SQSUBR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SQSUBR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sqxtnb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA7FC00)==0x45204000) {
  decode_fields32(ENC_SQXTNB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(ctx->tsize==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->tsize==2) {
   ctx->esize = 0x20;
  }
  else if(ctx->tsize==4) {
   ctx->esize = 0x40;
  }
  else {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQXTNB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQXTNB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqxtnt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA7FC00)==0x45204400) {
  decode_fields32(ENC_SQXTNT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(ctx->tsize==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->tsize==2) {
   ctx->esize = 0x20;
  }
  else if(ctx->tsize==4) {
   ctx->esize = 0x40;
  }
  else {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQXTNT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQXTNT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqxtunb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA7FC00)==0x45205000) {
  decode_fields32(ENC_SQXTUNB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(ctx->tsize==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->tsize==2) {
   ctx->esize = 0x20;
  }
  else if(ctx->tsize==4) {
   ctx->esize = 0x40;
  }
  else {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQXTUNB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQXTUNB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int sqxtunt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA7FC00)==0x45205400) {
  decode_fields32(ENC_SQXTUNT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(ctx->tsize==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->tsize==2) {
   ctx->esize = 0x20;
  }
  else if(ctx->tsize==4) {
   ctx->esize = 0x40;
  }
  else {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SQXTUNT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SQXTUNT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int srhadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44148000) {
  decode_fields32(ENC_SRHADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SRHADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SRHADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sri_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500F000) {
  decode_fields32(ENC_SRI_Z_ZZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SRI_Z_ZZI_); instr->operation = enc_to_oper(ENC_SRI_Z_ZZI_); rc = 0; };
 }
 return rc;
}


int srshl_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44028000) {
  decode_fields32(ENC_SRSHL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SRSHL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SRSHL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int srshlr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44068000) {
  decode_fields32(ENC_SRSHLR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_SRSHLR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SRSHLR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int srshr_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40C8000) {
  decode_fields32(ENC_SRSHR_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SRSHR_Z_P_ZI_); instr->operation = enc_to_oper(ENC_SRSHR_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int srsra_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500E800) {
  decode_fields32(ENC_SRSRA_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SRSRA_Z_ZI_); instr->operation = enc_to_oper(ENC_SRSRA_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sshllb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4500A000) {
  decode_fields32(ENC_SSHLLB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_SSHLLB_Z_ZI_); instr->operation = enc_to_oper(ENC_SSHLLB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sshllt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4500A400) {
  decode_fields32(ENC_SSHLLT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_SSHLLT_Z_ZI_); instr->operation = enc_to_oper(ENC_SSHLLT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int ssra_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500E000) {
  decode_fields32(ENC_SSRA_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_SSRA_Z_ZI_); instr->operation = enc_to_oper(ENC_SSRA_Z_ZI_); rc = 0; };
 }
 return rc;
}


int ssublb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45001000) {
  decode_fields32(ENC_SSUBLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 0;
  ctx->sel2 = 0;
  ctx->unsigned_ = 
# 47022 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 47022 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SSUBLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SSUBLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int ssublbt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45008800) {
  decode_fields32(ENC_SSUBLBT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 0;
  ctx->sel2 = 1;
  ctx->unsigned_ = 
# 47048 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 47048 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SSUBLBT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SSUBLBT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int ssublt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45001400) {
  decode_fields32(ENC_SSUBLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 1;
  ctx->sel2 = 1;
  ctx->unsigned_ = 
# 47074 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 47074 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SSUBLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SSUBLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int ssubltb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45008C00) {
  decode_fields32(ENC_SSUBLTB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 1;
  ctx->sel2 = 0;
  ctx->unsigned_ = 
# 47100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 47100 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SSUBLTB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SSUBLTB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int ssubwb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45005000) {
  decode_fields32(ENC_SSUBWB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SSUBWB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SSUBWB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int ssubwt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45005400) {
  decode_fields32(ENC_SSUBWT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SSUBWT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SSUBWT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int st1b_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE460A000) {
  decode_fields32(ENC_ST1B_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_ST1B_Z_P_AI_S); instr->operation = enc_to_oper(ENC_ST1B_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE440A000) {
  decode_fields32(ENC_ST1B_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_ST1B_Z_P_AI_D); instr->operation = enc_to_oper(ENC_ST1B_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int st1b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF90E000)==0xE400E000) {
  decode_fields32(ENC_ST1B_Z_P_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->msize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_ST1B_Z_P_BI_); instr->operation = enc_to_oper(ENC_ST1B_Z_P_BI_); rc = 0; };
 }
 return rc;
}


int st1b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80E000)==0xE4004000) {
  decode_fields32(ENC_ST1B_Z_P_BR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->msize = 8;
  {instr->encoding = (ENC_ST1B_Z_P_BR_); instr->operation = enc_to_oper(ENC_ST1B_Z_P_BR_); rc = 0; };
 }
 return rc;
}


int st1b_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0A000)==0xE4008000) {
  decode_fields32(ENC_ST1B_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1B_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_ST1B_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE4408000) {
  decode_fields32(ENC_ST1B_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1B_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_ST1B_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE400A000) {
  decode_fields32(ENC_ST1B_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 47290 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 47290 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1B_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_ST1B_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int st1d_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5C0A000) {
  decode_fields32(ENC_ST1D_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_ST1D_Z_P_AI_D); instr->operation = enc_to_oper(ENC_ST1D_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int st1d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF90E000)==0xE580E000) {
  decode_fields32(ENC_ST1D_Z_P_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->msize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_ST1D_Z_P_BI_); instr->operation = enc_to_oper(ENC_ST1D_Z_P_BI_); rc = 0; };
 }
 return rc;
}


int st1d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5E04000) {
  decode_fields32(ENC_ST1D_Z_P_BR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  {instr->encoding = (ENC_ST1D_Z_P_BR_); instr->operation = enc_to_oper(ENC_ST1D_Z_P_BR_); rc = 0; };
 }
 return rc;
}


int st1d_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0A000)==0xE5A08000) {
  decode_fields32(ENC_ST1D_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 3;
  {instr->encoding = (ENC_ST1D_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_ST1D_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE5808000) {
  decode_fields32(ENC_ST1D_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1D_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_ST1D_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE5A0A000) {
  decode_fields32(ENC_ST1D_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 47423 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 47423 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 3;
  {instr->encoding = (ENC_ST1D_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_ST1D_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE580A000) {
  decode_fields32(ENC_ST1D_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 47441 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 47441 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1D_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_ST1D_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int st1h_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4E0A000) {
  decode_fields32(ENC_ST1H_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_ST1H_Z_P_AI_S); instr->operation = enc_to_oper(ENC_ST1H_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE4C0A000) {
  decode_fields32(ENC_ST1H_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_ST1H_Z_P_AI_D); instr->operation = enc_to_oper(ENC_ST1H_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int st1h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF90E000)==0xE480E000) {
  decode_fields32(ENC_ST1H_Z_P_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->msize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_ST1H_Z_P_BI_); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BI_); rc = 0; };
 }
 return rc;
}


int st1h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80E000)==0xE4804000) {
  decode_fields32(ENC_ST1H_Z_P_BR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->msize = 0x10;
  {instr->encoding = (ENC_ST1H_Z_P_BR_); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BR_); rc = 0; };
 }
 return rc;
}


int st1h_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0A000)==0xE4E08000) {
  decode_fields32(ENC_ST1H_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_ST1H_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE4A08000) {
  decode_fields32(ENC_ST1H_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 1;
  {instr->encoding = (ENC_ST1H_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE4808000) {
  decode_fields32(ENC_ST1H_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1H_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE4C08000) {
  decode_fields32(ENC_ST1H_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1H_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE4A0A000) {
  decode_fields32(ENC_ST1H_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 47628 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 47628 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 1;
  {instr->encoding = (ENC_ST1H_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE480A000) {
  decode_fields32(ENC_ST1H_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 47646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 47646 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1H_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_ST1H_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int st1w_z_p_ai(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE560A000) {
  decode_fields32(ENC_ST1W_Z_P_AI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_ST1W_Z_P_AI_S); instr->operation = enc_to_oper(ENC_ST1W_Z_P_AI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE540A000) {
  decode_fields32(ENC_ST1W_Z_P_AI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offset = (unsigned int)(ctx->imm5);
  {instr->encoding = (ENC_ST1W_Z_P_AI_D); instr->operation = enc_to_oper(ENC_ST1W_Z_P_AI_D); rc = 0; };
 }
 return rc;
}


int st1w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF90E000)==0xE500E000) {
  decode_fields32(ENC_ST1W_Z_P_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if((ctx->size&2)!=2) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->msize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_ST1W_Z_P_BI_); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BI_); rc = 0; };
 }
 return rc;
}


int st1w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF80E000)==0xE5004000) {
  decode_fields32(ENC_ST1W_Z_P_BR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if((ctx->size&2)!=2) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->msize = 0x20;
  {instr->encoding = (ENC_ST1W_Z_P_BR_); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BR_); rc = 0; };
 }
 return rc;
}


int st1w_z_p_bz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0A000)==0xE5608000) {
  decode_fields32(ENC_ST1W_Z_P_BZ_S_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_ST1W_Z_P_BZ_S_X32_SCALED); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BZ_S_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE5208000) {
  decode_fields32(ENC_ST1W_Z_P_BZ_D_X32_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 2;
  {instr->encoding = (ENC_ST1W_Z_P_BZ_D_X32_SCALED); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BZ_D_X32_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE5008000) {
  decode_fields32(ENC_ST1W_Z_P_BZ_D_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1W_Z_P_BZ_D_X32_UNSCALED); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BZ_D_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0A000)==0xE5408000) {
  decode_fields32(ENC_ST1W_Z_P_BZ_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  ctx->offs_size = 0x20;
  ctx->offs_unsigned = ctx->xs==0;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1W_Z_P_BZ_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BZ_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE520A000) {
  decode_fields32(ENC_ST1W_Z_P_BZ_D_64_SCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 47833 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 47833 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 2;
  {instr->encoding = (ENC_ST1W_Z_P_BZ_D_64_SCALED); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BZ_D_64_SCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE500A000) {
  decode_fields32(ENC_ST1W_Z_P_BZ_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  ctx->offs_size = 0x40;
  ctx->offs_unsigned = 
# 47851 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                      1
# 47851 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  ctx->scale = 0;
  {instr->encoding = (ENC_ST1W_Z_P_BZ_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_ST1W_Z_P_BZ_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int st2b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE430E000) {
  decode_fields32(ENC_ST2B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st2b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4206000) {
  decode_fields32(ENC_ST2B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st2d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE5B0E000) {
  decode_fields32(ENC_ST2D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st2d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5A06000) {
  decode_fields32(ENC_ST2D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st2h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE4B0E000) {
  decode_fields32(ENC_ST2H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st2h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4A06000) {
  decode_fields32(ENC_ST2H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st2w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE530E000) {
  decode_fields32(ENC_ST2W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st2w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5206000) {
  decode_fields32(ENC_ST2W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->nreg = 2;
  {instr->encoding = (ENC_ST2W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST2W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE450E000) {
  decode_fields32(ENC_ST3B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4406000) {
  decode_fields32(ENC_ST3B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE5D0E000) {
  decode_fields32(ENC_ST3D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5C06000) {
  decode_fields32(ENC_ST3D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE4D0E000) {
  decode_fields32(ENC_ST3H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4C06000) {
  decode_fields32(ENC_ST3H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE550E000) {
  decode_fields32(ENC_ST3W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st3w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5406000) {
  decode_fields32(ENC_ST3W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->nreg = 3;
  {instr->encoding = (ENC_ST3W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST3W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE470E000) {
  decode_fields32(ENC_ST4B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4606000) {
  decode_fields32(ENC_ST4B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE5F0E000) {
  decode_fields32(ENC_ST4D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5E06000) {
  decode_fields32(ENC_ST4D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE4F0E000) {
  decode_fields32(ENC_ST4H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4E06000) {
  decode_fields32(ENC_ST4H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE570E000) {
  decode_fields32(ENC_ST4W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int st4w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5606000) {
  decode_fields32(ENC_ST4W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->nreg = 4;
  {instr->encoding = (ENC_ST4W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_ST4W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1b_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4402000) {
  decode_fields32(ENC_STNT1B_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 8;
  {instr->encoding = (ENC_STNT1B_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_STNT1B_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE4002000) {
  decode_fields32(ENC_STNT1B_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 8;
  {instr->encoding = (ENC_STNT1B_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_STNT1B_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int stnt1b_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE410E000) {
  decode_fields32(ENC_STNT1B_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_STNT1B_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1B_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1b_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4006000) {
  decode_fields32(ENC_STNT1B_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 8;
  {instr->encoding = (ENC_STNT1B_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1B_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1d_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5802000) {
  decode_fields32(ENC_STNT1D_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x40;
  {instr->encoding = (ENC_STNT1D_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_STNT1D_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int stnt1d_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE590E000) {
  decode_fields32(ENC_STNT1D_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_STNT1D_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1D_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1d_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5806000) {
  decode_fields32(ENC_STNT1D_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  {instr->encoding = (ENC_STNT1D_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1D_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1h_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4C02000) {
  decode_fields32(ENC_STNT1H_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x10;
  {instr->encoding = (ENC_STNT1H_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_STNT1H_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE4802000) {
  decode_fields32(ENC_STNT1H_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x10;
  {instr->encoding = (ENC_STNT1H_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_STNT1H_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int stnt1h_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE490E000) {
  decode_fields32(ENC_STNT1H_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_STNT1H_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1H_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1h_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE4806000) {
  decode_fields32(ENC_STNT1H_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x10;
  {instr->encoding = (ENC_STNT1H_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1H_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1w_z_p_ar(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5402000) {
  decode_fields32(ENC_STNT1W_Z_P_AR_S_X32_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->msize = 0x20;
  {instr->encoding = (ENC_STNT1W_Z_P_AR_S_X32_UNSCALED); instr->operation = enc_to_oper(ENC_STNT1W_Z_P_AR_S_X32_UNSCALED); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0E000)==0xE5002000) {
  decode_fields32(ENC_STNT1W_Z_P_AR_D_64_UNSCALED, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x40;
  ctx->msize = 0x20;
  {instr->encoding = (ENC_STNT1W_Z_P_AR_D_64_UNSCALED); instr->operation = enc_to_oper(ENC_STNT1W_Z_P_AR_D_64_UNSCALED); rc = 0; };
 }
 return rc;
}


int stnt1w_z_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0E000)==0xE510E000) {
  decode_fields32(ENC_STNT1W_Z_P_BI_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  ctx->offset = SignExtend((ctx->imm4),(4));
  {instr->encoding = (ENC_STNT1W_Z_P_BI_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1W_Z_P_BI_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int stnt1w_z_p_br(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0E000)==0xE5006000) {
  decode_fields32(ENC_STNT1W_Z_P_BR_CONTIGUOUS, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->Rm==0x1f) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->esize = 0x20;
  {instr->encoding = (ENC_STNT1W_Z_P_BR_CONTIGUOUS); instr->operation = enc_to_oper(ENC_STNT1W_Z_P_BR_CONTIGUOUS); rc = 0; };
 }
 return rc;
}


int str_p_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E010)==0xE5800000) {
  decode_fields32(ENC_STR_P_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Pt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->imm = SignExtend((((ctx->imm9h<<3)|ctx->imm9l)),(9));
  {instr->encoding = (ENC_STR_P_BI_); instr->operation = enc_to_oper(ENC_STR_P_BI_); rc = 0; };
 }
 return rc;
}


int str_z_bi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFC0E000)==0xE5804000) {
  decode_fields32(ENC_STR_Z_BI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->t = (unsigned int)(ctx->Zt);
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->imm = SignExtend((((ctx->imm9h<<3)|ctx->imm9l)),(9));
  {instr->encoding = (ENC_STR_Z_BI_); instr->operation = enc_to_oper(ENC_STR_Z_BI_); rc = 0; };
 }
 return rc;
}


int sub_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4010000) {
  decode_fields32(ENC_SUB_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SUB_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SUB_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sub_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2521C000) {
  decode_fields32(ENC_SUB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (unsigned int)(ctx->imm8);
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }
  {instr->encoding = (ENC_SUB_Z_ZI_); instr->operation = enc_to_oper(ENC_SUB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sub_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4200400) {
  decode_fields32(ENC_SUB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SUB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SUB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int subhnb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45207000) {
  decode_fields32(ENC_SUBHNB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SUBHNB_Z_ZZ_); instr->operation = enc_to_oper(ENC_SUBHNB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int subhnt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45207400) {
  decode_fields32(ENC_SUBHNT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_SUBHNT_Z_ZZ_); instr->operation = enc_to_oper(ENC_SUBHNT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int subr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4030000) {
  decode_fields32(ENC_SUBR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SUBR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SUBR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int subr_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2523C000) {
  decode_fields32(ENC_SUBR_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (unsigned int)(ctx->imm8);
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }
  {instr->encoding = (ENC_SUBR_Z_ZI_); instr->operation = enc_to_oper(ENC_SUBR_Z_ZI_); rc = 0; };
 }
 return rc;
}


int sudot_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x44A01C00) {
  decode_fields32(ENC_SUDOT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_SUDOT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_SUDOT_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int sunpkhi_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5313800) {
  decode_fields32(ENC_SUNPKHI_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 48967 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 48967 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->hi = 
# 48968 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
           1
# 48968 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
               ;
  {instr->encoding = (ENC_SUNPKHI_Z_Z_); instr->operation = enc_to_oper(ENC_SUNPKHI_Z_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FFC00)==0x5303800) {
  decode_fields32(ENC_SUNPKLO_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 48984 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 48984 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->hi = 
# 48985 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
           0
# 48985 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                ;
  {instr->encoding = (ENC_SUNPKLO_Z_Z_); instr->operation = enc_to_oper(ENC_SUNPKLO_Z_Z_); rc = 0; };
 }
 return rc;
}


int suqadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x441C8000) {
  decode_fields32(ENC_SUQADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_SUQADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_SUQADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int sxtb_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x410A000) {
  decode_fields32(ENC_SXTB_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->s_esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 49030 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 49030 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SXTB_Z_P_Z_); instr->operation = enc_to_oper(ENC_SXTB_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x412A000) {
  decode_fields32(ENC_SXTH_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if((ctx->size&2)!=2) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->s_esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 49048 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 49048 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SXTH_Z_P_Z_); instr->operation = enc_to_oper(ENC_SXTH_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x414A000) {
  decode_fields32(ENC_SXTW_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->s_esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 49066 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 49066 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  {instr->encoding = (ENC_SXTW_Z_P_Z_); instr->operation = enc_to_oper(ENC_SXTW_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int tbl_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5203000) {
  decode_fields32(ENC_TBL_Z_ZZ_1, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->double_table = 
# 49087 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 49087 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  {instr->encoding = (ENC_TBL_Z_ZZ_1); instr->operation = enc_to_oper(ENC_TBL_Z_ZZ_1); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20FC00)==0x5202800) {
  decode_fields32(ENC_TBL_Z_ZZ_2, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->double_table = 
# 49101 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     1
# 49101 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  {instr->encoding = (ENC_TBL_Z_ZZ_2); instr->operation = enc_to_oper(ENC_TBL_Z_ZZ_2); rc = 0; };
 }
 return rc;
}


int tbx_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5202C00) {
  decode_fields32(ENC_TBX_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_TBX_Z_ZZ_); instr->operation = enc_to_oper(ENC_TBX_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int trn1_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30FE10)==0x5205000) {
  decode_fields32(ENC_TRN1_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->part = 0;
  {instr->encoding = (ENC_TRN1_P_PP_); instr->operation = enc_to_oper(ENC_TRN1_P_PP_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF30FE10)==0x5205400) {
  decode_fields32(ENC_TRN2_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->part = 1;
  {instr->encoding = (ENC_TRN2_P_PP_); instr->operation = enc_to_oper(ENC_TRN2_P_PP_); rc = 0; };
 }
 return rc;
}


int trn1_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5207000) {
  decode_fields32(ENC_TRN1_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 0;
  {instr->encoding = (ENC_TRN1_Z_ZZ_); instr->operation = enc_to_oper(ENC_TRN1_Z_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x5A01800) {
  decode_fields32(ENC_TRN1_Z_ZZ_Q, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->esize = 0x80;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 0;
  {instr->encoding = (ENC_TRN1_Z_ZZ_Q); instr->operation = enc_to_oper(ENC_TRN1_Z_ZZ_Q); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20FC00)==0x5207400) {
  decode_fields32(ENC_TRN2_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 1;
  {instr->encoding = (ENC_TRN2_Z_ZZ_); instr->operation = enc_to_oper(ENC_TRN2_Z_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x5A01C00) {
  decode_fields32(ENC_TRN2_Z_ZZ_Q, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->esize = 0x80;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 1;
  {instr->encoding = (ENC_TRN2_Z_ZZ_Q); instr->operation = enc_to_oper(ENC_TRN2_Z_ZZ_Q); rc = 0; };
 }
 return rc;
}


int uaba_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500FC00) {
  decode_fields32(ENC_UABA_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->unsigned_ = 
# 49240 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49240 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UABA_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UABA_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int uabalb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500C800) {
  decode_fields32(ENC_UABALB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UABALB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UABALB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int uabalt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500CC00) {
  decode_fields32(ENC_UABALT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UABALT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UABALT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int uabd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40D0000) {
  decode_fields32(ENC_UABD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 49307 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49307 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UABD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UABD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uabdlb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45003800) {
  decode_fields32(ENC_UABDLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UABDLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_UABDLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uabdlt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45003C00) {
  decode_fields32(ENC_UABDLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UABDLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_UABDLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uadalp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4405A000) {
  decode_fields32(ENC_UADALP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UADALP_Z_P_Z_); instr->operation = enc_to_oper(ENC_UADALP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int uaddlb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45000800) {
  decode_fields32(ENC_UADDLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 0;
  ctx->sel2 = 0;
  ctx->unsigned_ = 
# 49402 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49402 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UADDLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_UADDLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uaddlt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45000C00) {
  decode_fields32(ENC_UADDLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 1;
  ctx->sel2 = 1;
  ctx->unsigned_ = 
# 49428 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49428 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UADDLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_UADDLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uaddv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4012000) {
  decode_fields32(ENC_UADDV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  {instr->encoding = (ENC_UADDV_R_P_Z_); instr->operation = enc_to_oper(ENC_UADDV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int uaddwb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45004800) {
  decode_fields32(ENC_UADDWB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UADDWB_Z_ZZ_); instr->operation = enc_to_oper(ENC_UADDWB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uaddwt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45004C00) {
  decode_fields32(ENC_UADDWT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UADDWT_Z_ZZ_); instr->operation = enc_to_oper(ENC_UADDWT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int ucvtf_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFE000)==0x6553A000) {
  decode_fields32(ENC_UCVTF_Z_P_Z_H2FP16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x10;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 49517 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49517 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_Z_P_Z_H2FP16); instr->operation = enc_to_oper(ENC_UCVTF_Z_P_Z_H2FP16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x6555A000) {
  decode_fields32(ENC_UCVTF_Z_P_Z_W2FP16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 49534 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49534 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_Z_P_Z_W2FP16); instr->operation = enc_to_oper(ENC_UCVTF_Z_P_Z_W2FP16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x6595A000) {
  decode_fields32(ENC_UCVTF_Z_P_Z_W2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 49551 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49551 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_Z_P_Z_W2S); instr->operation = enc_to_oper(ENC_UCVTF_Z_P_Z_W2S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D1A000) {
  decode_fields32(ENC_UCVTF_Z_P_Z_W2D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x20;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 49568 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49568 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_Z_P_Z_W2D); instr->operation = enc_to_oper(ENC_UCVTF_Z_P_Z_W2D); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x6557A000) {
  decode_fields32(ENC_UCVTF_Z_P_Z_X2FP16, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x10;
  ctx->unsigned_ = 
# 49585 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49585 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_Z_P_Z_X2FP16); instr->operation = enc_to_oper(ENC_UCVTF_Z_P_Z_X2FP16); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D5A000) {
  decode_fields32(ENC_UCVTF_Z_P_Z_X2S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x20;
  ctx->unsigned_ = 
# 49602 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49602 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_Z_P_Z_X2S); instr->operation = enc_to_oper(ENC_UCVTF_Z_P_Z_X2S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFFFE000)==0x65D7A000) {
  decode_fields32(ENC_UCVTF_Z_P_Z_X2D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->s_esize = 0x40;
  ctx->d_esize = 0x40;
  ctx->unsigned_ = 
# 49619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49619 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->rounding = FPRoundingMode(ctx->FPCR);
  {instr->encoding = (ENC_UCVTF_Z_P_Z_X2D); instr->operation = enc_to_oper(ENC_UCVTF_Z_P_Z_X2D); rc = 0; };
 }
 return rc;
}


int udiv_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4150000) {
  decode_fields32(ENC_UDIV_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 49644 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49644 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UDIV_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UDIV_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int udivr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4170000) {
  decode_fields32(ENC_UDIVR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 49668 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49668 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UDIVR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UDIVR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int udot_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44000400) {
  decode_fields32(ENC_UDOT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(!(ctx->size&2)) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UDOT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UDOT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int udot_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x44A00400) {
  decode_fields32(ENC_UDOT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UDOT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_UDOT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x44E00400) {
  decode_fields32(ENC_UDOT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->index = (unsigned int)(ctx->i1);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UDOT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_UDOT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int uhadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44118000) {
  decode_fields32(ENC_UHADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_UHADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UHADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uhsub_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44138000) {
  decode_fields32(ENC_UHSUB_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_UHSUB_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UHSUB_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uhsubr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44178000) {
  decode_fields32(ENC_UHSUBR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_UHSUBR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UHSUBR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int umax_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4090000) {
  decode_fields32(ENC_UMAX_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 49807 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49807 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UMAX_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UMAX_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int umax_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x2529C000) {
  decode_fields32(ENC_UMAX_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 49826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->imm = (unsigned int)(ctx->imm8);
  {instr->encoding = (ENC_UMAX_Z_ZI_); instr->operation = enc_to_oper(ENC_UMAX_Z_ZI_); rc = 0; };
 }
 return rc;
}


int umaxp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4415A000) {
  decode_fields32(ENC_UMAXP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_UMAXP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UMAXP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int umaxv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4092000) {
  decode_fields32(ENC_UMAXV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  ctx->unsigned_ = 
# 49868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UMAXV_R_P_Z_); instr->operation = enc_to_oper(ENC_UMAXV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int umin_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40B0000) {
  decode_fields32(ENC_UMIN_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 49889 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49889 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UMIN_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UMIN_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int umin_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x252BC000) {
  decode_fields32(ENC_UMIN_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 49908 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49908 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->imm = (unsigned int)(ctx->imm8);
  {instr->encoding = (ENC_UMIN_Z_ZI_); instr->operation = enc_to_oper(ENC_UMIN_Z_ZI_); rc = 0; };
 }
 return rc;
}


int uminp_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4417A000) {
  decode_fields32(ENC_UMINP_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_UMINP_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UMINP_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uminv_r_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40B2000) {
  decode_fields32(ENC_UMINV_R_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Vd);
  ctx->unsigned_ = 
# 49950 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 49950 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UMINV_R_P_Z_); instr->operation = enc_to_oper(ENC_UMINV_R_P_Z_); rc = 0; };
 }
 return rc;
}


int umlalb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44004800) {
  decode_fields32(ENC_UMLALB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UMLALB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UMLALB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int umlalb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A09000) {
  decode_fields32(ENC_UMLALB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_UMLALB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_UMLALB_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E09000) {
  decode_fields32(ENC_UMLALB_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_UMLALB_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_UMLALB_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int umlalt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44004C00) {
  decode_fields32(ENC_UMLALT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UMLALT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UMLALT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int umlalt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A09400) {
  decode_fields32(ENC_UMLALT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_UMLALT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_UMLALT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E09400) {
  decode_fields32(ENC_UMLALT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_UMLALT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_UMLALT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int umlslb_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44005800) {
  decode_fields32(ENC_UMLSLB_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UMLSLB_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UMLSLB_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int umlslb_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0B000) {
  decode_fields32(ENC_UMLSLB_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_UMLSLB_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_UMLSLB_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0B000) {
  decode_fields32(ENC_UMLSLB_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 0;
  {instr->encoding = (ENC_UMLSLB_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_UMLSLB_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int umlslt_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x44005C00) {
  decode_fields32(ENC_UMLSLT_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_UMLSLT_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UMLSLT_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int umlslt_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0B400) {
  decode_fields32(ENC_UMLSLT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_UMLSLT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_UMLSLT_Z_ZZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0B400) {
  decode_fields32(ENC_UMLSLT_Z_ZZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->sel = 1;
  {instr->encoding = (ENC_UMLSLT_Z_ZZZI_D); instr->operation = enc_to_oper(ENC_UMLSLT_Z_ZZZI_D); rc = 0; };
 }
 return rc;
}


int ummla_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x45C09800) {
  decode_fields32(ENC_UMMLA_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_unsigned = 
# 50210 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     1
# 50210 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  ctx->op2_unsigned = 
# 50211 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     1
# 50211 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  {instr->encoding = (ENC_UMMLA_Z_ZZZ_); instr->operation = enc_to_oper(ENC_UMMLA_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int umulh_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4130000) {
  decode_fields32(ENC_UMULH_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 50232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50232 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UMULH_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UMULH_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int umulh_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4206C00) {
  decode_fields32(ENC_UMULH_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 50253 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50253 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UMULH_Z_ZZ_); instr->operation = enc_to_oper(ENC_UMULH_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int umullb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45007800) {
  decode_fields32(ENC_UMULLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UMULLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_UMULLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int umullb_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0D000) {
  decode_fields32(ENC_UMULLB_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 0;
  {instr->encoding = (ENC_UMULLB_Z_ZZI_S); instr->operation = enc_to_oper(ENC_UMULLB_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0D000) {
  decode_fields32(ENC_UMULLB_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 0;
  {instr->encoding = (ENC_UMULLB_Z_ZZI_D); instr->operation = enc_to_oper(ENC_UMULLB_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int umullt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45007C00) {
  decode_fields32(ENC_UMULLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UMULLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_UMULLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int umullt_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0F400)==0x44A0D400) {
  decode_fields32(ENC_UMULLT_Z_ZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->index = (unsigned int)(((ctx->i3h<<1)|ctx->i3l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 1;
  {instr->encoding = (ENC_UMULLT_Z_ZZI_S); instr->operation = enc_to_oper(ENC_UMULLT_Z_ZZI_S); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0F400)==0x44E0D400) {
  decode_fields32(ENC_UMULLT_Z_ZZI_D, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(((ctx->i2h<<1)|ctx->i2l));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel = 1;
  {instr->encoding = (ENC_UMULLT_Z_ZZI_D); instr->operation = enc_to_oper(ENC_UMULLT_Z_ZZI_D); rc = 0; };
 }
 return rc;
}


int uqadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44198000) {
  decode_fields32(ENC_UQADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 50394 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50394 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UQADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uqadd_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2525C000) {
  decode_fields32(ENC_UQADD_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (unsigned int)(ctx->imm8);
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }
  ctx->unsigned_ = 
# 50420 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50420 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQADD_Z_ZI_); instr->operation = enc_to_oper(ENC_UQADD_Z_ZI_); rc = 0; };
 }
 return rc;
}


int uqadd_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4201400) {
  decode_fields32(ENC_UQADD_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 50441 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50441 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQADD_Z_ZZ_); instr->operation = enc_to_oper(ENC_UQADD_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uqdecb_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x420FC00) {
  decode_fields32(ENC_UQDECB_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50462 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50462 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQDECB_R_RS_UW); instr->operation = enc_to_oper(ENC_UQDECB_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x430FC00) {
  decode_fields32(ENC_UQDECB_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50477 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50477 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQDECB_R_RS_X); instr->operation = enc_to_oper(ENC_UQDECB_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqdecd_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0FC00) {
  decode_fields32(ENC_UQDECD_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50499 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50499 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQDECD_R_RS_UW); instr->operation = enc_to_oper(ENC_UQDECD_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0FC00) {
  decode_fields32(ENC_UQDECD_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50514 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50514 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQDECD_R_RS_X); instr->operation = enc_to_oper(ENC_UQDECD_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqdecd_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0CC00) {
  decode_fields32(ENC_UQDECD_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50536 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50536 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQDECD_Z_ZS_); instr->operation = enc_to_oper(ENC_UQDECD_Z_ZS_); rc = 0; };
 }
 return rc;
}


int uqdech_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460FC00) {
  decode_fields32(ENC_UQDECH_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50557 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQDECH_R_RS_UW); instr->operation = enc_to_oper(ENC_UQDECH_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470FC00) {
  decode_fields32(ENC_UQDECH_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50572 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50572 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQDECH_R_RS_X); instr->operation = enc_to_oper(ENC_UQDECH_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqdech_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460CC00) {
  decode_fields32(ENC_UQDECH_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50594 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50594 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQDECH_Z_ZS_); instr->operation = enc_to_oper(ENC_UQDECH_Z_ZS_); rc = 0; };
 }
 return rc;
}


int uqdecp_r_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252B8800) {
  decode_fields32(ENC_UQDECP_R_P_R_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 50614 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50614 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQDECP_R_P_R_UW); instr->operation = enc_to_oper(ENC_UQDECP_R_P_R_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FFE00)==0x252B8C00) {
  decode_fields32(ENC_UQDECP_R_P_R_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 50628 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50628 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQDECP_R_P_R_X); instr->operation = enc_to_oper(ENC_UQDECP_R_P_R_X); rc = 0; };
 }
 return rc;
}


int uqdecp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x252B8000) {
  decode_fields32(ENC_UQDECP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 50652 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50652 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQDECP_Z_P_Z_); instr->operation = enc_to_oper(ENC_UQDECP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int uqdecw_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0FC00) {
  decode_fields32(ENC_UQDECW_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50673 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50673 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQDECW_R_RS_UW); instr->operation = enc_to_oper(ENC_UQDECW_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0FC00) {
  decode_fields32(ENC_UQDECW_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50688 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQDECW_R_RS_X); instr->operation = enc_to_oper(ENC_UQDECW_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqdecw_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0CC00) {
  decode_fields32(ENC_UQDECW_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50710 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50710 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQDECW_Z_ZS_); instr->operation = enc_to_oper(ENC_UQDECW_Z_ZS_); rc = 0; };
 }
 return rc;
}


int uqincb_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x420F400) {
  decode_fields32(ENC_UQINCB_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50731 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQINCB_R_RS_UW); instr->operation = enc_to_oper(ENC_UQINCB_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x430F400) {
  decode_fields32(ENC_UQINCB_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 8;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50746 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50746 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQINCB_R_RS_X); instr->operation = enc_to_oper(ENC_UQINCB_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqincd_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0F400) {
  decode_fields32(ENC_UQINCD_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50768 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQINCD_R_RS_UW); instr->operation = enc_to_oper(ENC_UQINCD_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4F0F400) {
  decode_fields32(ENC_UQINCD_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50783 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50783 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQINCD_R_RS_X); instr->operation = enc_to_oper(ENC_UQINCD_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqincd_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4E0C400) {
  decode_fields32(ENC_UQINCD_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x40;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50805 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50805 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQINCD_Z_ZS_); instr->operation = enc_to_oper(ENC_UQINCD_Z_ZS_); rc = 0; };
 }
 return rc;
}


int uqinch_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460F400) {
  decode_fields32(ENC_UQINCH_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50826 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQINCH_R_RS_UW); instr->operation = enc_to_oper(ENC_UQINCH_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x470F400) {
  decode_fields32(ENC_UQINCH_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50841 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50841 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQINCH_R_RS_X); instr->operation = enc_to_oper(ENC_UQINCH_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqinch_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x460C400) {
  decode_fields32(ENC_UQINCH_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x10;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50863 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQINCH_Z_ZS_); instr->operation = enc_to_oper(ENC_UQINCH_Z_ZS_); rc = 0; };
 }
 return rc;
}


int uqincp_r_p_r(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x25298800) {
  decode_fields32(ENC_UQINCP_R_P_R_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 50883 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50883 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQINCP_R_P_R_UW); instr->operation = enc_to_oper(ENC_UQINCP_R_P_R_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FFE00)==0x25298C00) {
  decode_fields32(ENC_UQINCP_R_P_R_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->unsigned_ = 
# 50897 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50897 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQINCP_R_P_R_X); instr->operation = enc_to_oper(ENC_UQINCP_R_P_R_X); rc = 0; };
 }
 return rc;
}


int uqincp_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFE00)==0x25298000) {
  decode_fields32(ENC_UQINCP_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->unsigned_ = 
# 50921 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50921 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQINCP_Z_P_Z_); instr->operation = enc_to_oper(ENC_UQINCP_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int uqincw_r_rs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0F400) {
  decode_fields32(ENC_UQINCW_R_RS_UW, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50942 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50942 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x20;
  {instr->encoding = (ENC_UQINCW_R_RS_UW); instr->operation = enc_to_oper(ENC_UQINCW_R_RS_UW); rc = 0; };
 }


 if(((ctx->insword) & 0xFFF0FC00)==0x4B0F400) {
  decode_fields32(ENC_UQINCW_R_RS_X, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Rdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50957 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50957 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->ssize = 0x40;
  {instr->encoding = (ENC_UQINCW_R_RS_X); instr->operation = enc_to_oper(ENC_UQINCW_R_RS_X); rc = 0; };
 }
 return rc;
}


int uqincw_z_zs(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFF0FC00)==0x4A0C400) {
  decode_fields32(ENC_UQINCW_Z_ZS_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->pat = ctx->pattern;
  ctx->imm = (unsigned int)(ctx->imm4)+1;
  ctx->unsigned_ = 
# 50979 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 50979 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQINCW_Z_ZS_); instr->operation = enc_to_oper(ENC_UQINCW_Z_ZS_); rc = 0; };
 }
 return rc;
}


int uqrshl_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x440B8000) {
  decode_fields32(ENC_UQRSHL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_UQRSHL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UQRSHL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uqrshlr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x440F8000) {
  decode_fields32(ENC_UQRSHLR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_UQRSHLR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UQRSHLR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uqrshrnb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45203800) {
  decode_fields32(ENC_UQRSHRNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_UQRSHRNB_Z_ZI_); instr->operation = enc_to_oper(ENC_UQRSHRNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int uqrshrnt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45203C00) {
  decode_fields32(ENC_UQRSHRNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_UQRSHRNT_Z_ZI_); instr->operation = enc_to_oper(ENC_UQRSHRNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int uqshl_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4078000) {
  decode_fields32(ENC_UQSHL_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_UQSHL_Z_P_ZI_); instr->operation = enc_to_oper(ENC_UQSHL_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int uqshl_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44098000) {
  decode_fields32(ENC_UQSHL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_UQSHL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UQSHL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uqshlr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x440D8000) {
  decode_fields32(ENC_UQSHLR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_UQSHLR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UQSHLR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uqshrnb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45203000) {
  decode_fields32(ENC_UQSHRNB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_UQSHRNB_Z_ZI_); instr->operation = enc_to_oper(ENC_UQSHRNB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int uqshrnt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x45203400) {
  decode_fields32(ENC_UQSHRNT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_UQSHRNT_Z_ZI_); instr->operation = enc_to_oper(ENC_UQSHRNT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int uqsub_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x441B8000) {
  decode_fields32(ENC_UQSUB_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 51243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51243 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQSUB_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UQSUB_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uqsub_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FC000)==0x2527C000) {
  decode_fields32(ENC_UQSUB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(((ctx->size<<1)|ctx->sh)==1) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->imm = (unsigned int)(ctx->imm8);
  if(ctx->sh==1) {
   ctx->imm = (ctx->imm) << (8);
  }
  ctx->unsigned_ = 
# 51269 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51269 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQSUB_Z_ZI_); instr->operation = enc_to_oper(ENC_UQSUB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int uqsub_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4201C00) {
  decode_fields32(ENC_UQSUB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 51290 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51290 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQSUB_Z_ZZ_); instr->operation = enc_to_oper(ENC_UQSUB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uqsubr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x441F8000) {
  decode_fields32(ENC_UQSUBR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->unsigned_ = 
# 51311 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51311 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UQSUBR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_UQSUBR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int uqxtnb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA7FC00)==0x45204800) {
  decode_fields32(ENC_UQXTNB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(ctx->tsize==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->tsize==2) {
   ctx->esize = 0x20;
  }
  else if(ctx->tsize==4) {
   ctx->esize = 0x40;
  }
  else {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UQXTNB_Z_ZZ_); instr->operation = enc_to_oper(ENC_UQXTNB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uqxtnt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA7FC00)==0x45204C00) {
  decode_fields32(ENC_UQXTNT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(ctx->tsize==1) {
   ctx->esize = 0x10;
  }
  else if(ctx->tsize==2) {
   ctx->esize = 0x20;
  }
  else if(ctx->tsize==4) {
   ctx->esize = 0x40;
  }
  else {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_UQXTNT_Z_ZZ_); instr->operation = enc_to_oper(ENC_UQXTNT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int urecpe_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4400A000) {
  decode_fields32(ENC_URECPE_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size!=2) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_URECPE_Z_P_Z_); instr->operation = enc_to_oper(ENC_URECPE_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int urhadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44158000) {
  decode_fields32(ENC_URHADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_URHADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_URHADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int urshl_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44038000) {
  decode_fields32(ENC_URSHL_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_URSHL_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_URSHL_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int urshlr_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x44078000) {
  decode_fields32(ENC_URSHLR_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  {instr->encoding = (ENC_URSHLR_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_URSHLR_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int urshr_z_p_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x40D8000) {
  decode_fields32(ENC_URSHR_Z_P_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_URSHR_Z_P_ZI_); instr->operation = enc_to_oper(ENC_URSHR_Z_P_ZI_); rc = 0; };
 }
 return rc;
}


int ursqrte_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x4401A000) {
  decode_fields32(ENC_URSQRTE_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size!=2) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_URSQRTE_Z_P_Z_); instr->operation = enc_to_oper(ENC_URSQRTE_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int ursra_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500EC00) {
  decode_fields32(ENC_URSRA_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_URSRA_Z_ZI_); instr->operation = enc_to_oper(ENC_URSRA_Z_ZI_); rc = 0; };
 }
 return rc;
}


int usdot_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x44807800) {
  decode_fields32(ENC_USDOT_Z_ZZZ_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_USDOT_Z_ZZZ_S); instr->operation = enc_to_oper(ENC_USDOT_Z_ZZZ_S); rc = 0; };
 }
 return rc;
}


int usdot_z_zzzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x44A01800) {
  decode_fields32(ENC_USDOT_Z_ZZZI_S, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->esize = 0x20;
  ctx->index = (unsigned int)(ctx->i2);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  {instr->encoding = (ENC_USDOT_Z_ZZZI_S); instr->operation = enc_to_oper(ENC_USDOT_Z_ZZZI_S); rc = 0; };
 }
 return rc;
}


int ushllb_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4500A800) {
  decode_fields32(ENC_USHLLB_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_USHLLB_Z_ZI_); instr->operation = enc_to_oper(ENC_USHLLB_Z_ZI_); rc = 0; };
 }
 return rc;
}


int ushllt_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFA0FC00)==0x4500AC00) {
  decode_fields32(ENC_USHLLT_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&6)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&4)==4) {
   ctx->esize = 0x20;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->shift = (unsigned int)(((ctx->tsize<<3)|ctx->imm3))-ctx->esize;
  {instr->encoding = (ENC_USHLLT_Z_ZI_); instr->operation = enc_to_oper(ENC_USHLLT_Z_ZI_); rc = 0; };
 }
 return rc;
}


int usmmla_z_zzz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFE0FC00)==0x45809800) {
  decode_fields32(ENC_USMMLA_Z_ZZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35)) || !(ctx->features1 & ((uint64_t)1<<19))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->op1_unsigned = 
# 51674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     1
# 51674 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                         ;
  ctx->op2_unsigned = 
# 51675 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                     0
# 51675 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                          ;
  {instr->encoding = (ENC_USMMLA_Z_ZZZ_); instr->operation = enc_to_oper(ENC_USMMLA_Z_ZZZ_); rc = 0; };
 }
 return rc;
}


int usqadd_z_p_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x441D8000) {
  decode_fields32(ENC_USQADD_Z_P_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->m = (unsigned int)(ctx->Zm);
  {instr->encoding = (ENC_USQADD_Z_P_ZZ_); instr->operation = enc_to_oper(ENC_USQADD_Z_P_ZZ_); rc = 0; };
 }
 return rc;
}


int usra_z_zi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4500E400) {
  decode_fields32(ENC_USRA_Z_ZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->da = (unsigned int)(ctx->Zda);
  ctx->shift = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_USRA_Z_ZI_); instr->operation = enc_to_oper(ENC_USRA_Z_ZI_); rc = 0; };
 }
 return rc;
}


int usublb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45001800) {
  decode_fields32(ENC_USUBLB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 0;
  ctx->sel2 = 0;
  ctx->unsigned_ = 
# 51756 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51756 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_USUBLB_Z_ZZ_); instr->operation = enc_to_oper(ENC_USUBLB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int usublt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45001C00) {
  decode_fields32(ENC_USUBLT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->sel1 = 1;
  ctx->sel2 = 1;
  ctx->unsigned_ = 
# 51782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51782 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_USUBLT_Z_ZZ_); instr->operation = enc_to_oper(ENC_USUBLT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int usubwb_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45005800) {
  decode_fields32(ENC_USUBWB_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_USUBWB_Z_ZZ_); instr->operation = enc_to_oper(ENC_USUBWB_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int usubwt_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x45005C00) {
  decode_fields32(ENC_USUBWT_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  {instr->encoding = (ENC_USUBWT_Z_ZZ_); instr->operation = enc_to_oper(ENC_USUBWT_Z_ZZ_); rc = 0; };
 }
 return rc;
}


int uunpkhi_z_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FFC00)==0x5333800) {
  decode_fields32(ENC_UUNPKHI_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 51851 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51851 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->hi = 
# 51852 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
           1
# 51852 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
               ;
  {instr->encoding = (ENC_UUNPKHI_Z_Z_); instr->operation = enc_to_oper(ENC_UUNPKHI_Z_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FFC00)==0x5323800) {
  decode_fields32(ENC_UUNPKLO_Z_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 51868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51868 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->hi = 
# 51869 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
           0
# 51869 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                ;
  {instr->encoding = (ENC_UUNPKLO_Z_Z_); instr->operation = enc_to_oper(ENC_UUNPKLO_Z_Z_); rc = 0; };
 }
 return rc;
}


int uxtb_z_p_z(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF3FE000)==0x411A000) {
  decode_fields32(ENC_UXTB_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size==0) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->s_esize = 8;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 51894 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51894 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UXTB_Z_P_Z_); instr->operation = enc_to_oper(ENC_UXTB_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x413A000) {
  decode_fields32(ENC_UXTH_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if((ctx->size&2)!=2) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->s_esize = 0x10;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 51912 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51912 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UXTH_Z_P_Z_); instr->operation = enc_to_oper(ENC_UXTH_Z_P_Z_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF3FE000)==0x415A000) {
  decode_fields32(ENC_UXTW_Z_P_Z_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  if(ctx->size!=3) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->s_esize = 0x20;
  ctx->g = (unsigned int)(ctx->Pg);
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->unsigned_ = 
# 51930 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 51930 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  {instr->encoding = (ENC_UXTW_Z_P_Z_); instr->operation = enc_to_oper(ENC_UXTW_Z_P_Z_); rc = 0; };
 }
 return rc;
}


int uzp1_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30FE10)==0x5204800) {
  decode_fields32(ENC_UZP1_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->part = 0;
  {instr->encoding = (ENC_UZP1_P_PP_); instr->operation = enc_to_oper(ENC_UZP1_P_PP_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF30FE10)==0x5204C00) {
  decode_fields32(ENC_UZP2_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->part = 1;
  {instr->encoding = (ENC_UZP2_P_PP_); instr->operation = enc_to_oper(ENC_UZP2_P_PP_); rc = 0; };
 }
 return rc;
}


int uzp1_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5206800) {
  decode_fields32(ENC_UZP1_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 0;
  {instr->encoding = (ENC_UZP1_Z_ZZ_); instr->operation = enc_to_oper(ENC_UZP1_Z_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x5A00800) {
  decode_fields32(ENC_UZP1_Z_ZZ_Q, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->esize = 0x80;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 0;
  {instr->encoding = (ENC_UZP1_Z_ZZ_Q); instr->operation = enc_to_oper(ENC_UZP1_Z_ZZ_Q); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20FC00)==0x5206C00) {
  decode_fields32(ENC_UZP2_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 1;
  {instr->encoding = (ENC_UZP2_Z_ZZ_); instr->operation = enc_to_oper(ENC_UZP2_Z_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x5A00C00) {
  decode_fields32(ENC_UZP2_Z_ZZ_Q, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->esize = 0x80;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 1;
  {instr->encoding = (ENC_UZP2_Z_ZZ_Q); instr->operation = enc_to_oper(ENC_UZP2_Z_ZZ_Q); rc = 0; };
 }
 return rc;
}


int whilege_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200000) {
  decode_fields32(ENC_WHILEGE_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52050 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 52050 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->op = Cmp_GE;
  {instr->encoding = (ENC_WHILEGE_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILEGE_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilegt_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200010) {
  decode_fields32(ENC_WHILEGT_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52073 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 52073 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->op = Cmp_GT;
  {instr->encoding = (ENC_WHILEGT_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILEGT_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilehi_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200810) {
  decode_fields32(ENC_WHILEHI_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52096 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 52096 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->op = Cmp_GT;
  {instr->encoding = (ENC_WHILEHI_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILEHI_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilehs_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200800) {
  decode_fields32(ENC_WHILEHS_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52119 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 52119 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->op = Cmp_GE;
  {instr->encoding = (ENC_WHILEHS_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILEHS_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilele_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200410) {
  decode_fields32(ENC_WHILELE_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52142 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 52142 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->op = Cmp_LE;
  {instr->encoding = (ENC_WHILELE_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILELE_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilelo_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200C00) {
  decode_fields32(ENC_WHILELO_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52165 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 52165 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->op = Cmp_LT;
  {instr->encoding = (ENC_WHILELO_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILELO_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilels_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200C10) {
  decode_fields32(ENC_WHILELS_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52188 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  1
# 52188 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                      ;
  ctx->op = Cmp_LE;
  {instr->encoding = (ENC_WHILELS_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILELS_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilelt_p_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20EC10)==0x25200400) {
  decode_fields32(ENC_WHILELT_P_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->rsize = (0x20) << ((unsigned int)(ctx->sf));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->unsigned_ = 
# 52211 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c" 3 4
                  0
# 52211 "project/radare2/libr/asm/arch/arm/v35arm64/arch-arm64/disassembler/decode2.c"
                       ;
  ctx->op = Cmp_LT;
  {instr->encoding = (ENC_WHILELT_P_P_RR_); instr->operation = enc_to_oper(ENC_WHILELT_P_P_RR_); rc = 0; };
 }
 return rc;
}


int whilerw_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC10)==0x25203010) {
  decode_fields32(ENC_WHILERW_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  {instr->encoding = (ENC_WHILERW_P_RR_); instr->operation = enc_to_oper(ENC_WHILERW_P_RR_); rc = 0; };
 }
 return rc;
}


int whilewr_p_rr(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC10)==0x25203000) {
  decode_fields32(ENC_WHILEWR_P_RR_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Rn);
  ctx->m = (unsigned int)(ctx->Rm);
  ctx->d = (unsigned int)(ctx->Pd);
  {instr->encoding = (ENC_WHILEWR_P_RR_); instr->operation = enc_to_oper(ENC_WHILEWR_P_RR_); rc = 0; };
 }
 return rc;
}


int wrffr_f_p(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFFFFFE1F)==0x25289000) {
  decode_fields32(ENC_WRFFR_F_P_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->n = (unsigned int)(ctx->Pn);
  {instr->encoding = (ENC_WRFFR_F_P_); instr->operation = enc_to_oper(ENC_WRFFR_F_P_); rc = 0; };
 }
 return rc;
}


int xar_z_zzi(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x4203400) {
  decode_fields32(ENC_XAR_Z_ZZI_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<36))) {
   { return -4; };
  }
  ctx->tsize = ((ctx->tszh<<2)|ctx->tszl);
  if(!ctx->tsize) {
   { return -4; };
  }
  else if(ctx->tsize==1) {
   ctx->esize = 8;
  }
  else if((ctx->tsize&14)==2) {
   ctx->esize = 0x10;
  }
  else if((ctx->tsize&12)==4) {
   ctx->esize = 0x20;
  }
  else if((ctx->tsize&8)==8) {
   ctx->esize = 0x40;
  }
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->dn = (unsigned int)(ctx->Zdn);
  ctx->rot = ((2) * (ctx->esize))-(unsigned int)(((ctx->tsize<<3)|ctx->imm3));
  {instr->encoding = (ENC_XAR_Z_ZZI_); instr->operation = enc_to_oper(ENC_XAR_Z_ZZI_); rc = 0; };
 }
 return rc;
}


int zip1_p_pp(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF30FE10)==0x5204400) {
  decode_fields32(ENC_ZIP2_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->part = 1;
  {instr->encoding = (ENC_ZIP2_P_PP_); instr->operation = enc_to_oper(ENC_ZIP2_P_PP_); rc = 0; };
 }


 if(((ctx->insword) & 0xFF30FE10)==0x5204000) {
  decode_fields32(ENC_ZIP1_P_PP_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Pn);
  ctx->m = (unsigned int)(ctx->Pm);
  ctx->d = (unsigned int)(ctx->Pd);
  ctx->part = 0;
  {instr->encoding = (ENC_ZIP1_P_PP_); instr->operation = enc_to_oper(ENC_ZIP1_P_PP_); rc = 0; };
 }
 return rc;
}


int zip1_z_zz(context *ctx, Instruction *instr)
{
 int rc = -2;


 if(((ctx->insword) & 0xFF20FC00)==0x5206400) {
  decode_fields32(ENC_ZIP2_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 1;
  {instr->encoding = (ENC_ZIP2_Z_ZZ_); instr->operation = enc_to_oper(ENC_ZIP2_Z_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x5A00400) {
  decode_fields32(ENC_ZIP2_Z_ZZ_Q, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->esize = 0x80;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 1;
  {instr->encoding = (ENC_ZIP2_Z_ZZ_Q); instr->operation = enc_to_oper(ENC_ZIP2_Z_ZZ_Q); rc = 0; };
 }


 if(((ctx->insword) & 0xFF20FC00)==0x5206000) {
  decode_fields32(ENC_ZIP1_Z_ZZ_, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<35))) {
   { return -4; };
  }
  ctx->esize = (8) << ((unsigned int)(ctx->size));
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 0;
  {instr->encoding = (ENC_ZIP1_Z_ZZ_); instr->operation = enc_to_oper(ENC_ZIP1_Z_ZZ_); rc = 0; };
 }


 if(((ctx->insword) & 0xFFE0FC00)==0x5A00000) {
  decode_fields32(ENC_ZIP1_Z_ZZ_Q, ctx, instr);
  if(!(ctx->features1 & ((uint64_t)1<<43))) {
   { return -4; };
  }
  ctx->esize = 0x80;
  ctx->n = (unsigned int)(ctx->Zn);
  ctx->m = (unsigned int)(ctx->Zm);
  ctx->d = (unsigned int)(ctx->Zd);
  ctx->part = 0;
  {instr->encoding = (ENC_ZIP1_Z_ZZ_Q); instr->operation = enc_to_oper(ENC_ZIP1_Z_ZZ_Q); rc = 0; };
 }
 return rc;
}
